{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,0 @@\n-    jdk.incubator.foreign \\\n","filename":"make\/conf\/docs-modules.conf","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-    jdk.incubator.foreign \\\n","filename":"make\/conf\/module-loader-map.conf","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -206,0 +206,37 @@\n+\n+################################################################################\n+# Create system lookup\n+\n+ifeq ($(call isTargetOs, linux), true)\n+\n+  $(eval $(call SetupJdkLibrary, BUILD_SYSLOOKUPLIB, \\\n+      NAME := syslookup, \\\n+      CFLAGS := $(CFLAGS_JDKLIB), \\\n+      CXXFLAGS := $(CXXFLAGS_JDKLIB), \\\n+      LDFLAGS := $(LDFLAGS_JDKLIB) -Wl$(COMMA)--no-as-needed, \\\n+      LIBS := $(LIBCXX) -lc -lm -ldl, \\\n+  ))\n+\n+else ifeq ($(call isTargetOs, windows), false)\n+\n+  $(eval $(call SetupJdkLibrary, BUILD_SYSLOOKUPLIB, \\\n+      NAME := syslookup, \\\n+      CFLAGS := $(CFLAGS_JDKLIB), \\\n+      CXXFLAGS := $(CXXFLAGS_JDKLIB), \\\n+      LDFLAGS := $(LDFLAGS_JDKLIB), \\\n+      LIBS := $(LIBCXX), \\\n+  ))\n+\n+else # windows\n+\n+  $(eval $(call SetupJdkLibrary, BUILD_SYSLOOKUPLIB, \\\n+      NAME := WinFallbackLookup, \\\n+      CFLAGS := $(CFLAGS_JDKLIB), \\\n+      CXXFLAGS := $(CXXFLAGS_JDKLIB), \\\n+      LDFLAGS := $(LDFLAGS_JDKLIB), \\\n+      LIBS := $(LIBCXX), \\\n+  ))\n+\n+endif\n+\n+TARGETS += $(BUILD_SYSLOOKUPLIB)\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1,62 +0,0 @@\n-#\n-# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-include LibCommon.gmk\n-\n-ifeq ($(call isTargetOs, linux), true)\n-\n-  $(eval $(call SetupJdkLibrary, BUILD_SYSLOOKUPLIB, \\\n-      NAME := syslookup, \\\n-      CFLAGS := $(CFLAGS_JDKLIB), \\\n-      CXXFLAGS := $(CXXFLAGS_JDKLIB), \\\n-      LDFLAGS := $(LDFLAGS_JDKLIB) -Wl$(COMMA)--no-as-needed, \\\n-      LIBS := $(LIBCXX) -lc -lm -ldl, \\\n-  ))\n-\n-else ifeq ($(call isTargetOs, windows), false)\n-\n-  $(eval $(call SetupJdkLibrary, BUILD_SYSLOOKUPLIB, \\\n-      NAME := syslookup, \\\n-      CFLAGS := $(CFLAGS_JDKLIB), \\\n-      CXXFLAGS := $(CXXFLAGS_JDKLIB), \\\n-      LDFLAGS := $(LDFLAGS_JDKLIB), \\\n-      LIBS := $(LIBCXX), \\\n-  ))\n-\n-else # windows\n-\n-  $(eval $(call SetupJdkLibrary, BUILD_SYSLOOKUPLIB, \\\n-      NAME := WinFallbackLookup, \\\n-      CFLAGS := $(CFLAGS_JDKLIB), \\\n-      CXXFLAGS := $(CXXFLAGS_JDKLIB), \\\n-      LDFLAGS := $(LDFLAGS_JDKLIB), \\\n-      LIBS := $(LIBCXX), \\\n-  ))\n-\n-endif\n-\n-TARGETS += $(BUILD_SYSLOOKUPLIB)\n-\n-################################################################################\n","filename":"make\/modules\/jdk.incubator.foreign\/Lib.gmk","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-    DISABLED_WARNINGS := processing rawtypes cast serial, \\\n+    DISABLED_WARNINGS := processing rawtypes cast serial preview, \\\n@@ -97,1 +97,1 @@\n-    JAVAC_FLAGS := --add-exports java.base\/sun.security.util=ALL-UNNAMED, \\\n+    JAVAC_FLAGS := --add-exports java.base\/sun.security.util=ALL-UNNAMED --enable-preview, \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -227,0 +227,1 @@\n+      holder->is_in_package(\"jdk\/internal\/foreign\") || holder->is_in_package(\"java\/lang\/foreign\") ||\n@@ -228,1 +229,0 @@\n-      holder->is_in_package(\"jdk\/internal\/foreign\") || holder->is_in_package(\"jdk\/incubator\/foreign\") ||\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,1 +158,2 @@\n-#define PKG \"Ljdk\/internal\/misc\/\"\n+#define PKG_MISC \"Ljdk\/internal\/misc\/\"\n+#define PKG_FOREIGN \"Ljava\/lang\/foreign\/\"\n@@ -161,2 +162,2 @@\n-#define SCOPE PKG MEMACCESS \"$Scope;\"\n-#define SCOPED_ERR PKG MEMACCESS \"$Scope$ScopedAccessError;\"\n+#define SCOPE PKG_FOREIGN \"ResourceScope;\"\n+#define SCOPED_ERR PKG_MISC MEMACCESS \"$ScopedAccessError;\"\n@@ -174,1 +175,2 @@\n-#undef PKG\n+#undef PKG_MISC\n+#undef PKG_FOREIGN\n@@ -177,1 +179,1 @@\n-#undef SCOPED_EXC\n+#undef SCOPED_ERR\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n@@ -49,0 +52,1 @@\n+import java.util.Optional;\n@@ -58,0 +62,1 @@\n+import jdk.internal.foreign.ResourceScopeImpl;\n@@ -2448,0 +2453,20 @@\n+    \/**\n+     * Finds a native library symbol with the given name that is associated\n+     * with this classloader.\n+     *\n+     * @param name the symbol name.\n+     * @return the symbol (if any).\n+     * @throws NullPointerException if name is null.\n+     *\/\n+    public final Optional<NativeSymbol> findNative(String name) {\n+        Objects.requireNonNull(name);\n+\n+        MemoryAddress addr = MemoryAddress.ofLong(findNative(this, name));\n+        return addr == MemoryAddress.NULL? Optional.empty()\n+                : Optional.of(NativeSymbol.ofAddress(name, addr, loaderScope));\n+    }\n+\n+    \/\/ A resource scope which keeps this loader reachable. Useful when returning\n+    \/\/ native symbols associated with libraries loaded by this loader.\n+    private final ResourceScope loaderScope = ResourceScopeImpl.heapScope(this);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,4 +26,1 @@\n-package jdk.incubator.foreign;\n-\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.vm.annotation.Stable;\n+package java.lang.foreign;\n@@ -41,0 +38,2 @@\n+import jdk.internal.foreign.Utils;\n+import jdk.internal.vm.annotation.Stable;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AbstractLayout.java","additions":4,"deletions":5,"binary":false,"changes":9,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/AbstractLayout.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,3 @@\n-package jdk.incubator.foreign;\n+package java.lang.foreign;\n+\n+import jdk.internal.javac.PreviewFeature;\n@@ -39,0 +41,2 @@\n+ *\n+ * @since 19\n@@ -40,0 +44,1 @@\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Addressable.java","additions":7,"deletions":2,"binary":false,"changes":9,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/Addressable.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.incubator.foreign;\n+package java.lang.foreign;\n@@ -28,0 +28,3 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.Optional;\n@@ -34,0 +37,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -37,4 +41,0 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-import java.util.Optional;\n-\n@@ -111,5 +111,3 @@\n- * <h2>System lookup<\/h2>\n- *\n- * This class implements the {@link SymbolLookup} interface; as such clients can {@linkplain #lookup(String) look up} symbols\n- * in the standard libraries associated with this linker. The set of symbols available for lookup is unspecified,\n- * as it depends on the platform and on the operating system.\n+ * <h2>Symbol lookup<\/h2>\n+ * Clients can {@linkplain #lookup(String) look up} symbols in the standard libraries associated with this linker.\n+ * The set of symbols available for lookup is unspecified, as it depends on the platform and on the operating system.\n@@ -144,0 +142,2 @@\n+ *\n+ * @since 19\n@@ -145,1 +145,2 @@\n-public sealed interface CLinker extends SymbolLookup permits Windowsx64Linker, SysVx64Linker, LinuxAArch64Linker, MacOsAArch64Linker {\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+public sealed interface CLinker permits Windowsx64Linker, SysVx64Linker, LinuxAArch64Linker, MacOsAArch64Linker {\n@@ -169,0 +170,1 @@\n+     * @param name the symbol name\n@@ -171,1 +173,0 @@\n-    @Override\n@@ -194,2 +195,0 @@\n-     *\n-     * @see SymbolLookup\n@@ -219,2 +218,0 @@\n-     *\n-     * @see SymbolLookup\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/CLinker.java","additions":14,"deletions":17,"binary":false,"changes":31,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-package jdk.incubator.foreign;\n+package java.lang.foreign;\n@@ -38,0 +38,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -45,0 +46,2 @@\n+ *\n+ * @since 19\n@@ -46,0 +49,1 @@\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":6,"deletions":2,"binary":false,"changes":8,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/FunctionDescriptor.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.incubator.foreign;\n+package java.lang.foreign;\n@@ -39,0 +39,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -58,0 +59,2 @@\n+ *\n+ * @since 19\n@@ -59,0 +62,1 @@\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":6,"deletions":2,"binary":false,"changes":8,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/GroupLayout.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-package jdk.incubator.foreign;\n+package java.lang.foreign;\n@@ -29,0 +29,1 @@\n+import java.nio.ByteOrder;\n@@ -30,0 +31,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -33,1 +35,0 @@\n-import java.nio.ByteOrder;\n@@ -48,1 +49,1 @@\n- * Each dereference method takes a {@linkplain jdk.incubator.foreign.ValueLayout value layout}, which specifies the size,\n+ * Each dereference method takes a {@linkplain ValueLayout value layout}, which specifies the size,\n@@ -77,0 +78,2 @@\n+ *\n+ * @since 19\n@@ -78,0 +81,1 @@\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryAddress.java","additions":8,"deletions":4,"binary":false,"changes":12,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,5 +26,1 @@\n-package jdk.incubator.foreign;\n-\n-import jdk.internal.foreign.LayoutPath;\n-import jdk.internal.foreign.LayoutPath.PathElementImpl.PathKind;\n-import jdk.internal.foreign.Utils;\n+package java.lang.foreign;\n@@ -47,0 +43,4 @@\n+import jdk.internal.foreign.LayoutPath;\n+import jdk.internal.foreign.LayoutPath.PathElementImpl.PathKind;\n+import jdk.internal.foreign.Utils;\n+import jdk.internal.javac.PreviewFeature;\n@@ -194,0 +194,2 @@\n+ *\n+ * @since 19\n@@ -195,0 +197,1 @@\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -524,1 +527,1 @@\n-                                       Set<LayoutPath.PathElementImpl.PathKind> badKinds, PathElement... elements) {\n+                                       Set<PathKind> badKinds, PathElement... elements) {\n@@ -556,0 +559,2 @@\n+     *\n+     * @since 19\n@@ -557,0 +562,1 @@\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -572,1 +578,1 @@\n-            return new LayoutPath.PathElementImpl(LayoutPath.PathElementImpl.PathKind.GROUP_ELEMENT,\n+            return new LayoutPath.PathElementImpl(PathKind.GROUP_ELEMENT,\n@@ -589,1 +595,1 @@\n-            return new LayoutPath.PathElementImpl(LayoutPath.PathElementImpl.PathKind.SEQUENCE_ELEMENT_INDEX,\n+            return new LayoutPath.PathElementImpl(PathKind.SEQUENCE_ELEMENT_INDEX,\n@@ -620,1 +626,1 @@\n-            return new LayoutPath.PathElementImpl(LayoutPath.PathElementImpl.PathKind.SEQUENCE_RANGE,\n+            return new LayoutPath.PathElementImpl(PathKind.SEQUENCE_RANGE,\n@@ -632,1 +638,1 @@\n-            return new LayoutPath.PathElementImpl(LayoutPath.PathElementImpl.PathKind.SEQUENCE_ELEMENT,\n+            return new LayoutPath.PathElementImpl(PathKind.SEQUENCE_ELEMENT,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":17,"deletions":11,"binary":false,"changes":28,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayout.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-package jdk.incubator.foreign;\n+package java.lang.foreign;\n@@ -29,0 +29,1 @@\n+import java.io.IOException;\n@@ -31,0 +32,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -32,1 +34,7 @@\n-\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Spliterator;\n+import java.util.stream.Stream;\n@@ -36,1 +44,0 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n@@ -38,0 +45,1 @@\n+import jdk.internal.foreign.ResourceScopeImpl;\n@@ -40,0 +48,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -46,9 +55,0 @@\n-import java.io.IOException;\n-import java.nio.ByteOrder;\n-import java.nio.channels.FileChannel;\n-import java.nio.charset.StandardCharsets;\n-import java.nio.file.Path;\n-import java.util.Objects;\n-import java.util.Spliterator;\n-import java.util.stream.Stream;\n-\n@@ -119,1 +119,1 @@\n- * Each dereference method takes a {@linkplain jdk.incubator.foreign.ValueLayout value layout}, which specifies the size,\n+ * Each dereference method takes a {@linkplain ValueLayout value layout}, which specifies the size,\n@@ -139,2 +139,2 @@\n- * {@linkplain MemoryHandles#varHandle(ValueLayout) value layout}, and then adapt it using the var handle combinator\n- * functions defined in the {@link MemoryHandles} class.\n+ * {@linkplain MethodHandles#memoryAccessVarHandle(ValueLayout) value layout}, and then adapt it using the var handle combinator\n+ * functions defined in the {@link java.lang.invoke.MethodHandles} class.\n@@ -249,0 +249,2 @@\n+ *\n+ * @since 19\n@@ -250,0 +252,1 @@\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":19,"deletions":16,"binary":false,"changes":35,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.incubator.foreign;\n+package java.lang.foreign;\n@@ -28,0 +28,2 @@\n+import java.lang.invoke.MethodHandle;\n+import java.util.Objects;\n@@ -29,0 +31,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -32,3 +35,0 @@\n-import java.lang.invoke.MethodHandle;\n-import java.util.Objects;\n-\n@@ -39,1 +39,1 @@\n- * While native symbols are typically obtained using a {@link SymbolLookup#lookup(String) symbol lookup}, it is also possible to obtain an\n+ * While native symbols are typically obtained via {@link ClassLoader#findNative(String)}, it is also possible to obtain an\n@@ -42,0 +42,2 @@\n+ *\n+ * @since 19\n@@ -43,0 +45,1 @@\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/NativeSymbol.java","additions":9,"deletions":6,"binary":false,"changes":15,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/NativeSymbol.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.incubator.foreign;\n+package java.lang.foreign;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/PaddingLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/PaddingLayout.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,4 +26,1 @@\n-package jdk.incubator.foreign;\n-\n-import jdk.internal.foreign.ResourceScopeImpl;\n-import jdk.internal.ref.CleanerFactory;\n+package java.lang.foreign;\n@@ -38,0 +35,3 @@\n+import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.ref.CleanerFactory;\n@@ -147,0 +147,2 @@\n+ *\n+ * @since 19\n@@ -148,0 +150,1 @@\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ResourceScope.java","additions":8,"deletions":5,"binary":false,"changes":13,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ResourceScope.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,6 +26,1 @@\n-package jdk.incubator.foreign;\n-\n-import jdk.internal.foreign.AbstractMemorySegmentImpl;\n-import jdk.internal.foreign.ArenaAllocator;\n-import jdk.internal.foreign.ResourceScopeImpl;\n-import jdk.internal.foreign.Utils;\n+package java.lang.foreign;\n@@ -39,0 +34,5 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.ArenaAllocator;\n+import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.Utils;\n+import jdk.internal.javac.PreviewFeature;\n@@ -66,0 +66,1 @@\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":8,"deletions":7,"binary":false,"changes":15,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.incubator.foreign;\n+package java.lang.foreign;\n@@ -33,0 +33,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -66,0 +67,2 @@\n+ *\n+ * @since 19\n@@ -67,0 +70,1 @@\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SequenceLayout.java","additions":6,"deletions":2,"binary":false,"changes":8,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SequenceLayout.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.incubator.foreign;\n+package java.lang.foreign;\n@@ -28,0 +28,2 @@\n+import java.util.Objects;\n+import java.util.function.Consumer;\n@@ -33,0 +35,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -36,3 +39,0 @@\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-\n@@ -58,0 +58,2 @@\n+ *\n+ * @since 19\n@@ -59,0 +61,1 @@\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -227,0 +230,2 @@\n+     *\n+     * @since 19\n@@ -228,0 +233,1 @@\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/VaList.java","additions":11,"deletions":5,"binary":false,"changes":16,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/VaList.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,7 +26,1 @@\n-package jdk.incubator.foreign;\n-\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.misc.Unsafe;\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.annotation.Stable;\n-import sun.invoke.util.Wrapper;\n+package java.lang.foreign;\n@@ -42,0 +36,7 @@\n+import jdk.internal.foreign.Utils;\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+import sun.invoke.util.Wrapper;\n+\n@@ -65,0 +66,2 @@\n+ *\n+ * @since 19\n@@ -66,0 +69,1 @@\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -211,0 +215,2 @@\n+     *\n+     * @since 19\n@@ -212,0 +218,1 @@\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -245,0 +252,2 @@\n+     *\n+     * @since 19\n@@ -246,0 +255,1 @@\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -279,0 +289,2 @@\n+     *\n+     * @since 19\n@@ -280,0 +292,1 @@\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -313,0 +326,2 @@\n+     *\n+     * @since 19\n@@ -314,0 +329,1 @@\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -347,0 +363,2 @@\n+     *\n+     * @since 19\n@@ -348,0 +366,1 @@\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -381,0 +400,2 @@\n+     *\n+     * @since 19\n@@ -382,0 +403,1 @@\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -415,0 +437,2 @@\n+     *\n+     * @since 19\n@@ -416,0 +440,1 @@\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -449,0 +474,2 @@\n+     *\n+     * @since 19\n@@ -450,0 +477,1 @@\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -483,0 +511,2 @@\n+     *\n+     * @since 19\n@@ -484,0 +514,1 @@\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":39,"deletions":8,"binary":false,"changes":47,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ValueLayout.java","status":"renamed"},{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/**\n+ * <p> Classes to support low-level and efficient foreign memory\/function access, directly from Java.\n+ *\n+ * <h2>Foreign memory access<\/h2>\n+ *\n+ * <p>\n+ * The main abstractions introduced to support foreign memory access is {@link java.lang.foreign.MemorySegment}, which\n+ * models a contiguous memory region, which can reside either inside or outside the Java heap.\n+ * A memory segment represents the main access coordinate of a memory access var handle, which can be obtained\n+ * using the combinator methods defined in the {@link java.lang.invoke.MethodHandles} class; a set of\n+ * common dereference and copy operations is provided also by the {@link java.lang.foreign.MemorySegment} class, which can\n+ * be useful for simple, non-structured access. Finally, the {@link java.lang.foreign.MemoryLayout} class\n+ * hierarchy enables description of <em>memory layouts<\/em> and basic operations such as computing the size in bytes of a given\n+ * layout, obtain its alignment requirements, and so on. Memory layouts also provide an alternate, more abstract way, to produce\n+ * memory access var handles, e.g. using <a href=\"MemoryLayout.html#layout-paths\"><em>layout paths<\/em><\/a>.\n+ *\n+ * For example, to allocate an off-heap memory region big enough to hold 10 values of the primitive type {@code int}, and fill it with values\n+ * ranging from {@code 0} to {@code 9}, we can use the following code:\n+ *\n+ * {@snippet lang=java :\n+ * MemorySegment segment = MemorySegment.allocateNative(10 * 4, ResourceScope.newImplicitScope());\n+ * for (int i = 0 ; i < 10 ; i++) {\n+ *     segment.setAtIndex(ValueLayout.JAVA_INT, i, i);\n+ * }\n+ * }\n+ *\n+ * This code creates a <em>native<\/em> memory segment, that is, a memory segment backed by\n+ * off-heap memory; the size of the segment is 40 bytes, enough to store 10 values of the primitive type {@code int}.\n+ * Inside a loop, we then initialize the contents of the memory segment; note how the\n+ * {@linkplain java.lang.foreign.MemorySegment#setAtIndex(ValueLayout.OfInt, long, int) dereference method}\n+ * accepts a {@linkplain java.lang.foreign.ValueLayout value layout}, which specifies the size, alignment constraints,\n+ * byte order as well as the Java type ({@code int}, in this case) associated with the dereference operation. More specifically,\n+ * if we view the memory segment as a set of 10 adjacent slots, {@code s[i]}, where {@code 0 <= i < 10},\n+ * where the size of each slot is exactly 4 bytes, the initialization logic above will set each slot\n+ * so that {@code s[i] = i}, again where {@code 0 <= i < 10}.\n+ *\n+ * <h3><a id=\"deallocation\"><\/a>Deterministic deallocation<\/h3>\n+ *\n+ * When writing code that manipulates memory segments, especially if backed by memory which resides outside the Java heap, it is\n+ * often crucial that the resources associated with a memory segment are released when the segment is no longer in use,\n+ * and in a timely fashion. For this reason, there might be cases where waiting for the garbage collector to determine that a segment\n+ * is <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a> is not optimal.\n+ * Clients that operate under these assumptions might want to programmatically release the memory associated\n+ * with a memory segment. This can be done, using the {@link java.lang.foreign.ResourceScope} abstraction, as shown below:\n+ *\n+ * {@snippet lang=java :\n+ * try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+ *     MemorySegment segment = MemorySegment.allocateNative(10 * 4, scope);\n+ *     for (int i = 0 ; i < 10 ; i++) {\n+ *         segment.setAtIndex(ValueLayout.JAVA_INT, i, i);\n+ *     }\n+ * }\n+ * }\n+ *\n+ * This example is almost identical to the prior one; this time we first create a so called <em>resource scope<\/em>,\n+ * which is used to <em>bind<\/em> the life-cycle of the segment created immediately afterwards. Note the use of the\n+ * <em>try-with-resources<\/em> construct: this idiom ensures that all the memory resources associated with the segment will be released\n+ * at the end of the block, according to the semantics described in Section {@jls 14.20.3} of <cite>The Java Language Specification<\/cite>.\n+ *\n+ * <h3><a id=\"safety\"><\/a>Safety<\/h3>\n+ *\n+ * This API provides strong safety guarantees when it comes to memory access. First, when dereferencing a memory segment,\n+ * the access coordinates are validated (upon access), to make sure that access does not occur at any address which resides\n+ * <em>outside<\/em> the boundaries of the memory segment used by the dereference operation. We call this guarantee <em>spatial safety<\/em>;\n+ * in other words, access to memory segments is bounds-checked, in the same way as array access is, as described in\n+ * Section {@jls 15.10.4} of <cite>The Java Language Specification<\/cite>.\n+ * <p>\n+ * Since memory segments can be closed (see above), segments are also validated (upon access) to make sure that\n+ * the resource scope associated with the segment being accessed has not been closed prematurely.\n+ * We call this guarantee <em>temporal safety<\/em>. Together, spatial and temporal safety ensure that each memory access\n+ * operation either succeeds - and accesses a valid memory location - or fails.\n+ *\n+ * <h2>Foreign function access<\/h2>\n+ * The key abstractions introduced to support foreign function access are {@link java.lang.foreign.SymbolLookup},\n+ * {@link java.lang.foreign.MemoryAddress} and {@link java.lang.foreign.CLinker}.\n+ * The first is used to look up symbols inside native libraries; the second is used to model native addresses (more on that later),\n+ * while the third provides linking capabilities which allows modelling foreign functions as {@link java.lang.invoke.MethodHandle} instances,\n+ * so that clients can perform foreign function calls directly in Java, without the need for intermediate layers of native\n+ * code (as is the case with the <a href=\"{@docRoot}\/..\/specs\/jni\/index.html\">Java Native Interface (JNI)<\/a>).\n+ * <p>\n+ * For example, to compute the length of a string using the C standard library function {@code strlen} on a Linux x64 platform,\n+ * we can use the following code:\n+ *\n+ * {@snippet lang=java :\n+ * var linker = CLinker.systemCLinker();\n+ * MethodHandle strlen = linker.downcallHandle(\n+ *     linker.lookup(\"strlen\").get(),\n+ *     FunctionDescriptor.of(ValueLayout.JAVA_LONG, ValueLayout.ADDRESS)\n+ * );\n+ *\n+ * try (var scope = ResourceScope.newConfinedScope()) {\n+ *     var cString = MemorySegment.allocateNative(5 + 1, scope);\n+ *     cString.setUtf8String(\"Hello\");\n+ *     long len = (long)strlen.invoke(cString); \/\/ 5\n+ * }\n+ * }\n+ *\n+ * Here, we obtain a {@linkplain java.lang.foreign.CLinker#systemCLinker() linker instance} and we use it\n+ * to {@linkplain java.lang.foreign.CLinker#lookup(java.lang.String) look up} the {@code strlen} symbol in the\n+ * standard C library; a <em>downcall method handle<\/em> targeting said symbol is subsequently\n+ * {@linkplain java.lang.foreign.CLinker#downcallHandle(java.lang.foreign.FunctionDescriptor) obtained}.\n+ * To complete the linking successfully, we must provide a {@link java.lang.foreign.FunctionDescriptor} instance,\n+ * describing the signature of the {@code strlen} function.\n+ * From this information, the linker will uniquely determine the sequence of steps which will turn\n+ * the method handle invocation (here performed using {@link java.lang.invoke.MethodHandle#invoke(java.lang.Object...)})\n+ * into a foreign function call, according to the rules specified by the platform C ABI.\n+ * The {@link java.lang.foreign.MemorySegment} class also provides many useful methods for\n+ * interacting with native code, such as converting Java strings\n+ * {@linkplain java.lang.foreign.MemorySegment#setUtf8String(long, java.lang.String) into} native strings and\n+ * {@linkplain java.lang.foreign.MemorySegment#getUtf8String(long) back}, as demonstrated in the above example.\n+ *\n+ * <h3>Foreign addresses<\/h3>\n+ *\n+ * When a memory segment is created from Java code, the segment properties (spatial bounds, temporal bounds and confinement)\n+ * are fully known at segment creation. But when interacting with native libraries, clients will often receive <em>raw<\/em> pointers.\n+ * Such pointers have no spatial bounds. For example, the C type {@code char*} can refer to a single {@code char} value,\n+ * or an array of {@code char} values, of given size. Nor do said pointers have any notion of temporal bounds or thread-confinement.\n+ * <p>\n+ * Raw pointers are modelled using the {@link java.lang.foreign.MemoryAddress} class. When clients receive a\n+ * memory address instance from a foreign function call, they can perform memory dereference on it directly,\n+ * using one of the many <em>unsafe<\/em>\n+ * {@linkplain java.lang.foreign.MemoryAddress#get(java.lang.foreign.ValueLayout.OfInt, long) dereference methods}\n+ * provided:\n+ *\n+ * {@snippet lang=java :\n+ * MemoryAddress addr = ... \/\/obtain address from native code\n+ * int x = addr.get(ValueLayout.JAVA_INT, 0);\n+ * }\n+ *\n+ * Alternatively, the client can\n+ * {@linkplain java.lang.foreign.MemorySegment#ofAddress(java.lang.foreign.MemoryAddress, long, java.lang.foreign.ResourceScope) create}\n+ * a memory segment <em>unsafely<\/em>. This allows the client to inject extra knowledge about spatial bounds which might,\n+ * for instance, be available in the documentation of the foreign function which produced the native address.\n+ * Here is how an unsafe segment can be created from a native address:\n+ *\n+ * {@snippet lang=java :\n+ * ResourceScope scope = ... \/\/ initialize a resource scope object\n+ * MemoryAddress addr = ... \/\/obtain address from native code\n+ * MemorySegment segment = MemorySegment.ofAddress(addr, 4, scope); \/\/ segment is 4 bytes long\n+ * int x = segment.get(ValueLayout.JAVA_INT, 0);\n+ * }\n+ *\n+ * <h3>Upcalls<\/h3>\n+ * The {@link java.lang.foreign.CLinker} interface also allows clients to turn an existing method handle (which might point\n+ * to a Java method) into a memory address, so that Java code can effectively be passed to other foreign functions.\n+ * For instance, we can write a method that compares two integer values, as follows:\n+ *\n+ * {@snippet lang=java :\n+ * class IntComparator {\n+ *     static int intCompare(MemoryAddress addr1, MemoryAddress addr2) {\n+ *         return addr1.get(ValueLayout.JAVA_INT, 0) - addr2.get(ValueLayout.JAVA_INT, 0);\n+ *     }\n+ * }\n+ * }\n+ *\n+ * The above method dereferences two memory addresses containing an integer value, and performs a simple comparison\n+ * by returning the difference between such values. We can then obtain a method handle which targets the above static\n+ * method, as follows:\n+ *\n+ * {@snippet lang=java :\n+ * FunctionDescriptor intCompareDescriptor = FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.ADDRESS, ValueLayout.ADDRESS);\n+ * MethodHandle intCompareHandle = MethodHandles.lookup().findStatic(IntComparator.class,\n+ *                                                 \"intCompare\",\n+ *                                                 CLinker.upcallType(comparFunction));\n+ * }\n+ *\n+ * As before, we need to create a {@link java.lang.foreign.FunctionDescriptor} instance, this time describing the signature\n+ * of the function pointer we want to create. The descriptor can be used to\n+ * {@linkplain java.lang.foreign.CLinker#upcallType(java.lang.foreign.FunctionDescriptor) derive} a method type\n+ * that can be used to look up the method handle for {@code IntComparator.intCompare}.\n+ * <p>\n+ * Now that we have a method handle instance, we can turn it into a fresh function pointer,\n+ * using the {@link java.lang.foreign.CLinker} interface, as follows:\n+ *\n+ * {@snippet lang=java :\n+ * ResourceScope scope = ...\n+ * Addressable comparFunc = CLinker.systemCLinker().upcallStub(\n+ *     intCompareHandle, intCompareDescriptor, scope);\n+ * );\n+ * }\n+ *\n+ * The {@link java.lang.foreign.FunctionDescriptor} instance created in the previous step is then used to\n+ * {@linkplain java.lang.foreign.CLinker#upcallStub(java.lang.invoke.MethodHandle, java.lang.foreign.FunctionDescriptor, java.lang.foreign.ResourceScope) create}\n+ * a new upcall stub; the layouts in the function descriptors allow the linker to determine the sequence of steps which\n+ * allow foreign code to call the stub for {@code intCompareHandle} according to the rules specified by the platform C ABI.\n+ * The lifecycle of the upcall stub returned by is tied to the {@linkplain java.lang.foreign.ResourceScope resource scope}\n+ * provided when the upcall stub is created. This same scope is made available by the {@link java.lang.foreign.NativeSymbol}\n+ * instance returned by that method.\n+ *\n+ * <a id=\"restricted\"><\/a>\n+ * <h2>Restricted methods<\/h2>\n+ * Some methods in this package are considered <em>restricted<\/em>. Restricted methods are typically used to bind native\n+ * foreign data and\/or functions to first-class Java API elements which can then be used directly by clients. For instance\n+ * the restricted method {@link MemorySegment#ofAddress(MemoryAddress, long, ResourceScope)}\n+ * can be used to create a fresh segment with given spatial bounds out of a native address.\n+ * <p>\n+ * Binding foreign data and\/or functions is generally unsafe and, if done incorrectly, can result in VM crashes, or memory corruption when the bound Java API element is accessed.\n+ * For instance, in the case of {@link MemorySegment#ofAddress(MemoryAddress, long, ResourceScope)},\n+ * if the provided spatial bounds are incorrect, a client of the segment returned by that method might crash the VM, or corrupt\n+ * memory when attempting to dereference said segment. For these reasons, it is crucial for code that calls a restricted method\n+ * to never pass arguments that might cause incorrect binding of foreign data and\/or functions to a Java API.\n+ * <p>\n+ * Access to restricted methods is <em>disabled<\/em> by default; to enable restricted methods, the command line option\n+ * {@code --enable-native-access} must mention the name of the caller's module.\n+ *\/\n+package java.lang.foreign;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import jdk.internal.foreign.Utils;\n+import jdk.internal.javac.PreviewFeature;\n@@ -45,0 +47,3 @@\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.ValueLayout;\n@@ -51,1 +56,0 @@\n-import java.lang.reflect.ReflectPermission;\n@@ -7853,0 +7857,293 @@\n+    \/**\n+     * Creates a <i>memory access var handle<\/i> from the given value layout.\n+     *\n+     * <p>The provided layout specifies the {@linkplain ValueLayout#carrier() carrier type},\n+     * the {@linkplain ValueLayout#byteSize() byte size},\n+     * the {@linkplain ValueLayout#byteAlignment() byte alignment} and the {@linkplain ValueLayout#order() byte order}\n+     * associated with the returned var handle.\n+     *\n+     * <p>The returned var handle's type is {@code carrier} and the list of coordinate types is\n+     * {@code (MemorySegment, long)}, where the {@code long} coordinate type corresponds to byte offset into\n+     * a given memory segment. The returned var handle accesses bytes at an offset in a given\n+     * memory segment, composing bytes to or from a value of the type {@code carrier} according to the given endianness;\n+     * the alignment constraint (in bytes) for the resulting memory access var handle is given by {@code alignmentBytes}.\n+     *\n+     * <p>As an example, consider the memory layout expressed by a {@link GroupLayout} instance constructed as follows:\n+     * <blockquote><pre>{@code\n+     *     GroupLayout seq = java.lang.foreign.MemoryLayout.structLayout(\n+     *             MemoryLayout.paddingLayout(32),\n+     *             ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withName(\"value\")\n+     *     );\n+     * }<\/pre><\/blockquote>\n+     * To access the member layout named {@code value}, we can construct a memory access var handle as follows:\n+     * <blockquote><pre>{@code\n+     *     VarHandle handle = MethodHandles.memoryAccessVarHandle(ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN)); \/\/(MemorySegment, long) -> int\n+     *     handle = MethodHandles.insertCoordinates(handle, 1, 4); \/\/(MemorySegment) -> int\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @apiNote The resulting var handle features certain <i>access mode restrictions<\/i>,\n+     * which are common to all memory access var handles. A memory access var handle is associated\n+     * with an access size {@code S} and an alignment constraint {@code B}\n+     * (both expressed in bytes). We say that a memory access operation is <em>fully aligned<\/em> if it occurs\n+     * at a memory address {@code A} which is compatible with both alignment constraints {@code S} and {@code B}.\n+     * If access is fully aligned then following access modes are supported and are\n+     * guaranteed to support atomic access:\n+     * <ul>\n+     * <li>read write access modes for all {@code T}, with the exception of\n+     *     access modes {@code get} and {@code set} for {@code long} and\n+     *     {@code double} on 32-bit platforms.\n+     * <li>atomic update access modes for {@code int}, {@code long},\n+     *     {@code float}, {@code double} or {@link MemoryAddress}.\n+     *     (Future major platform releases of the JDK may support additional\n+     *     types for certain currently unsupported access modes.)\n+     * <li>numeric atomic update access modes for {@code int}, {@code long} and {@link MemoryAddress}.\n+     *     (Future major platform releases of the JDK may support additional\n+     *     numeric types for certain currently unsupported access modes.)\n+     * <li>bitwise atomic update access modes for {@code int}, {@code long} and {@link MemoryAddress}.\n+     *     (Future major platform releases of the JDK may support additional\n+     *     numeric types for certain currently unsupported access modes.)\n+     * <\/ul>\n+     *\n+     * If {@code T} is {@code float}, {@code double} or {@link MemoryAddress} then atomic\n+     * update access modes compare values using their bitwise representation\n+     * (see {@link Float#floatToRawIntBits},\n+     * {@link Double#doubleToRawLongBits} and {@link MemoryAddress#toRawLongValue()}, respectively).\n+     * <p>\n+     * Alternatively, a memory access operation is <em>partially aligned<\/em> if it occurs at a memory address {@code A}\n+     * which is only compatible with the alignment constraint {@code B}; in such cases, access for anything other than the\n+     * {@code get} and {@code set} access modes will result in an {@code IllegalStateException}. If access is partially aligned,\n+     * atomic access is only guaranteed with respect to the largest power of two that divides the GCD of {@code A} and {@code S}.\n+     * <p>\n+     * Finally, in all other cases, we say that a memory access operation is <em>misaligned<\/em>; in such cases an\n+     * {@code IllegalStateException} is thrown, irrespective of the access mode being used.\n+     *\n+     * @param layout the value layout for which a memory access handle is to be obtained.\n+     * @return the new memory access var handle.\n+     * @throws IllegalArgumentException if an illegal carrier type is used, or if {@code alignmentBytes} is not a power of two.\n+     * @throws NullPointerException if {@code layout} is {@code null}.\n+     * @since 19\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+    public static VarHandle memoryAccessVarHandle(ValueLayout layout) {\n+        Objects.requireNonNull(layout);\n+        return Utils.makeMemoryAccessVarHandle(layout, false);\n+    }\n+\n+    \/**\n+     * Adapts a target var handle by pre-processing incoming and outgoing values using a pair of filter functions.\n+     * <p>\n+     * When calling e.g. {@link VarHandle#set(Object...)} on the resulting var handle, the incoming value (of type {@code T}, where\n+     * {@code T} is the <em>last<\/em> parameter type of the first filter function) is processed using the first filter and then passed\n+     * to the target var handle.\n+     * Conversely, when calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, the return value obtained from\n+     * the target var handle (of type {@code T}, where {@code T} is the <em>last<\/em> parameter type of the second filter function)\n+     * is processed using the second filter and returned to the caller. More advanced access mode types, such as\n+     * {@link VarHandle.AccessMode#COMPARE_AND_EXCHANGE} might apply both filters at the same time.\n+     * <p>\n+     * For the boxing and unboxing filters to be well-formed, their types must be of the form {@code (A... , S) -> T} and\n+     * {@code (A... , T) -> S}, respectively, where {@code T} is the type of the target var handle. If this is the case,\n+     * the resulting var handle will have type {@code S} and will feature the additional coordinates {@code A...} (which\n+     * will be appended to the coordinates of the target var handle).\n+     * <p>\n+     * If the boxing and unboxing filters throw any checked exceptions when invoked, the resulting var handle will\n+     * throw an {@link IllegalStateException}.\n+     * <p>\n+     * The resulting var handle will feature the same access modes (see {@link VarHandle.AccessMode}) and\n+     * atomic access guarantees as those featured by the target var handle.\n+     *\n+     * @param target the target var handle\n+     * @param filterToTarget a filter to convert some type {@code S} into the type of {@code target}\n+     * @param filterFromTarget a filter to convert the type of {@code target} to some type {@code S}\n+     * @return an adapter var handle which accepts a new type, performing the provided boxing\/unboxing conversions.\n+     * @throws IllegalArgumentException if {@code filterFromTarget} and {@code filterToTarget} are not well-formed, that is, they have types\n+     * other than {@code (A... , S) -> T} and {@code (A... , T) -> S}, respectively, where {@code T} is the type of the target var handle,\n+     * or if it's determined that either {@code filterFromTarget} or {@code filterToTarget} throws any checked exceptions.\n+     * @throws NullPointerException if any of the arguments is {@code null}.\n+     * @since 19\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+    public static VarHandle filterValue(VarHandle target, MethodHandle filterToTarget, MethodHandle filterFromTarget) {\n+        return VarHandles.filterValue(target, filterToTarget, filterFromTarget);\n+    }\n+\n+    \/**\n+     * Adapts a target var handle by pre-processing incoming coordinate values using unary filter functions.\n+     * <p>\n+     * When calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, the incoming coordinate values\n+     * starting at position {@code pos} (of type {@code C1, C2 ... Cn}, where {@code C1, C2 ... Cn} are the return type\n+     * of the unary filter functions) are transformed into new values (of type {@code S1, S2 ... Sn}, where {@code S1, S2 ... Sn} are the\n+     * parameter types of the unary filter functions), and then passed (along with any coordinate that was left unaltered\n+     * by the adaptation) to the target var handle.\n+     * <p>\n+     * For the coordinate filters to be well-formed, their types must be of the form {@code S1 -> T1, S2 -> T1 ... Sn -> Tn},\n+     * where {@code T1, T2 ... Tn} are the coordinate types starting at position {@code pos} of the target var handle.\n+     * <p>\n+     * If any of the filters throws a checked exception when invoked, the resulting var handle will\n+     * throw an {@link IllegalStateException}.\n+     * <p>\n+     * The resulting var handle will feature the same access modes (see {@link VarHandle.AccessMode}) and\n+     * atomic access guarantees as those featured by the target var handle.\n+     *\n+     * @param target the target var handle\n+     * @param pos the position of the first coordinate to be transformed\n+     * @param filters the unary functions which are used to transform coordinates starting at position {@code pos}\n+     * @return an adapter var handle which accepts new coordinate types, applying the provided transformation\n+     * to the new coordinate values.\n+     * @throws IllegalArgumentException if the handles in {@code filters} are not well-formed, that is, they have types\n+     * other than {@code S1 -> T1, S2 -> T2, ... Sn -> Tn} where {@code T1, T2 ... Tn} are the coordinate types starting\n+     * at position {@code pos} of the target var handle, if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive,\n+     * or if more filters are provided than the actual number of coordinate types available starting at {@code pos},\n+     * or if it's determined that any of the filters throws any checked exceptions.\n+     * @throws NullPointerException if any of the arguments is {@code null} or {@code filters} contains {@code null}.\n+     * @since 19\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+    public static VarHandle filterCoordinates(VarHandle target, int pos, MethodHandle... filters) {\n+        return VarHandles.filterCoordinates(target, pos, filters);\n+    }\n+\n+    \/**\n+     * Provides a target var handle with one or more <em>bound coordinates<\/em>\n+     * in advance of the var handle's invocation. As a consequence, the resulting var handle will feature less\n+     * coordinate types than the target var handle.\n+     * <p>\n+     * When calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, incoming coordinate values\n+     * are joined with bound coordinate values, and then passed to the target var handle.\n+     * <p>\n+     * For the bound coordinates to be well-formed, their types must be {@code T1, T2 ... Tn },\n+     * where {@code T1, T2 ... Tn} are the coordinate types starting at position {@code pos} of the target var handle.\n+     * <p>\n+     * The resulting var handle will feature the same access modes (see {@link VarHandle.AccessMode}) and\n+     * atomic access guarantees as those featured by the target var handle.\n+     *\n+     * @param target the var handle to invoke after the bound coordinates are inserted\n+     * @param pos the position of the first coordinate to be inserted\n+     * @param values the series of bound coordinates to insert\n+     * @return an adapter var handle which inserts an additional coordinates,\n+     *         before calling the target var handle\n+     * @throws IllegalArgumentException if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive,\n+     * or if more values are provided than the actual number of coordinate types available starting at {@code pos}.\n+     * @throws ClassCastException if the bound coordinates in {@code values} are not well-formed, that is, they have types\n+     * other than {@code T1, T2 ... Tn }, where {@code T1, T2 ... Tn} are the coordinate types starting at position {@code pos}\n+     * of the target var handle.\n+     * @throws NullPointerException if any of the arguments is {@code null} or {@code values} contains {@code null}.\n+     * @since 19\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+    public static VarHandle insertCoordinates(VarHandle target, int pos, Object... values) {\n+        return VarHandles.insertCoordinates(target, pos, values);\n+    }\n+\n+    \/**\n+     * Provides a var handle which adapts the coordinate values of the target var handle, by re-arranging them\n+     * so that the new coordinates match the provided ones.\n+     * <p>\n+     * The given array controls the reordering.\n+     * Call {@code #I} the number of incoming coordinates (the value\n+     * {@code newCoordinates.size()}), and call {@code #O} the number\n+     * of outgoing coordinates (the number of coordinates associated with the target var handle).\n+     * Then the length of the reordering array must be {@code #O},\n+     * and each element must be a non-negative number less than {@code #I}.\n+     * For every {@code N} less than {@code #O}, the {@code N}-th\n+     * outgoing coordinate will be taken from the {@code I}-th incoming\n+     * coordinate, where {@code I} is {@code reorder[N]}.\n+     * <p>\n+     * No coordinate value conversions are applied.\n+     * The type of each incoming coordinate, as determined by {@code newCoordinates},\n+     * must be identical to the type of the corresponding outgoing coordinate\n+     * in the target var handle.\n+     * <p>\n+     * The reordering array need not specify an actual permutation.\n+     * An incoming coordinate will be duplicated if its index appears\n+     * more than once in the array, and an incoming coordinate will be dropped\n+     * if its index does not appear in the array.\n+     * <p>\n+     * The resulting var handle will feature the same access modes (see {@link VarHandle.AccessMode}) and\n+     * atomic access guarantees as those featured by the target var handle.\n+     * @param target the var handle to invoke after the coordinates have been reordered\n+     * @param newCoordinates the new coordinate types\n+     * @param reorder an index array which controls the reordering\n+     * @return an adapter var handle which re-arranges the incoming coordinate values,\n+     * before calling the target var handle\n+     * @throws IllegalArgumentException if the index array length is not equal to\n+     * the number of coordinates of the target var handle, or if any index array element is not a valid index for\n+     * a coordinate of {@code newCoordinates}, or if two corresponding coordinate types in\n+     * the target var handle and in {@code newCoordinates} are not identical.\n+     * @throws NullPointerException if any of the arguments is {@code null} or {@code newCoordinates} contains {@code null}.\n+     * @since 19\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+    public static VarHandle permuteCoordinates(VarHandle target, List<Class<?>> newCoordinates, int... reorder) {\n+        return VarHandles.permuteCoordinates(target, newCoordinates, reorder);\n+    }\n+\n+    \/**\n+     * Adapts a target var handle by pre-processing\n+     * a sub-sequence of its coordinate values with a filter (a method handle).\n+     * The pre-processed coordinates are replaced by the result (if any) of the\n+     * filter function and the target var handle is then called on the modified (usually shortened)\n+     * coordinate list.\n+     * <p>\n+     * If {@code R} is the return type of the filter (which cannot be void), the target var handle must accept a value of\n+     * type {@code R} as its coordinate in position {@code pos}, preceded and\/or followed by\n+     * any coordinate not passed to the filter.\n+     * No coordinates are reordered, and the result returned from the filter\n+     * replaces (in order) the whole subsequence of coordinates originally\n+     * passed to the adapter.\n+     * <p>\n+     * The argument types (if any) of the filter\n+     * replace zero or one coordinate types of the target var handle, at position {@code pos},\n+     * in the resulting adapted var handle.\n+     * The return type of the filter must be identical to the\n+     * coordinate type of the target var handle at position {@code pos}, and that target var handle\n+     * coordinate is supplied by the return value of the filter.\n+     * <p>\n+     * If any of the filters throws a checked exception when invoked, the resulting var handle will\n+     * throw an {@link IllegalStateException}.\n+     * <p>\n+     * The resulting var handle will feature the same access modes (see {@link VarHandle.AccessMode}) and\n+     * atomic access guarantees as those featured by the target var handle.\n+     *\n+     * @param target the var handle to invoke after the coordinates have been filtered\n+     * @param pos the position of the coordinate to be filtered\n+     * @param filter the filter method handle\n+     * @return an adapter var handle which filters the incoming coordinate values,\n+     * before calling the target var handle\n+     * @throws IllegalArgumentException if the return type of {@code filter}\n+     * is void, or it is not the same as the {@code pos} coordinate of the target var handle,\n+     * if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive,\n+     * if the resulting var handle's type would have <a href=\"MethodHandle.html#maxarity\">too many coordinates<\/a>,\n+     * or if it's determined that {@code filter} throws any checked exceptions.\n+     * @throws NullPointerException if any of the arguments is {@code null}.\n+     * @since 19\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+    public static VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle filter) {\n+        return VarHandles.collectCoordinates(target, pos, filter);\n+    }\n+\n+    \/**\n+     * Returns a var handle which will discard some dummy coordinates before delegating to the\n+     * target var handle. As a consequence, the resulting var handle will feature more\n+     * coordinate types than the target var handle.\n+     * <p>\n+     * The {@code pos} argument may range between zero and <i>N<\/i>, where <i>N<\/i> is the arity of the\n+     * target var handle's coordinate types. If {@code pos} is zero, the dummy coordinates will precede\n+     * the target's real arguments; if {@code pos} is <i>N<\/i> they will come after.\n+     * <p>\n+     * The resulting var handle will feature the same access modes (see {@link VarHandle.AccessMode}) and\n+     * atomic access guarantees as those featured by the target var handle.\n+     *\n+     * @param target the var handle to invoke after the dummy coordinates are dropped\n+     * @param pos position of first coordinate to drop (zero for the leftmost)\n+     * @param valueTypes the type(s) of the coordinate(s) to drop\n+     * @return an adapter var handle which drops some dummy coordinates,\n+     *         before calling the target var handle\n+     * @throws IllegalArgumentException if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive.\n+     * @throws NullPointerException if any of the arguments is {@code null} or {@code valueTypes} contains {@code null}.\n+     * @since 19\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+    public static VarHandle dropCoordinates(VarHandle target, int pos, Class<?>... valueTypes) {\n+        return VarHandles.dropCoordinates(target, pos, valueTypes);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":299,"deletions":2,"binary":false,"changes":301,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -31,1 +30,0 @@\n-import jdk.internal.misc.ScopedMemoryAccess.Scope;\n@@ -36,0 +34,2 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -610,1 +610,1 @@\n-            MemorySegmentProxy segmentProxy = NIO_ACCESS.bufferSegment(bb);\n+            MemorySegment segment = NIO_ACCESS.bufferSegment(bb);\n@@ -615,4 +615,4 @@\n-        static Scope scope(ByteBuffer bb) {\n-            MemorySegmentProxy segmentProxy = NIO_ACCESS.bufferSegment(bb);\n-            return segmentProxy != null ?\n-                    segmentProxy.scope() : null;\n+        static ResourceScope scope(ByteBuffer bb) {\n+            MemorySegment segment = NIO_ACCESS.bufferSegment(bb);\n+            return segment != null ?\n+                    segment.scope() : null;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleByteArrayView.java.template","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import jdk.internal.access.foreign.MemorySegmentProxy;\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n@@ -31,0 +31,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -47,1 +48,1 @@\n-    static final VarForm FORM = new VarForm(MemoryAccessVarHandle$Type$Helper.class, MemorySegmentProxy.class, $type$.class, long.class);\n+    static final VarForm FORM = new VarForm(MemoryAccessVarHandle$Type$Helper.class, MemorySegment.class, $type$.class, long.class);\n@@ -55,1 +56,1 @@\n-        return accessType.accessModeType(MemorySegmentProxy.class, $type$.class, long.class);\n+        return accessType.accessModeType(MemorySegment.class, $type$.class, long.class);\n@@ -99,2 +100,2 @@\n-    static MemorySegmentProxy checkAddress(Object obb, long offset, long length, boolean ro) {\n-        MemorySegmentProxy oo = (MemorySegmentProxy)Objects.requireNonNull(obb);\n+    static AbstractMemorySegmentImpl checkAddress(Object obb, long offset, long length, boolean ro) {\n+        AbstractMemorySegmentImpl oo = (AbstractMemorySegmentImpl)Objects.requireNonNull(obb);\n@@ -106,1 +107,1 @@\n-    static long offset(boolean skipAlignmentMaskCheck, MemorySegmentProxy bb, long offset, long alignmentMask) {\n+    static long offset(boolean skipAlignmentMaskCheck, AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n@@ -115,1 +116,1 @@\n-    static long offsetNoVMAlignCheck(boolean skipAlignmentMaskCheck, MemorySegmentProxy bb, long offset, long alignmentMask) {\n+    static long offsetNoVMAlignCheck(boolean skipAlignmentMaskCheck, AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n@@ -135,1 +136,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, true);\n@@ -159,1 +160,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -185,1 +186,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, true);\n@@ -195,1 +196,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -205,1 +206,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, true);\n@@ -215,1 +216,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -225,1 +226,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, true);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, true);\n@@ -235,1 +236,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -246,1 +247,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -256,1 +257,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -267,1 +268,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -278,1 +279,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -289,1 +290,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -299,1 +300,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -309,1 +310,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -319,1 +320,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -329,1 +330,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -340,1 +341,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -351,1 +352,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -364,1 +365,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -378,1 +379,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -392,1 +393,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -404,1 +405,1 @@\n-    static $type$ getAndAddConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ delta) {\n+    static $type$ getAndAddConvEndianWithCAS(AbstractMemorySegmentImpl  bb, long offset, $type$ delta) {\n@@ -420,1 +421,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -434,1 +435,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -448,1 +449,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -460,1 +461,1 @@\n-    static $type$ getAndBitwiseOrConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {\n+    static $type$ getAndBitwiseOrConvEndianWithCAS(AbstractMemorySegmentImpl  bb, long offset, $type$ value) {\n@@ -474,1 +475,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -488,1 +489,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -502,1 +503,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -514,1 +515,1 @@\n-    static $type$ getAndBitwiseAndConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {\n+    static $type$ getAndBitwiseAndConvEndianWithCAS(AbstractMemorySegmentImpl  bb, long offset, $type$ value) {\n@@ -529,1 +530,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -543,1 +544,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -557,1 +558,1 @@\n-        MemorySegmentProxy bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n@@ -569,1 +570,1 @@\n-    static $type$ getAndBitwiseXorConvEndianWithCAS(MemorySegmentProxy bb, long offset, $type$ value) {\n+    static $type$ getAndBitwiseXorConvEndianWithCAS(AbstractMemorySegmentImpl  bb, long offset, $type$ value) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleMemoryAccess.java.template","additions":44,"deletions":43,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -32,0 +31,1 @@\n+import jdk.internal.foreign.ResourceScopeImpl;\n@@ -33,1 +33,0 @@\n-import jdk.internal.misc.ScopedMemoryAccess.Scope;\n@@ -39,0 +38,2 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -226,1 +227,1 @@\n-    final MemorySegmentProxy segment;\n+    final MemorySegment segment;\n@@ -231,1 +232,1 @@\n-    Buffer(long addr, int cap, MemorySegmentProxy segment) {\n+    Buffer(long addr, int cap, MemorySegment segment) {\n@@ -240,1 +241,1 @@\n-    Buffer(int mark, int pos, int lim, int cap, MemorySegmentProxy segment) {       \/\/ package-private\n+    Buffer(int mark, int pos, int lim, int cap, MemorySegment segment) {       \/\/ package-private\n@@ -759,1 +760,1 @@\n-    final ScopedMemoryAccess.Scope scope() {\n+    final ResourceScope scope() {\n@@ -768,1 +769,1 @@\n-        ScopedMemoryAccess.Scope scope = scope();\n+        ResourceScope scope = scope();\n@@ -771,2 +772,2 @@\n-                scope.checkValidState();\n-            } catch (ScopedMemoryAccess.Scope.ScopedAccessError e) {\n+                ((ResourceScopeImpl)scope).checkValidState();\n+            } catch (ScopedMemoryAccess.ScopedAccessError e) {\n@@ -788,1 +789,1 @@\n-                public ByteBuffer newDirectByteBuffer(long addr, int cap, Object obj, MemorySegmentProxy segment) {\n+                public ByteBuffer newDirectByteBuffer(long addr, int cap, Object obj, MemorySegment segment) {\n@@ -793,1 +794,1 @@\n-                public ByteBuffer newMappedByteBuffer(UnmapperProxy unmapperProxy, long address, int cap, Object obj, MemorySegmentProxy segment) {\n+                public ByteBuffer newMappedByteBuffer(UnmapperProxy unmapperProxy, long address, int cap, Object obj, MemorySegment segment) {\n@@ -798,1 +799,1 @@\n-                public ByteBuffer newHeapByteBuffer(byte[] hb, int offset, int capacity, MemorySegmentProxy segment) {\n+                public ByteBuffer newHeapByteBuffer(byte[] hb, int offset, int capacity, MemorySegment segment) {\n@@ -822,1 +823,1 @@\n-                public MemorySegmentProxy bufferSegment(Buffer buffer) {\n+                public MemorySegment bufferSegment(Buffer buffer) {\n@@ -835,2 +836,2 @@\n-                    scope.acquire0();\n-                    return scope::release0;\n+                    ((ResourceScopeImpl)scope).acquire0();\n+                    return ((ResourceScopeImpl) scope)::release0;\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -31,1 +32,0 @@\n-import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -44,1 +44,1 @@\n-    ByteBufferAs$Type$Buffer$RW$$BO$(ByteBuffer bb, MemorySegmentProxy segment) {   \/\/ package-private\n+    ByteBufferAs$Type$Buffer$RW$$BO$(ByteBuffer bb, MemorySegment segment) {   \/\/ package-private\n@@ -63,1 +63,1 @@\n-                                     long addr, MemorySegmentProxy segment)\n+                                     long addr, MemorySegment segment)\n","filename":"src\/java.base\/share\/classes\/java\/nio\/ByteBufferAs-X-Buffer.java.template","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -33,2 +35,2 @@\n-import jdk.internal.access.foreign.MemorySegmentProxy;\n-import jdk.internal.misc.ScopedMemoryAccess.Scope;\n+import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.misc.ScopedMemoryAccess.ScopedAccessError;\n@@ -147,1 +149,1 @@\n-    Direct$Type$Buffer(long addr, int cap, Object ob, MemorySegmentProxy segment) {\n+    Direct$Type$Buffer(long addr, int cap, Object ob, MemorySegment segment) {\n@@ -157,1 +159,1 @@\n-    Direct$Type$Buffer(long addr, int cap, Object ob, FileDescriptor fd, boolean isSync, MemorySegmentProxy segment) {\n+    Direct$Type$Buffer(long addr, int cap, Object ob, FileDescriptor fd, boolean isSync, MemorySegment segment) {\n@@ -180,1 +182,1 @@\n-                                     boolean isSync, MemorySegmentProxy segment)\n+                                     boolean isSync, MemorySegment segment)\n@@ -202,1 +204,1 @@\n-                               MemorySegmentProxy segment)\n+                               MemorySegment segment)\n@@ -301,1 +303,1 @@\n-        Scope scope = scope();\n+        ResourceScope scope = scope();\n@@ -307,2 +309,2 @@\n-                scope.checkValidState();\n-            } catch (Scope.ScopedAccessError e) {\n+                ((ResourceScopeImpl)scope).checkValidState();\n+            } catch (ScopedAccessError e) {\n@@ -379,1 +381,1 @@\n-            \/\/ null is passed as destination Scope to avoid checking scope() twice\n+            \/\/ null is passed as destination ResourceScope to avoid checking scope() twice\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -31,1 +32,0 @@\n-import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -62,1 +62,1 @@\n-    Heap$Type$Buffer$RW$(int cap, int lim, MemorySegmentProxy segment) {            \/\/ package-private\n+    Heap$Type$Buffer$RW$(int cap, int lim, MemorySegment segment) {            \/\/ package-private\n@@ -76,1 +76,1 @@\n-    Heap$Type$Buffer$RW$($type$[] buf, int off, int len, MemorySegmentProxy segment) { \/\/ package-private\n+    Heap$Type$Buffer$RW$($type$[] buf, int off, int len, MemorySegment segment) { \/\/ package-private\n@@ -92,1 +92,1 @@\n-                                   int off, MemorySegmentProxy segment)\n+                                   int off, MemorySegment segment)\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Heap-X-Buffer.java.template","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -33,1 +34,0 @@\n-import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -98,1 +98,1 @@\n-                     FileDescriptor fd, boolean isSync, MemorySegmentProxy segment) {\n+                     FileDescriptor fd, boolean isSync, MemorySegment segment) {\n@@ -105,1 +105,1 @@\n-                     boolean isSync, MemorySegmentProxy segment) {\n+                     boolean isSync, MemorySegment segment) {\n@@ -111,1 +111,1 @@\n-    MappedByteBuffer(int mark, int pos, int lim, int cap, MemorySegmentProxy segment) { \/\/ package-private\n+    MappedByteBuffer(int mark, int pos, int lim, int cap, MemorySegment segment) { \/\/ package-private\n","filename":"src\/java.base\/share\/classes\/java\/nio\/MappedByteBuffer.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -41,1 +42,0 @@\n-import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -286,1 +286,1 @@\n-                 $type$[] hb, int offset, MemorySegmentProxy segment)\n+                 $type$[] hb, int offset, MemorySegment segment)\n@@ -295,1 +295,1 @@\n-    $Type$Buffer(int mark, int pos, int lim, int cap, MemorySegmentProxy segment) { \/\/ package-private\n+    $Type$Buffer(int mark, int pos, int lim, int cap, MemorySegment segment) { \/\/ package-private\n@@ -301,1 +301,1 @@\n-    $Type$Buffer($type$[] hb, long addr, int cap, MemorySegmentProxy segment) { \/\/ package-private\n+    $Type$Buffer($type$[] hb, long addr, int cap, MemorySegment segment) { \/\/ package-private\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-     * {@code jdk.incubator.foreign.MemoryHandles}.\n+     * {@code java.lang.invoke.MethodHandles}.\n@@ -94,1 +94,1 @@\n-     * Used by {@code jdk.incubator.foreign.MemoryHandles}.\n+     * Used by {@code java.lang.invoke.MethodHandles}.\n@@ -100,1 +100,1 @@\n-     * Used by {@code jdk.incubator.foreign.MemoryHandles}.\n+     * Used by {@code java.lang.invoke.MethodHandles}.\n@@ -106,1 +106,1 @@\n-     * Used by {@code jdk.incubator.foreign.MemoryHandles}.\n+     * Used by {@code java.lang.invoke.MethodHandles}.\n@@ -112,1 +112,1 @@\n-     * Used by {@code jdk.incubator.foreign.MemoryHandles}.\n+     * Used by {@code java.lang.invoke.MethodHandles}.\n@@ -118,1 +118,1 @@\n-     * Used by {@code jdk.incubator.foreign.MemoryHandles}.\n+     * Used by {@code java.lang.invoke.MethodHandles}.\n@@ -124,1 +124,1 @@\n-     * Used by {@code jdk.incubator.foreign.MemoryHandles}.\n+     * Used by {@code java.lang.invoke.MethodHandles}.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -30,1 +29,0 @@\n-import jdk.internal.misc.ScopedMemoryAccess.Scope;\n@@ -33,0 +31,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -51,1 +50,1 @@\n-    ByteBuffer newDirectByteBuffer(long addr, int cap, Object obj, MemorySegmentProxy segment);\n+    ByteBuffer newDirectByteBuffer(long addr, int cap, Object obj, MemorySegment segment);\n@@ -61,1 +60,1 @@\n-    ByteBuffer newMappedByteBuffer(UnmapperProxy unmapperProxy, long addr, int cap, Object obj, MemorySegmentProxy segment);\n+    ByteBuffer newMappedByteBuffer(UnmapperProxy unmapperProxy, long addr, int cap, Object obj, MemorySegment segment);\n@@ -67,1 +66,1 @@\n-    ByteBuffer newHeapByteBuffer(byte[] hb, int offset, int capacity, MemorySegmentProxy segment);\n+    ByteBuffer newHeapByteBuffer(byte[] hb, int offset, int capacity, MemorySegment segment);\n@@ -87,1 +86,1 @@\n-    MemorySegmentProxy bufferSegment(Buffer buffer);\n+    MemorySegment bufferSegment(Buffer buffer);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- *  Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package jdk.internal.access.foreign;\n-\n-\/**\n- * This proxy interface is required to allow instances of the {@code MemoryAddress} interface (which is defined inside\n- * an incubating module) to be accessed from the memory access var handles.\n- *\/\n-public interface MemoryAddressProxy {\n-    \/**\n-     * Check that memory access is within spatial and temporal bounds.\n-     * @throws IllegalStateException if underlying segment has been closed already.\n-     * @throws IndexOutOfBoundsException if access is out-of-bounds.\n-     *\/\n-    void checkAccess(long offset, long length, boolean readOnly);\n-    long unsafeGetOffset();\n-    Object unsafeGetBase();\n-    boolean isSmall();\n-\n-    \/* Helper functions for offset computations. These are required so that we can avoid issuing long opcodes\n-     * (e.g. LMUL, LADD) when we're operating on 'small' segments (segments whose length can be expressed with an int).\n-     * C2 BCE code is very sensitive to the kind of opcode being emitted, and this workaround allows us to rescue\n-     * BCE when working with small segments. This workaround should be dropped when JDK-8223051 is resolved.\n-     *\/\n-\n-    public static long addOffsets(long op1, long op2, MemoryAddressProxy addr) {\n-        if (addr.isSmall()) {\n-            \/\/ force ints for BCE\n-            if (op1 > Integer.MAX_VALUE || op2 > Integer.MAX_VALUE\n-                    || op1 < Integer.MIN_VALUE || op2 < Integer.MIN_VALUE) {\n-                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);\n-            }\n-            int i1 = (int)op1;\n-            int i2 = (int)op2;\n-            try {\n-                return Math.addExact(i1, i2);\n-            } catch (ArithmeticException ex) {\n-                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);\n-            }\n-        } else {\n-            try {\n-                return Math.addExact(op1, op2);\n-            } catch (ArithmeticException ex) {\n-                throw overflowException(Long.MIN_VALUE, Long.MAX_VALUE);\n-            }\n-        }\n-    }\n-\n-    public static long multiplyOffsets(long op1, long op2, MemoryAddressProxy addr) {\n-        if (addr.isSmall()) {\n-            if (op1 > Integer.MAX_VALUE || op2 > Integer.MAX_VALUE\n-                    || op1 < Integer.MIN_VALUE || op2 < Integer.MIN_VALUE) {\n-                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);\n-            }\n-            \/\/ force ints for BCE\n-            int i1 = (int)op1;\n-            int i2 = (int)op2;\n-            try {\n-                return Math.multiplyExact(i1, i2);\n-            } catch (ArithmeticException ex) {\n-                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);\n-            }\n-        } else {\n-            try {\n-                return Math.multiplyExact(op1, op2);\n-            } catch (ArithmeticException ex) {\n-                throw overflowException(Long.MIN_VALUE, Long.MAX_VALUE);\n-            }\n-        }\n-    }\n-\n-    private static IndexOutOfBoundsException overflowException(long min, long max) {\n-        return new IndexOutOfBoundsException(String.format(\"Overflow occurred during offset computation ; offset exceeded range { %d .. %d }\", min, max));\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/foreign\/MemoryAddressProxy.java","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- *  Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package jdk.internal.access.foreign;\n-\n-import jdk.internal.misc.ScopedMemoryAccess;\n-\n-\/**\n- * This abstract class is required to allow implementations of the {@code MemorySegment} interface (which is defined inside\n- * an incubating module) to be accessed from the memory access var handles.\n- *\/\n-public abstract class MemorySegmentProxy {\n-    \/**\n-     * Check that memory access is within spatial bounds and that access is compatible with segment access modes.\n-     * @throws UnsupportedOperationException if underlying segment has incompatible access modes (e.g. attempting to write\n-     * a read-only segment).\n-     * @throws IndexOutOfBoundsException if access is out-of-bounds.\n-     *\/\n-    public abstract void checkAccess(long offset, long length, boolean readOnly);\n-    public abstract long unsafeGetOffset();\n-    public abstract Object unsafeGetBase();\n-    public abstract boolean isSmall();\n-    public abstract ScopedMemoryAccess.Scope scope();\n-    public abstract long maxAlignMask();\n-\n-    \/* Helper functions for offset computations. These are required so that we can avoid issuing long opcodes\n-     * (e.g. LMUL, LADD) when we're operating on 'small' segments (segments whose length can be expressed with an int).\n-     * C2 BCE code is very sensitive to the kind of opcode being emitted, and this workaround allows us to rescue\n-     * BCE when working with small segments. This workaround should be dropped when JDK-8223051 is resolved.\n-     *\/\n-\n-    public static long addOffsets(long op1, long op2, MemorySegmentProxy segmentProxy) {\n-        if (segmentProxy.isSmall()) {\n-            \/\/ force ints for BCE\n-            if (op1 > Integer.MAX_VALUE || op2 > Integer.MAX_VALUE\n-                    || op1 < Integer.MIN_VALUE || op2 < Integer.MIN_VALUE) {\n-                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);\n-            }\n-            int i1 = (int)op1;\n-            int i2 = (int)op2;\n-            try {\n-                return Math.addExact(i1, i2);\n-            } catch (ArithmeticException ex) {\n-                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);\n-            }\n-        } else {\n-            try {\n-                return Math.addExact(op1, op2);\n-            } catch (ArithmeticException ex) {\n-                throw overflowException(Long.MIN_VALUE, Long.MAX_VALUE);\n-            }\n-        }\n-    }\n-\n-    public static long multiplyOffsets(long op1, long op2, MemorySegmentProxy segmentProxy) {\n-        if (segmentProxy.isSmall()) {\n-            if (op1 > Integer.MAX_VALUE || op2 > Integer.MAX_VALUE\n-                    || op1 < Integer.MIN_VALUE || op2 < Integer.MIN_VALUE) {\n-                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);\n-            }\n-            \/\/ force ints for BCE\n-            int i1 = (int)op1;\n-            int i2 = (int)op2;\n-            try {\n-                return Math.multiplyExact(i1, i2);\n-            } catch (ArithmeticException ex) {\n-                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);\n-            }\n-        } else {\n-            try {\n-                return Math.multiplyExact(op1, op2);\n-            } catch (ArithmeticException ex) {\n-                throw overflowException(Long.MIN_VALUE, Long.MAX_VALUE);\n-            }\n-        }\n-    }\n-\n-    private static IndexOutOfBoundsException overflowException(long min, long max) {\n-        return new IndexOutOfBoundsException(String.format(\"Overflow occurred during offset computation ; offset exceeded range { %d .. %d }\", min, max));\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/foreign\/MemorySegmentProxy.java","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package jdk.internal.access.foreign;\n-\n-public interface NativeLibraryProxy {\n-    long lookup(String name) throws NoSuchMethodException;\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/foreign\/NativeLibraryProxy.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,10 +28,5 @@\n-import jdk.incubator.foreign.*;\n-import jdk.internal.access.JavaNioAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.access.foreign.MemorySegmentProxy;\n-import jdk.internal.access.foreign.UnmapperProxy;\n-import jdk.internal.misc.ScopedMemoryAccess;\n-import jdk.internal.util.ArraysSupport;\n-import jdk.internal.vm.annotation.ForceInline;\n-import sun.security.action.GetPropertyAction;\n-\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ValueLayout;\n@@ -46,2 +41,8 @@\n-\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.access.foreign.UnmapperProxy;\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.util.ArraysSupport;\n+import jdk.internal.vm.annotation.ForceInline;\n+import sun.security.action.GetPropertyAction;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n@@ -58,1 +59,1 @@\n-public abstract non-sealed class AbstractMemorySegmentImpl extends MemorySegmentProxy implements MemorySegment, SegmentAllocator, Scoped {\n+public abstract non-sealed class AbstractMemorySegmentImpl implements MemorySegment, SegmentAllocator, Scoped {\n@@ -63,1 +64,1 @@\n-            Boolean.parseBoolean(GetPropertyAction.privilegedGetProperty(\"jdk.incubator.foreign.SmallSegments\", \"true\"));\n+            Boolean.parseBoolean(GetPropertyAction.privilegedGetProperty(\"jdk.internal.foreign.SmallSegments\", \"true\"));\n@@ -353,1 +354,0 @@\n-    @Override\n@@ -358,1 +358,0 @@\n-    @Override\n@@ -370,1 +369,0 @@\n-    @Override\n@@ -375,1 +373,0 @@\n-    @Override\n@@ -386,0 +383,2 @@\n+    public abstract long maxAlignMask();\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":18,"deletions":19,"binary":false,"changes":37,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,3 @@\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.SegmentAllocator;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SegmentAllocator;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ArenaAllocator.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ArenaAllocator.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CABI.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/CABI.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import jdk.internal.vm.annotation.ForceInline;\n-\n@@ -34,0 +32,2 @@\n+import jdk.internal.vm.annotation.ForceInline;\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ConfinedScope.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ConfinedScope.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,3 @@\n-import jdk.incubator.foreign.MemorySegment;\n+import java.lang.foreign.MemorySegment;\n+import java.nio.ByteBuffer;\n+import java.util.Objects;\n@@ -35,3 +37,0 @@\n-import java.nio.ByteBuffer;\n-import java.util.Objects;\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":4,"deletions":5,"binary":false,"changes":9,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,9 +28,5 @@\n-import jdk.incubator.foreign.MemoryHandles;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.internal.access.foreign.MemorySegmentProxy;\n-\n-import jdk.incubator.foreign.GroupLayout;\n-import jdk.incubator.foreign.SequenceLayout;\n-import jdk.incubator.foreign.ValueLayout;\n-\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -173,1 +169,1 @@\n-            handle = MemoryHandles.collectCoordinates(handle, 1 + i,\n+            handle = MethodHandles.collectCoordinates(handle, 1 + i,\n@@ -177,1 +173,1 @@\n-        handle = MemoryHandles.insertCoordinates(handle, 1 + strides.length, Utils.bitsToBytesOrThrow(offset, IllegalStateException::new));\n+        handle = MethodHandles.insertCoordinates(handle, 1 + strides.length, Utils.bitsToBytesOrThrow(offset, IllegalStateException::new));\n@@ -181,1 +177,1 @@\n-            handle = MemoryHandles.permuteCoordinates(handle, expectedCoordinates, perms.stream().mapToInt(i -> i).toArray());\n+            handle = MethodHandles.permuteCoordinates(handle, expectedCoordinates, perms.stream().mapToInt(i -> i).toArray());\n@@ -353,2 +349,1 @@\n-        return MemorySegmentProxy.addOffsets(base,\n-                    MemorySegmentProxy.multiplyOffsets(stride, index, ((MemorySegmentProxy)segment)), (MemorySegmentProxy)segment);\n+        return Utils.addOffsets(base, Utils.multiplyOffset(segment, index, stride), segment);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":10,"deletions":15,"binary":false,"changes":25,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,0 @@\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.internal.access.foreign.UnmapperProxy;\n-import jdk.internal.misc.ExtendedMapMode;\n-import jdk.internal.misc.ScopedMemoryAccess;\n-import sun.nio.ch.FileChannelImpl;\n-\n@@ -35,0 +29,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -43,0 +38,4 @@\n+import jdk.internal.access.foreign.UnmapperProxy;\n+import jdk.internal.misc.ExtendedMapMode;\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import sun.nio.ch.FileChannelImpl;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":6,"deletions":7,"binary":false,"changes":13,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,5 +28,5 @@\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.ValueLayout;\n@@ -36,1 +36,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":6,"deletions":7,"binary":false,"changes":13,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,3 @@\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n+import java.nio.ByteBuffer;\n@@ -36,2 +37,0 @@\n-import java.nio.ByteBuffer;\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":4,"deletions":5,"binary":false,"changes":9,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","status":"renamed"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign;\n+\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n+\n+public record NativeSymbolImpl(String name, MemoryAddress address, ResourceScope scope) implements NativeSymbol, Scoped {\n+    @Override\n+    public MemoryAddress address() {\n+        ((ResourceScopeImpl)scope).checkValidStateSlow();\n+        return address;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeSymbolImpl.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/PlatformLayouts.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/PlatformLayouts.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,6 +29,3 @@\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SegmentAllocator;\n-import jdk.internal.misc.ScopedMemoryAccess;\n-import jdk.internal.vm.annotation.ForceInline;\n-\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SegmentAllocator;\n@@ -40,0 +37,2 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -54,1 +53,1 @@\n-public abstract non-sealed class ResourceScopeImpl implements ResourceScope, SegmentAllocator, ScopedMemoryAccess.Scope {\n+public abstract non-sealed class ResourceScopeImpl implements ResourceScope, SegmentAllocator {\n@@ -106,1 +105,1 @@\n-        } catch (ScopedMemoryAccess.Scope.ScopedAccessError err) {\n+        } catch (ScopedMemoryAccess.ScopedAccessError err) {\n@@ -194,1 +193,1 @@\n-            throw ScopedAccessError.INSTANCE;\n+            throw ScopedMemoryAccess.ScopedAccessError.INSTANCE;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ResourceScopeImpl.java","additions":9,"deletions":10,"binary":false,"changes":19,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ResourceScopeImpl.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.ResourceScope;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Scoped.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/Scoped.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import jdk.internal.misc.ScopedMemoryAccess;\n-import jdk.internal.vm.annotation.ForceInline;\n-\n@@ -34,0 +31,2 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.vm.annotation.ForceInline;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedScope.java","additions":3,"deletions":4,"binary":false,"changes":7,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SharedScope.java","status":"renamed"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import jdk.internal.loader.NativeLibraries;\n+import jdk.internal.loader.NativeLibrary;\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+\n+public class SystemLookup {\n+\n+    private SystemLookup() { }\n+\n+    static final SystemLookup INSTANCE = new SystemLookup();\n+\n+    \/*\n+     * On POSIX systems, dlsym will allow us to lookup symbol in library dependencies; the same trick doesn't work\n+     * on Windows. For this reason, on Windows we do not generate any side-library, and load msvcrt.dll directly instead.\n+     *\/\n+    private static final Function<String, Optional<NativeSymbol>> syslookup = switch (CABI.current()) {\n+        case SysV, LinuxAArch64, MacOsAArch64 -> libLookup(libs -> libs.loadLibrary(\"syslookup\"));\n+        case Win64 -> makeWindowsLookup(); \/\/ out of line to workaround javac crash\n+    };\n+\n+    private static Function<String, Optional<NativeSymbol>> makeWindowsLookup() {\n+        Path system32 = Path.of(System.getenv(\"SystemRoot\"), \"System32\");\n+        Path ucrtbase = system32.resolve(\"ucrtbase.dll\");\n+        Path msvcrt = system32.resolve(\"msvcrt.dll\");\n+\n+        boolean useUCRT = Files.exists(ucrtbase);\n+        Path stdLib = useUCRT ? ucrtbase : msvcrt;\n+        Function<String, Optional<NativeSymbol>> lookup = libLookup(libs -> libs.loadLibrary(null, stdLib.toFile()));\n+\n+        if (useUCRT) {\n+            \/\/ use a fallback lookup to look up inline functions from fallback lib\n+\n+            Function<String, Optional<NativeSymbol>> fallbackLibLookup = libLookup(libs -> libs.loadLibrary(\"WinFallbackLookup\"));\n+\n+            int numSymbols = WindowsFallbackSymbols.values().length;\n+            MemorySegment funcs = MemorySegment.ofAddress(fallbackLibLookup.apply(\"funcs\").orElseThrow().address(),\n+                ADDRESS.byteSize() * numSymbols, ResourceScope.globalScope());\n+\n+            Function<String, Optional<NativeSymbol>> fallbackLookup = name -> Optional.ofNullable(WindowsFallbackSymbols.valueOfOrNull(name))\n+                .map(symbol -> NativeSymbol.ofAddress(symbol.name(), funcs.getAtIndex(ADDRESS, symbol.ordinal()), ResourceScope.globalScope()));\n+\n+            final Function<String, Optional<NativeSymbol>> finalLookup = lookup;\n+            lookup = name -> finalLookup.apply(name).or(() -> fallbackLookup.apply(name));\n+        }\n+\n+        return lookup;\n+    }\n+\n+    private static Function<String, Optional<NativeSymbol>> libLookup(Function<NativeLibraries, NativeLibrary> loader) {\n+        NativeLibrary lib = loader.apply(NativeLibraries.rawNativeLibraries(SystemLookup.class, false));\n+        return name -> {\n+            Objects.requireNonNull(name);\n+            try {\n+                long addr = lib.lookup(name);\n+                return addr == 0 ?\n+                        Optional.empty() :\n+                        Optional.of(NativeSymbol.ofAddress(name, MemoryAddress.ofLong(addr), ResourceScope.globalScope()));\n+            } catch (NoSuchMethodException e) {\n+                return Optional.empty();\n+            }\n+        };\n+    }\n+\n+    public static SystemLookup getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    public Optional<NativeSymbol> lookup(String name) {\n+        return syslookup.apply(name);\n+    }\n+\n+    \/\/ fallback symbols missing from ucrtbase.dll\n+    \/\/ this list has to be kept in sync with the table in the companion native library\n+    private enum WindowsFallbackSymbols {\n+        \/\/ stdio\n+        fprintf,\n+        fprintf_s,\n+        fscanf,\n+        fscanf_s,\n+        fwprintf,\n+        fwprintf_s,\n+        fwscanf,\n+        fwscanf_s,\n+        printf,\n+        printf_s,\n+        scanf,\n+        scanf_s,\n+        snprintf,\n+        sprintf,\n+        sprintf_s,\n+        sscanf,\n+        sscanf_s,\n+        swprintf,\n+        swprintf_s,\n+        swscanf,\n+        swscanf_s,\n+        vfprintf,\n+        vfprintf_s,\n+        vfscanf,\n+        vfscanf_s,\n+        vfwprintf,\n+        vfwprintf_s,\n+        vfwscanf,\n+        vfwscanf_s,\n+        vprintf,\n+        vprintf_s,\n+        vscanf,\n+        vscanf_s,\n+        vsnprintf,\n+        vsnprintf_s,\n+        vsprintf,\n+        vsprintf_s,\n+        vsscanf,\n+        vsscanf_s,\n+        vswprintf,\n+        vswprintf_s,\n+        vswscanf,\n+        vswscanf_s,\n+        vwprintf,\n+        vwprintf_s,\n+        vwscanf,\n+        vwscanf_s,\n+        wprintf,\n+        wprintf_s,\n+        wscanf,\n+        wscanf_s,\n+\n+        \/\/ time\n+        gmtime\n+        ;\n+\n+        static WindowsFallbackSymbols valueOfOrNull(String name) {\n+            try {\n+                return valueOf(name);\n+            } catch (IllegalArgumentException e) {\n+                return null;\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -0,0 +1,230 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.vm.annotation.ForceInline;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+\n+\/**\n+ * This class contains misc helper functions to support creation of memory segments.\n+ *\/\n+public final class Utils {\n+    private static final MethodHandle BYTE_TO_BOOL;\n+    private static final MethodHandle BOOL_TO_BYTE;\n+    private static final MethodHandle ADDRESS_TO_LONG;\n+    private static final MethodHandle LONG_TO_ADDRESS;\n+    public static final MethodHandle MH_bitsToBytesOrThrowForOffset;\n+\n+    public static final Supplier<RuntimeException> bitsToBytesThrowOffset\n+        = () -> new UnsupportedOperationException(\"Cannot compute byte offset; bit offset is not a multiple of 8\");\n+\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            BYTE_TO_BOOL = lookup.findStatic(Utils.class, \"byteToBoolean\",\n+                    MethodType.methodType(boolean.class, byte.class));\n+            BOOL_TO_BYTE = lookup.findStatic(Utils.class, \"booleanToByte\",\n+                    MethodType.methodType(byte.class, boolean.class));\n+            ADDRESS_TO_LONG = lookup.findVirtual(MemoryAddress.class, \"toRawLongValue\",\n+                    MethodType.methodType(long.class));\n+            LONG_TO_ADDRESS = lookup.findStatic(MemoryAddress.class, \"ofLong\",\n+                    MethodType.methodType(MemoryAddress.class, long.class));\n+            MH_bitsToBytesOrThrowForOffset = MethodHandles.insertArguments(\n+                lookup.findStatic(Utils.class, \"bitsToBytesOrThrow\",\n+                    MethodType.methodType(long.class, long.class, Supplier.class)),\n+                1,\n+                bitsToBytesThrowOffset);\n+        } catch (Throwable ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n+    public static long alignUp(long n, long alignment) {\n+        return (n + alignment - 1) & -alignment;\n+    }\n+\n+    public static MemoryAddress alignUp(MemoryAddress ma, long alignment) {\n+        long offset = ma.toRawLongValue();\n+        return ma.addOffset(alignUp(offset, alignment) - offset);\n+    }\n+\n+    public static MemorySegment alignUp(MemorySegment ms, long alignment) {\n+        long offset = ms.address().toRawLongValue();\n+        return ms.asSlice(alignUp(offset, alignment) - offset);\n+    }\n+\n+    public static long bitsToBytesOrThrow(long bits, Supplier<RuntimeException> exFactory) {\n+        if (Utils.isAligned(bits, 8)) {\n+            return bits \/ 8;\n+        } else {\n+            throw exFactory.get();\n+        }\n+    }\n+\n+    public static VarHandle makeMemoryAccessVarHandle(ValueLayout layout, boolean skipAlignmentCheck) {\n+        class VarHandleCache {\n+            private static final Map<ValueLayout, VarHandle> handleMap = new ConcurrentHashMap<>();\n+            private static final Map<ValueLayout, VarHandle> handleMapNoAlignCheck = new ConcurrentHashMap<>();\n+\n+            static VarHandle put(ValueLayout layout, VarHandle handle, boolean skipAlignmentCheck) {\n+                VarHandle prev = (skipAlignmentCheck ? handleMapNoAlignCheck : handleMap).putIfAbsent(layout, handle);\n+                return prev != null ? prev : handle;\n+            }\n+        }\n+        Class<?> baseCarrier = layout.carrier();\n+        if (layout.carrier() == MemoryAddress.class) {\n+            baseCarrier = switch ((int) ValueLayout.ADDRESS.byteSize()) {\n+                case 8 -> long.class;\n+                case 4 -> int.class;\n+                default -> throw new UnsupportedOperationException(\"Unsupported address layout\");\n+            };\n+        } else if (layout.carrier() == boolean.class) {\n+            baseCarrier = byte.class;\n+        }\n+\n+        VarHandle handle = SharedSecrets.getJavaLangInvokeAccess().memoryAccessVarHandle(baseCarrier, skipAlignmentCheck,\n+                layout.byteAlignment() - 1, layout.order());\n+\n+        if (layout.carrier() == boolean.class) {\n+            handle = MethodHandles.filterValue(handle, BOOL_TO_BYTE, BYTE_TO_BOOL);\n+        } else if (layout.carrier() == MemoryAddress.class) {\n+            handle = MethodHandles.filterValue(handle,\n+                    MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(baseCarrier, MemoryAddress.class)),\n+                    MethodHandles.explicitCastArguments(LONG_TO_ADDRESS, MethodType.methodType(MemoryAddress.class, baseCarrier)));\n+        }\n+        return VarHandleCache.put(layout, handle, skipAlignmentCheck);\n+    }\n+\n+    private static boolean byteToBoolean(byte b) {\n+        return b != 0;\n+    }\n+\n+    private static byte booleanToByte(boolean b) {\n+        return b ? (byte)1 : (byte)0;\n+    }\n+\n+    public static void copy(MemorySegment addr, byte[] bytes) {\n+        var heapSegment = MemorySegment.ofArray(bytes);\n+        addr.copyFrom(heapSegment);\n+        addr.set(JAVA_BYTE, bytes.length, (byte)0);\n+    }\n+\n+    public static MemorySegment toCString(byte[] bytes, SegmentAllocator allocator) {\n+        MemorySegment addr = allocator.allocate(bytes.length + 1, 1L);\n+        copy(addr, bytes);\n+        return addr;\n+    }\n+\n+    \/* Helper functions for offset computations. These are required so that we can avoid issuing long opcodes\n+     * (e.g. LMUL, LADD) when we're operating on 'small' segments (segments whose length can be expressed with an int).\n+     * C2 BCE code is very sensitive to the kind of opcode being emitted, and this workaround allows us to rescue\n+     * BCE when working with small segments. This workaround should be dropped when JDK-8259609 is resolved.\n+     *\/\n+\n+    @ForceInline\n+    public static long scaleOffset(MemorySegment segment, long index, long size) {\n+        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n+        return multiplyOffset(segment, index, (int)size);\n+    }\n+\n+    @ForceInline\n+    public static long multiplyOffset(MemorySegment segment, long op1, long op2) {\n+        if (((AbstractMemorySegmentImpl)segment).isSmall()) {\n+            if (op1 > Integer.MAX_VALUE || op2 > Integer.MAX_VALUE\n+                    || op1 < Integer.MIN_VALUE || op2 < Integer.MIN_VALUE) {\n+                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+            }\n+            \/\/ force ints for BCE\n+            int i1 = (int)op1;\n+            int i2 = (int)op2;\n+            try {\n+                return Math.multiplyExact(i1, i2);\n+            } catch (ArithmeticException ex) {\n+                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+            }\n+        } else {\n+            try {\n+                return Math.multiplyExact(op1, op2);\n+            } catch (ArithmeticException ex) {\n+                throw overflowException(Long.MIN_VALUE, Long.MAX_VALUE);\n+            }\n+        }\n+    }\n+\n+    @ForceInline\n+    public static long addOffsets(long op1, long op2, MemorySegment segment) {\n+        if (((AbstractMemorySegmentImpl)segment).isSmall()) {\n+            \/\/ force ints for BCE\n+            if (op1 > Integer.MAX_VALUE || op2 > Integer.MAX_VALUE\n+                    || op1 < Integer.MIN_VALUE || op2 < Integer.MIN_VALUE) {\n+                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+            }\n+            int i1 = (int)op1;\n+            int i2 = (int)op2;\n+            try {\n+                return Math.addExact(i1, i2);\n+            } catch (ArithmeticException ex) {\n+                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+            }\n+        } else {\n+            try {\n+                return Math.addExact(op1, op2);\n+            } catch (ArithmeticException ex) {\n+                throw overflowException(Long.MIN_VALUE, Long.MAX_VALUE);\n+            }\n+        }\n+    }\n+\n+    private static IndexOutOfBoundsException overflowException(long min, long max) {\n+        return new IndexOutOfBoundsException(String.format(\"Overflow occurred during offset computation ; offset exceeded range { %d .. %d }\", min, max));\n+    }\n+\n+    @ForceInline\n+    public static boolean isAligned(long offset, long align) {\n+        return (offset & (align - 1)) == 0;\n+    }\n+\n+    @ForceInline\n+    public static void checkElementAlignment(MemoryLayout layout, String msg) {\n+        if (layout.byteAlignment() > layout.byteSize()) {\n+            throw new IllegalArgumentException(msg);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":230,"deletions":0,"binary":false,"changes":230,"status":"added"},{"patch":"","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ABIDescriptor.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ABIDescriptor.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Architecture.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Architecture.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,11 +27,7 @@\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryHandles;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SegmentAllocator;\n-import jdk.incubator.foreign.ValueLayout;\n-import jdk.internal.foreign.MemoryAddressImpl;\n-import jdk.internal.foreign.ResourceScopeImpl;\n-\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ValueLayout;\n@@ -41,0 +37,2 @@\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n@@ -45,4 +43,2 @@\n-\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-\n+import jdk.internal.foreign.MemoryAddressImpl;\n+import jdk.internal.foreign.ResourceScopeImpl;\n@@ -221,1 +217,1 @@\n-            MH_COPY_BUFFER = lookup.findStatic(Binding.Copy.class, \"copyBuffer\",\n+            MH_COPY_BUFFER = lookup.findStatic(Copy.class, \"copyBuffer\",\n@@ -223,1 +219,1 @@\n-            MH_ALLOCATE_BUFFER = lookup.findStatic(Binding.Allocate.class, \"allocateBuffer\",\n+            MH_ALLOCATE_BUFFER = lookup.findStatic(Allocate.class, \"allocateBuffer\",\n@@ -225,1 +221,1 @@\n-            MH_TO_SEGMENT = lookup.findStatic(Binding.ToSegment.class, \"toSegment\",\n+            MH_TO_SEGMENT = lookup.findStatic(ToSegment.class, \"toSegment\",\n@@ -410,2 +406,2 @@\n-    public static Binding.Builder builder() {\n-        return new Binding.Builder();\n+    public static Builder builder() {\n+        return new Builder();\n@@ -433,1 +429,1 @@\n-        public Binding.Builder vmStore(VMStorage storage, Class<?> type) {\n+        public Builder vmStore(VMStorage storage, Class<?> type) {\n@@ -438,1 +434,1 @@\n-        public Binding.Builder vmLoad(VMStorage storage, Class<?> type) {\n+        public Builder vmLoad(VMStorage storage, Class<?> type) {\n@@ -443,1 +439,1 @@\n-        public Binding.Builder bufferStore(long offset, Class<?> type) {\n+        public Builder bufferStore(long offset, Class<?> type) {\n@@ -448,1 +444,1 @@\n-        public Binding.Builder bufferLoad(long offset, Class<?> type) {\n+        public Builder bufferLoad(long offset, Class<?> type) {\n@@ -453,1 +449,1 @@\n-        public Binding.Builder copy(MemoryLayout layout) {\n+        public Builder copy(MemoryLayout layout) {\n@@ -458,1 +454,1 @@\n-        public Binding.Builder allocate(MemoryLayout layout) {\n+        public Builder allocate(MemoryLayout layout) {\n@@ -463,1 +459,1 @@\n-        public Binding.Builder boxAddress() {\n+        public Builder boxAddress() {\n@@ -468,1 +464,1 @@\n-        public Binding.Builder unboxAddress() {\n+        public Builder unboxAddress() {\n@@ -473,1 +469,1 @@\n-        public Binding.Builder unboxAddress(Class<?> carrier) {\n+        public Builder unboxAddress(Class<?> carrier) {\n@@ -478,1 +474,1 @@\n-        public Binding.Builder toSegment(MemoryLayout layout) {\n+        public Builder toSegment(MemoryLayout layout) {\n@@ -483,1 +479,1 @@\n-        public Binding.Builder dup() {\n+        public Builder dup() {\n@@ -637,1 +633,1 @@\n-            return MemoryHandles.insertCoordinates(MemoryHandles.varHandle(layout), 1, offset);\n+            return MethodHandles.insertCoordinates(MethodHandles.memoryAccessVarHandle(layout), 1, offset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":29,"deletions":33,"binary":false,"changes":62,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingInterpreter.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingInterpreter.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,1 @@\n-import jdk.incubator.foreign.FunctionDescriptor;\n-\n+import java.lang.foreign.FunctionDescriptor;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","additions":2,"deletions":3,"binary":false,"changes":5,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,8 +27,5 @@\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ValueLayout;\n-import jdk.internal.foreign.Utils;\n-import sun.security.action.GetPropertyAction;\n-\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ValueLayout;\n@@ -42,1 +39,2 @@\n-\n+import jdk.internal.foreign.Utils;\n+import sun.security.action.GetPropertyAction;\n@@ -47,1 +45,1 @@\n-            GetPropertyAction.privilegedGetProperty(\"jdk.incubator.foreign.VERIFY_BINDINGS\", \"true\"));\n+            GetPropertyAction.privilegedGetProperty(\"java.lang.foreign.VERIFY_BINDINGS\", \"true\"));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":9,"deletions":11,"binary":false,"changes":20,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,12 +27,5 @@\n-import jdk.incubator.foreign.MemoryHandles;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.SegmentAllocator;\n-import jdk.incubator.foreign.ValueLayout;\n-import jdk.internal.access.JavaLangInvokeAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.invoke.NativeEntryPoint;\n-import jdk.internal.invoke.VMStorageProxy;\n-import sun.security.action.GetPropertyAction;\n-\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ValueLayout;\n@@ -48,1 +41,5 @@\n-\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.invoke.NativeEntryPoint;\n+import jdk.internal.invoke.VMStorageProxy;\n+import sun.security.action.GetPropertyAction;\n@@ -223,1 +220,1 @@\n-                    MethodHandle loadHandle = MemoryHandles.insertCoordinates(MemoryHandles.varHandle(layout), 1, retBufReadOffset)\n+                    MethodHandle loadHandle = MethodHandles.insertCoordinates(MethodHandles.memoryAccessVarHandle(layout), 1, retBufReadOffset)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":12,"deletions":15,"binary":false,"changes":27,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,5 @@\n-import jdk.incubator.foreign.MemoryHandles;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.ValueLayout;\n@@ -52,1 +51,0 @@\n-import static java.lang.invoke.MethodHandles.exactInvoker;\n@@ -167,1 +165,1 @@\n-                    MethodHandle storeHandle = MemoryHandles.insertCoordinates(MemoryHandles.varHandle(layout), 1, retBufWriteOffset)\n+                    MethodHandle storeHandle = MethodHandles.insertCoordinates(MethodHandles.memoryAccessVarHandle(layout), 1, retBufWriteOffset)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":7,"deletions":9,"binary":false,"changes":16,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,27 +27,13 @@\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.GroupLayout;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SegmentAllocator;\n-import jdk.incubator.foreign.SequenceLayout;\n-import jdk.incubator.foreign.VaList;\n-import jdk.incubator.foreign.ValueLayout;\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.JavaLangInvokeAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.foreign.Scoped;\n-import jdk.internal.foreign.CABI;\n-import jdk.internal.foreign.MemoryAddressImpl;\n-import jdk.internal.foreign.ResourceScopeImpl;\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64Linker;\n-import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64Linker;\n-import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;\n-import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;\n-import jdk.internal.vm.annotation.ForceInline;\n-\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.VaList;\n+import java.lang.foreign.ValueLayout;\n@@ -69,1 +55,12 @@\n-\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.foreign.CABI;\n+import jdk.internal.foreign.MemoryAddressImpl;\n+import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.Scoped;\n+import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64Linker;\n+import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64Linker;\n+import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;\n+import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -81,9 +78,9 @@\n-import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BOOLEAN;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n+import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n+import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":35,"deletions":38,"binary":false,"changes":73,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,3 +27,3 @@\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n-import jdk.internal.invoke.VMStorageProxy;\n-\n@@ -30,0 +28,1 @@\n+import jdk.internal.invoke.VMStorageProxy;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/VMStorage.java","additions":2,"deletions":3,"binary":false,"changes":5,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/VMStorage.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Architecture.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Architecture.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,7 +28,11 @@\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.GroupLayout;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.List;\n+import java.util.Optional;\n@@ -36,1 +40,0 @@\n-import jdk.internal.foreign.abi.CallingSequenceBuilder;\n@@ -40,0 +43,1 @@\n+import jdk.internal.foreign.abi.CallingSequenceBuilder;\n@@ -42,1 +46,0 @@\n-import jdk.internal.foreign.abi.VMStorage;\n@@ -44,8 +47,3 @@\n-import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64CallArranger;\n-import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64CallArranger;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-import java.util.List;\n-import java.util.Optional;\n-\n+import jdk.internal.foreign.abi.VMStorage;\n+import jdk.internal.foreign.abi.aarch64.linux.*;\n+import jdk.internal.foreign.abi.aarch64.macos.*;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":16,"deletions":18,"binary":false,"changes":34,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,5 +28,5 @@\n-import jdk.incubator.foreign.GroupLayout;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.SequenceLayout;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.ValueLayout;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/TypeClass.java","additions":6,"deletions":6,"binary":false,"changes":12,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/TypeClass.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64CallArranger.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64CallArranger.java","status":"renamed"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.linux;\n+\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.VaList;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.foreign.abi.aarch64.CallArranger;\n+\n+\/**\n+ * ABI implementation based on ARM document \"Procedure Call Standard for\n+ * the ARM 64-bit Architecture\".\n+ *\/\n+public final class LinuxAArch64Linker implements CLinker {\n+    private static LinuxAArch64Linker instance;\n+\n+    static final long ADDRESS_SIZE = 64; \/\/ bits\n+\n+    public static LinuxAArch64Linker getInstance() {\n+        if (instance == null) {\n+            instance = new LinuxAArch64Linker();\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n+        Objects.requireNonNull(function);\n+        MethodType type = SharedUtils.inferMethodType(function, false);\n+        MethodHandle handle = CallArranger.LINUX.arrangeDowncall(type, function);\n+        handle = SharedUtils.maybeInsertAllocator(handle);\n+        return SharedUtils.wrapDowncall(handle, function);\n+    }\n+\n+    @Override\n+    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n+        Objects.requireNonNull(target);\n+        Objects.requireNonNull(function);\n+        SharedUtils.checkExceptions(target);\n+        MethodType type = SharedUtils.inferMethodType(function, true);\n+        if (!type.equals(target.type())) {\n+            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n+        }\n+        return CallArranger.LINUX.arrangeUpcall(target, target.type(), function, scope);\n+    }\n+\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n+        LinuxAArch64VaList.Builder builder = LinuxAArch64VaList.builder(scope);\n+        actions.accept(builder);\n+        return builder.build();\n+    }\n+\n+    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n+        return LinuxAArch64VaList.ofAddress(ma, scope);\n+    }\n+\n+    public static VaList emptyVaList() {\n+        return LinuxAArch64VaList.empty();\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,13 @@\n-import jdk.incubator.foreign.*;\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.VaList;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.VarHandle;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n@@ -33,1 +45,1 @@\n-import jdk.internal.foreign.abi.aarch64.*;\n+import jdk.internal.foreign.abi.aarch64.TypeClass;\n@@ -35,7 +47,1 @@\n-\n-import java.lang.invoke.VarHandle;\n-import java.lang.ref.Cleaner;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-\n+import static java.lang.foreign.MemoryLayout.PathElement.groupElement;\n@@ -44,1 +50,0 @@\n-import static jdk.incubator.foreign.MemoryLayout.PathElement.groupElement;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":16,"deletions":11,"binary":false,"changes":27,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64CallArranger.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64CallArranger.java","status":"renamed"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.macos;\n+\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.VaList;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.foreign.abi.aarch64.CallArranger;\n+\n+\/**\n+ * ABI implementation for macOS on Apple silicon. Based on AAPCS with\n+ * changes to va_list and passing arguments on the stack.\n+ *\/\n+public final class MacOsAArch64Linker implements CLinker {\n+    private static MacOsAArch64Linker instance;\n+\n+    static final long ADDRESS_SIZE = 64; \/\/ bits\n+\n+    public static MacOsAArch64Linker getInstance() {\n+        if (instance == null) {\n+            instance = new MacOsAArch64Linker();\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n+        Objects.requireNonNull(function);\n+        MethodType type = SharedUtils.inferMethodType(function, false);\n+        MethodHandle handle = CallArranger.MACOS.arrangeDowncall(type, function);\n+        handle = SharedUtils.maybeInsertAllocator(handle);\n+        return SharedUtils.wrapDowncall(handle, function);\n+    }\n+\n+    @Override\n+    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n+        Objects.requireNonNull(target);\n+        Objects.requireNonNull(function);\n+        MethodType type = SharedUtils.inferMethodType(function, true);\n+        if (!type.equals(target.type())) {\n+            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n+        }\n+        return CallArranger.MACOS.arrangeUpcall(target, target.type(), function, scope);\n+    }\n+\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n+        MacOsAArch64VaList.Builder builder = MacOsAArch64VaList.builder(scope);\n+        actions.accept(builder);\n+        return builder.build();\n+    }\n+\n+    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n+        return MacOsAArch64VaList.ofAddress(ma, scope);\n+    }\n+\n+    public static VaList emptyVaList() {\n+        return MacOsAArch64VaList.empty();\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,9 @@\n-import jdk.incubator.foreign.*;\n-import jdk.internal.foreign.Scoped;\n-import jdk.internal.foreign.ResourceScopeImpl;\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.abi.SharedUtils.SimpleVaArg;\n-import jdk.internal.foreign.abi.aarch64.*;\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.VaList;\n+import java.lang.foreign.ValueLayout;\n@@ -39,1 +42,5 @@\n-\n+import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.Scoped;\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.foreign.abi.SharedUtils.SimpleVaArg;\n+import jdk.internal.foreign.abi.aarch64.TypeClass;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":15,"deletions":8,"binary":false,"changes":23,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.util.stream.IntStream;\n@@ -31,2 +32,0 @@\n-import java.util.stream.IntStream;\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/X86_64Architecture.java","additions":2,"deletions":3,"binary":false,"changes":5,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/X86_64Architecture.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/ArgumentClassImpl.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/ArgumentClassImpl.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,8 +28,12 @@\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.GroupLayout;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.internal.foreign.abi.CallingSequenceBuilder;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.List;\n+import java.util.Optional;\n@@ -39,0 +43,1 @@\n+import jdk.internal.foreign.abi.CallingSequenceBuilder;\n@@ -41,0 +46,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -43,8 +49,0 @@\n-import jdk.internal.foreign.abi.SharedUtils;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.util.List;\n-import java.util.Optional;\n-\n@@ -262,1 +260,1 @@\n-            Binding.Builder bindings = Binding.builder();\n+            Builder bindings = Binding.builder();\n@@ -315,1 +313,1 @@\n-            Binding.Builder bindings = Binding.builder();\n+            Builder bindings = Binding.builder();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":17,"deletions":19,"binary":false,"changes":36,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,13 @@\n-import jdk.incubator.foreign.*;\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.VaList;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.VarHandle;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n@@ -34,10 +46,1 @@\n-\n-import java.lang.invoke.VarHandle;\n-import java.lang.ref.Cleaner;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import static jdk.internal.foreign.PlatformLayouts.SysV;\n-\n-import static jdk.incubator.foreign.MemoryLayout.PathElement.groupElement;\n+import static java.lang.foreign.MemoryLayout.PathElement.groupElement;\n@@ -46,0 +49,1 @@\n+import static jdk.internal.foreign.PlatformLayouts.SysV;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":16,"deletions":12,"binary":false,"changes":28,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,8 +28,6 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.VaList;\n-import jdk.internal.foreign.abi.SharedUtils;\n-\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.VaList;\n@@ -40,0 +38,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":8,"deletions":9,"binary":false,"changes":17,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,7 +27,5 @@\n-import jdk.incubator.foreign.GroupLayout;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.SequenceLayout;\n-import jdk.incubator.foreign.ValueLayout;\n-import jdk.internal.foreign.Utils;\n-\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -38,0 +36,1 @@\n+import jdk.internal.foreign.Utils;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/TypeClass.java","additions":7,"deletions":8,"binary":false,"changes":15,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/TypeClass.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,7 +27,11 @@\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.GroupLayout;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.List;\n+import java.util.Optional;\n@@ -35,1 +39,0 @@\n-import jdk.internal.foreign.abi.CallingSequenceBuilder;\n@@ -39,0 +42,1 @@\n+import jdk.internal.foreign.abi.CallingSequenceBuilder;\n@@ -41,0 +45,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -43,7 +48,0 @@\n-import jdk.internal.foreign.abi.SharedUtils;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-import java.util.List;\n-import java.util.Optional;\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":14,"deletions":16,"binary":false,"changes":30,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,4 +27,4 @@\n-import jdk.incubator.foreign.GroupLayout;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/TypeClass.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/TypeClass.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,9 @@\n-import jdk.incubator.foreign.*;\n-import jdk.internal.foreign.Scoped;\n-import jdk.internal.foreign.ResourceScopeImpl;\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.abi.SharedUtils.SimpleVaArg;\n-\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.VaList;\n+import java.lang.foreign.ValueLayout;\n@@ -39,1 +42,4 @@\n-\n+import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.Scoped;\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.foreign.abi.SharedUtils.SimpleVaArg;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":14,"deletions":8,"binary":false,"changes":22,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","status":"renamed"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.x64.windows;\n+\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.VaList;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import jdk.internal.foreign.abi.SharedUtils;\n+\n+\/**\n+ * ABI implementation based on Windows ABI AMD64 supplement v.0.99.6\n+ *\/\n+public final class Windowsx64Linker implements CLinker {\n+\n+    public static final int MAX_INTEGER_ARGUMENT_REGISTERS = 4;\n+    public static final int MAX_INTEGER_RETURN_REGISTERS = 1;\n+    public static final int MAX_VECTOR_ARGUMENT_REGISTERS = 4;\n+    public static final int MAX_VECTOR_RETURN_REGISTERS = 1;\n+    public static final int MAX_REGISTER_ARGUMENTS = 4;\n+    public static final int MAX_REGISTER_RETURNS = 1;\n+\n+    private static Windowsx64Linker instance;\n+\n+    static final long ADDRESS_SIZE = 64; \/\/ bits\n+\n+    public static Windowsx64Linker getInstance() {\n+        if (instance == null) {\n+            instance = new Windowsx64Linker();\n+        }\n+        return instance;\n+    }\n+\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n+        WinVaList.Builder builder = WinVaList.builder(scope);\n+        actions.accept(builder);\n+        return builder.build();\n+    }\n+\n+    @Override\n+    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n+        Objects.requireNonNull(function);\n+        MethodType type = SharedUtils.inferMethodType(function, false);\n+        MethodHandle handle = CallArranger.arrangeDowncall(type, function);\n+        handle = SharedUtils.maybeInsertAllocator(handle);\n+        return SharedUtils.wrapDowncall(handle, function);\n+    }\n+\n+    @Override\n+    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n+        Objects.requireNonNull(target);\n+        Objects.requireNonNull(function);\n+        SharedUtils.checkExceptions(target);\n+        MethodType type = SharedUtils.inferMethodType(function, true);\n+        if (!type.equals(target.type())) {\n+            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n+        }\n+        return CallArranger.arrangeUpcall(target, target.type(), function, scope);\n+    }\n+\n+    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n+        return WinVaList.ofAddress(ma, scope);\n+    }\n+\n+    public static VaList emptyVaList() {\n+        return WinVaList.empty();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+        FOREIGN,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-    public $type$ get$Type$(Scope scope, Object base, long offset) {\n+    public $type$ get$Type$(ResourceScope scope, Object base, long offset) {\n@@ -5,1 +5,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -11,1 +11,1 @@\n-    private $type$ get$Type$Internal(Scope scope, Object base, long offset) {\n+    private $type$ get$Type$Internal(ResourceScope scope, Object base, long offset) {\n@@ -14,1 +14,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -23,1 +23,1 @@\n-    public void put$Type$(Scope scope, Object base, long offset, $type$ value) {\n+    public void put$Type$(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -26,1 +26,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -32,1 +32,1 @@\n-    private void put$Type$Internal(Scope scope, Object base, long offset, $type$ value) {\n+    private void put$Type$Internal(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -35,1 +35,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -45,1 +45,1 @@\n-    public $type$ get$Type$Unaligned(Scope scope, Object base, long offset, boolean be) {\n+    public $type$ get$Type$Unaligned(ResourceScope scope, Object base, long offset, boolean be) {\n@@ -48,1 +48,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -54,1 +54,1 @@\n-    private $type$ get$Type$UnalignedInternal(Scope scope, Object base, long offset, boolean be) {\n+    private $type$ get$Type$UnalignedInternal(ResourceScope scope, Object base, long offset, boolean be) {\n@@ -57,1 +57,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -66,1 +66,1 @@\n-    public void put$Type$Unaligned(Scope scope, Object base, long offset, $type$ value, boolean be) {\n+    public void put$Type$Unaligned(ResourceScope scope, Object base, long offset, $type$ value, boolean be) {\n@@ -69,1 +69,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -75,1 +75,1 @@\n-    private void put$Type$UnalignedInternal(Scope scope, Object base, long offset, $type$ value, boolean be) {\n+    private void put$Type$UnalignedInternal(ResourceScope scope, Object base, long offset, $type$ value, boolean be) {\n@@ -78,1 +78,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -88,1 +88,1 @@\n-    public $type$ get$Type$Volatile(Scope scope, Object base, long offset) {\n+    public $type$ get$Type$Volatile(ResourceScope scope, Object base, long offset) {\n@@ -91,1 +91,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -97,1 +97,1 @@\n-    private $type$ get$Type$VolatileInternal(Scope scope, Object base, long offset) {\n+    private $type$ get$Type$VolatileInternal(ResourceScope scope, Object base, long offset) {\n@@ -100,1 +100,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -109,1 +109,1 @@\n-    public void put$Type$Volatile(Scope scope, Object base, long offset, $type$ value) {\n+    public void put$Type$Volatile(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -112,1 +112,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -118,1 +118,1 @@\n-    private void put$Type$VolatileInternal(Scope scope, Object base, long offset, $type$ value) {\n+    private void put$Type$VolatileInternal(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -121,1 +121,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -130,1 +130,1 @@\n-    public $type$ get$Type$Acquire(Scope scope, Object base, long offset) {\n+    public $type$ get$Type$Acquire(ResourceScope scope, Object base, long offset) {\n@@ -133,1 +133,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -139,1 +139,1 @@\n-    private $type$ get$Type$AcquireInternal(Scope scope, Object base, long offset) {\n+    private $type$ get$Type$AcquireInternal(ResourceScope scope, Object base, long offset) {\n@@ -142,1 +142,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -151,1 +151,1 @@\n-    public void put$Type$Release(Scope scope, Object base, long offset, $type$ value) {\n+    public void put$Type$Release(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -154,1 +154,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -160,1 +160,1 @@\n-    private void put$Type$ReleaseInternal(Scope scope, Object base, long offset, $type$ value) {\n+    private void put$Type$ReleaseInternal(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -163,1 +163,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -172,1 +172,1 @@\n-    public $type$ get$Type$Opaque(Scope scope, Object base, long offset) {\n+    public $type$ get$Type$Opaque(ResourceScope scope, Object base, long offset) {\n@@ -175,1 +175,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -181,1 +181,1 @@\n-    private $type$ get$Type$OpaqueInternal(Scope scope, Object base, long offset) {\n+    private $type$ get$Type$OpaqueInternal(ResourceScope scope, Object base, long offset) {\n@@ -184,1 +184,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -192,1 +192,1 @@\n-    public void put$Type$Opaque(Scope scope, Object base, long offset, $type$ value) {\n+    public void put$Type$Opaque(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -195,1 +195,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -201,1 +201,1 @@\n-    private void put$Type$OpaqueInternal(Scope scope, Object base, long offset, $type$ value) {\n+    private void put$Type$OpaqueInternal(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -204,1 +204,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -213,1 +213,1 @@\n-    public boolean compareAndSet$Type$(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    public boolean compareAndSet$Type$(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -216,1 +216,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -222,1 +222,1 @@\n-    private boolean compareAndSet$Type$Internal(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    private boolean compareAndSet$Type$Internal(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -225,1 +225,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -234,1 +234,1 @@\n-    public $type$ compareAndExchange$Type$(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    public $type$ compareAndExchange$Type$(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -237,1 +237,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -243,1 +243,1 @@\n-    private $type$ compareAndExchange$Type$Internal(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    private $type$ compareAndExchange$Type$Internal(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -246,1 +246,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -255,1 +255,1 @@\n-    public $type$ compareAndExchange$Type$Acquire(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    public $type$ compareAndExchange$Type$Acquire(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -258,1 +258,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -264,1 +264,1 @@\n-    private $type$ compareAndExchange$Type$AcquireInternal(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    private $type$ compareAndExchange$Type$AcquireInternal(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -267,1 +267,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -276,1 +276,1 @@\n-    public $type$ compareAndExchange$Type$Release(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    public $type$ compareAndExchange$Type$Release(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -279,1 +279,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -285,1 +285,1 @@\n-    private $type$ compareAndExchange$Type$ReleaseInternal(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    private $type$ compareAndExchange$Type$ReleaseInternal(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -288,1 +288,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -297,1 +297,1 @@\n-    public boolean weakCompareAndSet$Type$Plain(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    public boolean weakCompareAndSet$Type$Plain(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -300,1 +300,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -306,1 +306,1 @@\n-    private boolean weakCompareAndSet$Type$PlainInternal(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    private boolean weakCompareAndSet$Type$PlainInternal(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -309,1 +309,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -318,1 +318,1 @@\n-    public boolean weakCompareAndSet$Type$(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    public boolean weakCompareAndSet$Type$(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -321,1 +321,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -327,1 +327,1 @@\n-    private boolean weakCompareAndSet$Type$Internal(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    private boolean weakCompareAndSet$Type$Internal(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -330,1 +330,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -339,1 +339,1 @@\n-    public boolean weakCompareAndSet$Type$Acquire(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    public boolean weakCompareAndSet$Type$Acquire(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -342,1 +342,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -348,1 +348,1 @@\n-    private boolean weakCompareAndSet$Type$AcquireInternal(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    private boolean weakCompareAndSet$Type$AcquireInternal(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -351,1 +351,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -360,1 +360,1 @@\n-    public boolean weakCompareAndSet$Type$Release(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    public boolean weakCompareAndSet$Type$Release(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -363,1 +363,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -369,1 +369,1 @@\n-    private boolean weakCompareAndSet$Type$ReleaseInternal(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    private boolean weakCompareAndSet$Type$ReleaseInternal(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n@@ -372,1 +372,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -381,1 +381,1 @@\n-    public $type$ getAndSet$Type$(Scope scope, Object base, long offset, $type$ value) {\n+    public $type$ getAndSet$Type$(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -384,1 +384,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -390,1 +390,1 @@\n-    private $type$ getAndSet$Type$Internal(Scope scope, Object base, long offset, $type$ value) {\n+    private $type$ getAndSet$Type$Internal(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -393,1 +393,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -402,1 +402,1 @@\n-    public $type$ getAndSet$Type$Acquire(Scope scope, Object base, long offset, $type$ value) {\n+    public $type$ getAndSet$Type$Acquire(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -405,1 +405,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -411,1 +411,1 @@\n-    private $type$ getAndSet$Type$AcquireInternal(Scope scope, Object base, long offset, $type$ value) {\n+    private $type$ getAndSet$Type$AcquireInternal(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -414,1 +414,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -423,1 +423,1 @@\n-    public $type$ getAndSet$Type$Release(Scope scope, Object base, long offset, $type$ value) {\n+    public $type$ getAndSet$Type$Release(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -426,1 +426,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -432,1 +432,1 @@\n-    private $type$ getAndSet$Type$ReleaseInternal(Scope scope, Object base, long offset, $type$ value) {\n+    private $type$ getAndSet$Type$ReleaseInternal(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -435,1 +435,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -446,1 +446,1 @@\n-    public $type$ getAndAdd$Type$(Scope scope, Object base, long offset, $type$ delta) {\n+    public $type$ getAndAdd$Type$(ResourceScope scope, Object base, long offset, $type$ delta) {\n@@ -449,1 +449,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -455,1 +455,1 @@\n-    private $type$ getAndAdd$Type$Internal(Scope scope, Object base, long offset, $type$ delta) {\n+    private $type$ getAndAdd$Type$Internal(ResourceScope scope, Object base, long offset, $type$ delta) {\n@@ -458,1 +458,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -467,1 +467,1 @@\n-    public $type$ getAndAdd$Type$Acquire(Scope scope, Object base, long offset, $type$ delta) {\n+    public $type$ getAndAdd$Type$Acquire(ResourceScope scope, Object base, long offset, $type$ delta) {\n@@ -470,1 +470,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -476,1 +476,1 @@\n-    private $type$ getAndAdd$Type$AcquireInternal(Scope scope, Object base, long offset, $type$ delta) {\n+    private $type$ getAndAdd$Type$AcquireInternal(ResourceScope scope, Object base, long offset, $type$ delta) {\n@@ -479,1 +479,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -488,1 +488,1 @@\n-    public $type$ getAndAdd$Type$Release(Scope scope, Object base, long offset, $type$ delta) {\n+    public $type$ getAndAdd$Type$Release(ResourceScope scope, Object base, long offset, $type$ delta) {\n@@ -491,1 +491,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -497,1 +497,1 @@\n-    private $type$ getAndAdd$Type$ReleaseInternal(Scope scope, Object base, long offset, $type$ delta) {\n+    private $type$ getAndAdd$Type$ReleaseInternal(ResourceScope scope, Object base, long offset, $type$ delta) {\n@@ -500,1 +500,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -511,1 +511,1 @@\n-    public $type$ getAndBitwiseOr$Type$(Scope scope, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseOr$Type$(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -514,1 +514,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -520,1 +520,1 @@\n-    private $type$ getAndBitwiseOr$Type$Internal(Scope scope, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseOr$Type$Internal(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -523,1 +523,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -532,1 +532,1 @@\n-    public $type$ getAndBitwiseOr$Type$Acquire(Scope scope, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseOr$Type$Acquire(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -535,1 +535,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -541,1 +541,1 @@\n-    private $type$ getAndBitwiseOr$Type$AcquireInternal(Scope scope, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseOr$Type$AcquireInternal(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -544,1 +544,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -553,1 +553,1 @@\n-    public $type$ getAndBitwiseOr$Type$Release(Scope scope, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseOr$Type$Release(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -556,1 +556,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -562,1 +562,1 @@\n-    private $type$ getAndBitwiseOr$Type$ReleaseInternal(Scope scope, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseOr$Type$ReleaseInternal(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -565,1 +565,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -574,1 +574,1 @@\n-    public $type$ getAndBitwiseAnd$Type$(Scope scope, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseAnd$Type$(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -577,1 +577,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -583,1 +583,1 @@\n-    private $type$ getAndBitwiseAnd$Type$Internal(Scope scope, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseAnd$Type$Internal(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -586,1 +586,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -595,1 +595,1 @@\n-    public $type$ getAndBitwiseAnd$Type$Acquire(Scope scope, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseAnd$Type$Acquire(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -598,1 +598,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -604,1 +604,1 @@\n-    private $type$ getAndBitwiseAnd$Type$AcquireInternal(Scope scope, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseAnd$Type$AcquireInternal(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -607,1 +607,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -616,1 +616,1 @@\n-    public $type$ getAndBitwiseAnd$Type$Release(Scope scope, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseAnd$Type$Release(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -619,1 +619,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -625,1 +625,1 @@\n-    private $type$ getAndBitwiseAnd$Type$ReleaseInternal(Scope scope, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseAnd$Type$ReleaseInternal(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -628,1 +628,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -637,1 +637,1 @@\n-    public $type$ getAndBitwiseXor$Type$(Scope scope, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseXor$Type$(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -640,1 +640,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -646,1 +646,1 @@\n-    private $type$ getAndBitwiseXor$Type$Internal(Scope scope, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseXor$Type$Internal(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -649,1 +649,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -658,1 +658,1 @@\n-    public $type$ getAndBitwiseXor$Type$Acquire(Scope scope, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseXor$Type$Acquire(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -661,1 +661,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -667,1 +667,1 @@\n-    private $type$ getAndBitwiseXor$Type$AcquireInternal(Scope scope, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseXor$Type$AcquireInternal(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -670,1 +670,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -679,1 +679,1 @@\n-    public $type$ getAndBitwiseXor$Type$Release(Scope scope, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseXor$Type$Release(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -682,1 +682,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -688,1 +688,1 @@\n-    private $type$ getAndBitwiseXor$Type$ReleaseInternal(Scope scope, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseXor$Type$ReleaseInternal(ResourceScope scope, Object base, long offset, $type$ value) {\n@@ -691,1 +691,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess-bin.java.template","additions":132,"deletions":132,"binary":false,"changes":264,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -39,1 +41,1 @@\n-import jdk.internal.access.foreign.MemorySegmentProxy;\n+import jdk.internal.foreign.ResourceScopeImpl;\n@@ -48,1 +50,1 @@\n- * class, accept one or more {@link Scope} parameter, which is used to validate as to whether access to memory\n+ * class accept one or more {@link ResourceScope} parameter, which is used to validate as to whether access to memory\n@@ -59,4 +61,3 @@\n- * {@link #closeScope(jdk.internal.misc.ScopedMemoryAccess.Scope)} method provided by this class. This method initiates\n- * thread-local handshakes with all the other VM threads, which are then stopped one by one. If any thread is found\n- * accessing memory that is associated to the very scope object being closed, that thread execution is asynchronously\n- * interrupted with a {@link Scope.ScopedAccessError}.\n+ * {@link ResourceScope#close()} method. This method initiates thread-local handshakes with all the other VM threads,\n+ * which are then stopped one by one. If any thread is found accessing memory that is associated to the very scope\n+ * object being closed, that thread execution is asynchronously interrupted with a {@link ScopedAccessError}.\n@@ -86,2 +87,2 @@\n-    public boolean closeScope(Scope scope) {\n-        return closeScope0(scope, Scope.ScopedAccessError.INSTANCE);\n+    public boolean closeScope(ResourceScope scope) {\n+        return closeScope0(scope, ScopedAccessError.INSTANCE);\n@@ -90,1 +91,1 @@\n-    native boolean closeScope0(Scope scope, Scope.ScopedAccessError exception);\n+    native boolean closeScope0(ResourceScope scope, ScopedAccessError exception);\n@@ -100,28 +101,3 @@\n-    \/**\n-     * Scope interface used during scoped memory access operations. A scope can be thought of as an object\n-     * which embodies the temporal checks associated with a given memory region.\n-     *\/\n-    public interface Scope {\n-\n-        void checkValidState();\n-\n-        Thread ownerThread();\n-\n-        void acquire0();\n-\n-        void release0();\n-\n-        \/**\n-         * Error thrown when memory access fails because the memory has already been released.\n-         * Note: for performance reasons, this exception is never created by client; instead a shared instance\n-         * is thrown (sometimes, this instance can be thrown asynchronously inside VM code). For this reason,\n-         * it is important for clients to always catch this exception and throw a regular exception instead\n-         * (which contains full stack information).\n-         *\/\n-        final class ScopedAccessError extends Error {\n-            private ScopedAccessError() {\n-                super(\"Attempt to access an already released memory resource\", null, false, false);\n-            }\n-            static final long serialVersionUID = 1L;\n-\n-            public static final ScopedAccessError INSTANCE = new ScopedAccessError();\n+    public final static class ScopedAccessError extends Error {\n+        private ScopedAccessError() {\n+            super(\"Attempt to access an already released memory resource\", null, false, false);\n@@ -129,0 +105,3 @@\n+        static final long serialVersionUID = 1L;\n+\n+        public static final ScopedAccessError INSTANCE = new ScopedAccessError();\n@@ -138,1 +117,1 @@\n-    public void copyMemory(Scope srcScope, Scope dstScope,\n+    public void copyMemory(ResourceScope srcScope, ResourceScope dstScope,\n@@ -144,1 +123,1 @@\n-          } catch (Scope.ScopedAccessError ex) {\n+          } catch (ScopedAccessError ex) {\n@@ -150,1 +129,1 @@\n-    private void copyMemoryInternal(Scope srcScope, Scope dstScope,\n+    private void copyMemoryInternal(ResourceScope srcScope, ResourceScope dstScope,\n@@ -156,1 +135,1 @@\n-                srcScope.checkValidState();\n+                ((ResourceScopeImpl)srcScope).checkValidState();\n@@ -159,1 +138,1 @@\n-                dstScope.checkValidState();\n+                ((ResourceScopeImpl)dstScope).checkValidState();\n@@ -169,1 +148,1 @@\n-    public void copySwapMemory(Scope srcScope, Scope dstScope,\n+    public void copySwapMemory(ResourceScope srcScope, ResourceScope dstScope,\n@@ -175,1 +154,1 @@\n-          } catch (Scope.ScopedAccessError ex) {\n+          } catch (ScopedAccessError ex) {\n@@ -181,1 +160,1 @@\n-    private void copySwapMemoryInternal(Scope srcScope, Scope dstScope,\n+    private void copySwapMemoryInternal(ResourceScope srcScope, ResourceScope dstScope,\n@@ -187,1 +166,1 @@\n-                srcScope.checkValidState();\n+                ((ResourceScopeImpl)srcScope).checkValidState();\n@@ -190,1 +169,1 @@\n-                dstScope.checkValidState();\n+                ((ResourceScopeImpl)dstScope).checkValidState();\n@@ -200,1 +179,1 @@\n-    public void setMemory(Scope scope, Object o, long offset, long bytes, byte value) {\n+    public void setMemory(ResourceScope scope, Object o, long offset, long bytes, byte value) {\n@@ -203,1 +182,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -209,1 +188,1 @@\n-    private void setMemoryInternal(Scope scope, Object o, long offset, long bytes, byte value) {\n+    private void setMemoryInternal(ResourceScope scope, Object o, long offset, long bytes, byte value) {\n@@ -212,1 +191,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -221,1 +200,1 @@\n-    public int vectorizedMismatch(Scope aScope, Scope bScope,\n+    public int vectorizedMismatch(ResourceScope aScope, ResourceScope bScope,\n@@ -228,1 +207,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -234,1 +213,1 @@\n-    private int vectorizedMismatchInternal(Scope aScope, Scope bScope,\n+    private int vectorizedMismatchInternal(ResourceScope aScope, ResourceScope bScope,\n@@ -241,1 +220,1 @@\n-                aScope.checkValidState();\n+                ((ResourceScopeImpl)aScope).checkValidState();\n@@ -244,1 +223,1 @@\n-                bScope.checkValidState();\n+                ((ResourceScopeImpl)bScope).checkValidState();\n@@ -254,1 +233,1 @@\n-    public boolean isLoaded(Scope scope, long address, boolean isSync, long size) {\n+    public boolean isLoaded(ResourceScope scope, long address, boolean isSync, long size) {\n@@ -257,1 +236,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -263,1 +242,1 @@\n-    public boolean isLoadedInternal(Scope scope, long address, boolean isSync, long size) {\n+    public boolean isLoadedInternal(ResourceScope scope, long address, boolean isSync, long size) {\n@@ -266,1 +245,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -275,1 +254,1 @@\n-    public void load(Scope scope, long address, boolean isSync, long size) {\n+    public void load(ResourceScope scope, long address, boolean isSync, long size) {\n@@ -278,1 +257,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -284,1 +263,1 @@\n-    public void loadInternal(Scope scope, long address, boolean isSync, long size) {\n+    public void loadInternal(ResourceScope scope, long address, boolean isSync, long size) {\n@@ -287,1 +266,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -296,1 +275,1 @@\n-    public void unload(Scope scope, long address, boolean isSync, long size) {\n+    public void unload(ResourceScope scope, long address, boolean isSync, long size) {\n@@ -299,1 +278,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -305,1 +284,1 @@\n-    public void unloadInternal(Scope scope, long address, boolean isSync, long size) {\n+    public void unloadInternal(ResourceScope scope, long address, boolean isSync, long size) {\n@@ -308,1 +287,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -317,1 +296,1 @@\n-    public void force(Scope scope, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n+    public void force(ResourceScope scope, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n@@ -320,1 +299,1 @@\n-        } catch (Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -326,1 +305,1 @@\n-    public void forceInternal(Scope scope, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n+    public void forceInternal(ResourceScope scope, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n@@ -329,1 +308,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -366,4 +345,4 @@\n-        static ScopedMemoryAccess.Scope scope(ByteBuffer bb) {\n-            MemorySegmentProxy segmentProxy = NIO_ACCESS.bufferSegment(bb);\n-            return segmentProxy != null ?\n-                    segmentProxy.scope() : null;\n+        static ResourceScope scope(ByteBuffer bb) {\n+            MemorySegment segment = NIO_ACCESS.bufferSegment(bb);\n+            return segment != null ?\n+                    segment.scope() : null;\n@@ -392,1 +371,1 @@\n-        } catch (ScopedMemoryAccess.Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -401,1 +380,1 @@\n-    V loadFromByteBufferScoped(ScopedMemoryAccess.Scope scope,\n+    V loadFromByteBufferScoped(ResourceScope scope,\n@@ -408,1 +387,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -436,1 +415,1 @@\n-        } catch (ScopedMemoryAccess.Scope.ScopedAccessError ex) {\n+        } catch (ScopedMemoryAccess.ScopedAccessError ex) {\n@@ -446,1 +425,1 @@\n-    V loadFromByteBufferMaskedScoped(ScopedMemoryAccess.Scope scope, Class<? extends V> vmClass,\n+    V loadFromByteBufferMaskedScoped(ResourceScope scope, Class<? extends V> vmClass,\n@@ -453,1 +432,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -479,1 +458,1 @@\n-        } catch (ScopedMemoryAccess.Scope.ScopedAccessError ex) {\n+        } catch (ScopedAccessError ex) {\n@@ -488,1 +467,1 @@\n-    void storeIntoByteBufferScoped(ScopedMemoryAccess.Scope scope,\n+    void storeIntoByteBufferScoped(ResourceScope scope,\n@@ -495,1 +474,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n@@ -524,1 +503,1 @@\n-        } catch (ScopedMemoryAccess.Scope.ScopedAccessError ex) {\n+        } catch (ScopedMemoryAccess.ScopedAccessError ex) {\n@@ -533,1 +512,1 @@\n-    void storeIntoByteBufferMaskedScoped(ScopedMemoryAccess.Scope scope,\n+    void storeIntoByteBufferMaskedScoped(ResourceScope scope,\n@@ -540,1 +519,1 @@\n-                scope.checkValidState();\n+                ((ResourceScopeImpl)scope).checkValidState();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":68,"deletions":89,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,0 +83,1 @@\n+    exports java.lang.foreign;\n@@ -140,2 +141,1 @@\n-        jdk.compiler,\n-        jdk.incubator.foreign;\n+        jdk.compiler;\n@@ -157,4 +157,1 @@\n-        jdk.net,\n-        jdk.incubator.foreign;\n-    exports jdk.internal.access.foreign to\n-        jdk.incubator.foreign;\n+        jdk.net;\n@@ -170,2 +167,1 @@\n-        java.naming,\n-        jdk.incubator.foreign;\n+        java.naming;\n@@ -209,2 +205,1 @@\n-        jdk.internal.vm.ci,\n-        jdk.incubator.foreign;\n+        jdk.internal.vm.ci;\n@@ -217,2 +212,1 @@\n-        jdk.jpackage,\n-        jdk.incubator.foreign;\n+        jdk.jpackage;\n@@ -227,2 +221,1 @@\n-        java.desktop,\n-        jdk.incubator.foreign;\n+        java.desktop;\n@@ -235,2 +228,1 @@\n-        jdk.unsupported,\n-        jdk.incubator.foreign;\n+        jdk.unsupported;\n@@ -244,1 +236,0 @@\n-        jdk.incubator.foreign,\n@@ -249,2 +240,0 @@\n-    exports jdk.internal.util to\n-            jdk.incubator.foreign;\n@@ -281,2 +270,1 @@\n-        jdk.sctp,\n-        jdk.incubator.foreign;\n+        jdk.sctp;\n@@ -301,2 +289,1 @@\n-        jdk.crypto.ec,\n-        jdk.incubator.foreign;\n+        jdk.crypto.ec;\n@@ -365,2 +352,0 @@\n-    exports jdk.internal.invoke to\n-        jdk.incubator.foreign;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":11,"deletions":26,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import jdk.internal.misc.ScopedMemoryAccess.Scope;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOUtil.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -40,1 +41,0 @@\n-import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -421,1 +421,1 @@\n-                                             boolean.class, MemorySegmentProxy.class});\n+                                             boolean.class, MemorySegment.class});\n@@ -470,1 +470,1 @@\n-                                             boolean.class, MemorySegmentProxy.class });\n+                                             boolean.class, MemorySegment.class });\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Util.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"","filename":"src\/java.base\/share\/native\/libsyslookup\/syslookup.c","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.incubator.foreign\/share\/native\/libsyslookup\/syslookup.c","status":"renamed"},{"patch":"","filename":"src\/java.base\/windows\/native\/libWinFallbackLookup\/WinFallbackLookup.c","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.incubator.foreign\/windows\/native\/libWinFallbackLookup\/WinFallbackLookup.c","status":"renamed"},{"patch":"@@ -1,459 +0,0 @@\n-\/*\n- *  Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.incubator.foreign;\n-\n-import jdk.internal.access.JavaLangInvokeAccess;\n-import jdk.internal.access.SharedSecrets;\n-import sun.invoke.util.Wrapper;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.invoke.VarHandle;\n-import java.util.List;\n-import java.util.Objects;\n-\n-\/**\n- * This class defines several factory methods for constructing and combining memory access var handles.\n- * Memory access var handles can be obtained using {@link MemoryHandles#varHandle(ValueLayout)}. The provided value layout\n- * determines the type, as well as the alignment constraint and the byte order associated with the memory access var handle.\n- * <p>\n- * The resulting memory access var handle can then be combined in various ways\n- * to emulate different addressing modes. The var handles created by this class feature a <em>mandatory<\/em> coordinate type\n- * (of type {@link MemorySegment}), and one {@code long} coordinate type, which represents the offset, in bytes, relative\n- * to the segment, at which dereference should occur.\n- * <p>\n- * As an example, consider the memory layout expressed by a {@link GroupLayout} instance constructed as follows:\n- * {@snippet lang=java :\n- * GroupLayout seq = MemoryLayout.structLayout(\n- *         MemoryLayout.paddingLayout(32),\n- *         ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withName(\"value\")\n- * );\n- * }\n- * To access the member layout named {@code value}, we can construct a memory access var handle as follows:\n- * {@snippet lang=java :\n- * VarHandle handle = MemoryHandles.varHandle(ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN)); \/\/(MemorySegment, long) -> int\n- * handle = MemoryHandles.insertCoordinates(handle, 1, 4); \/\/(MemorySegment) -> int\n- * }\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n- * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n- *\n- * <h2><a id=\"memaccess-mode\"><\/a>Alignment and access modes<\/h2>\n- *\n- * A memory access var handle is associated with an access size {@code S} and an alignment constraint {@code B}\n- * (both expressed in bytes). We say that a memory access operation is <em>fully aligned<\/em> if it occurs\n- * at a memory address {@code A} which is compatible with both alignment constraints {@code S} and {@code B}.\n- * If access is fully aligned then following access modes are supported and are\n- * guaranteed to support atomic access:\n- * <ul>\n- * <li>read write access modes for all {@code T}, with the exception of\n- *     access modes {@code get} and {@code set} for {@code long} and\n- *     {@code double} on 32-bit platforms.\n- * <li>atomic update access modes for {@code int}, {@code long},\n- *     {@code float}, {@code double} or {@link MemoryAddress}.\n- *     (Future major platform releases of the JDK may support additional\n- *     types for certain currently unsupported access modes.)\n- * <li>numeric atomic update access modes for {@code int}, {@code long} and {@link MemoryAddress}.\n- *     (Future major platform releases of the JDK may support additional\n- *     numeric types for certain currently unsupported access modes.)\n- * <li>bitwise atomic update access modes for {@code int}, {@code long} and {@link MemoryAddress}.\n- *     (Future major platform releases of the JDK may support additional\n- *     numeric types for certain currently unsupported access modes.)\n- * <\/ul>\n- *\n- * If {@code T} is {@code float}, {@code double} or {@link MemoryAddress} then atomic\n- * update access modes compare values using their bitwise representation\n- * (see {@link Float#floatToRawIntBits},\n- * {@link Double#doubleToRawLongBits} and {@link MemoryAddress#toRawLongValue()}, respectively).\n- * <p>\n- * Alternatively, a memory access operation is <em>partially aligned<\/em> if it occurs at a memory address {@code A}\n- * which is only compatible with the alignment constraint {@code B}; in such cases, access for anything other than the\n- * {@code get} and {@code set} access modes will result in an {@code IllegalStateException}. If access is partially aligned,\n- * atomic access is only guaranteed with respect to the largest power of two that divides the GCD of {@code A} and {@code S}.\n- * <p>\n- * Finally, in all other cases, we say that a memory access operation is <em>misaligned<\/em>; in such cases an\n- * {@code IllegalStateException} is thrown, irrespective of the access mode being used.\n- *\/\n-public final class MemoryHandles {\n-\n-    private static final JavaLangInvokeAccess JLI = SharedSecrets.getJavaLangInvokeAccess();\n-\n-    private MemoryHandles() {\n-        \/\/sorry, just the one!\n-    }\n-\n-    private static final MethodHandle INT_TO_BYTE;\n-    private static final MethodHandle BYTE_TO_UNSIGNED_INT;\n-    private static final MethodHandle INT_TO_SHORT;\n-    private static final MethodHandle SHORT_TO_UNSIGNED_INT;\n-    private static final MethodHandle LONG_TO_BYTE;\n-    private static final MethodHandle BYTE_TO_UNSIGNED_LONG;\n-    private static final MethodHandle LONG_TO_SHORT;\n-    private static final MethodHandle SHORT_TO_UNSIGNED_LONG;\n-    private static final MethodHandle LONG_TO_INT;\n-    private static final MethodHandle INT_TO_UNSIGNED_LONG;\n-\n-    static {\n-        try {\n-            INT_TO_BYTE = MethodHandles.explicitCastArguments(MethodHandles.identity(byte.class),\n-                    MethodType.methodType(byte.class, int.class));\n-            BYTE_TO_UNSIGNED_INT = MethodHandles.lookup().findStatic(Byte.class, \"toUnsignedInt\",\n-                    MethodType.methodType(int.class, byte.class));\n-            INT_TO_SHORT = MethodHandles.explicitCastArguments(MethodHandles.identity(short.class),\n-                    MethodType.methodType(short.class, int.class));\n-            SHORT_TO_UNSIGNED_INT = MethodHandles.lookup().findStatic(Short.class, \"toUnsignedInt\",\n-                    MethodType.methodType(int.class, short.class));\n-            LONG_TO_BYTE = MethodHandles.explicitCastArguments(MethodHandles.identity(byte.class),\n-                    MethodType.methodType(byte.class, long.class));\n-            BYTE_TO_UNSIGNED_LONG = MethodHandles.lookup().findStatic(Byte.class, \"toUnsignedLong\",\n-                    MethodType.methodType(long.class, byte.class));\n-            LONG_TO_SHORT = MethodHandles.explicitCastArguments(MethodHandles.identity(short.class),\n-                    MethodType.methodType(short.class, long.class));\n-            SHORT_TO_UNSIGNED_LONG = MethodHandles.lookup().findStatic(Short.class, \"toUnsignedLong\",\n-                    MethodType.methodType(long.class, short.class));\n-            LONG_TO_INT = MethodHandles.explicitCastArguments(MethodHandles.identity(int.class),\n-                    MethodType.methodType(int.class, long.class));\n-            INT_TO_UNSIGNED_LONG = MethodHandles.lookup().findStatic(Integer.class, \"toUnsignedLong\",\n-                    MethodType.methodType(long.class, int.class));\n-        } catch (Throwable ex) {\n-            throw new ExceptionInInitializerError(ex);\n-        }\n-    }\n-\n-    \/**\n-     * Creates a memory access var handle from given value layout. The provided layout will specify the\n-     * {@linkplain ValueLayout#carrier() carrier type}, the {@linkplain ValueLayout#byteSize() the byte size},\n-     * the {@linkplain ValueLayout#byteAlignment() byte alignment} and the {@linkplain ValueLayout#order() byte order}\n-     * associated to the returned var handle.\n-     *\n-     * The returned var handle's type is {@code carrier} and the list of coordinate types is\n-     * {@code (MemorySegment, long)}, where the {@code long} coordinate type corresponds to byte offset into\n-     * a given memory segment. The returned var handle accesses bytes at an offset in a given\n-     * memory segment, composing bytes to or from a value of the type {@code carrier} according to the given endianness;\n-     * the alignment constraint (in bytes) for the resulting memory access var handle is given by {@code alignmentBytes}.\n-     *\n-     * @apiNote the resulting var handle features certain <a href=\"#memaccess-mode\">access mode restrictions<\/a>,\n-     * which are common to all memory access var handles.\n-     *\n-     * @param layout the value layout for which a memory access handle is to be obtained.\n-     * @return the new memory access var handle.\n-     * @throws IllegalArgumentException if an illegal carrier type is used, or if {@code alignmentBytes} is not a power of two.\n-     *\/\n-    public static VarHandle varHandle(ValueLayout layout) {\n-        Objects.requireNonNull(layout);\n-        return layout.accessHandle();\n-    }\n-\n-    \/**\n-     * Adapts a target var handle by narrowing incoming values and widening\n-     * outgoing values, to and from the given type, respectively.\n-     * <p>\n-     * The returned var handle can be used to conveniently treat unsigned\n-     * primitive data types as if they were a wider signed primitive type. For\n-     * example, it is often convenient to model an <i>unsigned short<\/i> as a\n-     * Java {@code int} to avoid dealing with negative values, which would be\n-     * the case if modeled as a Java {@code short}. This is illustrated in the following example:\n-     * {@snippet lang=java :\n-     * MemorySegment segment = MemorySegment.allocateNative(2, ResourceScope.newImplicitScope());\n-     * VarHandle SHORT_VH = ValueLayout.JAVA_SHORT.varHandle();\n-     * VarHandle INT_VH = MemoryHandles.asUnsigned(SHORT_VH, int.class);\n-     * SHORT_VH.set(segment, (short)-1);\n-     * INT_VH.get(segment); \/\/ returns 65535\n-     * }\n-     * <p>\n-     * When calling e.g. {@link VarHandle#set(Object...)} on the resulting var\n-     * handle, the incoming value (of type {@code adaptedType}) is converted by a\n-     * <i>narrowing primitive conversion<\/i> and then passed to the {@code\n-     * target} var handle. A narrowing primitive conversion may lose information\n-     * about the overall magnitude of a numeric value. Conversely, when calling\n-     * e.g. {@link VarHandle#get(Object...)} on the resulting var handle, the\n-     * returned value obtained from the {@code target} var handle is converted\n-     * by a <i>unsigned widening conversion<\/i> before being returned to the\n-     * caller. In an unsigned widening conversion the high-order bits greater\n-     * than that of the {@code target} carrier type are zero, and the low-order\n-     * bits (equal to the width of the {@code target} carrier type) are equal to\n-     * the bits of the value obtained from the {@code target} var handle.\n-     * <p>\n-     * The returned var handle will feature the variable type {@code adaptedType},\n-     * and the same access coordinates, the same access modes (see {@link\n-     * java.lang.invoke.VarHandle.AccessMode}), and the same atomic access\n-     * guarantees, as those featured by the {@code target} var handle.\n-     *\n-     * @param target the memory access var handle to be adapted\n-     * @param adaptedType the adapted type\n-     * @return the adapted var handle.\n-     * @throws IllegalArgumentException if the carrier type of {@code target}\n-     * is not one of {@code byte}, {@code short}, or {@code int}; if {@code\n-     * adaptedType} is not one of {@code int}, or {@code long}; if the bit width\n-     * of the {@code adaptedType} is not greater than that of the {@code target}\n-     * carrier type.\n-     *\n-     * @jls 5.1.3 Narrowing Primitive Conversion\n-     *\/\n-    public static VarHandle asUnsigned(VarHandle target, final Class<?> adaptedType) {\n-        Objects.requireNonNull(target);\n-        Objects.requireNonNull(adaptedType);\n-        final Class<?> carrier = target.varType();\n-        checkWidenable(carrier);\n-        checkNarrowable(adaptedType);\n-        checkTargetWiderThanCarrier(carrier, adaptedType);\n-\n-        if (adaptedType == int.class && carrier == byte.class) {\n-            return filterValue(target, INT_TO_BYTE, BYTE_TO_UNSIGNED_INT);\n-        } else if (adaptedType == int.class && carrier == short.class) {\n-            return filterValue(target, INT_TO_SHORT, SHORT_TO_UNSIGNED_INT);\n-        } else if (adaptedType == long.class && carrier == byte.class) {\n-            return filterValue(target, LONG_TO_BYTE, BYTE_TO_UNSIGNED_LONG);\n-        } else if (adaptedType == long.class && carrier == short.class) {\n-            return filterValue(target, LONG_TO_SHORT, SHORT_TO_UNSIGNED_LONG);\n-        } else if (adaptedType == long.class && carrier == int.class) {\n-            return filterValue(target, LONG_TO_INT, INT_TO_UNSIGNED_LONG);\n-        } else {\n-            throw new InternalError(\"should not reach here\");\n-        }\n-    }\n-\n-    \/**\n-     * Adapts a target var handle by pre-processing incoming and outgoing values using a pair of filter functions.\n-     * <p>\n-     * When calling e.g. {@link VarHandle#set(Object...)} on the resulting var handle, the incoming value (of type {@code T}, where\n-     * {@code T} is the <em>last<\/em> parameter type of the first filter function) is processed using the first filter and then passed\n-     * to the target var handle.\n-     * Conversely, when calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, the return value obtained from\n-     * the target var handle (of type {@code T}, where {@code T} is the <em>last<\/em> parameter type of the second filter function)\n-     * is processed using the second filter and returned to the caller. More advanced access mode types, such as\n-     * {@link java.lang.invoke.VarHandle.AccessMode#COMPARE_AND_EXCHANGE} might apply both filters at the same time.\n-     * <p>\n-     * For the boxing and unboxing filters to be well-formed, their types must be of the form {@code (A... , S) -> T} and\n-     * {@code (A... , T) -> S}, respectively, where {@code T} is the type of the target var handle. If this is the case,\n-     * the resulting var handle will have type {@code S} and will feature the additional coordinates {@code A...} (which\n-     * will be appended to the coordinates of the target var handle).\n-     * <p>\n-     * If the boxing and unboxing filters throw any checked exceptions when invoked, the resulting var handle will\n-     * throw an {@link IllegalStateException}.\n-     * <p>\n-     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode}) and\n-     * atomic access guarantees as those featured by the target var handle.\n-     *\n-     * @param target the target var handle\n-     * @param filterToTarget a filter to convert some type {@code S} into the type of {@code target}\n-     * @param filterFromTarget a filter to convert the type of {@code target} to some type {@code S}\n-     * @return an adapter var handle which accepts a new type, performing the provided boxing\/unboxing conversions.\n-     * @throws IllegalArgumentException if {@code filterFromTarget} and {@code filterToTarget} are not well-formed, that is, they have types\n-     * other than {@code (A... , S) -> T} and {@code (A... , T) -> S}, respectively, where {@code T} is the type of the target var handle,\n-     * or if it's determined that either {@code filterFromTarget} or {@code filterToTarget} throws any checked exceptions.\n-     *\/\n-    public static VarHandle filterValue(VarHandle target, MethodHandle filterToTarget, MethodHandle filterFromTarget) {\n-        return JLI.filterValue(target, filterToTarget, filterFromTarget);\n-    }\n-\n-    \/**\n-     * Adapts a target var handle by pre-processing incoming coordinate values using unary filter functions.\n-     * <p>\n-     * When calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, the incoming coordinate values\n-     * starting at position {@code pos} (of type {@code C1, C2 ... Cn}, where {@code C1, C2 ... Cn} are the return type\n-     * of the unary filter functions) are transformed into new values (of type {@code S1, S2 ... Sn}, where {@code S1, S2 ... Sn} are the\n-     * parameter types of the unary filter functions), and then passed (along with any coordinate that was left unaltered\n-     * by the adaptation) to the target var handle.\n-     * <p>\n-     * For the coordinate filters to be well-formed, their types must be of the form {@code S1 -> T1, S2 -> T1 ... Sn -> Tn},\n-     * where {@code T1, T2 ... Tn} are the coordinate types starting at position {@code pos} of the target var handle.\n-     * <p>\n-     * If any of the filters throws a checked exception when invoked, the resulting var handle will\n-     * throw an {@link IllegalStateException}.\n-     * <p>\n-     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode}) and\n-     * atomic access guarantees as those featured by the target var handle.\n-     *\n-     * @param target the target var handle\n-     * @param pos the position of the first coordinate to be transformed\n-     * @param filters the unary functions which are used to transform coordinates starting at position {@code pos}\n-     * @return an adapter var handle which accepts new coordinate types, applying the provided transformation\n-     * to the new coordinate values.\n-     * @throws IllegalArgumentException if the handles in {@code filters} are not well-formed, that is, they have types\n-     * other than {@code S1 -> T1, S2 -> T2, ... Sn -> Tn} where {@code T1, T2 ... Tn} are the coordinate types starting\n-     * at position {@code pos} of the target var handle, if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive,\n-     * or if more filters are provided than the actual number of coordinate types available starting at {@code pos},\n-     * or if it's determined that any of the filters throws any checked exceptions.\n-     *\/\n-    public static VarHandle filterCoordinates(VarHandle target, int pos, MethodHandle... filters) {\n-        return JLI.filterCoordinates(target, pos, filters);\n-    }\n-\n-    \/**\n-     * Provides a target var handle with one or more <em>bound coordinates<\/em>\n-     * in advance of the var handle's invocation. As a consequence, the resulting var handle will feature less\n-     * coordinate types than the target var handle.\n-     * <p>\n-     * When calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, incoming coordinate values\n-     * are joined with bound coordinate values, and then passed to the target var handle.\n-     * <p>\n-     * For the bound coordinates to be well-formed, their types must be {@code T1, T2 ... Tn },\n-     * where {@code T1, T2 ... Tn} are the coordinate types starting at position {@code pos} of the target var handle.\n-     * <p>\n-     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode}) and\n-     * atomic access guarantees as those featured by the target var handle.\n-     *\n-     * @param target the var handle to invoke after the bound coordinates are inserted\n-     * @param pos the position of the first coordinate to be inserted\n-     * @param values the series of bound coordinates to insert\n-     * @return an adapter var handle which inserts an additional coordinates,\n-     *         before calling the target var handle\n-     * @throws IllegalArgumentException if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive,\n-     * or if more values are provided than the actual number of coordinate types available starting at {@code pos}.\n-     * @throws ClassCastException if the bound coordinates in {@code values} are not well-formed, that is, they have types\n-     * other than {@code T1, T2 ... Tn }, where {@code T1, T2 ... Tn} are the coordinate types starting at position {@code pos}\n-     * of the target var handle.\n-     *\/\n-    public static VarHandle insertCoordinates(VarHandle target, int pos, Object... values) {\n-        return JLI.insertCoordinates(target, pos, values);\n-    }\n-\n-    \/**\n-     * Provides a var handle which adapts the coordinate values of the target var handle, by re-arranging them\n-     * so that the new coordinates match the provided ones.\n-     * <p>\n-     * The given array controls the reordering.\n-     * Call {@code #I} the number of incoming coordinates (the value\n-     * {@code newCoordinates.size()}), and call {@code #O} the number\n-     * of outgoing coordinates (the number of coordinates associated with the target var handle).\n-     * Then the length of the reordering array must be {@code #O},\n-     * and each element must be a non-negative number less than {@code #I}.\n-     * For every {@code N} less than {@code #O}, the {@code N}-th\n-     * outgoing coordinate will be taken from the {@code I}-th incoming\n-     * coordinate, where {@code I} is {@code reorder[N]}.\n-     * <p>\n-     * No coordinate value conversions are applied.\n-     * The type of each incoming coordinate, as determined by {@code newCoordinates},\n-     * must be identical to the type of the corresponding outgoing coordinate\n-     * in the target var handle.\n-     * <p>\n-     * The reordering array need not specify an actual permutation.\n-     * An incoming coordinate will be duplicated if its index appears\n-     * more than once in the array, and an incoming coordinate will be dropped\n-     * if its index does not appear in the array.\n-     * <p>\n-     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode}) and\n-     * atomic access guarantees as those featured by the target var handle.\n-     * @param target the var handle to invoke after the coordinates have been reordered\n-     * @param newCoordinates the new coordinate types\n-     * @param reorder an index array which controls the reordering\n-     * @return an adapter var handle which re-arranges the incoming coordinate values,\n-     * before calling the target var handle\n-     * @throws IllegalArgumentException if the index array length is not equal to\n-     * the number of coordinates of the target var handle, or if any index array element is not a valid index for\n-     * a coordinate of {@code newCoordinates}, or if two corresponding coordinate types in\n-     * the target var handle and in {@code newCoordinates} are not identical.\n-     *\/\n-    public static VarHandle permuteCoordinates(VarHandle target, List<Class<?>> newCoordinates, int... reorder) {\n-        return JLI.permuteCoordinates(target, newCoordinates, reorder);\n-    }\n-\n-    \/**\n-     * Adapts a target var handle by pre-processing\n-     * a sub-sequence of its coordinate values with a filter (a method handle).\n-     * The pre-processed coordinates are replaced by the result (if any) of the\n-     * filter function and the target var handle is then called on the modified (usually shortened)\n-     * coordinate list.\n-     * <p>\n-     * If {@code R} is the return type of the filter (which cannot be void), the target var handle must accept a value of\n-     * type {@code R} as its coordinate in position {@code pos}, preceded and\/or followed by\n-     * any coordinate not passed to the filter.\n-     * No coordinates are reordered, and the result returned from the filter\n-     * replaces (in order) the whole subsequence of coordinates originally\n-     * passed to the adapter.\n-     * <p>\n-     * The argument types (if any) of the filter\n-     * replace zero or one coordinate types of the target var handle, at position {@code pos},\n-     * in the resulting adapted var handle.\n-     * The return type of the filter must be identical to the\n-     * coordinate type of the target var handle at position {@code pos}, and that target var handle\n-     * coordinate is supplied by the return value of the filter.\n-     * <p>\n-     * If any of the filters throws a checked exception when invoked, the resulting var handle will\n-     * throw an {@link IllegalStateException}.\n-     * <p>\n-     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode}) and\n-     * atomic access guarantees as those featured by the target var handle.\n-     *\n-     * @param target the var handle to invoke after the coordinates have been filtered\n-     * @param pos the position of the coordinate to be filtered\n-     * @param filter the filter method handle\n-     * @return an adapter var handle which filters the incoming coordinate values,\n-     * before calling the target var handle\n-     * @throws IllegalArgumentException if the return type of {@code filter}\n-     * is void, or it is not the same as the {@code pos} coordinate of the target var handle,\n-     * if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive,\n-     * if the resulting var handle's type would have <a href=\"MethodHandle.html#maxarity\">too many coordinates<\/a>,\n-     * or if it's determined that {@code filter} throws any checked exceptions.\n-     *\/\n-    public static VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle filter) {\n-        return JLI.collectCoordinates(target, pos, filter);\n-    }\n-\n-    \/**\n-     * Returns a var handle which will discard some dummy coordinates before delegating to the\n-     * target var handle. As a consequence, the resulting var handle will feature more\n-     * coordinate types than the target var handle.\n-     * <p>\n-     * The {@code pos} argument may range between zero and <i>N<\/i>, where <i>N<\/i> is the arity of the\n-     * target var handle's coordinate types. If {@code pos} is zero, the dummy coordinates will precede\n-     * the target's real arguments; if {@code pos} is <i>N<\/i> they will come after.\n-     * <p>\n-     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode}) and\n-     * atomic access guarantees as those featured by the target var handle.\n-     *\n-     * @param target the var handle to invoke after the dummy coordinates are dropped\n-     * @param pos position of first coordinate to drop (zero for the leftmost)\n-     * @param valueTypes the type(s) of the coordinate(s) to drop\n-     * @return an adapter var handle which drops some dummy coordinates,\n-     *         before calling the target var handle\n-     * @throws IllegalArgumentException if {@code pos} is not between 0 and the target var handle coordinate arity, inclusive.\n-     *\/\n-    public static VarHandle dropCoordinates(VarHandle target, int pos, Class<?>... valueTypes) {\n-        return JLI.dropCoordinates(target, pos, valueTypes);\n-    }\n-\n-    private static void checkWidenable(Class<?> carrier) {\n-        if (!(carrier == byte.class || carrier == short.class || carrier == int.class)) {\n-            throw new IllegalArgumentException(\"illegal carrier:\" + carrier.getSimpleName());\n-        }\n-    }\n-\n-    private static void checkNarrowable(Class<?> type) {\n-        if (!(type == int.class || type == long.class)) {\n-            throw new IllegalArgumentException(\"illegal adapter type: \" + type.getSimpleName());\n-        }\n-    }\n-\n-    private static void checkTargetWiderThanCarrier(Class<?> carrier, Class<?> target) {\n-        if (Wrapper.forPrimitiveType(target).bitWidth() <= Wrapper.forPrimitiveType(carrier).bitWidth()) {\n-            throw new IllegalArgumentException(\n-                    target.getSimpleName() + \" is not wider than: \" + carrier.getSimpleName());\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryHandles.java","additions":0,"deletions":459,"binary":false,"changes":459,"status":"deleted"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.incubator.foreign;\n-\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.foreign.ResourceScopeImpl;\n-import jdk.internal.reflect.CallerSensitive;\n-import jdk.internal.reflect.Reflection;\n-\n-import java.util.Objects;\n-import java.util.Optional;\n-\n-\/**\n- * A symbol lookup. Exposes a lookup operation for searching symbol addresses by name, see {@link SymbolLookup#lookup(String)}.\n- * A symbol lookup can be used to look up a symbol in a loaded library. Clients can obtain a {@linkplain #loaderLookup() loader lookup},\n- * which can be used to search symbols in libraries loaded by the current classloader (e.g. using {@link System#load(String)},\n- * or {@link System#loadLibrary(String)}).\n- * Alternatively, clients can search symbols in the standard C library using a {@link CLinker}, which conveniently\n- * implements this interface.\n- * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n- * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n- *\/\n-@FunctionalInterface\n-public interface SymbolLookup {\n-\n-    \/**\n-     * Looks up a symbol with given name in this lookup.\n-     *\n-     * @param name the symbol name.\n-     * @return the lookup symbol (if any).\n-     *\/\n-    Optional<NativeSymbol> lookup(String name);\n-\n-    \/**\n-     * Obtains a symbol lookup suitable to find symbols in native libraries associated with the caller's classloader\n-     * (that is, libraries loaded using {@link System#loadLibrary} or {@link System#load}). The returned lookup\n-     * returns native symbols backed by a non-closeable, shared scope which keeps the caller's classloader\n-     * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">reachable<\/a>.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @return a symbol lookup suitable to find symbols in libraries loaded by the caller's classloader.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    static SymbolLookup loaderLookup() {\n-        Class<?> caller = Reflection.getCallerClass();\n-        Reflection.ensureNativeAccess(caller);\n-        ClassLoader loader = Objects.requireNonNull(caller.getClassLoader());\n-        ResourceScope loaderScope = ResourceScopeImpl.heapScope(loader);\n-        return name -> {\n-            Objects.requireNonNull(name);\n-            JavaLangAccess javaLangAccess = SharedSecrets.getJavaLangAccess();\n-            MemoryAddress addr = MemoryAddress.ofLong(javaLangAccess.findNative(loader, name));\n-            return addr == MemoryAddress.NULL? Optional.empty() : Optional.of(NativeSymbol.ofAddress(name, addr, loaderScope));\n-        };\n-    }\n-\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SymbolLookup.java","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -1,232 +0,0 @@\n-\/*\n- *  Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-\/**\n- * <p> Classes to support low-level and efficient foreign memory\/function access, directly from Java.\n- *\n- * <h2>Foreign memory access<\/h2>\n- *\n- * <p>\n- * The main abstractions introduced to support foreign memory access is {@link jdk.incubator.foreign.MemorySegment}, which\n- * models a contiguous memory region, which can reside either inside or outside the Java heap.\n- * A memory segment represents the main access coordinate of a memory access var handle, which can be obtained\n- * using the combinator methods defined in the {@link jdk.incubator.foreign.MemoryHandles} class; a set of\n- * common dereference and copy operations is provided also by the {@link jdk.incubator.foreign.MemorySegment} class, which can\n- * be useful for simple, non-structured access. Finally, the {@link jdk.incubator.foreign.MemoryLayout} class\n- * hierarchy enables description of <em>memory layouts<\/em> and basic operations such as computing the size in bytes of a given\n- * layout, obtain its alignment requirements, and so on. Memory layouts also provide an alternate, more abstract way, to produce\n- * memory access var handles, e.g. using <a href=\"MemoryLayout.html#layout-paths\"><em>layout paths<\/em><\/a>.\n- *\n- * For example, to allocate an off-heap memory region big enough to hold 10 values of the primitive type {@code int}, and fill it with values\n- * ranging from {@code 0} to {@code 9}, we can use the following code:\n- *\n- * {@snippet lang=java :\n- * MemorySegment segment = MemorySegment.allocateNative(10 * 4, ResourceScope.newImplicitScope());\n- * for (int i = 0 ; i < 10 ; i++) {\n- *     segment.setAtIndex(ValueLayout.JAVA_INT, i, i);\n- * }\n- * }\n- *\n- * This code creates a <em>native<\/em> memory segment, that is, a memory segment backed by\n- * off-heap memory; the size of the segment is 40 bytes, enough to store 10 values of the primitive type {@code int}.\n- * Inside a loop, we then initialize the contents of the memory segment; note how the\n- * {@linkplain jdk.incubator.foreign.MemorySegment#setAtIndex(ValueLayout.OfInt, long, int) dereference method}\n- * accepts a {@linkplain jdk.incubator.foreign.ValueLayout value layout}, which specifies the size, alignment constraints,\n- * byte order as well as the Java type ({@code int}, in this case) associated with the dereference operation. More specifically,\n- * if we view the memory segment as a set of 10 adjacent slots, {@code s[i]}, where {@code 0 <= i < 10},\n- * where the size of each slot is exactly 4 bytes, the initialization logic above will set each slot\n- * so that {@code s[i] = i}, again where {@code 0 <= i < 10}.\n- *\n- * <h3><a id=\"deallocation\"><\/a>Deterministic deallocation<\/h3>\n- *\n- * When writing code that manipulates memory segments, especially if backed by memory which resides outside the Java heap, it is\n- * often crucial that the resources associated with a memory segment are released when the segment is no longer in use,\n- * and in a timely fashion. For this reason, there might be cases where waiting for the garbage collector to determine that a segment\n- * is <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a> is not optimal.\n- * Clients that operate under these assumptions might want to programmatically release the memory associated\n- * with a memory segment. This can be done, using the {@link jdk.incubator.foreign.ResourceScope} abstraction, as shown below:\n- *\n- * {@snippet lang=java :\n- * try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n- *     MemorySegment segment = MemorySegment.allocateNative(10 * 4, scope);\n- *     for (int i = 0 ; i < 10 ; i++) {\n- *         segment.setAtIndex(ValueLayout.JAVA_INT, i, i);\n- *     }\n- * }\n- * }\n- *\n- * This example is almost identical to the prior one; this time we first create a so called <em>resource scope<\/em>,\n- * which is used to <em>bind<\/em> the life-cycle of the segment created immediately afterwards. Note the use of the\n- * <em>try-with-resources<\/em> construct: this idiom ensures that all the memory resources associated with the segment will be released\n- * at the end of the block, according to the semantics described in Section {@jls 14.20.3} of <cite>The Java Language Specification<\/cite>.\n- *\n- * <h3><a id=\"safety\"><\/a>Safety<\/h3>\n- *\n- * This API provides strong safety guarantees when it comes to memory access. First, when dereferencing a memory segment,\n- * the access coordinates are validated (upon access), to make sure that access does not occur at any address which resides\n- * <em>outside<\/em> the boundaries of the memory segment used by the dereference operation. We call this guarantee <em>spatial safety<\/em>;\n- * in other words, access to memory segments is bounds-checked, in the same way as array access is, as described in\n- * Section {@jls 15.10.4} of <cite>The Java Language Specification<\/cite>.\n- * <p>\n- * Since memory segments can be closed (see above), segments are also validated (upon access) to make sure that\n- * the resource scope associated with the segment being accessed has not been closed prematurely.\n- * We call this guarantee <em>temporal safety<\/em>. Together, spatial and temporal safety ensure that each memory access\n- * operation either succeeds - and accesses a valid memory location - or fails.\n- *\n- * <h2>Foreign function access<\/h2>\n- * The key abstractions introduced to support foreign function access are {@link jdk.incubator.foreign.SymbolLookup},\n- * {@link jdk.incubator.foreign.MemoryAddress} and {@link jdk.incubator.foreign.CLinker}.\n- * The first is used to look up symbols inside native libraries; the second is used to model native addresses (more on that later),\n- * while the third provides linking capabilities which allows modelling foreign functions as {@link java.lang.invoke.MethodHandle} instances,\n- * so that clients can perform foreign function calls directly in Java, without the need for intermediate layers of native\n- * code (as is the case with the <a href=\"{@docRoot}\/..\/specs\/jni\/index.html\">Java Native Interface (JNI)<\/a>).\n- * <p>\n- * For example, to compute the length of a string using the C standard library function {@code strlen} on a Linux x64 platform,\n- * we can use the following code:\n- *\n- * {@snippet lang=java :\n- * var linker = CLinker.systemCLinker();\n- * MethodHandle strlen = linker.downcallHandle(\n- *     linker.lookup(\"strlen\").get(),\n- *     FunctionDescriptor.of(ValueLayout.JAVA_LONG, ValueLayout.ADDRESS)\n- * );\n- *\n- * try (var scope = ResourceScope.newConfinedScope()) {\n- *     var cString = MemorySegment.allocateNative(5 + 1, scope);\n- *     cString.setUtf8String(\"Hello\");\n- *     long len = (long)strlen.invoke(cString); \/\/ 5\n- * }\n- * }\n- *\n- * Here, we obtain a {@linkplain jdk.incubator.foreign.CLinker#systemCLinker() linker instance} and we use it\n- * to {@linkplain jdk.incubator.foreign.CLinker#lookup(java.lang.String) look up} the {@code strlen} symbol in the\n- * standard C library; a <em>downcall method handle<\/em> targeting said symbol is subsequently\n- * {@linkplain jdk.incubator.foreign.CLinker#downcallHandle(jdk.incubator.foreign.FunctionDescriptor) obtained}.\n- * To complete the linking successfully, we must provide a {@link jdk.incubator.foreign.FunctionDescriptor} instance,\n- * describing the signature of the {@code strlen} function.\n- * From this information, the linker will uniquely determine the sequence of steps which will turn\n- * the method handle invocation (here performed using {@link java.lang.invoke.MethodHandle#invoke(java.lang.Object...)})\n- * into a foreign function call, according to the rules specified by the platform C ABI.\n- * The {@link jdk.incubator.foreign.MemorySegment} class also provides many useful methods for\n- * interacting with native code, such as converting Java strings\n- * {@linkplain jdk.incubator.foreign.MemorySegment#setUtf8String(long, java.lang.String) into} native strings and\n- * {@linkplain jdk.incubator.foreign.MemorySegment#getUtf8String(long) back}, as demonstrated in the above example.\n- *\n- * <h3>Foreign addresses<\/h3>\n- *\n- * When a memory segment is created from Java code, the segment properties (spatial bounds, temporal bounds and confinement)\n- * are fully known at segment creation. But when interacting with native libraries, clients will often receive <em>raw<\/em> pointers.\n- * Such pointers have no spatial bounds. For example, the C type {@code char*} can refer to a single {@code char} value,\n- * or an array of {@code char} values, of given size. Nor do said pointers have any notion of temporal bounds or thread-confinement.\n- * <p>\n- * Raw pointers are modelled using the {@link jdk.incubator.foreign.MemoryAddress} class. When clients receive a\n- * memory address instance from a foreign function call, they can perform memory dereference on it directly,\n- * using one of the many <em>unsafe<\/em>\n- * {@linkplain jdk.incubator.foreign.MemoryAddress#get(jdk.incubator.foreign.ValueLayout.OfInt, long) dereference methods}\n- * provided:\n- *\n- * {@snippet lang=java :\n- * MemoryAddress addr = ... \/\/obtain address from native code\n- * int x = addr.get(ValueLayout.JAVA_INT, 0);\n- * }\n- *\n- * Alternatively, the client can\n- * {@linkplain jdk.incubator.foreign.MemorySegment#ofAddress(jdk.incubator.foreign.MemoryAddress, long, jdk.incubator.foreign.ResourceScope) create}\n- * a memory segment <em>unsafely<\/em>. This allows the client to inject extra knowledge about spatial bounds which might,\n- * for instance, be available in the documentation of the foreign function which produced the native address.\n- * Here is how an unsafe segment can be created from a native address:\n- *\n- * {@snippet lang=java :\n- * ResourceScope scope = ... \/\/ initialize a resource scope object\n- * MemoryAddress addr = ... \/\/obtain address from native code\n- * MemorySegment segment = MemorySegment.ofAddress(addr, 4, scope); \/\/ segment is 4 bytes long\n- * int x = segment.get(ValueLayout.JAVA_INT, 0);\n- * }\n- *\n- * <h3>Upcalls<\/h3>\n- * The {@link jdk.incubator.foreign.CLinker} interface also allows clients to turn an existing method handle (which might point\n- * to a Java method) into a memory address, so that Java code can effectively be passed to other foreign functions.\n- * For instance, we can write a method that compares two integer values, as follows:\n- *\n- * {@snippet lang=java :\n- * class IntComparator {\n- *     static int intCompare(MemoryAddress addr1, MemoryAddress addr2) {\n- *         return addr1.get(ValueLayout.JAVA_INT, 0) - addr2.get(ValueLayout.JAVA_INT, 0);\n- *     }\n- * }\n- * }\n- *\n- * The above method dereferences two memory addresses containing an integer value, and performs a simple comparison\n- * by returning the difference between such values. We can then obtain a method handle which targets the above static\n- * method, as follows:\n- *\n- * {@snippet lang=java :\n- * FunctionDescriptor intCompareDescriptor = FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.ADDRESS, ValueLayout.ADDRESS);\n- * MethodHandle intCompareHandle = MethodHandles.lookup().findStatic(IntComparator.class,\n- *                                                 \"intCompare\",\n- *                                                 CLinker.upcallType(comparFunction));\n- * }\n- *\n- * As before, we need to create a {@link jdk.incubator.foreign.FunctionDescriptor} instance, this time describing the signature\n- * of the function pointer we want to create. The descriptor can be used to\n- * {@linkplain jdk.incubator.foreign.CLinker#upcallType(jdk.incubator.foreign.FunctionDescriptor) derive} a method type\n- * that can be used to look up the method handle for {@code IntComparator.intCompare}.\n- * <p>\n- * Now that we have a method handle instance, we can turn it into a fresh function pointer,\n- * using the {@link jdk.incubator.foreign.CLinker} interface, as follows:\n- *\n- * {@snippet lang=java :\n- * ResourceScope scope = ...\n- * Addressable comparFunc = CLinker.systemCLinker().upcallStub(\n- *     intCompareHandle, intCompareDescriptor, scope);\n- * );\n- * }\n- *\n- * The {@link jdk.incubator.foreign.FunctionDescriptor} instance created in the previous step is then used to\n- * {@linkplain jdk.incubator.foreign.CLinker#upcallStub(java.lang.invoke.MethodHandle, jdk.incubator.foreign.FunctionDescriptor, jdk.incubator.foreign.ResourceScope) create}\n- * a new upcall stub; the layouts in the function descriptors allow the linker to determine the sequence of steps which\n- * allow foreign code to call the stub for {@code intCompareHandle} according to the rules specified by the platform C ABI.\n- * The lifecycle of the upcall stub returned by is tied to the {@linkplain jdk.incubator.foreign.ResourceScope resource scope}\n- * provided when the upcall stub is created. This same scope is made available by the {@link jdk.incubator.foreign.NativeSymbol}\n- * instance returned by that method.\n- *\n- * <a id=\"restricted\"><\/a>\n- * <h2>Restricted methods<\/h2>\n- * Some methods in this package are considered <em>restricted<\/em>. Restricted methods are typically used to bind native\n- * foreign data and\/or functions to first-class Java API elements which can then be used directly by clients. For instance\n- * the restricted method {@link MemorySegment#ofAddress(MemoryAddress, long, ResourceScope)}\n- * can be used to create a fresh segment with given spatial bounds out of a native address.\n- * <p>\n- * Binding foreign data and\/or functions is generally unsafe and, if done incorrectly, can result in VM crashes, or memory corruption when the bound Java API element is accessed.\n- * For instance, in the case of {@link MemorySegment#ofAddress(MemoryAddress, long, ResourceScope)},\n- * if the provided spatial bounds are incorrect, a client of the segment returned by that method might crash the VM, or corrupt\n- * memory when attempting to dereference said segment. For these reasons, it is crucial for code that calls a restricted method\n- * to never pass arguments that might cause incorrect binding of foreign data and\/or functions to a Java API.\n- * <p>\n- * Access to restricted methods is <em>disabled<\/em> by default; to enable restricted methods, the command line option\n- * {@code --enable-native-access} must mention the name of the caller's module.\n- *\/\n-package jdk.incubator.foreign;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":0,"deletions":232,"binary":false,"changes":232,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.internal.foreign;\n-\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.internal.misc.ScopedMemoryAccess;\n-\n-public record NativeSymbolImpl(String name, MemoryAddress address, ResourceScope scope) implements NativeSymbol, Scoped {\n-    @Override\n-    public MemoryAddress address() {\n-        ((ResourceScopeImpl)scope).checkValidStateSlow();\n-        return address;\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeSymbolImpl.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,179 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.foreign;\n-\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SymbolLookup;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.internal.loader.NativeLibraries;\n-import jdk.internal.loader.NativeLibrary;\n-\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.function.Function;\n-\n-import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n-\n-public class SystemLookup implements SymbolLookup {\n-\n-    private SystemLookup() { }\n-\n-    static final SystemLookup INSTANCE = new SystemLookup();\n-\n-    \/*\n-     * On POSIX systems, dlsym will allow us to lookup symbol in library dependencies; the same trick doesn't work\n-     * on Windows. For this reason, on Windows we do not generate any side-library, and load msvcrt.dll directly instead.\n-     *\/\n-    private static final SymbolLookup syslookup = switch (CABI.current()) {\n-        case SysV, LinuxAArch64, MacOsAArch64 -> libLookup(libs -> libs.loadLibrary(\"syslookup\"));\n-        case Win64 -> makeWindowsLookup(); \/\/ out of line to workaround javac crash\n-    };\n-\n-    private static SymbolLookup makeWindowsLookup() {\n-        Path system32 = Path.of(System.getenv(\"SystemRoot\"), \"System32\");\n-        Path ucrtbase = system32.resolve(\"ucrtbase.dll\");\n-        Path msvcrt = system32.resolve(\"msvcrt.dll\");\n-\n-        boolean useUCRT = Files.exists(ucrtbase);\n-        Path stdLib = useUCRT ? ucrtbase : msvcrt;\n-        SymbolLookup lookup = libLookup(libs -> libs.loadLibrary(null, stdLib.toFile()));\n-\n-        if (useUCRT) {\n-            \/\/ use a fallback lookup to look up inline functions from fallback lib\n-\n-            SymbolLookup fallbackLibLookup = libLookup(libs -> libs.loadLibrary(\"WinFallbackLookup\"));\n-\n-            int numSymbols = WindowsFallbackSymbols.values().length;\n-            MemorySegment funcs = MemorySegment.ofAddress(fallbackLibLookup.lookup(\"funcs\").orElseThrow().address(),\n-                ADDRESS.byteSize() * numSymbols, ResourceScope.globalScope());\n-\n-            SymbolLookup fallbackLookup = name -> Optional.ofNullable(WindowsFallbackSymbols.valueOfOrNull(name))\n-                .map(symbol -> NativeSymbol.ofAddress(symbol.name(), funcs.getAtIndex(ADDRESS, symbol.ordinal()), ResourceScope.globalScope()));\n-\n-            final SymbolLookup finalLookup = lookup;\n-            lookup = name -> finalLookup.lookup(name).or(() -> fallbackLookup.lookup(name));\n-        }\n-\n-        return lookup;\n-    }\n-\n-    private static SymbolLookup libLookup(Function<NativeLibraries, NativeLibrary> loader) {\n-        NativeLibrary lib = loader.apply(NativeLibraries.rawNativeLibraries(SystemLookup.class, false));\n-        return name -> {\n-            Objects.requireNonNull(name);\n-            try {\n-                long addr = lib.lookup(name);\n-                return addr == 0 ?\n-                        Optional.empty() :\n-                        Optional.of(NativeSymbol.ofAddress(name, MemoryAddress.ofLong(addr), ResourceScope.globalScope()));\n-            } catch (NoSuchMethodException e) {\n-                return Optional.empty();\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public Optional<NativeSymbol> lookup(String name) {\n-        return syslookup.lookup(name);\n-    }\n-\n-    public static SystemLookup getInstance() {\n-        return INSTANCE;\n-    }\n-\n-    \/\/ fallback symbols missing from ucrtbase.dll\n-    \/\/ this list has to be kept in sync with the table in the companion native library\n-    private enum WindowsFallbackSymbols {\n-        \/\/ stdio\n-        fprintf,\n-        fprintf_s,\n-        fscanf,\n-        fscanf_s,\n-        fwprintf,\n-        fwprintf_s,\n-        fwscanf,\n-        fwscanf_s,\n-        printf,\n-        printf_s,\n-        scanf,\n-        scanf_s,\n-        snprintf,\n-        sprintf,\n-        sprintf_s,\n-        sscanf,\n-        sscanf_s,\n-        swprintf,\n-        swprintf_s,\n-        swscanf,\n-        swscanf_s,\n-        vfprintf,\n-        vfprintf_s,\n-        vfscanf,\n-        vfscanf_s,\n-        vfwprintf,\n-        vfwprintf_s,\n-        vfwscanf,\n-        vfwscanf_s,\n-        vprintf,\n-        vprintf_s,\n-        vscanf,\n-        vscanf_s,\n-        vsnprintf,\n-        vsnprintf_s,\n-        vsprintf,\n-        vsprintf_s,\n-        vsscanf,\n-        vsscanf_s,\n-        vswprintf,\n-        vswprintf_s,\n-        vswscanf,\n-        vswscanf_s,\n-        vwprintf,\n-        vwprintf_s,\n-        vwscanf,\n-        vwscanf_s,\n-        wprintf,\n-        wprintf_s,\n-        wscanf,\n-        wscanf_s,\n-\n-        \/\/ time\n-        gmtime\n-        ;\n-\n-        static WindowsFallbackSymbols valueOfOrNull(String name) {\n-            try {\n-                return valueOf(name);\n-            } catch (IllegalArgumentException e) {\n-                return null;\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":0,"deletions":179,"binary":false,"changes":179,"status":"deleted"},{"patch":"@@ -1,188 +0,0 @@\n-\/*\n- *  Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package jdk.internal.foreign;\n-\n-import jdk.incubator.foreign.*;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.access.foreign.MemorySegmentProxy;\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.invoke.VarHandle;\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.function.Supplier;\n-\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n-import static sun.security.action.GetPropertyAction.*;\n-\n-\/**\n- * This class contains misc helper functions to support creation of memory segments.\n- *\/\n-public final class Utils {\n-    \/\/ used when testing invoke exact behavior of memory access handles\n-    private static final boolean SHOULD_ADAPT_HANDLES\n-        = Boolean.parseBoolean(privilegedGetProperty(\"jdk.internal.foreign.SHOULD_ADAPT_HANDLES\", \"true\"));\n-\n-    private static final MethodHandle SEGMENT_FILTER;\n-    private static final MethodHandle BYTE_TO_BOOL;\n-    private static final MethodHandle BOOL_TO_BYTE;\n-    private static final MethodHandle ADDRESS_TO_LONG;\n-    private static final MethodHandle LONG_TO_ADDRESS;\n-    public static final MethodHandle MH_bitsToBytesOrThrowForOffset;\n-\n-    public static final Supplier<RuntimeException> bitsToBytesThrowOffset\n-        = () -> new UnsupportedOperationException(\"Cannot compute byte offset; bit offset is not a multiple of 8\");\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            SEGMENT_FILTER = lookup.findStatic(Utils.class, \"filterSegment\",\n-                    MethodType.methodType(MemorySegmentProxy.class, MemorySegment.class));\n-            BYTE_TO_BOOL = lookup.findStatic(Utils.class, \"byteToBoolean\",\n-                    MethodType.methodType(boolean.class, byte.class));\n-            BOOL_TO_BYTE = lookup.findStatic(Utils.class, \"booleanToByte\",\n-                    MethodType.methodType(byte.class, boolean.class));\n-            ADDRESS_TO_LONG = lookup.findVirtual(MemoryAddress.class, \"toRawLongValue\",\n-                    MethodType.methodType(long.class));\n-            LONG_TO_ADDRESS = lookup.findStatic(MemoryAddress.class, \"ofLong\",\n-                    MethodType.methodType(MemoryAddress.class, long.class));\n-            MH_bitsToBytesOrThrowForOffset = MethodHandles.insertArguments(\n-                lookup.findStatic(Utils.class, \"bitsToBytesOrThrow\",\n-                    MethodType.methodType(long.class, long.class, Supplier.class)),\n-                1,\n-                bitsToBytesThrowOffset);\n-        } catch (Throwable ex) {\n-            throw new ExceptionInInitializerError(ex);\n-        }\n-    }\n-\n-    public static long alignUp(long n, long alignment) {\n-        return (n + alignment - 1) & -alignment;\n-    }\n-\n-    public static MemoryAddress alignUp(MemoryAddress ma, long alignment) {\n-        long offset = ma.toRawLongValue();\n-        return ma.addOffset(alignUp(offset, alignment) - offset);\n-    }\n-\n-    public static MemorySegment alignUp(MemorySegment ms, long alignment) {\n-        long offset = ms.address().toRawLongValue();\n-        return ms.asSlice(alignUp(offset, alignment) - offset);\n-    }\n-\n-    public static long bitsToBytesOrThrow(long bits, Supplier<RuntimeException> exFactory) {\n-        if (Utils.isAligned(bits, 8)) {\n-            return bits \/ 8;\n-        } else {\n-            throw exFactory.get();\n-        }\n-    }\n-\n-    public static VarHandle makeMemoryAccessVarHandle(ValueLayout layout, boolean skipAlignmentCheck) {\n-        class VarHandleCache {\n-            private static final Map<ValueLayout, VarHandle> handleMap = new ConcurrentHashMap<>();\n-            private static final Map<ValueLayout, VarHandle> handleMapNoAlignCheck = new ConcurrentHashMap<>();\n-\n-            static VarHandle put(ValueLayout layout, VarHandle handle, boolean skipAlignmentCheck) {\n-                VarHandle prev = (skipAlignmentCheck ? handleMapNoAlignCheck : handleMap).putIfAbsent(layout, handle);\n-                return prev != null ? prev : handle;\n-            }\n-        }\n-        Class<?> baseCarrier = layout.carrier();\n-        if (layout.carrier() == MemoryAddress.class) {\n-            baseCarrier = switch ((int) ValueLayout.ADDRESS.byteSize()) {\n-                case 8 -> long.class;\n-                case 4 -> int.class;\n-                default -> throw new UnsupportedOperationException(\"Unsupported address layout\");\n-            };\n-        } else if (layout.carrier() == boolean.class) {\n-            baseCarrier = byte.class;\n-        }\n-\n-        VarHandle handle = SharedSecrets.getJavaLangInvokeAccess().memoryAccessVarHandle(baseCarrier, skipAlignmentCheck,\n-                layout.byteAlignment() - 1, layout.order());\n-\n-        \/\/ This adaptation is required, otherwise the memory access var handle will have type MemorySegmentProxy,\n-        \/\/ and not MemorySegment (which the user expects), which causes performance issues with asType() adaptations.\n-        handle = SHOULD_ADAPT_HANDLES\n-            ? MemoryHandles.filterCoordinates(handle, 0, SEGMENT_FILTER)\n-            : handle;\n-        if (layout.carrier() == boolean.class) {\n-            handle = MemoryHandles.filterValue(handle, BOOL_TO_BYTE, BYTE_TO_BOOL);\n-        } else if (layout.carrier() == MemoryAddress.class) {\n-            handle = MemoryHandles.filterValue(handle,\n-                    MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(baseCarrier, MemoryAddress.class)),\n-                    MethodHandles.explicitCastArguments(LONG_TO_ADDRESS, MethodType.methodType(MemoryAddress.class, baseCarrier)));\n-        }\n-        return VarHandleCache.put(layout, handle, skipAlignmentCheck);\n-    }\n-\n-    private static MemorySegmentProxy filterSegment(MemorySegment segment) {\n-        return (AbstractMemorySegmentImpl)segment;\n-    }\n-\n-    private static boolean byteToBoolean(byte b) {\n-        return b != 0;\n-    }\n-\n-    private static byte booleanToByte(boolean b) {\n-        return b ? (byte)1 : (byte)0;\n-    }\n-\n-    public static void copy(MemorySegment addr, byte[] bytes) {\n-        var heapSegment = MemorySegment.ofArray(bytes);\n-        addr.copyFrom(heapSegment);\n-        addr.set(JAVA_BYTE, bytes.length, (byte)0);\n-    }\n-\n-    public static MemorySegment toCString(byte[] bytes, SegmentAllocator allocator) {\n-        MemorySegment addr = allocator.allocate(bytes.length + 1, 1L);\n-        copy(addr, bytes);\n-        return addr;\n-    }\n-\n-    @ForceInline\n-    public static long scaleOffset(MemorySegment segment, long index, long size) {\n-        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n-        return MemorySegmentProxy.multiplyOffsets(index, (int)size, (AbstractMemorySegmentImpl)segment);\n-    }\n-\n-    @ForceInline\n-    public static boolean isAligned(long offset, long align) {\n-        return (offset & (align - 1)) == 0;\n-    }\n-\n-    @ForceInline\n-    public static void checkElementAlignment(MemoryLayout layout, String msg) {\n-        if (layout.byteAlignment() > layout.byteSize()) {\n-            throw new IllegalArgumentException(msg);\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":0,"deletions":188,"binary":false,"changes":188,"status":"deleted"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019, 2021, Arm Limited. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.foreign.abi.aarch64.linux;\n-\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.VaList;\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.abi.aarch64.CallArranger;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-\n-\/**\n- * ABI implementation based on ARM document \"Procedure Call Standard for\n- * the ARM 64-bit Architecture\".\n- *\/\n-public final class LinuxAArch64Linker implements CLinker {\n-    private static LinuxAArch64Linker instance;\n-\n-    static final long ADDRESS_SIZE = 64; \/\/ bits\n-\n-    public static LinuxAArch64Linker getInstance() {\n-        if (instance == null) {\n-            instance = new LinuxAArch64Linker();\n-        }\n-        return instance;\n-    }\n-\n-    @Override\n-    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n-        Objects.requireNonNull(function);\n-        MethodType type = SharedUtils.inferMethodType(function, false);\n-        MethodHandle handle = CallArranger.LINUX.arrangeDowncall(type, function);\n-        handle = SharedUtils.maybeInsertAllocator(handle);\n-        return SharedUtils.wrapDowncall(handle, function);\n-    }\n-\n-    @Override\n-    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n-        Objects.requireNonNull(scope);\n-        Objects.requireNonNull(target);\n-        Objects.requireNonNull(function);\n-        SharedUtils.checkExceptions(target);\n-        MethodType type = SharedUtils.inferMethodType(function, true);\n-        if (!type.equals(target.type())) {\n-            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n-        }\n-        return CallArranger.LINUX.arrangeUpcall(target, target.type(), function, scope);\n-    }\n-\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n-        LinuxAArch64VaList.Builder builder = LinuxAArch64VaList.builder(scope);\n-        actions.accept(builder);\n-        return builder.build();\n-    }\n-\n-    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n-        return LinuxAArch64VaList.ofAddress(ma, scope);\n-    }\n-\n-    public static VaList emptyVaList() {\n-        return LinuxAArch64VaList.empty();\n-    }\n-\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2021, Arm Limited. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.foreign.abi.aarch64.macos;\n-\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.VaList;\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.abi.aarch64.CallArranger;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-\n-\/**\n- * ABI implementation for macOS on Apple silicon. Based on AAPCS with\n- * changes to va_list and passing arguments on the stack.\n- *\/\n-public final class MacOsAArch64Linker implements CLinker {\n-    private static MacOsAArch64Linker instance;\n-\n-    static final long ADDRESS_SIZE = 64; \/\/ bits\n-\n-    public static MacOsAArch64Linker getInstance() {\n-        if (instance == null) {\n-            instance = new MacOsAArch64Linker();\n-        }\n-        return instance;\n-    }\n-\n-    @Override\n-    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n-        Objects.requireNonNull(function);\n-        MethodType type = SharedUtils.inferMethodType(function, false);\n-        MethodHandle handle = CallArranger.MACOS.arrangeDowncall(type, function);\n-        handle = SharedUtils.maybeInsertAllocator(handle);\n-        return SharedUtils.wrapDowncall(handle, function);\n-    }\n-\n-    @Override\n-    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n-        Objects.requireNonNull(scope);\n-        Objects.requireNonNull(target);\n-        Objects.requireNonNull(function);\n-        MethodType type = SharedUtils.inferMethodType(function, true);\n-        if (!type.equals(target.type())) {\n-            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n-        }\n-        return CallArranger.MACOS.arrangeUpcall(target, target.type(), function, scope);\n-    }\n-\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n-        MacOsAArch64VaList.Builder builder = MacOsAArch64VaList.builder(scope);\n-        actions.accept(builder);\n-        return builder.build();\n-    }\n-\n-    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n-        return MacOsAArch64VaList.ofAddress(ma, scope);\n-    }\n-\n-    public static VaList emptyVaList() {\n-        return MacOsAArch64VaList.empty();\n-    }\n-\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.foreign.abi.x64.windows;\n-\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.VaList;\n-import jdk.internal.foreign.abi.SharedUtils;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-\n-\/**\n- * ABI implementation based on Windows ABI AMD64 supplement v.0.99.6\n- *\/\n-public final class Windowsx64Linker implements CLinker {\n-\n-    public static final int MAX_INTEGER_ARGUMENT_REGISTERS = 4;\n-    public static final int MAX_INTEGER_RETURN_REGISTERS = 1;\n-    public static final int MAX_VECTOR_ARGUMENT_REGISTERS = 4;\n-    public static final int MAX_VECTOR_RETURN_REGISTERS = 1;\n-    public static final int MAX_REGISTER_ARGUMENTS = 4;\n-    public static final int MAX_REGISTER_RETURNS = 1;\n-\n-    private static Windowsx64Linker instance;\n-\n-    static final long ADDRESS_SIZE = 64; \/\/ bits\n-\n-    public static Windowsx64Linker getInstance() {\n-        if (instance == null) {\n-            instance = new Windowsx64Linker();\n-        }\n-        return instance;\n-    }\n-\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n-        WinVaList.Builder builder = WinVaList.builder(scope);\n-        actions.accept(builder);\n-        return builder.build();\n-    }\n-\n-    @Override\n-    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n-        Objects.requireNonNull(function);\n-        MethodType type = SharedUtils.inferMethodType(function, false);\n-        MethodHandle handle = CallArranger.arrangeDowncall(type, function);\n-        handle = SharedUtils.maybeInsertAllocator(handle);\n-        return SharedUtils.wrapDowncall(handle, function);\n-    }\n-\n-    @Override\n-    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n-        Objects.requireNonNull(scope);\n-        Objects.requireNonNull(target);\n-        Objects.requireNonNull(function);\n-        SharedUtils.checkExceptions(target);\n-        MethodType type = SharedUtils.inferMethodType(function, true);\n-        if (!type.equals(target.type())) {\n-            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n-        }\n-        return CallArranger.arrangeUpcall(target, target.type(), function, scope);\n-    }\n-\n-    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n-        return WinVaList.ofAddress(ma, scope);\n-    }\n-\n-    public static VaList emptyVaList() {\n-        return WinVaList.empty();\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * Defines an API for accessing foreign memory and calling foreign functions, directly from Java.\n- *\n- * {@Incubating}\n- *\n- * @moduleGraph\n- *\/\n-module jdk.incubator.foreign {\n-    exports jdk.incubator.foreign;\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/module-info.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2021, 2022, Red Hat, Inc. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -33,2 +34,0 @@\n- * @modules jdk.incubator.foreign\n- *\n@@ -40,4 +39,2 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.SymbolLookup;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n@@ -45,0 +42,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -53,2 +51,1 @@\n-    static final SymbolLookup lookup = SymbolLookup.loaderLookup();\n-    final static MethodHandle foo = abi.downcallHandle(lookup.lookup(\"foo\").get(),\n+    final static MethodHandle foo = abi.downcallHandle(TestLinkToNativeRBP.class.getClassLoader().findNative(\"foo\").get(),\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestLinkToNativeRBP.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,11 +25,11 @@\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.GroupLayout;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SegmentAllocator;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ValueLayout;\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,9 +25,7 @@\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SegmentAllocator;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ValueLayout;\n@@ -111,0 +109,4 @@\n+\n+    public static NativeSymbol findNativeOrThrow(Class<?> clazz, String name) {\n+        return clazz.getClassLoader().findNative(name).orElseThrow();\n+    }\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -30,8 +31,7 @@\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.SymbolLookup;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -43,1 +43,1 @@\n-import jdk.incubator.foreign.VaList;\n+import java.lang.foreign.VaList;\n@@ -57,2 +57,0 @@\n-    static final SymbolLookup LOOKUP = SymbolLookup.loaderLookup();\n-\n@@ -67,1 +65,1 @@\n-                LOOKUP.lookup(\"struct_func\").get(),\n+                findNativeOrThrow(SafeFunctionAccessTest.class,\"struct_func\"),\n@@ -76,1 +74,1 @@\n-                LOOKUP.lookup(\"addr_func_6\").get(),\n+                findNativeOrThrow(SafeFunctionAccessTest.class, \"addr_func_6\"),\n@@ -118,1 +116,1 @@\n-                LOOKUP.lookup(\"addr_func\").get(),\n+                findNativeOrThrow(SafeFunctionAccessTest.class, \"addr_func\"),\n@@ -133,1 +131,1 @@\n-                LOOKUP.lookup(\"addr_func\").get(),\n+                findNativeOrThrow(SafeFunctionAccessTest.class, \"addr_func\"),\n@@ -144,1 +142,1 @@\n-                LOOKUP.lookup(\"addr_func_cb\").get(),\n+                findNativeOrThrow(SafeFunctionAccessTest.class, \"addr_func_cb\"),\n@@ -156,1 +154,1 @@\n-                LOOKUP.lookup(\"addr_func_cb\").get(),\n+                findNativeOrThrow(SafeFunctionAccessTest.class, \"addr_func_cb\"),\n@@ -168,1 +166,1 @@\n-                LOOKUP.lookup(\"addr_func_cb\").get(),\n+                findNativeOrThrow(SafeFunctionAccessTest.class, \"addr_func_cb\"),\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":17,"deletions":19,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -48,1 +49,1 @@\n-import jdk.incubator.foreign.*;\n+import java.lang.foreign.*;\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,25 +0,0 @@\n-#\n-# Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n-#  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-#  This code is free software; you can redistribute it and\/or modify it\n-#  under the terms of the GNU General Public License version 2 only, as\n-#  published by the Free Software Foundation.\n-#\n-#  This code is distributed in the hope that it will be useful, but WITHOUT\n-#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-#  version 2 for more details (a copy is included in the LICENSE file that\n-#  accompanied this code).\n-#\n-#  You should have received a copy of the GNU General Public License version\n-#  2 along with this work; if not, write to the Free Software Foundation,\n-#  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-#   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-#  or visit www.oracle.com if you need additional information or have any\n-#  questions.\n-#\n-#\n-\n-modules = jdk.incubator.foreign\n","filename":"test\/jdk\/java\/foreign\/TEST.properties","additions":0,"deletions":25,"binary":false,"changes":25,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -33,5 +34,4 @@\n-import jdk.incubator.foreign.MemoryHandles;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.ValueLayout;\n@@ -100,1 +100,1 @@\n-        VarHandle i2SHandle = MemoryHandles.filterValue(intHandle, S2I, I2S);\n+        VarHandle i2SHandle = MethodHandles.filterValue(intHandle, S2I, I2S);\n@@ -120,2 +120,2 @@\n-        VarHandle i2SHandle = MemoryHandles.filterValue(intHandle, CTX_S2I, CTX_I2S);\n-        i2SHandle = MemoryHandles.insertCoordinates(i2SHandle, 1, \"a\", \"b\");\n+        VarHandle i2SHandle = MethodHandles.filterValue(intHandle, CTX_S2I, CTX_I2S);\n+        i2SHandle = MethodHandles.insertCoordinates(i2SHandle, 1, \"a\", \"b\");\n@@ -140,1 +140,1 @@\n-        VarHandle i2SHandle = MemoryHandles.filterValue(intHandle, O2I, I2O);\n+        VarHandle i2SHandle = MethodHandles.filterValue(intHandle, O2I, I2O);\n@@ -156,1 +156,1 @@\n-        MemoryHandles.filterValue(floatHandle, S2I, I2S);\n+        MethodHandles.filterValue(floatHandle, S2I, I2S);\n@@ -162,1 +162,1 @@\n-        MemoryHandles.filterValue(floatHandle, S2I.bindTo(\"\"), I2S);\n+        MethodHandles.filterValue(floatHandle, S2I.bindTo(\"\"), I2S);\n@@ -168,1 +168,1 @@\n-        MemoryHandles.filterValue(intHandle, S2I, I2S.bindTo(42));\n+        MethodHandles.filterValue(intHandle, S2I, I2S.bindTo(42));\n@@ -174,1 +174,1 @@\n-        MemoryHandles.filterValue(intHandle,\n+        MethodHandles.filterValue(intHandle,\n@@ -182,1 +182,1 @@\n-        MemoryHandles.filterValue(intHandle, I2S, S2L_EX);\n+        MethodHandles.filterValue(intHandle, I2S, S2L_EX);\n@@ -188,1 +188,1 @@\n-        MemoryHandles.filterValue(intHandle, S2L_EX, I2S);\n+        MethodHandles.filterValue(intHandle, S2L_EX, I2S);\n@@ -194,1 +194,1 @@\n-        VarHandle vh = MemoryHandles.filterValue(intHandle, S2I, I2S_EX);\n+        VarHandle vh = MethodHandles.filterValue(intHandle, S2I, I2S_EX);\n@@ -205,1 +205,1 @@\n-        VarHandle vh = MemoryHandles.filterValue(intHandle, S2I_EX, I2S);\n+        VarHandle vh = MethodHandles.filterValue(intHandle, S2I_EX, I2S);\n@@ -216,1 +216,1 @@\n-        VarHandle intHandle_longIndex = MemoryHandles.filterCoordinates(intHandleIndexed, 0, BASE_ADDR, S2L);\n+        VarHandle intHandle_longIndex = MethodHandles.filterCoordinates(intHandleIndexed, 0, BASE_ADDR, S2L);\n@@ -232,1 +232,1 @@\n-        MemoryHandles.filterCoordinates(intHandle, -1, SUM_OFFSETS);\n+        MethodHandles.filterCoordinates(intHandle, -1, SUM_OFFSETS);\n@@ -237,1 +237,1 @@\n-        MemoryHandles.filterCoordinates(intHandle, 1, SUM_OFFSETS);\n+        MethodHandles.filterCoordinates(intHandle, 1, SUM_OFFSETS);\n@@ -242,1 +242,1 @@\n-        MemoryHandles.filterCoordinates(intHandleIndexed, 1, S2I);\n+        MethodHandles.filterCoordinates(intHandleIndexed, 1, S2I);\n@@ -247,1 +247,1 @@\n-        MemoryHandles.filterCoordinates(intHandleIndexed, 1, S2L_EX);\n+        MethodHandles.filterCoordinates(intHandleIndexed, 1, S2L_EX);\n@@ -252,1 +252,1 @@\n-        MemoryHandles.filterCoordinates(intHandleIndexed, 1, S2L, S2L);\n+        MethodHandles.filterCoordinates(intHandleIndexed, 1, S2L, S2L);\n@@ -259,1 +259,1 @@\n-        VarHandle intHandle_longIndex = MemoryHandles.insertCoordinates(intHandleIndexed, 0, segment, 0L);\n+        VarHandle intHandle_longIndex = MethodHandles.insertCoordinates(intHandleIndexed, 0, segment, 0L);\n@@ -275,1 +275,1 @@\n-        MemoryHandles.insertCoordinates(intHandle, -1, 42);\n+        MethodHandles.insertCoordinates(intHandle, -1, 42);\n@@ -280,1 +280,1 @@\n-        MemoryHandles.insertCoordinates(intHandle, 1, 42);\n+        MethodHandles.insertCoordinates(intHandle, 1, 42);\n@@ -285,1 +285,1 @@\n-        MemoryHandles.insertCoordinates(intHandleIndexed, 1, \"Hello\");\n+        MethodHandles.insertCoordinates(intHandleIndexed, 1, \"Hello\");\n@@ -290,1 +290,1 @@\n-        MemoryHandles.insertCoordinates(intHandleIndexed, 1, 0L, 0L);\n+        MethodHandles.insertCoordinates(intHandleIndexed, 1, 0L, 0L);\n@@ -297,1 +297,1 @@\n-        VarHandle intHandle_swap = MemoryHandles.permuteCoordinates(intHandleIndexed,\n+        VarHandle intHandle_swap = MethodHandles.permuteCoordinates(intHandleIndexed,\n@@ -314,1 +314,1 @@\n-        MemoryHandles.permuteCoordinates(intHandle, List.of(int.class, int.class), new int[2]);\n+        MethodHandles.permuteCoordinates(intHandle, List.of(int.class, int.class), new int[2]);\n@@ -319,1 +319,1 @@\n-        MemoryHandles.permuteCoordinates(intHandle, List.of());\n+        MethodHandles.permuteCoordinates(intHandle, List.of());\n@@ -324,1 +324,1 @@\n-        MemoryHandles.permuteCoordinates(intHandle, List.of(int.class, int.class), 3);\n+        MethodHandles.permuteCoordinates(intHandle, List.of(int.class, int.class), 3);\n@@ -329,1 +329,1 @@\n-        MemoryHandles.permuteCoordinates(intHandle, List.of(int.class, int.class), -1);\n+        MethodHandles.permuteCoordinates(intHandle, List.of(int.class, int.class), -1);\n@@ -336,1 +336,1 @@\n-        VarHandle intHandle_sum = MemoryHandles.collectCoordinates(intHandleIndexed, 1, SUM_OFFSETS);\n+        VarHandle intHandle_sum = MethodHandles.collectCoordinates(intHandleIndexed, 1, SUM_OFFSETS);\n@@ -352,1 +352,1 @@\n-        MemoryHandles.collectCoordinates(intHandle, -1, SUM_OFFSETS);\n+        MethodHandles.collectCoordinates(intHandle, -1, SUM_OFFSETS);\n@@ -357,1 +357,1 @@\n-        MemoryHandles.collectCoordinates(intHandle, 1, SUM_OFFSETS);\n+        MethodHandles.collectCoordinates(intHandle, 1, SUM_OFFSETS);\n@@ -362,1 +362,1 @@\n-        MemoryHandles.collectCoordinates(intHandle, 0, SUM_OFFSETS);\n+        MethodHandles.collectCoordinates(intHandle, 0, SUM_OFFSETS);\n@@ -367,1 +367,1 @@\n-        MemoryHandles.collectCoordinates(intHandle, 0, VOID_FILTER);\n+        MethodHandles.collectCoordinates(intHandle, 0, VOID_FILTER);\n@@ -372,1 +372,1 @@\n-        MemoryHandles.collectCoordinates(intHandle, 0, S2L_EX);\n+        MethodHandles.collectCoordinates(intHandle, 0, S2L_EX);\n@@ -379,1 +379,1 @@\n-        VarHandle intHandle_dummy = MemoryHandles.dropCoordinates(intHandleIndexed, 1, float.class, String.class);\n+        VarHandle intHandle_dummy = MethodHandles.dropCoordinates(intHandleIndexed, 1, float.class, String.class);\n@@ -395,1 +395,1 @@\n-        MemoryHandles.dropCoordinates(intHandle, -1);\n+        MethodHandles.dropCoordinates(intHandle, -1);\n@@ -400,1 +400,1 @@\n-        MemoryHandles.dropCoordinates(intHandle, 2);\n+        MethodHandles.dropCoordinates(intHandle, 2);\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":43,"deletions":43,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -29,5 +30,3 @@\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.fail;\n-\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n@@ -38,5 +37,0 @@\n-\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-\n-import jdk.incubator.foreign.ValueLayout;\n@@ -46,0 +40,5 @@\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.fail;\n+\n","filename":"test\/jdk\/java\/foreign\/TestArrayCopy.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -30,6 +31,6 @@\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemoryLayout.PathElement;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SequenceLayout;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemoryLayout.PathElement;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SequenceLayout;\n@@ -45,7 +46,7 @@\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n+import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n+import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,2 @@\n- * @modules java.base\/sun.nio.ch\n- *          jdk.incubator.foreign\/jdk.internal.foreign\n+ * @enablePreview\n+ * @modules java.base\/sun.nio.ch java.base\/jdk.internal.foreign\n@@ -31,6 +31,6 @@\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.MemoryLayout.PathElement;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SequenceLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemoryLayout.PathElement;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SequenceLayout;\n@@ -83,7 +83,7 @@\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n+import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n+import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestClassLoaderFindNative\n+ *\/\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.ValueLayout;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static org.testng.Assert.*;\n+\n+\/\/ FYI this test is run on 64-bit platforms only for now,\n+\/\/ since the windows 32-bit linker fails and there\n+\/\/ is some fallback behaviour to use the 64-bit linker,\n+\/\/ where cygwin gets in the way and we accidentally pick up its\n+\/\/ link.exe\n+public class TestClassLoaderFindNative {\n+    static {\n+        System.loadLibrary(\"LookupTest\");\n+    }\n+\n+    @Test\n+    public void testSimpleLookup() {\n+        assertFalse(this.getClass().getClassLoader().findNative(\"f\").isEmpty());\n+    }\n+\n+    @Test\n+    public void testInvalidSymbolLookup() {\n+        assertTrue(this.getClass().getClassLoader().findNative(\"nonExistent\").isEmpty());\n+    }\n+\n+    @Test\n+    public void testVariableSymbolLookup() {\n+        MemorySegment segment = MemorySegment.ofAddress(this.getClass().getClassLoader().findNative(\"c\").get().address(), ValueLayout.JAVA_INT.byteSize(), ResourceScope.globalScope());\n+        assertEquals(segment.get(JAVA_BYTE, 0), 42);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestClassLoaderFindNative.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -30,2 +31,2 @@\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryLayout;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryLayout;\n@@ -42,9 +43,9 @@\n-import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BOOLEAN;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n+import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n+import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n","filename":"test\/jdk\/java\/foreign\/TestCondy.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -28,1 +29,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -36,7 +36,5 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.GroupLayout;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SymbolLookup;\n-import jdk.incubator.foreign.MemoryLayout;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.MemoryLayout;\n@@ -44,0 +42,1 @@\n+import java.lang.foreign.ResourceScope;\n@@ -50,2 +49,2 @@\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.SegmentAllocator;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n@@ -63,2 +62,0 @@\n-    static final SymbolLookup LOOKUP = SymbolLookup.loaderLookup();\n-\n@@ -68,1 +65,1 @@\n-        NativeSymbol addr = LOOKUP.lookup(fName).get();\n+        NativeSymbol addr = findNativeOrThrow(TestDowncall.class, fName);\n@@ -90,1 +87,1 @@\n-        NativeSymbol addr = LOOKUP.lookup(\"s\" + fName).get();\n+        NativeSymbol addr = findNativeOrThrow(TestDowncall.class, \"s\" + fName);\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -32,4 +33,4 @@\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n","filename":"test\/jdk\/java\/foreign\/TestFree.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -31,4 +32,2 @@\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryLayout;\n-import org.testng.annotations.Test;\n-\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryLayout;\n@@ -37,0 +36,1 @@\n+import org.testng.annotations.Test;\n","filename":"test\/jdk\/java\/foreign\/TestFunctionDescriptor.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,2 @@\n- * @modules jdk.incubator.foreign java.base\/jdk.internal.vm.annotation java.base\/jdk.internal.misc\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.vm.annotation java.base\/jdk.internal.misc\n@@ -34,2 +35,2 @@\n-import jdk.incubator.foreign.MemorySegment;\n-\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -47,1 +48,0 @@\n-import jdk.incubator.foreign.ResourceScope;\n@@ -51,1 +51,1 @@\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -31,8 +32,5 @@\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.ValueLayout;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.ValueLayout;\n@@ -42,0 +40,2 @@\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n","filename":"test\/jdk\/java\/foreign\/TestHeapAlignment.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -31,6 +32,6 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -34,2 +35,2 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n@@ -42,3 +43,2 @@\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.SymbolLookup;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.NativeSymbol;\n@@ -48,1 +48,1 @@\n-import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n+import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n@@ -58,2 +58,0 @@\n-    static final SymbolLookup LOOKUP = SymbolLookup.loaderLookup();\n-\n@@ -89,1 +87,1 @@\n-            NativeSymbol ma = LOOKUP.lookup(name).get();\n+            NativeSymbol ma = findNativeOrThrow(TestIntrinsics.class, name);\n@@ -98,1 +96,1 @@\n-            NativeSymbol ma = LOOKUP.lookup(\"empty\").get();\n+            NativeSymbol ma = findNativeOrThrow(TestIntrinsics.class, \"empty\");\n@@ -113,1 +111,1 @@\n-            NativeSymbol ma = LOOKUP.lookup(\"identity_va\").get();\n+            NativeSymbol ma = findNativeOrThrow(TestIntrinsics.class, \"identity_va\");\n@@ -126,1 +124,1 @@\n-                NativeSymbol ma = LOOKUP.lookup(\"invoke_high_arity\" + i).get();\n+                NativeSymbol ma = findNativeOrThrow(TestIntrinsics.class, \"invoke_high_arity\" + i);\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -29,3 +30,3 @@\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryLayout;\n-\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -35,1 +36,0 @@\n-import jdk.incubator.foreign.ValueLayout;\n","filename":"test\/jdk\/java\/foreign\/TestLayoutConstants.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,2 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- *\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.foreign\n@@ -32,2 +32,2 @@\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.ValueLayout;\n@@ -42,9 +42,9 @@\n-import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BOOLEAN;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n+import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n+import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n","filename":"test\/jdk\/java\/foreign\/TestLayoutEquality.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -30,6 +31,6 @@\n-import jdk.incubator.foreign.GroupLayout;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemoryLayout.PathElement;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SequenceLayout;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemoryLayout.PathElement;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SequenceLayout;\n@@ -37,1 +38,1 @@\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -45,3 +46,3 @@\n-import static jdk.incubator.foreign.MemoryLayout.PathElement.groupElement;\n-import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.MemoryLayout.PathElement.groupElement;\n+import static java.lang.foreign.MemoryLayout.PathElement.sequenceElement;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -29,1 +30,1 @@\n-import jdk.incubator.foreign.*;\n+import java.lang.foreign.*;\n@@ -38,4 +39,4 @@\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ * @enablePreview\n@@ -36,1 +37,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -47,0 +47,1 @@\n+ * @enablePreview\n@@ -48,1 +49,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -59,0 +59,1 @@\n+ * @enablePreview\n@@ -60,1 +61,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -71,0 +71,1 @@\n+ * @enablePreview\n@@ -72,1 +73,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -83,0 +83,1 @@\n+ * @enablePreview\n@@ -84,1 +85,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -94,0 +94,1 @@\n+ * @enablePreview\n@@ -95,1 +96,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -105,0 +105,1 @@\n+ * @enablePreview\n@@ -106,1 +107,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -117,0 +117,1 @@\n+ * @enablePreview\n@@ -118,1 +119,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -129,0 +129,1 @@\n+ * @enablePreview\n@@ -130,1 +131,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -141,0 +141,1 @@\n+ * @enablePreview\n@@ -142,1 +143,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -153,0 +153,1 @@\n+ * @enablePreview\n@@ -154,1 +155,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -165,0 +165,1 @@\n+ * @enablePreview\n@@ -166,1 +167,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -177,0 +177,1 @@\n+ * @enablePreview\n@@ -178,1 +179,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -189,0 +189,1 @@\n+ * @enablePreview\n@@ -190,1 +191,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -201,0 +201,1 @@\n+ * @enablePreview\n@@ -202,1 +203,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -213,0 +213,1 @@\n+ * @enablePreview\n@@ -214,1 +215,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -225,0 +225,1 @@\n+ * @enablePreview\n@@ -226,1 +227,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -237,0 +237,1 @@\n+ * @enablePreview\n@@ -238,1 +239,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -247,1 +247,0 @@\n-\n","filename":"test\/jdk\/java\/foreign\/TestMatrix.java","additions":18,"deletions":19,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -32,8 +33,8 @@\n-import jdk.incubator.foreign.GroupLayout;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemoryLayout.PathElement;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SequenceLayout;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemoryLayout.PathElement;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.ValueLayout;\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -29,3 +30,4 @@\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n-\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.ValueLayout;\n@@ -36,3 +38,0 @@\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.ValueLayout;\n-import org.testng.SkipException;\n@@ -40,0 +39,1 @@\n+import org.testng.SkipException;\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessInstance.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -29,8 +30,7 @@\n-import jdk.incubator.foreign.MemoryLayout;\n-\n-import jdk.incubator.foreign.GroupLayout;\n-import jdk.incubator.foreign.MemoryLayout.PathElement;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SequenceLayout;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemoryLayout.PathElement;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.ValueLayout;\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -29,2 +30,2 @@\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -35,1 +36,1 @@\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -38,8 +39,8 @@\n-import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BOOLEAN;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n+import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n+import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n","filename":"test\/jdk\/java\/foreign\/TestMemoryDereference.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,257 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-import jdk.incubator.foreign.MemoryHandles;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemoryLayout.PathElement;\n-import jdk.incubator.foreign.MemorySegment;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.util.Arrays;\n-import java.util.stream.IntStream;\n-import java.util.stream.LongStream;\n-\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.ValueLayout;\n-import org.testng.annotations.*;\n-import static java.nio.ByteOrder.BIG_ENDIAN;\n-import static org.testng.Assert.*;\n-\n-\/*\n- * @test\n- * @run testng TestMemoryHandleAsUnsigned\n- *\/\n-\n-public class TestMemoryHandleAsUnsigned {\n-\n-    @DataProvider(name = \"unsignedIntToByteData\")\n-    public Object[][] unsignedIntToByteData() {\n-        return IntStream.range(0, 256)\n-                .mapToObj(v -> new Object[] { v }).toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"unsignedIntToByteData\")\n-    public void testUnsignedIntToByte(int intValue) {\n-        byte byteValue = (byte) (intValue & 0xFF);\n-\n-        MemoryLayout layout = ValueLayout.JAVA_BYTE;\n-        VarHandle byteHandle = layout.varHandle();\n-        VarHandle intHandle = MemoryHandles.asUnsigned(byteHandle, int.class);\n-\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n-            intHandle.set(segment, intValue);\n-            int expectedIntValue = Byte.toUnsignedInt(byteValue);\n-            assertEquals((int) intHandle.get(segment), expectedIntValue);\n-            assertEquals((byte) byteHandle.get(segment), byteValue);\n-        }\n-    }\n-\n-    @DataProvider(name = \"unsignedLongToByteData\")\n-    public Object[][] unsignedLongToByteData() {\n-        return LongStream.range(0L, 256L)\n-                .mapToObj(v -> new Object[] { v }).toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"unsignedLongToByteData\")\n-    public void testUnsignedLongToByte(long longValue) {\n-        byte byteValue = (byte) (longValue & 0xFFL);\n-\n-        MemoryLayout layout = ValueLayout.JAVA_BYTE;\n-        VarHandle byteHandle = layout.varHandle();\n-        VarHandle longHandle = MemoryHandles.asUnsigned(byteHandle, long.class);\n-\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n-            longHandle.set(segment, longValue);\n-            long expectedLongValue = Byte.toUnsignedLong(byteValue);\n-            assertEquals((long) longHandle.get(segment), expectedLongValue);\n-            assertEquals((byte) byteHandle.get(segment), byteValue);\n-        }\n-    }\n-\n-    @DataProvider(name = \"unsignedIntToShortData\")\n-    public Object[][] unsignedIntToShortData() {\n-        return IntStream.range(0, 65_536).filter(i -> i % 99 == 0)\n-                .mapToObj(v -> new Object[] { v }).toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"unsignedIntToShortData\")\n-    public void testUnsignedIntToShort(int intValue) {\n-        short shortValue = (short) (intValue & 0xFFFF);\n-\n-        MemoryLayout layout = ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN);\n-        VarHandle shortHandle = layout.varHandle();\n-        VarHandle intHandle = MemoryHandles.asUnsigned(shortHandle, int.class);\n-\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n-            intHandle.set(segment, intValue);\n-            int expectedIntValue = Short.toUnsignedInt(shortValue);\n-            assertEquals((int) intHandle.get(segment), expectedIntValue);\n-            assertEquals((short) shortHandle.get(segment), shortValue);\n-        }\n-    }\n-\n-    @DataProvider(name = \"unsignedLongToShortData\")\n-    public Object[][] unsignedLongToShortData() {\n-        return LongStream.range(0L, 65_536L).filter(i -> i % 99 == 0)\n-                .mapToObj(v -> new Object[] { v }).toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"unsignedLongToShortData\")\n-    public void testUnsignedLongToShort(long longValue) {\n-        short shortValue = (short) (longValue & 0xFFFFL);\n-\n-        MemoryLayout layout = ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN);\n-        VarHandle shortHandle = layout.varHandle();\n-        VarHandle longHandle = MemoryHandles.asUnsigned(shortHandle, long.class);\n-\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n-            longHandle.set(segment, longValue);\n-            long expectedLongValue = Short.toUnsignedLong(shortValue);\n-            assertEquals((long) longHandle.get(segment), expectedLongValue);\n-            assertEquals((short) shortHandle.get(segment), shortValue);\n-        }\n-    }\n-\n-    @DataProvider(name = \"unsignedLongToIntData\")\n-    public Object[][] unsignedLongToIntData() {\n-        \/\/ some boundary values\n-        long[] l = new long[] { Long.MAX_VALUE, Long.MIN_VALUE,\n-                Short.MAX_VALUE - 1L, Short.MAX_VALUE, Short.MAX_VALUE + 1L,\n-                Short.MIN_VALUE - 1L, Short.MIN_VALUE, Short.MIN_VALUE + 1L, };\n-        return LongStream.concat(LongStream.range(-256L, 256L), Arrays.stream(l))\n-                .mapToObj(v -> new Object[] { v }).toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"unsignedLongToIntData\")\n-    public void testUnsignedLongToInt(long longValue) {\n-        int intValue = (int) (longValue & 0xFFFF_FFFFL);\n-\n-        MemoryLayout layout = ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN);\n-        VarHandle intHandle = layout.varHandle();\n-        VarHandle longHandle = MemoryHandles.asUnsigned(intHandle, long.class);\n-\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n-            longHandle.set(segment, longValue);\n-            long expectedLongValue = Integer.toUnsignedLong(intValue);\n-            assertEquals((long) longHandle.get(segment), expectedLongValue);\n-            assertEquals((int) intHandle.get(segment), intValue);\n-        }\n-    }\n-\n-    @Test\n-    public void testCoordinatesSequenceLayout() {\n-        MemoryLayout layout = MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_BYTE);\n-        VarHandle byteHandle = layout.varHandle(PathElement.sequenceElement());\n-        VarHandle intHandle = MemoryHandles.asUnsigned(byteHandle, int.class);\n-\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n-            intHandle.set(segment, 0L, (int) -1);\n-            assertEquals((int) intHandle.get(segment, 0L), 255);\n-            intHandle.set(segment, 1L, (int) 200);\n-            assertEquals((int) intHandle.get(segment, 1L), 200);\n-        }\n-    }\n-\n-    @Test\n-    public void testCoordinatesStride() {\n-        byte[] arr = { 0, 0, (byte) 129, 0 };\n-        MemorySegment segment = MemorySegment.ofArray(arr);\n-\n-        {\n-            VarHandle byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n-                    .varHandle(PathElement.sequenceElement());\n-            VarHandle intHandle = MemoryHandles.asUnsigned(byteHandle, int.class);\n-            assertEquals((int) intHandle.get(segment, 2L), 129);\n-        }\n-        {\n-            VarHandle byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n-                    .varHandle(PathElement.sequenceElement());\n-            VarHandle intHandle = MemoryHandles.asUnsigned(byteHandle, int.class);\n-            assertEquals((int) intHandle.get(segment, 2L), 129);\n-        }\n-    }\n-\n-    static final Class<NullPointerException> NPE = NullPointerException.class;\n-\n-    @Test\n-    public void testNull() {\n-        VarHandle handle = MemoryHandles.varHandle(ValueLayout.JAVA_BYTE.withOrder(BIG_ENDIAN));\n-        assertThrows(NPE, () -> MemoryHandles.asUnsigned(handle, null));\n-        assertThrows(NPE, () -> MemoryHandles.asUnsigned(null, short.class));\n-        assertThrows(NPE, () -> MemoryHandles.asUnsigned(null, null));\n-    }\n-\n-    static final Class<IllegalArgumentException> IAE = IllegalArgumentException.class;\n-\n-    static void assertIllegalArgumentExceptionIllegalCarrier(ValueLayout layout, Class<?> adaptedType) {\n-        var vh = MemoryHandles.varHandle(layout.withOrder(BIG_ENDIAN));\n-        var exception = expectThrows(IAE, () -> MemoryHandles.asUnsigned(vh, adaptedType));\n-        var msg = exception.getMessage();\n-        assertTrue(msg.contains(\"illegal carrier\"), \"Expected \\\"illegal carrier\\\" in:[\" + msg +\"]\");\n-    }\n-\n-    static void assertIllegalArgumentExceptionIllegalAdapter(ValueLayout layout, Class<?> adaptedType) {\n-        var vh = MemoryHandles.varHandle(layout.withOrder(BIG_ENDIAN));\n-        var exception = expectThrows(IAE, () -> MemoryHandles.asUnsigned(vh, adaptedType));\n-        var msg = exception.getMessage();\n-        assertTrue(msg.contains(\"illegal adapter type\"), \"Expected \\\"illegal adapter type\\\" in:[\" + msg +\"]\");\n-    }\n-\n-    static void assertIllegalArgumentExceptionIsNotWiderThan(ValueLayout layout, Class<?> adaptedType) {\n-        var vh = MemoryHandles.varHandle(layout.withOrder(BIG_ENDIAN));\n-        var exception = expectThrows(IAE, () -> MemoryHandles.asUnsigned(vh, adaptedType));\n-        var msg = exception.getMessage();\n-        assertTrue(msg.contains(\"is not wider than\"), \"Expected \\\"is not wider than\\\" in:[\" + msg +\"]\");\n-    }\n-\n-    @Test\n-    public void testIllegalArgumentException() {\n-        assertIllegalArgumentExceptionIllegalCarrier(ValueLayout.JAVA_CHAR,   long.class);\n-        assertIllegalArgumentExceptionIllegalCarrier(ValueLayout.JAVA_DOUBLE, long.class);\n-        assertIllegalArgumentExceptionIllegalCarrier(ValueLayout.JAVA_FLOAT,  long.class);\n-        assertIllegalArgumentExceptionIllegalCarrier(ValueLayout.JAVA_LONG,   long.class);\n-\n-        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, void.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, byte.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, short.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, char.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, double.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, float.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, Object.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, Integer.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, Long.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, long[].class);\n-        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, int[].class);\n-        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, Integer[].class);\n-        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, Long[].class);\n-\n-        assertIllegalArgumentExceptionIsNotWiderThan(ValueLayout.JAVA_INT, int.class);\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryHandleAsUnsigned.java","additions":0,"deletions":257,"binary":false,"changes":257,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -33,0 +34,4 @@\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.ValueLayout;\n@@ -35,3 +40,0 @@\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.ValueLayout;\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -27,1 +28,0 @@\n- * @modules jdk.incubator.foreign\n@@ -33,6 +33,5 @@\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n","filename":"test\/jdk\/java\/foreign\/TestNULLAddress.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -28,1 +29,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -32,7 +32,7 @@\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemoryLayout.PathElement;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SequenceLayout;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemoryLayout.PathElement;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -57,1 +57,1 @@\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import jdk.incubator.foreign.*;\n+import java.lang.foreign.*;\n","filename":"test\/jdk\/java\/foreign\/TestNoForeignUnsafeOverride.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -28,1 +29,0 @@\n- *          jdk.incubator.foreign\n@@ -34,1 +34,1 @@\n-import jdk.incubator.foreign.*;\n+import java.lang.foreign.*;\n@@ -63,2 +63,2 @@\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n@@ -98,2 +98,0 @@\n-            SymbolLookup.class,\n-            MemoryHandles.class,\n@@ -110,17 +108,16 @@\n-            \"jdk.incubator.foreign.ResourceScope\/newConfinedScope(java.lang.ref.Cleaner)\/0\/0\",\n-            \"jdk.incubator.foreign.ResourceScope\/newSharedScope(java.lang.ref.Cleaner)\/0\/0\",\n-            \"jdk.incubator.foreign.MemoryLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"jdk.incubator.foreign.SequenceLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"jdk.incubator.foreign.ValueLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"jdk.incubator.foreign.ValueLayout$OfAddress\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"jdk.incubator.foreign.ValueLayout$OfBoolean\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"jdk.incubator.foreign.ValueLayout$OfByte\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"jdk.incubator.foreign.ValueLayout$OfChar\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"jdk.incubator.foreign.ValueLayout$OfShort\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"jdk.incubator.foreign.ValueLayout$OfInt\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"jdk.incubator.foreign.ValueLayout$OfFloat\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"jdk.incubator.foreign.ValueLayout$OfLong\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"jdk.incubator.foreign.ValueLayout$OfDouble\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"jdk.incubator.foreign.GroupLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"jdk.incubator.foreign.MemoryHandles\/insertCoordinates(java.lang.invoke.VarHandle,int,java.lang.Object[])\/2\/1\",\n-            \"jdk.incubator.foreign.FunctionDescriptor\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\"\n+            \"java.lang.foreign.ResourceScope\/newConfinedScope(java.lang.ref.Cleaner)\/0\/0\",\n+            \"java.lang.foreign.ResourceScope\/newSharedScope(java.lang.ref.Cleaner)\/0\/0\",\n+            \"java.lang.foreign.MemoryLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"java.lang.foreign.SequenceLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"java.lang.foreign.ValueLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"java.lang.foreign.ValueLayout$OfAddress\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"java.lang.foreign.ValueLayout$OfBoolean\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"java.lang.foreign.ValueLayout$OfByte\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"java.lang.foreign.ValueLayout$OfChar\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"java.lang.foreign.ValueLayout$OfShort\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"java.lang.foreign.ValueLayout$OfInt\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"java.lang.foreign.ValueLayout$OfFloat\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"java.lang.foreign.ValueLayout$OfLong\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"java.lang.foreign.ValueLayout$OfDouble\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"java.lang.foreign.GroupLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"java.lang.foreign.FunctionDescriptor\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\"\n@@ -160,1 +157,1 @@\n-        addDefaultMapping(VarHandle.class, MemoryHandles.varHandle(JAVA_INT));\n+        addDefaultMapping(VarHandle.class, MethodHandles.memoryAccessVarHandle(JAVA_INT));\n@@ -190,1 +187,0 @@\n-        addDefaultMapping(SymbolLookup.class, CLinker.systemCLinker());\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":22,"deletions":26,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -29,3 +30,3 @@\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.SequenceLayout;\n-\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -37,1 +38,0 @@\n-import jdk.incubator.foreign.ValueLayout;\n","filename":"test\/jdk\/java\/foreign\/TestReshape.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -27,1 +28,0 @@\n- *          jdk.incubator.foreign\/jdk.incubator.foreign\n@@ -33,1 +33,1 @@\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.ResourceScope;\n@@ -42,1 +42,0 @@\n-import java.util.Set;\n","filename":"test\/jdk\/java\/foreign\/TestResourceScope.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,6 +24,4 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import org.testng.annotations.Test;\n-\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -35,0 +33,2 @@\n+import org.testng.annotations.Test;\n+\n@@ -37,0 +37,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestRestricted.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -30,8 +31,8 @@\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SegmentAllocator;\n-import jdk.incubator.foreign.VaList;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.VaList;\n+import java.lang.foreign.ValueLayout;\n@@ -51,3 +52,3 @@\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -30,1 +31,1 @@\n-import jdk.incubator.foreign.*;\n+import java.lang.foreign.*;\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -30,7 +31,4 @@\n-import jdk.incubator.foreign.MemoryHandles;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.ValueLayout;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandles;\n@@ -43,1 +41,4 @@\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n@@ -99,1 +100,1 @@\n-        BYTE(byte.class, ValueLayout.JAVA_BYTE, i -> (byte)i),\n+        BYTE(byte.class, JAVA_BYTE, i -> (byte)i),\n@@ -131,1 +132,1 @@\n-            return MemoryHandles.varHandle(layout);\n+            return MethodHandles.memoryAccessVarHandle(layout);\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -29,2 +30,2 @@\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -37,1 +38,1 @@\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOffset.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -37,2 +38,2 @@\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOverlap.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -30,4 +31,4 @@\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.ValueLayout;\n@@ -44,1 +45,1 @@\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -30,3 +31,1 @@\n-import jdk.incubator.foreign.*;\n-import org.testng.annotations.*;\n-\n+import java.lang.foreign.*;\n@@ -41,0 +40,1 @@\n+import org.testng.annotations.*;\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,3 +25,4 @@\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.ValueLayout;\n@@ -30,2 +31,0 @@\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.ValueLayout;\n@@ -37,0 +36,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestSlices.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -29,4 +30,4 @@\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SequenceLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SequenceLayout;\n@@ -43,1 +44,1 @@\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.ValueLayout;\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,4 +25,3 @@\n-import jdk.incubator.foreign.MemorySegment;\n-\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SegmentAllocator;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SegmentAllocator;\n@@ -34,0 +33,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestSymbolLookup\n- *\/\n-\n-import jdk.incubator.foreign.SymbolLookup;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.ValueLayout;\n-import org.testng.annotations.Test;\n-\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n-import static org.testng.Assert.*;\n-\n-\/\/ FYI this test is run on 64-bit platforms only for now,\n-\/\/ since the windows 32-bit linker fails and there\n-\/\/ is some fallback behaviour to use the 64-bit linker,\n-\/\/ where cygwin gets in the way and we accidentally pick up its\n-\/\/ link.exe\n-public class TestSymbolLookup {\n-    static {\n-        System.loadLibrary(\"LookupTest\");\n-    }\n-\n-    static final SymbolLookup LOOKUP = SymbolLookup.loaderLookup();\n-\n-    @Test\n-    public void testSimpleLookup() {\n-        assertFalse(LOOKUP.lookup(\"f\").isEmpty());\n-    }\n-\n-    @Test\n-    public void testInvalidSymbolLookup() {\n-        assertTrue(LOOKUP.lookup(\"nonExistent\").isEmpty());\n-    }\n-\n-    @Test\n-    public void testVariableSymbolLookup() {\n-        MemorySegment segment = MemorySegment.ofAddress(LOOKUP.lookup(\"c\").get().address(), ValueLayout.JAVA_INT.byteSize(), ResourceScope.globalScope());\n-        assertEquals(segment.get(JAVA_BYTE, 0), 42);\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestSymbolLookup.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -30,3 +31,3 @@\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.ValueLayout;\n","filename":"test\/jdk\/java\/foreign\/TestTypeAccess.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -28,1 +29,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -32,1 +32,1 @@\n-import jdk.incubator.foreign.CLinker;\n+import java.lang.foreign.CLinker;\n","filename":"test\/jdk\/java\/foreign\/TestUnsupportedPlatform.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -27,1 +28,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -35,7 +35,7 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SegmentAllocator;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SegmentAllocator;\n@@ -63,1 +63,1 @@\n-        NativeSymbol addr = LOOKUP.lookup(fName).get();\n+        NativeSymbol addr = findNativeOrThrow(TestUpcallAsync.class, fName);\n@@ -96,1 +96,1 @@\n-                            LOOKUP.lookup(symbol).orElseThrow(),\n+                            TestUpcallAsync.class.getClassLoader().findNative(symbol).orElseThrow(),\n@@ -104,1 +104,1 @@\n-            NativeSymbol invokerSymbol = LOOKUP.lookup(symbol).orElseThrow();\n+            NativeSymbol invokerSymbol = TestUpcallAsync.class.getClassLoader().findNative(symbol).orElseThrow();\n","filename":"test\/jdk\/java\/foreign\/TestUpcallAsync.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -25,8 +25,7 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.SymbolLookup;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+\n+import java.lang.foreign.ResourceScope;\n@@ -50,1 +49,0 @@\n-    static final SymbolLookup LOOKUP = SymbolLookup.loaderLookup();\n","filename":"test\/jdk\/java\/foreign\/TestUpcallBase.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -28,1 +29,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -72,1 +72,1 @@\n-                \"--add-modules\", \"jdk.incubator.foreign\",\n+                \"--enable-preview\",\n","filename":"test\/jdk\/java\/foreign\/TestUpcallException.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -28,1 +29,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -36,9 +36,7 @@\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.SymbolLookup;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -71,1 +69,0 @@\n-            SymbolLookup lookup = SymbolLookup.loaderLookup();\n@@ -73,1 +70,1 @@\n-                lookup.lookup(\"do_upcall\").get(),\n+                    findNativeOrThrow(TestUpcallHighArity.class, \"do_upcall\"),\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -27,1 +28,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -35,3 +35,3 @@\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SegmentAllocator;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SegmentAllocator;\n@@ -55,1 +55,1 @@\n-        NativeSymbol addr = LOOKUP.lookup(fName).get();\n+        NativeSymbol addr = findNativeOrThrow(TestUpcallScope.class, fName);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallScope.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -27,1 +28,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -35,4 +35,4 @@\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SegmentAllocator;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SegmentAllocator;\n@@ -56,1 +56,1 @@\n-        NativeSymbol addr = LOOKUP.lookup(\"s\" + fName).get();\n+        NativeSymbol addr = findNativeOrThrow(TestUpcallStack.class, \"s\" + fName);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -28,1 +29,0 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -40,9 +40,6 @@\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.SymbolLookup;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -73,1 +70,0 @@\n-        SymbolLookup lookup = SymbolLookup.loaderLookup();\n@@ -75,1 +71,1 @@\n-            lookup.lookup(\"do_upcall\").get(),\n+                findNativeOrThrow(TestUpcallStructScope.class, \"do_upcall\"),\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -31,9 +32,8 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SymbolLookup;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.ValueLayout;\n@@ -49,1 +49,1 @@\n-import static jdk.incubator.foreign.MemoryLayout.PathElement.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n@@ -68,3 +68,1 @@\n-    static final NativeSymbol VARARGS_ADDR =\n-            SymbolLookup.loaderLookup()\n-                    .lookup(\"varargs\").get();\n+    static final NativeSymbol VARARGS_ADDR = findNativeOrThrow(TestVarArgs.class, \"varargs\");\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -30,3 +31,2 @@\n-import jdk.incubator.foreign.MemoryHandles;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.ValueLayout;\n@@ -36,2 +36,2 @@\n-import jdk.incubator.foreign.MemorySegment;\n-\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandles;\n@@ -47,1 +47,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(ValueLayout.JAVA_BYTE);\n+        VarHandle vh = MethodHandles.memoryAccessVarHandle(ValueLayout.JAVA_BYTE);\n@@ -56,1 +56,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(ValueLayout.JAVA_BYTE.withBitAlignment(32));\n+        VarHandle vh = MethodHandles.memoryAccessVarHandle(ValueLayout.JAVA_BYTE.withBitAlignment(32));\n@@ -66,1 +66,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(ValueLayout.JAVA_BYTE.withBitAlignment(16));\n+        VarHandle vh = MethodHandles.memoryAccessVarHandle(ValueLayout.JAVA_BYTE.withBitAlignment(16));\n@@ -75,1 +75,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN));\n+        VarHandle vh = MethodHandles.memoryAccessVarHandle(ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN));\n@@ -85,1 +85,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN));\n+        VarHandle vh = MethodHandles.memoryAccessVarHandle(ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN));\n@@ -100,1 +100,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(ValueLayout.JAVA_INT.withBitAlignment(32));\n+        VarHandle vh = MethodHandles.memoryAccessVarHandle(ValueLayout.JAVA_INT.withBitAlignment(32));\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,5 +24,4 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SymbolLookup;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n@@ -42,1 +41,0 @@\n-        SymbolLookup lookup = SymbolLookup.loaderLookup();\n@@ -44,1 +42,1 @@\n-            lookup.lookup(\"f0_V__\").orElseThrow(),\n+            ThrowingUpcall.class.getClassLoader().findNative(\"f0_V__\").orElseThrow(),\n@@ -48,1 +46,1 @@\n-            lookup.lookup(\"f10_I_I_\").orElseThrow(),\n+                ThrowingUpcall.class.getClassLoader().findNative(\"f10_I_I_\").orElseThrow(),\n","filename":"test\/jdk\/java\/foreign\/ThrowingUpcall.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,0 @@\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryLayout;\n@@ -29,1 +27,0 @@\n-import java.util.ArrayList;\n","filename":"test\/jdk\/java\/foreign\/callarranger\/CallArrangerTestBase.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,3 +27,4 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- *          jdk.incubator.foreign\/jdk.internal.foreign.abi\n- *          jdk.incubator.foreign\/jdk.internal.foreign.abi.aarch64\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.foreign\n+ *          java.base\/jdk.internal.foreign.abi\n+ *          java.base\/jdk.internal.foreign.abi.aarch64\n@@ -34,5 +35,4 @@\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeSymbol;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n@@ -45,0 +45,1 @@\n+import java.lang.foreign.NativeSymbol;\n@@ -47,1 +48,1 @@\n-import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,4 +27,5 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- *          jdk.incubator.foreign\/jdk.internal.foreign.abi\n- *          jdk.incubator.foreign\/jdk.internal.foreign.abi.x64\n- *          jdk.incubator.foreign\/jdk.internal.foreign.abi.x64.sysv\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.foreign\n+ *          java.base\/jdk.internal.foreign.abi\n+ *          java.base\/jdk.internal.foreign.abi.x64\n+ *          java.base\/jdk.internal.foreign.abi.x64.sysv\n@@ -35,5 +36,4 @@\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeSymbol;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n@@ -46,0 +46,1 @@\n+import java.lang.foreign.NativeSymbol;\n@@ -48,1 +49,1 @@\n-import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,4 +27,5 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- *          jdk.incubator.foreign\/jdk.internal.foreign.abi\n- *          jdk.incubator.foreign\/jdk.internal.foreign.abi.x64\n- *          jdk.incubator.foreign\/jdk.internal.foreign.abi.x64.windows\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.foreign\n+ *          java.base\/jdk.internal.foreign.abi\n+ *          java.base\/jdk.internal.foreign.abi.x64\n+ *          java.base\/jdk.internal.foreign.abi.x64.windows\n@@ -35,5 +36,5 @@\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeSymbol;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.NativeSymbol;\n@@ -47,1 +48,1 @@\n-import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,2 @@\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -37,1 +37,1 @@\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n","filename":"test\/jdk\/java\/foreign\/channels\/AbstractChannelsTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -28,1 +29,0 @@\n- *          jdk.incubator.foreign\/jdk.internal.foreign\n@@ -52,2 +52,2 @@\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -57,1 +57,1 @@\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -28,1 +29,0 @@\n- *          jdk.incubator.foreign\/jdk.internal.foreign\n@@ -44,2 +44,2 @@\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -48,1 +48,1 @@\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n","filename":"test\/jdk\/java\/foreign\/channels\/TestSocketChannels.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -35,0 +36,1 @@\n+ * @enablePreview\n@@ -43,0 +45,1 @@\n+ * @enablePreview\n@@ -51,0 +54,1 @@\n+ * @enablePreview\n@@ -59,0 +63,1 @@\n+ * @enablePreview\n@@ -67,0 +72,1 @@\n+ * @enablePreview\n@@ -75,0 +81,1 @@\n+ * @enablePreview\n@@ -83,0 +90,1 @@\n+ * @enablePreview\n@@ -91,0 +99,1 @@\n+ * @enablePreview\n@@ -99,0 +108,1 @@\n+ * @enablePreview\n@@ -107,0 +117,1 @@\n+ * @enablePreview\n@@ -115,0 +126,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestDriver.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import jdk.incubator.foreign.*;\n+import java.lang.foreign.*;\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/org\/openjdk\/foreigntest\/PanamaMainUnnamedModule.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-    requires jdk.incubator.foreign;\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/module-info.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import jdk.incubator.foreign.*;\n+import java.lang.foreign.*;\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMain.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import jdk.incubator.foreign.*;\n+import java.lang.foreign.*;\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainInvoke.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import jdk.incubator.foreign.*;\n+import java.lang.foreign.*;\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainReflection.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/handles\/Driver.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,10 +26,9 @@\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SegmentAllocator;\n-import jdk.incubator.foreign.SymbolLookup;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ValueLayout;\n@@ -78,1 +77,0 @@\n-        addDefaultMapping(SymbolLookup.class, SymbolLookup.loaderLookup());\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/handle\/invoker\/MethodHandleInvoker.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-    requires jdk.incubator.foreign;\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/module-info.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import jdk.incubator.foreign.CLinker;\n+import java.lang.foreign.CLinker;\n@@ -32,5 +32,4 @@\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.SymbolLookup;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -38,2 +37,2 @@\n-import jdk.incubator.foreign.VaList;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.VaList;\n+import java.lang.foreign.ValueLayout;\n@@ -58,3 +57,0 @@\n-                    { MethodHandles.lookup().findStatic(SymbolLookup.class, \"loaderLookup\",\n-                            MethodType.methodType(SymbolLookup.class)),\n-                            \"SymbolLookup::loaderLookup\" },\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-    requires jdk.incubator.foreign;\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/module-info.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -27,2 +28,2 @@\n- * @compile --add-modules jdk.incubator.foreign lookup\/Lookup.java\n- * @compile --add-modules jdk.incubator.foreign invoker\/Invoker.java\n+ * @compile lookup\/Lookup.java\n+ * @compile invoker\/Invoker.java\n@@ -32,0 +33,1 @@\n+import java.lang.foreign.*;\n@@ -33,1 +35,0 @@\n-import jdk.incubator.foreign.*;\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/TestLoaderLookup.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import jdk.incubator.foreign.*;\n+import java.lang.foreign.*;\n@@ -34,1 +34,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/invoker\/Invoker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import jdk.incubator.foreign.*;\n+import java.lang.foreign.NativeSymbol;\n@@ -33,2 +33,0 @@\n-    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n-\n@@ -36,1 +34,1 @@\n-        return lookup.lookup(\"foo\").get();\n+        return Lookup.class.getClassLoader().findNative(\"foo\").get();\n@@ -38,1 +36,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/lookup\/Lookup.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -31,6 +32,5 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SymbolLookup;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -41,1 +41,1 @@\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -50,2 +50,0 @@\n-        SymbolLookup MALLOC = SymbolLookup.loaderLookup();\n-\n@@ -53,1 +51,1 @@\n-            MALLOC.lookup(\"my_malloc\").orElseThrow(),\n+                TestMixedMallocFree.class.getClassLoader().findNative(\"my_malloc\").orElseThrow(),\n","filename":"test\/jdk\/java\/foreign\/malloc\/TestMixedMallocFree.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -43,0 +44,1 @@\n+ * @enablePreview\n@@ -61,0 +63,1 @@\n+ * @enablePreview\n@@ -78,5 +81,4 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.SymbolLookup;\n-import jdk.incubator.foreign.MemoryAddress;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.MemoryAddress;\n@@ -87,1 +89,1 @@\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.ResourceScope;\n@@ -104,1 +106,0 @@\n-            SymbolLookup lookup = SymbolLookup.loaderLookup();\n@@ -106,1 +107,1 @@\n-                    lookup.lookup(\"asyncStackWalk\").get(),\n+                    findNativeOrThrow(TestAsyncStackWalk.class, \"asyncStackWalk\"),\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -43,0 +44,1 @@\n+ * @enablePreview\n@@ -61,0 +63,1 @@\n+ * @enablePreview\n@@ -78,5 +81,5 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.SymbolLookup;\n-import jdk.incubator.foreign.MemoryAddress;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.ResourceScope;\n@@ -88,1 +91,0 @@\n-import jdk.incubator.foreign.ResourceScope;\n@@ -104,1 +106,0 @@\n-            SymbolLookup lookup = SymbolLookup.loaderLookup();\n@@ -106,1 +107,1 @@\n-                    lookup.lookup(\"foo\").get(),\n+                    findNativeOrThrow(TestStackWalk.class, \"foo\"),\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -42,6 +43,5 @@\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.SymbolLookup;\n-import jdk.incubator.foreign.MemoryAddress;\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n@@ -53,1 +53,0 @@\n-import jdk.incubator.foreign.ResourceScope;\n@@ -69,1 +68,0 @@\n-            SymbolLookup lookup = SymbolLookup.loaderLookup();\n@@ -71,1 +69,1 @@\n-                    lookup.lookup(\"foo\").orElseThrow(),\n+                    TestUpcallDeopt.class.getClassLoader().findNative(\"foo\").orElseThrow(),\n","filename":"test\/jdk\/java\/foreign\/upcalldeopt\/TestUpcallDeopt.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -29,6 +30,9 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- *          jdk.incubator.foreign\/jdk.internal.foreign.abi\n- *          jdk.incubator.foreign\/jdk.internal.foreign.abi.aarch64.linux\n- *          jdk.incubator.foreign\/jdk.internal.foreign.abi.aarch64.macos\n- *          jdk.incubator.foreign\/jdk.internal.foreign.abi.x64.windows\n- *          jdk.incubator.foreign\/jdk.internal.foreign.abi.x64.sysv\n+ * @modules java.base\/jdk.internal.foreign\n+ *          java.base\/jdk.internal.foreign.abi\n+ *          java.base\/jdk.internal.foreign.abi.x64\n+ *          java.base\/jdk.internal.foreign.abi.x64.sysv\n+ *          java.base\/jdk.internal.foreign.abi.x64.windows\n+ *          java.base\/jdk.internal.foreign.abi.aarch64\n+ *          java.base\/jdk.internal.foreign.abi.aarch64.linux\n+ *          java.base\/jdk.internal.foreign.abi.aarch64.macos\n+ *          java.base\/jdk.internal.foreign.abi.aarch64.windows\n@@ -38,2 +42,2 @@\n-import jdk.incubator.foreign.*;\n-import jdk.incubator.foreign.VaList;\n+import java.lang.foreign.*;\n+import java.lang.foreign.VaList;\n@@ -58,4 +62,4 @@\n-import static jdk.incubator.foreign.MemoryLayout.PathElement.groupElement;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.MemoryLayout.PathElement.groupElement;\n+import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n@@ -72,2 +76,0 @@\n-    static final SymbolLookup LOOKUP = SymbolLookup.loaderLookup();\n-\n@@ -112,1 +114,1 @@\n-        return abi.downcallHandle(LOOKUP.lookup(symbol).get(), fd);\n+        return abi.downcallHandle(findNativeOrThrow(VaListTest.class, symbol), fd);\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -33,3 +34,2 @@\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n@@ -39,3 +39,1 @@\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.SymbolLookup;\n-import jdk.incubator.foreign.MemoryAddress;\n+import java.lang.foreign.NativeSymbol;\n@@ -60,4 +58,3 @@\n-        SymbolLookup lookup = SymbolLookup.loaderLookup();\n-        funcA = lookup.lookup(\"funcA\").get();\n-        funcB = lookup.lookup(\"funcB\").get();\n-        funcC = lookup.lookup(\"funcC\").get();\n+        funcA = findNativeOrThrow(TestVirtualCalls.class, \"funcA\");\n+        funcB = findNativeOrThrow(TestVirtualCalls.class, \"funcB\");\n+        funcC = findNativeOrThrow(TestVirtualCalls.class, \"funcC\");\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,2 @@\n- * @modules jdk.incubator.foreign\n- *          java.base\/jdk.internal.access.foreign\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.access.foreign\n@@ -49,4 +49,3 @@\n-import jdk.incubator.foreign.MemoryHandles;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -174,1 +173,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(MemoryLayout.valueLayout(carrier, ByteOrder.nativeOrder()));\n+        VarHandle vh = MethodHandles.memoryAccessVarHandle(MemoryLayout.valueLayout(carrier, ByteOrder.nativeOrder()));\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestExact.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -9,3 +9,0 @@\n-\n-# To help out with foreign memory access Spliterator tests\n-modules = jdk.incubator.foreign\n","filename":"test\/jdk\/java\/util\/stream\/test\/TEST.properties","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,2 @@\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n@@ -37,1 +37,1 @@\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.ValueLayout;\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SegmentTestDataProvider.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,3 +25,3 @@\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SequenceLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SequenceLayout;\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SpliteratorTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,3 +24,2 @@\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorLoadStoreTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package org.openjdk.bench.jdk.incubator.foreign;\n+package org.openjdk.bench.java.lang.foreign;\n@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.ResourceScope;\n@@ -41,1 +40,2 @@\n-import jdk.incubator.foreign.MemorySegment;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -51,1 +51,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\" })\n+@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkMismatchAcquire.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/BulkMismatchAcquire.java","status":"renamed"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.lang.foreign.ResourceScope;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+import sun.misc.Unsafe;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.nio.ByteBuffer;\n+import java.nio.IntBuffer;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+public class BulkOps {\n+\n+    static final Unsafe unsafe = Utils.unsafe;\n+\n+    static final int ELEM_SIZE = 1_000_000;\n+    static final int CARRIER_SIZE = (int)JAVA_INT.byteSize();\n+    static final int ALLOC_SIZE = ELEM_SIZE * CARRIER_SIZE;\n+\n+    final ResourceScope scope = ResourceScope.newConfinedScope();\n+\n+    final long unsafe_addr = unsafe.allocateMemory(ALLOC_SIZE);\n+    final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.newConfinedScope());\n+    final IntBuffer buffer = IntBuffer.allocate(ELEM_SIZE);\n+\n+    final int[] ints = new int[ELEM_SIZE];\n+    final MemorySegment bytesSegment = MemorySegment.ofArray(ints);\n+    final int UNSAFE_INT_OFFSET = unsafe.arrayBaseOffset(int[].class);\n+\n+    \/\/ large(ish) segments\/buffers with same content, 0, for mismatch, non-multiple-of-8 sized\n+    static final int SIZE_WITH_TAIL = (1024 * 1024) + 7;\n+    final MemorySegment mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, scope);\n+    final MemorySegment mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, scope);\n+    final ByteBuffer mismatchBufferLarge1 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n+    final ByteBuffer mismatchBufferLarge2 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n+\n+    \/\/ mismatch at first byte\n+    final MemorySegment mismatchSegmentSmall1 = MemorySegment.allocateNative(7, scope);\n+    final MemorySegment mismatchSegmentSmall2 = MemorySegment.allocateNative(7, scope);\n+    final ByteBuffer mismatchBufferSmall1 = ByteBuffer.allocateDirect(7);\n+    final ByteBuffer mismatchBufferSmall2 = ByteBuffer.allocateDirect(7);\n+\n+    @Setup\n+    public void setup() {\n+        mismatchSegmentSmall1.fill((byte) 0xFF);\n+        mismatchBufferSmall1.put((byte) 0xFF).clear();\n+        \/\/ verify expected mismatch indices\n+        long si = mismatchSegmentLarge1.mismatch(mismatchSegmentLarge2);\n+        if (si != -1)\n+            throw new AssertionError(\"Unexpected mismatch index:\" + si);\n+        int bi = mismatchBufferLarge1.mismatch(mismatchBufferLarge2);\n+        if (bi != -1)\n+            throw new AssertionError(\"Unexpected mismatch index:\" + bi);\n+        si = mismatchSegmentSmall1.mismatch(mismatchSegmentSmall2);\n+        if (si != 0)\n+            throw new AssertionError(\"Unexpected mismatch index:\" + si);\n+        bi = mismatchBufferSmall1.mismatch(mismatchBufferSmall2);\n+        if (bi != 0)\n+            throw new AssertionError(\"Unexpected mismatch index:\" + bi);\n+\n+        for (int i = 0; i < ints.length ; i++) {\n+            ints[i] = i;\n+        }\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        scope.close();\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void unsafe_fill() {\n+        unsafe.setMemory(unsafe_addr, ALLOC_SIZE, (byte)42);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_fill() {\n+        segment.fill((byte)42);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void unsafe_copy() {\n+        unsafe.copyMemory(ints, UNSAFE_INT_OFFSET, null, unsafe_addr, ALLOC_SIZE);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_copy() {\n+        segment.copyFrom(bytesSegment);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_copy_static() {\n+        MemorySegment.copy(ints, 0, segment, JAVA_BYTE, 0, ints.length);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_copy_static_small() {\n+        MemorySegment.copy(ints, 0, segment, JAVA_BYTE, 0, 10);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_copy_static_small_dontinline() {\n+        MemorySegment.copy(ints, 0, segment, JAVA_BYTE, 0, 10);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void unsafe_copy_small() {\n+        unsafe.copyMemory(ints, UNSAFE_INT_OFFSET, null, unsafe_addr, 10 * CARRIER_SIZE);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void buffer_copy_small() {\n+        buffer.put(0, ints, 0, 10);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void buffer_copy() {\n+        buffer.put(0, ints, 0, ints.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_copy_static_dontinline() {\n+        MemorySegment.copy(ints, 0, segment, JAVA_BYTE, 0, ints.length);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public long mismatch_large_segment() {\n+        return mismatchSegmentLarge1.mismatch(mismatchSegmentLarge2);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int mismatch_large_bytebuffer() {\n+        return mismatchBufferLarge1.mismatch(mismatchBufferLarge2);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public long mismatch_small_segment() {\n+        return mismatchSegmentSmall1.mismatch(mismatchSegmentSmall2);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int mismatch_small_bytebuffer() {\n+        return mismatchBufferSmall1.mismatch(mismatchBufferSmall2);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkOps.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-package org.openjdk.bench.jdk.incubator.foreign;\n+package org.openjdk.bench.java.lang.foreign;\n@@ -26,5 +26,5 @@\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.ValueLayout;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CLayouts.java","additions":7,"deletions":7,"binary":false,"changes":14,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CLayouts.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-package org.openjdk.bench.jdk.incubator.foreign;\n+package org.openjdk.bench.java.lang.foreign;\n@@ -25,3 +25,3 @@\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -39,1 +39,1 @@\n-import static org.openjdk.bench.jdk.incubator.foreign.CallOverheadHelper.*;\n+import static org.openjdk.bench.java.lang.foreign.CallOverheadHelper.*;\n@@ -46,1 +46,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadConstant.java","additions":7,"deletions":7,"binary":false,"changes":14,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadConstant.java","status":"renamed"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SegmentAllocator;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+\n+import static java.lang.invoke.MethodHandles.insertArguments;\n+\n+public class CallOverheadHelper extends CLayouts {\n+\n+    static final CLinker abi = CLinker.systemCLinker();\n+\n+    static final MethodHandle func;\n+    static final MethodHandle func_v;\n+    static NativeSymbol func_addr;\n+    static final MethodHandle identity;\n+    static final MethodHandle identity_v;\n+    static NativeSymbol identity_addr;\n+    static final MethodHandle identity_struct;\n+    static final MethodHandle identity_struct_v;\n+    static NativeSymbol identity_struct_addr;\n+    static final MethodHandle identity_struct_3;\n+    static final MethodHandle identity_struct_3_v;\n+    static NativeSymbol identity_struct_3_addr;\n+    static final MethodHandle identity_memory_address;\n+    static final MethodHandle identity_memory_address_v;\n+    static NativeSymbol identity_memory_address_addr;\n+    static final MethodHandle identity_memory_address_3;\n+    static final MethodHandle identity_memory_address_3_v;\n+    static NativeSymbol identity_memory_address_3_addr;\n+    static final MethodHandle args1;\n+    static final MethodHandle args1_v;\n+    static NativeSymbol args1_addr;\n+    static final MethodHandle args2;\n+    static final MethodHandle args2_v;\n+    static NativeSymbol args2_addr;\n+    static final MethodHandle args3;\n+    static final MethodHandle args3_v;\n+    static NativeSymbol args3_addr;\n+    static final MethodHandle args4;\n+    static final MethodHandle args4_v;\n+    static NativeSymbol args4_addr;\n+    static final MethodHandle args5;\n+    static final MethodHandle args5_v;\n+    static NativeSymbol args5_addr;\n+    static final MethodHandle args10;\n+    static final MethodHandle args10_v;\n+    static NativeSymbol args10_addr;\n+\n+    static final MemoryLayout POINT_LAYOUT = MemoryLayout.structLayout(\n+            C_INT, C_INT\n+    );\n+\n+    static final MemorySegment sharedPoint = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newSharedScope());\n+    static final MemorySegment confinedPoint = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newConfinedScope());\n+\n+    static final MemorySegment point = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newImplicitScope());\n+\n+    static final SegmentAllocator recycling_allocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newImplicitScope()));\n+\n+    static {\n+        System.loadLibrary(\"CallOverheadJNI\");\n+\n+        System.loadLibrary(\"CallOverhead\");\n+        {\n+            func_addr = CallOverheadHelper.class.getClassLoader().findNative(\"func\").orElseThrow();\n+            MethodType mt = MethodType.methodType(void.class);\n+            FunctionDescriptor fd = FunctionDescriptor.ofVoid();\n+            func_v = abi.downcallHandle(fd);\n+            func = insertArguments(func_v, 0, func_addr);\n+        }\n+        {\n+            identity_addr = CallOverheadHelper.class.getClassLoader().findNative(\"identity\").orElseThrow();\n+            FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT);\n+            identity_v = abi.downcallHandle(fd);\n+            identity = insertArguments(identity_v, 0, identity_addr);\n+        }\n+        identity_struct_addr = CallOverheadHelper.class.getClassLoader().findNative(\"identity_struct\").orElseThrow();\n+        identity_struct_v = abi.downcallHandle(\n+                FunctionDescriptor.of(POINT_LAYOUT, POINT_LAYOUT));\n+        identity_struct = insertArguments(identity_struct_v, 0, identity_struct_addr);\n+\n+        identity_struct_3_addr = CallOverheadHelper.class.getClassLoader().findNative(\"identity_struct_3\").orElseThrow();\n+        identity_struct_3_v = abi.downcallHandle(\n+                FunctionDescriptor.of(POINT_LAYOUT, POINT_LAYOUT, POINT_LAYOUT, POINT_LAYOUT));\n+        identity_struct_3 = insertArguments(identity_struct_3_v, 0, identity_struct_3_addr);\n+\n+        identity_memory_address_addr = CallOverheadHelper.class.getClassLoader().findNative(\"identity_memory_address\").orElseThrow();\n+        identity_memory_address_v = abi.downcallHandle(\n+                FunctionDescriptor.of(C_POINTER, C_POINTER));\n+        identity_memory_address = insertArguments(identity_memory_address_v, 0, identity_memory_address_addr);\n+\n+        identity_memory_address_3_addr = CallOverheadHelper.class.getClassLoader().findNative(\"identity_memory_address_3\").orElseThrow();\n+        identity_memory_address_3_v = abi.downcallHandle(\n+                FunctionDescriptor.of(C_POINTER, C_POINTER, C_POINTER, C_POINTER));\n+        identity_memory_address_3 = insertArguments(identity_memory_address_3_v, 0, identity_memory_address_3_addr);\n+\n+        args1_addr = CallOverheadHelper.class.getClassLoader().findNative(\"args1\").orElseThrow();\n+        args1_v = abi.downcallHandle(\n+                FunctionDescriptor.ofVoid(C_LONG_LONG));\n+        args1 = insertArguments(args1_v, 0, args1_addr);\n+\n+        args2_addr = CallOverheadHelper.class.getClassLoader().findNative(\"args2\").orElseThrow();\n+        args2_v = abi.downcallHandle(\n+                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE));\n+        args2 = insertArguments(args2_v, 0, args2_addr);\n+\n+        args3_addr = CallOverheadHelper.class.getClassLoader().findNative(\"args3\").orElseThrow();\n+        args3_v = abi.downcallHandle(\n+                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG));\n+        args3 = insertArguments(args3_v, 0, args3_addr);\n+\n+        args4_addr = CallOverheadHelper.class.getClassLoader().findNative(\"args4\").orElseThrow();\n+        args4_v = abi.downcallHandle(\n+                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE));\n+        args4 = insertArguments(args4_v, 0, args4_addr);\n+\n+        args5_addr = CallOverheadHelper.class.getClassLoader().findNative(\"args5\").orElseThrow();\n+        args5_v = abi.downcallHandle(\n+                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG));\n+        args5 = insertArguments(args5_v, 0, args5_addr);\n+\n+        args10_addr = CallOverheadHelper.class.getClassLoader().findNative(\"args10\").orElseThrow();\n+        args10_v = abi.downcallHandle(\n+                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG,\n+                                          C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE));\n+        args10 = insertArguments(args10_v, 0, args10_addr);\n+    }\n+\n+    static native void blank();\n+    static native int identity(int x);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadHelper.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-package org.openjdk.bench.jdk.incubator.foreign;\n+package org.openjdk.bench.java.lang.foreign;\n@@ -25,3 +25,3 @@\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -39,1 +39,1 @@\n-import static org.openjdk.bench.jdk.incubator.foreign.CallOverheadHelper.*;\n+import static org.openjdk.bench.java.lang.foreign.CallOverheadHelper.*;\n@@ -46,1 +46,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadVirtual.java","additions":7,"deletions":7,"binary":false,"changes":14,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadVirtual.java","status":"renamed"},{"patch":"","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/JNICB.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/JNICB.h","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-package org.openjdk.bench.jdk.incubator.foreign;\n+package org.openjdk.bench.java.lang.foreign;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/JNICB.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/JNICB.java","status":"renamed"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ResourceScope;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+import sun.misc.Unsafe;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.MemoryLayout.PathElement.sequenceElement;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+public class LoopOverConstant {\n+\n+    static final Unsafe unsafe = Utils.unsafe;\n+\n+    static final int ELEM_SIZE = 1_000_000;\n+    static final int CARRIER_SIZE = (int)JAVA_INT.byteSize();\n+    static final int ALLOC_SIZE = ELEM_SIZE * CARRIER_SIZE;\n+\n+    static final long unsafe_addr = unsafe.allocateMemory(ALLOC_SIZE);\n+\n+    \/\/setup unsafe address\n+\n+    static {\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            unsafe.putInt(unsafe_addr + (i * CARRIER_SIZE) , i);\n+        }\n+    }\n+\n+    \/\/setup native memory segment\n+\n+    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.newImplicitScope());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n+\n+    static {\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            VH_int.set(segment, (long) i, i);\n+        }\n+    }\n+\n+    \/\/setup direct buffer\n+\n+    static final ByteBuffer bb = ByteBuffer.allocateDirect(ALLOC_SIZE).order(ByteOrder.nativeOrder());\n+\n+    static {\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            bb.putInt(i * CARRIER_SIZE , i);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int unsafe_get() {\n+        return unsafe.getInt(unsafe_addr);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int segment_get() {\n+        return (int)VH_int.get(segment, 0L);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int BB_get() {\n+        return bb.getInt(0);\n+    }\n+\n+    @Benchmark\n+    public int unsafe_loop() {\n+        int res = 0;\n+        for (int i = 0; i < ELEM_SIZE; i ++) {\n+            res += unsafe.getInt(unsafe_addr + (i * CARRIER_SIZE));\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop() {\n+        int res = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            res += (int) VH_int.get(segment, (long)i);\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int BB_loop() {\n+        int res = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            res += bb.getInt(i * CARRIER_SIZE);\n+        }\n+        return res;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverConstant.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-package org.openjdk.bench.jdk.incubator.foreign;\n+package org.openjdk.bench.java.lang.foreign;\n@@ -25,4 +25,4 @@\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.SegmentAllocator;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ResourceScope;\n@@ -46,2 +46,2 @@\n-import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.MemoryLayout.PathElement.sequenceElement;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -54,1 +54,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\" })\n+@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNew.java","additions":9,"deletions":9,"binary":false,"changes":18,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNew.java","status":"renamed"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+import sun.misc.Unsafe;\n+\n+import java.lang.invoke.VarHandle;\n+import java.nio.IntBuffer;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.MemoryLayout.PathElement.sequenceElement;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+public class LoopOverNewHeap {\n+\n+    static final Unsafe unsafe = Utils.unsafe;\n+\n+    static final int ELEM_SIZE = 1_000_000;\n+    static final int CARRIER_SIZE = (int)JAVA_INT.byteSize();\n+\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n+\n+    @Param(value = {\"false\", \"true\"})\n+    boolean polluteProfile;\n+\n+    @Setup\n+    public void setup() {\n+        if (polluteProfile) {\n+            for (int i = 0 ; i < 10000 ; i++) {\n+                MemorySegment intB = MemorySegment.ofArray(new byte[ELEM_SIZE]);\n+                MemorySegment intI = MemorySegment.ofArray(new int[ELEM_SIZE]);\n+                MemorySegment intD = MemorySegment.ofArray(new double[ELEM_SIZE]);\n+                MemorySegment intF = MemorySegment.ofArray(new float[ELEM_SIZE]);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void unsafe_loop() {\n+        int[] elems = new int[ELEM_SIZE];\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            unsafe.putInt(elems, Unsafe.ARRAY_INT_BASE_OFFSET + (i * CARRIER_SIZE) , i);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void segment_loop() {\n+        MemorySegment segment = MemorySegment.ofArray(new int[ELEM_SIZE]);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            VH_int.set(segment, (long) i, i);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @Benchmark\n+    public void segment_loop_dontinline() {\n+        MemorySegment segment = MemorySegment.ofArray(new int[ELEM_SIZE]);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            VH_int.set(segment, (long) i, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void buffer_loop() {\n+        IntBuffer buffer = IntBuffer.wrap(new int[ELEM_SIZE]);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            buffer.put(i , i);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNewHeap.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-package org.openjdk.bench.jdk.incubator.foreign;\n+package org.openjdk.bench.java.lang.foreign;\n@@ -25,5 +25,4 @@\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -42,0 +41,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -47,2 +47,2 @@\n-import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.MemoryLayout.PathElement.sequenceElement;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -55,1 +55,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-preview\", \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstant.java","additions":10,"deletions":10,"binary":false,"changes":20,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstant.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-package org.openjdk.bench.jdk.incubator.foreign;\n+package org.openjdk.bench.java.lang.foreign;\n@@ -25,2 +25,2 @@\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -43,2 +43,2 @@\n-import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static java.lang.foreign.MemoryLayout.PathElement.sequenceElement;\n+import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n@@ -51,1 +51,1 @@\n-@Fork(3)\n+@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantFP.java","additions":7,"deletions":7,"binary":false,"changes":14,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantFP.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-package org.openjdk.bench.jdk.incubator.foreign;\n+package org.openjdk.bench.java.lang.foreign;\n@@ -25,4 +25,4 @@\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.ValueLayout;\n@@ -48,5 +48,5 @@\n-import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.MemoryLayout.PathElement.sequenceElement;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n+import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -59,1 +59,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\" })\n+@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantHeap.java","additions":12,"deletions":12,"binary":false,"changes":24,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantHeap.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-package org.openjdk.bench.jdk.incubator.foreign;\n+package org.openjdk.bench.java.lang.foreign;\n@@ -25,3 +25,3 @@\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -52,2 +52,2 @@\n-import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.MemoryLayout.PathElement.sequenceElement;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -60,1 +60,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantMapped.java","additions":8,"deletions":8,"binary":false,"changes":16,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantMapped.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-package org.openjdk.bench.jdk.incubator.foreign;\n+package org.openjdk.bench.java.lang.foreign;\n@@ -25,3 +25,3 @@\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -45,2 +45,2 @@\n-import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.MemoryLayout.PathElement.sequenceElement;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -53,1 +53,1 @@\n-@Fork(3)\n+@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantShared.java","additions":8,"deletions":8,"binary":false,"changes":16,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantShared.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-package org.openjdk.bench.jdk.incubator.foreign;\n+package org.openjdk.bench.java.lang.foreign;\n@@ -45,1 +45,1 @@\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -52,1 +52,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\" })\n+@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverPollutedBuffer.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverPollutedBuffer.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-package org.openjdk.bench.jdk.incubator.foreign;\n+package org.openjdk.bench.java.lang.foreign;\n@@ -25,3 +25,3 @@\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -43,3 +43,3 @@\n-import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.MemoryLayout.PathElement.sequenceElement;\n+import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -52,1 +52,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\" })\n+@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverPollutedSegments.java","additions":9,"deletions":9,"binary":false,"changes":18,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverPollutedSegments.java","status":"renamed"},{"patch":"@@ -23,1 +23,1 @@\n-package org.openjdk.bench.jdk.incubator.foreign;\n+package org.openjdk.bench.java.lang.foreign;\n@@ -25,2 +25,2 @@\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -44,2 +44,1 @@\n-import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -52,1 +51,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-preview\", \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverSlice.java","additions":5,"deletions":6,"binary":false,"changes":11,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverSlice.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-package org.openjdk.bench.jdk.incubator.foreign;\n+package org.openjdk.bench.java.lang.foreign;\n@@ -26,4 +26,4 @@\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SequenceLayout;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -42,1 +42,1 @@\n-import jdk.incubator.foreign.MemorySegment;\n+import java.lang.foreign.MemorySegment;\n@@ -54,2 +54,2 @@\n-import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.MemoryLayout.PathElement.sequenceElement;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -62,1 +62,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\" })\n+@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ParallelSum.java","additions":10,"deletions":10,"binary":false,"changes":20,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/ParallelSum.java","status":"renamed"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.invoke.MethodHandles.lookup;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+public class QSort extends CLayouts {\n+\n+    static final CLinker abi = CLinker.systemCLinker();\n+    static final MethodHandle clib_qsort;\n+    static final NativeSymbol native_compar;\n+    static final NativeSymbol panama_upcall_compar;\n+    static final long jni_upcall_compar;\n+\n+    static final int[] INPUT = { 5, 3, 2, 7, 8, 12, 1, 7 };\n+    static final MemorySegment INPUT_SEGMENT;\n+\n+    static NativeSymbol qsort_addr = abi.lookup(\"qsort\").get();\n+\n+    static {\n+        INPUT_SEGMENT = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(INPUT.length, JAVA_INT), ResourceScope.globalScope());\n+        INPUT_SEGMENT.copyFrom(MemorySegment.ofArray(INPUT));\n+\n+        System.loadLibrary(\"QSortJNI\");\n+        jni_upcall_compar = JNICB.makeCB(\"org\/openjdk\/bench\/java\/lang\/foreign\/QSort\", \"jni_upcall_compar\", \"(II)I\");\n+\n+        try {\n+            clib_qsort = abi.downcallHandle(\n+                    qsort_addr,\n+                    FunctionDescriptor.ofVoid(C_POINTER, C_LONG_LONG, C_LONG_LONG, C_POINTER)\n+            );\n+            System.loadLibrary(\"QSort\");\n+            native_compar = QSort.class.getClassLoader().findNative(\"compar\").orElseThrow();\n+            panama_upcall_compar = abi.upcallStub(\n+                    lookup().findStatic(QSort.class,\n+                            \"panama_upcall_compar\",\n+                            MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class)),\n+                    FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER),\n+                    ResourceScope.globalScope()\n+            );\n+        } catch (ReflectiveOperationException e) {\n+            throw new BootstrapMethodError(e);\n+        }\n+    }\n+\n+    static native void jni_qsort_optimized(int[] array, long cb);\n+    static native void jni_qsort_naive(int[] array);\n+\n+    @FunctionalInterface\n+    interface JNIComparator {\n+        int cmp(int e0, int e1);\n+    }\n+\n+    static final JNIComparator COMP = QSort::jni_upcall_compar;\n+\n+    @Benchmark\n+    public void native_qsort() throws Throwable {\n+         clib_qsort.invokeExact((Addressable)INPUT_SEGMENT, (long) INPUT.length, JAVA_INT.byteSize(), (Addressable)native_compar);\n+    }\n+\n+    @Benchmark\n+    public void jni_upcall_qsort_optimized() {\n+        jni_qsort_optimized(INPUT, jni_upcall_compar);\n+    }\n+\n+    @Benchmark\n+    public void jni_upcall_qsort_naive() {\n+        jni_qsort_naive(INPUT);\n+    }\n+\n+    @Benchmark\n+    public void panama_upcall_qsort() throws Throwable {\n+        clib_qsort.invokeExact((Addressable)INPUT_SEGMENT, (long) INPUT.length, JAVA_INT.byteSize(), (Addressable)panama_upcall_compar);\n+    }\n+\n+    private static int getIntAbsolute(MemoryAddress addr) {\n+        return addr.get(JAVA_INT, 0);\n+    }\n+\n+    static int panama_upcall_compar(MemoryAddress e0, MemoryAddress e1) {\n+        return Integer.compare(getIntAbsolute(e0), getIntAbsolute(e1));\n+    }\n+\n+    static int jni_upcall_compar(int j0, int j1) {\n+        return Integer.compare(j0, j1);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/QSort.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-package org.openjdk.bench.jdk.incubator.foreign;\n+package org.openjdk.bench.java.lang.foreign;\n@@ -25,2 +25,2 @@\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -50,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\" })\n+@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ResourceScopeClose.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/ResourceScopeClose.java","status":"renamed"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SegmentAllocator;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+public class StrLenTest extends CLayouts {\n+\n+    ResourceScope scope = ResourceScope.newImplicitScope();\n+\n+    SegmentAllocator segmentAllocator;\n+    SegmentAllocator arenaAllocator = SegmentAllocator.newNativeArena(scope);\n+\n+    @Param({\"5\", \"20\", \"100\"})\n+    public int size;\n+    public String str;\n+\n+    static {\n+        System.loadLibrary(\"StrLen\");\n+    }\n+\n+    static final MethodHandle STRLEN;\n+\n+    static {\n+        CLinker abi = CLinker.systemCLinker();\n+        STRLEN = abi.downcallHandle(abi.lookup(\"strlen\").get(),\n+                FunctionDescriptor.of(C_INT, C_POINTER));\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        str = makeString(size);\n+        segmentAllocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(size + 1, ResourceScope.newConfinedScope()));\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        scope.close();\n+    }\n+\n+    @Benchmark\n+    public int jni_strlen() throws Throwable {\n+        return strlen(str);\n+    }\n+\n+    @Benchmark\n+    public int panama_strlen() throws Throwable {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(str.length() + 1, scope);\n+            segment.setUtf8String(0, str);\n+            return (int)STRLEN.invokeExact((Addressable)segment);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int panama_strlen_arena() throws Throwable {\n+        return (int)STRLEN.invokeExact((Addressable)arenaAllocator.allocateUtf8String(str));\n+    }\n+\n+    @Benchmark\n+    public int panama_strlen_prefix() throws Throwable {\n+        return (int)STRLEN.invokeExact((Addressable)segmentAllocator.allocateUtf8String(str));\n+    }\n+\n+    @Benchmark\n+    public int panama_strlen_unsafe() throws Throwable {\n+        MemoryAddress address = makeStringUnsafe(str);\n+        int res = (int) STRLEN.invokeExact((Addressable)address);\n+        freeMemory(address);\n+        return res;\n+    }\n+\n+    static MemoryAddress makeStringUnsafe(String s) {\n+        byte[] bytes = s.getBytes();\n+        int len = bytes.length;\n+        MemoryAddress address = allocateMemory(len + 1);\n+        MemorySegment str = MemorySegment.ofAddress(address, len + 1, ResourceScope.globalScope());\n+        str.copyFrom(MemorySegment.ofArray(bytes));\n+        str.set(JAVA_BYTE, len, (byte)0);\n+        return address;\n+    }\n+\n+    static native int strlen(String str);\n+\n+    static String makeString(int size) {\n+        String lorem = \"\"\"\n+                Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et\n+                 dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip\n+                 ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu\n+                 fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt\n+                 mollit anim id est laborum.\n+                \"\"\";\n+        return lorem.substring(0, size);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-package org.openjdk.bench.jdk.incubator.foreign;\n+package org.openjdk.bench.java.lang.foreign;\n@@ -27,4 +27,3 @@\n-import jdk.incubator.foreign.MemoryHandles;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ValueLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n@@ -52,1 +51,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\" })\n+@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n@@ -86,1 +85,1 @@\n-    static final VarHandle VH_box_int = MemoryHandles.filterValue(VH_int, INTBOX_TO_INT, INT_TO_INTBOX);\n+    static final VarHandle VH_box_int = MethodHandles.filterValue(VH_int, INTBOX_TO_INT, INT_TO_INTBOX);\n@@ -91,1 +90,1 @@\n-    static final VarHandle VH_addr_box_int = MemoryHandles.filterValue(VH_addr_int, INTBOX_TO_INT, INT_TO_INTBOX);\n+    static final VarHandle VH_addr_box_int = MethodHandles.filterValue(VH_addr_int, INTBOX_TO_INT, INT_TO_INTBOX);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestAdaptVarHandles.java","additions":8,"deletions":9,"binary":false,"changes":17,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/TestAdaptVarHandles.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-package org.openjdk.bench.jdk.incubator.foreign;\n+package org.openjdk.bench.java.lang.foreign;\n@@ -26,2 +26,2 @@\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -43,1 +43,1 @@\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n@@ -51,1 +51,0 @@\n-        \"--add-modules=jdk.incubator.foreign\",\n@@ -53,1 +52,2 @@\n-        \"--enable-native-access\", \"ALL-UNNAMED\"})\n+        \"--enable-native-access\", \"ALL-UNNAMED\",\n+        \"--enable-preview\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestLoadBytes.java","additions":7,"deletions":7,"binary":false,"changes":14,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/TestLoadBytes.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-package org.openjdk.bench.jdk.incubator.foreign;\n+package org.openjdk.bench.java.lang.foreign;\n@@ -26,1 +26,1 @@\n-import jdk.incubator.foreign.*;\n+import java.lang.foreign.*;\n@@ -36,1 +36,1 @@\n-import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n@@ -43,1 +43,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-preview\", \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/UnrolledAccess.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/UnrolledAccess.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-package org.openjdk.bench.jdk.incubator.foreign;\n+package org.openjdk.bench.java.lang.foreign;\n@@ -25,6 +25,5 @@\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SymbolLookup;\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n@@ -51,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n@@ -73,1 +72,1 @@\n-        String className = \"org\/openjdk\/bench\/jdk\/incubator\/foreign\/Upcalls\";\n+        String className = \"org\/openjdk\/bench\/java\/lang\/foreign\/Upcalls\";\n@@ -126,1 +125,1 @@\n-            SymbolLookup.loaderLookup().lookup(name).orElseThrow(),\n+                Upcalls.class.getClassLoader().findNative(name).orElseThrow(),\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/Upcalls.java","additions":10,"deletions":11,"binary":false,"changes":21,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/Upcalls.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-package org.openjdk.bench.jdk.incubator.foreign;\n+package org.openjdk.bench.java.lang.foreign;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/Utils.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/Utils.java","status":"renamed"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.ResourceScope;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+public class VaList extends CLayouts {\n+\n+    static final CLinker linker = CLinker.systemCLinker();\n+    static {\n+        System.loadLibrary(\"VaList\");\n+    }\n+\n+    static final MethodHandle MH_ellipsis;\n+    static final MethodHandle MH_vaList;\n+\n+    static {\n+        MH_ellipsis = linker.downcallHandle(VaList.class.getClassLoader().findNative(\"ellipsis\").get(),\n+                FunctionDescriptor.ofVoid(C_INT).asVariadic(C_INT, C_DOUBLE, C_LONG_LONG));\n+        MH_vaList = linker.downcallHandle(VaList.class.getClassLoader().findNative(\"vaList\").get(),\n+                FunctionDescriptor.ofVoid(C_INT, C_POINTER));\n+    }\n+\n+    @Benchmark\n+    public void ellipsis() throws Throwable {\n+        MH_ellipsis.invokeExact(3,\n+                                1, 2D, 3L);\n+    }\n+\n+    @Benchmark\n+    public void vaList() throws Throwable {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            java.lang.foreign.VaList vaList = java.lang.foreign.VaList.make(b ->\n+                    b.addVarg(C_INT, 1)\n+                            .addVarg(C_DOUBLE, 2D)\n+                            .addVarg(C_LONG_LONG, 3L), scope);\n+            MH_vaList.invokeExact(3,\n+                    (Addressable)vaList);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VaList.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+public class VarHandleExact {\n+\n+    static final VarHandle exact;\n+    static final VarHandle generic;\n+\n+    static {\n+        generic = MethodHandles.memoryAccessVarHandle(JAVA_INT);\n+        exact = generic.withInvokeExactBehavior();\n+    }\n+\n+    MemorySegment data;\n+\n+    @Setup\n+    public void setup() {\n+        data = MemorySegment.allocateNative(JAVA_INT, ResourceScope.newConfinedScope());\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        data.scope().close();\n+    }\n+\n+    @Benchmark\n+    public void exact_exactInvocation() {\n+        exact.set(data, (long) 0, 42);\n+    }\n+\n+    @Benchmark\n+    public void generic_genericInvocation() {\n+        generic.set(data, 0, 42);\n+    }\n+\n+    @Benchmark\n+    public void generic_exactInvocation() {\n+        generic.set(data, (long) 0, 42);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VarHandleExact.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libCallOverhead.c","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libCallOverhead.c","status":"renamed"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <jni.h>\n+#include <stdlib.h>\n+#include \"libCallOverhead.c\"\n+\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_java_lang_foreign_CallOverheadHelper_blank\n+  (JNIEnv *env, jclass cls) {\n+    func();\n+}\n+\n+JNIEXPORT jint JNICALL Java_org_openjdk_bench_java_lang_foreign_CallOverheadHelper_identity\n+  (JNIEnv *env, jclass cls, jint x) {\n+    return identity(x);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libCallOverheadJNI.c","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-JNIEXPORT jlong JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_JNICB_makeCB\n+JNIEXPORT jlong JNICALL Java_org_openjdk_bench_java_lang_foreign_JNICB_makeCB\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libJNICB.c","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libJNICB.c","status":"renamed"},{"patch":"","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libQSort.c","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libQSort.c","status":"renamed"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+\n+#include <stdlib.h>\n+\n+#include \"jlong.h\"\n+#include \"JNICB.h\"\n+\n+#ifdef _WIN64\n+#define THREAD_LOCAL __declspec(thread)\n+#else\n+#define THREAD_LOCAL __thread\n+#endif\n+\n+THREAD_LOCAL struct {\n+  JNICB cb;\n+  JNIEnv* env;\n+} ctx_opt;\n+\n+static int comparator(const void* e0, const void* e1) {\n+    JNICB jniCb = ctx_opt.cb;\n+    JNIEnv* env = ctx_opt.env;\n+    jint j0 = *((jint*) e0);\n+    jint j1 = *((jint*) e1);\n+    return (*env)->CallStaticIntMethod(env, jniCb->holder, jniCb->mid, j0, j1);\n+}\n+\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_java_lang_foreign_QSort_jni_1qsort_1optimized\n+        (JNIEnv *env, jclass cls, jintArray arr, jlong cb) {\n+\n+    ctx_opt.cb = jlong_to_ptr(cb);\n+    ctx_opt.env = env;\n+\n+    jint* ints = (*env)->GetIntArrayElements(env, arr, NULL);\n+    jsize length = (*env)->GetArrayLength(env, arr);\n+\n+    qsort(ints, length, sizeof(jint), &comparator);\n+\n+    (*env)->ReleaseIntArrayElements(env, arr, ints, 0);\n+}\n+\n+JavaVM* VM = NULL;\n+\n+int java_cmp(const void *a, const void *b) {\n+   int v1 = *((int*)a);\n+   int v2 = *((int*)b);\n+\n+   JNIEnv* env;\n+   (*VM)->GetEnv(VM, (void**) &env, JNI_VERSION_10);\n+\n+   jclass qsortClass = (*env)->FindClass(env, \"org\/openjdk\/bench\/java\/lang\/foreign\/QSort\");\n+   jmethodID methodId = (*env)->GetStaticMethodID(env, qsortClass, \"jni_upcall_compar\", \"(II)I\");\n+\n+   return (*env)->CallStaticIntMethod(env, qsortClass, methodId, v1, v2);\n+}\n+\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_java_lang_foreign_QSort_jni_1qsort_1naive\n+        (JNIEnv *env, jclass cls, jintArray arr) {\n+    if (VM == NULL) {\n+        (*env)->GetJavaVM(env, &VM);\n+    }\n+\n+    jint* carr = (*env)->GetIntArrayElements(env, arr, 0);\n+    jsize length = (*env)->GetArrayLength(env, arr);\n+    qsort(carr, length, sizeof(jint), java_cmp);\n+    (*env)->ReleaseIntArrayElements(env, arr, carr, 0);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libQSortJNI.c","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+JNIEXPORT jint JNICALL Java_org_openjdk_bench_java_lang_foreign_StrLenTest_strlen(JNIEnv *const env, const jclass cls, const jstring text) {\n+    const char *str = (*env)->GetStringUTFChars(env, text, NULL);\n+    int len = (int)strlen(str);\n+    (*env)->ReleaseStringUTFChars(env, text, str);\n+    return len;\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libStrLen.c","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libUpcalls.c","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libUpcalls.c","status":"renamed"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <jni.h>\n+#include <stdlib.h>\n+\n+#include \"jlong.h\"\n+#include \"JNICB.h\"\n+\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_java_lang_foreign_Upcalls_blank\n+  (JNIEnv *env, jclass cls, jlong cb) {\n+    JNICB jniCb = jlong_to_ptr(cb);\n+    (*env)->CallStaticVoidMethod(env, jniCb->holder, jniCb->mid);\n+}\n+\n+JNIEXPORT jint JNICALL Java_org_openjdk_bench_java_lang_foreign_Upcalls_identity\n+  (JNIEnv *env, jclass cls, jint x, jlong cb) {\n+    JNICB jniCb = jlong_to_ptr(cb);\n+    return (*env)->CallStaticIntMethod(env, jniCb->holder, jniCb->mid, x);\n+}\n+\n+JNIEXPORT jint JNICALL Java_org_openjdk_bench_java_lang_foreign_Upcalls_args5\n+  (JNIEnv *env, jclass cls,\n+      jlong a0, jdouble a1, jlong a2, jdouble a3, jlong a4,\n+      jlong cb) {\n+    JNICB jniCb = jlong_to_ptr(cb);\n+    return (*env)->CallStaticIntMethod(env, jniCb->holder, jniCb->mid, a0, a1, a2, a3, a4);\n+}\n+\n+JNIEXPORT jint JNICALL Java_org_openjdk_bench_java_lang_foreign_Upcalls_args10\n+  (JNIEnv *env, jclass cls,\n+      jlong a0, jdouble a1, jlong a2, jdouble a3, jlong a4,\n+      jdouble a5, jlong a6, jdouble a7, jlong a8, jdouble a9,\n+      jlong cb) {\n+    JNICB jniCb = jlong_to_ptr(cb);\n+    return (*env)->CallStaticIntMethod(env, jniCb->holder, jniCb->mid, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libUpcallsJNI.c","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libVaList.c","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libVaList.c","status":"renamed"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign.points;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.bench.java.lang.foreign.points.support.BBPoint;\n+import org.openjdk.bench.java.lang.foreign.points.support.JNIPoint;\n+import org.openjdk.bench.java.lang.foreign.points.support.PanamaPoint;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class PointsAccess {\n+\n+    BBPoint BBPoint;\n+    PanamaPoint panamaPoint;\n+    JNIPoint JNIPoint;\n+\n+    @Setup\n+    public void setup() {\n+        BBPoint = new BBPoint(0, 0);\n+        panamaPoint = new PanamaPoint(0, 0);\n+        JNIPoint = new JNIPoint(0, 0);\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        JNIPoint.free();\n+        panamaPoint.close();\n+    }\n+\n+    @Benchmark\n+    public void BB_set() throws Throwable {\n+        BBPoint.setX(10);\n+    }\n+\n+    @Benchmark\n+    public int BB_get() throws Throwable {\n+        return BBPoint.getX();\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public int BB_get_loop() throws Throwable {\n+        int sum = 0;\n+        for (int i = 0; i < 1_000_000; i++) {\n+            sum += BBPoint.getX();\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void jni_set() throws Throwable {\n+        JNIPoint.setX(10);\n+    }\n+\n+    @Benchmark\n+    public int jni_get() throws Throwable {\n+        return JNIPoint.getX();\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public int jni_get_loop() throws Throwable {\n+        int sum = 0;\n+        for (int i = 0; i < 1_000_000; i++) {\n+            sum += JNIPoint.getX();\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void panama_set() throws Throwable {\n+        panamaPoint.setX(10);\n+    }\n+\n+    @Benchmark\n+    public int panama_get() throws Throwable {\n+        return panamaPoint.getX();\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public int panama_get_loop() throws Throwable {\n+        int sum = 0;\n+        for (int i = 0; i < 1_000_000; i++) {\n+            sum += panamaPoint.getX();\n+        }\n+        return sum;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/PointsAccess.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign.points;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.bench.java.lang.foreign.points.support.BBPoint;\n+import org.openjdk.bench.java.lang.foreign.points.support.JNIPoint;\n+import org.openjdk.bench.java.lang.foreign.points.support.PanamaPoint;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class PointsAlloc {\n+\n+    @Benchmark\n+    public Object jni_ByteBuffer_alloc() throws Throwable {\n+        return new BBPoint(0, 0);\n+    }\n+\n+    @Benchmark\n+    public Object jni_long_alloc() throws Throwable {\n+        return new JNIPoint(0, 0);\n+    }\n+\n+    @Benchmark\n+    public Object panama_alloc() throws Throwable {\n+        return new PanamaPoint(0, 0);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/PointsAlloc.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign.points;\n+\n+import org.openjdk.bench.java.lang.foreign.points.support.BBPoint;\n+import org.openjdk.bench.java.lang.foreign.points.support.JNIPoint;\n+import org.openjdk.bench.java.lang.foreign.points.support.PanamaPoint;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class PointsDistance {\n+\n+    BBPoint jniP1;\n+    BBPoint jniP2;\n+\n+    JNIPoint nativeP1;\n+    JNIPoint nativeP2;\n+\n+    PanamaPoint panamaPointP1;\n+    PanamaPoint panamaPointP2;\n+\n+    @Setup\n+    public void setup() {\n+        jniP1 = new BBPoint(0, 0);\n+        jniP2 = new BBPoint(1, 1);\n+\n+        nativeP1 = new JNIPoint(0, 0);\n+        nativeP2 = new JNIPoint(1, 1);\n+\n+        panamaPointP1 = new PanamaPoint(0, 0);\n+        panamaPointP2 = new PanamaPoint(1, 1);\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        nativeP1.free();\n+        nativeP2.free();\n+\n+        panamaPointP1.close();\n+        panamaPointP2.close();\n+    }\n+\n+    @Benchmark\n+    public double jni_ByteBuffer() throws Throwable {\n+        return jniP1.distanceTo(jniP2);\n+    }\n+\n+    @Benchmark\n+    public double jni_long() throws Throwable {\n+        return nativeP1.distanceTo(nativeP2);\n+    }\n+\n+    @Benchmark\n+    public double panama_MemorySegment() throws Throwable {\n+        return panamaPointP1.distanceTo(panamaPointP2);\n+    }\n+\n+    @Benchmark\n+    public double panama_MemoryAddress() throws Throwable {\n+        return panamaPointP1.distanceToPtrs(panamaPointP2);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/PointsDistance.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign.points;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.bench.java.lang.foreign.points.support.JNIPoint;\n+import org.openjdk.bench.java.lang.foreign.points.support.PanamaPoint;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class PointsFree {\n+\n+    JNIPoint jniPoint;\n+    PanamaPoint panamaPoint;\n+\n+    @Setup(Level.Invocation)\n+    public void setup() {\n+        jniPoint = new JNIPoint(0, 0);\n+        panamaPoint = new PanamaPoint(0, 0);\n+    }\n+\n+    @Benchmark\n+    public void jni_long_free() throws Throwable {\n+        jniPoint.close();\n+    }\n+\n+    @Benchmark\n+    public void panama_free() throws Throwable {\n+        panamaPoint.close();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/PointsFree.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-package org.openjdk.bench.jdk.incubator.foreign.points.support;\n+package org.openjdk.bench.java.lang.foreign.points.support;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/BBPoint.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/support\/BBPoint.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-package org.openjdk.bench.jdk.incubator.foreign.points.support;\n+package org.openjdk.bench.java.lang.foreign.points.support;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/JNIPoint.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/support\/JNIPoint.java","status":"renamed"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign.points.support;\n+\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import org.openjdk.bench.java.lang.foreign.CLayouts;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.lang.foreign.MemoryLayout.PathElement.groupElement;\n+\n+public class PanamaPoint extends CLayouts implements AutoCloseable {\n+\n+    public static final MemoryLayout LAYOUT = MemoryLayout.structLayout(\n+        C_INT.withName(\"x\"),\n+        C_INT.withName(\"y\")\n+    );\n+\n+    private static final VarHandle VH_x = LAYOUT.varHandle(groupElement(\"x\"));\n+    private static final VarHandle VH_y = LAYOUT.varHandle(groupElement(\"y\"));\n+    private static final MethodHandle MH_distance;\n+    private static final MethodHandle MH_distance_ptrs;\n+\n+    static {\n+        CLinker abi = CLinker.systemCLinker();\n+        System.loadLibrary(\"Point\");\n+        MH_distance = abi.downcallHandle(\n+                PanamaPoint.class.getClassLoader().findNative(\"distance\").get(),\n+                FunctionDescriptor.of(C_DOUBLE, LAYOUT, LAYOUT)\n+        );\n+        MH_distance_ptrs = abi.downcallHandle(\n+                PanamaPoint.class.getClassLoader().findNative(\"distance_ptrs\").get(),\n+                FunctionDescriptor.of(C_DOUBLE, C_POINTER, C_POINTER)\n+        );\n+    }\n+\n+    private final MemorySegment segment;\n+\n+    public PanamaPoint(int x, int y) {\n+        this(MemorySegment.allocateNative(LAYOUT, ResourceScope.newConfinedScope()), x, y);\n+    }\n+\n+    public PanamaPoint(MemorySegment segment, int x, int y) {\n+        this(segment);\n+        setX(x);\n+        setY(y);\n+    }\n+\n+    public PanamaPoint(MemorySegment segment) {\n+        this.segment = segment;\n+    }\n+\n+    public void setX(int x) {\n+        VH_x.set(segment, x);\n+    }\n+\n+    public int getX() {\n+        return (int) VH_x.get(segment);\n+    }\n+\n+    public void setY(int y) {\n+        VH_y.set(segment, y);\n+    }\n+\n+    public int getY() {\n+        return (int) VH_y.get(segment);\n+    }\n+\n+    public double distanceTo(PanamaPoint other) {\n+        try {\n+            return (double) MH_distance.invokeExact(segment, other.segment);\n+        } catch (Throwable throwable) {\n+            throw new InternalError(throwable);\n+        }\n+    }\n+\n+    public double distanceToPtrs(PanamaPoint other) {\n+        try {\n+            return (double) MH_distance_ptrs.invokeExact((Addressable)segment, (Addressable)other.segment);\n+        } catch (Throwable throwable) {\n+            throw new InternalError(throwable);\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        segment.scope().close();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/PanamaPoint.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <jni.h>\n+#include <stdlib.h>\n+#include \"jlong.h\"\n+#include <math.h>\n+\n+#include \"points.h\"\n+\n+double distance(Point p1, Point p2) {\n+    int xDist = abs(p1.x - p2.x);\n+    int yDist = abs(p1.y - p2.y);\n+    return sqrt((xDist * xDist) + (yDist * yDist));\n+}\n+\n+JNIEXPORT jlong JNICALL Java_org_openjdk_bench_java_lang_foreign_points_support_JNIPoint_allocate\n+  (JNIEnv *env, jclass nativePointClass) {\n+    Point* p = malloc(sizeof *p);\n+    return ptr_to_jlong(p);\n+}\n+\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_java_lang_foreign_points_support_JNIPoint_free\n+  (JNIEnv *env, jclass cls, jlong thisPoint) {\n+    free(jlong_to_ptr(thisPoint));\n+}\n+\n+JNIEXPORT jint JNICALL Java_org_openjdk_bench_java_lang_foreign_points_support_JNIPoint_getX\n+  (JNIEnv *env, jclass cls, jlong thisPoint) {\n+    Point* point = jlong_to_ptr(thisPoint);\n+    return point->x;\n+}\n+\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_java_lang_foreign_points_support_JNIPoint_setX\n+  (JNIEnv *env, jclass cls, jlong thisPoint, jint value) {\n+    Point* point = jlong_to_ptr(thisPoint);\n+    point->x = value;\n+}\n+\n+JNIEXPORT jint JNICALL Java_org_openjdk_bench_java_lang_foreign_points_support_JNIPoint_getY\n+  (JNIEnv *env, jclass cls, jlong thisPoint) {\n+    Point* point = jlong_to_ptr(thisPoint);\n+    return point->y;\n+}\n+\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_java_lang_foreign_points_support_JNIPoint_setY\n+  (JNIEnv *env, jclass cls, jlong thisPoint, jint value) {\n+    Point* point = jlong_to_ptr(thisPoint);\n+    point->y = value;\n+}\n+\n+JNIEXPORT jdouble JNICALL Java_org_openjdk_bench_java_lang_foreign_points_support_JNIPoint_distance\n+  (JNIEnv *env, jclass cls, jlong thisPoint, jlong other) {\n+    Point* p1 = jlong_to_ptr(thisPoint);\n+    Point* p2 = jlong_to_ptr(other);\n+    return distance(*p1, *p2);\n+}\n+\n+JNIEXPORT jdouble JNICALL Java_org_openjdk_bench_java_lang_foreign_points_support_BBPoint_distance\n+  (JNIEnv *env, jclass ignored, jobject buffP1, jobject buffP2) {\n+    Point* p1 = (Point*) (*env)->GetDirectBufferAddress(env, buffP1);\n+    Point* p2 = (Point*) (*env)->GetDirectBufferAddress(env, buffP2);\n+    return distance(*p1, *p2);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/libJNIPoint.c","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/libPoint.c","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/support\/libPoint.c","status":"renamed"},{"patch":"","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/points.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/support\/points.h","status":"renamed"},{"patch":"@@ -1,204 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package org.openjdk.bench.jdk.incubator.foreign;\n-\n-import jdk.incubator.foreign.ResourceScope;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.TearDown;\n-import org.openjdk.jmh.annotations.Warmup;\n-import sun.misc.Unsafe;\n-\n-import jdk.incubator.foreign.MemorySegment;\n-import java.nio.ByteBuffer;\n-import java.nio.IntBuffer;\n-import java.util.concurrent.TimeUnit;\n-\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.MILLISECONDS)\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\" })\n-public class BulkOps {\n-\n-    static final Unsafe unsafe = Utils.unsafe;\n-\n-    static final int ELEM_SIZE = 1_000_000;\n-    static final int CARRIER_SIZE = (int)JAVA_INT.byteSize();\n-    static final int ALLOC_SIZE = ELEM_SIZE * CARRIER_SIZE;\n-\n-    final ResourceScope scope = ResourceScope.newConfinedScope();\n-\n-    final long unsafe_addr = unsafe.allocateMemory(ALLOC_SIZE);\n-    final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.newConfinedScope());\n-    final IntBuffer buffer = IntBuffer.allocate(ELEM_SIZE);\n-\n-    final int[] bytes = new int[ELEM_SIZE];\n-    final MemorySegment bytesSegment = MemorySegment.ofArray(bytes);\n-    final int UNSAFE_INT_OFFSET = unsafe.arrayBaseOffset(int[].class);\n-\n-    \/\/ large(ish) segments\/buffers with same content, 0, for mismatch, non-multiple-of-8 sized\n-    static final int SIZE_WITH_TAIL = (1024 * 1024) + 7;\n-    final MemorySegment mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, scope);\n-    final MemorySegment mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, scope);\n-    final ByteBuffer mismatchBufferLarge1 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n-    final ByteBuffer mismatchBufferLarge2 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n-\n-    \/\/ mismatch at first byte\n-    final MemorySegment mismatchSegmentSmall1 = MemorySegment.allocateNative(7, scope);\n-    final MemorySegment mismatchSegmentSmall2 = MemorySegment.allocateNative(7, scope);\n-    final ByteBuffer mismatchBufferSmall1 = ByteBuffer.allocateDirect(7);\n-    final ByteBuffer mismatchBufferSmall2 = ByteBuffer.allocateDirect(7);\n-\n-    @Setup\n-    public void setup() {\n-        mismatchSegmentSmall1.fill((byte) 0xFF);\n-        mismatchBufferSmall1.put((byte) 0xFF).clear();\n-        \/\/ verify expected mismatch indices\n-        long si = mismatchSegmentLarge1.mismatch(mismatchSegmentLarge2);\n-        if (si != -1)\n-            throw new AssertionError(\"Unexpected mismatch index:\" + si);\n-        int bi = mismatchBufferLarge1.mismatch(mismatchBufferLarge2);\n-        if (bi != -1)\n-            throw new AssertionError(\"Unexpected mismatch index:\" + bi);\n-        si = mismatchSegmentSmall1.mismatch(mismatchSegmentSmall2);\n-        if (si != 0)\n-            throw new AssertionError(\"Unexpected mismatch index:\" + si);\n-        bi = mismatchBufferSmall1.mismatch(mismatchBufferSmall2);\n-        if (bi != 0)\n-            throw new AssertionError(\"Unexpected mismatch index:\" + bi);\n-\n-        for (int i = 0 ; i < bytes.length ; i++) {\n-            bytes[i] = i;\n-        }\n-    }\n-\n-    @TearDown\n-    public void tearDown() {\n-        scope.close();\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void unsafe_fill() {\n-        unsafe.setMemory(unsafe_addr, ALLOC_SIZE, (byte)42);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void segment_fill() {\n-        segment.fill((byte)42);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void unsafe_copy() {\n-        unsafe.copyMemory(bytes, UNSAFE_INT_OFFSET, null, unsafe_addr, ALLOC_SIZE);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void segment_copy() {\n-        segment.copyFrom(bytesSegment);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void segment_copy_static() {\n-        MemorySegment.copy(bytes, 0, segment, JAVA_INT, 0, bytes.length);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void segment_copy_static_small() {\n-        MemorySegment.copy(bytes, 0, segment, JAVA_INT, 0, 10);\n-    }\n-\n-    @Benchmark\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void segment_copy_static_small_dontinline() {\n-        MemorySegment.copy(bytes, 0, segment, JAVA_INT, 0, 10);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void unsafe_copy_small() {\n-        unsafe.copyMemory(bytes, UNSAFE_INT_OFFSET, null, unsafe_addr, 10 * CARRIER_SIZE);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void buffer_copy_small() {\n-        buffer.put(0, bytes, 0, 10);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void buffer_copy() {\n-        buffer.put(0, bytes, 0, bytes.length);\n-    }\n-\n-    @Benchmark\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void segment_copy_static_dontinline() {\n-        MemorySegment.copy(bytes, 0, segment, JAVA_INT, 0, bytes.length);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public long mismatch_large_segment() {\n-        return mismatchSegmentLarge1.mismatch(mismatchSegmentLarge2);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int mismatch_large_bytebuffer() {\n-        return mismatchBufferLarge1.mismatch(mismatchBufferLarge2);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public long mismatch_small_segment() {\n-        return mismatchSegmentSmall1.mismatch(mismatchSegmentSmall2);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int mismatch_small_bytebuffer() {\n-        return mismatchBufferSmall1.mismatch(mismatchBufferSmall2);\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/BulkOps.java","additions":0,"deletions":204,"binary":false,"changes":204,"status":"deleted"},{"patch":"@@ -1,163 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.jdk.incubator.foreign;\n-\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SegmentAllocator;\n-import jdk.incubator.foreign.SymbolLookup;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-\n-import static java.lang.invoke.MethodHandles.insertArguments;\n-\n-public class CallOverheadHelper extends CLayouts {\n-\n-    static final CLinker abi = CLinker.systemCLinker();\n-\n-    static final MethodHandle func;\n-    static final MethodHandle func_v;\n-    static NativeSymbol func_addr;\n-    static final MethodHandle identity;\n-    static final MethodHandle identity_v;\n-    static NativeSymbol identity_addr;\n-    static final MethodHandle identity_struct;\n-    static final MethodHandle identity_struct_v;\n-    static NativeSymbol identity_struct_addr;\n-    static final MethodHandle identity_struct_3;\n-    static final MethodHandle identity_struct_3_v;\n-    static NativeSymbol identity_struct_3_addr;\n-    static final MethodHandle identity_memory_address;\n-    static final MethodHandle identity_memory_address_v;\n-    static NativeSymbol identity_memory_address_addr;\n-    static final MethodHandle identity_memory_address_3;\n-    static final MethodHandle identity_memory_address_3_v;\n-    static NativeSymbol identity_memory_address_3_addr;\n-    static final MethodHandle args1;\n-    static final MethodHandle args1_v;\n-    static NativeSymbol args1_addr;\n-    static final MethodHandle args2;\n-    static final MethodHandle args2_v;\n-    static NativeSymbol args2_addr;\n-    static final MethodHandle args3;\n-    static final MethodHandle args3_v;\n-    static NativeSymbol args3_addr;\n-    static final MethodHandle args4;\n-    static final MethodHandle args4_v;\n-    static NativeSymbol args4_addr;\n-    static final MethodHandle args5;\n-    static final MethodHandle args5_v;\n-    static NativeSymbol args5_addr;\n-    static final MethodHandle args10;\n-    static final MethodHandle args10_v;\n-    static NativeSymbol args10_addr;\n-\n-    static final MemoryLayout POINT_LAYOUT = MemoryLayout.structLayout(\n-            C_INT, C_INT\n-    );\n-\n-    static final MemorySegment sharedPoint = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newSharedScope());\n-    static final MemorySegment confinedPoint = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newConfinedScope());\n-\n-    static final MemorySegment point = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newImplicitScope());\n-\n-    static final SegmentAllocator recycling_allocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newImplicitScope()));\n-\n-    static {\n-        System.loadLibrary(\"CallOverheadJNI\");\n-\n-        System.loadLibrary(\"CallOverhead\");\n-        SymbolLookup lookup = SymbolLookup.loaderLookup();\n-        {\n-            func_addr = lookup.lookup(\"func\").orElseThrow();\n-            MethodType mt = MethodType.methodType(void.class);\n-            FunctionDescriptor fd = FunctionDescriptor.ofVoid();\n-            func_v = abi.downcallHandle(fd);\n-            func = insertArguments(func_v, 0, func_addr);\n-        }\n-        {\n-            identity_addr = lookup.lookup(\"identity\").orElseThrow();\n-            FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT);\n-            identity_v = abi.downcallHandle(fd);\n-            identity = insertArguments(identity_v, 0, identity_addr);\n-        }\n-        identity_struct_addr = lookup.lookup(\"identity_struct\").orElseThrow();\n-        identity_struct_v = abi.downcallHandle(\n-                FunctionDescriptor.of(POINT_LAYOUT, POINT_LAYOUT));\n-        identity_struct = insertArguments(identity_struct_v, 0, identity_struct_addr);\n-\n-        identity_struct_3_addr = lookup.lookup(\"identity_struct_3\").orElseThrow();\n-        identity_struct_3_v = abi.downcallHandle(\n-                FunctionDescriptor.of(POINT_LAYOUT, POINT_LAYOUT, POINT_LAYOUT, POINT_LAYOUT));\n-        identity_struct_3 = insertArguments(identity_struct_3_v, 0, identity_struct_3_addr);\n-\n-        identity_memory_address_addr = lookup.lookup(\"identity_memory_address\").orElseThrow();\n-        identity_memory_address_v = abi.downcallHandle(\n-                FunctionDescriptor.of(C_POINTER, C_POINTER));\n-        identity_memory_address = insertArguments(identity_memory_address_v, 0, identity_memory_address_addr);\n-\n-        identity_memory_address_3_addr = lookup.lookup(\"identity_memory_address_3\").orElseThrow();\n-        identity_memory_address_3_v = abi.downcallHandle(\n-                FunctionDescriptor.of(C_POINTER, C_POINTER, C_POINTER, C_POINTER));\n-        identity_memory_address_3 = insertArguments(identity_memory_address_3_v, 0, identity_memory_address_3_addr);\n-\n-        args1_addr = lookup.lookup(\"args1\").orElseThrow();\n-        args1_v = abi.downcallHandle(\n-                FunctionDescriptor.ofVoid(C_LONG_LONG));\n-        args1 = insertArguments(args1_v, 0, args1_addr);\n-\n-        args2_addr = lookup.lookup(\"args2\").orElseThrow();\n-        args2_v = abi.downcallHandle(\n-                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE));\n-        args2 = insertArguments(args2_v, 0, args2_addr);\n-\n-        args3_addr = lookup.lookup(\"args3\").orElseThrow();\n-        args3_v = abi.downcallHandle(\n-                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG));\n-        args3 = insertArguments(args3_v, 0, args3_addr);\n-\n-        args4_addr = lookup.lookup(\"args4\").orElseThrow();\n-        args4_v = abi.downcallHandle(\n-                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE));\n-        args4 = insertArguments(args4_v, 0, args4_addr);\n-\n-        args5_addr = lookup.lookup(\"args5\").orElseThrow();\n-        args5_v = abi.downcallHandle(\n-                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG));\n-        args5 = insertArguments(args5_v, 0, args5_addr);\n-\n-        args10_addr = lookup.lookup(\"args10\").orElseThrow();\n-        args10_v = abi.downcallHandle(\n-                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG,\n-                                          C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE));\n-        args10 = insertArguments(args10_v, 0, args10_addr);\n-    }\n-\n-    static native void blank();\n-    static native int identity(int x);\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadHelper.java","additions":0,"deletions":163,"binary":false,"changes":163,"status":"deleted"},{"patch":"@@ -1,138 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.jdk.incubator.foreign;\n-\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.ResourceScope;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.TearDown;\n-import org.openjdk.jmh.annotations.Warmup;\n-import sun.misc.Unsafe;\n-\n-import jdk.incubator.foreign.MemorySegment;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-import java.util.concurrent.TimeUnit;\n-\n-import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.MILLISECONDS)\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\" })\n-public class LoopOverConstant {\n-\n-    static final Unsafe unsafe = Utils.unsafe;\n-\n-    static final int ELEM_SIZE = 1_000_000;\n-    static final int CARRIER_SIZE = (int)JAVA_INT.byteSize();\n-    static final int ALLOC_SIZE = ELEM_SIZE * CARRIER_SIZE;\n-\n-    static final long unsafe_addr = unsafe.allocateMemory(ALLOC_SIZE);\n-\n-    \/\/setup unsafe address\n-\n-    static {\n-        for (int i = 0; i < ELEM_SIZE; i++) {\n-            unsafe.putInt(unsafe_addr + (i * CARRIER_SIZE) , i);\n-        }\n-    }\n-\n-    \/\/setup native memory segment\n-\n-    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.newImplicitScope());\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n-\n-    static {\n-        for (int i = 0; i < ELEM_SIZE; i++) {\n-            VH_int.set(segment, (long) i, i);\n-        }\n-    }\n-\n-    \/\/setup direct buffer\n-\n-    static final ByteBuffer bb = ByteBuffer.allocateDirect(ALLOC_SIZE).order(ByteOrder.nativeOrder());\n-\n-    static {\n-        for (int i = 0; i < ELEM_SIZE; i++) {\n-            bb.putInt(i * CARRIER_SIZE , i);\n-        }\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int unsafe_get() {\n-        return unsafe.getInt(unsafe_addr);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int segment_get() {\n-        return (int)VH_int.get(segment, 0L);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int BB_get() {\n-        return bb.getInt(0);\n-    }\n-\n-    @Benchmark\n-    public int unsafe_loop() {\n-        int res = 0;\n-        for (int i = 0; i < ELEM_SIZE; i ++) {\n-            res += unsafe.getInt(unsafe_addr + (i * CARRIER_SIZE));\n-        }\n-        return res;\n-    }\n-\n-    @Benchmark\n-    public int segment_loop() {\n-        int res = 0;\n-        for (int i = 0; i < ELEM_SIZE; i++) {\n-            res += (int) VH_int.get(segment, (long)i);\n-        }\n-        return res;\n-    }\n-\n-    @Benchmark\n-    public int BB_loop() {\n-        int res = 0;\n-        for (int i = 0; i < ELEM_SIZE; i++) {\n-            res += bb.getInt(i * CARRIER_SIZE);\n-        }\n-        return res;\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverConstant.java","additions":0,"deletions":138,"binary":false,"changes":138,"status":"deleted"},{"patch":"@@ -1,112 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.jdk.incubator.foreign;\n-\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.TearDown;\n-import org.openjdk.jmh.annotations.Warmup;\n-import sun.misc.Unsafe;\n-\n-import java.lang.invoke.VarHandle;\n-import java.nio.IntBuffer;\n-import java.util.concurrent.TimeUnit;\n-\n-import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.MILLISECONDS)\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\" })\n-public class LoopOverNewHeap {\n-\n-    static final Unsafe unsafe = Utils.unsafe;\n-\n-    static final int ELEM_SIZE = 1_000_000;\n-    static final int CARRIER_SIZE = (int)JAVA_INT.byteSize();\n-\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n-\n-    @Param(value = {\"false\", \"true\"})\n-    boolean polluteProfile;\n-\n-    @Setup\n-    public void setup() {\n-        if (polluteProfile) {\n-            for (int i = 0 ; i < 10000 ; i++) {\n-                MemorySegment intB = MemorySegment.ofArray(new byte[ELEM_SIZE]);\n-                MemorySegment intI = MemorySegment.ofArray(new int[ELEM_SIZE]);\n-                MemorySegment intD = MemorySegment.ofArray(new double[ELEM_SIZE]);\n-                MemorySegment intF = MemorySegment.ofArray(new float[ELEM_SIZE]);\n-            }\n-        }\n-    }\n-\n-    @Benchmark\n-    public void unsafe_loop() {\n-        int[] elems = new int[ELEM_SIZE];\n-        for (int i = 0; i < ELEM_SIZE; i++) {\n-            unsafe.putInt(elems, Unsafe.ARRAY_INT_BASE_OFFSET + (i * CARRIER_SIZE) , i);\n-        }\n-    }\n-\n-\n-    @Benchmark\n-    public void segment_loop() {\n-        MemorySegment segment = MemorySegment.ofArray(new int[ELEM_SIZE]);\n-        for (int i = 0; i < ELEM_SIZE; i++) {\n-            VH_int.set(segment, (long) i, i);\n-        }\n-    }\n-\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    @Benchmark\n-    public void segment_loop_dontinline() {\n-        MemorySegment segment = MemorySegment.ofArray(new int[ELEM_SIZE]);\n-        for (int i = 0; i < ELEM_SIZE; i++) {\n-            VH_int.set(segment, (long) i, i);\n-        }\n-    }\n-\n-    @Benchmark\n-    public void buffer_loop() {\n-        IntBuffer buffer = IntBuffer.wrap(new int[ELEM_SIZE]);\n-        for (int i = 0; i < ELEM_SIZE; i++) {\n-            buffer.put(i , i);\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNewHeap.java","additions":0,"deletions":112,"binary":false,"changes":112,"status":"deleted"},{"patch":"@@ -1,136 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.jdk.incubator.foreign;\n-\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SymbolLookup;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-import java.util.concurrent.TimeUnit;\n-\n-import static java.lang.invoke.MethodHandles.lookup;\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n-public class QSort extends CLayouts {\n-\n-    static final CLinker abi = CLinker.systemCLinker();\n-    static final MethodHandle clib_qsort;\n-    static final NativeSymbol native_compar;\n-    static final NativeSymbol panama_upcall_compar;\n-    static final long jni_upcall_compar;\n-\n-    static final int[] INPUT = { 5, 3, 2, 7, 8, 12, 1, 7 };\n-    static final MemorySegment INPUT_SEGMENT;\n-\n-    static NativeSymbol qsort_addr = abi.lookup(\"qsort\").get();\n-\n-    static {\n-        INPUT_SEGMENT = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(INPUT.length, JAVA_INT), ResourceScope.globalScope());\n-        INPUT_SEGMENT.copyFrom(MemorySegment.ofArray(INPUT));\n-\n-        System.loadLibrary(\"QSortJNI\");\n-        jni_upcall_compar = JNICB.makeCB(\"org\/openjdk\/bench\/jdk\/incubator\/foreign\/QSort\", \"jni_upcall_compar\", \"(II)I\");\n-\n-        try {\n-            clib_qsort = abi.downcallHandle(\n-                    qsort_addr,\n-                    FunctionDescriptor.ofVoid(C_POINTER, C_LONG_LONG, C_LONG_LONG, C_POINTER)\n-            );\n-            System.loadLibrary(\"QSort\");\n-            native_compar = SymbolLookup.loaderLookup().lookup(\"compar\").orElseThrow();\n-            panama_upcall_compar = abi.upcallStub(\n-                    lookup().findStatic(QSort.class,\n-                            \"panama_upcall_compar\",\n-                            MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class)),\n-                    FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER),\n-                    ResourceScope.globalScope()\n-            );\n-        } catch (ReflectiveOperationException e) {\n-            throw new BootstrapMethodError(e);\n-        }\n-    }\n-\n-    static native void jni_qsort_optimized(int[] array, long cb);\n-    static native void jni_qsort_naive(int[] array);\n-\n-    @FunctionalInterface\n-    interface JNIComparator {\n-        int cmp(int e0, int e1);\n-    }\n-\n-    static final JNIComparator COMP = QSort::jni_upcall_compar;\n-\n-    @Benchmark\n-    public void native_qsort() throws Throwable {\n-         clib_qsort.invokeExact((Addressable)INPUT_SEGMENT, (long) INPUT.length, JAVA_INT.byteSize(), (Addressable)native_compar);\n-    }\n-\n-    @Benchmark\n-    public void jni_upcall_qsort_optimized() {\n-        jni_qsort_optimized(INPUT, jni_upcall_compar);\n-    }\n-\n-    @Benchmark\n-    public void jni_upcall_qsort_naive() {\n-        jni_qsort_naive(INPUT);\n-    }\n-\n-    @Benchmark\n-    public void panama_upcall_qsort() throws Throwable {\n-        clib_qsort.invokeExact((Addressable)INPUT_SEGMENT, (long) INPUT.length, JAVA_INT.byteSize(), (Addressable)panama_upcall_compar);\n-    }\n-\n-    private static int getIntAbsolute(MemoryAddress addr) {\n-        return addr.get(JAVA_INT, 0);\n-    }\n-\n-    static int panama_upcall_compar(MemoryAddress e0, MemoryAddress e1) {\n-        return Integer.compare(getIntAbsolute(e0), getIntAbsolute(e1));\n-    }\n-\n-    static int jni_upcall_compar(int j0, int j1) {\n-        return Integer.compare(j0, j1);\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/QSort.java","additions":0,"deletions":136,"binary":false,"changes":136,"status":"deleted"},{"patch":"@@ -1,146 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.bench.jdk.incubator.foreign;\n-\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SegmentAllocator;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.TearDown;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.util.concurrent.TimeUnit;\n-\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n-public class StrLenTest extends CLayouts {\n-\n-    ResourceScope scope = ResourceScope.newImplicitScope();\n-\n-    SegmentAllocator segmentAllocator;\n-    SegmentAllocator arenaAllocator = SegmentAllocator.newNativeArena(scope);\n-\n-    @Param({\"5\", \"20\", \"100\"})\n-    public int size;\n-    public String str;\n-\n-    static {\n-        System.loadLibrary(\"StrLen\");\n-    }\n-\n-    static final MethodHandle STRLEN;\n-\n-    static {\n-        CLinker abi = CLinker.systemCLinker();\n-        STRLEN = abi.downcallHandle(abi.lookup(\"strlen\").get(),\n-                FunctionDescriptor.of(C_INT, C_POINTER));\n-    }\n-\n-    @Setup\n-    public void setup() {\n-        str = makeString(size);\n-        segmentAllocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(size + 1, ResourceScope.newConfinedScope()));\n-    }\n-\n-    @TearDown\n-    public void tearDown() {\n-        scope.close();\n-    }\n-\n-    @Benchmark\n-    public int jni_strlen() throws Throwable {\n-        return strlen(str);\n-    }\n-\n-    @Benchmark\n-    public int panama_strlen() throws Throwable {\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(str.length() + 1, scope);\n-            segment.setUtf8String(0, str);\n-            return (int)STRLEN.invokeExact((Addressable)segment);\n-        }\n-    }\n-\n-    @Benchmark\n-    public int panama_strlen_arena() throws Throwable {\n-        return (int)STRLEN.invokeExact((Addressable)arenaAllocator.allocateUtf8String(str));\n-    }\n-\n-    @Benchmark\n-    public int panama_strlen_prefix() throws Throwable {\n-        return (int)STRLEN.invokeExact((Addressable)segmentAllocator.allocateUtf8String(str));\n-    }\n-\n-    @Benchmark\n-    public int panama_strlen_unsafe() throws Throwable {\n-        MemoryAddress address = makeStringUnsafe(str);\n-        int res = (int) STRLEN.invokeExact((Addressable)address);\n-        freeMemory(address);\n-        return res;\n-    }\n-\n-    static MemoryAddress makeStringUnsafe(String s) {\n-        byte[] bytes = s.getBytes();\n-        int len = bytes.length;\n-        MemoryAddress address = allocateMemory(len + 1);\n-        MemorySegment str = MemorySegment.ofAddress(address, len + 1, ResourceScope.globalScope());\n-        str.copyFrom(MemorySegment.ofArray(bytes));\n-        str.set(JAVA_BYTE, len, (byte)0);\n-        return address;\n-    }\n-\n-    static native int strlen(String str);\n-\n-    static String makeString(int size) {\n-        String lorem = \"\"\"\n-                Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et\n-                 dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip\n-                 ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu\n-                 fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt\n-                 mollit anim id est laborum.\n-                \"\"\";\n-        return lorem.substring(0, size);\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":0,"deletions":146,"binary":false,"changes":146,"status":"deleted"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.jdk.incubator.foreign;\n-\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.SymbolLookup;\n-import jdk.incubator.foreign.ResourceScope;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.util.concurrent.TimeUnit;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n-public class VaList extends CLayouts {\n-\n-    static final CLinker linker = CLinker.systemCLinker();\n-    static {\n-        System.loadLibrary(\"VaList\");\n-    }\n-\n-    static final MethodHandle MH_ellipsis;\n-    static final MethodHandle MH_vaList;\n-\n-    static {\n-        SymbolLookup lookup = SymbolLookup.loaderLookup();\n-        MH_ellipsis = linker.downcallHandle(lookup.lookup(\"ellipsis\").get(),\n-                FunctionDescriptor.ofVoid(C_INT).asVariadic(C_INT, C_DOUBLE, C_LONG_LONG));\n-        MH_vaList = linker.downcallHandle(lookup.lookup(\"vaList\").get(),\n-                FunctionDescriptor.ofVoid(C_INT, C_POINTER));\n-    }\n-\n-    @Benchmark\n-    public void ellipsis() throws Throwable {\n-        MH_ellipsis.invokeExact(3,\n-                                1, 2D, 3L);\n-    }\n-\n-    @Benchmark\n-    public void vaList() throws Throwable {\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            jdk.incubator.foreign.VaList vaList = jdk.incubator.foreign.VaList.make(b ->\n-                    b.addVarg(C_INT, 1)\n-                            .addVarg(C_DOUBLE, 2D)\n-                            .addVarg(C_LONG_LONG, 3L), scope);\n-            MH_vaList.invokeExact(3,\n-                    (Addressable)vaList);\n-        }\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/VaList.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.jdk.incubator.foreign;\n-\n-import jdk.incubator.foreign.MemoryHandles;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.TearDown;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.util.concurrent.TimeUnit;\n-\n-import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules\", \"jdk.incubator.foreign\" })\n-public class VarHandleExact {\n-\n-    static final VarHandle exact;\n-    static final VarHandle generic;\n-\n-    static {\n-        generic = MemoryHandles.varHandle(JAVA_INT);\n-        exact = generic.withInvokeExactBehavior();\n-    }\n-\n-    MemorySegment data;\n-\n-    @Setup\n-    public void setup() {\n-        data = MemorySegment.allocateNative(JAVA_INT, ResourceScope.newConfinedScope());\n-    }\n-\n-    @TearDown\n-    public void tearDown() {\n-        data.scope().close();\n-    }\n-\n-    @Benchmark\n-    public void exact_exactInvocation() {\n-        exact.set(data, (long) 0, 42);\n-    }\n-\n-    @Benchmark\n-    public void generic_genericInvocation() {\n-        generic.set(data, 0, 42);\n-    }\n-\n-    @Benchmark\n-    public void generic_exactInvocation() {\n-        generic.set(data, (long) 0, 42);\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/VarHandleExact.java","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include <jni.h>\n-#include <stdlib.h>\n-#include \"libCallOverhead.c\"\n-\n-JNIEXPORT void JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_CallOverheadHelper_blank\n-  (JNIEnv *env, jclass cls) {\n-    func();\n-}\n-\n-JNIEXPORT jint JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_CallOverheadHelper_identity\n-  (JNIEnv *env, jclass cls, jint x) {\n-    return identity(x);\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libCallOverheadJNI.c","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,89 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <jni.h>\n-\n-#include <stdlib.h>\n-\n-#include \"jlong.h\"\n-#include \"JNICB.h\"\n-\n-#ifdef _WIN64\n-#define THREAD_LOCAL __declspec(thread)\n-#else\n-#define THREAD_LOCAL __thread\n-#endif\n-\n-THREAD_LOCAL struct {\n-  JNICB cb;\n-  JNIEnv* env;\n-} ctx_opt;\n-\n-static int comparator(const void* e0, const void* e1) {\n-    JNICB jniCb = ctx_opt.cb;\n-    JNIEnv* env = ctx_opt.env;\n-    jint j0 = *((jint*) e0);\n-    jint j1 = *((jint*) e1);\n-    return (*env)->CallStaticIntMethod(env, jniCb->holder, jniCb->mid, j0, j1);\n-}\n-\n-JNIEXPORT void JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_QSort_jni_1qsort_1optimized\n-        (JNIEnv *env, jclass cls, jintArray arr, jlong cb) {\n-\n-    ctx_opt.cb = jlong_to_ptr(cb);\n-    ctx_opt.env = env;\n-\n-    jint* ints = (*env)->GetIntArrayElements(env, arr, NULL);\n-    jsize length = (*env)->GetArrayLength(env, arr);\n-\n-    qsort(ints, length, sizeof(jint), &comparator);\n-\n-    (*env)->ReleaseIntArrayElements(env, arr, ints, 0);\n-}\n-\n-JavaVM* VM = NULL;\n-\n-int java_cmp(const void *a, const void *b) {\n-   int v1 = *((int*)a);\n-   int v2 = *((int*)b);\n-\n-   JNIEnv* env;\n-   (*VM)->GetEnv(VM, (void**) &env, JNI_VERSION_10);\n-\n-   jclass qsortClass = (*env)->FindClass(env, \"org\/openjdk\/bench\/jdk\/incubator\/foreign\/QSort\");\n-   jmethodID methodId = (*env)->GetStaticMethodID(env, qsortClass, \"jni_upcall_compar\", \"(II)I\");\n-\n-   return (*env)->CallStaticIntMethod(env, qsortClass, methodId, v1, v2);\n-}\n-\n-JNIEXPORT void JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_QSort_jni_1qsort_1naive\n-        (JNIEnv *env, jclass cls, jintArray arr) {\n-    if (VM == NULL) {\n-        (*env)->GetJavaVM(env, &VM);\n-    }\n-\n-    jint* carr = (*env)->GetIntArrayElements(env, arr, 0);\n-    jsize length = (*env)->GetArrayLength(env, arr);\n-    qsort(carr, length, sizeof(jint), java_cmp);\n-    (*env)->ReleaseIntArrayElements(env, arr, carr, 0);\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libQSortJNI.c","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <jni.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-JNIEXPORT jint JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_StrLenTest_strlen(JNIEnv *const env, const jclass cls, const jstring text) {\n-    const char *str = (*env)->GetStringUTFChars(env, text, NULL);\n-    int len = (int)strlen(str);\n-    (*env)->ReleaseStringUTFChars(env, text, str);\n-    return len;\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libStrLen.c","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include <jni.h>\n-#include <stdlib.h>\n-\n-#include \"jlong.h\"\n-#include \"JNICB.h\"\n-\n-JNIEXPORT void JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_Upcalls_blank\n-  (JNIEnv *env, jclass cls, jlong cb) {\n-    JNICB jniCb = jlong_to_ptr(cb);\n-    (*env)->CallStaticVoidMethod(env, jniCb->holder, jniCb->mid);\n-}\n-\n-JNIEXPORT jint JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_Upcalls_identity\n-  (JNIEnv *env, jclass cls, jint x, jlong cb) {\n-    JNICB jniCb = jlong_to_ptr(cb);\n-    return (*env)->CallStaticIntMethod(env, jniCb->holder, jniCb->mid, x);\n-}\n-\n-JNIEXPORT jint JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_Upcalls_args5\n-  (JNIEnv *env, jclass cls,\n-      jlong a0, jdouble a1, jlong a2, jdouble a3, jlong a4,\n-      jlong cb) {\n-    JNICB jniCb = jlong_to_ptr(cb);\n-    return (*env)->CallStaticIntMethod(env, jniCb->holder, jniCb->mid, a0, a1, a2, a3, a4);\n-}\n-\n-JNIEXPORT jint JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_Upcalls_args10\n-  (JNIEnv *env, jclass cls,\n-      jlong a0, jdouble a1, jlong a2, jdouble a3, jlong a4,\n-      jdouble a5, jlong a6, jdouble a7, jlong a8, jdouble a9,\n-      jlong cb) {\n-    JNICB jniCb = jlong_to_ptr(cb);\n-    return (*env)->CallStaticIntMethod(env, jniCb->holder, jniCb->mid, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libUpcallsJNI.c","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,126 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.jdk.incubator.foreign.points;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.TearDown;\n-import org.openjdk.jmh.annotations.Warmup;\n-import org.openjdk.bench.jdk.incubator.foreign.points.support.BBPoint;\n-import org.openjdk.bench.jdk.incubator.foreign.points.support.JNIPoint;\n-import org.openjdk.bench.jdk.incubator.foreign.points.support.PanamaPoint;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n-public class PointsAccess {\n-\n-    BBPoint BBPoint;\n-    PanamaPoint panamaPoint;\n-    JNIPoint JNIPoint;\n-\n-    @Setup\n-    public void setup() {\n-        BBPoint = new BBPoint(0, 0);\n-        panamaPoint = new PanamaPoint(0, 0);\n-        JNIPoint = new JNIPoint(0, 0);\n-    }\n-\n-    @TearDown\n-    public void tearDown() {\n-        JNIPoint.free();\n-        panamaPoint.close();\n-    }\n-\n-    @Benchmark\n-    public void BB_set() throws Throwable {\n-        BBPoint.setX(10);\n-    }\n-\n-    @Benchmark\n-    public int BB_get() throws Throwable {\n-        return BBPoint.getX();\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n-    public int BB_get_loop() throws Throwable {\n-        int sum = 0;\n-        for (int i = 0; i < 1_000_000; i++) {\n-            sum += BBPoint.getX();\n-        }\n-        return sum;\n-    }\n-\n-    @Benchmark\n-    public void jni_set() throws Throwable {\n-        JNIPoint.setX(10);\n-    }\n-\n-    @Benchmark\n-    public int jni_get() throws Throwable {\n-        return JNIPoint.getX();\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n-    public int jni_get_loop() throws Throwable {\n-        int sum = 0;\n-        for (int i = 0; i < 1_000_000; i++) {\n-            sum += JNIPoint.getX();\n-        }\n-        return sum;\n-    }\n-\n-    @Benchmark\n-    public void panama_set() throws Throwable {\n-        panamaPoint.setX(10);\n-    }\n-\n-    @Benchmark\n-    public int panama_get() throws Throwable {\n-        return panamaPoint.getX();\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n-    public int panama_get_loop() throws Throwable {\n-        int sum = 0;\n-        for (int i = 0; i < 1_000_000; i++) {\n-            sum += panamaPoint.getX();\n-        }\n-        return sum;\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/PointsAccess.java","additions":0,"deletions":126,"binary":false,"changes":126,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.jdk.incubator.foreign.points;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-import org.openjdk.bench.jdk.incubator.foreign.points.support.BBPoint;\n-import org.openjdk.bench.jdk.incubator.foreign.points.support.JNIPoint;\n-import org.openjdk.bench.jdk.incubator.foreign.points.support.PanamaPoint;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n-public class PointsAlloc {\n-\n-    @Benchmark\n-    public Object jni_ByteBuffer_alloc() throws Throwable {\n-        return new BBPoint(0, 0);\n-    }\n-\n-    @Benchmark\n-    public Object jni_long_alloc() throws Throwable {\n-        return new JNIPoint(0, 0);\n-    }\n-\n-    @Benchmark\n-    public Object panama_alloc() throws Throwable {\n-        return new PanamaPoint(0, 0);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/PointsAlloc.java","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.jdk.incubator.foreign.points;\n-\n-import org.openjdk.bench.jdk.incubator.foreign.points.support.BBPoint;\n-import org.openjdk.bench.jdk.incubator.foreign.points.support.JNIPoint;\n-import org.openjdk.bench.jdk.incubator.foreign.points.support.PanamaPoint;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.TearDown;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n-public class PointsDistance {\n-\n-    BBPoint jniP1;\n-    BBPoint jniP2;\n-\n-    JNIPoint nativeP1;\n-    JNIPoint nativeP2;\n-\n-    PanamaPoint panamaPointP1;\n-    PanamaPoint panamaPointP2;\n-\n-    @Setup\n-    public void setup() {\n-        jniP1 = new BBPoint(0, 0);\n-        jniP2 = new BBPoint(1, 1);\n-\n-        nativeP1 = new JNIPoint(0, 0);\n-        nativeP2 = new JNIPoint(1, 1);\n-\n-        panamaPointP1 = new PanamaPoint(0, 0);\n-        panamaPointP2 = new PanamaPoint(1, 1);\n-    }\n-\n-    @TearDown\n-    public void tearDown() {\n-        nativeP1.free();\n-        nativeP2.free();\n-\n-        panamaPointP1.close();\n-        panamaPointP2.close();\n-    }\n-\n-    @Benchmark\n-    public double jni_ByteBuffer() throws Throwable {\n-        return jniP1.distanceTo(jniP2);\n-    }\n-\n-    @Benchmark\n-    public double jni_long() throws Throwable {\n-        return nativeP1.distanceTo(nativeP2);\n-    }\n-\n-    @Benchmark\n-    public double panama_MemorySegment() throws Throwable {\n-        return panamaPointP1.distanceTo(panamaPointP2);\n-    }\n-\n-    @Benchmark\n-    public double panama_MemoryAddress() throws Throwable {\n-        return panamaPointP1.distanceToPtrs(panamaPointP2);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/PointsDistance.java","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.jdk.incubator.foreign.points;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Level;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-import org.openjdk.bench.jdk.incubator.foreign.points.support.JNIPoint;\n-import org.openjdk.bench.jdk.incubator.foreign.points.support.PanamaPoint;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n-public class PointsFree {\n-\n-    JNIPoint jniPoint;\n-    PanamaPoint panamaPoint;\n-\n-    @Setup(Level.Invocation)\n-    public void setup() {\n-        jniPoint = new JNIPoint(0, 0);\n-        panamaPoint = new PanamaPoint(0, 0);\n-    }\n-\n-    @Benchmark\n-    public void jni_long_free() throws Throwable {\n-        jniPoint.close();\n-    }\n-\n-    @Benchmark\n-    public void panama_free() throws Throwable {\n-        panamaPoint.close();\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/PointsFree.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.jdk.incubator.foreign.points.support;\n-\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.SymbolLookup;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import org.openjdk.bench.jdk.incubator.foreign.CLayouts;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-\n-import static java.lang.invoke.MethodType.methodType;\n-import static jdk.incubator.foreign.MemoryLayout.PathElement.groupElement;\n-\n-public class PanamaPoint extends CLayouts implements AutoCloseable {\n-\n-    public static final MemoryLayout LAYOUT = MemoryLayout.structLayout(\n-        C_INT.withName(\"x\"),\n-        C_INT.withName(\"y\")\n-    );\n-\n-    private static final VarHandle VH_x = LAYOUT.varHandle(groupElement(\"x\"));\n-    private static final VarHandle VH_y = LAYOUT.varHandle(groupElement(\"y\"));\n-    private static final MethodHandle MH_distance;\n-    private static final MethodHandle MH_distance_ptrs;\n-\n-    static {\n-        CLinker abi = CLinker.systemCLinker();\n-        System.loadLibrary(\"Point\");\n-        SymbolLookup lookup = SymbolLookup.loaderLookup();\n-        MH_distance = abi.downcallHandle(\n-            lookup.lookup(\"distance\").get(),\n-                FunctionDescriptor.of(C_DOUBLE, LAYOUT, LAYOUT)\n-        );\n-        MH_distance_ptrs = abi.downcallHandle(\n-                lookup.lookup(\"distance_ptrs\").get(),\n-                FunctionDescriptor.of(C_DOUBLE, C_POINTER, C_POINTER)\n-        );\n-    }\n-\n-    private final MemorySegment segment;\n-\n-    public PanamaPoint(int x, int y) {\n-        this(MemorySegment.allocateNative(LAYOUT, ResourceScope.newConfinedScope()), x, y);\n-    }\n-\n-    public PanamaPoint(MemorySegment segment, int x, int y) {\n-        this(segment);\n-        setX(x);\n-        setY(y);\n-    }\n-\n-    public PanamaPoint(MemorySegment segment) {\n-        this.segment = segment;\n-    }\n-\n-    public void setX(int x) {\n-        VH_x.set(segment, x);\n-    }\n-\n-    public int getX() {\n-        return (int) VH_x.get(segment);\n-    }\n-\n-    public void setY(int y) {\n-        VH_y.set(segment, y);\n-    }\n-\n-    public int getY() {\n-        return (int) VH_y.get(segment);\n-    }\n-\n-    public double distanceTo(PanamaPoint other) {\n-        try {\n-            return (double) MH_distance.invokeExact(segment, other.segment);\n-        } catch (Throwable throwable) {\n-            throw new InternalError(throwable);\n-        }\n-    }\n-\n-    public double distanceToPtrs(PanamaPoint other) {\n-        try {\n-            return (double) MH_distance_ptrs.invokeExact((Addressable)segment, (Addressable)other.segment);\n-        } catch (Throwable throwable) {\n-            throw new InternalError(throwable);\n-        }\n-    }\n-\n-    @Override\n-    public void close() {\n-        segment.scope().close();\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/support\/PanamaPoint.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include <jni.h>\n-#include <stdlib.h>\n-#include \"jlong.h\"\n-#include <math.h>\n-\n-#include \"points.h\"\n-\n-double distance(Point p1, Point p2) {\n-    int xDist = abs(p1.x - p2.x);\n-    int yDist = abs(p1.y - p2.y);\n-    return sqrt((xDist * xDist) + (yDist * yDist));\n-}\n-\n-JNIEXPORT jlong JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_points_support_JNIPoint_allocate\n-  (JNIEnv *env, jclass nativePointClass) {\n-    Point* p = malloc(sizeof *p);\n-    return ptr_to_jlong(p);\n-}\n-\n-JNIEXPORT void JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_points_support_JNIPoint_free\n-  (JNIEnv *env, jclass cls, jlong thisPoint) {\n-    free(jlong_to_ptr(thisPoint));\n-}\n-\n-JNIEXPORT jint JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_points_support_JNIPoint_getX\n-  (JNIEnv *env, jclass cls, jlong thisPoint) {\n-    Point* point = jlong_to_ptr(thisPoint);\n-    return point->x;\n-}\n-\n-JNIEXPORT void JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_points_support_JNIPoint_setX\n-  (JNIEnv *env, jclass cls, jlong thisPoint, jint value) {\n-    Point* point = jlong_to_ptr(thisPoint);\n-    point->x = value;\n-}\n-\n-JNIEXPORT jint JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_points_support_JNIPoint_getY\n-  (JNIEnv *env, jclass cls, jlong thisPoint) {\n-    Point* point = jlong_to_ptr(thisPoint);\n-    return point->y;\n-}\n-\n-JNIEXPORT void JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_points_support_JNIPoint_setY\n-  (JNIEnv *env, jclass cls, jlong thisPoint, jint value) {\n-    Point* point = jlong_to_ptr(thisPoint);\n-    point->y = value;\n-}\n-\n-JNIEXPORT jdouble JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_points_support_JNIPoint_distance\n-  (JNIEnv *env, jclass cls, jlong thisPoint, jlong other) {\n-    Point* p1 = jlong_to_ptr(thisPoint);\n-    Point* p2 = jlong_to_ptr(other);\n-    return distance(*p1, *p2);\n-}\n-\n-JNIEXPORT jdouble JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_points_support_BBPoint_distance\n-  (JNIEnv *env, jclass ignored, jobject buffP1, jobject buffP2) {\n-    Point* p1 = (Point*) (*env)->GetDirectBufferAddress(env, buffP1);\n-    Point* p2 = (Point*) (*env)->GetDirectBufferAddress(env, buffP2);\n-    return distance(*p1, *p2);\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/support\/libJNIPoint.c","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,3 +29,3 @@\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -47,1 +47,1 @@\n-import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n@@ -55,1 +55,1 @@\n-    \"--add-modules=jdk.incubator.foreign,jdk.incubator.vector\",\n+    \"--add-modules=jdk.incubator.vector\",\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,3 @@\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n@@ -55,1 +55,1 @@\n-    \"--add-modules=jdk.incubator.foreign,jdk.incubator.vector\",\n+    \"--add-modules=jdk.incubator.vector\",\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShort.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}