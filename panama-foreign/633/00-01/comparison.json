{"files":[{"patch":"@@ -2471,1 +2471,1 @@\n-    final ResourceScope loaderScope = ResourceScopeImpl.heapScope(this);\n+    private final ResourceScope loaderScope = ResourceScopeImpl.heapScope(this);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,0 +111,4 @@\n+ * <h2>Symbol lookup<\/h2>\n+ * Clients can {@linkplain #lookup(String) look up} symbols in the standard libraries associated with this linker.\n+ * The set of symbols available for lookup is unspecified, as it depends on the platform and on the operating system.\n+ *\n@@ -166,1 +170,1 @@\n-     * @param name the name of the symbol\n+     * @param name the symbol name\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/CLinker.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -138,1 +139,1 @@\n- * {@linkplain java.lang.invoke.MethodHandles#memoryAccessVarHandle(ValueLayout) value layout}, and then adapt it using the var handle combinator\n+ * {@linkplain MethodHandles#memoryAccessVarHandle(ValueLayout) value layout}, and then adapt it using the var handle combinator\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.Utils;\n@@ -48,2 +49,0 @@\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n@@ -57,1 +56,0 @@\n-import java.lang.reflect.ReflectPermission;\n@@ -7931,23 +7929,1 @@\n-        Class<?> carrier = layout.carrier();\n-        Class<?> baseCarrier = carrier;\n-        if (carrier == MemoryAddress.class) {\n-            baseCarrier = switch ((int) ValueLayout.ADDRESS.byteSize()) {\n-                case 8 -> long.class;\n-                case 4 -> int.class;\n-                default -> throw new UnsupportedOperationException(\"Unsupported address layout\");\n-            };\n-        } else if (carrier == boolean.class) {\n-            baseCarrier = byte.class;\n-        }\n-\n-        VarHandle handle = VarHandles.makeMemoryAddressViewHandle(baseCarrier, false, layout.byteAlignment() - 1, layout.order());\n-\n-        if (carrier == boolean.class) {\n-            return MethodHandles.filterValue(handle, VarHandles.BOOL_TO_BYTE, VarHandles.BYTE_TO_BOOL);\n-        } else if (carrier == MemoryAddress.class) {\n-            return MethodHandles.filterValue(handle,\n-                    MethodHandles.explicitCastArguments(VarHandles.ADDRESS_TO_LONG, MethodType.methodType(baseCarrier, MemoryAddress.class)),\n-                    MethodHandles.explicitCastArguments(VarHandles.LONG_TO_ADDRESS, MethodType.methodType(MemoryAddress.class, baseCarrier)));\n-        } else {\n-            return handle;\n-        }\n+        return Utils.makeMemoryAccessVarHandle(layout, false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":2,"deletions":26,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -49,20 +48,0 @@\n-    static final MethodHandle BYTE_TO_BOOL;\n-    static final MethodHandle BOOL_TO_BYTE;\n-    static final MethodHandle ADDRESS_TO_LONG;\n-    static final MethodHandle LONG_TO_ADDRESS;\n-\n-    static {\n-        try {\n-            BYTE_TO_BOOL = MethodHandles.lookup().findStatic(VarHandles.class, \"byteToBoolean\",\n-                    MethodType.methodType(boolean.class, byte.class));\n-            BOOL_TO_BYTE = MethodHandles.lookup().findStatic(VarHandles.class, \"booleanToByte\",\n-                    MethodType.methodType(byte.class, boolean.class));\n-            ADDRESS_TO_LONG = MethodHandles.lookup().findVirtual(MemoryAddress.class, \"toRawLongValue\",\n-                    MethodType.methodType(long.class));\n-            LONG_TO_ADDRESS = MethodHandles.lookup().findStatic(MemoryAddress.class, \"ofLong\",\n-                    MethodType.methodType(MemoryAddress.class, long.class));\n-        } catch (Throwable ex) {\n-            throw new ExceptionInInitializerError(ex);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -366,5 +366,1 @@\n-        try {\n-            scope.checkValidStateSlow();\n-        } catch (ScopedMemoryAccess.ScopedAccessError ex) {\n-            throw new IllegalStateException(\"This segment is already closed\");\n-        }\n+        scope.checkValidStateSlow();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,10 +47,0 @@\n-    private static final VarHandle STATE;\n-\n-    static {\n-        try {\n-            STATE = MethodHandles.lookup().findVarHandle(SharedScope.class, \"state\", int.class);\n-        } catch (Throwable ex) {\n-            throw new ExceptionInInitializerError(ex);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedScope.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BufferLayout.java","additions":0,"deletions":0,"binary":false,"changes":0,"status":"deleted"},{"patch":"@@ -42,0 +42,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -43,3 +44,0 @@\n-import java.lang.invoke.MethodType;\n-\n-import staticjava.lang.foreign.CLinker.C_INT;\n@@ -52,4 +50,3 @@\n-    final static CLinker abi = CLinker.getInstance();\n-    final static MethodHandle foo = abi.downcallHandle(ClassLoader.findNative(\"foo\").get(),\n-            MethodType.methodType(int.class),\n-            FunctionDescriptor.of(C_INT));\n+    final static CLinker abi = CLinker.systemCLinker();\n+    final static MethodHandle foo = abi.downcallHandle(TestLinkToNativeRBP.class.getClassLoader().findNative(\"foo\").get(),\n+            FunctionDescriptor.of(ValueLayout.JAVA_INT));\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestLinkToNativeRBP.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.NativeSymbol;\n@@ -108,0 +109,4 @@\n+\n+    public static NativeSymbol findNativeOrThrow(Class<?> clazz, String name) {\n+        return clazz.getClassLoader().findNative(name).orElseThrow();\n+    }\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-                this.getClass().getClassLoader().findNative(\"struct_func\").get(),\n+                findNativeOrThrow(this.getClass(), \"struct_func\"),\n@@ -74,1 +74,1 @@\n-                this.getClass().getClassLoader().findNative(\"addr_func_6\").get(),\n+                findNativeOrThrow(this.getClass(), \"addr_func_6\"),\n@@ -116,1 +116,1 @@\n-                this.getClass().getClassLoader().findNative(\"addr_func\").get(),\n+                findNativeOrThrow(this.getClass(), \"addr_func\"),\n@@ -131,1 +131,1 @@\n-                this.getClass().getClassLoader().findNative(\"addr_func\").get(),\n+                findNativeOrThrow(this.getClass(), \"addr_func\"),\n@@ -142,1 +142,1 @@\n-                this.getClass().getClassLoader().findNative(\"addr_func_cb\").get(),\n+                findNativeOrThrow(this.getClass(), \"addr_func_cb\"),\n@@ -154,1 +154,1 @@\n-                this.getClass().getClassLoader().findNative(\"addr_func_cb\").get(),\n+                findNativeOrThrow(this.getClass(), \"addr_func_cb\"),\n@@ -166,1 +166,1 @@\n-                this.getClass().getClassLoader().findNative(\"addr_func_cb\").get(),\n+                findNativeOrThrow(this.getClass(), \"addr_func_cb\"),\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-        NativeSymbol addr = TestDowncall.class.getClassLoader().findNative(fName).get();\n+        NativeSymbol addr = findNativeOrThrow(TestDowncall.class, fName);\n@@ -87,1 +87,1 @@\n-        NativeSymbol addr = TestDowncall.class.getClassLoader().findNative(\"s\" +    fName).get();\n+        NativeSymbol addr = findNativeOrThrow(TestDowncall.class, \"s\" + fName);\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-            NativeSymbol ma = this.getClass().getClassLoader().findNative(name).get();\n+            NativeSymbol ma = findNativeOrThrow(this.getClass(), name);\n@@ -96,1 +96,1 @@\n-            NativeSymbol ma = this.getClass().getClassLoader().findNative(\"empty\").get();\n+            NativeSymbol ma = findNativeOrThrow(this.getClass(), \"empty\");\n@@ -111,1 +111,1 @@\n-            NativeSymbol ma = this.getClass().getClassLoader().findNative(\"identity_va\").get();\n+            NativeSymbol ma = findNativeOrThrow(this.getClass(), \"identity_va\");\n@@ -124,1 +124,1 @@\n-                NativeSymbol ma = this.getClass().getClassLoader().findNative(\"invoke_high_arity\" + i).get();\n+                NativeSymbol ma = findNativeOrThrow(this.getClass(), \"invoke_high_arity\" + i);\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":0,"deletions":0,"binary":false,"changes":0,"status":"deleted"},{"patch":"@@ -63,1 +63,1 @@\n-        NativeSymbol addr = TestUpcallAsync.class.getClassLoader().findNative(fName).get();\n+        NativeSymbol addr = findNativeOrThrow(TestUpcallAsync.class, fName);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallAsync.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-                    TestUpcallHighArity.class.getClassLoader().findNative(\"do_upcall\").get(),\n+                    findNativeOrThrow(TestUpcallHighArity.class, \"do_upcall\"),\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        NativeSymbol addr = TestUpcallScope.class.getClassLoader().findNative(fName).get();\n+        NativeSymbol addr = findNativeOrThrow(TestUpcallScope.class, fName);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallScope.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        NativeSymbol addr = TestUpcallStack.class.getClassLoader().findNative(\"s\" + fName).get();\n+        NativeSymbol addr = findNativeOrThrow(TestUpcallStack.class, \"s\" + fName);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-                TestUpcallStructScope.class.getClassLoader().findNative(\"do_upcall\").get(),\n+                findNativeOrThrow(TestUpcallStructScope.class, \"do_upcall\"),\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    static final NativeSymbol VARARGS_ADDR = TestVarArgs.class.getClassLoader().findNative(\"varargs\").get();\n+    static final NativeSymbol VARARGS_ADDR = findNativeOrThrow(TestVarArgs.class, \"varargs\");\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-                    TestAsyncStackWalk.class.getClassLoader().findNative(\"asyncStackWalk\").get(),\n+                    findNativeOrThrow(TestAsyncStackWalk.class, \"asyncStackWalk\"),\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-                    TestStackWalk.class.getClassLoader().findNative(\"foo\").get(),\n+                    findNativeOrThrow(TestStackWalk.class, \"foo\"),\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-        return abi.downcallHandle(VaListTest.class.getClassLoader().findNative(symbol).get(), fd);\n+        return abi.downcallHandle(findNativeOrThrow(VaListTest.class, symbol), fd);\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,3 +58,3 @@\n-        funcA = TestVirtualCalls.class.getClassLoader().findNative(\"funcA\").get();\n-        funcB = TestVirtualCalls.class.getClassLoader().findNative(\"funcB\").get();\n-        funcC = TestVirtualCalls.class.getClassLoader().findNative(\"funcC\").get();\n+        funcA = findNativeOrThrow(TestVirtualCalls.class, \"funcA\");\n+        funcB = findNativeOrThrow(TestVirtualCalls.class, \"funcB\");\n+        funcC = findNativeOrThrow(TestVirtualCalls.class, \"funcC\");\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,2 +69,2 @@\n-    final int[] bytes = new int[ELEM_SIZE];\n-    final MemorySegment bytesSegment = MemorySegment.ofArray(bytes);\n+    final int[] ints = new int[ELEM_SIZE];\n+    final MemorySegment bytesSegment = MemorySegment.ofArray(ints);\n@@ -104,2 +104,2 @@\n-        for (int i = 0 ; i < bytes.length ; i++) {\n-            bytes[i] = i;\n+        for (int i = 0; i < ints.length ; i++) {\n+            ints[i] = i;\n@@ -129,1 +129,1 @@\n-        unsafe.copyMemory(bytes, UNSAFE_INT_OFFSET, null, unsafe_addr, ALLOC_SIZE);\n+        unsafe.copyMemory(ints, UNSAFE_INT_OFFSET, null, unsafe_addr, ALLOC_SIZE);\n@@ -141,1 +141,1 @@\n-        MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, 0, bytes.length);\n+        MemorySegment.copy(ints, 0, segment, JAVA_BYTE, 0, ints.length);\n@@ -147,1 +147,1 @@\n-        MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, 0, 10);\n+        MemorySegment.copy(ints, 0, segment, JAVA_BYTE, 0, 10);\n@@ -154,1 +154,1 @@\n-        MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, 0, 10);\n+        MemorySegment.copy(ints, 0, segment, JAVA_BYTE, 0, 10);\n@@ -160,1 +160,1 @@\n-        unsafe.copyMemory(bytes, UNSAFE_INT_OFFSET, null, unsafe_addr, 10 * CARRIER_SIZE);\n+        unsafe.copyMemory(ints, UNSAFE_INT_OFFSET, null, unsafe_addr, 10 * CARRIER_SIZE);\n@@ -166,1 +166,1 @@\n-        buffer.put(0, bytes, 0, 10);\n+        buffer.put(0, ints, 0, 10);\n@@ -172,1 +172,1 @@\n-        buffer.put(0, bytes, 0, bytes.length);\n+        buffer.put(0, ints, 0, ints.length);\n@@ -179,1 +179,1 @@\n-        MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, 0, bytes.length);\n+        MemorySegment.copy(ints, 0, segment, JAVA_BYTE, 0, ints.length);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkOps.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,258 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.IntBuffer;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-preview\", \"--enable-native-access=ALL-UNNAMED\" })\n+\n+public class LoopOverSlice {\n+\n+    static final int ELEM_SIZE = 1_000_000;\n+    static final int CARRIER_SIZE = (int)JAVA_INT.byteSize();\n+    static final int ALLOC_SIZE = ELEM_SIZE * CARRIER_SIZE;\n+\n+    MemorySegment nativeSegment, heapSegment;\n+    IntBuffer nativeBuffer, heapBuffer;\n+    ResourceScope scope;\n+\n+    @Setup\n+    public void setup() {\n+        scope = ResourceScope.newConfinedScope();\n+        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, scope);\n+        heapSegment = MemorySegment.ofArray(new int[ELEM_SIZE]);\n+        nativeBuffer = ByteBuffer.allocateDirect(ALLOC_SIZE).order(ByteOrder.LITTLE_ENDIAN).asIntBuffer();\n+        heapBuffer = IntBuffer.wrap(new int[ELEM_SIZE]);\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        scope.close();\n+    }\n+\n+    @Benchmark\n+    public void native_segment_slice_loop() {\n+        new NativeSegmentWrapper(nativeSegment).forEach(NativeSegmentWrapper.Element::get);\n+    }\n+\n+    @Benchmark\n+    public void native_buffer_slice_loop() {\n+        new NativeBufferWrapper(nativeBuffer).forEach(NativeBufferWrapper.Element::get);\n+    }\n+\n+    @Benchmark\n+    public void heap_segment_slice_loop() {\n+        new HeapSegmentWrapper(heapSegment).forEach(HeapSegmentWrapper.Element::get);\n+    }\n+\n+    @Benchmark\n+    public void heap_buffer_slice_loop() {\n+        new HeapBufferWrapper(heapBuffer).forEach(HeapBufferWrapper.Element::get);\n+    }\n+\n+    class HeapSegmentWrapper implements Iterable<HeapSegmentWrapper.Element> {\n+        final MemorySegment segment;\n+\n+        public HeapSegmentWrapper(MemorySegment segment) {\n+            this.segment = segment;\n+        }\n+\n+        @Override\n+        public Iterator<Element> iterator() {\n+            return new Iterator<Element>() {\n+\n+                MemorySegment current = segment;\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return current.byteSize() > 4;\n+                }\n+\n+                @Override\n+                public Element next() {\n+                    Element element = new Element(current);\n+                    current = current.asSlice(4);\n+                    return element;\n+                }\n+            };\n+        }\n+\n+        static class Element {\n+            final MemorySegment segment;\n+\n+            public Element(MemorySegment segment) {\n+                this.segment = segment;\n+            }\n+\n+            int get() {\n+                return segment.getAtIndex(JAVA_INT, 0);\n+            }\n+        }\n+    }\n+\n+    class NativeSegmentWrapper implements Iterable<NativeSegmentWrapper.Element> {\n+        final MemorySegment segment;\n+\n+        public NativeSegmentWrapper(MemorySegment segment) {\n+            this.segment = segment;\n+        }\n+\n+        @Override\n+        public Iterator<Element> iterator() {\n+            return new Iterator<Element>() {\n+\n+                MemorySegment current = segment;\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return current.byteSize() > 4;\n+                }\n+\n+                @Override\n+                public Element next() {\n+                    Element element = new Element(current);\n+                    current = current.asSlice(4);\n+                    return element;\n+                }\n+            };\n+        }\n+\n+        static class Element {\n+            final MemorySegment segment;\n+\n+            public Element(MemorySegment segment) {\n+                this.segment = segment;\n+            }\n+\n+            int get() {\n+                return segment.getAtIndex(JAVA_INT, 0);\n+            }\n+        }\n+    }\n+\n+    class NativeBufferWrapper implements Iterable<NativeBufferWrapper.Element> {\n+        final IntBuffer buffer;\n+\n+        public NativeBufferWrapper(IntBuffer buffer) {\n+            this.buffer = buffer;\n+        }\n+\n+        @Override\n+        public Iterator<Element> iterator() {\n+            return new Iterator<Element>() {\n+\n+                IntBuffer current = buffer;\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return current.position() < current.limit();\n+                }\n+\n+                @Override\n+                public Element next() {\n+                    Element element = new Element(current);\n+                    int lim = current.limit();\n+                    current = current.slice(1, lim - 1);\n+                    return element;\n+                }\n+            };\n+        }\n+\n+        static class Element {\n+            final IntBuffer buffer;\n+\n+            public Element(IntBuffer segment) {\n+                this.buffer = segment;\n+            }\n+\n+            int get() {\n+                return buffer.get( 0);\n+            }\n+        }\n+    }\n+\n+    class HeapBufferWrapper implements Iterable<HeapBufferWrapper.Element> {\n+        final IntBuffer buffer;\n+\n+        public HeapBufferWrapper(IntBuffer buffer) {\n+            this.buffer = buffer;\n+        }\n+\n+        @Override\n+        public Iterator<Element> iterator() {\n+            return new Iterator<Element>() {\n+\n+                IntBuffer current = buffer;\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return current.position() < current.limit();\n+                }\n+\n+                @Override\n+                public Element next() {\n+                    Element element = new Element(current);\n+                    int lim = current.limit();\n+                    current = current.slice(1, lim - 1);\n+                    return element;\n+                }\n+            };\n+        }\n+\n+        static class Element {\n+            final IntBuffer buffer;\n+\n+            public Element(IntBuffer segment) {\n+                this.buffer = segment;\n+            }\n+\n+            int get() {\n+                return buffer.get( 0);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverSlice.java","additions":258,"deletions":0,"binary":false,"changes":258,"status":"added"}]}