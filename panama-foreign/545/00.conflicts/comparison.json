{"files":[{"patch":"@@ -362,0 +362,1 @@\n+<<<<<<< HEAD\n@@ -363,0 +364,3 @@\n+=======\n+JavaFrameAnchor* EntryBlob::jfa_for_frame(const frame& frame) const {\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -367,0 +371,1 @@\n+<<<<<<< HEAD\n@@ -368,0 +373,3 @@\n+=======\n+frame frame::sender_for_panama_entry_frame(RegisterMap* map) const {\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+<<<<<<< HEAD\n@@ -106,0 +107,3 @@\n+=======\n+    } else if (is_panama_entry_frame()) {\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -204,0 +208,1 @@\n+<<<<<<< HEAD\n@@ -205,0 +210,3 @@\n+=======\n+    } else if (sender_blob->is_entry_blob()) {\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -356,0 +364,1 @@\n+<<<<<<< HEAD\n@@ -357,0 +366,3 @@\n+=======\n+JavaFrameAnchor* EntryBlob::jfa_for_frame(const frame& frame) const {\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -361,0 +373,1 @@\n+<<<<<<< HEAD\n@@ -364,0 +377,5 @@\n+=======\n+frame frame::sender_for_panama_entry_frame(RegisterMap* map) const {\n+  assert(map != NULL, \"map must be set\");\n+  EntryBlob* blob = _cb->as_entry_blob();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -512,0 +530,1 @@\n+<<<<<<< HEAD\n@@ -513,0 +532,3 @@\n+=======\n+  if (is_panama_entry_frame()) return sender_for_panama_entry_frame(map);\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+<<<<<<< HEAD\n@@ -36,0 +37,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -293,0 +296,1 @@\n+<<<<<<< HEAD\n@@ -294,0 +298,3 @@\n+=======\n+  LogTarget(Trace, panama) lt;\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -422,0 +429,1 @@\n+<<<<<<< HEAD\n@@ -427,0 +435,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -445,0 +455,1 @@\n+<<<<<<< HEAD\n@@ -447,0 +458,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -451,0 +464,1 @@\n+<<<<<<< HEAD\n@@ -452,0 +466,3 @@\n+=======\n+  \/\/ 2. save mxcsr (?)\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -478,0 +495,1 @@\n+<<<<<<< HEAD\n@@ -495,0 +513,5 @@\n+=======\n+  __ block_comment(\"} preserve_callee_saved_regs \");\n+\n+  \/\/ TODO mxcsr\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -501,0 +524,1 @@\n+<<<<<<< HEAD\n@@ -502,0 +526,3 @@\n+=======\n+  \/\/ 2. restore mxcsr (?)\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -529,0 +556,1 @@\n+<<<<<<< HEAD\n@@ -535,0 +563,5 @@\n+=======\n+  __ block_comment(\"} restore_callee_saved_regs \");\n+\n+  \/\/ TODO mxcsr\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -832,0 +865,1 @@\n+<<<<<<< HEAD\n@@ -841,0 +875,11 @@\n+=======\n+  ss.print(\"panama_upcall_stub_%s\", entry->signature()->as_C_string());\n+  const char* name = _masm->code_string(ss.as_string());\n+#else \/\/ PRODUCT\n+  const char* name = \"panama_upcall_stub\";\n+#endif \/\/ PRODUCT\n+\n+  EntryBlob* blob = EntryBlob::create(name, &buffer, exception_handler_offset, receiver, jfa_offset);\n+\n+  if (TracePanamaUpcallStubs) {\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/hotspot\/cpu\/x86\/universalUpcallHandler_x86_64.cpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -713,0 +713,1 @@\n+<<<<<<< HEAD\n@@ -716,0 +717,5 @@\n+=======\n+\/\/ Implementation of EntryBlob\n+\n+EntryBlob::EntryBlob(const char* name, int size, CodeBuffer* cb, intptr_t exception_handler_offset,\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -724,0 +730,1 @@\n+<<<<<<< HEAD\n@@ -733,0 +740,11 @@\n+=======\n+EntryBlob* EntryBlob::create(const char* name, CodeBuffer* cb, intptr_t exception_handler_offset,\n+                             jobject receiver, ByteSize jfa_sp_offset) {\n+  ThreadInVMfromUnknown __tiv;  \/\/ get to VM state in case we block on CodeCache_lock\n+\n+  EntryBlob* blob = nullptr;\n+  unsigned int size = CodeBlob::allocation_size(cb, sizeof(EntryBlob));\n+  {\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    blob = new (size) EntryBlob(name, size, cb, exception_handler_offset, receiver, jfa_sp_offset);\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+<<<<<<< HEAD\n@@ -62,0 +63,3 @@\n+=======\n+\/\/    EntryBlob          : Used for upcalls from native code\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -79,0 +83,1 @@\n+<<<<<<< HEAD\n@@ -80,0 +85,3 @@\n+=======\n+class EntryBlob; \/\/ for as_entry_blob()\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -142,0 +150,1 @@\n+<<<<<<< HEAD\n@@ -143,0 +152,3 @@\n+=======\n+  virtual bool is_entry_blob() const                  { return false; }\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -156,0 +168,1 @@\n+<<<<<<< HEAD\n@@ -157,0 +170,3 @@\n+=======\n+  EntryBlob* as_entry_blob() const             { assert(is_entry_blob(), \"must be entry blob\"); return (EntryBlob*) this; }\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -387,0 +403,1 @@\n+<<<<<<< HEAD\n@@ -388,0 +405,3 @@\n+=======\n+  friend class EntryBlob;\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -729,0 +749,1 @@\n+<<<<<<< HEAD\n@@ -731,0 +752,4 @@\n+=======\n+\/\/ For Panama upcall stubs\n+class EntryBlob: public BufferBlob {\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -736,0 +761,1 @@\n+<<<<<<< HEAD\n@@ -737,0 +763,3 @@\n+=======\n+  EntryBlob(const char* name, int size, CodeBuffer* cb, intptr_t exception_handler_offset,\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -741,0 +770,1 @@\n+<<<<<<< HEAD\n@@ -742,0 +772,3 @@\n+=======\n+  static EntryBlob* create(const char* name, CodeBuffer* cb,\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -753,0 +786,1 @@\n+<<<<<<< HEAD\n@@ -754,0 +788,3 @@\n+=======\n+  virtual bool is_entry_blob() const override { return true; }\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1069,0 +1069,1 @@\n+<<<<<<< HEAD\n@@ -1070,0 +1071,3 @@\n+=======\n+    } else if(iid == vmIntrinsics::_linkToNative) {\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+<<<<<<< HEAD\n@@ -123,0 +124,3 @@\n+=======\n+JVM_ENTRY(jlong, PUH_AllocateOptimzedUpcallStub(JNIEnv *env, jclass unused, jobject mh, jobject abi, jobject conv))\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -137,0 +141,1 @@\n+<<<<<<< HEAD\n@@ -138,0 +143,3 @@\n+=======\n+JVM_ENTRY(jboolean, PUH_SupportsOptimzedUpcalls(JNIEnv *env, jclass unused))\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -146,0 +154,1 @@\n+<<<<<<< HEAD\n@@ -148,0 +157,4 @@\n+=======\n+  {CC \"allocateOptimizedUpcallStub\", CC \"(\" \"Ljava\/lang\/invoke\/MethodHandle;\" \"L\" FOREIGN_ABI \"ABIDescriptor;\" \"L\" FOREIGN_ABI \"ProgrammableUpcallHandler$CallRegs;\" \")J\", FN_PTR(PUH_AllocateOptimzedUpcallStub)},\n+  {CC \"supportsOptimizedUpcalls\", CC \"()Z\", FN_PTR(PUH_SupportsOptimzedUpcalls)},\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+<<<<<<< HEAD\n@@ -42,0 +43,4 @@\n+=======\n+  if (cb->is_entry_blob()) {\n+    handle = ((EntryBlob*)cb)->receiver();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/hotspot\/share\/prims\/upcallStubs.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1070,0 +1070,1 @@\n+<<<<<<< HEAD\n@@ -1071,0 +1072,3 @@\n+=======\n+  } else if (is_panama_entry_frame()) {\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -141,0 +141,1 @@\n+<<<<<<< HEAD\n@@ -142,0 +143,3 @@\n+=======\n+  bool is_panama_entry_frame()         const;\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -176,0 +180,1 @@\n+<<<<<<< HEAD\n@@ -177,0 +182,3 @@\n+=======\n+  frame sender_for_panama_entry_frame(RegisterMap* map) const;\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+<<<<<<< HEAD\n@@ -58,0 +59,4 @@\n+=======\n+inline bool frame::is_panama_entry_frame() const {\n+  return _cb != NULL && _cb->is_entry_blob();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/hotspot\/share\/runtime\/frame.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2084,0 +2084,1 @@\n+<<<<<<< HEAD\n@@ -2086,0 +2087,4 @@\n+=======\n+  develop(bool, TracePanamaUpcallStubs, false,                              \\\n+                \"Trace Panama upcall stub generation\")                      \\\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -515,0 +515,1 @@\n+<<<<<<< HEAD\n@@ -517,0 +518,4 @@\n+=======\n+  if (blob != NULL && blob->is_entry_blob()) {\n+    return ((EntryBlob*)blob)->exception_handler();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -1445,0 +1450,1 @@\n+<<<<<<< HEAD\n@@ -1446,0 +1452,3 @@\n+=======\n+  assert(!caller_frame.is_interpreted_frame() && !caller_frame.is_entry_frame() && !caller_frame.is_panama_entry_frame(), \"unexpected frame\");\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -1478,0 +1487,1 @@\n+<<<<<<< HEAD\n@@ -1479,0 +1489,3 @@\n+=======\n+      caller_frame.is_panama_entry_frame()) {\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -59,0 +59,5 @@\n+<<<<<<< HEAD\n+=======\n+import jdk.internal.module.IllegalAccessLogger;\n+import jdk.internal.module.IllegalNativeAccessChecker;\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -112,0 +117,1 @@\n+<<<<<<< HEAD\n@@ -114,0 +120,4 @@\n+=======\n+    \/\/ is this module a native module\n+    private volatile boolean enableNativeAccess = false;\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -140,0 +150,1 @@\n+<<<<<<< HEAD\n@@ -141,0 +152,3 @@\n+=======\n+            addEnableNativeAccess();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -144,1 +158,0 @@\n-\n@@ -157,1 +170,0 @@\n-\n@@ -254,0 +266,1 @@\n+<<<<<<< HEAD\n@@ -276,0 +289,14 @@\n+=======\n+    boolean isEnableNativeAccess() {\n+        if (enableNativeAccess) {\n+            return true;\n+        }\n+\n+        \/\/ lazy init for unnamed modules\n+        if (!isNamed() && IllegalNativeAccessChecker.enableNativeAccessAllUnnamedModules()) {\n+            enableNativeAccess = true;\n+            return true;\n+        }\n+\n+        return false;\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -443,0 +470,5 @@\n+    Module addEnableNativeAccess() {\n+        enableNativeAccess = true;\n+        return this;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -142,0 +142,10 @@\n+<<<<<<< HEAD\n+=======\n+\n+    \/**\n+     * A best-effort method that tries to find any exceptions thrown by the given method handle.\n+     * @param handle the handle to check\n+     * @return an array of exceptions, or {@code null}.\n+     *\/\n+    Class<?>[] exceptionTypes(MethodHandle handle);\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -268,0 +268,1 @@\n+<<<<<<< HEAD\n@@ -271,0 +272,4 @@\n+=======\n+        SharedSecrets.getJavaLangAccess()\n+                .addEnableNativeAccess(Modules.defineModule(null, base.descriptor(), baseUri));\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -464,0 +469,3 @@\n+        \/\/ add enable native access\n+        addEnableNativeAccess(bootLayer);\n+\n@@ -816,0 +824,15 @@\n+    private static void addEnableNativeAccess(ModuleLayer layer) {\n+        \/\/ add native modules explicitly provided on the command line\n+\n+        JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n+        for (String name : IllegalNativeAccessChecker.enableNativeAccessModules()) {\n+            Optional<Module> module = layer.findModule(name);\n+            if (module.isPresent()) {\n+                jla.addEnableNativeAccess(module.get());\n+            } else {\n+                \/\/ silently skip.\n+                \/\/ warnUnknownModule(ENABLE_NATIVE_ACCESS, name);\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleBootstrap.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -112,0 +112,1 @@\n+<<<<<<< HEAD\n@@ -113,0 +114,4 @@\n+=======\n+            String moduleName = module.isNamed()?  module.getName() : \"UNNAMED\";\n+            throw new IllegalCallerException(\"Illegal native access from module: \" + moduleName);\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/Reflection.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,0 +32,8 @@\n+<<<<<<< HEAD\n+=======\n+ *\n+ * @apiNote In the future, if the Java language permits, {@link Addressable}\n+ * may become a {@code sealed} interface, which would prohibit subclassing except by\n+ * explicitly permitted types, such as {@link MemorySegment}, {@link MemoryAddress}\n+ * and {@link CLinker.VaList}.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/Addressable.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+<<<<<<< HEAD\n@@ -35,0 +36,4 @@\n+=======\n+import jdk.internal.foreign.SystemLookup;\n+import jdk.internal.foreign.abi.SharedUtils;\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -122,0 +127,1 @@\n+<<<<<<< HEAD\n@@ -125,0 +131,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -133,0 +141,19 @@\n+<<<<<<< HEAD\n+=======\n+     * Obtains a system lookup which is suitable to find symbols in the standard C libraries. The set of symbols\n+     * available for lookup is unspecified, as it depends on the platform and on the operating system.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     * @return a system-specific library lookup which is suitable to find symbols in the standard C libraries.\n+     *\/\n+    @CallerSensitive\n+    static SymbolLookup systemLookup() {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return SystemLookup.getInstance();\n+    }\n+\n+    \/**\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -139,0 +166,8 @@\n+<<<<<<< HEAD\n+=======\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -140,1 +175,1 @@\n-     * @see LibraryLookup#lookup(String)\n+     * @see SymbolLookup\n@@ -156,0 +191,1 @@\n+<<<<<<< HEAD\n@@ -158,0 +194,9 @@\n+=======\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @see SymbolLookup\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -164,0 +209,1 @@\n+<<<<<<< HEAD\n@@ -165,0 +211,4 @@\n+=======\n+     * @throws IllegalArgumentException in the case of a method type and function descriptor mismatch, or if the symbol\n+     *                                  is {@link MemoryAddress#NULL}\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -177,0 +227,1 @@\n+<<<<<<< HEAD\n@@ -179,0 +230,12 @@\n+=======\n+     * <p>\n+     * The returned method handle will throw an {@link IllegalArgumentException} if the target address passed to it is\n+     * {@link MemoryAddress#NULL}, or a {@link NullPointerException} if the target address is {@code null}.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     **\n+     * @see SymbolLookup\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -191,0 +254,1 @@\n+<<<<<<< HEAD\n@@ -193,0 +257,13 @@\n+=======\n+     * <p>\n+     * The returned memory address is associated with the provided scope. When such scope is closed,\n+     * the corresponding native stub will be deallocated.\n+     * <p>\n+     * The target method handle should not throw any exceptions. If the target method handle does throw an exception,\n+     * the VM will exit with a non-zero exit code.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -198,0 +275,1 @@\n+<<<<<<< HEAD\n@@ -201,0 +279,4 @@\n+=======\n+     * @throws IllegalArgumentException if the target's method type and the function descriptor mismatch, or\n+     *         if it is determined that the target method handle can throw an exception.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -293,0 +375,1 @@\n+<<<<<<< HEAD\n@@ -294,0 +377,3 @@\n+=======\n+     * Converts a Java string into a null-terminated C string, using the given {@link java.nio.charset.Charset charset},\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -314,0 +400,1 @@\n+<<<<<<< HEAD\n@@ -315,0 +402,3 @@\n+=======\n+     * Converts a Java string into a null-terminated C string, using the given {@link java.nio.charset.Charset charset},\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -501,0 +591,1 @@\n+<<<<<<< HEAD\n@@ -502,0 +593,3 @@\n+=======\n+    interface VaList extends Addressable {\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -622,0 +716,1 @@\n+<<<<<<< HEAD\n@@ -623,0 +718,3 @@\n+=======\n+         * backed by the {@link ResourceScope#globalScope() global} resource scope.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -653,0 +751,1 @@\n+<<<<<<< HEAD\n@@ -658,0 +757,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -669,0 +770,1 @@\n+<<<<<<< HEAD\n@@ -673,0 +775,6 @@\n+=======\n+         * {@link ResourceScope resource scope}.\n+         * <p>\n+         * If this method needs to allocate native memory, such memory will be managed by the given\n+         * {@link ResourceScope resource scope}, and will be released when the resource scope is {@link ResourceScope#close closed}.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":109,"deletions":1,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+<<<<<<< HEAD\n@@ -33,0 +34,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -45,0 +48,1 @@\n+<<<<<<< HEAD\n@@ -49,0 +53,6 @@\n+=======\n+ * A memory address is associated with a {@link ResourceScope resource scope}; the resource scope determines the\n+ * lifecycle of the memory address, and whether the address can be used from multiple threads. Memory addresses\n+ * obtained from {@link #ofLong(long) numeric values}, or from native code, are associated with the\n+ * {@link ResourceScope#globalScope() global resource scope}. Memory addresses obtained from segments\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -100,0 +110,1 @@\n+<<<<<<< HEAD\n@@ -101,0 +112,3 @@\n+=======\n+     * when {@code segment} models an heap memory region, while this address is a {@link #isNative() native} address.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -133,0 +147,1 @@\n+<<<<<<< HEAD\n@@ -139,0 +154,4 @@\n+=======\n+     * @throws UnsupportedOperationException if this address is not a {@link #isNative() native} address.\n+     *\/\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -168,0 +187,1 @@\n+<<<<<<< HEAD\n@@ -174,0 +194,4 @@\n+=======\n+     * @throws UnsupportedOperationException if this address is not a {@link #isNative() native} address.\n+     *\/\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -185,0 +209,1 @@\n+<<<<<<< HEAD\n@@ -186,0 +211,3 @@\n+=======\n+     * @throws UnsupportedOperationException if this memory address is not a {@link #isNative() native} address.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -215,0 +243,1 @@\n+<<<<<<< HEAD\n@@ -216,0 +245,3 @@\n+=======\n+     * with the {@link ResourceScope#globalScope() global} resource scope.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -221,0 +253,1 @@\n+<<<<<<< HEAD\n@@ -222,0 +255,3 @@\n+=======\n+     * with the {@link ResourceScope#globalScope() global} resource scope.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -496,0 +496,1 @@\n+<<<<<<< HEAD\n@@ -497,0 +498,3 @@\n+=======\n+     * Creates a method handle which, given a memory segment, returns a {@link MemorySegment#asSlice(long,long) slice}\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayout.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+<<<<<<< HEAD\n@@ -89,0 +90,3 @@\n+=======\n+ * Contents of mapped memory segments can be {@link #force() persisted} and {@link #load() loaded} to and from the underlying file;\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -101,0 +105,1 @@\n+<<<<<<< HEAD\n@@ -102,0 +107,3 @@\n+=======\n+ * Memory segments are associated to a resource scope (see {@link ResourceScope}), which can be accessed using\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -112,0 +120,1 @@\n+<<<<<<< HEAD\n@@ -115,0 +124,5 @@\n+=======\n+ * Additionally, access to a memory segment in subject to the thread-confinement checks enforced by the owning scope; that is,\n+ * if the segment is associated with a shared scope, it can be accessed by multiple threads; if it is associated with a confined\n+ * scope, it can only be accessed by the thread which own the scope.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -155,0 +169,1 @@\n+<<<<<<< HEAD\n@@ -159,0 +174,9 @@\n+=======\n+ * @apiNote In the future, if the Java language permits, {@link MemorySegment}\n+ * may become a {@code sealed} interface, which would prohibit subclassing except by other explicitly permitted subtypes.\n+ *\n+ * @implSpec\n+ * Implementations of this interface are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ *\/\n+public interface MemorySegment extends Addressable {\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -314,0 +338,1 @@\n+<<<<<<< HEAD\n@@ -315,0 +340,3 @@\n+=======\n+     * or if this is a {@link #isMapped() mapped} segment.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -583,0 +611,1 @@\n+<<<<<<< HEAD\n@@ -584,0 +613,3 @@\n+=======\n+     * {@link ResourceScope#globalScope() global} resource scope, in case the buffer has been created independently,\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -597,0 +629,1 @@\n+<<<<<<< HEAD\n@@ -598,0 +631,3 @@\n+=======\n+     * The returned segment's resource scope is set to the {@link ResourceScope#globalScope() global} resource scope.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -608,0 +644,1 @@\n+<<<<<<< HEAD\n@@ -609,0 +646,3 @@\n+=======\n+     * The returned segment's resource scope is set to the {@link ResourceScope#globalScope() global} resource scope.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -619,0 +659,1 @@\n+<<<<<<< HEAD\n@@ -620,0 +661,3 @@\n+=======\n+     * The returned segment's resource scope is set to the {@link ResourceScope#globalScope() global} resource scope.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -630,0 +674,1 @@\n+<<<<<<< HEAD\n@@ -631,0 +676,3 @@\n+=======\n+     * The returned segment's resource scope is set to the {@link ResourceScope#globalScope() global} resource scope.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -641,0 +689,1 @@\n+<<<<<<< HEAD\n@@ -642,0 +691,3 @@\n+=======\n+     * The returned segment's resource scope is set to the {@link ResourceScope#globalScope() global} resource scope.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -652,0 +704,1 @@\n+<<<<<<< HEAD\n@@ -653,0 +706,3 @@\n+=======\n+     * The returned segment's resource scope is set to the {@link ResourceScope#globalScope() global} resource scope.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -663,0 +719,1 @@\n+<<<<<<< HEAD\n@@ -664,0 +721,3 @@\n+=======\n+     * The returned segment's resource scope is set to the {@link ResourceScope#globalScope() global} resource scope.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -674,0 +734,1 @@\n+<<<<<<< HEAD\n@@ -675,0 +736,3 @@\n+=======\n+     * and resource scope. A client is responsible make sure that the resource scope associated to the returned segment is closed\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -699,0 +763,1 @@\n+<<<<<<< HEAD\n@@ -700,0 +765,3 @@\n+=======\n+     * and resource scope. A client is responsible make sure that the resource scope associated to the returned segment is closed\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -713,0 +781,1 @@\n+<<<<<<< HEAD\n@@ -715,0 +784,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -723,0 +794,1 @@\n+<<<<<<< HEAD\n@@ -724,0 +796,3 @@\n+=======\n+     * scope associated to the returned segment is closed when the segment is no longer in use.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -734,0 +809,1 @@\n+<<<<<<< HEAD\n@@ -736,0 +812,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -812,0 +890,1 @@\n+<<<<<<< HEAD\n@@ -815,0 +894,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+<<<<<<< HEAD\n@@ -77,0 +78,3 @@\n+=======\n+ * An important implicit resource scope is the so called {@link #globalScope() global scope}; the global scope is\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -143,0 +147,1 @@\n+<<<<<<< HEAD\n@@ -147,0 +152,9 @@\n+=======\n+ * @apiNote In the future, if the Java language permits, {@link ResourceScope}\n+ * may become a {@code sealed} interface, which would prohibit subclassing except by other explicitly permitted subtypes.\n+ *\n+ * @implSpec\n+ * Implementations of this interface are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ *\/\n+public interface ResourceScope extends AutoCloseable {\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -183,0 +197,1 @@\n+<<<<<<< HEAD\n@@ -186,0 +201,5 @@\n+=======\n+     *     <li>one or more handles (see {@link #acquire()}) associated with this resource scope have not been closed<\/li>\n+     * <\/ul>\n+     * @throws UnsupportedOperationException if this resource scope is {@link #isImplicit() implicit}.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -198,0 +218,1 @@\n+<<<<<<< HEAD\n@@ -200,0 +221,5 @@\n+=======\n+     * If this resource scope is explicit, this method acquires a new resource scope handle, associated with this\n+     * resource scope; an explicit resource scope cannot be {@link #close() closed}\n+     * until all the resource scope handles acquired from it have been {@link #release(Handle)} released}.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -213,0 +239,1 @@\n+<<<<<<< HEAD\n@@ -219,0 +246,8 @@\n+=======\n+     * An abstraction modelling a resource scope handle. A resource scope handle is typically {@link #acquire() acquired} by clients\n+     * in order to prevent an explicit resource scope from being closed while executing a certain operation.\n+     * Once obtained, resource scope handles can be {@link #release(Handle)} released}; an explicit resource scope can\n+     * be closed only <em>after<\/em> all the resource scope handles acquired from it have been released.\n+     *\/\n+    interface Handle {\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ResourceScope.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+<<<<<<< HEAD\n@@ -69,0 +70,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -84,0 +87,1 @@\n+<<<<<<< HEAD\n@@ -85,0 +89,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -100,0 +106,1 @@\n+<<<<<<< HEAD\n@@ -101,0 +108,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -116,0 +125,1 @@\n+<<<<<<< HEAD\n@@ -117,0 +127,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -132,0 +144,1 @@\n+<<<<<<< HEAD\n@@ -133,0 +146,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -148,0 +163,1 @@\n+<<<<<<< HEAD\n@@ -149,0 +165,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -164,0 +182,1 @@\n+<<<<<<< HEAD\n@@ -165,0 +184,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -182,0 +203,1 @@\n+<<<<<<< HEAD\n@@ -183,0 +205,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -203,0 +227,1 @@\n+<<<<<<< HEAD\n@@ -204,0 +229,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -215,0 +242,1 @@\n+<<<<<<< HEAD\n@@ -216,0 +244,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -227,0 +257,1 @@\n+<<<<<<< HEAD\n@@ -228,0 +259,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -239,0 +272,1 @@\n+<<<<<<< HEAD\n@@ -240,0 +274,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -251,0 +287,1 @@\n+<<<<<<< HEAD\n@@ -252,0 +289,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -263,0 +302,1 @@\n+<<<<<<< HEAD\n@@ -264,0 +304,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -275,0 +317,1 @@\n+<<<<<<< HEAD\n@@ -276,0 +319,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -288,0 +333,1 @@\n+<<<<<<< HEAD\n@@ -289,0 +335,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -328,0 +376,1 @@\n+<<<<<<< HEAD\n@@ -329,0 +378,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -339,0 +390,1 @@\n+<<<<<<< HEAD\n@@ -340,0 +392,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -351,0 +405,1 @@\n+<<<<<<< HEAD\n@@ -352,0 +407,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -384,0 +441,1 @@\n+<<<<<<< HEAD\n@@ -387,0 +445,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -422,0 +482,1 @@\n+<<<<<<< HEAD\n@@ -424,0 +485,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -459,0 +522,1 @@\n+<<<<<<< HEAD\n@@ -460,0 +524,3 @@\n+=======\n+     * @param scope the resource scope associated to the segments created by the returned allocator.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+<<<<<<< HEAD\n@@ -73,0 +74,3 @@\n+=======\n+try (ResourceScope scope = ResourceScope.ofConfined()) {\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -99,2 +103,2 @@\n- * The key abstractions introduced to support foreign function access are {@link jdk.incubator.foreign.LibraryLookup} and {@link jdk.incubator.foreign.CLinker}.\n- * The former is used to load foreign libraries, as well as to lookup symbols inside said libraries; the latter\n+ * The key abstractions introduced to support foreign function access are {@link jdk.incubator.foreign.SymbolLookup} and {@link jdk.incubator.foreign.CLinker}.\n+ * The former is used to lookup symbols inside native libraries; the latter\n@@ -110,0 +114,1 @@\n+<<<<<<< HEAD\n@@ -111,0 +116,3 @@\n+=======\n+        CLinker.systemLookup().lookup(\"strlen\").get(),\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -121,1 +129,1 @@\n- * Here, we lookup the {@code strlen} symbol in the <em>default<\/em> library lookup (see {@link jdk.incubator.foreign.LibraryLookup#ofDefault()}).\n+ * Here, we lookup the {@code strlen} symbol in the {@linkplain jdk.incubator.foreign.CLinker#systemLookup() system lookup}.\n@@ -218,0 +226,1 @@\n+<<<<<<< HEAD\n@@ -219,0 +228,3 @@\n+=======\n+ * is tied to the {@link jdk.incubator.foreign.ResourceScope resource scope} parameter passed to that method.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -223,0 +235,1 @@\n+<<<<<<< HEAD\n@@ -224,0 +237,3 @@\n+=======\n+ * foreign data and\/or functions to first-class Java API elements which can then be used directly by client. For instance\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -233,0 +249,1 @@\n+<<<<<<< HEAD\n@@ -234,0 +251,3 @@\n+=======\n+ * Access to restricted methods is <em>disabled<\/em> by default; to enable restricted methods, the JVM command line option\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -33,0 +33,6 @@\n+<<<<<<< HEAD\n+=======\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -39,0 +45,1 @@\n+<<<<<<< HEAD\n@@ -48,0 +55,15 @@\n+=======\n+public abstract class AbstractCLinker implements CLinker {\n+\n+    @CallerSensitive\n+    public final MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        SharedUtils.checkSymbol(symbol);\n+        return MethodHandles.insertArguments(downcallHandle(type, function), 0, symbol);\n+    }\n+\n+    @CallerSensitive\n+    public final MethodHandle downcallHandle(Addressable symbol, SegmentAllocator allocator, MethodType type, FunctionDescriptor function) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        SharedUtils.checkSymbol(symbol);\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractCLinker.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+<<<<<<< HEAD\n@@ -111,0 +112,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ConfinedScope.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+<<<<<<< HEAD\n@@ -53,0 +54,3 @@\n+=======\n+public abstract class ResourceScopeImpl implements ResourceScope, ScopedMemoryAccess.Scope, SegmentAllocator {\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -86,0 +90,1 @@\n+<<<<<<< HEAD\n@@ -91,0 +96,8 @@\n+=======\n+        ResourceScope.Handle handle = acquire();\n+        try {\n+            \/\/ avoid close vs. add races\n+            resourceList.add(resource);\n+        } finally {\n+            release(handle);\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -154,0 +167,1 @@\n+<<<<<<< HEAD\n@@ -155,0 +169,3 @@\n+=======\n+    interface HandleImpl extends ResourceScope.Handle, ScopedMemoryAccess.Scope.Handle {\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -267,0 +284,1 @@\n+<<<<<<< HEAD\n@@ -268,0 +286,3 @@\n+=======\n+    public static ResourceScopeImpl GLOBAL = new ImplicitScopeImpl( null) {\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -285,0 +306,1 @@\n+<<<<<<< HEAD\n@@ -286,0 +308,18 @@\n+=======\n+        final void cleanup() {\n+            \/\/ We don't need to worry about add vs. close races here; adding a new cleanup action is done\n+            \/\/ under acquire, which prevents scope from being closed. Additionally, close vs. close races are impossible\n+            \/\/ (because MemoryScope::justClose ensures that only one thread can win the race to close the scope).\n+            \/\/ In other words, this is effectively single-threaded code.\n+            if (fst != ResourceCleanup.CLOSED_LIST) {\n+                ResourceCleanup current = fst;\n+                fst = ResourceCleanup.CLOSED_LIST;\n+                while (current != null) {\n+                    current.cleanup();\n+                    current = current.next;\n+                }\n+            } else {\n+                throw new IllegalStateException(\"Attempt to cleanup an already closed resource list\");\n+            }\n+        }\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -291,0 +331,1 @@\n+<<<<<<< HEAD\n@@ -299,0 +340,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -320,0 +363,1 @@\n+<<<<<<< HEAD\n@@ -321,0 +365,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ResourceScopeImpl.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+<<<<<<< HEAD\n@@ -29,0 +30,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -119,0 +122,1 @@\n+<<<<<<< HEAD\n@@ -120,0 +124,3 @@\n+=======\n+     * A shared resource list; this implementation has to handle add vs. add races.\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -135,0 +142,1 @@\n+<<<<<<< HEAD\n@@ -143,0 +151,9 @@\n+=======\n+            \/\/ We don't need to worry about add vs. close races here; adding a new cleanup action is done\n+            \/\/ under acquire, which prevents scope from being closed. The only possible race here is\n+            \/\/ add vs. add.\n+            while (true) {\n+                ResourceCleanup prev = (ResourceCleanup) FST.getAcquire(this);\n+                cleanup.next = prev;\n+                if ((ResourceCleanup) FST.compareAndExchangeRelease(this, prev, cleanup) == prev) {\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -148,0 +165,1 @@\n+<<<<<<< HEAD\n@@ -169,0 +187,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SharedScope.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -106,0 +106,8 @@\n+<<<<<<< HEAD\n+=======\n+    private static void throwIllegalAccessError(String value, String method) {\n+        throw new IllegalAccessError(\"Illegal access to restricted foreign method: \" + method +\n+                \" ; system property 'foreign.restricted' is set to '\" + value + \"'\");\n+    }\n+\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -297,0 +297,1 @@\n+<<<<<<< HEAD\n@@ -298,0 +299,3 @@\n+=======\n+        public static Context DUMMY = new Context(null, null) {\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+<<<<<<< HEAD\n@@ -98,0 +99,3 @@\n+=======\n+            MH_ADDR_TO_LONG = lookup.findStatic(ProgrammableInvoker.class, \"unboxTargetAddress\", methodType(long.class, Addressable.class));\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -179,0 +183,8 @@\n+<<<<<<< HEAD\n+=======\n+    private static long unboxTargetAddress(Addressable addr) {\n+        MemoryAddress ma = SharedUtils.checkSymbol(addr);\n+        return ma.toRawLongValue();\n+    }\n+\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -298,0 +298,6 @@\n+<<<<<<< HEAD\n+=======\n+        } catch(Throwable t) {\n+            SharedUtils.handleUncaughtException(t);\n+            return null;\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -304,0 +310,1 @@\n+<<<<<<< HEAD\n@@ -307,0 +314,5 @@\n+=======\n+    public static native long allocateOptimizedUpcallStub(MethodHandle mh, ABIDescriptor abi, CallRegs conv);\n+    public static native long allocateUpcallStub(MethodHandle mh, ABIDescriptor abi, BufferLayout layout);\n+    public static native boolean supportsOptimizedUpcalls();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+<<<<<<< HEAD\n@@ -36,0 +37,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -41,0 +44,3 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -54,0 +60,1 @@\n+import java.util.Arrays;\n@@ -56,0 +63,4 @@\n+<<<<<<< HEAD\n+=======\n+import java.util.Objects;\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -75,0 +86,3 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+    private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n+\n@@ -82,0 +96,4 @@\n+<<<<<<< HEAD\n+=======\n+    private static final MethodHandle MH_HANDLE_UNCAUGHT_EXCEPTION;\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -100,0 +118,5 @@\n+<<<<<<< HEAD\n+=======\n+            MH_HANDLE_UNCAUGHT_EXCEPTION = lookup.findStatic(SharedUtils.class, \"handleUncaughtException\",\n+                    methodType(void.class, Throwable.class));\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -362,0 +385,10 @@\n+<<<<<<< HEAD\n+=======\n+    static void handleUncaughtException(Throwable t) {\n+        if (t != null) {\n+            t.printStackTrace();\n+            JLA.exit(1);\n+        }\n+    }\n+\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -369,0 +402,1 @@\n+<<<<<<< HEAD\n@@ -370,0 +404,7 @@\n+=======\n+            if (!upcall) {\n+                closer = empty(methodType(void.class, Throwable.class)); \/\/ (Throwable) -> void\n+            } else {\n+                closer = MH_HANDLE_UNCAUGHT_EXCEPTION;\n+            }\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -415,0 +456,1 @@\n+<<<<<<< HEAD\n@@ -425,0 +467,19 @@\n+=======\n+    public static void checkExceptions(MethodHandle target) {\n+        Class<?>[] exceptions = JLIA.exceptionTypes(target);\n+        if (exceptions != null && exceptions.length != 0) {\n+            throw new IllegalArgumentException(\"Target handle may throw exceptions: \" + Arrays.toString(exceptions));\n+        }\n+    }\n+\n+    \/\/ lazy init MH_ALLOC and MH_FREE handles\n+    private static class AllocHolder {\n+\n+        private static final CLinker linker = getSystemLinker();\n+\n+        static final MethodHandle MH_MALLOC = linker.downcallHandle(CLinker.systemLookup().lookup(\"malloc\").get(),\n+                        MethodType.methodType(MemoryAddress.class, long.class),\n+                FunctionDescriptor.of(C_POINTER, C_LONG_LONG));\n+\n+        static final MethodHandle MH_FREE = linker.downcallHandle(CLinker.systemLookup().lookup(\"free\").get(),\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -429,0 +490,8 @@\n+    public static MemoryAddress checkSymbol(Addressable symbol) {\n+        Objects.requireNonNull(symbol);\n+        MemoryAddress symbolAddr = symbol.address();\n+        if (symbolAddr.equals(MemoryAddress.NULL))\n+            throw new IllegalArgumentException(\"Symbol is NULL: \" + symbolAddr);\n+        return symbolAddr;\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n@@ -75,0 +77,1 @@\n+<<<<<<< HEAD\n@@ -76,0 +79,5 @@\n+=======\n+    @CallerSensitive\n+    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -89,0 +97,4 @@\n+<<<<<<< HEAD\n+    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+=======\n+    @CallerSensitive\n@@ -90,0 +102,2 @@\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -93,0 +107,1 @@\n+        SharedUtils.checkExceptions(target);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Linker.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -400,0 +400,1 @@\n+<<<<<<< HEAD\n@@ -401,0 +402,3 @@\n+=======\n+    static class Builder implements VaList.Builder {\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64VaList.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -343,0 +343,1 @@\n+<<<<<<< HEAD\n@@ -344,0 +345,3 @@\n+=======\n+    static class Builder implements VaList.Builder {\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n@@ -86,0 +88,1 @@\n+<<<<<<< HEAD\n@@ -87,0 +90,5 @@\n+=======\n+    @CallerSensitive\n+    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -100,0 +108,4 @@\n+<<<<<<< HEAD\n+    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+=======\n+    @CallerSensitive\n@@ -101,0 +113,2 @@\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -104,0 +118,1 @@\n+        SharedUtils.checkExceptions(target);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -173,0 +173,1 @@\n+<<<<<<< HEAD\n@@ -174,0 +175,3 @@\n+=======\n+    static class Builder implements VaList.Builder {\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n@@ -87,0 +89,1 @@\n+<<<<<<< HEAD\n@@ -88,0 +91,5 @@\n+=======\n+    @CallerSensitive\n+    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -101,0 +109,4 @@\n+<<<<<<< HEAD\n+    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+=======\n+    @CallerSensitive\n@@ -102,0 +114,2 @@\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -105,0 +119,1 @@\n+        SharedUtils.checkExceptions(target);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+<<<<<<< HEAD\n@@ -33,0 +34,3 @@\n+=======\n+import jdk.incubator.foreign.SymbolLookup;\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -45,0 +49,1 @@\n+<<<<<<< HEAD\n@@ -47,0 +52,5 @@\n+=======\n+    static {\n+        System.loadLibrary(\"SafeAccess\");\n+    }\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -52,0 +62,5 @@\n+<<<<<<< HEAD\n+=======\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n+\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.Optional;\n@@ -157,1 +158,1 @@\n-        static final LibraryLookup lookup = LibraryLookup.ofDefault();\n+        final static SymbolLookup LOOKUP;\n@@ -159,1 +160,17 @@\n-        final static MethodHandle strcat = abi.downcallHandle(lookup.lookup(\"strcat\").get(),\n+        static {\n+            System.loadLibrary(\"StdLib\");\n+            SymbolLookup stdLibLookup = SymbolLookup.loaderLookup();\n+            MemorySegment funcs = stdLibLookup.lookup(\"funcs\").get()\n+                    .asSegment(C_POINTER.byteSize() * 3, ResourceScope.newImplicitScope());\n+\n+            SymbolLookup fallbackLookup = name -> switch (name) {\n+                    case \"printf\" -> Optional.of(MemoryAccess.getAddressAtIndex(funcs, 0));\n+                    case \"vprintf\" -> Optional.of(MemoryAccess.getAddressAtIndex(funcs, 1));\n+                    case \"gmtime\" -> Optional.of(MemoryAccess.getAddressAtIndex(funcs, 2));\n+                    default -> Optional.empty();\n+                };\n+\n+            LOOKUP = name -> CLinker.systemLookup().lookup(name).or(() -> fallbackLookup.lookup(name));\n+        }\n+\n+        final static MethodHandle strcat = abi.downcallHandle(LOOKUP.lookup(\"strcat\").get(),\n@@ -163,1 +180,1 @@\n-        final static MethodHandle strcmp = abi.downcallHandle(lookup.lookup(\"strcmp\").get(),\n+        final static MethodHandle strcmp = abi.downcallHandle(LOOKUP.lookup(\"strcmp\").get(),\n@@ -167,1 +184,1 @@\n-        final static MethodHandle puts = abi.downcallHandle(lookup.lookup(\"puts\").get(),\n+        final static MethodHandle puts = abi.downcallHandle(LOOKUP.lookup(\"puts\").get(),\n@@ -171,1 +188,1 @@\n-        final static MethodHandle strlen = abi.downcallHandle(lookup.lookup(\"strlen\").get(),\n+        final static MethodHandle strlen = abi.downcallHandle(LOOKUP.lookup(\"strlen\").get(),\n@@ -175,1 +192,1 @@\n-        final static MethodHandle gmtime = abi.downcallHandle(lookup.lookup(\"gmtime\").get(),\n+        final static MethodHandle gmtime = abi.downcallHandle(LOOKUP.lookup(\"gmtime\").get(),\n@@ -179,1 +196,1 @@\n-        final static MethodHandle qsort = abi.downcallHandle(lookup.lookup(\"qsort\").get(),\n+        final static MethodHandle qsort = abi.downcallHandle(LOOKUP.lookup(\"qsort\").get(),\n@@ -187,1 +204,1 @@\n-        final static MethodHandle rand = abi.downcallHandle(lookup.lookup(\"rand\").get(),\n+        final static MethodHandle rand = abi.downcallHandle(LOOKUP.lookup(\"rand\").get(),\n@@ -191,1 +208,1 @@\n-        final static MethodHandle vprintf = abi.downcallHandle(lookup.lookup(\"vprintf\").get(),\n+        final static MethodHandle vprintf = abi.downcallHandle(LOOKUP.lookup(\"vprintf\").get(),\n@@ -195,0 +212,1 @@\n+<<<<<<< HEAD\n@@ -196,0 +214,3 @@\n+=======\n+        final static MemoryAddress printfAddr = LOOKUP.lookup(\"printf\").get();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":30,"deletions":9,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+<<<<<<< HEAD\n@@ -39,0 +40,3 @@\n+=======\n+import jdk.incubator.foreign.SymbolLookup;\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -55,1 +59,0 @@\n-    static LibraryLookup lib = LibraryLookup.ofLibrary(\"TestDowncall\");\n@@ -57,0 +60,3 @@\n+    static {\n+        System.loadLibrary(\"TestDowncall\");\n+    }\n@@ -58,0 +64,1 @@\n+<<<<<<< HEAD\n@@ -89,0 +96,35 @@\n+=======\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n+\n+    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n+    public void testDowncall(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+        List<Consumer<Object>> checks = new ArrayList<>();\n+        MemoryAddress addr = lookup.lookup(fName).get();\n+        MethodType mt = methodType(ret, paramTypes, fields);\n+        FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n+        Object[] args = makeArgs(paramTypes, fields, checks);\n+        try (NativeScope scope = new NativeScope()) {\n+            boolean needsScope = mt.returnType().equals(MemorySegment.class);\n+            Object res = doCall(addr, scope, mt, descriptor, args);\n+            if (ret == Ret.NON_VOID) {\n+                checks.forEach(c -> c.accept(res));\n+                if (needsScope) {\n+                    \/\/ check that return struct has indeed been allocated in the native scope\n+                    assertEquals(((MemorySegment) res).scope(), scope.scope());\n+                    assertEquals(scope.allocatedBytes(), descriptor.returnLayout().get().byteSize());\n+                } else {\n+                    \/\/ if here, there should be no allocation through the scope!\n+                    assertEquals(scope.allocatedBytes(), 0L);\n+                }\n+            } else {\n+                \/\/ if here, there should be no allocation through the scope!\n+                assertEquals(scope.allocatedBytes(), 0L);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n+    public void testDowncallNoScope(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+        List<Consumer<Object>> checks = new ArrayList<>();\n+        MemoryAddress addr = lookup.lookup(fName).get();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":43,"deletions":1,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.incubator.foreign.LibraryLookup;\n@@ -44,0 +43,4 @@\n+<<<<<<< HEAD\n+=======\n+import jdk.incubator.foreign.SymbolLookup;\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -56,0 +59,1 @@\n+<<<<<<< HEAD\n@@ -58,0 +62,12 @@\n+    private interface RunnableX {\n+        void run() throws Throwable;\n+=======\n+    static {\n+        System.loadLibrary(\"Intrinsics\");\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n+    }\n+\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n+\n+<<<<<<< HEAD\n+=======\n@@ -69,0 +85,1 @@\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -87,0 +104,1 @@\n+<<<<<<< HEAD\n@@ -88,0 +106,3 @@\n+=======\n+            MemoryAddress ma = lookup.lookup(name).get();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -97,0 +118,1 @@\n+<<<<<<< HEAD\n@@ -98,0 +120,3 @@\n+=======\n+            MemoryAddress ma = lookup.lookup(\"empty\").get();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -112,0 +137,1 @@\n+<<<<<<< HEAD\n@@ -113,0 +139,3 @@\n+=======\n+            MemoryAddress ma = lookup.lookup(\"identity_va\").get();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -127,0 +156,1 @@\n+<<<<<<< HEAD\n@@ -128,0 +158,3 @@\n+=======\n+                MemoryAddress ma = lookup.lookup(\"invoke_high_arity\" + i).get();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -8,0 +8,1 @@\n+<<<<<<< HEAD\n@@ -9,0 +10,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -15,0 +19,1 @@\n+<<<<<<< HEAD\n@@ -16,0 +21,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -22,0 +30,1 @@\n+<<<<<<< HEAD\n@@ -23,0 +32,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -29,0 +41,1 @@\n+<<<<<<< HEAD\n@@ -30,0 +43,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -37,0 +53,1 @@\n+<<<<<<< HEAD\n@@ -38,0 +55,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -44,0 +64,1 @@\n+<<<<<<< HEAD\n@@ -45,0 +66,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -51,0 +75,1 @@\n+<<<<<<< HEAD\n@@ -52,0 +77,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -58,0 +86,1 @@\n+<<<<<<< HEAD\n@@ -59,0 +88,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -66,0 +98,1 @@\n+<<<<<<< HEAD\n@@ -67,0 +100,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -73,0 +109,1 @@\n+<<<<<<< HEAD\n@@ -74,0 +111,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -80,0 +120,1 @@\n+<<<<<<< HEAD\n@@ -81,0 +122,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -87,0 +131,1 @@\n+<<<<<<< HEAD\n@@ -88,0 +133,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -95,0 +143,1 @@\n+<<<<<<< HEAD\n@@ -96,0 +145,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -102,0 +154,1 @@\n+<<<<<<< HEAD\n@@ -103,0 +156,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -109,0 +165,1 @@\n+<<<<<<< HEAD\n@@ -110,0 +167,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -116,0 +176,1 @@\n+<<<<<<< HEAD\n@@ -117,0 +178,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -124,0 +188,1 @@\n+<<<<<<< HEAD\n@@ -125,0 +190,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -129,0 +197,1 @@\n+<<<<<<< HEAD\n@@ -130,0 +199,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -134,0 +206,1 @@\n+<<<<<<< HEAD\n@@ -135,0 +208,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -139,0 +215,1 @@\n+<<<<<<< HEAD\n@@ -140,0 +217,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -145,0 +225,1 @@\n+<<<<<<< HEAD\n@@ -146,0 +227,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -152,0 +236,1 @@\n+<<<<<<< HEAD\n@@ -153,0 +238,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -159,0 +247,1 @@\n+<<<<<<< HEAD\n@@ -160,0 +249,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -166,0 +258,1 @@\n+<<<<<<< HEAD\n@@ -167,0 +260,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -174,0 +270,1 @@\n+<<<<<<< HEAD\n@@ -175,0 +272,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -181,0 +281,1 @@\n+<<<<<<< HEAD\n@@ -182,0 +283,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -188,0 +292,1 @@\n+<<<<<<< HEAD\n@@ -189,0 +294,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -195,0 +303,1 @@\n+<<<<<<< HEAD\n@@ -196,0 +305,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -203,0 +315,1 @@\n+<<<<<<< HEAD\n@@ -204,0 +317,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -210,0 +326,1 @@\n+<<<<<<< HEAD\n@@ -211,0 +328,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -217,0 +337,1 @@\n+<<<<<<< HEAD\n@@ -218,0 +339,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -224,0 +348,1 @@\n+<<<<<<< HEAD\n@@ -225,0 +350,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -232,0 +360,1 @@\n+<<<<<<< HEAD\n@@ -233,0 +362,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -239,0 +371,1 @@\n+<<<<<<< HEAD\n@@ -240,0 +373,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -246,0 +382,1 @@\n+<<<<<<< HEAD\n@@ -247,0 +384,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -253,0 +393,1 @@\n+<<<<<<< HEAD\n@@ -254,0 +395,3 @@\n+=======\n+ *   -Dforeign.restricted=permit\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"test\/jdk\/java\/foreign\/TestMatrix.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+            SymbolLookup.class,\n@@ -94,0 +95,1 @@\n+<<<<<<< HEAD\n@@ -95,0 +97,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -148,2 +152,2 @@\n-        addDefaultMapping(MemoryAddress.class, MemoryAddress.NULL);\n-        addDefaultMapping(Addressable.class, MemoryAddress.NULL);\n+        addDefaultMapping(MemoryAddress.class, MemoryAddress.ofLong(1));\n+        addDefaultMapping(Addressable.class, MemoryAddress.ofLong(1));\n@@ -159,0 +163,1 @@\n+<<<<<<< HEAD\n@@ -160,0 +165,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -164,0 +171,5 @@\n+<<<<<<< HEAD\n+=======\n+        addDefaultMapping(ClassLoader.class, TestNulls.class.getClassLoader());\n+        addDefaultMapping(SymbolLookup.class, CLinker.systemLookup());\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+<<<<<<< HEAD\n@@ -29,0 +30,3 @@\n+=======\n+ * @run testng\/othervm -Dforeign.restricted=permit TestResourceScope\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -130,0 +134,1 @@\n+<<<<<<< HEAD\n@@ -131,0 +136,10 @@\n+=======\n+            while (true) {\n+                try {\n+                    scope.close();\n+                    break;\n+                } catch (IllegalStateException ise) {\n+                    \/\/ scope is acquired (by add) - wait some more\n+                }\n+            }\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"test\/jdk\/java\/foreign\/TestResourceScope.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+<<<<<<< HEAD\n@@ -27,0 +28,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -57,0 +60,1 @@\n+<<<<<<< HEAD\n@@ -69,0 +73,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -105,0 +111,1 @@\n+<<<<<<< HEAD\n@@ -168,0 +175,52 @@\n+=======\n+            \/\/ scope operations\n+            ScopedOperation.ofScope(scope -> scope.addCloseAction(() -> {}), \"ResourceScope::addOnClose\");\n+            ScopedOperation.ofScope(scope -> {\n+                ResourceScope.Handle handle = scope.acquire();\n+                scope.release(handle);\n+            }, \"ResourceScope::lock\");\n+            \/\/ segment operations\n+            ScopedOperation.ofSegment(MemorySegment::toByteArray, \"MemorySegment::toByteArray\");\n+            ScopedOperation.ofSegment(MemorySegment::toCharArray, \"MemorySegment::toCharArray\");\n+            ScopedOperation.ofSegment(MemorySegment::toShortArray, \"MemorySegment::toShortArray\");\n+            ScopedOperation.ofSegment(MemorySegment::toIntArray, \"MemorySegment::toIntArray\");\n+            ScopedOperation.ofSegment(MemorySegment::toFloatArray, \"MemorySegment::toFloatArray\");\n+            ScopedOperation.ofSegment(MemorySegment::toLongArray, \"MemorySegment::toLongArray\");\n+            ScopedOperation.ofSegment(MemorySegment::toDoubleArray, \"MemorySegment::toDoubleArray\");\n+            ScopedOperation.ofSegment(MemorySegment::address, \"MemorySegment::address\");\n+            ScopedOperation.ofSegment(s -> MemoryLayout.sequenceLayout(s.byteSize(), MemoryLayouts.JAVA_BYTE), \"MemorySegment::spliterator\");\n+            ScopedOperation.ofSegment(s -> s.copyFrom(s), \"MemorySegment::copyFrom\");\n+            ScopedOperation.ofSegment(s -> s.mismatch(s), \"MemorySegment::mismatch\");\n+            ScopedOperation.ofSegment(s -> s.fill((byte) 0), \"MemorySegment::fill\");\n+            \/\/ address operations\n+            ScopedOperation.ofAddress(a -> a.toRawLongValue(), \"MemoryAddress::toRawLongValue\");\n+            ScopedOperation.ofAddress(a -> a.asSegment(100, ResourceScope.globalScope()), \"MemoryAddress::asSegment\");\n+            \/\/ valist operations\n+            ScopedOperation.ofVaList(CLinker.VaList::address, \"VaList::address\");\n+            ScopedOperation.ofVaList(CLinker.VaList::copy, \"VaList::copy\");\n+            ScopedOperation.ofVaList(list -> list.vargAsAddress(MemoryLayouts.ADDRESS), \"VaList::vargAsAddress\");\n+            ScopedOperation.ofVaList(list -> list.vargAsInt(MemoryLayouts.JAVA_INT), \"VaList::vargAsInt\");\n+            ScopedOperation.ofVaList(list -> list.vargAsLong(MemoryLayouts.JAVA_LONG), \"VaList::vargAsLong\");\n+            ScopedOperation.ofVaList(list -> list.vargAsDouble(MemoryLayouts.JAVA_DOUBLE), \"VaList::vargAsDouble\");\n+            ScopedOperation.ofVaList(CLinker.VaList::skip, \"VaList::skip\");\n+            ScopedOperation.ofVaList(list -> list.vargAsSegment(MemoryLayout.structLayout(MemoryLayouts.JAVA_INT), ResourceScope.newImplicitScope()), \"VaList::vargAsSegment\/1\");\n+            \/\/ allocator operations\n+            ScopedOperation.ofAllocator(a -> a.allocate(1), \"NativeAllocator::allocate\/size\");\n+            ScopedOperation.ofAllocator(a -> a.allocate(1, 1), \"NativeAllocator::allocate\/size\/align\");\n+            ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_BYTE), \"NativeAllocator::allocate\/layout\");\n+            ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_BYTE, (byte)0), \"NativeAllocator::allocate\/byte\");\n+            ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_CHAR, (char)0), \"NativeAllocator::allocate\/char\");\n+            ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_SHORT, (short)0), \"NativeAllocator::allocate\/short\");\n+            ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_INT, 0), \"NativeAllocator::allocate\/int\");\n+            ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_FLOAT, 0f), \"NativeAllocator::allocate\/float\");\n+            ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_LONG, 0L), \"NativeAllocator::allocate\/long\");\n+            ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_DOUBLE, 0d), \"NativeAllocator::allocate\/double\");\n+            ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_BYTE, 1L), \"NativeAllocator::allocateArray\/size\");\n+            ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_BYTE, new byte[] { 0 }), \"NativeAllocator::allocateArray\/byte\");\n+            ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_CHAR, new char[] { 0 }), \"NativeAllocator::allocateArray\/char\");\n+            ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_SHORT, new short[] { 0 }), \"NativeAllocator::allocateArray\/short\");\n+            ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_INT, new int[] { 0 }), \"NativeAllocator::allocateArray\/int\");\n+            ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_FLOAT, new float[] { 0 }), \"NativeAllocator::allocateArray\/float\");\n+            ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_LONG, new long[] { 0 }), \"NativeAllocator::allocateArray\/long\");\n+            ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_DOUBLE, new double[] { 0 }), \"NativeAllocator::allocateArray\/double\");\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+<<<<<<< HEAD\n@@ -32,0 +33,3 @@\n+=======\n+ * @run testng\/othervm\/timeout=720\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -38,1 +42,1 @@\n-import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -44,0 +48,1 @@\n+<<<<<<< HEAD\n@@ -45,0 +50,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -64,1 +71,3 @@\n-    static LibraryLookup lib = LibraryLookup.ofLibrary(\"TestUpcall\");\n+    static {\n+        System.loadLibrary(\"TestUpcall\");\n+    }\n@@ -67,0 +76,2 @@\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n+\n@@ -91,0 +102,1 @@\n+<<<<<<< HEAD\n@@ -92,0 +104,3 @@\n+=======\n+        MemoryAddress addr = lookup.lookup(fName).get();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -109,0 +124,1 @@\n+<<<<<<< HEAD\n@@ -110,0 +126,3 @@\n+=======\n+        MemoryAddress addr = lookup.lookup(fName).get();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+<<<<<<< HEAD\n@@ -28,0 +29,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -42,0 +45,1 @@\n+<<<<<<< HEAD\n@@ -43,0 +47,3 @@\n+=======\n+import jdk.incubator.foreign.SymbolLookup;\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -73,0 +80,1 @@\n+<<<<<<< HEAD\n@@ -76,0 +84,6 @@\n+=======\n+        System.loadLibrary(\"TestUpcallStructScope\");\n+        SymbolLookup lookup = SymbolLookup.loaderLookup();\n+        MH_do_upcall = LINKER.downcallHandle(\n+            lookup.lookup(\"do_upcall\").get(),\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.incubator.foreign.LibraryLookup;\n@@ -38,0 +37,4 @@\n+<<<<<<< HEAD\n+=======\n+import jdk.incubator.foreign.SymbolLookup;\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -64,0 +67,1 @@\n+<<<<<<< HEAD\n@@ -66,0 +70,9 @@\n+=======\n+    static {\n+        System.loadLibrary(\"VarArgs\");\n+    }\n+\n+    static final MemoryAddress varargsAddr =\n+            SymbolLookup.loaderLookup()\n+                    .lookup(\"varargs\").get();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+<<<<<<< HEAD\n@@ -33,0 +34,5 @@\n+=======\n+ * @run testng\/othervm -Dforeign.restricted=permit TestAsyncSocketChannels\n+ * @run testng\/othervm -Dforeign.restricted=permit -Dsun.nio.ch.disableSynchronousRead=true TestAsyncSocketChannels\n+ * @run testng\/othervm -Dforeign.restricted=permit -Dsun.nio.ch.disableSynchronousRead=false TestAsyncSocketChannels\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+<<<<<<< HEAD\n@@ -31,0 +32,3 @@\n+=======\n+ * @run testng\/othervm -Dforeign.restricted=permit TestSocketChannels\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"test\/jdk\/java\/foreign\/channels\/TestSocketChannels.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+<<<<<<< HEAD\n@@ -28,0 +29,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -35,0 +38,1 @@\n+<<<<<<< HEAD\n@@ -36,0 +40,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -43,0 +49,1 @@\n+<<<<<<< HEAD\n@@ -44,0 +51,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -51,0 +60,1 @@\n+<<<<<<< HEAD\n@@ -52,0 +62,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -59,0 +71,1 @@\n+<<<<<<< HEAD\n@@ -60,0 +73,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -67,0 +82,1 @@\n+<<<<<<< HEAD\n@@ -68,0 +84,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -75,0 +93,1 @@\n+<<<<<<< HEAD\n@@ -76,0 +95,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -83,0 +104,1 @@\n+<<<<<<< HEAD\n@@ -84,0 +106,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -91,0 +115,1 @@\n+<<<<<<< HEAD\n@@ -92,0 +117,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -99,0 +126,1 @@\n+<<<<<<< HEAD\n@@ -100,0 +128,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -107,0 +137,1 @@\n+<<<<<<< HEAD\n@@ -108,0 +139,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -115,0 +148,1 @@\n+<<<<<<< HEAD\n@@ -116,0 +150,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestDriver.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+<<<<<<< HEAD\n@@ -36,0 +37,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -40,0 +43,4 @@\n+<<<<<<< HEAD\n+=======\n+import jdk.incubator.foreign.SymbolLookup;\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -49,0 +56,1 @@\n+<<<<<<< HEAD\n@@ -50,0 +58,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -61,0 +71,1 @@\n+<<<<<<< HEAD\n@@ -64,0 +75,7 @@\n+=======\n+        System.loadLibrary(\"Virtual\");\n+        SymbolLookup lookup = SymbolLookup.loaderLookup();\n+        funcA = lookup.lookup(\"funcA\").get();\n+        funcB = lookup.lookup(\"funcB\").get();\n+        funcC = lookup.lookup(\"funcC\").get();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -73,0 +91,8 @@\n+<<<<<<< HEAD\n+=======\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testNullTarget() throws Throwable {\n+        int x = (int) func.invokeExact((Addressable) null);\n+    }\n+\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+<<<<<<< HEAD\n@@ -29,0 +30,3 @@\n+=======\n+import jdk.incubator.foreign.SymbolLookup;\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -94,0 +98,1 @@\n+<<<<<<< HEAD\n@@ -97,0 +102,6 @@\n+=======\n+        System.loadLibrary(\"CallOverhead\");\n+        SymbolLookup lookup = SymbolLookup.loaderLookup();\n+        {\n+            func_addr = lookup.lookup(\"func\").orElseThrow();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -105,0 +116,1 @@\n+<<<<<<< HEAD\n@@ -106,0 +118,3 @@\n+=======\n+            identity_addr = lookup.lookup(\"identity\").orElseThrow();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -113,0 +128,1 @@\n+<<<<<<< HEAD\n@@ -114,0 +130,3 @@\n+=======\n+        identity_struct_addr = lookup.lookup(\"identity_struct\").orElseThrow();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -119,0 +138,1 @@\n+<<<<<<< HEAD\n@@ -120,0 +140,3 @@\n+=======\n+        identity_memory_address_addr = lookup.lookup(\"identity_memory_address\").orElseThrow();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -125,0 +148,1 @@\n+<<<<<<< HEAD\n@@ -126,0 +150,3 @@\n+=======\n+        args1_addr = lookup.lookup(\"args1\").orElseThrow();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -131,0 +158,1 @@\n+<<<<<<< HEAD\n@@ -132,0 +160,3 @@\n+=======\n+        args2_addr = lookup.lookup(\"args2\").orElseThrow();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -137,0 +168,1 @@\n+<<<<<<< HEAD\n@@ -138,0 +170,3 @@\n+=======\n+        args3_addr = lookup.lookup(\"args3\").orElseThrow();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -143,0 +178,1 @@\n+<<<<<<< HEAD\n@@ -144,0 +180,3 @@\n+=======\n+        args4_addr = lookup.lookup(\"args4\").orElseThrow();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -149,0 +188,1 @@\n+<<<<<<< HEAD\n@@ -150,0 +190,3 @@\n+=======\n+        args5_addr = lookup.lookup(\"args5\").orElseThrow();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -155,0 +198,1 @@\n+<<<<<<< HEAD\n@@ -156,0 +200,3 @@\n+=======\n+        args10_addr = lookup.lookup(\"args10\").orElseThrow();\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadHelper.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+<<<<<<< HEAD\n@@ -31,0 +32,2 @@\n+=======\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -81,0 +84,1 @@\n+<<<<<<< HEAD\n@@ -94,0 +98,14 @@\n+=======\n+        CLinker abi = CLinker.getInstance();\n+        STRLEN = abi.downcallHandle(CLinker.systemLookup().lookup(\"strlen\").get(),\n+                MethodType.methodType(int.class, MemoryAddress.class),\n+                FunctionDescriptor.of(C_INT, C_POINTER));\n+        STRLEN_TRIVIAL = abi.downcallHandle(CLinker.systemLookup().lookup(\"strlen\").get(),\n+                MethodType.methodType(int.class, MemoryAddress.class),\n+                FunctionDescriptor.of(C_INT, C_POINTER).withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n+        MALLOC_TRIVIAL = abi.downcallHandle(CLinker.systemLookup().lookup(\"malloc\").get(),\n+                MethodType.methodType(MemoryAddress.class, long.class),\n+                FunctionDescriptor.of(C_POINTER, C_LONG_LONG).withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n+\n+        FREE_TRIVIAL = abi.downcallHandle(CLinker.systemLookup().lookup(\"free\").get(),\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.LibraryLookup;\n@@ -30,0 +29,4 @@\n+<<<<<<< HEAD\n+=======\n+import jdk.incubator.foreign.SymbolLookup;\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -83,1 +86,1 @@\n-            LibraryLookup ll = LibraryLookup.ofLibrary(\"Upcalls\");\n+            System.loadLibrary(\"Upcalls\");\n@@ -89,0 +92,1 @@\n+<<<<<<< HEAD\n@@ -90,0 +94,3 @@\n+=======\n+                blank = linkFunc(name, mt, fd);\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -97,0 +104,1 @@\n+<<<<<<< HEAD\n@@ -98,0 +106,3 @@\n+=======\n+                identity = linkFunc(name, mt, fd);\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -107,0 +118,1 @@\n+<<<<<<< HEAD\n@@ -108,0 +120,3 @@\n+=======\n+                args5 = linkFunc(name, mt, fd);\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -119,0 +134,1 @@\n+<<<<<<< HEAD\n@@ -120,0 +136,3 @@\n+=======\n+                args10 = linkFunc(name, mt, fd);\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -127,0 +146,1 @@\n+<<<<<<< HEAD\n@@ -130,0 +150,5 @@\n+=======\n+    static MethodHandle linkFunc(String name, MethodType baseType, FunctionDescriptor baseDesc) {\n+        return abi.downcallHandle(\n+            SymbolLookup.loaderLookup().lookup(name).orElseThrow(),\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/Upcalls.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.LibraryLookup;\n@@ -28,0 +27,4 @@\n+<<<<<<< HEAD\n+=======\n+import jdk.incubator.foreign.SymbolLookup;\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n@@ -57,1 +60,3 @@\n-    static final LibraryLookup lookup = LibraryLookup.ofLibrary(\"VaList\");\n+    static {\n+        System.loadLibrary(\"VaList\");\n+    }\n@@ -63,0 +68,1 @@\n+        SymbolLookup lookup = SymbolLookup.loaderLookup();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/VaList.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,0 +30,9 @@\n+<<<<<<< HEAD\n+=======\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+>>>>>>> d1b8b67021f037b362780354b4caa0b77e9c6e29\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libStrLen.c","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}