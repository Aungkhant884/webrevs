{"files":[{"patch":"@@ -203,4 +203,2 @@\n-     * <p>The returned segment is associated with the provided scope. When such scope is closed,\n-     * the corresponding native stub will be deallocated. The returned memory address maintain a strong reference\n-     * to the resource scope parameter; this helps keeping the native stub alive if, for instance,\n-     * an {@link ResourceScope#isImplicit() implicit} resource scope is used.\n+     * <p>The returned memory address is associated with the provided scope. When such scope is closed,\n+     * the corresponding native stub will be deallocated.\n@@ -617,0 +615,1 @@\n+         * The returned memory address is associated with same resource scope as that associated with this instance.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -43,0 +43,6 @@\n+ * A memory address is associated with a {@link ResourceScope resource scope}; the resource scope determines the\n+ * lifecycle of the memory address, and whether the address can be used from multiple threads. Memory addresses\n+ * obtained from {@link #ofLong(long) numeric values}, or from native code, are associated with the\n+ * {@link ResourceScope#globalScope() global resource scope}. Memory addresses obtained from segments\n+ * are associated with the same scope as the segment from which they have been obtained.\n+ * <p>\n@@ -74,0 +80,6 @@\n+    \/**\n+     * Returns the resource scope associated with this memory address.\n+     * @return the resource scope associated with this memory address.\n+     *\/\n+    ResourceScope scope();\n+\n@@ -95,2 +107,3 @@\n-     * Returns a native memory segment with given size and resource scope, and whose base address is this address. This method\n-     * can be useful when interacting with custom native memory sources (e.g. custom allocators), where an address to some\n+     Returns a new native memory segment with given size and resource scope (replacing the scope already associated\n+     * with this address), and whose base address is this address. This method can be useful when interacting with custom\n+     * native memory sources (e.g. custom allocators), where an address to some\n@@ -119,0 +132,3 @@\n+     * @throws IllegalStateException if either the scope associated with this address or the provided scope\n+     * have been already closed, or if access occurs from a thread other than the thread owning either\n+     * scopes.\n@@ -124,2 +140,3 @@\n-     * Returns a new native memory segment with given size and resource scope, and whose base address is this address. This method\n-     * can be useful when interacting with custom native memory sources (e.g. custom allocators), where an address to some\n+     * Returns a new native memory segment with given size and resource scope (replacing the scope already associated\n+     * with this address), and whose base address is this address. This method can be useful when interacting with custom\n+     * native memory sources (e.g. custom allocators), where an address to some\n@@ -146,0 +163,3 @@\n+     * @throws IllegalStateException if either the scope associated with this address or the provided scope\n+     * have been already closed, or if access occurs from a thread other than the thread owning either\n+     * scopes.\n@@ -160,0 +180,2 @@\n+     * @throws IllegalStateException if the scope associated with this segment has been already closed,\n+     * or if access occurs from a thread other than the thread owning either segment.\n@@ -167,5 +189,4 @@\n-     * @apiNote two addresses might be considered equal despite their associated segments differ. This\n-     * can happen, for instance, if the segment associated with one address is a <em>slice<\/em>\n-     * (see {@link MemorySegment#asSlice(long, long)}) of the segment associated with the other address. Moreover,\n-     * two addresses might be considered equals despite differences in the temporal bounds associated with their\n-     * corresponding segments.\n+     * @apiNote two addresses might be considered equal despite their associated resource scopes differ. This\n+     * can happen, for instance, if the same memory address is used to create memory segments with different\n+     * scopes (using {@link #asSegment(long, ResourceScope)}), and the base address of the resulting segments is\n+     * then compared.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":30,"deletions":9,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -165,3 +165,1 @@\n-     * The returned memory address contains a strong reference to this segment; this means that if this segment\n-     * is associated with a resource scope featuring <a href=\"ResourceScope.html#implicit-closure\"><em>implicit closure<\/em><\/a>,\n-     * the scope won't be closed as long as the returned address is <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">reachable<\/a>.\n+     * The returned memory address is associated with same resource scope as that associated with this segment.\n@@ -351,2 +349,2 @@\n-     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n-     * thread owning this segment\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope,\n@@ -372,2 +370,3 @@\n-     * @throws IllegalStateException if either the source segment or this segment have been already closed,\n-     * or if access occurs from a thread other than the thread owning either segment.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with this segment have been already closed, or if access occurs from a thread other than the thread owning either\n+     * scopes.\n@@ -396,3 +395,3 @@\n-     * @throws IllegalStateException if either this segment of the other segment\n-     * have been already closed, or if access occurs from a thread other than the\n-     * thread owning either segment\n+     * @throws IllegalStateException if either the scope associated with this segment or the scope associated\n+     * with the {@code other} segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n@@ -518,2 +517,2 @@\n-     * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the\n-     * thread owning this segment, or if this segment's contents cannot be copied into a {@link byte[]} instance,\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link byte[]} instance,\n@@ -527,2 +526,2 @@\n-     * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the\n-     * thread owning this segment, or if this segment's contents cannot be copied into a {@link short[]} instance,\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link short[]} instance,\n@@ -536,2 +535,2 @@\n-     * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the\n-     * thread owning this segment, or if this segment's contents cannot be copied into a {@link char[]} instance,\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link char[]} instance,\n@@ -545,2 +544,2 @@\n-     * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the\n-     * thread owning this segment, or if this segment's contents cannot be copied into a {@link int[]} instance,\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link int[]} instance,\n@@ -554,2 +553,2 @@\n-     * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the\n-     * thread owning this segment, or if this segment's contents cannot be copied into a {@link float[]} instance,\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link float[]} instance,\n@@ -563,2 +562,2 @@\n-     * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the\n-     * thread owning this segment, or if this segment's contents cannot be copied into a {@link long[]} instance,\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link long[]} instance,\n@@ -572,2 +571,2 @@\n-     * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the\n-     * thread owning this segment, or if this segment's contents cannot be copied into a {@link double[]} instance,\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link double[]} instance,\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":23,"deletions":24,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -232,1 +232,0 @@\n-        checkValidState();\n@@ -346,1 +345,1 @@\n-    private void checkValidState() {\n+    void checkValidState() {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,0 +61,5 @@\n+    @Override\n+    public ResourceScope scope() {\n+        return segment != null ?\n+                segment.scope() : ResourceScope.globalScope();\n+    }\n@@ -72,1 +77,1 @@\n-            throw new IllegalArgumentException(\"Invalid segment: \" + segment);\n+            throw new IllegalArgumentException(\"Incompatible segment: \" + segment);\n@@ -84,2 +89,5 @@\n-        if (base() != null) {\n-            throw new UnsupportedOperationException(\"Not a native address\");\n+        if (segment != null) {\n+            if (segment.base() != null) {\n+                throw new UnsupportedOperationException(\"Not a native address\");\n+            }\n+            segment.checkValidState();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED SafeFunctionAccessTest\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+\n+import org.testng.annotations.*;\n+import static org.testng.Assert.*;\n+\n+public class SafeFunctionAccessTest {\n+\n+    LibraryLookup lookup = LibraryLookup.ofLibrary(\"SafeAccess\");\n+\n+    static MemoryLayout POINT = MemoryLayout.structLayout(\n+            CLinker.C_INT, CLinker.C_INT\n+    );\n+\n+    @Test(expectedExceptions = IllegalStateException.class)\n+    public void testClosedStruct() throws Throwable {\n+        MemorySegment segment;\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            segment = MemorySegment.allocateNative(POINT, scope);\n+        }\n+        assertFalse(segment.scope().isAlive());\n+        MethodHandle handle = CLinker.getInstance().downcallHandle(\n+                lookup.lookup(\"struct_func\").get(),\n+                MethodType.methodType(void.class, MemorySegment.class),\n+                FunctionDescriptor.ofVoid(POINT));\n+\n+        handle.invokeExact(segment);\n+    }\n+\n+    @Test(expectedExceptions = IllegalStateException.class)\n+    public void testClosedPointer() throws Throwable {\n+        MemoryAddress address;\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            address = MemorySegment.allocateNative(POINT, scope).address();\n+        }\n+        assertFalse(address.scope().isAlive());\n+        MethodHandle handle = CLinker.getInstance().downcallHandle(\n+                lookup.lookup(\"addr_func\").get(),\n+                MethodType.methodType(void.class, MemoryAddress.class),\n+                FunctionDescriptor.ofVoid(CLinker.C_POINTER));\n+\n+        handle.invokeExact(address);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -320,7 +320,7 @@\n-            MappedMemorySegments.isLoaded(segment);\n-            MappedMemorySegments.load(segment);\n-            MappedMemorySegments.isLoaded(segment);\n-            MappedMemorySegments.force(segment);\n-            MappedMemorySegments.isLoaded(segment);\n-            MappedMemorySegments.unload(segment);\n-            MappedMemorySegments.isLoaded(segment);\n+            segment.isLoaded();\n+            segment.load();\n+            segment.isLoaded();\n+            segment.force();\n+            segment.isLoaded();\n+            segment.unload();\n+            segment.isLoaded();\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-            MappedMemorySegments.class,\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -111,0 +111,3 @@\n+            \/\/ address operations\n+            ScopedOperation.ofAddress(a -> a.toRawLongValue(), \"MemoryAddress::toRawLongValue\");\n+            ScopedOperation.ofAddress(a -> a.asSegment(100, ResourceScope.globalScope()), \"MemoryAddress::asSegment\");\n@@ -181,0 +184,9 @@\n+        static void ofAddress(Consumer<MemoryAddress> addressConsumer, String name) {\n+            for (SegmentFactory segmentFactory : SegmentFactory.values()) {\n+                scopedOperations.add(new ScopedOperation(scope -> {\n+                    MemoryAddress segment = segmentFactory.segmentFactory.apply(scope).address();\n+                    addressConsumer.accept(segment);\n+                }, segmentFactory.name() + \"\/\" + name));\n+            }\n+        }\n+\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+struct Point {\n+    int x;\n+    int y;\n+};\n+\n+EXPORT void struct_func(struct Point p) { }\n+\n+EXPORT void addr_func(struct Point* p) { }\n","filename":"test\/jdk\/java\/foreign\/libSafeAccess.c","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"}]}