{"files":[{"patch":"@@ -81,3 +81,3 @@\n-     * {@return a {@link Function} that can project {@linkplain MemorySegment MemorySegments} onto new instances\n-     * of the provided {@link Record} {@code type} by means of matching the names of the\n-     * record components with the names of the elements in this group layout}\n+     * {@return a {@link Function} that can project {@linkplain MemorySegment MemorySegments} into new\n+     * instances of the provided {@link Record} {@code type} by means of matching the names of the\n+     * record components with the names of the member layouts in this group layout}\n@@ -85,0 +85,13 @@\n+     * In short, the method finds, for each record component, a corresponding member layout with the same\n+     * name in this group layout. There are some restrictions on the record component type and the\n+     * corresponding member layout type (e.g. a record component of type {@code int} can only be matched\n+     * with a member layout having a carrier type of {@code int.class} (such as {@link ValueLayout#JAVA_INT}).\n+     * <p>\n+     * Using the member layouts (e.g. observing offsets and {@link java.nio.ByteOrder byte ordering}, a\n+     * number of extraction methods are then identified for all the record components and are stored\n+     * internally in the returned function.\n+     * <p>\n+     * Upon invoking the function, the canonical constructor of the record is invoked with the result of all\n+     * the extraction methods.\n+     * <p>\n+     * More formally:\n@@ -88,2 +101,2 @@\n-     * Let {@code R} comprise its the constituent components\n-     * {@code c_1, c_2}, ..., c_N}, where {@code N} is the (non-negative) number of components of {@code R}.\n+     * Let {@code R} be a record type with its constituent components:\n+     * {@code C1, C2}, ..., CN}, where {@code N} is the (non-negative) number of components of {@code R}.\n@@ -91,2 +104,2 @@\n-     * Let {@code f_a(MemorySegment ms)} be a function that takes\n-     * a {@link MemorySegment} {@code ms} and produces a value for {@code c_a}.\n+     * Let {@code Fa(MemorySegment ms)} be a function that takes\n+     * a {@link MemorySegment} {@code ms} and produces a value for {@code Ca}.\n@@ -94,1 +107,1 @@\n-     * Let {@code L} be a group layout with the elements {@code e_1, e_2, ..., e_M}, where {@code M >= N}.\n+     * Let {@code L} be a group layout with the member layouts {@code ML1, ML2, ..., MLM}, where {@code M >= N}.\n@@ -96,1 +109,1 @@\n-     * Let {@code offsetBetween(GroupLayout layout, MemoryLayout target)} be a function that, via\n+     * Let {@code offsetOf(GroupLayout L, MemoryLayout LL)} be a function that, via\n@@ -98,1 +111,1 @@\n-     * {@code layout L} to a sub-layout of {@code L}.\n+     * {@code layout L} to the sub-layout {@code LL}.\n@@ -100,3 +113,3 @@\n-     * Then, for each {@code c_a, a <= N}, there must be a corresponding distinct\n-     * {@code e_b} such that the {@link MemoryLayout#name() name} of {@code c_a}\n-     * {@link Object#equals(Object) equals} the {@link RecordComponent#getName() name} of {@code e_b} and:\n+     * Then, for each {@code Ca, a <= N}, there must be a corresponding distinct\n+     * {@code MLb} such that the {@link RecordComponent#getName()} () name} of {@code Ca}\n+     * and the {@link MemoryLayout#name() name} of {@code MLb} are the same, and:\n@@ -105,3 +118,3 @@\n-     *        <h4>If {@code e_b} is a {@link ValueLayout };<\/h4>\n-     *        then {@code c_a} must be of the exact type of {@code e_b}'s {@link ValueLayout#carrier() carrier()}<br>\n-     *        whereby {@code c_a = f_a(MemorySegment ms) = ms.get(e_b, offset + offsetBetween(layout, e_b))}.<br>\n+     *        <h4>If {@code MLb} is a {@link ValueLayout };<\/h4>\n+     *        then {@code Ca} must be of the exact type of {@code MLb}'s {@link ValueLayout#carrier() carrier()}<br>\n+     *        whereby {@code Ca = Fa(MemorySegment ms) = ms.get(MLb, offset + offsetOf(layout, MLb))}.<br>\n@@ -110,5 +123,5 @@\n-     *        <h4>If {@code e_b} is a {@link GroupLayout };<\/h4>\n-     *        then {@code e_a} must be of another {@link Record} type {@code R2}\n-     *        (such that {@code R2 != R}) that can be mapped to {@code e_b} via\n-     *        another resulting mapper {@code M2 = M(R2, e_b, offset + offsetBetween(layout, e_b))} recursively\n-     *        whereby {@code c_a} = {@code f_a(MemorySegment ms) = M2.apply(ms)}<br>\n+     *        <h4>If {@code MLb} is a {@link GroupLayout };<\/h4>\n+     *        then {@code Ca} must be of another {@link Record} type {@code R2}\n+     *        (such that {@code R2 != R}) that can be mapped to {@code Ca} via\n+     *        another resulting mapper {@code M2 = M(R2, MLb, offset + offsetOf(layout, MLb))} recursively\n+     *        whereby {@code Ca} = {@code Fa(MemorySegment ms) = M2.apply(ms)}<br>\n@@ -117,4 +130,4 @@\n-     *        <h4>If {@code e_b} is a {@link SequenceLayout };<\/h4>\n-     *        then {@code c_a} must be an array {@code C[]^D} (an array of depth {@code D}\n-     *        and with an array component type {@code C}) that can be mapped to {@code e_b} via a resulting\n-     *        \"array mapper\" {@code A2} obtained via recursively pealing off nested sequence layouts in {@code e_b}\n+     *        <h4>If {@code MLb} is a {@link SequenceLayout };<\/h4>\n+     *        then {@code Ca} must be an array {@code C[]^D} (an array of depth {@code D}\n+     *        and with an array component type {@code C}) that can be mapped to {@code Cb} via a resulting\n+     *        \"array mapper\" {@code A2} obtained via recursively pealing off nested sequence layouts in {@code MLb}\n@@ -128,1 +141,1 @@\n-     *            {@code LM} = {@link MemorySegment#get(ValueLayout.OfInt, long) ms -> ms.get(LL, offset + offsetBetween(layout, e_b))}\n+     *            {@code LM} = {@link MemorySegment#get(ValueLayout.OfInt, long) ms -> ms.get(LL, offset + offsetOf(layout, MLb))}\n@@ -133,1 +146,1 @@\n-     *            {@code LM} = M(C.type, LL, offset + offsetBetween(layout, e_b)} recursively.\n+     *            {@code LM} = M(C.type, LL, offset + offsetOf(layout, MLb)} recursively.\n@@ -136,1 +149,1 @@\n-     *        whereby {@code c_a} = {@code f_a(MemorySegment ms)} will be extracted by\n+     *        whereby {@code Ca} = {@code Fa(MemorySegment ms)} will be extracted by\n@@ -143,5 +156,0 @@\n-     *        <h4>If {@code e_b} is a {@link PaddingLayout };<\/h4>\n-     *        then the method will throw an {@link IllegalArgumentException} as a padding layout cannot\n-     *        be projected to any record component.<br>\n-     *    <\/li>\n-     *    <li>\n@@ -149,3 +157,3 @@\n-     *        the method will throw an {@link IllegalArgumentException} as {@code e_b} cannot\n-     *        be projected onto {@code c_a}.  An example of this is trying to match a record component\n-     *        of type {@link String}.<br>\n+     *        the method will throw an {@link IllegalArgumentException} as {@code MLb} cannot\n+     *        be projected onto {@code Ca}.  An example of this is trying to match a record component\n+     *        of type {@link String} or trying to map a {@link PaddingLayout} element.<br>\n@@ -159,1 +167,1 @@\n-     * {@code ms -> new R(f_1(ms), f_2(ms), ..., f_N(ms))}\n+     * {@code ms -> new R(F1(ms), F2(ms), ..., FN(ms))}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":45,"deletions":37,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.util.Random;\n@@ -48,1 +47,1 @@\n-public class RecordMapper {\n+public class LayoutRecordMapper {\n@@ -82,3 +81,2 @@\n-        var rnd = new Random();\n-        pointSegment.set(JAVA_INT, 0, rnd.nextInt(10));\n-        pointSegment.set(JAVA_INT, 4, rnd.nextInt(10));\n+        pointSegment.set(JAVA_INT, 0, 3);\n+        pointSegment.set(JAVA_INT, 4, 4);\n@@ -86,1 +84,0 @@\n-        int[] ints = rnd.ints(ARRAY_SIZE).toArray();\n@@ -90,1 +87,1 @@\n-            arraySegment.setAtIndex(JAVA_INT, i, ints[i]);\n+            arraySegment.setAtIndex(JAVA_INT, i, i);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LayoutRecordMapper.java","additions":4,"deletions":7,"binary":false,"changes":11,"previous_filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/RecordMapper.java","status":"renamed"}]}