{"files":[{"patch":"@@ -49,0 +49,1 @@\n+import java.util.Optional;\n@@ -50,1 +51,0 @@\n-import java.util.function.BinaryOperator;\n@@ -53,1 +53,0 @@\n-import java.util.stream.IntStream;\n@@ -66,4 +65,0 @@\n-    enum Allow {EXACT, BOXING, BOXING_NARROWING_AND_WIDENING}\n-\n-    public static final Allow ALLOW = Allow.EXACT;\n-\n@@ -75,0 +70,1 @@\n+    private final long offset;\n@@ -85,0 +81,5 @@\n+\n+        if (Record.class.equals(type)) {\n+            throw new IllegalArgumentException(\"The common base class java.lang.Record is not a record in itself\");\n+        }\n+\n@@ -87,0 +88,1 @@\n+        this.offset = offset;\n@@ -88,16 +90,1 @@\n-        var recordComponents = Arrays.asList(type.getRecordComponents());\n-        var recordComponentNames = recordComponents.stream()\n-                .map(RecordComponent::getName)\n-                .collect(Collectors.toSet());\n-\n-        var nameToLayoutMap = layout.memberLayouts().stream()\n-                \/\/ Only consider named layouts\n-                .filter(l -> l.name().isPresent())\n-                \/\/ Only look at the relevant layouts which could ever be matched with a record component\n-                .filter(l -> recordComponentNames.contains(l.name().orElseThrow()))\n-                .collect(toMap(l -> l.name().orElseThrow(), Function.identity(), throwingMerger()));\n-\n-        var missingComponents = recordComponents.stream()\n-                .map(RecordComponent::getName)\n-                .filter(l -> !nameToLayoutMap.containsKey(l))\n-                .toList();\n+        assertMappingsCorrect();\n@@ -105,8 +92,3 @@\n-        if (!missingComponents.isEmpty()) {\n-            throw new IllegalArgumentException(\"No mapping for \" +\n-                    type.getName() + missingComponents +\n-                    \" in layout \" + layout);\n-        }\n-\n-        var componentAndLayoutList = recordComponents.stream()\n-                .map(c -> new ComponentAndLayout(c, nameToLayoutMap.get(c.getName())))\n+        \/\/ For each component, find an f(a) = MethodHandle(MemorySegment) that returns the component type\n+        var handles = Arrays.stream(type.getRecordComponents())\n+                .map(this::methodHandle)\n@@ -115,1 +97,1 @@\n-        Class<?>[] ctorParameterTypes = recordComponents.stream()\n+        Class<?>[] ctorParameterTypes = Arrays.stream(type.getRecordComponents())\n@@ -119,179 +101,0 @@\n-        \/\/ An array of the record component MethodHandle extractors, each of type (MemorySegment)X\n-        \/\/ where X is the component type.\n-        MethodHandle[] handles = componentAndLayoutList.stream()\n-                .map(cl -> {\n-                    var name = cl.layout().name().orElseThrow();\n-                    var pathElement = MemoryLayout.PathElement.groupElement(name);\n-                    long byteOffset = layout.byteOffset(pathElement) + offset;\n-\n-                    return switch (cl.layout()) {\n-                        case ValueLayout vl -> {\n-                            try {\n-                                assertTypesMatch(cl, type, vl, layout);\n-                                var mt = MethodType.methodType(vl.carrier(), valueLayoutType(vl), long.class);\n-                                var mh = PUBLIC_LOOKUP.findVirtual(MemorySegment.class, \"get\", mt);\n-                                \/\/ (MemorySegment, OfX, long) -> (MemorySegment, long)\n-                                mh = MethodHandles.insertArguments(mh, 1, vl);\n-                                \/\/ (MemorySegment, long) -> (MemorySegment)\n-                                yield castReturnType(MethodHandles.insertArguments(mh, 1, byteOffset), cl.component().getType());\n-                            } catch (NoSuchMethodException | IllegalAccessException e) {\n-                                throw new InternalError(e);\n-                            }\n-                        }\n-                        case GroupLayout gl -> {\n-                            var componentType = cl.component().getType().asSubclass(Record.class);\n-                            var componentMapper = recordMapper(componentType, gl, byteOffset);\n-                            try {\n-                                var mt = MethodType.methodType(Record.class, MemorySegment.class);\n-                                var mh = LOOKUP.findVirtual(LayoutRecordMapper.class, \"apply\", mt);\n-                                \/\/ (LayoutRecordAccessor, MemorySegment)Record -> (MemorySegment)Record\n-                                mh = MethodHandles.insertArguments(mh, 0, componentMapper);\n-                                \/\/ (MemorySegment)Record -> (MemorySegment)componentType\n-                                yield MethodHandles.explicitCastArguments(mh, MethodType.methodType(componentType, MemorySegment.class));\n-                            } catch (NoSuchMethodException | IllegalAccessException e) {\n-                                throw new RuntimeException(e);\n-                            }\n-                        }\n-                        case SequenceLayout sl -> {\n-                            try {\n-                                var componentType = cl.component().getType();\n-                                if (!componentType.isArray()) {\n-                                    throw new IllegalArgumentException(\"Unable to map '\" + sl +\n-                                            \"' because the component '\" + componentType.getName() + \" \" + name + \"' is not an array\");\n-                                }\n-\n-                                MultidimensionalSequenceLayoutInfo info = MultidimensionalSequenceLayoutInfo.of(sl);\n-\n-                                if (info.elementLayout() instanceof ValueLayout.OfBoolean) {\n-                                    throw new IllegalArgumentException(\"Arrays of booleans (\" + info.elementLayout() + \") are not supported\");\n-                                }\n-\n-                                if (dimensionOf(componentType) != info.sequences().size()) {\n-                                    throw new IllegalArgumentException(\"Unable to map '\" + sl + \"'\" +\n-                                            \" of dimension \" + info.sequences().size() +\n-                                            \" because the component '\" + componentType.getName() + \" \" + name + \"'\" +\n-                                            \" has a dimension of \" + dimensionOf(componentType));\n-                                }\n-\n-                                \/\/ Handle multi-dimensional arrays\n-                                if (info.sequences().size() > 1) {\n-                                    var mh = LOOKUP.findStatic(LayoutRecordMapper.class, \"toMultiArrayFunction\",\n-                                            MethodType.methodType(Object.class, MemorySegment.class, MultidimensionalSequenceLayoutInfo.class, long.class, Class.class, Function.class));\n-                                    \/\/ (MemorySegment, MultidimensionalSequenceLayoutInfo, long offset, Class leafType, Function mapper) ->\n-                                    \/\/ (MemorySegment, long offset, Class leafType, Function mapper)\n-                                    mh = MethodHandles.insertArguments(mh, 1, info);\n-                                    \/\/ (MemorySegment, long offset, Class leafType, Function mapper) ->\n-                                    \/\/ (MemorySegment, Class leafType, Function mapper)\n-                                    mh = MethodHandles.insertArguments(mh, 1, byteOffset);\n-\n-                                    switch (info.elementLayout()) {\n-                                        case ValueLayout vl -> {\n-                                            \/\/ (MemorySegment, Class leafType, Function mapper) ->\n-                                            \/\/ (MemorySegment, Function mapper)\n-                                            mh = MethodHandles.insertArguments(mh, 1, vl.carrier());\n-                                            Function<MemorySegment, Object> leafArrayMapper =\n-                                            switch (vl) {\n-                                                case ValueLayout.OfByte ofByte ->\n-                                                        ms -> ms.toArray(ofByte);\n-                                                case ValueLayout.OfBoolean ofBoolean ->\n-                                                        throw new UnsupportedOperationException(\"boolean arrays not supported: \" + ofBoolean);\n-                                                case ValueLayout.OfShort ofShort ->\n-                                                         ms -> ms.toArray(ofShort);\n-                                                case ValueLayout.OfChar ofChar ->\n-                                                        ms -> ms.toArray(ofChar);\n-                                                case ValueLayout.OfInt ofInt ->\n-                                                        ms -> ms.toArray(ofInt);\n-                                                case ValueLayout.OfLong ofLong ->\n-                                                        ms -> ms.toArray(ofLong);\n-                                                case ValueLayout.OfFloat ofFloat ->\n-                                                        ms -> ms.toArray(ofFloat);\n-                                                case ValueLayout.OfDouble ofDouble ->\n-                                                        ms -> ms.toArray(ofDouble);\n-                                                case AddressLayout addressLayout ->\n-                                                        ms -> ms.elements(addressLayout)\n-                                                                .map(s -> s.get(addressLayout, 0))\n-                                                                .toArray(MemorySegment[]::new);\n-                                            };\n-                                            \/\/ (MemorySegment, Function mapper) ->\n-                                            \/\/ (MemorySegment)\n-                                            mh = MethodHandles.insertArguments(mh, 1, leafArrayMapper);\n-                                            yield castReturnType(mh, cl.component().getType());\n-                                        }\n-                                        case GroupLayout gl -> {\n-                                            var arrayComponentType = deepArrayComponentType(cl.component.getType()).asSubclass(Record.class);\n-                                            \/\/ The \"local\" byteOffset for the record component mapper is zero\n-                                            var componentMapper = recordMapper(arrayComponentType, gl, 0);\n-                                            Function<MemorySegment, Object> leafArrayMapper = ms -> {\n-                                                Object leafArray = Array.newInstance(arrayComponentType, info.lastDimension());\n-\n-                                                int[] i = new int[]{0};\n-                                                ms.elements(info.elementLayout())\n-                                                        .map(componentMapper)\n-                                                        .forEachOrdered(r -> Array.set(leafArray, i[0]++, r));\n-                                                return leafArray;\n-                                            };\n-\n-                                            \/\/ (MemorySegment, Class leafType, Function mapper) ->\n-                                            \/\/ (MemorySegment, Function mapper)\n-                                            mh = MethodHandles.insertArguments(mh, 1, arrayComponentType);\n-                                            \/\/ (MemorySegment, Function mapper) ->\n-                                            \/\/ (MemorySegment)\n-                                            mh = MethodHandles.insertArguments(mh, 1, leafArrayMapper);\n-                                            yield castReturnType(mh, cl.component().getType());\n-                                        }\n-                                        case SequenceLayout __ -> {\n-                                            throw new InternalError(\"Should not reach here\");\n-                                        }\n-                                        case PaddingLayout __ -> throw fail(cl);\n-                                    }\n-                                }\n-\n-                                \/\/ Faster single-dimensional arrays\n-                                switch (info.elementLayout()) {\n-                                    case ValueLayout vl -> {\n-                                        assertTypesMatch(cl, type, vl, layout);\n-                                        var mh = findStaticToArray(vl.carrier().arrayType(), valueLayoutType(vl), null);\n-                                        \/\/ (MemorySegment, OfX, long offset, long count) -> (MemorySegment, OfX, long offset)\n-                                        mh = MethodHandles.insertArguments(mh, 3, info.sequences().getFirst().elementCount());\n-                                        \/\/ (MemorySegment, OfX, long offset) -> (MemorySegment, long offset)\n-                                        mh = MethodHandles.insertArguments(mh, 1, vl);\n-                                        \/\/ (MemorySegment, long offset) -> (MemorySegment)\n-                                        yield castReturnType(MethodHandles.insertArguments(mh, 1, byteOffset), cl.component().getType());\n-                                    }\n-                                    case GroupLayout gl -> {\n-                                        var arrayComponentType = deepArrayComponentType(cl.component().getType()).asSubclass(Record.class);\n-                                        \/\/ The \"local\" byteOffset for the record component mapper is zero\n-                                        var componentMapper = recordMapper(arrayComponentType, gl, 0);\n-                                        try {\n-                                            var mh = findStaticToArray(Record.class.arrayType(), GroupLayout.class, LayoutRecordMapper.class);\n-                                            \/\/ (MemorySegment, GroupLayout, long offset, long count, Function) ->\n-                                            \/\/ (MemorySegment, GroupLayout, long offset, long count)\n-                                            mh = MethodHandles.insertArguments(mh, 4, componentMapper);\n-                                            \/\/ (MemorySegment, GroupLayout, long offset, long count) ->\n-                                            \/\/ (MemorySegment, GroupLayout, long offset)\n-                                            mh = MethodHandles.insertArguments(mh, 3, info.sequences().getFirst().elementCount());\n-                                            \/\/ (MemorySegment, GroupLayout, long offset) ->\n-                                            \/\/ (MemorySegment, long offset)\n-                                            mh = MethodHandles.insertArguments(mh, 1, gl);\n-                                            \/\/ (MemorySegment, long offset) -> (MemorySegment)Record[]\n-                                            mh = MethodHandles.insertArguments(mh, 1, byteOffset);\n-                                            \/\/ (MemorySegment, long offset)Record[] -> (MemorySegment)componentType\n-                                            yield MethodHandles.explicitCastArguments(mh, MethodType.methodType(cl.component().getType(), MemorySegment.class));\n-                                        } catch (NoSuchMethodException | IllegalAccessException e) {\n-                                            throw new RuntimeException(e);\n-                                        }\n-                                    }\n-                                    case SequenceLayout __ -> {\n-                                        throw new InternalError(\"Should not reach here\");\n-                                    }\n-                                    case PaddingLayout __ -> throw fail(cl);\n-                                }\n-                            } catch (NoSuchMethodException | IllegalAccessException e) {\n-                                throw new InternalError(e);\n-                            }\n-                        }\n-                        case PaddingLayout __ -> throw fail(cl); \/\/ Ignore\n-                    };\n-                })\n-                .toArray(MethodHandle[]::new);\n-\n@@ -300,1 +103,1 @@\n-            for (int i = 0; i < handles.length; i++) {\n+            for (int i = 0; i < handles.size(); i++) {\n@@ -302,1 +105,1 @@\n-                ctor = MethodHandles.filterArguments(ctor, i, handles[i]);\n+                ctor = MethodHandles.filterArguments(ctor, i, handles.get(i));\n@@ -307,1 +110,1 @@\n-            ctor = MethodHandles.permuteArguments(ctor, mt, new int[handles.length]);\n+            ctor = MethodHandles.permuteArguments(ctor, mt, new int[handles.size()]);\n@@ -317,4 +120,15 @@\n-    private static <U> BinaryOperator<U> throwingMerger() {\n-        return (a, b) -> {\n-            throw new IllegalArgumentException(\"Duplicate keys: \" + a);\n-        };\n+    private MethodHandle methodHandle(RecordComponent component) {\n+\n+        var pathElement = MemoryLayout.PathElement.groupElement(component.getName());\n+        var componentLayout = layout.select(pathElement);\n+        var byteOffset = layout.byteOffset(pathElement) + offset;\n+        try {\n+            return switch (componentLayout) {\n+                case ValueLayout vl -> methodHandle(vl, component, byteOffset);\n+                case GroupLayout gl -> methodHandle(gl, component, byteOffset);\n+                case SequenceLayout sl -> methodHandle(sl, component, byteOffset);\n+                case PaddingLayout __ -> throw fail(component, componentLayout);\n+            };\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            throw new InternalError(e);\n+        }\n@@ -323,1 +137,158 @@\n-    private IllegalArgumentException fail(ComponentAndLayout cl) {\n+    private MethodHandle methodHandle(ValueLayout vl,\n+                                      RecordComponent component,\n+                                      long byteOffset) throws NoSuchMethodException, IllegalAccessException {\n+\n+        assertTypesMatch(component, null, vl);\n+        var mt = MethodType.methodType(vl.carrier(), valueLayoutType(vl), long.class);\n+        var mh = PUBLIC_LOOKUP.findVirtual(MemorySegment.class, \"get\", mt);\n+        \/\/ (MemorySegment, OfX, long) -> (MemorySegment, long)\n+        mh = MethodHandles.insertArguments(mh, 1, vl);\n+        \/\/ (MemorySegment, long) -> (MemorySegment)\n+        return castReturnType(MethodHandles.insertArguments(mh, 1, byteOffset), component.getType());\n+    }\n+\n+    private MethodHandle methodHandle(GroupLayout gl,\n+                                      RecordComponent component,\n+                                      long byteOffset) throws NoSuchMethodException, IllegalAccessException {\n+\n+        var componentType = component.getType().asSubclass(Record.class);\n+        var componentMapper = recordMapper(componentType, gl, byteOffset);\n+        var mt = MethodType.methodType(Record.class, MemorySegment.class);\n+        var mh = LOOKUP.findVirtual(LayoutRecordMapper.class, \"apply\", mt);\n+        \/\/ (LayoutRecordAccessor, MemorySegment)Record -> (MemorySegment)Record\n+        mh = MethodHandles.insertArguments(mh, 0, componentMapper);\n+        \/\/ (MemorySegment)Record -> (MemorySegment)componentType\n+        return MethodHandles.explicitCastArguments(mh, MethodType.methodType(componentType, MemorySegment.class));\n+    }\n+\n+    private MethodHandle methodHandle(SequenceLayout sl,\n+                                      RecordComponent component,\n+                                      long byteOffset) throws NoSuchMethodException, IllegalAccessException {\n+\n+        String name = component.getName();\n+        var componentType = component.getType();\n+        if (!componentType.isArray()) {\n+            throw new IllegalArgumentException(\"Unable to map '\" + sl +\n+                    \"' because the component '\" + componentType.getName() + \" \" + name + \"' is not an array\");\n+        }\n+\n+        MultidimensionalSequenceLayoutInfo info = MultidimensionalSequenceLayoutInfo.of(sl);\n+\n+        if (info.elementLayout() instanceof ValueLayout.OfBoolean) {\n+            throw new IllegalArgumentException(\"Arrays of booleans (\" + info.elementLayout() + \") are not supported\");\n+        }\n+\n+        if (dimensionOf(componentType) != info.sequences().size()) {\n+            throw new IllegalArgumentException(\"Unable to map '\" + sl + \"'\" +\n+                    \" of dimension \" + info.sequences().size() +\n+                    \" because the component '\" + componentType.getName() + \" \" + name + \"'\" +\n+                    \" has a dimension of \" + dimensionOf(componentType));\n+        }\n+\n+        \/\/ Handle multi-dimensional arrays\n+        if (info.sequences().size() > 1) {\n+            var mh = LOOKUP.findStatic(LayoutRecordMapper.class, \"toMultiArrayFunction\",\n+                    MethodType.methodType(Object.class, MemorySegment.class, MultidimensionalSequenceLayoutInfo.class, long.class, Class.class, Function.class));\n+            \/\/ (MemorySegment, MultidimensionalSequenceLayoutInfo, long offset, Class leafType, Function mapper) ->\n+            \/\/ (MemorySegment, long offset, Class leafType, Function mapper)\n+            mh = MethodHandles.insertArguments(mh, 1, info);\n+            \/\/ (MemorySegment, long offset, Class leafType, Function mapper) ->\n+            \/\/ (MemorySegment, Class leafType, Function mapper)\n+            mh = MethodHandles.insertArguments(mh, 1, byteOffset);\n+\n+            switch (info.elementLayout()) {\n+                case ValueLayout vl -> {\n+                    \/\/ (MemorySegment, Class leafType, Function mapper) ->\n+                    \/\/ (MemorySegment, Function mapper)\n+                    mh = MethodHandles.insertArguments(mh, 1, vl.carrier());\n+                    Function<MemorySegment, Object> leafArrayMapper =\n+                            switch (vl) {\n+                                case ValueLayout.OfByte ofByte -> ms -> ms.toArray(ofByte);\n+                                case ValueLayout.OfBoolean ofBoolean ->\n+                                        throw new UnsupportedOperationException(\"boolean arrays not supported: \" + ofBoolean);\n+                                case ValueLayout.OfShort ofShort -> ms -> ms.toArray(ofShort);\n+                                case ValueLayout.OfChar ofChar -> ms -> ms.toArray(ofChar);\n+                                case ValueLayout.OfInt ofInt -> ms -> ms.toArray(ofInt);\n+                                case ValueLayout.OfLong ofLong -> ms -> ms.toArray(ofLong);\n+                                case ValueLayout.OfFloat ofFloat -> ms -> ms.toArray(ofFloat);\n+                                case ValueLayout.OfDouble ofDouble -> ms -> ms.toArray(ofDouble);\n+                                case AddressLayout addressLayout -> ms -> ms.elements(addressLayout)\n+                                        .map(s -> s.get(addressLayout, 0))\n+                                        .toArray(MemorySegment[]::new);\n+                            };\n+                    \/\/ (MemorySegment, Function mapper) ->\n+                    \/\/ (MemorySegment)\n+                    mh = MethodHandles.insertArguments(mh, 1, leafArrayMapper);\n+                    return castReturnType(mh, component.getType());\n+                }\n+                case GroupLayout gl -> {\n+                    var arrayComponentType = deepArrayComponentType(component.getType()).asSubclass(Record.class);\n+                    \/\/ The \"local\" byteOffset for the record component mapper is zero\n+                    var componentMapper = recordMapper(arrayComponentType, gl, 0);\n+                    Function<MemorySegment, Object> leafArrayMapper = ms -> {\n+                        Object leafArray = Array.newInstance(arrayComponentType, info.lastDimension());\n+\n+                        int[] i = new int[]{0};\n+                        ms.elements(info.elementLayout())\n+                                .map(componentMapper)\n+                                .forEachOrdered(r -> Array.set(leafArray, i[0]++, r));\n+                        return leafArray;\n+                    };\n+\n+                    \/\/ (MemorySegment, Class leafType, Function mapper) ->\n+                    \/\/ (MemorySegment, Function mapper)\n+                    mh = MethodHandles.insertArguments(mh, 1, arrayComponentType);\n+                    \/\/ (MemorySegment, Function mapper) ->\n+                    \/\/ (MemorySegment)\n+                    mh = MethodHandles.insertArguments(mh, 1, leafArrayMapper);\n+                    return castReturnType(mh, component.getType());\n+                }\n+                case SequenceLayout __ -> {\n+                    throw new InternalError(\"Should not reach here\");\n+                }\n+                case PaddingLayout __ -> throw fail(component, sl);\n+            }\n+        }\n+\n+        \/\/ Faster single-dimensional arrays\n+        switch (info.elementLayout()) {\n+            case ValueLayout vl -> {\n+                assertTypesMatch(component, sl, vl);\n+                var mh = findStaticToArray(vl.carrier().arrayType(), valueLayoutType(vl), null);\n+                \/\/ (MemorySegment, OfX, long offset, long count) -> (MemorySegment, OfX, long offset)\n+                mh = MethodHandles.insertArguments(mh, 3, info.sequences().getFirst().elementCount());\n+                \/\/ (MemorySegment, OfX, long offset) -> (MemorySegment, long offset)\n+                mh = MethodHandles.insertArguments(mh, 1, vl);\n+                \/\/ (MemorySegment, long offset) -> (MemorySegment)\n+                return castReturnType(MethodHandles.insertArguments(mh, 1, byteOffset), component.getType());\n+            }\n+            case GroupLayout gl -> {\n+                var arrayComponentType = deepArrayComponentType(component.getType()).asSubclass(Record.class);\n+                \/\/ The \"local\" byteOffset for the record component mapper is zero\n+                var componentMapper = recordMapper(arrayComponentType, gl, 0);\n+                try {\n+                    var mh = findStaticToArray(Record.class.arrayType(), GroupLayout.class, LayoutRecordMapper.class);\n+                    \/\/ (MemorySegment, GroupLayout, long offset, long count, Function) ->\n+                    \/\/ (MemorySegment, GroupLayout, long offset, long count)\n+                    mh = MethodHandles.insertArguments(mh, 4, componentMapper);\n+                    \/\/ (MemorySegment, GroupLayout, long offset, long count) ->\n+                    \/\/ (MemorySegment, GroupLayout, long offset)\n+                    mh = MethodHandles.insertArguments(mh, 3, info.sequences().getFirst().elementCount());\n+                    \/\/ (MemorySegment, GroupLayout, long offset) ->\n+                    \/\/ (MemorySegment, long offset)\n+                    mh = MethodHandles.insertArguments(mh, 1, gl);\n+                    \/\/ (MemorySegment, long offset) -> (MemorySegment)Record[]\n+                    mh = MethodHandles.insertArguments(mh, 1, byteOffset);\n+                    \/\/ (MemorySegment, long offset)Record[] -> (MemorySegment)componentType\n+                    return MethodHandles.explicitCastArguments(mh, MethodType.methodType(component.getType(), MemorySegment.class));\n+                } catch (NoSuchMethodException | IllegalAccessException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+            case SequenceLayout __ ->  throw new InternalError(\"Should not reach here\");\n+            case PaddingLayout __ -> throw fail(component, sl);\n+        }\n+    }\n+\n+    private IllegalArgumentException fail(RecordComponent component,\n+                                          MemoryLayout layout) {\n@@ -325,1 +296,1 @@\n-                \"Unable to map \" + cl.layout() + \" to \" + type.getName() + \".\" + cl.component().getName());\n+                \"Unable to map \" + layout + \" to \" + type.getName() + \".\" + component.getName());\n@@ -344,1 +315,2 @@\n-                \"layout=\" + layout + \"}\";\n+                \"layout=\" + layout + \", \" +\n+                \"offset=\" + offset + \"}\";\n@@ -374,4 +346,3 @@\n-    static void assertTypesMatch(ComponentAndLayout cl,\n-                                 Class<? extends Record> type,\n-                                 ValueLayout vl,\n-                                 MemoryLayout originalLayout) {\n+    void assertTypesMatch(RecordComponent component,\n+                          MemoryLayout sequenceLayout,\n+                          ValueLayout vl) {\n@@ -379,2 +350,2 @@\n-        Class<?> recordComponentType = cl.component().getType();\n-        if (recordComponentType.isArray() && cl.layout() instanceof SequenceLayout) {\n+        Class<?> recordComponentType = component.getType();\n+        if (recordComponentType.isArray() && sequenceLayout instanceof SequenceLayout) {\n@@ -384,10 +355,1 @@\n-        boolean match = switch (ALLOW) {\n-            \/\/ Require types to be identical only: e.g. Integer.class != int.class\n-            case EXACT -> recordComponentType == vl.carrier();\n-            \/\/ Accept boxing: e.g. Integer.class.isInstance(int.class) -> true\n-            case BOXING -> recordComponentType.isInstance(vl.carrier());\n-            \/\/ Accept anything for now and signal errors later when composing VHs\n-            case BOXING_NARROWING_AND_WIDENING -> true;\n-        };\n-\n-        if (!match) {\n+        if (!(recordComponentType == vl.carrier())) {\n@@ -395,2 +357,2 @@\n-                    cl.component().getName() + \"' (in \" + type.getName() + \") has the type of '\" + cl.component().getType() +\n-                    \"' but the layout type is '\" + vl.carrier() + \"' (in \" + originalLayout + \")\");\n+                    component.getName() + \"' (in \" + type.getName() + \") has the type of '\" + component.getType() +\n+                    \"' but the layout carrier is '\" + vl.carrier() + \"' (in \" + layout + \")\");\n@@ -408,0 +370,20 @@\n+    void assertMappingsCorrect() {\n+        var nameMappingCounts = layout.memberLayouts().stream()\n+                .map(MemoryLayout::name)\n+                .flatMap(Optional::stream)\n+                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n+\n+        \/\/ Make sure we have all components distinctly mapped\n+        for (RecordComponent component : type.getRecordComponents()) {\n+            String name = component.getName();\n+            switch (nameMappingCounts.get(name).intValue()) {\n+                case 0 -> throw new IllegalArgumentException(\"No mapping for \" +\n+                        type.getName() + \".\" + component.getName() +\n+                        \" in layout \" + layout);\n+                case 1 -> { \/* Happy path *\/ }\n+                default -> throw new IllegalArgumentException(\"Duplicate mappings for \" +\n+                        type.getName() + \".\" + component.getName() +\n+                        \" in layout \" + layout);\n+            }\n+        }\n+    }\n@@ -419,4 +401,0 @@\n-    record ComponentAndLayout(RecordComponent component,\n-                              MemoryLayout layout) {\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutRecordMapper.java","additions":220,"deletions":242,"binary":false,"changes":462,"status":"modified"},{"patch":"@@ -123,3 +123,0 @@\n-        if (Record.class.equals(recordType)) {\n-            throw new IllegalArgumentException(\"The common base class java.lang.Record is not a record in itself\");\n-        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractGroupLayout.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}