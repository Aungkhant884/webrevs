{"files":[{"patch":"@@ -48,0 +48,1 @@\n+import java.util.Spliterator;\n@@ -148,1 +149,1 @@\n-        var mt = MethodType.methodType(vl.carrier(), valueLayoutType(vl), long.class);\n+        var mt = MethodType.methodType(vl.carrier(), topValueLayoutType(vl), long.class);\n@@ -231,17 +232,2 @@\n-                    \/\/ Todo: Investigate the performance of the Function below\n-                    \/\/ Todo: Use the existing method further below for this.\n-                    Function<MemorySegment, Object> leafArrayMapper = ms -> {\n-                        Object leafArray = Array.newInstance(arrayComponentType, info.lastDimension());\n-\n-                        int[] i = new int[]{0};\n-                        ms.elements(info.elementLayout())\n-                                .map(s -> {\n-                                    try {\n-                                        return mapperCtor.invokeExact(s);\n-                                    } catch (Throwable t) {\n-                                        throw new IllegalArgumentException(t);\n-                                    }\n-                                })\n-                                .forEachOrdered(r -> Array.set(leafArray, i[0]++, r));\n-                        return leafArray;\n-                    };\n+                    Function<MemorySegment, Object> leafArrayMapper = ms ->\n+                            toArray(ms, gl, info.lastDimension(), arrayComponentType, mapperCtor);\n@@ -269,1 +255,1 @@\n-                        MemorySegment.class, valueLayoutType(vl), long.class, long.class);\n+                        MemorySegment.class, topValueLayoutType(vl), long.class, long.class);\n@@ -338,13 +324,4 @@\n-    \/\/ The parameter is of type ValueLayouts.OfByteImpl and the likes.\n-    static Class<? extends ValueLayout> valueLayoutType(ValueLayout vl) {\n-        return switch (vl) {\n-            case ValueLayout.OfBoolean __ -> ValueLayout.OfBoolean.class;\n-            case ValueLayout.OfByte __ -> ValueLayout.OfByte.class;\n-            case ValueLayout.OfShort __ -> ValueLayout.OfShort.class;\n-            case ValueLayout.OfChar __ -> ValueLayout.OfChar.class;\n-            case ValueLayout.OfInt __ -> ValueLayout.OfInt.class;\n-            case ValueLayout.OfLong __ -> ValueLayout.OfLong.class;\n-            case ValueLayout.OfFloat __ -> ValueLayout.OfFloat.class;\n-            case ValueLayout.OfDouble __ -> ValueLayout.OfDouble.class;\n-            case AddressLayout __ -> AddressLayout.class;\n-        };\n+    static Class<? extends ValueLayout> topValueLayoutType(ValueLayout vl) {\n+        \/\/ All the permitted implementations OfXImpl of the ValueLayout interfaces declare\n+        \/\/ its main top interface OfX as the sole interface (e.g. OfIntImpl implements only OfInt directly)\n+        return vl.getClass().getInterfaces()[0].asSubclass(ValueLayout.class);\n@@ -475,1 +452,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -480,1 +456,1 @@\n-                           Class<?> type,\n+                           Class<R> type,\n@@ -483,10 +459,22 @@\n-        return slice(segment, elementLayout, offset, count)\n-                .elements(elementLayout)\n-                .map(s -> {\n-                    try {\n-                        return mapper.invokeExact(s);\n-                    } catch (Throwable t) {\n-                        throw new IllegalArgumentException(t);\n-                    }\n-                })\n-                .toArray(l -> (R[]) Array.newInstance(type, l));\n+        var slice = slice(segment, elementLayout, offset, count);\n+        return toArray(slice, elementLayout, count, type, mapper);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <R> R[] toArray(MemorySegment segment,\n+                           GroupLayout elementLayout,\n+                           long count,\n+                           Class<R> type,\n+                           MethodHandle mapper) {\n+\n+        R[] result = (R[]) Array.newInstance(type, Math.toIntExact(count));\n+        Spliterator<MemorySegment> spliterator = segment.spliterator(elementLayout);\n+        int[] cnt = new int[]{0};\n+        spliterator.forEachRemaining(s -> {\n+            try {\n+                result[cnt[0]++] = (R) mapper.invokeExact(s);\n+            } catch (Throwable t) {\n+                throw new IllegalArgumentException(t);\n+            }\n+        });\n+        return result;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutRecordMapper.java","additions":32,"deletions":44,"binary":false,"changes":76,"status":"modified"}]}