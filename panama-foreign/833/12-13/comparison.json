{"files":[{"patch":"@@ -62,1 +62,1 @@\n-public final class LayoutRecordMapper<T extends Record>\n+public final class LayoutRecordMapper<T>\n@@ -71,0 +71,1 @@\n+    private final int depth;\n@@ -76,1 +77,1 @@\n-        this(type, layout, 0L, PUBLIC_LOOKUP);\n+        this(type, layout, 0L, 0, PUBLIC_LOOKUP);\n@@ -82,0 +83,1 @@\n+                              int depth,\n@@ -84,2 +86,2 @@\n-        if (Record.class.equals(type)) {\n-            throw new IllegalArgumentException(\"The common base class java.lang.Record is not a record in itself\");\n+        if (!type.isRecord() || Record.class.equals(type)) {\n+            throw new IllegalArgumentException(type + \" is not a Record\");\n@@ -91,0 +93,1 @@\n+        this.depth = depth;\n@@ -100,0 +103,2 @@\n+        System.out.println(\"handles for \" + type + \" are \" + handles);\n+\n@@ -106,0 +111,1 @@\n+            System.out.println(\"ctor0 = \" + ctor);\n@@ -114,1 +120,8 @@\n-\n+            \/\/ ctor = ctor.asType(mt);\n+            System.out.println(\"ctor1 = \" + ctor);\n+            if (depth == 0) {\n+                \/\/ This is the base level mh so, we need to cast to Object as the final\n+                \/\/ apply() method will do the final cast\n+                ctor = ctor.asType(MethodType.methodType(Object.class, MemorySegment.class));\n+            }\n+            System.out.println(\"ctor2 = \" + ctor);\n@@ -156,9 +169,2 @@\n-\n-        var componentType = component.getType().asSubclass(Record.class);\n-        var componentMapper = recordMapper(componentType, gl, byteOffset);\n-        var mt = MethodType.methodType(Record.class, MemorySegment.class);\n-        var mh = LOOKUP.findVirtual(LayoutRecordMapper.class, \"apply\", mt);\n-        \/\/ (LayoutRecordAccessor, MemorySegment)Record -> (MemorySegment)Record\n-        mh = MethodHandles.insertArguments(mh, 0, componentMapper);\n-        \/\/ (MemorySegment)Record -> (MemorySegment)componentType\n-        return MethodHandles.explicitCastArguments(mh, MethodType.methodType(componentType, MemorySegment.class));\n+        \/\/ Simply return the raw MethodHandle of the recursively computed record mapper\n+        return recordMapper(component.getType(), gl, byteOffset).ctor;\n@@ -228,1 +234,1 @@\n-                    var arrayComponentType = info.type().asSubclass(Record.class);\n+                    var arrayComponentType = info.type();\n@@ -231,0 +237,6 @@\n+                    \/\/ Change the return type to Object so that we may use Array.set() below\n+                    var mapperCtor = componentMapper.ctor\n+                            .asType(MethodType.methodType(Object.class, MemorySegment.class));\n+\n+                    \/\/ Todo: Investigate the performance of the Function below\n+                    \/\/ Todo: Use the existing method further below for this.\n@@ -236,1 +248,7 @@\n-                                .map(componentMapper)\n+                                .map(s -> {\n+                                    try {\n+                                        return mapperCtor.invokeExact(s);\n+                                    } catch (Throwable t) {\n+                                        throw new IllegalArgumentException(t);\n+                                    }\n+                                })\n@@ -275,2 +293,2 @@\n-                    var mt = MethodType.methodType(Record.class.arrayType(),\n-                            MemorySegment.class, GroupLayout.class, long.class, long.class, LayoutRecordMapper.class);\n+                    var mt = MethodType.methodType(Object.class.arrayType(),\n+                            MemorySegment.class, GroupLayout.class, long.class, long.class, Class.class, MethodHandle.class);\n@@ -278,1 +296,5 @@\n-                    \/\/ (MemorySegment, GroupLayout, long offset, long count, Function) ->\n+                    var mapper = componentMapper.ctor.asType(MethodType.methodType(Object.class, MemorySegment.class));\n+                    \/\/ (MemorySegment, GroupLayout, long offset, long count, Class, MethodHandle) ->\n+                    \/\/ (MemorySegment, GroupLayout, long offset, long count, Class)\n+                    mh = MethodHandles.insertArguments(mh, 5, mapper);\n+                    \/\/ (MemorySegment, GroupLayout, long offset, long count, Class) ->\n@@ -280,1 +302,1 @@\n-                    mh = MethodHandles.insertArguments(mh, 4, componentMapper);\n+                    mh = MethodHandles.insertArguments(mh, 4, componentMapper.type);\n@@ -310,1 +332,1 @@\n-            return (T) (ctor.invoke(segment));\n+            return (T) ctor.invokeExact(segment);\n@@ -361,1 +383,1 @@\n-            switch (nameMappingCounts.get(name).intValue()) {\n+            switch (nameMappingCounts.getOrDefault(name, 0L).intValue()) {\n@@ -373,3 +395,3 @@\n-    private <R extends Record> LayoutRecordMapper<R> recordMapper(Class<R> componentType,\n-                                                                  GroupLayout gl,\n-                                                                  long byteOffset) {\n+    private <R> LayoutRecordMapper<R> recordMapper(Class<R> componentType,\n+                                                   GroupLayout gl,\n+                                                   long byteOffset) {\n@@ -377,4 +399,1 @@\n-        if (!componentType.isRecord()) {\n-            throw new IllegalArgumentException(componentType + \" is not a Record\");\n-        }\n-        return new LayoutRecordMapper<>(componentType, gl, byteOffset, lookup);\n+        return new LayoutRecordMapper<>(componentType, gl, byteOffset, depth + 1, lookup);\n@@ -467,5 +486,6 @@\n-    static <R extends Record> R[] toArray(MemorySegment segment,\n-                                          GroupLayout elementLayout,\n-                                          long offset,\n-                                          long count,\n-                                          LayoutRecordMapper<R> mapper) {\n+    static <R> R[] toArray(MemorySegment segment,\n+                           GroupLayout elementLayout,\n+                           long offset,\n+                           long count,\n+                           Class<?> type,\n+                           MethodHandle mapper) {\n@@ -475,2 +495,8 @@\n-                .map(mapper)\n-                .toArray(l -> (R[]) Array.newInstance(mapper.type, l));\n+                .map(s -> {\n+                    try {\n+                        return mapper.invokeExact(s);\n+                    } catch (Throwable t) {\n+                        throw new IllegalArgumentException(t);\n+                    }\n+                })\n+                .toArray(l -> (R[]) Array.newInstance(type, l));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutRecordMapper.java","additions":62,"deletions":36,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -146,0 +146,9 @@\n+    public record Unmatched(int foo){}\n+\n+    @Test\n+    public void noMapping() {\n+        assertThrows(IllegalArgumentException.class, () ->\n+                POINT_LAYOUT.recordMapper(Unmatched.class)\n+        );\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestRecordMapper.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}