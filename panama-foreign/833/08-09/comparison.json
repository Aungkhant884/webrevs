{"files":[{"patch":"@@ -87,2 +87,2 @@\n-     * Let <em>R<\/em> be the provided record {@code type} with the constituent components\n-     * <em>C<sub>0<\/sub><\/em>, ..., <em>C<sub>N-1<\/sub><\/em>, where <em>N<\/em> is non-negative.\n+     * Let {@code R} be the provided record {@code type} with the constituent components\n+     * {@code c_1}, {@code c_2}, ..., {@code c_N}, where <em>N<\/em> is the (non-negative) number of components.\n@@ -90,2 +90,2 @@\n-     * Let <em>L<\/em> be this group layout with the elements <em>E<sub>0<\/sub><\/em>, ..., <em>E<sub>M-1<\/sub><\/em>\n-     * , where <em>M<\/em> {@code >=} <em>N<\/em>.\n+     * Let {@code f_a(MemorySegment ms)} be a function that takes\n+     * a {@link MemorySegment} {@code ms} and produces a value for {@code c_a}.\n@@ -93,3 +93,10 @@\n-     * Then, for each <em>C<sub>a<\/sub><\/em> (<em>a<\/em> {@code <} <em>N<\/em>), there must be a corresponding distinct\n-     * <em>E<sub>b<\/sub><\/em> such that the {@link MemoryLayout#name() name} of <em>C<sub>a<\/sub><\/em>\n-     * {@link Object#equals(Object) equals} the {@link RecordComponent#getName() name} of the <em>E<sub>b<\/sub><\/em> and:\n+     * Let {@code L} be this group layout with the elements {@code e_1}, {@code e_2}, ..., {@code e_M}\n+     * , where {@code M >= N}.\n+     * <p>\n+     * Let {@code offsetBetween(GroupLayout rootLayout, MemoryLayout target)} be a pseudo function that, via\n+     * the method {@link MemoryLayout#byteOffset(PathElement...)}, can compute the offset from the initial root\n+     * layout (from which this method was first invoked) to a sub-layout of the root layout.\n+     * <p>\n+     * Then, for each {@code c_a} ({@code a <= N}, there must be a corresponding distinct\n+     * {@code e_b} such that the {@link MemoryLayout#name() name} of {@code c_a}\n+     * {@link Object#equals(Object) equals} the {@link RecordComponent#getName() name} of {@code e_b} and:\n@@ -98,3 +105,3 @@\n-     *        <h4>If <em>E<sub>b<\/sub><\/em> is a {@link ValueLayout };<\/h4>\n-     *        then <em>C<sub>a<\/sub><\/em> must be of the exact type of <em>E<sub>b<\/sub>'s<\/em> {@link ValueLayout#carrier() carrier()}<br>\n-     *        whereby C<sub>a<\/sub> = f<sub>a<\/sub>(MemorySegment ms) = ms.get(E<sub>b<\/sub>, offset) at the appropriate offset.<br>\n+     *        <h4>If {@code e_b} is a {@link ValueLayout };<\/h4>\n+     *        then {@code c_a} must be of the exact type of {@code e_b}'s {@link ValueLayout#carrier() carrier()}<br>\n+     *        whereby {@code c_a} = {@code f_a(MemorySegment ms) = ms.get({@code e_b}, offsetBetween(root, e_b))}.<br>\n@@ -103,7 +110,6 @@\n-     *        <h4>If <em>E<sub>b<\/sub><\/em> is a {@link GroupLayout };<\/h4>\n-     *        then <em>C<sub>a<\/sub><\/em> must be of another {@link Record} type <em>R2<\/em>\n-     *        (such that <em>R2<\/em> {@code !=} <em>R<\/em>) that can be mapped to <em>E<sub>b<\/sub><\/em> via\n-     *        a resulting mapper <em>M2<\/em> =\n-     *        {@link #recordMapper(Class) E<sub>b<\/sub>.recordMapper(C<sub>a<\/sub>.type())}<br>\n-     *        whereby <em>C<sub>a<\/sub><\/em> = f<sub>a<\/sub>(MemorySegment ms) = <em>M2<\/em>.apply(ms) recursively\n-     *        at the appropriate offset.<br>\n+     *        <h4>If {@code e_b} is a {@link GroupLayout };<\/h4>\n+     *        then {@code e_a} must be of another {@link Record} type {@code R2}\n+     *        (such that {@code R2 != R}) that can be mapped to {@code e_b} via\n+     *        a resulting mapper {@code M2} = {@link #recordMapper(Class) e_b.recordMapper(c_a.type())}<br>\n+     *        whereby {@code c_a} = {@code f_a(MemorySegment ms) =\n+     *        M2.apply(ms.asSlice(offsetBetween(root, e_b)))} recursively.<br>\n@@ -112,6 +118,6 @@\n-     *        <h4>If <em>E<sub>b<\/sub><\/em> is a {@link SequenceLayout };<\/h4>\n-     *        then <em>C<sub>a<\/sub><\/em> must be an array <em>C[]<sup>D<\/sup><\/em> (of depth <em>D<\/em>\n-     *        and with an array component type <em>C<\/em>) that can be mapped to <em>E<sub>b<\/sub><\/em> via a resulting\n-     *        \"array mapper\" <em>A2<\/em> obtained via recursively pealing off nested sequence layouts in <em>E<sub>b<\/sub><\/em>\n-     *        and then (after <em>D<\/em> pealing operations)\n-     *        finally determining the leaf element layout <em>LL<\/em> = {@link SequenceLayout#elementLayout() elementLayout()}\n+     *        <h4>If {@code e_b} is a {@link SequenceLayout };<\/h4>\n+     *        then {@code c_a} must be an array {@code C[]^D} (an array of depth {@code D}\n+     *        and with an array component type {@code C}) that can be mapped to {@code e_b} via a resulting\n+     *        \"array mapper\" {@code A2} obtained via recursively pealing off nested sequence layouts in {@code e_b}\n+     *        and then (after {@code D} pealing operations)\n+     *        finally determining the leaf element layout {@code LL = } {@link SequenceLayout#elementLayout() elementLayout()}\n@@ -121,2 +127,2 @@\n-     *            if <em>LL<\/em> is a {@link ValueLayout}:\n-     *            <em>LM<\/em> = {@link MemorySegment#get(ValueLayout.OfInt, long) ms -> ms.get(LL, offset)}\n+     *            if {@code LL} is a {@link ValueLayout}:\n+     *            {@code LM} = {@link MemorySegment#get(ValueLayout.OfInt, long) ms -> ms.get(LL, offset)}\n@@ -126,2 +132,2 @@\n-     *            if <em>LL<\/em> is a {@link GroupLayout}:\n-     *            <em>LM<\/em> = {@link #recordMapper(Class) LL.recordMapper(C.type())}\n+     *            if {@code LL} is a {@link GroupLayout}:\n+     *            {@code LM} = {@link #recordMapper(Class) LL.recordMapper(C.type())}\n@@ -130,2 +136,3 @@\n-     *        whereby <em>C<sub>a<\/sub><\/em> = f<sub>a<\/sub>(MemorySegment ms) will be extracted by\n-     *        applying {@code A2} which, in turn, will apply {@code LM} recursively at the appropriate offset(s).<br>\n+     *        whereby {@code c_a} = {@code f_a(MemorySegment ms)} will be extracted by\n+     *        applying {@code A2} which, in turn, will apply {@code LM} recursively at base offset\n+     *        offsetBetween(root, e_b) plus applicable multidimensional array offsets.<br>\n@@ -136,1 +143,1 @@\n-     *        <h4>If <em>E<sub>b<\/sub><\/em> is a {@link PaddingLayout };<\/h4>\n+     *        <h4>If {@code e_b} is a {@link PaddingLayout };<\/h4>\n@@ -142,2 +149,2 @@\n-     *        the method will throw an {@link IllegalArgumentException} as <em>E<sub>b<\/sub><\/em> cannot\n-     *        be projected onto <em>C<sub>a<\/sub><\/em>. An example of this is trying to match a record component\n+     *        the method will throw an {@link IllegalArgumentException} as {@code e_b} cannot\n+     *        be projected onto {@code c_a}.  An example of this is trying to match a record component\n@@ -149,1 +156,1 @@\n-     * canonical constructor using a composition of the above mapping functions:\n+     * canonical constructor {@code R::new} using a composition of the above mapping functions:\n@@ -151,1 +158,1 @@\n-     * <em>ms -> R(f<sub>0<\/sub>(ms), ..., f<sub>N-1<\/sub>(ms))<\/em>\n+     * <em>ms -> new R(f_1(ms), f_2(ms), ..., f_N(ms))<\/em>\n@@ -160,1 +167,1 @@\n-     * to extract a {@link Record}. An example of such a failure is if the applied memory segment is too\n+     * to extract a {@link Record}.  An example of such a failure is if the applied memory segment is too\n@@ -181,1 +188,1 @@\n-     * Boxing, widening and narrowing must be explicitly handled by user code. In the following example, the above\n+     * Boxing, widening and narrowing must be explicitly handled by user code.  In the following example, the above\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":43,"deletions":36,"binary":false,"changes":79,"status":"modified"}]}