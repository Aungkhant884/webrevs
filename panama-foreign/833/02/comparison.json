{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.reflect.RecordComponent;\n@@ -29,0 +30,2 @@\n+import java.util.function.Function;\n+\n@@ -76,0 +79,132 @@\n+\n+    \/**\n+     * {@return a {@link Function} that can project {@linkplain MemorySegment MemorySegments} onto new instances\n+     * of the provided {@link Record} {@code type} by means of matching the names of the\n+     * record components with the names of the elements in this group layout}\n+     * <p>\n+     * The mapping between the record type and this memory layout is defined as follows;\n+     * <p>\n+     * Let <em>R<\/em> be the provided record {@code type} with the constituent components\n+     * <em>C<sub>0<\/sub><\/em>, ..., <em>C<sub>N-1<\/sub><\/em>, where <em>N<\/em> is non-negative.\n+     * <p>\n+     * Let <em>L<\/em> be this group layout with the elements <em>E<sub>0<\/sub><\/em>, ..., <em>E<sub>M-1<\/sub><\/em>\n+     * , where <em>M<\/em> {@code >=} <em>N<\/em>.\n+     * <p>\n+     * Then, for each <em>C<sub>a<\/sub><\/em> (<em>a<\/em> {@code <} <em>N<\/em>), there must be a corresponding distinct\n+     * <em>E<sub>b<\/sub><\/em> such that the {@link MemoryLayout#name() name} of <em>C<sub>a<\/sub><\/em>\n+     * {@link Object#equals(Object) equals} the {@link RecordComponent#getName() name} of the <em>E<sub>b<\/sub><\/em> and:\n+     * <ul>\n+     *    <li>\n+     *        <h4>If <em>E<sub>b<\/sub><\/em> is a {@link ValueLayout };<\/h4>\n+     *        then <em>C<sub>a<\/sub><\/em> must be of the exact type of <em>E<sub>b<\/sub>'s<\/em> {@link ValueLayout#carrier() carrier()}<br>\n+     *        whereby C<sub>a<\/sub> = f<sub>a<\/sub>(MemorySegment ms) = ms.get(E<sub>b<\/sub>, offset) at the appropriate offset.<br>\n+     *    <\/li>\n+     *    <li>\n+     *        <h4>If <em>E<sub>b<\/sub><\/em> is a {@link GroupLayout };<\/h4>\n+     *        then <em>C<sub>a<\/sub><\/em> must be of another {@link Record} type <em>R2<\/em>\n+     *        (such that <em>R2<\/em> {@code !=} <em>R<\/em>) that can be mapped to <em>E<sub>b<\/sub><\/em> via\n+     *        a resulting mapper <em>M2<\/em> =\n+     *        {@link #recordMapper(Class) E<sub>b<\/sub>.recordMapper(C<sub>a<\/sub>.type())}<br>\n+     *        whereby <em>C<sub>a<\/sub><\/em> = f<sub>a<\/sub>(MemorySegment ms) = <em>M2<\/em>.apply(ms) recursively\n+     *        at the appropriate offset.<br>\n+     *    <\/li>\n+     *    <li>\n+     *        <h4>If <em>E<sub>b<\/sub><\/em> is a {@link SequenceLayout };<\/h4>\n+     *        then <em>C<sub>a<\/sub><\/em> must be an array <em>C[]<sup>D<\/sup><\/em> (of depth <em>D<\/em>\n+     *        and with an array component type <em>C<\/em>) that can be mapped to <em>E<sub>b<\/sub><\/em> via a resulting\n+     *        \"array mapper\" <em>A2<\/em> obtained via recursively pealing off nested sequence layouts in <em>E<sub>b<\/sub><\/em>\n+     *        and then (after <em>D<\/em> pealing operations)\n+     *        finally determining the leaf element layout <em>LL<\/em> = {@link SequenceLayout#elementLayout() elementLayout()}\n+     *        and subsequently obtaining a leaf record mapper:\n+     *        <ul>\n+     *            <li>\n+     *            if <em>LL<\/em> is a {@link ValueLayout}:\n+     *            <em>LM<\/em> = {@link MemorySegment#get(ValueLayout.OfInt, long) ms -> ms.get(LL, offset)}\n+     *            <\/li>\n+     *\n+     *            <li>\n+     *            if <em>LL<\/em> is a {@link GroupLayout}:\n+     *            <em>LM<\/em> = {@link #recordMapper(Class) LL.recordMapper(C.type())}\n+     *            <\/li>\n+     *        <\/ul>\n+     *        whereby <em>C<sub>a<\/sub><\/em> = f<sub>a<\/sub>(MemorySegment ms) will be extracted by\n+     *        applying {@code A2} which, in turn, will apply {@code LM} recursively at the appropriate offset(s).<br>\n+     *        Note: boolean arrays are not supported despite the above and if an attempt is made to map\n+     *        a boolean array, an {@link IllegalArgumentException} will be thrown.\n+     *    <\/li>\n+     *    <li>\n+     *        <h4>If <em>E<sub>b<\/sub><\/em> is a {@link PaddingLayout };<\/h4>\n+     *        then the method will throw an {@link IllegalArgumentException} as a padding layout cannot\n+     *        be projected to any record component.<br>\n+     *    <\/li>\n+     *    <li>\n+     *        <h4>Otherwise;<\/h4>\n+     *        the method will throw an {@link IllegalArgumentException} as <em>E<sub>b<\/sub><\/em> cannot\n+     *        be projected onto <em>C<sub>a<\/sub><\/em>. An example of this is trying to match a record component\n+     *        of type {@link String}.<br>\n+     *    <\/li>\n+     * <\/ul>\n+     * <p>\n+     * If the above is true, the returned mapper will, when invoked, subsequently invoke the record type's\n+     * canonical constructor using a composition of the above mapping functions:\n+     * <p>\n+     * <em>ms -> R(f<sub>0<\/sub>(ms), ..., f<sub>N-1<\/sub>(ms))<\/em>\n+     * <p>\n+     * Unnamed elements in this group will be ignored.\n+     * Unmatched elements (with respect to the name) in this group layout will be ignored.\n+     * <p>\n+     * The returned function will respect the byte orderings and alignment constraints of this\n+     * group layout.\n+     * <p>\n+     * The returned Function may throw an {@link IllegalArgumentException} if it, for any reason, fails\n+     * to extract a {@link Record}. An example of such a failure is if the applied memory segment is too\n+     * small for the layout at hand.\n+     * <p>\n+     * The example below shows how to extract an instance of a public {@code Point} record class\n+     * from a {@link MemorySegment}:\n+     * {@snippet lang = java:\n+     *     MemorySegment segment = MemorySegment.ofArray(new int[]{3, 4});\n+     *\n+     *     public record Point(int x, int y){}\n+     *\n+     *     var pointLayout = MemoryLayout.structLayout(\n+     *         JAVA_INT.withName(\"x\"),\n+     *         JAVA_INT.withName(\"y\")\n+     *     );\n+     *\n+     *     Function<MemorySegment, Point> pointExtractor = pointLayout.recordMapper(Point.class);\n+     *\n+     *     \/\/ Extracts a new Point from the provided MemorySegment\n+     *     Point point = pointExtractor.apply(segment); \/\/ Point[x=3, y=4]\n+     * }\n+     * <p>\n+     * Boxing, widening and narrowing must be explicitly handled by user code. In the following example, the above\n+     * {@code Point} (using primitive {@code int x} and {@code int y} coordinates) are explicitly mapped to\n+     * a narrowed point type (instead using primitive {@code byte x} and {@code byte y} coordinates):\n+     * <p>\n+     * {@snippet lang = java:\n+     *     public record NarrowedPoint(byte x, byte y) {\n+     *\n+     *         static NarrowedPoint fromPoint(Point p) {\n+     *             return new NarrowedPoint((byte) p.x, (byte) p.y);\n+     *         }\n+     *     }\n+     *\n+     *     Function<MemorySegment, NarrowedPoint> narrowedPointExtractor =\n+     *             pointLayout.recordMapper(Point.class)\n+     *                     .andThen(NarrowedPoint::fromPoint);\n+     *\n+     *     \/\/ Extracts a new NarrowedPoint from the provided MemorySegment\n+     *     NarrowedPoint narrowedPoint = narrowedPointExtractor.apply(segment); \/\/ NarrowedPoint[x=3, y=4]\n+     * }\n+     *\n+     * @param <R> record type\n+     * @param type the type (Class) of the record\n+     * @throws IllegalArgumentException if the provided record {@code type} is the class {@link Record} or contains\n+     *                                  components for which there are no exact mapping (of names and types) in\n+     *                                  this group layout or if the provided {@code type} is not public or\n+     *                                  if the method is otherwise unable to create a record mapper as specified above.\n+     * @since 21\n+     *\/\n+    <R extends Record> Function<MemorySegment, R> recordMapper(Class<R> type);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -166,0 +166,24 @@\n+ * <h2 id=\"record-mapping\">Record mapping<\/h2>\n+ * <p>A {@linkplain GroupLayout group layout} can provide mapping capabilities from memory segments to Java\n+ * {@linkplain Record Records} by means of matching named elements in the group layout with component names\n+ * in a record class.\n+ * For instance:\n+ *\n+ * {@snippet lang=java:\n+ *     MemorySegment segment = MemorySegment.ofArray(new int[]{3, 4});\n+ *\n+ *     public record Point(int x, int y){}\n+ *\n+ *     var pointLayout = MemoryLayout.structLayout(\n+ *         JAVA_INT.withName(\"x\"),\n+ *         JAVA_INT.withName(\"y\")\n+ *     );\n+ *\n+ *     Function<MemorySegment, Point> pointExtractor = pointLayout.recordMapper(Point.class);\n+ *\n+ *     \/\/ Extracts a new Point from the provided MemorySegment\n+ *     Point point = pointExtractor.apply(segment); \/\/ Point{x=3, y=4}\n+ * }\n+ *\n+ * The mapping capability provides an easy-to-use bridge from native memory to Java objects.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,641 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.util.ArraysSupport;\n+\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.PaddingLayout;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.RecordComponent;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static java.util.stream.Collectors.toMap;\n+\n+\/**\n+ * A record mapper that is matching a GroupLayout to match the components of a record.\n+ *\n+ * @param <T> the Record type\n+ *\/\n+public final class LayoutRecordMapper<T extends Record>\n+        implements Function<MemorySegment, T> {\n+\n+    enum Allow {EXACT, BOXING, BOXING_NARROWING_AND_WIDENING}\n+\n+    public static final Allow ALLOW = Allow.EXACT;\n+\n+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+    private static final MethodHandles.Lookup PUBLIC_LOOKUP = MethodHandles.publicLookup();\n+\n+    private final Class<T> type;\n+    private final GroupLayout layout;\n+    private final MethodHandle ctor;\n+\n+    public LayoutRecordMapper(Class<T> type,\n+                              GroupLayout layout) {\n+        this(type, layout, 0);\n+    }\n+\n+    private LayoutRecordMapper(Class<T> type,\n+                               GroupLayout layout,\n+                               long offset) {\n+        this.type = type;\n+        this.layout = layout;\n+\n+        var recordComponents = Arrays.asList(type.getRecordComponents());\n+        var recordComponentNames = recordComponents.stream()\n+                .map(RecordComponent::getName)\n+                .collect(Collectors.toSet());\n+\n+        var nameToLayoutMap = layout.memberLayouts().stream()\n+                \/\/ Only consider named layouts\n+                .filter(l -> l.name().isPresent())\n+                \/\/ Only look at the relevant layouts which could ever be matched with a record component\n+                .filter(l -> recordComponentNames.contains(l.name().orElseThrow()))\n+                .collect(toMap(l -> l.name().orElseThrow(), Function.identity(), throwingMerger()));\n+\n+        var missingComponents = recordComponents.stream()\n+                .map(RecordComponent::getName)\n+                .filter(l -> !nameToLayoutMap.containsKey(l))\n+                .toList();\n+\n+        if (!missingComponents.isEmpty()) {\n+            throw new IllegalArgumentException(\"There is no mapping for \" +\n+                    missingComponents + \" in \" + type.getName() +\n+                    \"(\" + String.join(\", \", recordComponents.stream().map(RecordComponent::getName).collect(Collectors.joining(\", \"))) + \")\" +\n+                    \" provided by the layout \" + layout);\n+        }\n+\n+        var componentAndLayoutList = recordComponents.stream()\n+                .map(c -> new ComponentAndLayout(c, nameToLayoutMap.get(c.getName())))\n+                .toList();\n+\n+        Class<?>[] ctorParameterTypes = recordComponents.stream()\n+                .map(RecordComponent::getType)\n+                .toArray(Class<?>[]::new);\n+\n+        \/\/ An array of the record component MethodHandle extractors, each of type (MemorySegment)X\n+        \/\/ where X is the component type.\n+        MethodHandle[] handles = componentAndLayoutList.stream()\n+                .map(cl -> {\n+                    var name = cl.layout().name().orElseThrow();\n+                    var pathElement = MemoryLayout.PathElement.groupElement(name);\n+                    long byteOffset = layout.byteOffset(pathElement) + offset;\n+\n+                    return switch (cl.layout()) {\n+                        case ValueLayout vl -> {\n+                            try {\n+                                assertTypesMatch(cl, type, vl, layout);\n+                                var mt = MethodType.methodType(vl.carrier(), valueLayoutType(vl), long.class);\n+                                var mh = PUBLIC_LOOKUP.findVirtual(MemorySegment.class, \"get\", mt);\n+                                \/\/ (MemorySegment, OfX, long) -> (MemorySegment, long)\n+                                mh = MethodHandles.insertArguments(mh, 1, vl);\n+                                \/\/ (MemorySegment, long) -> (MemorySegment)\n+                                yield castReturnType(MethodHandles.insertArguments(mh, 1, byteOffset), cl.component().getType());\n+                            } catch (NoSuchMethodException | IllegalAccessException e) {\n+                                throw new InternalError(e);\n+                            }\n+                        }\n+                        case GroupLayout gl -> {\n+                            @SuppressWarnings(\"unchecked\")\n+                            var componentType = (Class<? extends Record>) cl.component().getType();\n+                            var componentMapper = recordMapper(componentType, gl, byteOffset);\n+                            try {\n+                                var mt = MethodType.methodType(Record.class, MemorySegment.class);\n+                                var mh = LOOKUP.findVirtual(LayoutRecordMapper.class, \"apply\", mt);\n+                                \/\/ (LayoutRecordAccessor, MemorySegment)Record -> (MemorySegment)Record\n+                                mh = MethodHandles.insertArguments(mh, 0, componentMapper);\n+                                \/\/ (MemorySegment)Record -> (MemorySegment)componentType\n+                                yield MethodHandles.explicitCastArguments(mh, MethodType.methodType(componentType, MemorySegment.class));\n+                            } catch (NoSuchMethodException | IllegalAccessException e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                        }\n+                        case SequenceLayout sl -> {\n+                            try {\n+                                var componentType = cl.component().getType();\n+                                if (!componentType.isArray()) {\n+                                    throw new IllegalArgumentException(\"Unable to map '\" + sl +\n+                                            \"' because the component '\" + componentType.getName() + \" \" + name + \"' is not an array\");\n+                                }\n+\n+                                MultidimensionalSequenceLayoutInfo info = MultidimensionalSequenceLayoutInfo.of(sl);\n+\n+                                if (info.elementLayout() instanceof ValueLayout.OfBoolean) {\n+                                    throw new IllegalArgumentException(\"Arrays of booleans (\" + info.elementLayout() + \") are not supported\");\n+                                }\n+\n+                                if (dimensionOf(componentType) != info.sequences().size()) {\n+                                    throw new IllegalArgumentException(\"Unable to map '\" + sl + \"'\" +\n+                                            \" of dimension \" + info.sequences().size() +\n+                                            \" because the component '\" + componentType.getName() + \" \" + name + \"'\" +\n+                                            \" has a dimension of \" + dimensionOf(componentType));\n+                                }\n+\n+                                \/\/ Handle multi-dimensional arrays\n+                                if (info.sequences().size() > 1) {\n+                                    var mh = LOOKUP.findStatic(LayoutRecordMapper.class, \"toMultiArrayFunction\",\n+                                            MethodType.methodType(Object.class, MemorySegment.class, MultidimensionalSequenceLayoutInfo.class, long.class, Class.class, Function.class));\n+                                    \/\/ (MemorySegment, MultidimensionalSequenceLayoutInfo, long offset, Class leafType, Function mapper) ->\n+                                    \/\/ (MemorySegment, long offset, Class leafType, Function mapper)\n+                                    mh = MethodHandles.insertArguments(mh, 1, info);\n+                                    \/\/ (MemorySegment, long offset, Class leafType, Function mapper) ->\n+                                    \/\/ (MemorySegment, Class leafType, Function mapper)\n+                                    mh = MethodHandles.insertArguments(mh, 1, byteOffset);\n+\n+                                    switch (info.elementLayout()) {\n+                                        case ValueLayout vl -> {\n+                                            \/\/ (MemorySegment, Class leafType, Function mapper) ->\n+                                            \/\/ (MemorySegment, Function mapper)\n+                                            mh = MethodHandles.insertArguments(mh, 1, vl.carrier());\n+                                            Function<MemorySegment, Object> leafArrayMapper =\n+                                            switch (vl) {\n+                                                case ValueLayout.OfByte ofByte ->\n+                                                        ms -> ms.toArray(ofByte);\n+                                                case ValueLayout.OfBoolean ofBoolean ->\n+                                                        throw new UnsupportedOperationException(\"boolean arrays not supported: \" + ofBoolean);\n+                                                case ValueLayout.OfShort ofShort ->\n+                                                         ms -> ms.toArray(ofShort);\n+                                                case ValueLayout.OfChar ofChar ->\n+                                                        ms -> ms.toArray(ofChar);\n+                                                case ValueLayout.OfInt ofInt ->\n+                                                        ms -> ms.toArray(ofInt);\n+                                                case ValueLayout.OfLong ofLong ->\n+                                                        ms -> ms.toArray(ofLong);\n+                                                case ValueLayout.OfFloat ofFloat ->\n+                                                        ms -> ms.toArray(ofFloat);\n+                                                case ValueLayout.OfDouble ofDouble ->\n+                                                        ms -> ms.toArray(ofDouble);\n+                                                case AddressLayout addressLayout ->\n+                                                        ms -> ms.elements(addressLayout)\n+                                                                .map(s -> s.get(addressLayout, 0))\n+                                                                .toArray(MemorySegment[]::new);\n+                                            };\n+                                            \/\/ (MemorySegment, Function mapper) ->\n+                                            \/\/ (MemorySegment)\n+                                            mh = MethodHandles.insertArguments(mh, 1, leafArrayMapper);\n+                                            yield castReturnType(mh, cl.component().getType());\n+                                        }\n+                                        case GroupLayout gl -> {\n+                                            @SuppressWarnings(\"unchecked\")\n+                                            var arrayComponentType = (Class<? extends Record>) deepArrayComponentType(cl.component.getType());\n+                                            \/\/ The \"local\" byteOffset for the record component mapper is zero\n+                                            var componentMapper = recordMapper(arrayComponentType, gl, 0);\n+                                            Function<MemorySegment, Object> leafArrayMapper = ms -> {\n+                                                Object leafArray = Array.newInstance(arrayComponentType, info.lastDimension());\n+\n+                                                int[] i = new int[]{0};\n+                                                ms.elements(info.elementLayout())\n+                                                        .map(componentMapper)\n+                                                        .forEachOrdered(r -> Array.set(leafArray, i[0]++, r));\n+                                                return leafArray;\n+                                            };\n+\n+                                            \/\/ (MemorySegment, Class leafType, Function mapper) ->\n+                                            \/\/ (MemorySegment, Function mapper)\n+                                            mh = MethodHandles.insertArguments(mh, 1, arrayComponentType);\n+                                            \/\/ (MemorySegment, Function mapper) ->\n+                                            \/\/ (MemorySegment)\n+                                            mh = MethodHandles.insertArguments(mh, 1, leafArrayMapper);\n+                                            yield castReturnType(mh, cl.component().getType());\n+                                        }\n+                                        case SequenceLayout __ -> {\n+                                            throw new InternalError(\"Should not reach here\");\n+                                        }\n+                                        case PaddingLayout __ -> throw fail(cl);\n+                                    }\n+                                }\n+\n+                                \/\/ Faster single-dimensional arrays\n+                                switch (info.elementLayout()) {\n+                                    case ValueLayout vl -> {\n+                                        assertTypesMatch(cl, type, vl, layout);\n+                                        var mh = findStaticToArray(vl.carrier().arrayType(), valueLayoutType(vl), null);\n+                                        \/\/ (MemorySegment, OfX, long offset, long count) -> (MemorySegment, OfX, long offset)\n+                                        mh = MethodHandles.insertArguments(mh, 3, info.sequences().getFirst().elementCount());\n+                                        \/\/ (MemorySegment, OfX, long offset) -> (MemorySegment, long offset)\n+                                        mh = MethodHandles.insertArguments(mh, 1, vl);\n+                                        \/\/ (MemorySegment, long offset) -> (MemorySegment)\n+                                        yield castReturnType(MethodHandles.insertArguments(mh, 1, byteOffset), cl.component().getType());\n+                                    }\n+                                    case GroupLayout gl -> {\n+                                        @SuppressWarnings(\"unchecked\")\n+                                        var arrayComponentType = (Class<? extends Record>) deepArrayComponentType(cl.component().getType());\n+                                        \/\/ The \"local\" byteOffset for the record component mapper is zero\n+                                        var componentMapper = recordMapper(arrayComponentType, gl, 0);\n+                                        try {\n+                                            var mh = findStaticToArray(Record.class.arrayType(), GroupLayout.class, LayoutRecordMapper.class);\n+                                            \/\/ (MemorySegment, GroupLayout, long offset, long count, Function) ->\n+                                            \/\/ (MemorySegment, GroupLayout, long offset, long count)\n+                                            mh = MethodHandles.insertArguments(mh, 4, componentMapper);\n+                                            \/\/ (MemorySegment, GroupLayout, long offset, long count) ->\n+                                            \/\/ (MemorySegment, GroupLayout, long offset)\n+                                            mh = MethodHandles.insertArguments(mh, 3, info.sequences().getFirst().elementCount());\n+                                            \/\/ (MemorySegment, GroupLayout, long offset) ->\n+                                            \/\/ (MemorySegment, long offset)\n+                                            mh = MethodHandles.insertArguments(mh, 1, gl);\n+                                            \/\/ (MemorySegment, long offset) -> (MemorySegment)Record[]\n+                                            mh = MethodHandles.insertArguments(mh, 1, byteOffset);\n+                                            \/\/ (MemorySegment, long offset)Record[] -> (MemorySegment)componentType\n+                                            yield MethodHandles.explicitCastArguments(mh, MethodType.methodType(cl.component().getType(), MemorySegment.class));\n+                                        } catch (NoSuchMethodException | IllegalAccessException e) {\n+                                            throw new RuntimeException(e);\n+                                        }\n+                                    }\n+                                    case SequenceLayout __ -> {\n+                                        throw new InternalError(\"Should not reach here\");\n+                                    }\n+                                    case PaddingLayout __ -> throw fail(cl);\n+                                }\n+                            } catch (NoSuchMethodException | IllegalAccessException e) {\n+                                throw new InternalError(e);\n+                            }\n+                        }\n+                        case PaddingLayout __ -> throw fail(cl); \/\/ Ignore\n+                    };\n+                })\n+                .filter(Objects::nonNull) \/\/ Remove ignored items\n+                .toArray(MethodHandle[]::new);\n+\n+        try {\n+            var ctor = PUBLIC_LOOKUP.findConstructor(type, MethodType.methodType(void.class, ctorParameterTypes));\n+            for (int i = 0; i < handles.length; i++) {\n+                \/\/ Insert the respective handler for the constructor\n+                ctor = MethodHandles.filterArguments(ctor, i, handles[i]);\n+            }\n+\n+            var mt = MethodType.methodType(type, MemorySegment.class);\n+            \/\/ Fold the many identical MemorySegment arguments into a single argument\n+            ctor = MethodHandles.permuteArguments(ctor, mt, IntStream.range(0, handles.length)\n+                    .map(i -> 0)\n+                    .toArray());\n+\n+            \/\/ The constructor MethodHandle is now of type (MemorySegment)T\n+            this.ctor = ctor;\n+        } catch (IllegalAccessException | NoSuchMethodException e) {\n+            throw new IllegalArgumentException(\"There is no public constructor in '\" + type.getName() +\n+                    \"' for \" + Arrays.toString(ctorParameterTypes), e);\n+        }\n+    }\n+\n+    private static <U> BinaryOperator<U> throwingMerger() {\n+        return (a, b) -> {\n+            throw new IllegalArgumentException(\"Duplicate keys: \" + a);\n+        };\n+    }\n+\n+    private IllegalArgumentException fail(ComponentAndLayout cl) {\n+        throw new IllegalArgumentException(\n+                \"Unable to map \" + cl.layout() + \" to \" + type.getName() + \".\" + cl.component().getName());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public T apply(MemorySegment segment) {\n+        try {\n+            return (T) (ctor.invoke(segment));\n+        } catch (Throwable e) {\n+            throw new IllegalArgumentException(\n+                    \"Unable to invoke the canonical constructor for \" + type.getName() +\n+                            \" using \" + segment, e);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"LayoutRecordMapper{\" +\n+                \"type=\" + type.getName() + \", \" +\n+                \"layout=\" + layout + \"}\";\n+    }\n+\n+    \/\/ The parameter is of type ValueLayouts.OfByteImpl and the likes.\n+    static Class<? extends ValueLayout> valueLayoutType(ValueLayout vl) {\n+        return switch (vl) {\n+            case ValueLayout.OfBoolean __ -> ValueLayout.OfBoolean.class;\n+            case ValueLayout.OfByte __ -> ValueLayout.OfByte.class;\n+            case ValueLayout.OfShort __ -> ValueLayout.OfShort.class;\n+            case ValueLayout.OfChar __ -> ValueLayout.OfChar.class;\n+            case ValueLayout.OfInt __ -> ValueLayout.OfInt.class;\n+            case ValueLayout.OfLong __ -> ValueLayout.OfLong.class;\n+            case ValueLayout.OfFloat __ -> ValueLayout.OfFloat.class;\n+            case ValueLayout.OfDouble __ -> ValueLayout.OfDouble.class;\n+            case AddressLayout __ -> AddressLayout.class;\n+        };\n+    }\n+\n+    static MethodHandle findStaticToArray(Class<?> rType,\n+                                          Class<?> layoutType,\n+                                          Class<?> extra) throws NoSuchMethodException, IllegalAccessException {\n+\n+        var pTypes = Stream.of(MemorySegment.class, layoutType, long.class, long.class, extra)\n+                .filter(Objects::nonNull)\n+                .toArray(Class<?>[]::new);\n+\n+        var mt = MethodType.methodType(rType, pTypes);\n+        return LOOKUP.findStatic(LayoutRecordMapper.class, \"toArray\", mt);\n+    }\n+\n+    static void assertTypesMatch(ComponentAndLayout cl,\n+                                 Class<? extends Record> type,\n+                                 ValueLayout vl,\n+                                 MemoryLayout originalLayout) {\n+\n+        Class<?> recordComponentType = cl.component().getType();\n+        if (recordComponentType.isArray() && cl.layout() instanceof SequenceLayout) {\n+            recordComponentType = deepArrayComponentType(recordComponentType);\n+        }\n+\n+        boolean match = switch (ALLOW) {\n+            \/\/ Require types to be identical only: e.g. Integer.class != int.class\n+            case EXACT -> recordComponentType == vl.carrier();\n+            \/\/ Accept boxing: e.g. Integer.class.isInstance(int.class) -> true\n+            case BOXING -> recordComponentType.isInstance(vl.carrier());\n+            \/\/ Accept anything for now and signal errors later when composing VHs\n+            case BOXING_NARROWING_AND_WIDENING -> true;\n+        };\n+\n+        if (!match) {\n+            throw new IllegalArgumentException(\"Unable to match types because the component '\" +\n+                    cl.component().getName() + \"' (in \" + type.getName() + \") has the type of '\" + cl.component().getType() +\n+                    \"' but the layout type is '\" + vl.carrier() + \"' (in \" + originalLayout + \")\");\n+        }\n+    }\n+\n+    static Class<?> deepArrayComponentType(Class<?> arrayType) {\n+        Class<?> recordComponentType = arrayType;\n+        while (recordComponentType.isArray()) {\n+            recordComponentType = Objects.requireNonNull(recordComponentType.componentType());\n+        }\n+        return recordComponentType;\n+    }\n+\n+\n+    private <R extends Record> LayoutRecordMapper<R> recordMapper(Class<R> componentType,\n+                                                                  GroupLayout gl,\n+                                                                  long byteOffset) {\n+\n+        if (!componentType.isRecord()) {\n+            throw new IllegalArgumentException(componentType + \" is not a Record\");\n+        }\n+        return new LayoutRecordMapper<>(componentType, gl, byteOffset);\n+    }\n+\n+    record ComponentAndLayout(RecordComponent component,\n+                              MemoryLayout layout) {\n+    }\n+\n+    record MultidimensionalSequenceLayoutInfo(List<SequenceLayout> sequences,\n+                                              MemoryLayout elementLayout){\n+\n+        int[] dimensions() {\n+            return sequences().stream()\n+                    .mapToLong(SequenceLayout::elementCount)\n+                    .mapToInt(Math::toIntExact)\n+                    .toArray();\n+        }\n+\n+        int firstDimension() {\n+           return (int) sequences().getFirst().elementCount();\n+        }\n+\n+        int lastDimension() {\n+            return (int) sequences().getLast().elementCount();\n+        }\n+\n+        long layoutByteSize() {\n+            return sequences()\n+                    .getFirst()\n+                    .byteSize();\n+        }\n+\n+        MultidimensionalSequenceLayoutInfo removeFirst() {\n+            var removed = new ArrayList<>(sequences);\n+            removed.removeFirst();\n+            return new MultidimensionalSequenceLayoutInfo(removed, elementLayout);\n+        }\n+\n+        static MultidimensionalSequenceLayoutInfo of(SequenceLayout sequenceLayout) {\n+            MemoryLayout current = sequenceLayout;\n+            List<SequenceLayout> sequences = new ArrayList<>();\n+            while(true) {\n+                if (current instanceof SequenceLayout element) {\n+                    long count = element.elementCount();\n+                    if (count > ArraysSupport.SOFT_MAX_ARRAY_LENGTH) {\n+                        throw new IllegalArgumentException(\"Unable to accommodate '\" + element + \"' in an array.\");\n+                    }\n+                    current = element.elementLayout();\n+                    sequences.add(element);\n+                } else {\n+                    return new MultidimensionalSequenceLayoutInfo(List.copyOf(sequences), current);\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    \/\/ Provide widening and boxing magic\n+    static MethodHandle castReturnType(MethodHandle mh,\n+                                       Class<?> to) {\n+        var from = mh.type().returnType();\n+        if (from == to) {\n+            \/\/ We are done as it is\n+            return mh;\n+        }\n+\n+        if (!to.isPrimitive() && !isWrapperClass(to) && !to.isArray()) {\n+            throw new IllegalArgumentException(\"Cannot convert '\" + from + \"' to '\" + to.getName() +\n+                    \"' because '\" + to.getName() + \"' is not a wrapper class: [\" + WRAPPER_CLASSES.stream()\n+                    .map(Class::getSimpleName)\n+                    .collect(Collectors.joining(\", \"))+\"]\");\n+        }\n+\n+        return MethodHandles.explicitCastArguments(mh, MethodType.methodType(to, MemorySegment.class));\n+    }\n+\n+    private static final Set<Class<?>> WRAPPER_CLASSES = Stream.of(\n+            Byte.class, Boolean.class, Short.class, Character.class,\n+            Integer.class, Long.class, Float.class, Double.class\n+    ).collect(Collectors.collectingAndThen(\n+            Collectors.toCollection(LinkedHashSet::new),\n+            Collections::unmodifiableSet));\n+\n+    static boolean isWrapperClass(Class<?> type) {\n+        return WRAPPER_CLASSES.contains(type);\n+    }\n+\n+    static int dimensionOf(Class<?> arrayClass) {\n+        return (int) Stream.<Class<?>>iterate(arrayClass, Class::isArray, Class::componentType)\n+                .count();\n+    }\n+\n+    \/\/ Wrapper to create an array of Records\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <R extends Record> R[] toArray(MemorySegment segment,\n+                                          GroupLayout elementLayout,\n+                                          long offset,\n+                                          long count,\n+                                          LayoutRecordMapper<R> mapper) {\n+\n+        return slice(segment, elementLayout, offset, count)\n+                .elements(elementLayout)\n+                .map(mapper)\n+                .toArray(l -> (R[]) Array.newInstance(mapper.type, l));\n+    }\n+\n+    \/\/ Below are `MemorySegment::toArray` wrapper methods that is also taking an offset\n+    \/\/ Begin: Reflectively used methods\n+\n+    static byte[] toArray(MemorySegment segment,\n+                          ValueLayout.OfByte elementLayout,\n+                          long offset,\n+                          long count) {\n+\n+        return slice(segment, elementLayout, offset, count).toArray(elementLayout);\n+    }\n+\n+    static short[] toArray(MemorySegment segment,\n+                           ValueLayout.OfShort elementLayout,\n+                           long offset,\n+                           long count) {\n+\n+        return slice(segment, elementLayout, offset, count).toArray(elementLayout);\n+    }\n+\n+    static char[] toArray(MemorySegment segment,\n+                          ValueLayout.OfChar elementLayout,\n+                          long offset,\n+                          long count) {\n+\n+        return slice(segment, elementLayout, offset, count).toArray(elementLayout);\n+    }\n+\n+    static int[] toArray(MemorySegment segment,\n+                         ValueLayout.OfInt elementLayout,\n+                         long offset,\n+                         long count) {\n+\n+        return slice(segment, elementLayout, offset, count).toArray(elementLayout);\n+    }\n+\n+    static long[] toArray(MemorySegment segment,\n+                          ValueLayout.OfLong elementLayout,\n+                          long offset,\n+                          long count) {\n+\n+        return slice(segment, elementLayout, offset, count).toArray(elementLayout);\n+    }\n+\n+    static float[] toArray(MemorySegment segment,\n+                           ValueLayout.OfFloat elementLayout,\n+                           long offset,\n+                           long count) {\n+\n+        return slice(segment, elementLayout, offset, count).toArray(elementLayout);\n+    }\n+\n+    static double[] toArray(MemorySegment segment,\n+                            ValueLayout.OfDouble elementLayout,\n+                            long offset,\n+                            long count) {\n+\n+        return slice(segment, elementLayout, offset, count).toArray(elementLayout);\n+    }\n+\n+    static MemorySegment[] toArray(MemorySegment segment,\n+                                   AddressLayout elementLayout,\n+                                   long offset,\n+                                   long count) {\n+\n+        return slice(segment, elementLayout, offset, count)\n+                .elements(elementLayout)\n+                .map(s -> s.get(elementLayout, 0))\n+                .toArray(MemorySegment[]::new);\n+    }\n+\n+    \/\/ End: Reflectively used methods\n+\n+    private static MemorySegment slice(MemorySegment segment,\n+                                       MemoryLayout elementLayout,\n+                                       long offset,\n+                                       long count) {\n+\n+        return segment.asSlice(offset, elementLayout.byteSize() * count);\n+    }\n+\n+    static Object toMultiArrayFunction(MemorySegment segment,\n+                                       MultidimensionalSequenceLayoutInfo info,\n+                                       long offset,\n+                                       Class<?> leafType,\n+                                       Function<MemorySegment, Object> leafArrayConstructor) {\n+\n+        int[] dimensions = info.dimensions();\n+        \/\/ Create the array to return\n+        Object result = Array.newInstance(leafType, dimensions);\n+\n+        int firstDimension = info.firstDimension();\n+\n+        var infoFirstRemoved = info.removeFirst();\n+        int secondDimension = infoFirstRemoved.firstDimension();\n+        long chunkByteSize = infoFirstRemoved.layoutByteSize();\n+\n+        for (int i = 0; i < firstDimension; i++) {\n+            Object part;\n+            if (dimensions.length == 2) {\n+                \/\/ Trivial case: Just extract the array from the memory segment\n+                var slice = slice(segment, info.elementLayout(), offset + i * chunkByteSize, secondDimension);\n+                part = leafArrayConstructor.apply(slice);\n+            } else {\n+                \/\/ Recursively convert to arrays of (dimension - 1)\n+                var slice = segment.asSlice(i * chunkByteSize);\n+                part = toMultiArrayFunction(slice, infoFirstRemoved, offset, leafType, leafArrayConstructor);\n+            }\n+            Array.set(result, i, part);\n+        }\n+        return result;\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutRecordMapper.java","additions":641,"deletions":0,"binary":false,"changes":641,"status":"added"},{"patch":"@@ -112,1 +112,1 @@\n-            action.accept(state.indentSpaces() + paddingLayout.bitSize() + \" padding bits\");\n+            action.accept(state.indentSpaces() + paddingLayout.byteSize() + \" padding bytes\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemoryInspectionUtil.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import jdk.internal.foreign.LayoutRecordMapper;\n+\n+import java.lang.foreign.GroupLayout;\n@@ -29,0 +32,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -32,0 +36,1 @@\n+import java.util.function.Function;\n@@ -116,0 +121,8 @@\n+    public final <R extends Record> Function<MemorySegment, R> recordMapper(Class<R> recordType) {\n+        Objects.requireNonNull(recordType);\n+        if (Record.class.equals(recordType)) {\n+            throw new IllegalArgumentException(\"The common base class java.lang.Record is not a record in itself\");\n+        }\n+        return new LayoutRecordMapper<>(recordType, (GroupLayout) this);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractGroupLayout.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,992 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run junit\/othervm --enable-native-access=ALL-UNNAMED TestRecordMapper\n+ *\/\n+\n+import org.junit.jupiter.api.*;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public final class TestRecordMapper {\n+\n+    private static final boolean EXACT = true;\n+\n+    private static final GroupLayout POINT_LAYOUT = MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"x\"),\n+            JAVA_INT.withName(\"y\"));\n+\n+    private static final GroupLayout LINE_LAYOUT = MemoryLayout.structLayout(\n+            POINT_LAYOUT.withName(\"begin\"),\n+            POINT_LAYOUT.withName(\"end\"));\n+\n+    private static final MemorySegment POINT_SEGMENT = MemorySegment.ofArray(new int[]{\n+            3, 4,\n+            6, 0,\n+            0, 0});\n+\n+    \/\/ Records\n+\n+    public record Point(int x, int y) {\n+    }\n+\n+    public record FlippedPoint(int y, int x) {\n+    }\n+\n+    public record PointUnion(Point normal, FlippedPoint flipped) {\n+        static final GroupLayout LAYOUT = MemoryLayout.unionLayout(\n+                POINT_LAYOUT.withName(\"normal\"),\n+                POINT_LAYOUT.withName(\"flipped\")\n+        );\n+    }\n+\n+    public record PointUnionUnion(PointUnion left, PointUnion right) {\n+        static final GroupLayout LAYOUT = MemoryLayout.unionLayout(\n+                PointUnion.LAYOUT.withName(\"left\"),\n+                PointUnion.LAYOUT.withName(\"right\")\n+        );\n+    }\n+\n+\n+    public record LongPoint(long x, long y) {\n+    }\n+\n+    public record Line(Point begin, Point end) {\n+    }\n+\n+    \/\/ Manually declared function\n+\n+    static class PointMapper implements Function<MemorySegment, Point> {\n+\n+        @Override\n+        public Point apply(MemorySegment segment) {\n+            return new Point(segment.get(JAVA_INT, 0), segment.get(JAVA_INT, 4));\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testCustomPoint() {\n+        test(POINT_SEGMENT, new PointMapper(), new Point(3, 4));\n+    }\n+\n+    @Test\n+    public void testPointMapper() {\n+        test(POINT_SEGMENT, POINT_LAYOUT.recordMapper(Point.class), new Point(3, 4));\n+    }\n+\n+    @Test\n+    public void testPointMapperUnderflow() {\n+        assertThrows(IllegalArgumentException.class, () ->\n+                POINT_LAYOUT.recordMapper(Point.class)\n+                        .apply(MemorySegment.ofArray(new int[]{1})));\n+    }\n+\n+    public record StringPoint(String x, String y){}\n+\n+    @Test\n+    public void testLongPointTypeMismatch() {\n+        \/\/ This should fail as the types `int` and `String` cannot be mapped\n+        assertThrows(IllegalArgumentException.class, () -> {\n+                    POINT_LAYOUT.recordMapper(StringPoint.class);\n+                }\n+        );\n+    }\n+\n+    public record Empty() {}\n+\n+    @Test\n+    public void testEmptyRecord() {\n+        var mapper = POINT_LAYOUT.recordMapper(Empty.class);\n+        Empty empty = mapper.apply(POINT_SEGMENT);\n+        assertEquals(new Empty(), empty);\n+    }\n+\n+    @Test\n+    public void testFlippedPointMapper() {\n+        test(POINT_SEGMENT, POINT_LAYOUT.recordMapper(FlippedPoint.class), new FlippedPoint(4, 3));\n+    }\n+\n+    \/\/ Line\n+\n+    @Test\n+    public void testLineMapper() {\n+        test(POINT_SEGMENT, LINE_LAYOUT.recordMapper(Line.class), new Line(new Point(3, 4), new Point(6, 0)));\n+    }\n+\n+    \/\/ Union\n+    @Test\n+    public void testUnion() {\n+        test(POINT_SEGMENT, PointUnion.LAYOUT.recordMapper(PointUnion.class),\n+                new PointUnion(\n+                        new Point(3, 4),\n+                        new FlippedPoint(4, 3))\n+        );\n+    }\n+\n+    \/\/ Union of Union\n+    @Test\n+    public void testUnionUnion() {\n+        test(POINT_SEGMENT, PointUnionUnion.LAYOUT.recordMapper(PointUnionUnion.class),\n+                new PointUnionUnion(\n+                        new PointUnion(\n+                                new Point(3, 4),\n+                                new FlippedPoint(4, 3)),\n+                        new PointUnion(\n+                                new Point(3, 4),\n+                                new FlippedPoint(4, 3))\n+                ));\n+    }\n+\n+    \/\/ Test Padding\n+    @Test\n+    public void testPadding() {\n+        GroupLayout paddedPointLayout = MemoryLayout.structLayout(\n+                MemoryLayout.paddingLayout(Integer.BYTES * 2).withName(\"padding\"),\n+                JAVA_INT.withName(\"x\"),\n+                JAVA_INT.withName(\"y\"));\n+        test(POINT_SEGMENT, paddedPointLayout.recordMapper(Point.class), new Point(6, 0));\n+    }\n+\n+    @Test\n+    public void testStream() {\n+\n+        List<Point> points = POINT_SEGMENT.elements(POINT_LAYOUT)\n+                .map(POINT_LAYOUT.recordMapper(Point.class))\n+                .toList();\n+\n+        assertEquals(List.of(new Point(3, 4), new Point(6, 0), new Point(0, 0)), points);\n+    }\n+\n+\n+    \/\/ A lot of types\n+\n+    public record Types(byte by, boolean bo, short sh, char ch, int in, long lo, float fl, double dl) {\n+    }\n+\n+    @Test\n+    public void testTypes() {\n+\n+        \/\/ Test wrappers Integer etc.\n+\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_BYTE.withName(\"by\"),\n+                JAVA_BOOLEAN.withName(\"bo\"),\n+                JAVA_SHORT.withName(\"sh\"),\n+                JAVA_CHAR.withName(\"ch\"),\n+                JAVA_INT_UNALIGNED.withName(\"in\"),\n+                JAVA_LONG_UNALIGNED.withName(\"lo\"),\n+                JAVA_FLOAT_UNALIGNED.withName(\"fl\"),\n+                JAVA_DOUBLE_UNALIGNED.withName(\"dl\")\n+        );\n+\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(layout);\n+\n+            layout.varHandle(PathElement.groupElement(\"by\")).set(segment, (byte) 1);\n+            layout.varHandle(PathElement.groupElement(\"bo\")).set(segment, true);\n+            layout.varHandle(PathElement.groupElement(\"sh\")).set(segment, (short) 1);\n+            layout.varHandle(PathElement.groupElement(\"ch\")).set(segment, 'a');\n+            layout.varHandle(PathElement.groupElement(\"in\")).set(segment, 1);\n+            layout.varHandle(PathElement.groupElement(\"lo\")).set(segment, 1L);\n+            layout.varHandle(PathElement.groupElement(\"fl\")).set(segment, 1f);\n+            layout.varHandle(PathElement.groupElement(\"dl\")).set(segment, 1d);\n+\n+            var mapper = layout.recordMapper(Types.class);\n+            Types types = mapper.apply(segment);\n+            assertEquals(new Types(\n+                    (byte) 1,\n+                    true,\n+                    (short) 1,\n+                    'a',\n+                    1,\n+                    1L,\n+                    1.0f,\n+                    1.0d\n+            ), types);\n+        }\n+    }\n+\n+    \/\/ Float80, From https:\/\/github.com\/graalvm\/sulong\/blob\/db830610d6ffbdab9678eef359a9f915e6ad2ee8\/projects\/com.oracle.truffle.llvm.types\/src\/com\/oracle\/truffle\/llvm\/types\/floating\/LLVM80BitFloat.java\n+\n+    public record Float80(short exponent, long fraction){}\n+\n+    @Test\n+    public void testFloat80() {\n+\n+        short exponent = (short) 3;\n+        long fraction = 23423423L;\n+\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_SHORT.withName(\"exponent\"),\n+                JAVA_LONG_UNALIGNED.withName(\"fraction\")\n+        );\n+\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(layout);\n+\n+            layout.varHandle(PathElement.groupElement(\"exponent\")).set(segment, exponent);\n+            layout.varHandle(PathElement.groupElement(\"fraction\")).set(segment, fraction);\n+\n+            var mapper = layout.recordMapper(Float80.class);\n+            Float80 float80 = mapper.apply(segment);\n+            assertEquals(new Float80(exponent, fraction), float80);\n+        }\n+    }\n+\n+    @Test\n+    public void testToString() {\n+        var toString = POINT_LAYOUT.recordMapper(Point.class).toString();\n+        assertTrue(toString.contains(\"type=\" + Point.class.getName()));\n+        assertTrue(toString.contains(\"layout=\" + POINT_LAYOUT));\n+    }\n+\n+    public record BytePoint(byte x, byte y) {}\n+    @Test\n+    public void testByte() {\n+        testPointType(new BytePoint((byte)3, (byte)4), new byte[]{3, 4}, JAVA_BYTE);\n+    }\n+\n+    public record BooleanPoint(boolean x, boolean y) {}\n+    @Test\n+    public void testBoolean() {\n+        testPointType(new BooleanPoint(false, true), new byte[]{0, 1}, JAVA_BOOLEAN);\n+    }\n+\n+    public record ShortPoint(short x, short y) {}\n+    @Test\n+    public void testShort() {\n+        testPointType(new ShortPoint((short)3, (short)4), new short[]{3, 4}, JAVA_SHORT);\n+    }\n+\n+    public record CharPoint(char x, char y) {}\n+    @Test\n+    public void testChar() {\n+        testPointType(new CharPoint('d', 'e'), new char[]{'d', 'e'}, JAVA_CHAR);\n+    }\n+\n+    public record IntPoint(int x, int y) {}\n+    @Test\n+    public void testInt() {\n+        testPointType(new IntPoint(3, 4), new int[]{3, 4}, JAVA_INT);\n+    }\n+\n+    @Test\n+    public void testLong() {\n+        testPointType(new LongPoint(3L, 4L), new long[]{3L, 4L}, JAVA_LONG);\n+    }\n+\n+    public record FloatPoint(float x, float y) {}\n+    @Test\n+    public void testFloat() {\n+        testPointType(new FloatPoint(3.0f, 4.0f), new float[]{3.0f, 4.0f}, JAVA_FLOAT);\n+    }\n+\n+    public record DoublePoint(double x, double y){}\n+    @Test\n+    public void testDouble() {\n+        testPointType(new DoublePoint(3.0d, 4.0d), new double[]{3.0d, 4.0d}, JAVA_DOUBLE);\n+    }\n+\n+\n+    public record SequenceBox(int before, int[] ints, int after) {\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof SequenceBox other &&\n+                    before == other.before &&\n+                    Arrays.equals(ints, other.ints) &&\n+                    after == other.after;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"SequenceBox[before=\" + before +\n+                    \", ints=\" + Arrays.toString(ints) +\n+                    \", after=\" + after + \"]\";\n+        }\n+    }\n+\n+    @Test\n+    public void testSequenceBox() {\n+\n+        var segment = MemorySegment.ofArray(IntStream.rangeClosed(0, 3).toArray());\n+\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"before\"),\n+                MemoryLayout.sequenceLayout(2, JAVA_INT).withName(\"ints\"),\n+                JAVA_INT.withName(\"after\")\n+        );\n+\n+        var mapper = layout.recordMapper(SequenceBox.class);\n+\n+        SequenceBox sequenceBox = mapper.apply(segment);\n+\n+        assertEquals(new SequenceBox(0, new int[]{1, 2}, 3), sequenceBox);\n+    }\n+\n+    public record SequenceBox2(int before, int[][] ints, int after) {\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof SequenceBox2 other &&\n+                    before == other.before &&\n+                    Arrays.deepEquals(ints, other.ints) &&\n+                    after == other.after;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"SequenceBox2[before=\" + before +\n+                    \", ints=\" + Arrays.deepToString(ints) +\n+                    \", after=\" + after + \"]\";\n+        }\n+    }\n+\n+    @Test\n+    public void testSequenceBox2WrongDimension() {\n+\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"before\"),\n+                MemoryLayout.sequenceLayout(2,\n+                                MemoryLayout.sequenceLayout(2, JAVA_INT).withName(\"whatever\"))\n+                        .withName(\"ints\"),\n+                JAVA_INT.withName(\"after\")\n+        );\n+\n+        assertThrows(IllegalArgumentException.class, () ->\n+                \/\/ SequenceBox.ints is of dimension 1 whereas the layout is of dimension 2\n+            layout.recordMapper(SequenceBox.class)\n+        );\n+    }\n+\n+    @Test\n+    public void testSequenceBox2() {\n+\n+        var segment = MemorySegment.ofArray(IntStream.rangeClosed(0, 7).toArray());\n+\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"before\"),\n+                MemoryLayout.sequenceLayout(2,\n+                                MemoryLayout.sequenceLayout(3, JAVA_INT).withName(\"whatever\"))\n+                        .withName(\"ints\"),\n+                JAVA_INT.withName(\"after\")\n+        );\n+\n+        var mapper = layout.recordMapper(SequenceBox2.class);\n+\n+        SequenceBox2 sequenceBox2 = mapper.apply(segment);\n+\n+        assertEquals(new SequenceBox2(0, new int[][]{{1, 2, 3}, {4, 5, 6}}, 7), sequenceBox2);\n+    }\n+\n+    public record SequenceBox3(int before, int[][][] ints, int after) {\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof SequenceBox3 other &&\n+                    before == other.before &&\n+                    Arrays.deepEquals(ints, other.ints) &&\n+                    after == other.after;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"SequenceBox3[before=\" + before +\n+                    \", ints=\" + Arrays.deepToString(ints) +\n+                    \", after=\" + after + \"]\";\n+        }\n+    }\n+\n+    @Test\n+    public void testSequenceBox3() {\n+\n+        var segment = MemorySegment.ofArray(IntStream.rangeClosed(0, 2 + (2 * 3 * 4)).toArray());\n+\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"before\"),\n+                MemoryLayout.sequenceLayout(2,\n+                                MemoryLayout.sequenceLayout(3,\n+                                        MemoryLayout.sequenceLayout(4, JAVA_INT).withName(\"whatever2\")\n+                                ).withName(\"whatever\")\n+                        )\n+                        .withName(\"ints\"),\n+                JAVA_INT.withName(\"after\")\n+        );\n+\n+        var mapper = layout.recordMapper(SequenceBox3.class);\n+\n+        SequenceBox3 sequenceBox3 = mapper.apply(segment);\n+\n+        assertEquals(new SequenceBox3(0, new int[][][]{\n+                {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}},\n+                {{13, 14, 15, 16}, {17, 18, 19, 20}, {21, 22, 23, 24}}\n+        }, 25), sequenceBox3);\n+    }\n+\n+    public record LongSequenceBox3(long before, long[][][] longs, long after) {\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof LongSequenceBox3 other &&\n+                    before == other.before &&\n+                    Arrays.deepEquals(longs, other.longs) &&\n+                    after == other.after;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"LongSequenceBox3[before=\" + before +\n+                    \", longs=\" + Arrays.deepToString(longs) +\n+                    \", after=\" + after+ \"]\";\n+        }\n+    }\n+\n+    @Test\n+    public void testLongSequenceBox3() {\n+\n+        var segment = MemorySegment.ofArray(LongStream.rangeClosed(0, 2 + (2 * 3 * 4)).toArray());\n+\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_LONG.withName(\"before\"),\n+                MemoryLayout.sequenceLayout(2,\n+                                MemoryLayout.sequenceLayout(3,\n+                                        MemoryLayout.sequenceLayout(4, JAVA_LONG).withName(\"whatever2\")\n+                                ).withName(\"whatever\")\n+                        )\n+                        .withName(\"longs\"),\n+                JAVA_LONG.withName(\"after\")\n+        );\n+\n+        var mapper = layout.recordMapper(LongSequenceBox3.class);\n+\n+        LongSequenceBox3 sequenceBox3 = mapper.apply(segment);\n+\n+        assertEquals(new LongSequenceBox3(0, new long[][][]{\n+                {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}},\n+                {{13, 14, 15, 16}, {17, 18, 19, 20}, {21, 22, 23, 24}}\n+        }, 25), sequenceBox3);\n+    }\n+\n+    public record PureArray(int[] ints) {\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof PureArray other &&\n+                    Arrays.equals(ints, other.ints);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"PureArray[ints=\" + Arrays.toString(ints) + \"]\";\n+        }\n+    }\n+\n+    @Test\n+    public void testPureArray() {\n+        GroupLayout layout =\n+                MemoryLayout.structLayout(\n+                        MemoryLayout.sequenceLayout(8, JAVA_INT)\n+                                .withName(\"ints\"));\n+\n+        var segment = MemorySegment.ofArray(IntStream.range(0, 8).toArray());\n+\n+        var mapper = layout.recordMapper(PureArray.class);\n+\n+        PureArray pureArray = mapper.apply(segment);\n+\n+        assertEquals(new PureArray(new int[]{0, 1, 2, 3, 4, 5, 6, 7}), pureArray);\n+    }\n+\n+    public record SequenceOfPoints(int before, Point[] points, int after) {\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof SequenceOfPoints other &&\n+                    before == other.before &&\n+                    Arrays.equals(points, other.points) &&\n+                    after == other.after;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"SequenceOfPoints[before=\" + before +\n+                    \", points=\" + Arrays.toString(points) +\n+                    \", after=\" + after + \"]\";\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testSequenceOfPoints() {\n+\n+        var segment = MemorySegment.ofArray(IntStream.rangeClosed(0, 5).toArray());\n+\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"before\"),\n+                MemoryLayout.sequenceLayout(2, POINT_LAYOUT).withName(\"points\"),\n+                JAVA_INT.withName(\"after\")\n+        );\n+\n+        var mapper = layout.recordMapper(SequenceOfPoints.class);\n+\n+        SequenceOfPoints sequenceOfPoints = mapper.apply(segment);\n+\n+        assertEquals(new SequenceOfPoints(0, new Point[]{new Point(1, 2), new Point(3,4)}, 5), sequenceOfPoints);\n+\n+    }\n+\n+    public record MultiSequenceOfPoints(int before, Point[][] points, int after) {\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof MultiSequenceOfPoints other &&\n+                    before == other.before &&\n+                    Arrays.deepEquals(points, other.points) &&\n+                    after == other.after;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"MultiSequenceOfPoints[before=\" + before +\n+                    \", points=\" + Arrays.deepToString(points) +\n+                    \", after=\" + after + \"]\";\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testMultiSequenceOfPoints() {\n+\n+        var segment = MemorySegment.ofArray(IntStream.rangeClosed(0, 13).toArray());\n+\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"before\"),\n+                MemoryLayout.sequenceLayout(2,\n+                                MemoryLayout.sequenceLayout(3, POINT_LAYOUT))\n+                        .withName(\"points\"),\n+                JAVA_INT.withName(\"after\")\n+        );\n+\n+        var mapper = layout.recordMapper(MultiSequenceOfPoints.class);\n+\n+        MultiSequenceOfPoints actual = mapper.apply(segment);\n+\n+        var expected = new MultiSequenceOfPoints(0,\n+                new Point[][]{\n+                        {new Point(1, 2), new Point(3, 4), new Point(5, 6)},\n+                        {new Point(7, 8), new Point(9, 10), new Point(11, 12)}},\n+                13);\n+\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void streaming() {\n+        var segment = MemorySegment.ofArray(new int[]{-1, 2, 3, 4, 5, -2});\n+        var s2 = segment.asSlice(4, 16);\n+        var mapper = POINT_LAYOUT.recordMapper(Point.class);\n+\n+        var list = s2.elements(POINT_LAYOUT)\n+                .map(mapper)\n+                .toList();\n+\n+        assertEquals(List.of(new Point(2, 3), new Point(4, 5)), list);\n+    }\n+\n+    @Test\n+    public void testPointSequence() {\n+\n+        var segment = MemorySegment.ofArray(new int[]{-1, 2, 3, 4, 5, -2});\n+\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"before\"),\n+                MemoryLayout.sequenceLayout(2, POINT_LAYOUT).withName(\"points\"),\n+                JAVA_INT.withName(\"after\")\n+        );\n+\n+        var mapper = layout.recordMapper(SequenceOfPoints.class);\n+\n+        SequenceOfPoints sequenceOfPoints = mapper.apply(segment);\n+\n+        assertEquals(new SequenceOfPoints(-1, new Point[]{new Point(2, 3), new Point(4, 5)}, -2), sequenceOfPoints);\n+    }\n+\n+    private record Foo(int x){}\n+    @Test\n+    public void testConstructorAccessibility() {\n+        assertThrows(IllegalArgumentException.class, () ->\n+                POINT_LAYOUT.recordMapper(Foo.class)\n+        );\n+    }\n+\n+    @Test\n+    public void testMhComposition() throws Throwable {\n+        var lookup = MethodHandles.lookup();\n+        var ctor = lookup.findConstructor(Point.class, MethodType.methodType(void.class, int.class, int.class));\n+\n+        var extractorType = MethodType.methodType(int.class, ValueLayout.OfInt.class, long.class);\n+\n+        var xVh = lookup.findVirtual(MemorySegment.class, \"get\", extractorType);\n+        \/\/ (MemorySegment, OfInt, long) -> (MemorySegment, long)\n+        var xVh2 = MethodHandles.insertArguments(xVh, 1, JAVA_INT);\n+        \/\/ (MemorySegment, long) -> (MemorySegment)\n+        var xVh3 = MethodHandles.insertArguments(xVh2, 1, 0L);\n+\n+        var yVh = lookup.findVirtual(MemorySegment.class, \"get\", extractorType);\n+        \/\/ (MemorySegment, OfInt, long) -> (MemorySegment, long)\n+        var yVh2 = MethodHandles.insertArguments(yVh, 1, JAVA_INT);\n+        \/\/ (MemorySegment, long) -> (MemorySegment)\n+        var yVh3 = MethodHandles.insertArguments(yVh2, 1, 4L);\n+\n+        assertEquals(3, (int) xVh3.invokeExact(POINT_SEGMENT));\n+        assertEquals(4, (int) yVh3.invokeExact(POINT_SEGMENT));\n+\n+        var expected = new Point(3, 4);\n+\n+        var p = ctor.invokeWithArguments((int) xVh3.invokeExact(POINT_SEGMENT), (int) yVh3.invokeExact(POINT_SEGMENT));\n+        assertEquals(expected, p);\n+\n+        var ctorFilter = MethodHandles.filterArguments(ctor, 0, xVh3);\n+        var ctorFilter2 = MethodHandles.filterArguments(ctorFilter, 1, yVh3);\n+\n+        var pf = (Point) ctorFilter2.invokeExact(POINT_SEGMENT, POINT_SEGMENT);\n+        assertEquals(expected, pf);\n+\n+        var mt = MethodType.methodType(Point.class, MemorySegment.class);\n+        var mh = MethodHandles.permuteArguments(ctorFilter2, mt, 0, 0);\n+\n+        \/\/ Finally, we have a MethodHandle MemorySegment -> Point\n+        Point point = (Point) mh.invokeExact(POINT_SEGMENT);\n+        assertEquals(expected, point);\n+    }\n+\n+\n+    public record BoxedPoint(Integer x, Integer y) {}\n+\n+    @Test\n+    public void testIntegerBoxing() {\n+        if (EXACT) return;\n+        var mapper = POINT_LAYOUT.recordMapper(BoxedPoint.class);\n+        var boxedPoint = mapper.apply(POINT_SEGMENT);\n+        assertEquals(new BoxedPoint(3, 4), boxedPoint);\n+    }\n+\n+    public record WidenedPoint(long x, long y) {}\n+\n+    @Test\n+    public void testWidening() {\n+        if (EXACT) return;\n+        var mapper = POINT_LAYOUT.recordMapper(WidenedPoint.class);\n+        var widenedPoint = mapper.apply(POINT_SEGMENT);\n+        assertEquals(new WidenedPoint(3, 4L), widenedPoint);\n+    }\n+\n+    public record NarrowedPoint(byte x, byte y) {}\n+\n+    @Test\n+    public void testNarrowingExplicit() {\n+\n+        Function<MemorySegment, NarrowedPoint> narrowingMapper =\n+                POINT_LAYOUT.recordMapper(Point.class)\n+                        .andThen(p -> new NarrowedPoint((byte) p.x, (byte) p.y));\n+\n+        NarrowedPoint narrowedPoint = narrowingMapper.apply(POINT_SEGMENT);\n+        assertEquals(new NarrowedPoint((byte) 3, (byte) 4), narrowedPoint);\n+    }\n+\n+    @Test\n+    public void testNarrowing() {\n+        if (EXACT) return;\n+        var mapper = POINT_LAYOUT.recordMapper(NarrowedPoint.class);\n+        var narrowedPoint = mapper.apply(POINT_SEGMENT);\n+        assertEquals(new NarrowedPoint((byte) 3, (byte) 4), narrowedPoint);\n+    }\n+\n+    @Test\n+    public void inspectPoint() {\n+        String view = POINT_LAYOUT\n+                .recordMapper(Point.class)\n+                .apply(POINT_SEGMENT)\n+                .toString();\n+\n+        assertEquals(\"Point[x=3, y=4]\", view);\n+    }\n+\n+    @Test\n+    public void inspectMemory() {\n+        try (var arena = Arena.ofConfined()) {\n+            MemorySegment memorySegment = arena.allocate(64 + 4);\n+            memorySegment.setUtf8String(0, \"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\");\n+            HexFormat format = HexFormat.ofDelimiter(\" \").withUpperCase();\n+            String hex = format.formatHex(memorySegment.toArray(JAVA_BYTE));\n+\n+            String expected = \"54 68 65 20 71 75 69 63 6B 20 62 72 6F 77 6E 20 66 6F 78 20 6A 75 6D 70 65 64 20 6F 76 65 72 20 74 68 65 20 6C 61 7A 79 20 64 6F 67 0A 53 65 63 6F 6E 64 20 6C 69 6E 65 09 3A 68 65 72 65 00 00 00 00 00 00\";\n+            assertEquals(expected, hex);\n+        }\n+    }\n+\n+    @Test\n+    public void recordClassItself() {\n+        assertThrows(IllegalArgumentException.class, () ->\n+                POINT_LAYOUT.recordMapper(Record.class)\n+        );\n+    }\n+\n+    public record LinkedNode(MemorySegment next, int value){\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof LinkedNode(var next, var value) &&\n+                    this.next == next &&\n+                    this.value == value;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(next, value);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void linkedNode() {\n+\n+        var rawLayout = MemoryLayout.structLayout(ADDRESS, JAVA_INT);\n+\n+        var layout = MemoryLayout.structLayout(\n+                ADDRESS.withName(\"next\").withTargetLayout(rawLayout),\n+                JAVA_INT.withName(\"value\")\n+        );\n+\n+        VarHandle next = layout.varHandle(PathElement.groupElement(\"next\"));\n+        VarHandle value = layout.varHandle(PathElement.groupElement(\"value\"));\n+\n+        MemorySegment first;\n+        MemorySegment second;\n+        try (var arena = Arena.ofConfined()) {\n+            first = arena.allocate(layout);\n+            value.set(first, 41);\n+            second = arena.allocate(layout);\n+            value.set(second, 42);\n+            next.set(first, second);\n+\n+            var mapper = layout.recordMapper(LinkedNode.class);\n+\n+            LinkedNode actualFirst = mapper.apply(first);\n+            assertEquals(41, actualFirst.value());\n+            assertEquals(second, actualFirst.next());\n+\n+            LinkedNode actualSecond = mapper.apply(actualFirst.next());\n+            assertEquals(42, actualSecond.value());\n+            assertEquals(MemorySegment.NULL, actualSecond.next());\n+        }\n+\n+    }\n+\n+    public record TreeNode(MemorySegment[] children, int value){\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof TreeNode(var children, var value) &&\n+                    Arrays.equals(this.children, children) &&\n+                    this.value == value;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Arrays.hashCode(children) + value;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"TreeNode[children=\" + Arrays.toString(children) + \", value=\" + value + \"]\";\n+        }\n+    }\n+\n+    @Test\n+    public void TreeNode() {\n+\n+        var rawLayout = MemoryLayout.structLayout(\n+                MemoryLayout.sequenceLayout(3, ADDRESS),\n+                JAVA_INT\n+        );\n+\n+        var layout = MemoryLayout.structLayout(\n+                MemoryLayout.sequenceLayout(\n+                        3,\n+                        ADDRESS.withTargetLayout(rawLayout)\n+                ).withName(\"children\"),\n+                JAVA_INT.withName(\"value\")\n+        );\n+\n+        VarHandle child = layout.varHandle(PathElement.groupElement(\"children\"), PathElement.sequenceElement());\n+        VarHandle value = layout.varHandle(PathElement.groupElement(\"value\"));\n+\n+        MemorySegment root;\n+        MemorySegment firstChild;\n+        MemorySegment secondChild;\n+        try (var arena = Arena.ofConfined()) {\n+            root = arena.allocate(layout);\n+            value.set(root, 100);\n+            firstChild = arena.allocate(layout);\n+            value.set(firstChild, 41);\n+            secondChild = arena.allocate(layout);\n+            value.set(secondChild, 42);\n+            child.set(root, 0, firstChild);\n+            child.set(root, 1, secondChild);\n+\n+            var mapper = layout.recordMapper(TreeNode.class);\n+\n+            TreeNode actualRoot = mapper.apply(root);\n+            assertEquals(100, actualRoot.value());\n+\n+            TreeNode actualFirstChild = mapper.apply(actualRoot.children()[0]);\n+            TreeNode actualSecondChild = mapper.apply(actualRoot.children()[1]);\n+\n+            assertEquals(firstChild, actualRoot.children()[0]);\n+            assertEquals(secondChild, actualRoot.children()[1]);\n+            assertEquals(MemorySegment.NULL, actualRoot.children()[2]);\n+\n+            assertEquals(41, actualFirstChild.value());\n+            for (int i = 0; i < 3; i++) {\n+                assertEquals(MemorySegment.NULL, actualFirstChild.children()[i]);\n+            }\n+            assertEquals(42, actualSecondChild.value());\n+            for (int i = 0; i < 3; i++) {\n+                assertEquals(MemorySegment.NULL, actualSecondChild.children()[i]);\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void paddingLayout() {\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"x\"),\n+                MemoryLayout.paddingLayout(Integer.SIZE).withName(\"y\")\n+        );\n+\n+        assertThrows(IllegalArgumentException.class, () ->\n+                layout.recordMapper(Point.class)\n+        );\n+\n+    }\n+\n+    public record SingleValue(int x) {}\n+\n+    @Test\n+    public void nonDistinctUnusedNames() {\n+        \/\/ Tests that a name must not be unique in the MemoryLayout if it is unused\n+        \/\/ by any record component\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"z\"), \/\/ Not used\n+                JAVA_INT.withName(\"z\"), \/\/ Not used\n+                JAVA_INT.withName(\"x\"), \/\/ Used\n+                JAVA_INT.withName(\"y\")  \/\/ Used\n+        );\n+\n+        var mapper = layout.recordMapper(Point.class);\n+\n+        Point point = mapper.apply(POINT_SEGMENT);\n+        assertEquals(new Point(6, 0), point);\n+    }\n+\n+    @Test\n+    public void nonDistinctUsedNames() {\n+        \/\/ Tests that a name must be unique in the MemoryLayout if it is used\n+        \/\/ by a record component\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"x\"), \/\/ Used\n+                JAVA_INT.withName(\"x\")  \/\/ Used\n+        );\n+\n+        assertThrows(IllegalArgumentException.class, () ->\n+                layout.recordMapper(SingleValue.class)\n+        );\n+    }\n+\n+    static public <R extends Record> void testPointType(R expected,\n+                                                 Object array,\n+                                                 ValueLayout valueLayout) {\n+        testType(expected, array, valueLayout, \"x\", \"y\");\n+    }\n+\n+        @SuppressWarnings(\"unchecked\")\n+    static public <R extends Record> void testType(R expected,\n+                                            Object array,\n+                                            ValueLayout valueLayout,\n+                                            String... names) {\n+\n+        MemorySegment segment = switch (array) {\n+            case byte[] a -> MemorySegment.ofArray(a);\n+            case short[] a -> MemorySegment.ofArray(a);\n+            case char[] a -> MemorySegment.ofArray(a);\n+            case int[] a -> MemorySegment.ofArray(a);\n+            case long[] a -> MemorySegment.ofArray(a);\n+            case float[] a -> MemorySegment.ofArray(a);\n+            case double[] a -> MemorySegment.ofArray(a);\n+            default -> throw new IllegalArgumentException(\"Unknown array type: \" + array);\n+        };\n+\n+        StructLayout layout = MemoryLayout.structLayout(Arrays.stream(names)\n+                .map(valueLayout::withName)\n+                .toArray(MemoryLayout[]::new));\n+\n+        Class<R> type = (Class<R>) expected.getClass();\n+        Function<MemorySegment, R> mapper = layout.recordMapper(type);\n+        R actual = mapper.apply(segment);\n+        assertEquals(expected, actual);\n+    }\n+\n+\n+    public <T> void test(MemorySegment segment,\n+                         Function<MemorySegment, T> mapper,\n+                         T expected) {\n+\n+        T actual = mapper.apply(segment);\n+        assertEquals(expected, actual);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestRecordMapper.java","additions":992,"deletions":0,"binary":false,"changes":992,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-preview\", \"--enable-native-access=ALL-UNNAMED\" })\n+public class RecordMapper {\n+\n+    private static final GroupLayout POINT_LAYOUT =\n+            MemoryLayout.structLayout(\n+                    JAVA_INT.withName(\"x\"),\n+                    JAVA_INT.withName(\"y\"));\n+\n+    private static final int ARRAY_SIZE = 8;\n+\n+    private static final GroupLayout ARRAY_LAYOUT =\n+            MemoryLayout.structLayout(\n+                    MemoryLayout.sequenceLayout(ARRAY_SIZE, JAVA_INT)\n+                            .withName(\"ints\"));\n+\n+    public record Point(int x, int y){}\n+\n+    public record Array(int[] ints) {}\n+\n+    private static final Function<MemorySegment, Point> POINT_MAPPER = POINT_LAYOUT.recordMapper(Point.class);\n+    private static final Function<MemorySegment, Point> POINT_EXPLICIT_MAPPER = ms ->\n+            new Point(ms.get(JAVA_INT, 0L), ms.get(JAVA_INT, 4));\n+    private static final MethodHandle POINT_MH = methodHandle();\n+\n+    private static final Function<MemorySegment, Array> ARRAY_MAPPER = ARRAY_LAYOUT.recordMapper(Array.class);\n+    private static final Function<MemorySegment, Array> ARRAY_EXPLICIT_MAPPER = ms -> new Array(ms.toArray(JAVA_INT));\n+\n+    Arena arena;\n+    MemorySegment pointSegment;\n+    MemorySegment arraySegment;\n+\n+    @Setup\n+    public void setup() {\n+        arena = Arena.ofConfined();\n+        pointSegment = arena.allocate(POINT_LAYOUT);\n+        var rnd = new Random();\n+        pointSegment.set(JAVA_INT, 0, rnd.nextInt(10));\n+        pointSegment.set(JAVA_INT, 4, rnd.nextInt(10));\n+\n+        int[] ints = rnd.ints(ARRAY_SIZE).toArray();\n+        \/\/ Use native memory\n+        arraySegment = arena.allocate(ARRAY_LAYOUT);\n+        for (int i = 0; i < ARRAY_SIZE; i++) {\n+            arraySegment.setAtIndex(JAVA_INT, i, ints[i]);\n+        }\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        arena.close();\n+    }\n+\n+    @Benchmark\n+    public void pointMapper(Blackhole bh) {\n+        bh.consume(POINT_MAPPER.apply(pointSegment));\n+    }\n+\n+    @Benchmark\n+    public void pointExplicitMapper(Blackhole bh) {\n+        bh.consume(POINT_EXPLICIT_MAPPER.apply(pointSegment));\n+    }\n+\n+    @Benchmark\n+    public void pointMhMapper(Blackhole bh) {\n+        try {\n+            bh.consume((Point) POINT_MH.invokeExact(pointSegment));\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void arrayMapper(Blackhole bh) {\n+        bh.consume(ARRAY_MAPPER.apply(arraySegment));\n+    }\n+\n+    @Benchmark\n+    public void arrayExplicitMapper(Blackhole bh) {\n+        bh.consume(ARRAY_EXPLICIT_MAPPER.apply(arraySegment));\n+    }\n+\n+    static MethodHandle methodHandle() {\n+        try {\n+            var lookup = MethodHandles.lookup();\n+            var ctor = lookup.findConstructor(Point.class, MethodType.methodType(void.class, int.class, int.class));\n+\n+            var extractorType = MethodType.methodType(int.class, ValueLayout.OfInt.class, long.class);\n+\n+            var xVh = lookup.findVirtual(MemorySegment.class, \"get\", extractorType);\n+            \/\/ (MemorySegment, OfInt, long) -> (MemorySegment, long)\n+            var xVh2 = MethodHandles.insertArguments(xVh, 1, JAVA_INT);\n+            \/\/ (MemorySegment, long) -> (MemorySegment)\n+            var xVh3 = MethodHandles.insertArguments(xVh2, 1, 0L);\n+\n+            var yVh = lookup.findVirtual(MemorySegment.class, \"get\", extractorType);\n+            \/\/ (MemorySegment, OfInt, long) -> (MemorySegment, long)\n+            var yVh2 = MethodHandles.insertArguments(yVh, 1, JAVA_INT);\n+            \/\/ (MemorySegment, long) -> (MemorySegment)\n+            var yVh3 = MethodHandles.insertArguments(yVh2, 1, 4L);\n+\n+            var ctorFilter = MethodHandles.filterArguments(ctor, 0, xVh3);\n+            var ctorFilter2 = MethodHandles.filterArguments(ctorFilter, 1, yVh3);\n+\n+            var mt = MethodType.methodType(Point.class, MemorySegment.class);\n+\n+            return MethodHandles.permuteArguments(ctorFilter2, mt, 0, 0);\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/RecordMapper.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"}]}