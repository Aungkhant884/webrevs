{"files":[{"patch":"@@ -887,1 +887,1 @@\n-          Start-Process -FilePath \"$HOME\\cygwin\\setup-x86_64.exe\" -ArgumentList \"--quiet-mode --packages autoconf,make,zip,unzip --root $HOME\\cygwin\\cygwin64 --local-package-dir $HOME\\cygwin\\packages --site http:\/\/mirrors.kernel.org\/sourceware\/cygwin --no-desktop --no-shortcuts --no-startmenu --no-admin\" -Wait -NoNewWindow\n+          Start-Process -FilePath \"$HOME\\cygwin\\setup-x86_64.exe\" -ArgumentList \"--quiet-mode --packages cygwin=3.2.0-1,autoconf,make,zip,unzip --root $HOME\\cygwin\\cygwin64 --local-package-dir $HOME\\cygwin\\packages --site http:\/\/mirrors.kernel.org\/sourceware\/cygwin --no-desktop --no-shortcuts --no-startmenu --no-admin\" -Wait -NoNewWindow\n@@ -976,1 +976,1 @@\n-          Start-Process -FilePath \"$HOME\\cygwin\\setup-x86_64.exe\" -ArgumentList \"--quiet-mode --packages autoconf,make,zip,unzip --root $HOME\\cygwin\\cygwin64 --local-package-dir $HOME\\cygwin\\packages --site http:\/\/mirrors.kernel.org\/sourceware\/cygwin --no-desktop --no-shortcuts --no-startmenu --no-admin\" -Wait -NoNewWindow\n+          Start-Process -FilePath \"$HOME\\cygwin\\setup-x86_64.exe\" -ArgumentList \"--quiet-mode --packages cygwin=3.2.0-1,autoconf,make,zip,unzip --root $HOME\\cygwin\\cygwin64 --local-package-dir $HOME\\cygwin\\packages --site http:\/\/mirrors.kernel.org\/sourceware\/cygwin --no-desktop --no-shortcuts --no-startmenu --no-admin\" -Wait -NoNewWindow\n@@ -1148,1 +1148,1 @@\n-          Start-Process -FilePath \"$HOME\\cygwin\\setup-x86_64.exe\" -ArgumentList \"--quiet-mode --packages autoconf,make,zip,unzip --root $HOME\\cygwin\\cygwin64 --local-package-dir $HOME\\cygwin\\packages --site http:\/\/mirrors.kernel.org\/sourceware\/cygwin --no-desktop --no-shortcuts --no-startmenu --no-admin\" -Wait -NoNewWindow\n+          Start-Process -FilePath \"$HOME\\cygwin\\setup-x86_64.exe\" -ArgumentList \"--quiet-mode --packages cygwin=3.2.0-1,autoconf,make,zip,unzip --root $HOME\\cygwin\\cygwin64 --local-package-dir $HOME\\cygwin\\packages --site http:\/\/mirrors.kernel.org\/sourceware\/cygwin --no-desktop --no-shortcuts --no-startmenu --no-admin\" -Wait -NoNewWindow\n","filename":".github\/workflows\/submit.yml","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+<li><a href=\"#reproducible-builds\">Reproducible Builds<\/a><\/li>\n@@ -887,0 +888,26 @@\n+<h2 id=\"reproducible-builds\">Reproducible Builds<\/h2>\n+<p>Build reproducibility is the property of getting exactly the same bits out when building, every time, independent on who builds the product, or where. This is for many reasons a harder goal than it initially appears, but it is an important goal, for security reasons and others. Please see <a href=\"https:\/\/reproducible-builds.org\">Reproducible Builds<\/a> for more information about the background and reasons for reproducible builds.<\/p>\n+<p>Currently, it is not possible to build OpenJDK fully reproducibly, but getting there is an ongoing effort. There are some things you can do to minimize non-determinism and make a larger part of the build reproducible:<\/p>\n+<ul>\n+<li>Turn on build system support for reproducible builds<\/li>\n+<\/ul>\n+<p>Add the flag <code>--enable-reproducible-builds<\/code> to your <code>configure<\/code> command line. This will turn on support for reproducible builds where it could otherwise be lacking.<\/p>\n+<ul>\n+<li>Do not rely on <code>configure<\/code>'s default adhoc version strings<\/li>\n+<\/ul>\n+<p>Default adhoc version strings OPT segment include user name, source directory and timestamp. You can either override just the OPT segment using <code>--with-version-opt=&lt;any fixed string&gt;<\/code>, or you can specify the entire version string using <code>--with-version-string=&lt;your version&gt;<\/code>.<\/p>\n+<ul>\n+<li>Specify how the build sets <code>SOURCE_DATE_EPOCH<\/code><\/li>\n+<\/ul>\n+<p>The JDK build system will set the <code>SOURCE_DATE_EPOCH<\/code> environment variable during building, depending on the value of the <code>--with-source-date<\/code> option for <code>configure<\/code>. The default value is <code>updated<\/code>, which means that <code>SOURCE_DATE_EPOCH<\/code> will be set to the current time each time you are running <code>make<\/code>.<\/p>\n+<p>The <a href=\"https:\/\/reproducible-builds.org\/docs\/source-date-epoch\/\"><code>SOURCE_DATE_EPOCH<\/code> environment variable<\/a> is an industry standard, that many tools, such as gcc, recognize, and use in place of the current time when generating output.<\/p>\n+<p>For reproducible builds, you need to set this to a fixed value. You can use the special value <code>version<\/code> which will use the nominal release date for the current JDK version, or a value describing a date, either an epoch based timestamp as an integer, or a valid ISO-8601 date.<\/p>\n+<p><strong>Hint:<\/strong> If your build environment already sets <code>SOURCE_DATE_EPOCH<\/code>, you can propagate this using <code>--with-source-date=$SOURCE_DATE_EPOCH<\/code>.<\/p>\n+<ul>\n+<li>Specify a hotspot build time<\/li>\n+<\/ul>\n+<p>Set a fixed hotspot build time. This will be included in the hotspot library (<code>libjvm.so<\/code> or <code>jvm.dll<\/code>) and defaults to the current time when building hotspot. Use <code>--with-hotspot-build-time=&lt;any fixed string&gt;<\/code> for reproducible builds. It's a string so you don't need to format it specifically, so e.g. <code>n\/a<\/code> will do. Another solution is to use the <code>SOURCE_DATE_EPOCH<\/code> variable, e.g. <code>--with-hotspot-build-time=$(date --date=@$SOURCE_DATE_EPOCH)<\/code>.<\/p>\n+<ul>\n+<li>Copyright year<\/li>\n+<\/ul>\n+<p>The copyright year in some generated text files are normally set to the current year. This can be overridden by <code>--with-copyright-year=&lt;year&gt;<\/code>. For fully reproducible builds, this needs to be set to a fixed value.<\/p>\n","filename":"doc\/building.html","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1506,0 +1506,62 @@\n+## Reproducible Builds\n+\n+Build reproducibility is the property of getting exactly the same bits out when\n+building, every time, independent on who builds the product, or where. This is\n+for many reasons a harder goal than it initially appears, but it is an important\n+goal, for security reasons and others. Please see [Reproducible Builds](\n+https:\/\/reproducible-builds.org) for more information about the background and\n+reasons for reproducible builds.\n+\n+Currently, it is not possible to build OpenJDK fully reproducibly, but getting\n+there is an ongoing effort. There are some things you can do to minimize\n+non-determinism and make a larger part of the build reproducible:\n+\n+  * Turn on build system support for reproducible builds\n+\n+Add the flag `--enable-reproducible-builds` to your `configure` command line.\n+This will turn on support for reproducible builds where it could otherwise be\n+lacking.\n+\n+  * Do not rely on `configure`'s default adhoc version strings\n+\n+Default adhoc version strings OPT segment include user name, source directory\n+and timestamp. You can either override just the OPT segment using\n+`--with-version-opt=<any fixed string>`, or you can specify the entire version\n+string using `--with-version-string=<your version>`.\n+\n+  * Specify how the build sets `SOURCE_DATE_EPOCH`\n+\n+The JDK build system will set the `SOURCE_DATE_EPOCH` environment variable\n+during building, depending on the value of the `--with-source-date` option for\n+`configure`. The default value is `updated`, which means that\n+`SOURCE_DATE_EPOCH` will be set to the current time each time you are running\n+`make`.\n+\n+The [`SOURCE_DATE_EPOCH` environment variable](\n+https:\/\/reproducible-builds.org\/docs\/source-date-epoch\/) is an industry\n+standard, that many tools, such as gcc, recognize, and use in place of the\n+current time when generating output.\n+\n+For reproducible builds, you need to set this to a fixed value. You can use the\n+special value `version` which will use the nominal release date for the current\n+JDK version, or a value describing a date, either an epoch based timestamp as an\n+integer, or a valid ISO-8601 date.\n+\n+**Hint:** If your build environment already sets `SOURCE_DATE_EPOCH`, you can\n+propagate this using `--with-source-date=$SOURCE_DATE_EPOCH`.\n+\n+  * Specify a hotspot build time\n+\n+Set a fixed hotspot build time. This will be included in the hotspot library\n+(`libjvm.so` or `jvm.dll`) and defaults to the current time when building\n+hotspot. Use `--with-hotspot-build-time=<any fixed string>` for reproducible\n+builds. It's a string so you don't need to format it specifically, so e.g. `n\/a`\n+will do. Another solution is to use the `SOURCE_DATE_EPOCH` variable, e.g.\n+`--with-hotspot-build-time=$(date --date=@$SOURCE_DATE_EPOCH)`.\n+\n+  * Copyright year\n+\n+The copyright year in some generated text files are normally set to the current\n+year. This can be overridden by `--with-copyright-year=<year>`. For fully\n+reproducible builds, this needs to be set to a fixed value.\n+\n","filename":"doc\/building.md","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -47,0 +47,9 @@\n+  MINGW_SYSROOT = $(shell $(MINGW_BASE)-gcc -print-sysroot)\n+  ifeq ($(wildcard $(MINGW_SYSROOT)), )\n+    # Use fallback path\n+    MINGW_SYSROOT := \/usr\/$(MINGW_BASE)\n+    ifeq ($(wildcard $(MINGW_SYSROOT)), )\n+      $(error mingw sysroot not found)\n+    endif\n+  endif\n+\n@@ -52,2 +61,2 @@\n-      SYSROOT_CFLAGS := --sysroot=\/usr\/$(MINGW_BASE)\/sys-root, \\\n-      SYSROOT_LDFLAGS := --sysroot=\/usr\/$(MINGW_BASE)\/sys-root, \\\n+      SYSROOT_CFLAGS := --sysroot=$(MINGW_SYSROOT), \\\n+      SYSROOT_LDFLAGS := --sysroot=$(MINGW_SYSROOT), \\\n@@ -56,0 +65,20 @@\n+  MINGW_SYSROOT_LIB_PATH := $(MINGW_SYSROOT)\/mingw\/lib\n+  ifeq ($(wildcard $(MINGW_SYSROOT_LIB_PATH)), )\n+    # Try without mingw\n+    MINGW_SYSROOT_LIB_PATH := $(MINGW_SYSROOT)\/lib\n+    ifeq ($(wildcard $(MINGW_SYSROOT_LIB_PATH)), )\n+      $(error mingw sysroot lib path not found)\n+    endif\n+  endif\n+\n+  MINGW_VERSION = $(shell $(MINGW_BASE)-gcc -v 2>&1 | $(GREP) \"gcc version\" | $(CUT) -d \" \" -f 3)\n+  MINGW_GCC_LIB_PATH := \/usr\/lib\/gcc\/$(MINGW_BASE)\/$(MINGW_VERSION)\n+  ifeq ($(wildcard $(MINGW_GCC_LIB_PATH)), )\n+    # Try using only major version number\n+    MINGW_VERSION_MAJOR := $(firstword $(subst ., , $(MINGW_VERSION)))\n+    MINGW_GCC_LIB_PATH := \/usr\/lib\/gcc\/$(MINGW_BASE)\/$(MINGW_VERSION_MAJOR)\n+    ifeq ($(wildcard $(MINGW_GCC_LIB_PATH)), )\n+      $(error mingw gcc lib path not found)\n+    endif\n+  endif\n+\n@@ -69,3 +98,2 @@\n-  HSDIS_TOOLCHAIN_LDFLAGS := -L\/usr\/lib\/gcc\/$(MINGW_BASE)\/9.2.0 \\\n-      -L\/usr\/$(MINGW_BASE)\/sys-root\/mingw\/lib\n-  MINGW_DLLCRT := \/usr\/$(MINGW_BASE)\/sys-root\/mingw\/lib\/dllcrt2.o\n+  HSDIS_TOOLCHAIN_LDFLAGS := -L$(MINGW_GCC_LIB_PATH) -L$(MINGW_SYSROOT_LIB_PATH)\n+  MINGW_DLLCRT := $(MINGW_SYSROOT_LIB_PATH)\/dllcrt2.o\n","filename":"make\/Hsdis.gmk","additions":33,"deletions":5,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-VALID_VS_VERSIONS=\"2019 2017\"\n+VALID_VS_VERSIONS=\"2019 2017 2022\"\n@@ -59,0 +59,15 @@\n+VS_DESCRIPTION_2022=\"Microsoft Visual Studio 2022\"\n+VS_VERSION_INTERNAL_2022=143\n+VS_MSVCR_2022=vcruntime140.dll\n+VS_VCRUNTIME_1_2022=vcruntime140_1.dll\n+VS_MSVCP_2022=msvcp140.dll\n+VS_ENVVAR_2022=\"VS170COMNTOOLS\"\n+VS_USE_UCRT_2022=\"true\"\n+VS_VS_INSTALLDIR_2022=\"Microsoft Visual Studio\/2022\"\n+VS_EDITIONS_2022=\"BuildTools Community Professional Enterprise\"\n+VS_SDK_INSTALLDIR_2022=\n+VS_VS_PLATFORM_NAME_2022=\"v143\"\n+VS_SDK_PLATFORM_NAME_2022=\n+VS_SUPPORTED_2022=true\n+VS_TOOLSET_SUPPORTED_2022=true\n+\n","filename":"make\/autoconf\/toolchain_microsoft.m4","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -33,3 +33,3 @@\n-LINUX_X64_BOOT_JDK_FILENAME=openjdk-17_linux-x64_bin.tar.gz\n-LINUX_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk17\/0d483333a00540d886896bac774ff48b\/35\/GPL\/openjdk-17_linux-x64_bin.tar.gz\n-LINUX_X64_BOOT_JDK_SHA256=aef49cc7aa606de2044302e757fa94c8e144818e93487081c4fd319ca858134b\n+LINUX_X64_BOOT_JDK_FILENAME=openjdk-17.0.1_linux-x64_bin.tar.gz\n+LINUX_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk17.0.1\/2a2082e5a09d4267845be086888add4f\/12\/GPL\/openjdk-17.0.1_linux-x64_bin.tar.gz\n+LINUX_X64_BOOT_JDK_SHA256=1c0a73cbb863aad579b967316bf17673b8f98a9bb938602a140ba2e5c38f880a\n@@ -37,3 +37,3 @@\n-WINDOWS_X64_BOOT_JDK_FILENAME=openjdk-17_windows-x64_bin.zip\n-WINDOWS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk17\/0d483333a00540d886896bac774ff48b\/35\/GPL\/openjdk-17_windows-x64_bin.zip\n-WINDOWS_X64_BOOT_JDK_SHA256=e88b0df00021c9d266bb435c9a95fdc67d1948cce4518daf85c234907bd393c5\n+WINDOWS_X64_BOOT_JDK_FILENAME=openjdk-17.0.1_windows-x64_bin.zip\n+WINDOWS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk17.0.1\/2a2082e5a09d4267845be086888add4f\/12\/GPL\/openjdk-17.0.1_windows-x64_bin.zip\n+WINDOWS_X64_BOOT_JDK_SHA256=329900a6673b237b502bdcf77bc334da34bc91355c5fd2d457fc00f53fd71ef1\n@@ -41,3 +41,3 @@\n-MACOS_X64_BOOT_JDK_FILENAME=openjdk-17_macos-x64_bin.tar.gz\n-MACOS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk17\/0d483333a00540d886896bac774ff48b\/35\/GPL\/openjdk-17_macos-x64_bin.tar.gz\n-MACOS_X64_BOOT_JDK_SHA256=18e11cf9bbc6f584031e801b11ae05a233c32086f8e1b84eb8a1e9bb8e1f5d90\n+MACOS_X64_BOOT_JDK_FILENAME=openjdk-17.0.1_macos-x64_bin.tar.gz\n+MACOS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk17.0.1\/2a2082e5a09d4267845be086888add4f\/12\/GPL\/openjdk-17.0.1_macos-x64_bin.tar.gz\n+MACOS_X64_BOOT_JDK_SHA256=6ccb35800e723cabe15af60e67099d1a07c111d2d3208aa75523614dde68bee1\n","filename":"make\/conf\/test-dependencies","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -75,1 +75,3 @@\n-\t$(RM) -r $(ELEMENT_LISTS_DIR)\n+\t$(RM) $(ELEMENT_LISTS_DIR)\/element-list-{$(call CommaList, \\\n+\t\t$(call sequence, $(GENERATE_SYMBOLS_FROM_JDK_VERSION), \\\n+\t\t\t\t $(JDK_SOURCE_TARGET_VERSION)))}.txt\n","filename":"make\/modules\/jdk.javadoc\/Gendata.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2376,0 +2376,2 @@\n+    case Op_OnSpinWait:\n+      return VM_Version::supports_on_spin_wait();\n@@ -14336,0 +14338,12 @@\n+instruct onspinwait() %{\n+  match(OnSpinWait);\n+  ins_cost(INSN_COST);\n+\n+  format %{ \"onspinwait\" %}\n+\n+  ins_encode %{\n+    __ spin_wait();\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2987,1 +2987,1 @@\n-  Unimplemented();\n+  __ spin_wait();\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1094,1 +1094,1 @@\n-        __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), c_rarg0);\n+        __ call_VM_leaf(CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)), c_rarg0);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,1 +113,9 @@\n-          range(-1, 4096)\n+          range(-1, 4096)                                               \\\n+  product(ccstr, OnSpinWaitInst, \"none\", DIAGNOSTIC,                    \\\n+          \"The instruction to use to implement \"                        \\\n+          \"java.lang.Thread.onSpinWait().\"                              \\\n+          \"Options: none, nop, isb, yield.\")                            \\\n+  product(uint, OnSpinWaitInstCount, 1, DIAGNOSTIC,                     \\\n+          \"The number of OnSpinWaitInst instructions to generate.\"      \\\n+          \"It cannot be used with OnSpinWaitInst=none.\")                \\\n+          range(1, 99)\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -5169,0 +5169,18 @@\n+void MacroAssembler::spin_wait() {\n+  for (int i = 0; i < VM_Version::spin_wait_desc().inst_count(); ++i) {\n+    switch (VM_Version::spin_wait_desc().inst()) {\n+      case SpinWait::NOP:\n+        nop();\n+        break;\n+      case SpinWait::ISB:\n+        isb();\n+        break;\n+      case SpinWait::YIELD:\n+        yield();\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  }\n+}\n+\n@@ -5330,1 +5348,1 @@\n- if (src.first()->is_stack()) {\n+  if (src.first()->is_stack()) {\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1423,0 +1423,3 @@\n+  \/\/ Code for java.lang.Thread::onSpinWait() intrinsic.\n+  void spin_wait();\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2021, Amazon.com Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_AARCH64_SPIN_WAIT_AARCH64_HPP\n+#define CPU_AARCH64_SPIN_WAIT_AARCH64_HPP\n+\n+class SpinWait {\n+public:\n+  enum Inst {\n+    NONE = -1,\n+    NOP,\n+    ISB,\n+    YIELD\n+  };\n+\n+private:\n+  Inst _inst;\n+  int _count;\n+\n+public:\n+  SpinWait(Inst inst = NONE, int count = 0) : _inst(inst), _count(count) {}\n+\n+  Inst inst() const { return _inst; }\n+  int inst_count() const { return _count; }\n+};\n+\n+#endif \/\/ CPU_AARCH64_SPIN_WAIT_AARCH64_HPP\n","filename":"src\/hotspot\/cpu\/aarch64\/spin_wait_aarch64.hpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -3566,1 +3566,1 @@\n-           CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), r0);\n+           CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)), r0);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,20 @@\n+SpinWait VM_Version::_spin_wait;\n+\n+static SpinWait get_spin_wait_desc() {\n+  if (strcmp(OnSpinWaitInst, \"nop\") == 0) {\n+    return SpinWait(SpinWait::NOP, OnSpinWaitInstCount);\n+  } else if (strcmp(OnSpinWaitInst, \"isb\") == 0) {\n+    return SpinWait(SpinWait::ISB, OnSpinWaitInstCount);\n+  } else if (strcmp(OnSpinWaitInst, \"yield\") == 0) {\n+    return SpinWait(SpinWait::YIELD, OnSpinWaitInstCount);\n+  } else if (strcmp(OnSpinWaitInst, \"none\") != 0) {\n+    vm_exit_during_initialization(\"The options for OnSpinWaitInst are nop, isb, yield, and none\", OnSpinWaitInst);\n+  }\n+\n+  if (!FLAG_IS_DEFAULT(OnSpinWaitInstCount) && OnSpinWaitInstCount > 0) {\n+    vm_exit_during_initialization(\"OnSpinWaitInstCount cannot be used for OnSpinWaitInst 'none'\");\n+  }\n+\n+  return SpinWait{};\n+}\n+\n@@ -454,0 +474,2 @@\n+  _spin_wait = get_spin_wait_desc();\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"spin_wait_aarch64.hpp\"\n@@ -48,0 +49,2 @@\n+  static SpinWait _spin_wait;\n+\n@@ -145,0 +148,4 @@\n+  static const SpinWait& spin_wait_desc() { return _spin_wait; }\n+\n+  static bool supports_on_spin_wait() { return _spin_wait.inst() != SpinWait::NONE; }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3988,1 +3988,1 @@\n-      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), Robj);\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)), Robj);\n","filename":"src\/hotspot\/cpu\/arm\/templateTable_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -697,1 +697,1 @@\n-\/\/        __ call(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc),\n+\/\/        __ call(CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)),\n","filename":"src\/hotspot\/cpu\/ppc\/c1_Runtime1_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3806,1 +3806,1 @@\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc));\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)));\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -670,1 +670,1 @@\n-        __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc)));\n+        __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc))));\n","filename":"src\/hotspot\/cpu\/s390\/c1_Runtime1_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3825,1 +3825,1 @@\n-      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), RallocatedObject);\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)), RallocatedObject);\n","filename":"src\/hotspot\/cpu\/s390\/templateTable_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1500,1 +1500,1 @@\n-        __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc)));\n+        __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc))));\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4041,1 +4041,1 @@\n-           CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), rax);\n+           CAST_FROM_FN_PTR(address, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc)), rax);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,7 @@\n-  return is_even(value());\n+  \/\/ Do not use is_XMMRegister() here as it depends on the UseAVX setting.\n+  if (value() >= ConcreteRegisterImpl::max_fpr && value() < ConcreteRegisterImpl::max_xmm) {\n+    int base = value() - ConcreteRegisterImpl::max_fpr;\n+    return base % XMMRegisterImpl::max_slots_per_register == 0;\n+  } else {\n+    return is_even(value());   \/\/ General, float, and K registers are all two slots wide\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/vmreg_x86.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7207,1 +7207,1 @@\n-  predicate(UseSSE >= 2);\n+  predicate(UseSSE >= 1);\n@@ -7225,1 +7225,1 @@\n-  predicate(UseSSE < 2);\n+  predicate(UseSSE < 1);\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,0 +55,6 @@\n+  if (addr == (address)(intptr_t)-1) {\n+    \/\/ dladdr() in macOS12\/Monterey returns success for -1, but that addr value\n+    \/\/ won't work in this function. Should have been handled by the caller.\n+    ShouldNotReachHere();\n+    return false;\n+  }\n","filename":"src\/hotspot\/os\/bsd\/decoder_machO.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -841,0 +841,11 @@\n+static int local_dladdr(const void* addr, Dl_info* info) {\n+#ifdef __APPLE__\n+  if (addr == (void*)-1) {\n+    \/\/ dladdr() in macOS12\/Monterey returns success for -1, but that addr\n+    \/\/ value should not be allowed to work to avoid confusion.\n+    return 0;\n+  }\n+#endif\n+  return dladdr(addr, info);\n+}\n+\n@@ -880,3 +891,0 @@\n-\n-#define MACH_MAXSYMLEN 256\n-\n@@ -890,1 +898,0 @@\n-  char localbuf[MACH_MAXSYMLEN];\n@@ -892,1 +899,1 @@\n-  if (dladdr((void*)addr, &dlinfo) != 0) {\n+  if (local_dladdr((void*)addr, &dlinfo) != 0) {\n@@ -901,0 +908,8 @@\n+\n+#ifndef __APPLE__\n+    \/\/ The 6-parameter Decoder::decode() function is not implemented on macOS.\n+    \/\/ The Mach-O binary format does not contain a \"list of files\" with address\n+    \/\/ ranges like ELF. That makes sense since Mach-O can contain binaries for\n+    \/\/ than one instruction set so there can be more than one address range for\n+    \/\/ each \"file\".\n+\n@@ -909,0 +924,4 @@\n+#else  \/\/ __APPLE__\n+    #define MACH_MAXSYMLEN 256\n+\n+    char localbuf[MACH_MAXSYMLEN];\n@@ -918,0 +937,3 @@\n+\n+    #undef MACH_MAXSYMLEN\n+#endif  \/\/ __APPLE__\n@@ -932,1 +954,1 @@\n-  if (dladdr((void*)addr, &dlinfo) != 0) {\n+  if (local_dladdr((void*)addr, &dlinfo) != 0) {\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  { \"GenericCDSFileMapHeader::_base_archive_path_offset\",  offset_of(GenericCDSFileMapHeader, _base_archive_path_offset) },\n+  { \"GenericCDSFileMapHeader::_base_archive_name_offset\",  offset_of(GenericCDSFileMapHeader, _base_archive_name_offset) },\n","filename":"src\/hotspot\/share\/cds\/cdsConstants.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-  size_t base_archive_path_offset = 0;\n+  size_t base_archive_name_offset = 0;\n@@ -210,1 +210,1 @@\n-      base_archive_path_offset = c_header_size;\n+      base_archive_name_offset = c_header_size;\n@@ -219,1 +219,1 @@\n-                    base_archive_path_offset);\n+                    base_archive_name_offset);\n@@ -224,1 +224,1 @@\n-                             size_t base_archive_path_offset) {\n+                             size_t base_archive_name_offset) {\n@@ -229,1 +229,1 @@\n-  set_base_archive_path_offset((unsigned int)base_archive_path_offset);\n+  set_base_archive_name_offset((unsigned int)base_archive_name_offset);\n@@ -283,1 +283,1 @@\n-  assert(base_archive_path_offset() != 0, \"_base_archive_path_offset not set\");\n+  assert(base_archive_name_offset() != 0, \"_base_archive_name_offset not set\");\n@@ -285,1 +285,1 @@\n-  memcpy((char*)this + base_archive_path_offset(), archive, base_archive_name_size());\n+  memcpy((char*)this + base_archive_name_offset(), archive, base_archive_name_size());\n@@ -295,1 +295,1 @@\n-  st->print_cr(\"- base_archive_path_offset:       \" UINT32_FORMAT, base_archive_path_offset());\n+  st->print_cr(\"- base_archive_name_offset:       \" UINT32_FORMAT, base_archive_name_offset());\n@@ -1086,1 +1086,1 @@\n-  bool read_base_archive_name(char** target) {\n+  char* read_base_archive_name() {\n@@ -1088,1 +1088,1 @@\n-    size_t name_size = (size_t)_header._base_archive_name_size;\n+    size_t name_size = _header._base_archive_name_size;\n@@ -1090,3 +1090,3 @@\n-    *target = NEW_C_HEAP_ARRAY(char, name_size, mtInternal);\n-    lseek(_fd, _header._base_archive_path_offset, SEEK_SET); \/\/ position to correct offset.\n-    size_t n = os::read(_fd, *target, (unsigned int)name_size);\n+    char* base_name = NEW_C_HEAP_ARRAY(char, name_size, mtInternal);\n+    lseek(_fd, _header._base_archive_name_offset, SEEK_SET); \/\/ position to correct offset.\n+    size_t n = os::read(_fd, base_name, (unsigned int)name_size);\n@@ -1095,2 +1095,2 @@\n-      FREE_C_HEAP_ARRAY(char, *target);\n-      return false;\n+      FREE_C_HEAP_ARRAY(char, base_name);\n+      return nullptr;\n@@ -1098,4 +1098,4 @@\n-    if (!os::file_exists(*target)) {\n-      log_info(cds)(\"Base archive %s does not exist\", *target);\n-      FREE_C_HEAP_ARRAY(char, *target);\n-      return false;\n+    if (base_name[name_size - 1] != '\\0' || strlen(base_name) != name_size - 1) {\n+      log_info(cds)(\"Base archive name is damaged\");\n+      FREE_C_HEAP_ARRAY(char, base_name);\n+      return nullptr;\n@@ -1103,1 +1103,6 @@\n-    return true;\n+    if (!os::file_exists(base_name)) {\n+      log_info(cds)(\"Base archive %s does not exist\", base_name);\n+      FREE_C_HEAP_ARRAY(char, base_name);\n+      return nullptr;\n+    }\n+    return base_name;\n@@ -1122,3 +1127,3 @@\n-    if (header->_base_archive_path_offset != 0) {\n-      log_info(cds)(\"_base_archive_path_offset should be 0\");\n-      log_info(cds)(\"_base_archive_path_offset = \" UINT32_FORMAT, header->_base_archive_path_offset);\n+    if (header->_base_archive_name_offset != 0) {\n+      log_info(cds)(\"_base_archive_name_offset should be 0\");\n+      log_info(cds)(\"_base_archive_name_offset = \" UINT32_FORMAT, header->_base_archive_name_offset);\n@@ -1133,1 +1138,1 @@\n-    unsigned int path_offset = header->_base_archive_path_offset;\n+    unsigned int name_offset = header->_base_archive_name_offset;\n@@ -1135,2 +1140,2 @@\n-    if (path_offset + name_size != header_size) {\n-      log_info(cds)(\"_header_size should be equal to _base_archive_path_offset plus _base_archive_name_size\");\n+    if (name_offset + name_size != header_size) {\n+      log_info(cds)(\"_header_size should be equal to _base_archive_name_offset plus _base_archive_name_size\");\n@@ -1138,1 +1143,1 @@\n-      log_info(cds)(\"  _base_archive_path_offset = \" UINT32_FORMAT, path_offset);\n+      log_info(cds)(\"  _base_archive_name_offset = \" UINT32_FORMAT, name_offset);\n@@ -1142,2 +1147,2 @@\n-    char* base_name = NULL;\n-    if (!file_helper.read_base_archive_name(&base_name)) {\n+    char* base_name = file_helper.read_base_archive_name();\n+    if (base_name == nullptr) {\n@@ -1163,2 +1168,2 @@\n-  if ((header->_base_archive_name_size == 0 && header->_base_archive_path_offset != 0) ||\n-      (header->_base_archive_name_size != 0 && header->_base_archive_path_offset == 0)) {\n+  if ((header->_base_archive_name_size == 0 && header->_base_archive_name_offset != 0) ||\n+      (header->_base_archive_name_size != 0 && header->_base_archive_name_offset == 0)) {\n@@ -1169,1 +1174,1 @@\n-      header->_base_archive_path_offset == 0) {\n+      header->_base_archive_name_offset == 0) {\n@@ -1173,2 +1178,2 @@\n-    if (!file_helper.read_base_archive_name(base_archive_name)) {\n-      *base_archive_name = NULL;\n+    *base_archive_name = file_helper.read_base_archive_name();\n+    if (*base_archive_name == nullptr) {\n@@ -1215,1 +1220,1 @@\n-  unsigned int base_offset = header()->base_archive_path_offset();\n+  unsigned int base_offset = header()->base_archive_name_offset();\n@@ -1222,1 +1227,1 @@\n-      log_info(cds)(\"base_archive_path_offset: \" UINT32_FORMAT, base_offset);\n+      log_info(cds)(\"base_archive_name_offset: \" UINT32_FORMAT, base_offset);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":41,"deletions":36,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -246,1 +246,1 @@\n-  unsigned int base_archive_path_offset() const { return _generic_header._base_archive_path_offset; }\n+  unsigned int base_archive_name_offset() const { return _generic_header._base_archive_name_offset; }\n@@ -253,1 +253,1 @@\n-  void set_base_archive_path_offset(unsigned int s) { _generic_header._base_archive_path_offset = s; }\n+  void set_base_archive_name_offset(unsigned int s) { _generic_header._base_archive_name_offset = s; }\n@@ -316,1 +316,1 @@\n-                size_t base_archive_name_size, size_t base_archive_path_offset);\n+                size_t base_archive_name_size, size_t base_archive_name_offset);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  const int neg = JVM_ACC_STATIC | JVM_ACC_SYNCHRONIZED;\n+  const int neg = JVM_ACC_STATIC | JVM_ACC_SYNCHRONIZED | JVM_ACC_NATIVE;\n@@ -42,1 +42,1 @@\n-  const int neg = JVM_ACC_STATIC;\n+  const int neg = JVM_ACC_STATIC | JVM_ACC_NATIVE;\n@@ -54,1 +54,1 @@\n-  const int neg = JVM_ACC_SYNCHRONIZED;\n+  const int neg = JVM_ACC_SYNCHRONIZED | JVM_ACC_NATIVE;\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-  do_intrinsic(_hashCode,                 java_lang_Object,       hashCode_name, void_int_signature,             F_R)   \\\n+  do_intrinsic(_hashCode,                 java_lang_Object,       hashCode_name, void_int_signature,             F_RN)  \\\n@@ -112,1 +112,1 @@\n-  do_intrinsic(_getClass,                 java_lang_Object,       getClass_name, void_class_signature,           F_R)   \\\n+  do_intrinsic(_getClass,                 java_lang_Object,       getClass_name, void_class_signature,           F_RN)  \\\n@@ -114,1 +114,1 @@\n-  do_intrinsic(_clone,                    java_lang_Object,       clone_name, void_object_signature,             F_R)   \\\n+  do_intrinsic(_clone,                    java_lang_Object,       clone_name, void_object_signature,             F_RN)  \\\n@@ -116,1 +116,1 @@\n-  do_intrinsic(_notify,                   java_lang_Object,       notify_name, void_method_signature,            F_R)   \\\n+  do_intrinsic(_notify,                   java_lang_Object,       notify_name, void_method_signature,            F_RN)  \\\n@@ -118,1 +118,1 @@\n-  do_intrinsic(_notifyAll,                java_lang_Object,       notifyAll_name, void_method_signature,         F_R)   \\\n+  do_intrinsic(_notifyAll,                java_lang_Object,       notifyAll_name, void_method_signature,         F_RN)  \\\n@@ -203,1 +203,1 @@\n-  do_intrinsic(_floatToRawIntBits,        java_lang_Float,        floatToRawIntBits_name,   float_int_signature, F_S)   \\\n+  do_intrinsic(_floatToRawIntBits,        java_lang_Float,        floatToRawIntBits_name,   float_int_signature, F_SN)  \\\n@@ -207,1 +207,1 @@\n-  do_intrinsic(_intBitsToFloat,           java_lang_Float,        intBitsToFloat_name,      int_float_signature, F_S)   \\\n+  do_intrinsic(_intBitsToFloat,           java_lang_Float,        intBitsToFloat_name,      int_float_signature, F_SN)  \\\n@@ -209,1 +209,1 @@\n-  do_intrinsic(_doubleToRawLongBits,      java_lang_Double,       doubleToRawLongBits_name, double_long_signature, F_S) \\\n+  do_intrinsic(_doubleToRawLongBits,      java_lang_Double,       doubleToRawLongBits_name, double_long_signature, F_SN)\\\n@@ -213,1 +213,1 @@\n-  do_intrinsic(_longBitsToDouble,         java_lang_Double,       longBitsToDouble_name,    long_double_signature, F_S) \\\n+  do_intrinsic(_longBitsToDouble,         java_lang_Double,       longBitsToDouble_name,    long_double_signature, F_SN)\\\n@@ -234,1 +234,1 @@\n-  do_intrinsic(_identityHashCode,         java_lang_System,       identityHashCode_name, object_int_signature,   F_S)   \\\n+  do_intrinsic(_identityHashCode,         java_lang_System,       identityHashCode_name, object_int_signature,   F_SN)  \\\n@@ -236,1 +236,1 @@\n-  do_intrinsic(_currentTimeMillis,        java_lang_System,       currentTimeMillis_name, void_long_signature,   F_S)   \\\n+  do_intrinsic(_currentTimeMillis,        java_lang_System,       currentTimeMillis_name, void_long_signature,   F_SN)  \\\n@@ -239,1 +239,1 @@\n-  do_intrinsic(_nanoTime,                 java_lang_System,       nanoTime_name,          void_long_signature,   F_S)   \\\n+  do_intrinsic(_nanoTime,                 java_lang_System,       nanoTime_name,          void_long_signature,   F_SN)  \\\n@@ -244,1 +244,1 @@\n-  do_intrinsic(_arraycopy,                java_lang_System,       arraycopy_name, arraycopy_signature,           F_S)   \\\n+  do_intrinsic(_arraycopy,                java_lang_System,       arraycopy_name, arraycopy_signature,           F_SN)  \\\n@@ -247,1 +247,1 @@\n-  do_intrinsic(_currentThread,            java_lang_Thread,       currentThread_name, currentThread_signature,   F_S)   \\\n+  do_intrinsic(_currentThread,            java_lang_Thread,       currentThread_name, currentThread_signature,   F_SN)  \\\n@@ -404,3 +404,3 @@\n-  do_intrinsic(_Reference_get,            java_lang_ref_Reference, get_name,    void_object_signature, F_R)             \\\n-  do_intrinsic(_Reference_refersTo0,     java_lang_ref_Reference, refersTo0_name, object_boolean_signature, F_R)        \\\n-  do_intrinsic(_PhantomReference_refersTo0, java_lang_ref_PhantomReference, refersTo0_name, object_boolean_signature, F_R) \\\n+  do_intrinsic(_Reference_get,              java_lang_ref_Reference, get_name,       void_object_signature,    F_R)     \\\n+  do_intrinsic(_Reference_refersTo0,        java_lang_ref_Reference, refersTo0_name, object_boolean_signature, F_RN)    \\\n+  do_intrinsic(_PhantomReference_refersTo0, java_lang_ref_PhantomReference, refersTo0_name, object_boolean_signature, F_RN) \\\n@@ -954,1 +954,1 @@\n-  do_intrinsic(_park,                     jdk_internal_misc_Unsafe,     park_name, park_signature,                     F_R)    \\\n+  do_intrinsic(_park,                     jdk_internal_misc_Unsafe,     park_name, park_signature,                     F_RN)   \\\n@@ -957,1 +957,1 @@\n-  do_intrinsic(_unpark,                   jdk_internal_misc_Unsafe,     unpark_name, unpark_signature,                 F_R)    \\\n+  do_intrinsic(_unpark,                   jdk_internal_misc_Unsafe,     unpark_name, unpark_signature,                 F_RN)   \\\n@@ -1093,3 +1093,3 @@\n-    F_R,                        \/\/ !static ?native !synchronized (R=\"regular\")\n-    F_S,                        \/\/  static ?native !synchronized\n-    F_Y,                        \/\/ !static ?native  synchronized\n+    F_R,                        \/\/ !static !native !synchronized (R=\"regular\")\n+    F_S,                        \/\/  static !native !synchronized\n+    F_Y,                        \/\/ !static !native  synchronized\n@@ -1105,0 +1105,44 @@\n+  static constexpr bool is_flag_static(Flags flags) {\n+    switch (flags) {\n+      case F_S:\n+      case F_SN:\n+        return true;\n+      case F_R:\n+      case F_Y:\n+      case F_RN:\n+        return false;\n+      default:\n+        ShouldNotReachHere();\n+        return false;\n+    }\n+  }\n+\n+  static constexpr bool is_flag_synchronized(Flags flags) {\n+    switch (flags) {\n+      case F_Y:\n+        return true;\n+      case F_RN:\n+      case F_SN:\n+      case F_S:\n+      case F_R:\n+        return false;\n+      default:\n+        ShouldNotReachHere();\n+        return false;\n+    }\n+  }\n+\n+  static constexpr bool is_flag_native(Flags flags) {\n+    switch (flags) {\n+      case F_RN:\n+      case F_SN:\n+        return true;\n+      case F_S:\n+      case F_R:\n+      case F_Y:\n+        return false;\n+      default:\n+        ShouldNotReachHere();\n+        return false;\n+    }\n+  }\n@@ -1156,3 +1200,9 @@\n-    assert(    class_for(id) == holder, \"correct id\");\n-    assert(     name_for(id) == name,   \"correct id\");\n-    assert(signature_for(id) == sig,    \"correct id\");\n+    assert(    class_for(id) == holder, \"correct class: %s\",     name_at(id));\n+    assert(     name_for(id) == name,   \"correct name: %s\",      name_at(id));\n+    assert(signature_for(id) == sig,    \"correct signature: %s\", name_at(id));\n+    assert(      is_flag_static(flags_for(id)) == ((flags & JVM_ACC_STATIC)       != 0),\n+                 \"correct static flag: %s\", name_at(id));\n+    assert(is_flag_synchronized(flags_for(id)) == ((flags & JVM_ACC_SYNCHRONIZED) != 0),\n+           \"correct synchronized flag: %s\", name_at(id));\n+    assert(      is_flag_native(flags_for(id)) == ((flags & JVM_ACC_NATIVE)       != 0),\n+                 \"correct native flag: %s\", name_at(id));\n@@ -1167,1 +1217,1 @@\n-  static Flags              flags_for(ID id);\n+  static Flags          flags_for(ID id);\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":76,"deletions":26,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-  assert(dummy_region->allocate_no_bot_updates(1) == NULL, \"should fail\");\n-  assert(dummy_region->allocate(1) == NULL, \"should fail\");\n@@ -49,1 +47,0 @@\n-  assert(dummy_region->par_allocate_no_bot_updates(1, 1, &assert_tmp) == NULL, \"should fail\");\n@@ -80,2 +77,3 @@\n-      \/\/ If the allocation was successful we should fill in the space.\n-      CollectedHeap::fill_with_object(dummy, free_word_size);\n+      \/\/ If the allocation was successful we should fill in the space. If the\n+      \/\/ allocation was in old any necessary BOT updates will be done.\n+      alloc_region->fill_with_dummy_object(dummy, free_word_size);\n@@ -259,1 +257,0 @@\n-    _bot_updates(bot_updates),\n@@ -392,1 +389,1 @@\n-        CollectedHeap::fill_with_object(dummy, to_allocate_words);\n+        cur->fill_with_dummy_object(dummy, to_allocate_words);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -71,3 +71,0 @@\n-  \/\/ When true, indicates that allocate calls should do BOT updates.\n-  const bool _bot_updates;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,3 +34,3 @@\n-    assert((p), \"[%s] %s c: %u b: %s r: \" PTR_FORMAT \" u: \" SIZE_FORMAT, \\\n-           _name, (message), _count, BOOL_TO_STR(_bot_updates),          \\\n-           p2i(_alloc_region), _used_bytes_before);                      \\\n+    assert((p), \"[%s] %s c: %u r: \" PTR_FORMAT \" u: \" SIZE_FORMAT,       \\\n+           _name, (message), _count, p2i(_alloc_region),                 \\\n+           _used_bytes_before);                                          \\\n@@ -48,5 +48,1 @@\n-  if (!_bot_updates) {\n-    return alloc_region->allocate_no_bot_updates(word_size);\n-  } else {\n-    return alloc_region->allocate(word_size);\n-  }\n+  return alloc_region->allocate(word_size);\n@@ -67,5 +63,1 @@\n-  if (!_bot_updates) {\n-    return alloc_region->par_allocate_no_bot_updates(min_word_size, desired_word_size, actual_word_size);\n-  } else {\n-    return alloc_region->par_allocate(min_word_size, desired_word_size, actual_word_size);\n-  }\n+  return alloc_region->par_allocate(min_word_size, desired_word_size, actual_word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.inline.hpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -302,0 +302,1 @@\n+    size_t word_sz = _g1h->desired_plab_sz(state);\n@@ -303,1 +304,4 @@\n-      _alloc_buffers[state][node_index] = new PLAB(_g1h->desired_plab_sz(state));\n+      \/\/ Specialized PLABs for old that handle BOT updates for object allocations.\n+      _alloc_buffers[state][node_index] = (state == G1HeapRegionAttr::Old)\n+                                        ? new G1BotUpdatingPLAB(word_sz)\n+                                        : new PLAB(word_sz);\n@@ -363,0 +367,1 @@\n+    update_bot_for_direct_allocation(dest, result, word_sz);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -148,0 +148,16 @@\n+\/\/ Specialized PLAB for old generation promotions. For old regions the\n+\/\/ BOT needs to be updated and the relevant data to do this efficiently\n+\/\/ is stored in the PLAB.\n+class G1BotUpdatingPLAB : public PLAB {\n+  \/\/ An object spanning this threshold will cause a BOT update.\n+  HeapWord* _next_bot_threshold;\n+  \/\/ The region in which the PLAB resides.\n+  HeapRegion* _region;\n+public:\n+  G1BotUpdatingPLAB(size_t word_sz) : PLAB(word_sz) { }\n+  \/\/ Sets the new PLAB buffer as well as updates the threshold and region.\n+  void set_buf(HeapWord* buf, size_t word_sz) override;\n+  \/\/ Updates the BOT if the last allocation crossed the threshold.\n+  inline void update_bot(size_t word_sz);\n+};\n+\n@@ -168,0 +184,3 @@\n+  \/\/ Helpers to do explicit BOT updates for allocations in old generation regions.\n+  void update_bot_for_direct_allocation(G1HeapRegionAttr attr, HeapWord* addr, size_t size);\n+\n@@ -173,0 +192,4 @@\n+  \/\/ Returns if BOT updates are needed for the given destinaion. Currently we only have\n+  \/\/ two destinations and BOT updates are only needed for the old generation.\n+  inline bool needs_bot_update(G1HeapRegionAttr dest) const;\n+\n@@ -201,0 +224,3 @@\n+  \/\/ Update the BOT for the last PLAB allocation.\n+  inline void update_bot_for_plab_allocation(G1HeapRegionAttr dest, size_t word_sz, uint node_index);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -136,0 +136,45 @@\n+inline bool G1PLABAllocator::needs_bot_update(G1HeapRegionAttr dest) const {\n+  return dest.is_old();\n+}\n+\n+inline void G1PLABAllocator::update_bot_for_direct_allocation(G1HeapRegionAttr attr, HeapWord* addr, size_t size) {\n+  if (!needs_bot_update(attr)) {\n+    return;\n+  }\n+\n+  \/\/ Out of PLAB allocations in an old generation region. Update BOT.\n+  HeapRegion* region = _g1h->heap_region_containing(addr);\n+  region->update_bot_at(addr, size);\n+}\n+\n+inline void G1PLABAllocator::update_bot_for_plab_allocation(G1HeapRegionAttr dest, size_t word_sz, uint node_index) {\n+  assert(needs_bot_update(dest), \"Wrong destination: %s\", dest.get_type_str());\n+  G1BotUpdatingPLAB* plab = static_cast<G1BotUpdatingPLAB*>(alloc_buffer(dest, node_index));\n+  plab->update_bot(word_sz);\n+}\n+\n+inline void G1BotUpdatingPLAB::set_buf(HeapWord* buf, size_t word_sz) {\n+  PLAB::set_buf(buf, word_sz);\n+  \/\/ Update the region and threshold to allow efficient BOT updates.\n+  _region = G1CollectedHeap::heap()->heap_region_containing(buf);\n+  _next_bot_threshold = _region->bot_threshold_for_addr(buf);\n+}\n+\n+inline void G1BotUpdatingPLAB::update_bot(size_t word_sz) {\n+  \/\/ The last object end is at _top, if it did not cross the\n+  \/\/ threshold, there is nothing to do.\n+  if (_top <= _next_bot_threshold) {\n+    return;\n+  }\n+\n+  HeapWord* obj_start = _top - word_sz;\n+  assert(contains(obj_start),\n+         \"Object start outside PLAB. bottom: \" PTR_FORMAT \" object: \" PTR_FORMAT,\n+         p2i(_bottom), p2i(obj_start));\n+  assert(obj_start <= _next_bot_threshold,\n+         \"Object start not below or at threshold. threshold: \" PTR_FORMAT \" object: \" PTR_FORMAT,\n+         p2i(_next_bot_threshold), p2i(obj_start));\n+\n+  _region->update_bot_crossing_threshold(&_next_bot_threshold, obj_start, _top);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.inline.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+  friend class HeapRegion;\n@@ -184,0 +185,3 @@\n+  \/\/ Given an address calculate where the next threshold needing an update is.\n+  inline HeapWord* threshold_for_addr(const void* addr);\n+\n@@ -207,0 +211,5 @@\n+  \/\/ Sets the threshold explicitly to keep it consistent with what has been\n+  \/\/ updated. This needs to be done when the threshold is not used for updating\n+  \/\/ the bot, for example when promoting to old in young collections.\n+  void set_threshold(HeapWord* threshold) { _next_offset_threshold = threshold; }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,0 +34,14 @@\n+inline HeapWord* G1BlockOffsetTablePart::threshold_for_addr(const void* addr) {\n+  assert(addr >= _hr->bottom() && addr < _hr->top(), \"invalid address\");\n+  size_t index = _bot->index_for(addr);\n+  HeapWord* card_boundary = _bot->address_for_index(index);\n+  \/\/ Address at card boundary, use as threshold.\n+  if (card_boundary == addr) {\n+    return card_boundary;\n+  }\n+\n+  \/\/ Calculate next threshold.\n+  HeapWord* threshold = card_boundary + BOTConstants::N_words;\n+  return threshold;\n+}\n+\n@@ -112,3 +126,0 @@\n-  \/\/ We must make sure that the offset table entry we use is valid.\n-  assert(addr < _next_offset_threshold, \"Precondition\");\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.inline.hpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -330,0 +330,1 @@\n+      assert(card_set == G1CardSet::FullCardSet, \"Must be\");\n@@ -331,1 +332,0 @@\n-        assert(card_set == G1CardSet::FullCardSet, \"Must be\");\n@@ -333,3 +333,1 @@\n-        for (uint i = 0; i < config->max_cards_in_region(); i++) {\n-          found((offset | (uint)i));\n-        }\n+        found(offset, config->num_cards_in_howl_bitmap());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.inline.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1SegmentedArray.inline.hpp\"\n@@ -49,0 +50,5 @@\n+template <class Elem>\n+G1CardSetAllocator<Elem>::~G1CardSetAllocator() {\n+  drop_all();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -116,3 +116,1 @@\n-  ~G1CardSetAllocator() {\n-    drop_all();\n-  }\n+  ~G1CardSetAllocator();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3296,0 +3296,1 @@\n+    alloc_region->update_bot_threshold();\n@@ -3448,0 +3449,5 @@\n+\n+void G1CollectedHeap::fill_with_dummy_object(HeapWord* start, HeapWord* end, bool zap) {\n+  HeapRegion* region = heap_region_containing(start);\n+  region->fill_with_dummy_object(start, pointer_delta(end, start), zap);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -937,0 +937,2 @@\n+  virtual void fill_with_dummy_object(HeapWord* start, HeapWord* end, bool zap);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  size_t _marked_bytes;\n+  size_t _marked_words;\n@@ -56,1 +56,1 @@\n-    _marked_bytes(0),\n+    _marked_words(0),\n@@ -61,1 +61,1 @@\n-  size_t marked_bytes() { return _marked_bytes; }\n+  size_t marked_bytes() { return _marked_words * HeapWordSize; }\n@@ -71,0 +71,1 @@\n+    assert(_last_forwarded_object_end <= obj_addr, \"should iterate in ascending address order\");\n@@ -73,2 +74,2 @@\n-    if (obj->is_forwarded() && obj->forwardee() == obj) {\n-      \/\/ The object failed to move.\n+    \/\/ The object failed to move.\n+    assert(obj->is_forwarded() && obj->forwardee() == obj, \"sanity\");\n@@ -76,21 +77,21 @@\n-      zap_dead_objects(_last_forwarded_object_end, obj_addr);\n-      \/\/ We consider all objects that we find self-forwarded to be\n-      \/\/ live. What we'll do is that we'll update the prev marking\n-      \/\/ info so that they are all under PTAMS and explicitly marked.\n-      if (!_cm->is_marked_in_prev_bitmap(obj)) {\n-        _cm->mark_in_prev_bitmap(obj);\n-      }\n-      if (_during_concurrent_start) {\n-        \/\/ For the next marking info we'll only mark the\n-        \/\/ self-forwarded objects explicitly if we are during\n-        \/\/ concurrent start (since, normally, we only mark objects pointed\n-        \/\/ to by roots if we succeed in copying them). By marking all\n-        \/\/ self-forwarded objects we ensure that we mark any that are\n-        \/\/ still pointed to be roots. During concurrent marking, and\n-        \/\/ after concurrent start, we don't need to mark any objects\n-        \/\/ explicitly and all objects in the CSet are considered\n-        \/\/ (implicitly) live. So, we won't mark them explicitly and\n-        \/\/ we'll leave them over NTAMS.\n-        _cm->mark_in_next_bitmap(_worker_id, _hr, obj);\n-      }\n-      size_t obj_size = obj->size();\n+    zap_dead_objects(_last_forwarded_object_end, obj_addr);\n+    \/\/ We consider all objects that we find self-forwarded to be\n+    \/\/ live. What we'll do is that we'll update the prev marking\n+    \/\/ info so that they are all under PTAMS and explicitly marked.\n+    if (!_cm->is_marked_in_prev_bitmap(obj)) {\n+      _cm->mark_in_prev_bitmap(obj);\n+    }\n+    if (_during_concurrent_start) {\n+      \/\/ For the next marking info we'll only mark the\n+      \/\/ self-forwarded objects explicitly if we are during\n+      \/\/ concurrent start (since, normally, we only mark objects pointed\n+      \/\/ to by roots if we succeed in copying them). By marking all\n+      \/\/ self-forwarded objects we ensure that we mark any that are\n+      \/\/ still pointed to be roots. During concurrent marking, and\n+      \/\/ after concurrent start, we don't need to mark any objects\n+      \/\/ explicitly and all objects in the CSet are considered\n+      \/\/ (implicitly) live. So, we won't mark them explicitly and\n+      \/\/ we'll leave them over NTAMS.\n+      _cm->mark_in_next_bitmap(_worker_id, _hr, obj);\n+    }\n+    size_t obj_size = obj->size();\n@@ -98,2 +99,2 @@\n-      _marked_bytes += (obj_size * HeapWordSize);\n-      PreservedMarks::init_forwarded_mark(obj);\n+    _marked_words += obj_size;\n+    PreservedMarks::init_forwarded_mark(obj);\n@@ -101,4 +102,3 @@\n-      HeapWord* obj_end = obj_addr + obj_size;\n-      _last_forwarded_object_end = obj_end;\n-      _hr->alloc_block_in_bot(obj_addr, obj_end);\n-    }\n+    HeapWord* obj_end = obj_addr + obj_size;\n+    _last_forwarded_object_end = obj_end;\n+    _hr->alloc_block_in_bot(obj_addr, obj_end);\n@@ -167,1 +167,2 @@\n-    hr->object_iterate(&rspc);\n+    \/\/ Iterates evac failure objs which are recorded during evacuation.\n+    hr->process_and_drop_evac_failure_objs(&rspc);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":34,"deletions":33,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2021, Huawei and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1EvacFailureObjectsSet.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1SegmentedArray.inline.hpp\"\n+#include \"gc\/g1\/heapRegion.inline.hpp\"\n+#include \"utilities\/quickSort.hpp\"\n+\n+\n+const G1SegmentedArrayAllocOptions G1EvacFailureObjectsSet::_alloc_options =\n+  G1SegmentedArrayAllocOptions((uint)sizeof(OffsetInRegion), BufferLength, UINT_MAX, Alignment);\n+\n+G1SegmentedArrayBufferList<mtGC> G1EvacFailureObjectsSet::_free_buffer_list;\n+\n+#ifdef ASSERT\n+void G1EvacFailureObjectsSet::assert_is_valid_offset(size_t offset) const {\n+  const uint max_offset = 1u << (HeapRegion::LogOfHRGrainBytes - LogHeapWordSize);\n+  assert(offset < max_offset, \"must be, but is \" SIZE_FORMAT, offset);\n+}\n+#endif\n+\n+oop G1EvacFailureObjectsSet::from_offset(OffsetInRegion offset) const {\n+  assert_is_valid_offset(offset);\n+  return cast_to_oop(_bottom + offset);\n+}\n+\n+G1EvacFailureObjectsSet::OffsetInRegion G1EvacFailureObjectsSet::to_offset(oop obj) const {\n+  const HeapWord* o = cast_from_oop<const HeapWord*>(obj);\n+  size_t offset = pointer_delta(o, _bottom);\n+  assert(obj == from_offset(static_cast<OffsetInRegion>(offset)), \"must be\");\n+  return static_cast<OffsetInRegion>(offset);\n+}\n+\n+G1EvacFailureObjectsSet::G1EvacFailureObjectsSet(uint region_idx, HeapWord* bottom) :\n+  DEBUG_ONLY(_region_idx(region_idx) COMMA)\n+  _bottom(bottom),\n+  _offsets(&_alloc_options, &_free_buffer_list)  {\n+  assert(HeapRegion::LogOfHRGrainBytes < 32, \"must be\");\n+}\n+\n+\/\/ Helper class to join, sort and iterate over the previously collected segmented\n+\/\/ array of objects that failed evacuation.\n+class G1EvacFailureObjectsIterationHelper {\n+  typedef G1EvacFailureObjectsSet::OffsetInRegion OffsetInRegion;\n+\n+  G1EvacFailureObjectsSet* _objects_set;\n+  const G1SegmentedArray<OffsetInRegion, mtGC>* _segments;\n+  OffsetInRegion* _offset_array;\n+  uint _array_length;\n+\n+  static int order_oop(OffsetInRegion a, OffsetInRegion b) {\n+    return static_cast<int>(a-b);\n+  }\n+\n+  void join_and_sort() {\n+    _segments->iterate_nodes(*this);\n+\n+    QuickSort::sort(_offset_array, _array_length, order_oop, true);\n+  }\n+\n+  void iterate(ObjectClosure* closure) {\n+    for (uint i = 0; i < _array_length; i++) {\n+      oop cur = _objects_set->from_offset(_offset_array[i]);\n+      closure->do_object(cur);\n+    }\n+  }\n+\n+public:\n+  G1EvacFailureObjectsIterationHelper(G1EvacFailureObjectsSet* collector) :\n+    _objects_set(collector),\n+    _segments(&_objects_set->_offsets),\n+    _offset_array(nullptr),\n+    _array_length(0) { }\n+\n+  void process_and_drop(ObjectClosure* closure) {\n+    uint num = _segments->num_allocated_nodes();\n+    _offset_array = NEW_C_HEAP_ARRAY(OffsetInRegion, num, mtGC);\n+\n+    join_and_sort();\n+    assert(_array_length == num, \"must be %u, %u\", _array_length, num);\n+    iterate(closure);\n+\n+    FREE_C_HEAP_ARRAY(OffsetInRegion, _offset_array);\n+  }\n+\n+  \/\/ Callback of G1SegmentedArray::iterate_nodes\n+  void do_buffer(G1SegmentedArrayBuffer<mtGC>* node, uint length) {\n+    node->copy_to(&_offset_array[_array_length]);\n+    _array_length += length;\n+  }\n+};\n+\n+void G1EvacFailureObjectsSet::process_and_drop(ObjectClosure* closure) {\n+  assert_at_safepoint();\n+\n+  G1EvacFailureObjectsIterationHelper helper(this);\n+  helper.process_and_drop(closure);\n+\n+  _offsets.drop_all();\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureObjectsSet.cpp","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2021, Huawei and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1EVACUATIONFAILUREOBJSINHR_HPP\n+#define SHARE_GC_G1_G1EVACUATIONFAILUREOBJSINHR_HPP\n+\n+#include \"gc\/g1\/g1SegmentedArray.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"oops\/oop.hpp\"\n+\n+class G1EvacFailureObjectsIterationHelper;\n+\n+\/\/ This class collects addresses of objects that failed evacuation in a specific\n+\/\/ heap region.\n+\/\/ Provides sorted iteration of these elements for processing during the remove\n+\/\/ self forwards phase.\n+class G1EvacFailureObjectsSet {\n+  friend class G1EvacFailureObjectsIterationHelper;\n+\n+public:\n+  \/\/ Storage type of an object that failed evacuation within a region. Given\n+  \/\/ heap region size and possible object locations within a region, it is\n+  \/\/ sufficient to use an uint here to save some space instead of full pointers.\n+  typedef uint OffsetInRegion;\n+\n+private:\n+  static const uint BufferLength = 256;\n+  static const uint Alignment = 4;\n+\n+  static const G1SegmentedArrayAllocOptions _alloc_options;\n+\n+  \/\/ This free list is shared among evacuation failure process in all regions.\n+  static G1SegmentedArrayBufferList<mtGC> _free_buffer_list;\n+\n+  DEBUG_ONLY(const uint _region_idx;)\n+\n+  \/\/ Region bottom\n+  const HeapWord* _bottom;\n+\n+  \/\/ Offsets within region containing objects that failed evacuation.\n+  G1SegmentedArray<OffsetInRegion, mtGC> _offsets;\n+\n+  void assert_is_valid_offset(size_t offset) const NOT_DEBUG_RETURN;\n+  \/\/ Converts between an offset within a region and an oop address.\n+  oop from_offset(OffsetInRegion offset) const;\n+  OffsetInRegion to_offset(oop obj) const;\n+\n+public:\n+  G1EvacFailureObjectsSet(uint region_idx, HeapWord* bottom);\n+\n+  \/\/ Record an object that failed evacuation.\n+  inline void record(oop obj);\n+\n+  \/\/ Apply the given ObjectClosure to all objects that failed evacuation and\n+  \/\/ empties the list after processing.\n+  \/\/ Objects are passed in increasing address order.\n+  void process_and_drop(ObjectClosure* closure);\n+};\n+\n+\n+#endif \/\/SHARE_GC_G1_G1EVACUATIONFAILUREOBJSINHR_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureObjectsSet.hpp","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2021, Huawei and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1EVACFAILUREOBJECTSSET_INLINE_HPP\n+#define SHARE_GC_G1_G1EVACFAILUREOBJECTSSET_INLINE_HPP\n+\n+#include \"gc\/g1\/g1EvacFailureObjectsSet.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1SegmentedArray.inline.hpp\"\n+#include \"gc\/g1\/heapRegion.inline.hpp\"\n+\n+void G1EvacFailureObjectsSet::record(oop obj) {\n+  assert(obj != NULL, \"must be\");\n+  assert(_region_idx == G1CollectedHeap::heap()->heap_region_containing(obj)->hrm_index(), \"must be\");\n+  OffsetInRegion* e = _offsets.allocate();\n+  *e = to_offset(obj);\n+}\n+\n+#endif \/\/SHARE_GC_G1_G1EVACFAILUREOBJECTSSET_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureObjectsSet.inline.hpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -59,1 +59,1 @@\n-                                       uint worker_id) {\n+                                       uint worker_id) const {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-                   uint worker_id);\n+                   uint worker_id) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -501,0 +501,5 @@\n+    } else {\n+      \/\/ Currently we only have two destinations and we only need BOT updates for\n+      \/\/ old. If the current allocation was done outside the PLAB this call will\n+      \/\/ have no effect since the _top of the PLAB has not changed.\n+      _plab_allocator->update_bot_for_plab_allocation(dest_attr, word_sz, node_index);\n@@ -610,0 +615,3 @@\n+    \/\/ Records evac failure objs, this will help speed up iteration\n+    \/\/ of these objs later in *remove self forward* phase of post evacuation.\n+    r->record_evac_failure_obj(old);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-  uint scan_chunk_size() const { return (uint)1 << _scan_chunks_shift; }\n+  uint scan_chunk_size_in_cards() const { return (uint)1 << _scan_chunks_shift; }\n@@ -371,1 +371,1 @@\n-  void set_chunk_region_dirty(size_t const region_card_idx) {\n+  void set_chunk_range_dirty(size_t const region_card_idx, size_t const card_length) {\n@@ -373,2 +373,5 @@\n-    for (uint i = 0; i < _scan_chunks_per_region; i++) {\n-      _region_scan_chunks[chunk_idx++] = true;\n+    \/\/ Make sure that all chunks that contain the range are marked. Calculate the\n+    \/\/ chunk of the last card that is actually marked.\n+    size_t const end_chunk = (region_card_idx + card_length - 1) >> _scan_chunks_shift;\n+    for (; chunk_idx <= end_chunk; chunk_idx++) {\n+      _region_scan_chunks[chunk_idx] = true;\n@@ -754,1 +757,1 @@\n-  uint size() const { return _scan_state->scan_chunk_size(); }\n+  uint size() const { return _scan_state->scan_chunk_size_in_cards(); }\n@@ -1211,3 +1214,1 @@\n-      assert(start_card_idx == 0, \"must be\");\n-      assert(length == HeapRegion::CardsPerRegion, \"must be\");\n-      size_t num_dirtied = _ct->mark_range_dirty(_region_base_idx, HeapRegion::CardsPerRegion);\n+      size_t num_dirtied = _ct->mark_range_dirty(_region_base_idx + start_card_idx, length);\n@@ -1215,1 +1216,1 @@\n-      _scan_state->set_chunk_region_dirty(_region_base_idx);\n+      _scan_state->set_chunk_range_dirty(_region_base_idx + start_card_idx, length);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -76,0 +76,11 @@\n+  uint length() const {\n+    \/\/ _next_allocate might grow larger than _num_elems in multi-thread environments\n+    \/\/ due to races.\n+    return MIN2(_next_allocate, _num_elems);\n+  }\n+\n+  \/\/ Copies the (valid) contents of this buffer into the destination.\n+  void copy_to(void* dest) const {\n+    ::memcpy(dest, _buffer, length() * _elem_size);\n+  }\n+\n@@ -192,0 +203,2 @@\n+  DEBUG_ONLY(uint calculate_length() const;)\n+\n@@ -196,1 +209,5 @@\n-  uint num_allocated_nodes() const { return Atomic::load(&_num_allocated_nodes); }\n+  uint num_allocated_nodes() const {\n+    uint allocated = Atomic::load(&_num_allocated_nodes);\n+    assert(calculate_length() == allocated, \"Must be\");\n+    return allocated;\n+  }\n@@ -202,3 +219,1 @@\n-  ~G1SegmentedArray() {\n-    drop_all();\n-  }\n+  ~G1SegmentedArray();\n@@ -213,0 +228,3 @@\n+\n+  template<typename BufferClosure>\n+  void iterate_nodes(BufferClosure& closure) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArray.hpp","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -170,0 +170,5 @@\n+template <class Elem, MEMFLAGS flag>\n+G1SegmentedArray<Elem, flag>::~G1SegmentedArray() {\n+  drop_all();\n+}\n+\n@@ -235,0 +240,36 @@\n+#ifdef ASSERT\n+template <MEMFLAGS flag>\n+class LengthClosure {\n+  uint _total;\n+public:\n+  LengthClosure() : _total(0) {}\n+  void do_buffer(G1SegmentedArrayBuffer<flag>* node, uint limit) {\n+    _total += limit;\n+  }\n+  uint length() const {\n+    return _total;\n+  }\n+};\n+\n+template <class Elem, MEMFLAGS flag>\n+uint G1SegmentedArray<Elem, flag>::calculate_length() const {\n+  LengthClosure<flag> closure;\n+  iterate_nodes(closure);\n+  return closure.length();\n+}\n+#endif\n+\n+template <class Elem, MEMFLAGS flag>\n+template <typename BufferClosure>\n+void G1SegmentedArray<Elem, flag>::iterate_nodes(BufferClosure& closure) const {\n+  G1SegmentedArrayBuffer<flag>* cur = Atomic::load_acquire(&_first);\n+\n+  assert((cur != nullptr) == (_last != nullptr),\n+         \"If there is at least one element, there must be a last one\");\n+\n+  while (cur != nullptr) {\n+    closure.do_buffer(cur, cur->length());\n+    cur = cur->next();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArray.inline.hpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -109,0 +109,4 @@\n+void HeapRegion::process_and_drop_evac_failure_objs(ObjectClosure* closure) {\n+  _evac_failure_objs.process_and_drop(closure);\n+}\n+\n@@ -234,1 +238,0 @@\n-  _par_alloc_lock(Mutex::service-2, \"HeapRegionParAlloc_lock\"),\n@@ -249,1 +252,2 @@\n-  _node_index(G1NUMA::UnknownNodeIndex)\n+  _node_index(G1NUMA::UnknownNodeIndex),\n+  _evac_failure_objs(hrm_index, _bottom)\n@@ -816,0 +820,9 @@\n+\n+void HeapRegion::fill_with_dummy_object(HeapWord* address, size_t word_size, bool zap) {\n+  \/\/ Keep the BOT in sync for old generation regions.\n+  if (is_old()) {\n+    update_bot_at(address, word_size);\n+  }\n+  \/\/ Fill in the object.\n+  CollectedHeap::fill_with_object(address, word_size, zap);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1EvacFailureObjectsSet.hpp\"\n@@ -80,1 +81,1 @@\n-  Mutex _par_alloc_lock;\n+\n@@ -155,12 +156,18 @@\n-  \/\/ Allocation (return NULL if full).  Assumes the caller has established\n-  \/\/ mutually exclusive access to the HeapRegion.\n-  HeapWord* allocate(size_t min_word_size, size_t desired_word_size, size_t* actual_word_size);\n-  \/\/ Allocation (return NULL if full).  Enforces mutual exclusion internally.\n-  HeapWord* par_allocate(size_t min_word_size, size_t desired_word_size, size_t* actual_word_size);\n-\n-  HeapWord* allocate(size_t word_size);\n-  HeapWord* par_allocate(size_t word_size);\n-\n-  inline HeapWord* par_allocate_no_bot_updates(size_t min_word_size, size_t desired_word_size, size_t* word_size);\n-  inline HeapWord* allocate_no_bot_updates(size_t word_size);\n-  inline HeapWord* allocate_no_bot_updates(size_t min_word_size, size_t desired_word_size, size_t* actual_size);\n+  \/\/ At the given address create an object with the given size. If the region\n+  \/\/ is old the BOT will be updated if the object spans a threshold.\n+  void fill_with_dummy_object(HeapWord* address, size_t word_size, bool zap = true);\n+\n+  \/\/ All allocations are done without updating the BOT. The BOT\n+  \/\/ needs to be kept in sync for old generation regions and\n+  \/\/ this is done by explicit updates when crossing thresholds.\n+  inline HeapWord* par_allocate(size_t min_word_size, size_t desired_word_size, size_t* word_size);\n+  inline HeapWord* allocate(size_t word_size);\n+  inline HeapWord* allocate(size_t min_word_size, size_t desired_word_size, size_t* actual_size);\n+\n+  \/\/ Update the BOT for the given address if it crosses the next\n+  \/\/ BOT threshold at or after obj_start.\n+  inline void update_bot_at(HeapWord* obj_start, size_t obj_size);\n+  \/\/ Update BOT at the given threshold for the given object. The\n+  \/\/ given object must cross the threshold.\n+  inline void update_bot_crossing_threshold(HeapWord** threshold, HeapWord* obj_start, HeapWord* obj_end);\n+  inline HeapWord* bot_threshold_for_addr(const void* addr);\n@@ -203,0 +210,4 @@\n+  void update_bot_threshold() {\n+    _bot_part.set_threshold(top());\n+  }\n+\n@@ -261,0 +272,2 @@\n+  G1EvacFailureObjectsSet _evac_failure_objs;\n+\n@@ -557,0 +570,5 @@\n+  \/\/ Record an object that failed evacuation within this region.\n+  void record_evac_failure_obj(oop obj);\n+  \/\/ Applies the given closure to all previously recorded objects\n+  \/\/ that failed evacuation in ascending address order.\n+  void process_and_drop_evac_failure_objs(ObjectClosure* closure);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":31,"deletions":13,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/g1\/g1EvacFailureObjectsSet.inline.hpp\"\n@@ -34,0 +35,1 @@\n+#include \"gc\/g1\/g1SegmentedArray.inline.hpp\"\n@@ -81,30 +83,0 @@\n-inline HeapWord* HeapRegion::allocate(size_t min_word_size,\n-                                      size_t desired_word_size,\n-                                      size_t* actual_size) {\n-  HeapWord* res = allocate_impl(min_word_size, desired_word_size, actual_size);\n-  if (res != NULL) {\n-    _bot_part.alloc_block(res, *actual_size);\n-  }\n-  return res;\n-}\n-\n-inline HeapWord* HeapRegion::allocate(size_t word_size) {\n-  size_t temp;\n-  return allocate(word_size, word_size, &temp);\n-}\n-\n-inline HeapWord* HeapRegion::par_allocate(size_t word_size) {\n-  size_t temp;\n-  return par_allocate(word_size, word_size, &temp);\n-}\n-\n-\/\/ Because of the requirement of keeping \"_offsets\" up to date with the\n-\/\/ allocations, we sequentialize these with a lock.  Therefore, best if\n-\/\/ this is used for larger LAB allocations only.\n-inline HeapWord* HeapRegion::par_allocate(size_t min_word_size,\n-                                          size_t desired_word_size,\n-                                          size_t* actual_size) {\n-  MutexLocker x(&_par_alloc_lock, Mutex::_no_safepoint_check_flag);\n-  return allocate(min_word_size, desired_word_size, actual_size);\n-}\n-\n@@ -254,4 +226,3 @@\n-inline HeapWord* HeapRegion::par_allocate_no_bot_updates(size_t min_word_size,\n-                                                         size_t desired_word_size,\n-                                                         size_t* actual_word_size) {\n-  assert(is_young(), \"we can only skip BOT updates on young regions\");\n+inline HeapWord* HeapRegion::par_allocate(size_t min_word_size,\n+                                          size_t desired_word_size,\n+                                          size_t* actual_word_size) {\n@@ -261,1 +232,1 @@\n-inline HeapWord* HeapRegion::allocate_no_bot_updates(size_t word_size) {\n+inline HeapWord* HeapRegion::allocate(size_t word_size) {\n@@ -263,1 +234,1 @@\n-  return allocate_no_bot_updates(word_size, word_size, &temp);\n+  return allocate(word_size, word_size, &temp);\n@@ -266,4 +237,3 @@\n-inline HeapWord* HeapRegion::allocate_no_bot_updates(size_t min_word_size,\n-                                                     size_t desired_word_size,\n-                                                     size_t* actual_word_size) {\n-  assert(is_young(), \"we can only skip BOT updates on young regions\");\n+inline HeapWord* HeapRegion::allocate(size_t min_word_size,\n+                                      size_t desired_word_size,\n+                                      size_t* actual_word_size) {\n@@ -273,0 +243,29 @@\n+inline HeapWord* HeapRegion::bot_threshold_for_addr(const void* addr) {\n+  HeapWord* threshold = _bot_part.threshold_for_addr(addr);\n+  assert(threshold >= addr,\n+         \"threshold must be at or after given address. \" PTR_FORMAT \" >= \" PTR_FORMAT,\n+         p2i(threshold), p2i(addr));\n+  assert(is_old(),\n+         \"Should only calculate BOT threshold for old regions. addr: \" PTR_FORMAT \" region:\" HR_FORMAT,\n+         p2i(addr), HR_FORMAT_PARAMS(this));\n+  return threshold;\n+}\n+\n+inline void HeapRegion::update_bot_crossing_threshold(HeapWord** threshold, HeapWord* obj_start, HeapWord* obj_end) {\n+  assert(is_old(), \"should only do BOT updates for old regions\");\n+  assert(is_in(obj_start), \"obj_start must be in this region: \" HR_FORMAT\n+         \" obj_start \" PTR_FORMAT \" obj_end \" PTR_FORMAT \" threshold \" PTR_FORMAT,\n+         HR_FORMAT_PARAMS(this),\n+         p2i(obj_start), p2i(obj_end), p2i(*threshold));\n+  _bot_part.alloc_block_work(threshold, obj_start, obj_end);\n+}\n+\n+inline void HeapRegion::update_bot_at(HeapWord* obj_start, size_t obj_size) {\n+  HeapWord* threshold = bot_threshold_for_addr(obj_start);\n+  HeapWord* obj_end = obj_start + obj_size;\n+\n+  if (obj_end > threshold) {\n+    update_bot_crossing_threshold(&threshold, obj_start, obj_end);\n+  }\n+}\n+\n@@ -453,0 +452,4 @@\n+inline void HeapRegion::record_evac_failure_obj(oop obj) {\n+  _evac_failure_objs.record(obj);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":43,"deletions":40,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -596,4 +596,0 @@\n-    \/\/ However, if the iteration is specified as concurrent, the values for\n-    \/\/ is_starts_humongous and is_continues_humongous can not be trusted,\n-    \/\/ and we should just blindly iterate over regions regardless of their\n-    \/\/ humongous status.\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionManager.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -133,1 +134,1 @@\n-  assert(_phases->length() <= 1000, \"Too many recorded phases? (count: %d)\", _phases->length());\n+  assert(UseZGC || _phases->length() <= 1000, \"Too many recorded phases? (count: %d)\", _phases->length());\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTimer.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-      SharedRuntime::dtrace_object_alloc(obj(), (int)word_size);\n+      SharedRuntime::dtrace_object_alloc(Thread::current(), obj(), word_size);\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-  void set_buf(HeapWord* buf, size_t new_word_sz) {\n+  virtual void set_buf(HeapWord* buf, size_t new_word_sz) {\n","filename":"src\/hotspot\/share\/gc\/shared\/plab.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"utilities\/align.hpp\"\n@@ -67,3 +68,3 @@\n-  \/\/ Chunk size should be at least (unmodified) page size as using multiple threads\n-  \/\/ pretouch on a single page can decrease performance.\n-  size_t chunk_size = MAX2(PretouchTask::chunk_size(), page_size);\n+  \/\/ Page-align the chunk size, so if start_address is also page-aligned (as\n+  \/\/ is common) then there won't be any pages shared by multiple chunks.\n+  size_t chunk_size = align_down_bounded(PretouchTask::chunk_size(), page_size);\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-  assert_locked_or_safepoint(CodeCache_lock);\n+  assert(CodeCache_lock->owned_by_self(), \"Must have CodeCache_lock held\");\n@@ -124,1 +124,1 @@\n-  assert_locked_or_safepoint(CodeCache_lock);\n+  assert(CodeCache_lock->owned_by_self(), \"Must have CodeCache_lock held\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -274,1 +274,0 @@\n-  ShenandoahReentrantLocker data_locker(data != NULL ? data->lock() : NULL);\n@@ -279,0 +278,3 @@\n+    \/\/ Prevent updating a nmethod while concurrent iteration is in progress.\n+    wait_until_concurrent_iteration_done();\n+    ShenandoahReentrantLocker data_locker(data->lock());\n@@ -281,0 +283,2 @@\n+    \/\/ For a new nmethod, we can safely append it to the list, because\n+    \/\/ concurrent iteration will not touch it.\n@@ -385,0 +389,1 @@\n+  assert(CodeCache_lock->owned_by_self(), \"Must have CodeCache_lock held\");\n@@ -390,0 +395,1 @@\n+  assert(CodeCache_lock->owned_by_self(), \"Must have CodeCache_lock held\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  unsigned int _base_archive_path_offset; \/\/ offset where the base archive name is stored\n+  unsigned int _base_archive_name_offset; \/\/ offset where the base archive name is stored\n@@ -75,1 +75,1 @@\n-                                          \/\/       (char*)this + _base_archive_path_offset\n+                                          \/\/       (char*)this + _base_archive_name_offset\n","filename":"src\/hotspot\/share\/include\/cds.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -267,6 +267,0 @@\n-  if (Settings::uncommit_free_chunks() &&\n-      c->word_size() >= Settings::commit_granule_words()) {\n-    UL2(debug, \"uncommitting free chunk \" METACHUNK_FORMAT \".\", METACHUNK_FORMAT_ARGS(c));\n-    c->uncommit_locked();\n-  }\n-\n","filename":"src\/hotspot\/share\/memory\/metaspace\/chunkManager.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -731,1 +731,0 @@\n-\/\/ To remove these from requires an incompatible change and CSR review.\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-    unsigned addr_bits = (unsigned)((uintptr_t)this >> (LogBytesPerWord + 3));\n+    unsigned addr_bits = (unsigned)((uintptr_t)this >> LogBytesPerWord);\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -908,1 +908,1 @@\n-        \/\/ Fall-thru case in succs[0], so flip targets in succs map\n+        \/\/ Fall-thru case in succs[0], should be in succs[1], so flip targets in _succs map\n@@ -914,4 +914,1 @@\n-        ProjNode* tmp = proj0;\n-        proj0 = proj1;\n-        proj1 = tmp;\n-\n+        swap(proj0, proj1);\n@@ -1651,2 +1648,1 @@\n-\/\/ Order the sequence of the traces in some desirable way, and fixup the\n-\/\/ jumps at the end of each block.\n+\/\/ Order the sequence of the traces in some desirable way\n@@ -1674,1 +1670,1 @@\n-  \/\/ Patch up the successor blocks\n+  \/\/ Collect all blocks from existing Traces\n@@ -1679,1 +1675,4 @@\n-      tr->fixup_blocks(_cfg);\n+      \/\/ push blocks onto the CFG list\n+      for (Block* b = tr->first_block(); b != NULL; b = tr->next(b)) {\n+        _cfg.add_block(b);\n+      }\n@@ -1785,37 +1784,0 @@\n-\n-\/\/ push blocks onto the CFG list\n-\/\/ ensure that blocks have the correct two-way branch sense\n-void Trace::fixup_blocks(PhaseCFG &cfg) {\n-  Block *last = last_block();\n-  for (Block *b = first_block(); b != NULL; b = next(b)) {\n-    cfg.add_block(b);\n-    if (!b->is_connector()) {\n-      int nfallthru = b->num_fall_throughs();\n-      if (b != last) {\n-        if (nfallthru == 2) {\n-          \/\/ Ensure that the sense of the branch is correct\n-          Block *bnext = next(b);\n-          Block *bs0 = b->non_connector_successor(0);\n-\n-          MachNode *iff = b->get_node(b->number_of_nodes() - 3)->as_Mach();\n-          ProjNode *proj0 = b->get_node(b->number_of_nodes() - 2)->as_Proj();\n-          ProjNode *proj1 = b->get_node(b->number_of_nodes() - 1)->as_Proj();\n-\n-          if (bnext == bs0) {\n-            \/\/ Fall-thru case in succs[0], should be in succs[1]\n-\n-            \/\/ Flip targets in _succs map\n-            Block *tbs0 = b->_succs[0];\n-            Block *tbs1 = b->_succs[1];\n-            b->_succs.map( 0, tbs1 );\n-            b->_succs.map( 1, tbs0 );\n-\n-            \/\/ Flip projections to match targets\n-            b->map_node(proj1, b->number_of_nodes() - 2);\n-            b->map_node(proj0, b->number_of_nodes() - 1);\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n","filename":"src\/hotspot\/share\/opto\/block.cpp","additions":8,"deletions":46,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -800,2 +800,0 @@\n-  \/\/ Return the block that follows \"b\" in the trace.\n-  Block * next(Block *b) const { return _next_list[b->_pre_order]; }\n@@ -839,0 +837,3 @@\n+  \/\/ Return the block that follows \"b\" in the trace.\n+  Block * next(Block *b) const { return _next_list[b->_pre_order]; }\n+\n@@ -872,2 +873,0 @@\n-  \/\/ Adjust the the blocks in this trace\n-  void fixup_blocks(PhaseCFG &cfg);\n","filename":"src\/hotspot\/share\/opto\/block.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -234,4 +234,0 @@\n-    if (false && r->is_reg() && !r->is_concrete()) {\n-      continue;\n-    }\n-\n@@ -315,3 +311,1 @@\n-            if (b->is_stack() || b->is_concrete() || true ) {\n-              omap->set_oop( b);\n-            }\n+            omap->set_oop(b);\n@@ -320,3 +314,1 @@\n-        if (b->is_stack() || b->is_concrete() || true ) {\n-          omap->set_derived_oop( r, b);\n-        }\n+        omap->set_derived_oop(r, b);\n@@ -350,3 +342,1 @@\n-      if ( callee->is_concrete() || true ) {\n-        omap->set_callee_saved( r, callee);\n-      }\n+      omap->set_callee_saved(r, callee);\n","filename":"src\/hotspot\/share\/opto\/buildOopMap.cpp","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -107,1 +107,2 @@\n-    Compile C(env, target, entry_bci, subsume_loads, do_escape_analysis, eliminate_boxing, do_locks_coarsening, install_code, directive);\n+    Options options(subsume_loads, do_escape_analysis, eliminate_boxing, do_locks_coarsening, install_code);\n+    Compile C(env, target, entry_bci, options, directive);\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -678,6 +678,7 @@\n-    if (is_boxing_late_inline() && callprojs.resproj != nullptr) {\n-        \/\/ replace box node to scalar node only in case it is directly referenced by debug info\n-        assert(call->as_CallStaticJava()->is_boxing_method(), \"sanity\");\n-        if (!has_non_debug_usages(callprojs.resproj) && is_box_cache_valid(call)) {\n-          scalarize_debug_usages(call, callprojs.resproj);\n-        }\n+    \/\/ Disabled due to JDK-8276112\n+    if (false && is_boxing_late_inline() && callprojs.resproj != nullptr) {\n+      \/\/ replace box node to scalar node only in case it is directly referenced by debug info\n+      assert(call->as_CallStaticJava()->is_boxing_method(), \"sanity\");\n+      if (!has_non_debug_usages(callprojs.resproj) && is_box_cache_valid(call)) {\n+        scalarize_debug_usages(call, callprojs.resproj);\n+      }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1369,1 +1369,2 @@\n-  if (true_path != 0) {\n+  \/\/ Delay CMove'ing identity if Ideal has not had the chance to handle unsafe cases, yet.\n+  if (true_path != 0 && !(phase->is_IterGVN() && wait_for_region_igvn(phase))) {\n@@ -1371,1 +1372,3 @@\n-    if (id != NULL)  return id;\n+    if (id != NULL) {\n+      return id;\n+    }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -490,1 +490,1 @@\n-  if (_subsume_loads == false && PrintOpto) {\n+  if (!subsume_loads() && PrintOpto) {\n@@ -496,1 +496,1 @@\n-  if (_do_escape_analysis != DoEscapeAnalysis && PrintOpto) {\n+  if ((do_escape_analysis() != DoEscapeAnalysis) && PrintOpto) {\n@@ -502,1 +502,1 @@\n-  if (_eliminate_boxing != EliminateAutoBox && PrintOpto) {\n+  if ((eliminate_boxing() != EliminateAutoBox) && PrintOpto) {\n@@ -508,1 +508,1 @@\n-  if ((_do_locks_coarsening != EliminateLocks) && PrintOpto) {\n+  if ((do_locks_coarsening() != EliminateLocks) && PrintOpto) {\n@@ -541,2 +541,1 @@\n-                  bool subsume_loads, bool do_escape_analysis, bool eliminate_boxing,\n-                  bool do_locks_coarsening, bool install_code, DirectiveSet* directive)\n+                  Options options, DirectiveSet* directive)\n@@ -545,5 +544,1 @@\n-                  _subsume_loads(subsume_loads),\n-                  _do_escape_analysis(do_escape_analysis),\n-                  _install_code(install_code),\n-                  _eliminate_boxing(eliminate_boxing),\n-                  _do_locks_coarsening(do_locks_coarsening),\n+                  _options(options),\n@@ -848,5 +843,1 @@\n-    _subsume_loads(true),\n-    _do_escape_analysis(false),\n-    _install_code(true),\n-    _eliminate_boxing(false),\n-    _do_locks_coarsening(false),\n+    _options(Options::for_runtime_stub()),\n@@ -1035,1 +1026,1 @@\n-  if (!_do_escape_analysis && aliaslevel == 3)\n+  if (!do_escape_analysis() && aliaslevel == 3) {\n@@ -1037,0 +1028,1 @@\n+  }\n@@ -2161,1 +2153,1 @@\n-  if (_do_escape_analysis && ConnectionGraph::has_candidates(this)) {\n+  if (do_escape_analysis() && ConnectionGraph::has_candidates(this)) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":10,"deletions":18,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -165,0 +165,31 @@\n+class Options {\n+  friend class Compile;\n+  friend class VMStructs;\n+ private:\n+  const bool _subsume_loads;         \/\/ Load can be matched as part of a larger op.\n+  const bool _do_escape_analysis;    \/\/ Do escape analysis.\n+  const bool _eliminate_boxing;      \/\/ Do boxing elimination.\n+  const bool _do_locks_coarsening;   \/\/ Do locks coarsening\n+  const bool _install_code;          \/\/ Install the code that was compiled\n+ public:\n+  Options(bool subsume_loads, bool do_escape_analysis,\n+          bool eliminate_boxing, bool do_locks_coarsening,\n+          bool install_code) :\n+          _subsume_loads(subsume_loads),\n+          _do_escape_analysis(do_escape_analysis),\n+          _eliminate_boxing(eliminate_boxing),\n+          _do_locks_coarsening(do_locks_coarsening),\n+          _install_code(install_code) {\n+  }\n+\n+  static Options for_runtime_stub() {\n+    return Options(\n+       \/* subsume_loads = *\/ true,\n+       \/* do_escape_analysis = *\/ false,\n+       \/* eliminate_boxing = *\/ false,\n+       \/* do_lock_coarsening = *\/ false,\n+       \/* install_code = *\/ true\n+    );\n+  }\n+};\n+\n@@ -249,5 +280,1 @@\n-  const bool            _subsume_loads;         \/\/ Load can be matched as part of a larger op.\n-  const bool            _do_escape_analysis;    \/\/ Do escape analysis.\n-  const bool            _install_code;          \/\/ Install the code that was compiled\n-  const bool            _eliminate_boxing;      \/\/ Do boxing elimination.\n-  const bool            _do_locks_coarsening;   \/\/ Do locks coarsening\n+  const Options         _options;               \/\/ Compilation options\n@@ -505,1 +532,1 @@\n-  bool              subsume_loads() const       { return _subsume_loads; }\n+  bool              subsume_loads() const       { return _options._subsume_loads; }\n@@ -507,1 +534,1 @@\n-  bool              do_escape_analysis() const  { return _do_escape_analysis; }\n+  bool              do_escape_analysis() const  { return _options._do_escape_analysis; }\n@@ -509,1 +536,1 @@\n-  bool              eliminate_boxing() const    { return _eliminate_boxing; }\n+  bool              eliminate_boxing() const    { return _options._eliminate_boxing; }\n@@ -511,2 +538,2 @@\n-  bool              aggressive_unboxing() const { return _eliminate_boxing && AggressiveUnboxing; }\n-  bool              should_install_code() const { return _install_code; }\n+  bool              aggressive_unboxing() const { return _options._eliminate_boxing && AggressiveUnboxing; }\n+  bool              should_install_code() const { return _options._install_code; }\n@@ -514,1 +541,1 @@\n-  bool              do_locks_coarsening() const { return _do_locks_coarsening; }\n+  bool              do_locks_coarsening() const { return _options._do_locks_coarsening; }\n@@ -1031,3 +1058,1 @@\n-          int entry_bci, bool subsume_loads, bool do_escape_analysis,\n-          bool eliminate_boxing, bool do_locks_coarsening,\n-          bool install_code, DirectiveSet* directive);\n+          int entry_bci, Options options, DirectiveSet* directive);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":39,"deletions":14,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -1724,0 +1724,10 @@\n+    if (in(0)->is_BaseCountedLoopEnd()) {\n+      \/\/ CountedLoopEndNode may be eliminated by if subsuming, replace CountedLoopNode with LoopNode to\n+      \/\/ avoid mismatching between CountedLoopNode and CountedLoopEndNode in the following optimization.\n+      Node* head = unique_ctrl_out();\n+      if (head != NULL && head->is_BaseCountedLoop() && head->in(LoopNode::LoopBackControl) == this) {\n+        Node* new_head = new LoopNode(head->in(LoopNode::EntryControl), this);\n+        phase->is_IterGVN()->register_new_node_with_optimizer(new_head);\n+        phase->is_IterGVN()->replace_node(head, new_head);\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -805,1 +805,1 @@\n-                                       Node* range, bool upper, bool &overflow) {\n+                                       Node* range, bool upper, bool &overflow, bool negate) {\n@@ -931,1 +931,1 @@\n-  BoolNode* bol = new BoolNode(cmp, BoolTest::lt);\n+  BoolNode* bol = new BoolNode(cmp, negate ? BoolTest::ge : BoolTest::lt);\n@@ -1298,0 +1298,1 @@\n+    bool negate = (proj->_con != predicate_proj->_con);\n@@ -1300,8 +1301,2 @@\n-    BoolNode* lower_bound_bol = rc_predicate(loop, ctrl, scale, offset, init, limit, stride, rng, false, overflow);\n-    \/\/ Negate test if necessary\n-    bool negated = false;\n-    if (proj->_con != predicate_proj->_con) {\n-      lower_bound_bol = new BoolNode(lower_bound_bol->in(1), lower_bound_bol->_test.negate());\n-      register_new_node(lower_bound_bol, ctrl);\n-      negated = true;\n-    }\n+    BoolNode* lower_bound_bol = rc_predicate(loop, ctrl, scale, offset, init, limit, stride, rng, false, overflow, negate);\n+\n@@ -1312,1 +1307,1 @@\n-    if (TraceLoopPredicate) tty->print_cr(\"lower bound check if: %s %d \", negated ? \" negated\" : \"\", lower_bound_iff->_idx);\n+    if (TraceLoopPredicate) tty->print_cr(\"lower bound check if: %s %d \", negate ? \" negated\" : \"\", lower_bound_iff->_idx);\n@@ -1315,7 +1310,2 @@\n-    BoolNode* upper_bound_bol = rc_predicate(loop, lower_bound_proj, scale, offset, init, limit, stride, rng, true, overflow);\n-    negated = false;\n-    if (proj->_con != predicate_proj->_con) {\n-      upper_bound_bol = new BoolNode(upper_bound_bol->in(1), upper_bound_bol->_test.negate());\n-      register_new_node(upper_bound_bol, ctrl);\n-      negated = true;\n-    }\n+    BoolNode* upper_bound_bol = rc_predicate(loop, lower_bound_proj, scale, offset, init, limit, stride, rng, true, overflow, negate);\n+\n@@ -1327,1 +1317,1 @@\n-    if (TraceLoopPredicate) tty->print_cr(\"upper bound check if: %s %d \", negated ? \" negated\" : \"\", lower_bound_iff->_idx);\n+    if (TraceLoopPredicate) tty->print_cr(\"upper bound check if: %s %d \", negate ? \" negated\" : \"\", lower_bound_iff->_idx);\n@@ -1373,1 +1363,0 @@\n-  assert(proj->_con && predicate_proj->_con, \"not a range check?\");\n@@ -1376,1 +1365,2 @@\n-  BoolNode* bol = rc_predicate(loop, upper_bound_proj, scale, offset, opaque_init, limit, stride, rng, (stride > 0) != (scale > 0), overflow);\n+  bool negate = (proj->_con != predicate_proj->_con);\n+  BoolNode* bol = rc_predicate(loop, upper_bound_proj, scale, offset, opaque_init, limit, stride, rng, (stride > 0) != (scale > 0), overflow, negate);\n@@ -1394,1 +1384,1 @@\n-  bol = rc_predicate(loop, new_proj, scale, offset, max_value, limit, stride, rng, (stride > 0) != (scale > 0), overflow);\n+  bol = rc_predicate(loop, new_proj, scale, offset, max_value, limit, stride, rng, (stride > 0) != (scale > 0), overflow, negate);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":12,"deletions":22,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2592,1 +2592,1 @@\n-  BoolNode* bol = rc_predicate(loop, predicate_proj, scale_con, offset, value, NULL, stride_con, limit, (stride_con > 0) != (scale_con > 0), overflow);\n+  BoolNode* bol = rc_predicate(loop, predicate_proj, scale_con, offset, value, NULL, stride_con, limit, (stride_con > 0) != (scale_con > 0), overflow, false);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1319,1 +1319,2 @@\n-                         Node* range, bool upper, bool &overflow);\n+                         Node* range, bool upper, bool &overflow,\n+                         bool negate);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1638,1 +1638,2 @@\n-                                          CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc_base),\n+                                          CAST_FROM_FN_PTR(address,\n+                                          static_cast<int (*)(Thread*, oopDesc*)>(SharedRuntime::dtrace_object_alloc)),\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -189,1 +189,0 @@\n-  void copy_call_debug_info(CallNode *oldcall, CallNode * newcall);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2918,0 +2918,10 @@\n+  if (OptoReg::is_reg(def_reg)) {\n+    VMReg vmreg = OptoReg::as_VMReg(def_reg);\n+    if (vmreg->is_reg() && !vmreg->is_concrete() && !vmreg->prev()->is_concrete()) {\n+      \/\/ This is one of the high slots of a vector register.\n+      \/\/ ScheduleAndBundle already checked there are no live wide\n+      \/\/ vectors in this method so it can be safely ignored.\n+      return;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -614,1 +614,1 @@\n-      if (u != NodeSentinel) {    \/\/ Junk Phi.  Remove\n+      if (u != NodeSentinel || phi->outcnt() == 0) {    \/\/ Junk Phi.  Remove\n","filename":"src\/hotspot\/share\/opto\/postaloc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1563,1 +1563,1 @@\n-    Handshake::execute(&op, java_thread);\n+    Handshake::execute(&op, &tlh, java_thread);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -619,2 +619,12 @@\n-  for (JvmtiThreadState *state = JvmtiThreadState::first(); state != NULL; state = state->next()) {\n-    any_env_thread_enabled |= recompute_thread_enabled(state);\n+  JvmtiThreadState *state = JvmtiThreadState::first();\n+  if (state != nullptr) {\n+    \/\/ If we have a JvmtiThreadState, then we've reached the point where\n+    \/\/ threads can exist so create a ThreadsListHandle to protect them.\n+    \/\/ The held JvmtiThreadState_lock prevents exiting JavaThreads from\n+    \/\/ being removed from the JvmtiThreadState list we're about to walk\n+    \/\/ so this ThreadsListHandle exists just to satisfy the lower level sanity\n+    \/\/ checks that the target JavaThreads are protected.\n+    ThreadsListHandle tlh;\n+    for (; state != nullptr; state = state->next()) {\n+      any_env_thread_enabled |= recompute_thread_enabled(state);\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2073,4 +2073,7 @@\n-  oop thread_oop = JNIHandles::resolve(thread_handle);\n-  if (thread_oop != NULL) {\n-    JavaThread* target = java_lang_Thread::thread(thread_oop);\n-    Handshake::execute(&rmc, target);\n+  if (thread_handle != NULL) {\n+    ThreadsListHandle tlh;\n+    JavaThread* target = nullptr;\n+    bool is_alive = tlh.cv_internal_thread_to_JavaThread(thread_handle, &target, NULL);\n+    if (is_alive) {\n+      Handshake::execute(&rmc, &tlh, target);\n+    }\n@@ -2104,5 +2107,6 @@\n-  } else {\n-    oop thread_oop = JNIHandles::resolve(thread_handle);\n-    if (thread_oop != NULL) {\n-      JavaThread* target = java_lang_Thread::thread(thread_oop);\n-      Handshake::execute(&tsc, target);\n+  } else if (thread_handle != NULL) {\n+    ThreadsListHandle tlh;\n+    JavaThread* target = nullptr;\n+    bool is_alive = tlh.cv_internal_thread_to_JavaThread(thread_handle, &target, NULL);\n+    if (is_alive) {\n+      Handshake::execute(&tsc, &tlh, target);\n@@ -2132,5 +2136,8 @@\n-  oop thread_oop = JNIHandles::resolve(thread_handle);\n-  if (thread_oop != NULL) {\n-    JavaThread* target = java_lang_Thread::thread(thread_oop);\n-    TraceSelfClosure* tsc = new TraceSelfClosure(target);\n-    Handshake::execute(tsc, target);\n+  if (thread_handle != NULL) {\n+    ThreadsListHandle tlh;\n+    JavaThread* target = nullptr;\n+    bool is_alive = tlh.cv_internal_thread_to_JavaThread(thread_handle, &target, NULL);\n+    if (is_alive) {\n+      TraceSelfClosure* tsc = new TraceSelfClosure(target);\n+      Handshake::execute(tsc, target);\n+    }\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -345,0 +345,6 @@\n+  \/\/ tlh == nullptr means we rely on a ThreadsListHandle somewhere\n+  \/\/ in the caller's context (and we sanity check for that).\n+  Handshake::execute(hs_cl, nullptr, target);\n+}\n+\n+void Handshake::execute(HandshakeClosure* hs_cl, ThreadsListHandle* tlh, JavaThread* target) {\n@@ -350,2 +356,6 @@\n-  ThreadsListHandle tlh;\n-  if (tlh.includes(target)) {\n+  guarantee(target != nullptr, \"must be\");\n+  if (tlh == nullptr) {\n+    guarantee(Thread::is_JavaThread_protected(target, \/* checkTLHOnly *\/ true),\n+              \"missing ThreadsListHandle in calling context.\");\n+    target->handshake_state()->add_operation(&op);\n+  } else if (tlh->includes(target)) {\n@@ -399,6 +409,8 @@\n-  ThreadsListHandle tlh;\n-  if (tlh.includes(target)) {\n-    target->handshake_state()->add_operation(op);\n-  } else {\n-    log_handshake_info(start_time_ns, op->name(), 0, 0, \"(thread dead)\");\n-    delete op;\n+  guarantee(target != nullptr, \"must be\");\n+\n+  Thread* current = Thread::current();\n+  if (current != target) {\n+    \/\/ Another thread is handling the request and it must be protecting\n+    \/\/ the target.\n+    guarantee(Thread::is_JavaThread_protected(target, \/* checkTLHOnly *\/ true),\n+              \"missing ThreadsListHandle in calling context.\");\n@@ -406,0 +418,4 @@\n+  \/\/ Implied else:\n+  \/\/ The target is handling the request itself so it can't be dead.\n+\n+  target->handshake_state()->add_operation(op);\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+class ThreadsListHandle;\n@@ -67,0 +68,2 @@\n+  \/\/ This version of execute() relies on a ThreadListHandle somewhere in\n+  \/\/ the caller's context to protect target (and we sanity check for that).\n@@ -68,0 +71,7 @@\n+  \/\/ This version of execute() is used when you have a ThreadListHandle in\n+  \/\/ hand and are using it to protect target. If tlh == nullptr, then we\n+  \/\/ sanity check for a ThreadListHandle somewhere in the caller's context\n+  \/\/ to verify that target is protected.\n+  static void execute(HandshakeClosure*       hs_cl, ThreadsListHandle* tlh, JavaThread* target);\n+  \/\/ This version of execute() relies on a ThreadListHandle somewhere in\n+  \/\/ the caller's context to protect target (and we sanity check for that).\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -910,1 +910,1 @@\n-#endif \/\/ HANDLE_FUNCTION_DESCRIPTORS\n+#endif \/\/ HAVE_FUNCTION_DESCRIPTORS\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1004,2 +1004,2 @@\n-int SharedRuntime::dtrace_object_alloc(oopDesc* o, int size) {\n-  return dtrace_object_alloc_base(Thread::current(), o, size);\n+int SharedRuntime::dtrace_object_alloc(oopDesc* o) {\n+  return dtrace_object_alloc(Thread::current(), o, o->size());\n@@ -1008,1 +1008,5 @@\n-int SharedRuntime::dtrace_object_alloc_base(Thread* thread, oopDesc* o, int size) {\n+int SharedRuntime::dtrace_object_alloc(Thread* thread, oopDesc* o) {\n+  return dtrace_object_alloc(thread, o, o->size());\n+}\n+\n+int SharedRuntime::dtrace_object_alloc(Thread* thread, oopDesc* o, size_t size) {\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -274,2 +274,3 @@\n-  static int dtrace_object_alloc(oopDesc* o, int size);\n-  static int dtrace_object_alloc_base(Thread* thread, oopDesc* o, int size);\n+  static int dtrace_object_alloc(oopDesc* o);\n+  static int dtrace_object_alloc(Thread* thread, oopDesc* o);\n+  static int dtrace_object_alloc(Thread* thread, oopDesc* o, size_t size);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -438,9 +438,14 @@\n-\/\/ Is the target JavaThread protected by the calling Thread\n-\/\/ or by some other mechanism:\n-bool Thread::is_JavaThread_protected(const JavaThread* p) {\n-  \/\/ Do the simplest check first:\n-  if (SafepointSynchronize::is_at_safepoint()) {\n-    \/\/ The target is protected since JavaThreads cannot exit\n-    \/\/ while we're at a safepoint.\n-    return true;\n-  }\n+\/\/ Is the target JavaThread protected by the calling Thread or by some other\n+\/\/ mechanism? If checkTLHOnly is true (default is false), then we only check\n+\/\/ if the target JavaThread is protected by a ThreadsList (if any) associated\n+\/\/ with the calling Thread.\n+\/\/\n+bool Thread::is_JavaThread_protected(const JavaThread* p, bool checkTLHOnly) {\n+  Thread* current_thread = Thread::current();\n+  if (!checkTLHOnly) {\n+    \/\/ Do the simplest check first:\n+    if (SafepointSynchronize::is_at_safepoint()) {\n+      \/\/ The target is protected since JavaThreads cannot exit\n+      \/\/ while we're at a safepoint.\n+      return true;\n+    }\n@@ -448,6 +453,6 @@\n-  \/\/ If the target hasn't been started yet then it is trivially\n-  \/\/ \"protected\". We assume the caller is the thread that will do\n-  \/\/ the starting.\n-  if (p->osthread() == NULL || p->osthread()->get_state() <= INITIALIZED) {\n-    return true;\n-  }\n+    \/\/ If the target hasn't been started yet then it is trivially\n+    \/\/ \"protected\". We assume the caller is the thread that will do\n+    \/\/ the starting.\n+    if (p->osthread() == NULL || p->osthread()->get_state() <= INITIALIZED) {\n+      return true;\n+    }\n@@ -455,7 +460,7 @@\n-  \/\/ Now make the simple checks based on who the caller is:\n-  Thread* current_thread = Thread::current();\n-  if (current_thread == p || Threads_lock->owner() == current_thread) {\n-    \/\/ Target JavaThread is self or calling thread owns the Threads_lock.\n-    \/\/ Second check is the same as Threads_lock->owner_is_self(),\n-    \/\/ but we already have the current thread so check directly.\n-    return true;\n+    \/\/ Now make the simple checks based on who the caller is:\n+    if (current_thread == p || Threads_lock->owner() == current_thread) {\n+      \/\/ Target JavaThread is self or calling thread owns the Threads_lock.\n+      \/\/ Second check is the same as Threads_lock->owner_is_self(),\n+      \/\/ but we already have the current thread so check directly.\n+      return true;\n+    }\n@@ -474,4 +479,5 @@\n-  \/\/ Use this debug code with -XX:+UseNewCode to diagnose locations that\n-  \/\/ are missing a ThreadsListHandle or other protection mechanism:\n-  \/\/ guarantee(!UseNewCode, \"current_thread=\" INTPTR_FORMAT \" is not protecting p=\"\n-  \/\/           INTPTR_FORMAT, p2i(current_thread), p2i(p));\n+  if (!checkTLHOnly) {\n+    \/\/ Use this debug code with -XX:+UseNewCode to diagnose locations that\n+    \/\/ are missing a ThreadsListHandle or other protection mechanism:\n+    \/\/ guarantee(!UseNewCode, \"current_thread=\" INTPTR_FORMAT \" is not protecting p=\"\n+    \/\/           INTPTR_FORMAT, p2i(current_thread), p2i(p));\n@@ -479,5 +485,6 @@\n-  \/\/ Note: Since 'p' isn't protected by a TLH, the call to\n-  \/\/ p->is_handshake_safe_for() may crash, but we have debug bits so\n-  \/\/ we'll be able to figure out what protection mechanism is missing.\n-  assert(p->is_handshake_safe_for(current_thread), \"JavaThread=\" INTPTR_FORMAT\n-         \" is not protected and not handshake safe.\", p2i(p));\n+    \/\/ Note: Since 'p' isn't protected by a TLH, the call to\n+    \/\/ p->is_handshake_safe_for() may crash, but we have debug bits so\n+    \/\/ we'll be able to figure out what protection mechanism is missing.\n+    assert(p->is_handshake_safe_for(current_thread), \"JavaThread=\" INTPTR_FORMAT\n+           \" is not protected and not handshake safe.\", p2i(p));\n+  }\n@@ -1746,5 +1753,2 @@\n-  ThreadsListHandle tlh;\n-  if (!tlh.includes(this)) {\n-    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" not on ThreadsList, no suspension\", p2i(this));\n-    return false;\n-  }\n+  guarantee(Thread::is_JavaThread_protected(this, \/* checkTLHOnly *\/ true),\n+            \"missing ThreadsListHandle in calling context.\");\n@@ -1755,5 +1759,2 @@\n-  ThreadsListHandle tlh;\n-  if (!tlh.includes(this)) {\n-    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" not on ThreadsList, nothing to resume\", p2i(this));\n-    return false;\n-  }\n+  guarantee(Thread::is_JavaThread_protected(this, \/* checkTLHOnly *\/ true),\n+            \"missing ThreadsListHandle in calling context.\");\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":42,"deletions":41,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -202,3 +202,5 @@\n-  \/\/ Is the target JavaThread protected by the calling Thread\n-  \/\/ or by some other mechanism:\n-  static bool is_JavaThread_protected(const JavaThread* p);\n+  \/\/ Is the target JavaThread protected by the calling Thread or by some other\n+  \/\/ mechanism? If checkTLHOnly is true (default is false), then we only check\n+  \/\/ if the target JavaThread is protected by a ThreadsList (if any) associated\n+  \/\/ with the calling Thread.\n+  static bool is_JavaThread_protected(const JavaThread* p, bool checkTLHOnly = false);\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -888,3 +888,1 @@\n-  c2_nonstatic_field(Compile,                  _subsume_loads,                                const bool)                            \\\n-  c2_nonstatic_field(Compile,                  _do_escape_analysis,                           const bool)                            \\\n-  c2_nonstatic_field(Compile,                  _eliminate_boxing,                             const bool)                            \\\n+  c2_nonstatic_field(Compile,                  _options,                                      const Options)                         \\\n@@ -893,0 +891,6 @@\n+  c2_nonstatic_field(Options,                  _subsume_loads,                                const bool)                            \\\n+  c2_nonstatic_field(Options,                  _do_escape_analysis,                           const bool)                            \\\n+  c2_nonstatic_field(Options,                  _eliminate_boxing,                             const bool)                            \\\n+  c2_nonstatic_field(Options,                  _do_locks_coarsening,                          const bool)                            \\\n+  c2_nonstatic_field(Options,                  _install_code,                                 const bool)                            \\\n+                                                                                                                                     \\\n@@ -1444,0 +1448,1 @@\n+  declare_c2_toplevel_type(Options)                                       \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -610,1 +610,1 @@\n-  virtual void flush(bool force = false);\n+  void flush(bool force = false) override;\n@@ -617,1 +617,1 @@\n-  virtual julong bytes_written() const          { return (julong) _backend.get_written(); }\n+  julong bytes_written() const override { return (julong) _backend.get_written(); }\n@@ -619,1 +619,1 @@\n-  virtual char const* error() const             { return _backend.error(); }\n+  char const* error() const override    { return _backend.error(); }\n@@ -624,1 +624,1 @@\n-  virtual void deactivate()             { flush(); _backend.deactivate(); }\n+  void deactivate() override            { flush(); _backend.deactivate(); }\n@@ -626,1 +626,1 @@\n-  CompressionBackend* backend_ptr() { return &_backend; }\n+  CompressionBackend* backend_ptr()     { return &_backend; }\n@@ -704,1 +704,1 @@\n-  virtual void flush(bool force = false) {\n+  void flush(bool force = false) override {\n@@ -745,2 +745,2 @@\n-  virtual julong bytes_written() const          { return (julong) _backend_ptr->get_written(); }\n-  virtual char const* error() const { return _err == NULL ? _backend_ptr->error() : _err; }\n+  julong bytes_written() const override { return (julong) _backend_ptr->get_written(); }\n+  char const* error() const override    { return _err == NULL ? _backend_ptr->error() : _err; }\n@@ -760,1 +760,1 @@\n-  virtual void write_raw(const void* s, size_t len) {\n+  void write_raw(const void* s, size_t len) override {\n@@ -781,1 +781,1 @@\n-  virtual void deactivate()             { flush(true); _backend_ptr->deactivate(); }\n+  void deactivate() override { flush(true); _backend_ptr->deactivate(); }\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -223,1 +223,1 @@\n-    public static final String separator = \"\" + separatorChar;\n+    public static final String separator = String.valueOf(separatorChar);\n@@ -242,1 +242,1 @@\n-    public static final String pathSeparator = \"\" + pathSeparatorChar;\n+    public static final String pathSeparator = String.valueOf(pathSeparatorChar);\n","filename":"src\/java.base\/share\/classes\/java\/io\/File.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -293,0 +293,6 @@\n+     * @deprecated This method is error-prone and should not be used, the corresponding method\n+     * {@link #exec(String[])} or {@link ProcessBuilder} should be used instead.\n+     * The command string is broken into tokens using only whitespace characters.\n+     * For an argument with an embedded space, such as a filename, this can cause problems\n+     * as the token does not include the full filename.\n+     *\n@@ -314,0 +320,1 @@\n+    @Deprecated(since=\"18\")\n@@ -327,0 +334,6 @@\n+     * @deprecated This method is error-prone and should not be used, the corresponding method\n+     * {@link #exec(String[], String[])} or {@link ProcessBuilder} should be used instead.\n+     * The command string is broken into tokens using only whitespace characters.\n+     * For an argument with an embedded space, such as a filename, this can cause problems\n+     * as the token does not include the full filename.\n+     *\n@@ -355,0 +368,1 @@\n+    @Deprecated(since=\"18\")\n@@ -377,0 +391,6 @@\n+     * @deprecated This method is error-prone and should not be used, the corresponding method\n+     * {@link #exec(String[], String[], File)} or {@link ProcessBuilder} should be used instead.\n+     * The command string is broken into tokens using only whitespace characters.\n+     * For an argument with an embedded space, such as a filename, this can cause problems\n+     * as the token does not include the full filename.\n+     *\n@@ -409,0 +429,1 @@\n+    @Deprecated(since=\"18\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Runtime.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -381,0 +381,10 @@\n+ * <tr>\n+ *   <th scope=\"row\">inetAddressResolverProvider<\/th>\n+ *   <td>This {@code RuntimePermission} is required to be granted to\n+ *   classes which subclass and implement {@code java.net.spi.InetAddressResolverProvider}.\n+ *   The permission is checked during invocation of the abstract base class constructor.\n+ *   This permission ensures trust in classes which provide resolvers used by\n+ *   {@link java.net.InetAddress} hostname and address resolution methods.<\/td>\n+ *   <td>See {@link java.net.spi.InetAddressResolverProvider} for more information.<\/td>\n+ * <\/tr>\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/RuntimePermission.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1036,7 +1036,0 @@\n-                if (c >= '0' && c <= '9')\n-                    i = takeNumber(v, i, pre);\n-                else\n-                    i = takeString(v, i, pre);\n-                if (i >= n)\n-                    break;\n-                c = v.charAt(i);\n@@ -1051,0 +1044,4 @@\n+                if (c >= '0' && c <= '9')\n+                    i = takeNumber(v, i, pre);\n+                else\n+                    i = takeString(v, i, pre);\n@@ -1058,7 +1055,0 @@\n-                if (c >= '0' && c <= '9')\n-                    i = takeNumber(v, i, build);\n-                else\n-                    i = takeString(v, i, build);\n-                if (i >= n)\n-                    break;\n-                c = v.charAt(i);\n@@ -1069,0 +1059,4 @@\n+                if (c >= '0' && c <= '9')\n+                    i = takeNumber(v, i, build);\n+                else\n+                    i = takeString(v, i, build);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/ModuleDescriptor.java","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import java.net.spi.InetAddressResolver.LookupPolicy;\n+\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV4;\n@@ -35,2 +38,8 @@\n-    public native InetAddress[]\n-        lookupAllHostAddr(String hostname) throws UnknownHostException;\n+    public InetAddress[] lookupAllHostAddr(String hostname, LookupPolicy lookupPolicy)\n+            throws UnknownHostException {\n+        if ((lookupPolicy.characteristics() & IPV4) == 0) {\n+            throw new UnknownHostException(hostname);\n+        }\n+        return lookupAllHostAddr(hostname);\n+    }\n+    private native InetAddress[] lookupAllHostAddr(String hostname) throws UnknownHostException;\n","filename":"src\/java.base\/share\/classes\/java\/net\/Inet4AddressImpl.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.net.spi.InetAddressResolver.LookupPolicy;\n@@ -29,3 +30,1 @@\n-import static java.net.InetAddress.IPv6;\n-import static java.net.InetAddress.PREFER_IPV6_VALUE;\n-import static java.net.InetAddress.PREFER_SYSTEM_VALUE;\n+import static java.net.InetAddress.PLATFORM_LOOKUP_POLICY;\n@@ -51,2 +50,7 @@\n-    public native InetAddress[] lookupAllHostAddr(String hostname)\n-        throws UnknownHostException;\n+    public InetAddress[] lookupAllHostAddr(String hostname, LookupPolicy lookupPolicy)\n+            throws UnknownHostException {\n+        return lookupAllHostAddr(hostname, lookupPolicy.characteristics());\n+    }\n+\n+    private native InetAddress[] lookupAllHostAddr(String hostname, int characteristics)\n+            throws UnknownHostException;\n@@ -99,2 +103,3 @@\n-            if (InetAddress.preferIPv6Address == PREFER_IPV6_VALUE ||\n-                InetAddress.preferIPv6Address == PREFER_SYSTEM_VALUE) {\n+            int flags = PLATFORM_LOOKUP_POLICY.characteristics();\n+            if (InetAddress.ipv6AddressesFirst(flags) ||\n+                InetAddress.systemAddressesOrder(flags)) {\n@@ -112,3 +117,3 @@\n-            boolean preferIPv6Address =\n-                InetAddress.preferIPv6Address == PREFER_IPV6_VALUE ||\n-                InetAddress.preferIPv6Address == PREFER_SYSTEM_VALUE;\n+            int flags = PLATFORM_LOOKUP_POLICY.characteristics();\n+            boolean preferIPv6Address = InetAddress.ipv6AddressesFirst(flags) ||\n+                    InetAddress.systemAddressesOrder(flags);\n","filename":"src\/java.base\/share\/classes\/java\/net\/Inet6AddressImpl.java","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import java.net.spi.InetAddressResolver;\n+import java.net.spi.InetAddressResolverProvider;\n+import java.net.spi.InetAddressResolver.LookupPolicy;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n@@ -43,0 +48,1 @@\n+import java.util.ServiceLoader;\n@@ -48,0 +54,4 @@\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.misc.VM;\n@@ -51,0 +61,2 @@\n+import jdk.internal.vm.annotation.Stable;\n+import sun.net.ResolverProviderConfiguration;\n@@ -56,0 +68,5 @@\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV4;\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV4_FIRST;\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV6;\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV6_FIRST;\n+\n@@ -131,2 +148,2 @@\n- * <P>There is a <a href=\"doc-files\/net-properties.html#Ipv4IPv6\">couple of\n- * System Properties<\/a> affecting how IPv4 and IPv6 addresses are used.<\/P>\n+ * <p> There is a <a href=\"doc-files\/net-properties.html#Ipv4IPv6\">couple of\n+ * System Properties<\/a> affecting how IPv4 and IPv6 addresses are used.\n@@ -134,1 +151,5 @@\n- * <h3> Host Name Resolution <\/h3>\n+ * <h2 id=\"host-name-resolution\"> Host Name Resolution <\/h2>\n+ *\n+ * <p> The InetAddress class provides methods to resolve host names to\n+ * their IP addresses and vice versa. The actual resolution is delegated to an\n+ * {@linkplain InetAddressResolver InetAddress resolver}.\n@@ -136,6 +157,2 @@\n- * Host name-to-IP address <i>resolution<\/i> is accomplished through\n- * the use of a combination of local machine configuration information\n- * and network naming services such as the Domain Name System (DNS)\n- * and Network Information Service(NIS). The particular naming\n- * services(s) being used is by default the local machine configured\n- * one. For any host name, its corresponding IP address is returned.\n+ * <p> <i>Host name-to-IP address resolution<\/i> maps a host name to an IP address.\n+ * For any host name, its corresponding IP address is returned.\n@@ -146,2 +163,12 @@\n- * <p> The InetAddress class provides methods to resolve host names to\n- * their IP addresses and vice versa.\n+ * <p id=\"built-in-resolver\"> The built-in InetAddress resolver implementation does\n+ * host name-to-IP address resolution and vice versa through the use of\n+ * a combination of local machine configuration information and network\n+ * naming services such as the Domain Name System (DNS) and the Lightweight Directory\n+ * Access Protocol (LDAP).\n+ * The particular naming services that the built-in resolver uses by default\n+ * depends on the configuration of the local machine.\n+ *\n+ * <p> {@code InetAddress} has a service provider mechanism for InetAddress resolvers\n+ * that allows a custom InetAddress resolver to be used instead of the built-in implementation.\n+ * {@link InetAddressResolverProvider} is the service provider class. Its API docs provide all the\n+ * details on this mechanism.\n@@ -149,1 +176,1 @@\n- * <h3> InetAddress Caching <\/h3>\n+ * <h2> InetAddress Caching <\/h2>\n@@ -201,4 +228,0 @@\n-    @Native static final int PREFER_IPV4_VALUE = 0;\n-    @Native static final int PREFER_IPV6_VALUE = 1;\n-    @Native static final int PREFER_SYSTEM_VALUE = 2;\n-\n@@ -217,3 +240,0 @@\n-    \/* Specify address family preference *\/\n-    static final transient int preferIPv6Address;\n-\n@@ -291,2 +311,5 @@\n-    \/* Used to store the name service provider *\/\n-    private static transient NameService nameService;\n+    \/* Used to store the system-wide resolver *\/\n+    @Stable\n+    private static volatile InetAddressResolver resolver;\n+\n+    private static final InetAddressResolver BUILTIN_RESOLVER;\n@@ -304,0 +327,9 @@\n+    \/\/ \"java.net.preferIPv4Stack\" system property value\n+    private static final String PREFER_IPV4_STACK_VALUE;\n+\n+    \/\/ \"java.net.preferIPv6Addresses\" system property value\n+    private static final String PREFER_IPV6_ADDRESSES_VALUE;\n+\n+    \/\/ \"jdk.net.hosts.file\" system property value\n+    private static final String HOSTS_FILE_NAME;\n+\n@@ -308,12 +340,6 @@\n-        String str = GetPropertyAction.privilegedGetProperty(\"java.net.preferIPv6Addresses\");\n-        if (str == null) {\n-            preferIPv6Address = PREFER_IPV4_VALUE;\n-        } else if (str.equalsIgnoreCase(\"true\")) {\n-            preferIPv6Address = PREFER_IPV6_VALUE;\n-        } else if (str.equalsIgnoreCase(\"false\")) {\n-            preferIPv6Address = PREFER_IPV4_VALUE;\n-        } else if (str.equalsIgnoreCase(\"system\")) {\n-            preferIPv6Address = PREFER_SYSTEM_VALUE;\n-        } else {\n-            preferIPv6Address = PREFER_IPV4_VALUE;\n-        }\n+        PREFER_IPV4_STACK_VALUE =\n+                GetPropertyAction.privilegedGetProperty(\"java.net.preferIPv4Stack\");\n+        PREFER_IPV6_ADDRESSES_VALUE =\n+                GetPropertyAction.privilegedGetProperty(\"java.net.preferIPv6Addresses\");\n+        HOSTS_FILE_NAME =\n+                GetPropertyAction.privilegedGetProperty(\"jdk.net.hosts.file\");\n@@ -327,7 +353,0 @@\n-                    public InetAddress getByName(String hostName,\n-                                                 InetAddress hostAddress)\n-                        throws UnknownHostException\n-                    {\n-                        return InetAddress.getByName(hostName, hostAddress);\n-                    }\n-\n@@ -346,0 +365,125 @@\n+    \/**\n+     * Creates an address lookup policy from {@code \"java.net.preferIPv4Stack\"},\n+     * {@code \"java.net.preferIPv6Addresses\"} system property values, and O\/S configuration.\n+     *\/\n+    private static final LookupPolicy initializePlatformLookupPolicy() {\n+        \/\/ Calculate AddressFamily value first\n+        boolean ipv4Available = isIPv4Available();\n+        if (\"true\".equals(PREFER_IPV4_STACK_VALUE) && ipv4Available) {\n+            return LookupPolicy.of(IPV4);\n+        }\n+        \/\/ Check if IPv6 is not supported\n+        if (InetAddress.impl instanceof Inet4AddressImpl) {\n+            return LookupPolicy.of(IPV4);\n+        }\n+        \/\/ Check if system supports IPv4, if not use IPv6\n+        if (!ipv4Available) {\n+            return LookupPolicy.of(IPV6);\n+        }\n+        \/\/ If both address families are needed - check preferIPv6Addresses value\n+        if (PREFER_IPV6_ADDRESSES_VALUE != null) {\n+            if (PREFER_IPV6_ADDRESSES_VALUE.equalsIgnoreCase(\"true\")) {\n+                return LookupPolicy.of(IPV4 | IPV6 | IPV6_FIRST);\n+            }\n+            if (PREFER_IPV6_ADDRESSES_VALUE.equalsIgnoreCase(\"false\")) {\n+                return LookupPolicy.of(IPV4 | IPV6 | IPV4_FIRST);\n+            }\n+            if (PREFER_IPV6_ADDRESSES_VALUE.equalsIgnoreCase(\"system\")) {\n+                return LookupPolicy.of(IPV4 | IPV6);\n+            }\n+        }\n+        \/\/ Default value with both address families needed - IPv4 addresses come first\n+        return LookupPolicy.of(IPV4 | IPV6 | IPV4_FIRST);\n+    }\n+\n+    static boolean systemAddressesOrder(int lookupCharacteristics) {\n+        return (lookupCharacteristics & (IPV4_FIRST | IPV6_FIRST)) == 0;\n+    }\n+\n+    static boolean ipv4AddressesFirst(int lookupCharacteristics) {\n+        return (lookupCharacteristics & IPV4_FIRST) != 0;\n+    }\n+\n+    static boolean ipv6AddressesFirst(int lookupCharacteristics) {\n+        return (lookupCharacteristics & IPV6_FIRST) != 0;\n+    }\n+\n+    \/\/ Native method to check if IPv4 is available\n+    private static native boolean isIPv4Available();\n+\n+    \/**\n+     * The {@code RuntimePermission(\"inetAddressResolverProvider\")} is\n+     * necessary to subclass and instantiate the {@code InetAddressResolverProvider}\n+     * class, as well as to obtain resolver from an instance of that class,\n+     * and it is also required to obtain the operating system name resolution configurations.\n+     *\/\n+    private static final RuntimePermission INET_ADDRESS_RESOLVER_PERMISSION =\n+            new RuntimePermission(\"inetAddressResolverProvider\");\n+\n+    private static final ReentrantLock RESOLVER_LOCK = new ReentrantLock();\n+    private static volatile InetAddressResolver bootstrapResolver;\n+\n+    @SuppressWarnings(\"removal\")\n+    private static InetAddressResolver resolver() {\n+        InetAddressResolver cns = resolver;\n+        if (cns != null) {\n+            return cns;\n+        }\n+        if (VM.isBooted()) {\n+            RESOLVER_LOCK.lock();\n+            boolean bootstrapSet = false;\n+            try {\n+                cns = resolver;\n+                if (cns != null) {\n+                    return cns;\n+                }\n+                \/\/ Protection against provider calling InetAddress APIs during initialization\n+                if (bootstrapResolver != null) {\n+                    return bootstrapResolver;\n+                }\n+                bootstrapResolver = BUILTIN_RESOLVER;\n+                bootstrapSet = true;\n+\n+                if (HOSTS_FILE_NAME != null) {\n+                    \/\/ The default resolver service is already host file resolver\n+                    cns = BUILTIN_RESOLVER;\n+                } else if (System.getSecurityManager() != null) {\n+                    PrivilegedAction<InetAddressResolver> pa = InetAddress::loadResolver;\n+                    cns = AccessController.doPrivileged(\n+                            pa, null, INET_ADDRESS_RESOLVER_PERMISSION);\n+                } else {\n+                    cns = loadResolver();\n+                }\n+\n+                InetAddress.resolver = cns;\n+                return cns;\n+            } finally {\n+                \/\/ We want to clear bootstrap resolver reference only after an attempt to\n+                \/\/ instantiate a resolver has been completed.\n+                if (bootstrapSet) {\n+                    bootstrapResolver = null;\n+                }\n+                RESOLVER_LOCK.unlock();\n+            }\n+        } else {\n+            return BUILTIN_RESOLVER;\n+        }\n+    }\n+\n+    private static InetAddressResolver loadResolver() {\n+        return ServiceLoader.load(InetAddressResolverProvider.class)\n+                .findFirst()\n+                .map(nsp -> nsp.get(builtinConfiguration()))\n+                .orElse(BUILTIN_RESOLVER);\n+    }\n+\n+    private static InetAddressResolverProvider.Configuration builtinConfiguration() {\n+        return new ResolverProviderConfiguration(BUILTIN_RESOLVER, () -> {\n+            try {\n+                return impl.getLocalHostName();\n+            } catch (UnknownHostException unknownHostException) {\n+                return \"localhost\";\n+            }\n+        });\n+    }\n+\n@@ -558,1 +702,1 @@\n-     * configured name lookup service. If a lookup of the name service\n+     * configured resolver. If a lookup of the name service\n@@ -659,1 +803,2 @@\n-        String host = null;\n+        String host;\n+        var resolver = resolver();\n@@ -662,1 +807,1 @@\n-            host = nameService.getHostByAddr(addr.getAddress());\n+            host = resolver.lookupByAddress(addr.getAddress());\n@@ -694,1 +839,5 @@\n-        } catch (SecurityException e) {\n+        } catch (RuntimeException | UnknownHostException e) {\n+            \/\/ 'resolver.lookupByAddress' and 'InetAddress.getAllByName0' delegate to\n+            \/\/ the system-wide resolver, which could be a custom one. At that point we\n+            \/\/ treat any unexpected RuntimeException thrown by the resolver as we would\n+            \/\/ treat an UnknownHostException or an unmatched host name.\n@@ -696,3 +845,0 @@\n-        } catch (UnknownHostException e) {\n-            host = addr.getHostAddress();\n-            \/\/ let next provider resolve the hostname\n@@ -758,2 +904,3 @@\n-     * If the host name is unresolved, no reverse name service lookup\n-     * is performed. The hostname part will be represented by an empty string.\n+     * If the host name is unresolved, no reverse lookup\n+     * is performed. The hostname part will be represented\n+     * by an empty string.\n@@ -824,1 +971,0 @@\n-        private final InetAddress reqAddr;\n@@ -826,1 +972,1 @@\n-        NameServiceAddresses(String host, InetAddress reqAddr) {\n+        NameServiceAddresses(String host) {\n@@ -828,1 +974,0 @@\n-            this.reqAddr = reqAddr;\n@@ -852,1 +997,1 @@\n-                        inetAddresses = getAddressesFromNameService(host, reqAddr);\n+                        inetAddresses = getAddressesFromNameService(host);\n@@ -878,1 +1023,1 @@\n-                    if (inetAddresses == null) {\n+                    if (inetAddresses == null || inetAddresses.length == 0) {\n@@ -892,32 +1037,1 @@\n-     * NameService provides host and address lookup service\n-     *\n-     * @since 9\n-     *\/\n-    private interface NameService {\n-\n-        \/**\n-         * Lookup a host mapping by name. Retrieve the IP addresses\n-         * associated with a host\n-         *\n-         * @param host the specified hostname\n-         * @return array of IP addresses for the requested host\n-         * @throws UnknownHostException\n-         *             if no IP address for the {@code host} could be found\n-         *\/\n-        InetAddress[] lookupAllHostAddr(String host)\n-                throws UnknownHostException;\n-\n-        \/**\n-         * Lookup the host corresponding to the IP address provided\n-         *\n-         * @param addr byte array representing an IP address\n-         * @return {@code String} representing the host name mapping\n-         * @throws UnknownHostException\n-         *             if no host found for the specified IP address\n-         *\/\n-        String getHostByAddr(byte[] addr) throws UnknownHostException;\n-\n-    }\n-\n-    \/**\n-     * The default NameService implementation, which delegates to the underlying\n+     * The default InetAddressResolver implementation, which delegates to the underlying\n@@ -928,1 +1042,1 @@\n-    private static final class PlatformNameService implements NameService {\n+    private static final class PlatformResolver implements InetAddressResolver {\n@@ -930,4 +1044,5 @@\n-        public InetAddress[] lookupAllHostAddr(String host)\n-            throws UnknownHostException\n-        {\n-            return impl.lookupAllHostAddr(host);\n+        public Stream<InetAddress> lookupByName(String host, LookupPolicy policy)\n+                throws UnknownHostException {\n+            Objects.requireNonNull(host);\n+            Objects.requireNonNull(policy);\n+            return Arrays.stream(impl.lookupAllHostAddr(host, policy));\n@@ -936,3 +1051,6 @@\n-        public String getHostByAddr(byte[] addr)\n-            throws UnknownHostException\n-        {\n+        public String lookupByAddress(byte[] addr)\n+                throws UnknownHostException {\n+            Objects.requireNonNull(addr);\n+            if (addr.length != Inet4Address.INADDRSZ && addr.length != Inet6Address.INADDRSZ) {\n+                throw new IllegalArgumentException(\"Invalid address length\");\n+            }\n@@ -944,1 +1062,1 @@\n-     * The HostsFileNameService provides host address mapping\n+     * The HostsFileResolver provides host address mapping\n@@ -951,1 +1069,1 @@\n-     * <p>When the file lookup is enabled it replaces the default NameService\n+     * <p>When the file lookup is enabled it replaces the default InetAddressResolver\n@@ -956,7 +1074,1 @@\n-    private static final class HostsFileNameService implements NameService {\n-\n-        private static final InetAddress[] EMPTY_ARRAY = new InetAddress[0];\n-\n-        \/\/ Specify if only IPv4 addresses should be returned by HostsFileService implementation\n-        private static final boolean preferIPv4Stack = Boolean.parseBoolean(\n-                GetPropertyAction.privilegedGetProperty(\"java.net.preferIPv4Stack\"));\n+    private static final class HostsFileResolver implements InetAddressResolver {\n@@ -966,1 +1078,1 @@\n-        public HostsFileNameService(String hostsFileName) {\n+        public HostsFileResolver(String hostsFileName) {\n@@ -977,2 +1089,3 @@\n-         * @throws UnknownHostException\n-         *             if no host found for the specified IP address\n+         * @throws UnknownHostException if no host found for the specified IP address\n+         * @throws IllegalArgumentException if IP address is of illegal length\n+         * @throws NullPointerException     if addr is {@code null}\n@@ -981,1 +1094,1 @@\n-        public String getHostByAddr(byte[] addr) throws UnknownHostException {\n+        public String lookupByAddress(byte[] addr) throws UnknownHostException {\n@@ -984,0 +1097,5 @@\n+            Objects.requireNonNull(addr);\n+            \/\/ Check the length of the address array\n+            if (addr.length != Inet4Address.INADDRSZ && addr.length != Inet6Address.INADDRSZ) {\n+                throw new IllegalArgumentException(\"Invalid address length\");\n+            }\n@@ -986,2 +1104,1 @@\n-                                                        UTF_8.INSTANCE))\n-            {\n+                                                        UTF_8.INSTANCE)) {\n@@ -1023,1 +1140,4 @@\n-         * @return array of IP addresses for the requested host\n+         * @param lookupPolicy IP addresses lookup policy which specifies addresses\n+         *                     family and their order\n+         * @return stream of IP addresses for the requested host\n+         * @throws NullPointerException if either parameter is {@code null}\n@@ -1027,1 +1147,1 @@\n-        public InetAddress[] lookupAllHostAddr(String host)\n+        public Stream<InetAddress> lookupByName(String host, LookupPolicy lookupPolicy)\n@@ -1032,0 +1152,3 @@\n+\n+            Objects.requireNonNull(host);\n+            Objects.requireNonNull(lookupPolicy);\n@@ -1035,0 +1158,3 @@\n+            int flags = lookupPolicy.characteristics();\n+            boolean needIPv4 = (flags & IPv4) != 0;\n+            boolean needIPv6 = (flags & IPv6) != 0;\n@@ -1038,1 +1164,1 @@\n-                                                        UTF_8.INSTANCE)) {\n+                    UTF_8.INSTANCE)) {\n@@ -1050,1 +1176,1 @@\n-                                    if (address instanceof Inet4Address) {\n+                                    if (address instanceof Inet4Address && needIPv4) {\n@@ -1053,1 +1179,1 @@\n-                                    if (address instanceof Inet6Address) {\n+                                    if (address instanceof Inet6Address && needIPv6) {\n@@ -1065,13 +1191,4 @@\n-\n-            List<InetAddress> res;\n-            \/\/ If \"preferIPv4Stack\" system property is set to \"true\" then return\n-            \/\/ only IPv4 addresses\n-            if (preferIPv4Stack) {\n-                res = inet4Addresses;\n-            } else {\n-                \/\/ Otherwise, analyse \"preferIPv6Addresses\" value\n-                res = switch (preferIPv6Address) {\n-                    case PREFER_IPV4_VALUE -> concatAddresses(inet4Addresses, inet6Addresses);\n-                    case PREFER_IPV6_VALUE -> concatAddresses(inet6Addresses, inet4Addresses);\n-                    default -> inetAddresses;\n-                };\n+            \/\/ Check if only IPv4 addresses are requested\n+            if (needIPv4 && !needIPv6) {\n+                checkResultsList(inet4Addresses, host);\n+                return inet4Addresses.stream();\n@@ -1079,4 +1196,4 @@\n-\n-            if (res.isEmpty()) {\n-                throw new UnknownHostException(\"Unable to resolve host \" + host\n-                        + \" in hosts file \" + hostsFile);\n+            \/\/ Check if only IPv6 addresses are requested\n+            if (!needIPv4 && needIPv6) {\n+                checkResultsList(inet6Addresses, host);\n+                return inet6Addresses.stream();\n@@ -1084,1 +1201,12 @@\n-            return res.toArray(EMPTY_ARRAY);\n+            \/\/ If both type of addresses are requested:\n+            \/\/ First, check if there is any results. Then arrange\n+            \/\/ addresses according to LookupPolicy value.\n+            checkResultsList(inetAddresses, host);\n+            if (ipv6AddressesFirst(flags)) {\n+                return Stream.concat(inet6Addresses.stream(), inet4Addresses.stream());\n+            } else if (ipv4AddressesFirst(flags)) {\n+                return Stream.concat(inet4Addresses.stream(), inet6Addresses.stream());\n+            }\n+            \/\/ Only \"system\" addresses order is possible at this stage\n+            assert systemAddressesOrder(flags);\n+            return inetAddresses.stream();\n@@ -1087,5 +1215,8 @@\n-        private static List<InetAddress> concatAddresses(List<InetAddress> firstPart,\n-                                                         List<InetAddress> secondPart) {\n-            List<InetAddress> result = new ArrayList<>(firstPart);\n-            result.addAll(secondPart);\n-            return result;\n+        \/\/ Checks if result list with addresses is not empty.\n+        \/\/ If it is empty throw an UnknownHostException.\n+        private void checkResultsList(List<InetAddress> addressesList, String hostName)\n+                throws UnknownHostException {\n+            if (addressesList.isEmpty()) {\n+                throw new UnknownHostException(\"Unable to resolve host \" + hostName\n+                        + \" in hosts file \" + hostsFile);\n+            }\n@@ -1133,0 +1264,6 @@\n+    \/**\n+     * Platform-wide {@code LookupPolicy} initialized from {@code \"java.net.preferIPv4Stack\"},\n+     * {@code \"java.net.preferIPv6Addresses\"} system properties.\n+     *\/\n+    static final LookupPolicy PLATFORM_LOOKUP_POLICY;\n+\n@@ -1137,2 +1274,5 @@\n-        \/\/ create name service\n-        nameService = createNameService();\n+        \/\/ impl must be initialized before calling this method\n+        PLATFORM_LOOKUP_POLICY = initializePlatformLookupPolicy();\n+\n+        \/\/ create built-in resolver\n+        BUILTIN_RESOLVER = createBuiltinInetAddressResolver();\n@@ -1142,1 +1282,1 @@\n-     * Create an instance of the NameService interface based on\n+     * Create an instance of the InetAddressResolver interface based on\n@@ -1145,1 +1285,1 @@\n-     * <p>The default NameService is the PlatformNameService, which typically\n+     * <p>The default InetAddressResolver is the PlatformResolver, which typically\n@@ -1149,1 +1289,1 @@\n-     * <p> A HostsFileNameService is created if the {@code jdk.net.hosts.file}\n+     * <p> A HostsFileResolver is created if the {@code jdk.net.hosts.file}\n@@ -1154,1 +1294,1 @@\n-     * @return a NameService\n+     * @return an InetAddressResolver\n@@ -1156,7 +1296,4 @@\n-    private static NameService createNameService() {\n-\n-        String hostsFileName =\n-                GetPropertyAction.privilegedGetProperty(\"jdk.net.hosts.file\");\n-        NameService theNameService;\n-        if (hostsFileName != null) {\n-            theNameService = new HostsFileNameService(hostsFileName);\n+    private static InetAddressResolver createBuiltinInetAddressResolver() {\n+        InetAddressResolver theResolver;\n+        if (HOSTS_FILE_NAME != null) {\n+            theResolver = new HostsFileResolver(HOSTS_FILE_NAME);\n@@ -1164,1 +1301,1 @@\n-            theNameService = new PlatformNameService();\n+            theResolver = new PlatformResolver();\n@@ -1166,1 +1303,1 @@\n-        return theNameService;\n+        return theResolver;\n@@ -1171,1 +1308,2 @@\n-     * No name service is checked for the validity of the address.\n+     * The system-wide {@linkplain InetAddressResolver resolver} is not used to check\n+     * the validity of the address.\n@@ -1254,6 +1392,0 @@\n-    \/\/ called from deployment cache manager\n-    private static InetAddress getByName(String host, InetAddress reqAddr)\n-        throws UnknownHostException {\n-        return InetAddress.getAllByName(host, reqAddr)[0];\n-    }\n-\n@@ -1262,1 +1394,1 @@\n-     * based on the configured name service on the system.\n+     * based on the configured system {@linkplain InetAddressResolver resolver}.\n@@ -1301,5 +1433,0 @@\n-        return getAllByName(host, null);\n-    }\n-\n-    private static InetAddress[] getAllByName(String host, InetAddress reqAddr)\n-        throws UnknownHostException {\n@@ -1367,1 +1494,1 @@\n-        return getAllByName0(host, reqAddr, true, true);\n+        return getAllByName0(host, true, true);\n@@ -1417,6 +1544,0 @@\n-    private static InetAddress[] getAllByName0 (String host)\n-        throws UnknownHostException\n-    {\n-        return getAllByName0(host, true);\n-    }\n-\n@@ -1428,1 +1549,1 @@\n-        return getAllByName0 (host, null, check, true);\n+        return getAllByName0(host, check, true);\n@@ -1435,1 +1556,0 @@\n-     * @param reqAddr requested address to be the 1st in returned array\n@@ -1443,1 +1563,0 @@\n-                                               InetAddress reqAddr,\n@@ -1501,1 +1620,1 @@\n-                addrs = new NameServiceAddresses(host, reqAddr)\n+                    addrs = new NameServiceAddresses(host)\n@@ -1512,1 +1631,1 @@\n-    static InetAddress[] getAddressesFromNameService(String host, InetAddress reqAddr)\n+    static InetAddress[] getAddressesFromNameService(String host)\n@@ -1514,1 +1633,1 @@\n-        InetAddress[] addresses = null;\n+        Stream<InetAddress> addresses = null;\n@@ -1517,0 +1636,1 @@\n+        var resolver = resolver();\n@@ -1518,2 +1638,2 @@\n-            addresses = nameService.lookupAllHostAddr(host);\n-        } catch (UnknownHostException uhe) {\n+            addresses = resolver.lookupByName(host, PLATFORM_LOOKUP_POLICY);\n+        } catch (RuntimeException | UnknownHostException x) {\n@@ -1521,2 +1641,2 @@\n-                addresses = new InetAddress[]{impl.loopbackAddress()};\n-            } else {\n+                addresses = Stream.of(impl.loopbackAddress());\n+            } else if (x instanceof UnknownHostException uhe) {\n@@ -1524,0 +1644,3 @@\n+            } else {\n+                ex = new UnknownHostException();\n+                ex.initCause(x);\n@@ -1526,2 +1649,3 @@\n-\n-        if (addresses == null) {\n+        InetAddress[] result = addresses == null ? null\n+                : addresses.toArray(InetAddress[]::new);\n+        if (result == null || result.length == 0) {\n@@ -1530,23 +1654,1 @@\n-\n-        \/\/ More to do?\n-        if (reqAddr != null && addresses.length > 1 && !addresses[0].equals(reqAddr)) {\n-            \/\/ Find it?\n-            int i = 1;\n-            for (; i < addresses.length; i++) {\n-                if (addresses[i].equals(reqAddr)) {\n-                    break;\n-                }\n-            }\n-            \/\/ Rotate\n-            if (i < addresses.length) {\n-                InetAddress tmp, tmp2 = reqAddr;\n-                for (int j = 0; j < i; j++) {\n-                    tmp = addresses[j];\n-                    addresses[j] = tmp2;\n-                    tmp2 = tmp;\n-                }\n-                addresses[i] = tmp2;\n-            }\n-        }\n-\n-        return addresses;\n+        return result;\n@@ -1560,2 +1662,1 @@\n-     * <p> This method doesn't block, i.e. no reverse name service lookup\n-     * is performed.\n+     * <p> This method doesn't block, i.e. no reverse lookup is performed.\n@@ -1640,1 +1741,1 @@\n-                    localAddr = getAllByName0(local, null, false, false)[0];\n+                    localAddr = getAllByName0(local, false, false)[0];\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":311,"deletions":210,"binary":false,"changes":521,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+\n@@ -28,0 +29,2 @@\n+import java.net.spi.InetAddressResolver.LookupPolicy;\n+\n@@ -41,1 +44,1 @@\n-        lookupAllHostAddr(String hostname) throws UnknownHostException;\n+        lookupAllHostAddr(String hostname, LookupPolicy lookupPolicy) throws UnknownHostException;\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddressImpl.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-    returned by the operating system.<\/P>\n+    returned by the system-wide {@linkplain java.net.spi.InetAddressResolver resolver}.<\/P>\n","filename":"src\/java.base\/share\/classes\/java\/net\/doc-files\/net-properties.html","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.net.spi;\n+\n+import java.lang.annotation.Native;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * This interface defines operations for looking up host names and IP addresses.\n+ * {@link InetAddress} delegates all lookup operations to the <i>system-wide\n+ * resolver<\/i>.\n+ *\n+ * <p> The <i>system-wide resolver<\/i> can be customized by\n+ * <a href=\"InetAddressResolverProvider.html#system-wide-resolver\">\n+ * deploying an implementation<\/a> of {@link InetAddressResolverProvider}.\n+ *\n+ * @since 18\n+ *\/\n+public interface InetAddressResolver {\n+\n+    \/**\n+     * Given the name of a host, returns a stream of IP addresses of the requested\n+     * address family associated with a provided hostname.\n+     *\n+     * <p> {@code host} should be a machine name, such as \"{@code www.example.com}\",\n+     * not a textual representation of its IP address. No validation is performed on\n+     * the given {@code host} name: if a textual representation is supplied, the name\n+     * resolution is likely to fail and {@link UnknownHostException} may be thrown.\n+     *\n+     * <p> The address family type and addresses order are specified by the\n+     * {@code LookupPolicy} instance. Lookup operation characteristics could be\n+     * acquired with {@link LookupPolicy#characteristics()}.\n+     * If {@link InetAddressResolver.LookupPolicy#IPV4} and\n+     * {@link InetAddressResolver.LookupPolicy#IPV6} characteristics provided then this\n+     * method returns addresses of both IPV4 and IPV6 families.\n+     *\n+     * @param host         the specified hostname\n+     * @param lookupPolicy the address lookup policy\n+     * @return a stream of IP addresses for the requested host\n+     * @throws NullPointerException if either parameter is {@code null}\n+     * @throws UnknownHostException if no IP address for the {@code host} could be found\n+     * @see LookupPolicy\n+     *\/\n+    Stream<InetAddress> lookupByName(String host, LookupPolicy lookupPolicy) throws UnknownHostException;\n+\n+    \/**\n+     * Lookup the host name corresponding to the raw IP address provided.\n+     *\n+     * <p> {@code addr} argument is in network byte order: the highest order byte of the address\n+     * is in {@code addr[0]}.\n+     *\n+     * <p> IPv4 address byte array must be 4 bytes long and IPv6 byte array\n+     * must be 16 bytes long.\n+     *\n+     * @param addr byte array representing a raw IP address\n+     * @return {@code String} representing the host name mapping\n+     * @throws UnknownHostException     if no host name is found for the specified IP address\n+     * @throws IllegalArgumentException if the length of the provided byte array doesn't correspond\n+     *                                  to a valid IP address length\n+     * @throws NullPointerException     if addr is {@code null}\n+     *\/\n+    String lookupByAddress(byte[] addr) throws UnknownHostException;\n+\n+    \/**\n+     * A {@code LookupPolicy} object describes characteristics that can be applied to a lookup operation.\n+     * In particular, it is used to specify the ordering and which filtering should be performed when\n+     * {@linkplain InetAddressResolver#lookupByName(String, LookupPolicy) looking up host addresses}.\n+     *\n+     * <p> The default platform-wide lookup policy is constructed by consulting\n+     * <a href=\"doc-files\/net-properties.html#Ipv4IPv6\">System Properties<\/a> which affect\n+     * how IPv4 and IPv6 addresses are returned.\n+     *\n+     * @since 18\n+     *\/\n+    final class LookupPolicy {\n+\n+        \/**\n+         * Characteristic value signifying if IPv4 addresses need to be queried during lookup.\n+         *\/\n+        @Native\n+        public static final int IPV4 = 1 << 0;\n+\n+        \/**\n+         * Characteristic value signifying if IPv6 addresses need to be queried during lookup.\n+         *\/\n+        @Native\n+        public static final int IPV6 = 1 << 1;\n+\n+        \/**\n+         * Characteristic value signifying if IPv4 addresses should be returned\n+         * first by {@code InetAddressResolver}.\n+         *\/\n+        @Native\n+        public static final int IPV4_FIRST = 1 << 2;\n+\n+        \/**\n+         * Characteristic value signifying if IPv6 addresses should be returned\n+         * first by {@code InetAddressResolver}.\n+         *\/\n+        @Native\n+        public static final int IPV6_FIRST = 1 << 3;\n+\n+        private final int characteristics;\n+\n+        private LookupPolicy(int characteristics) {\n+            this.characteristics = characteristics;\n+        }\n+\n+        \/**\n+         * This factory method creates a {@link LookupPolicy LookupPolicy} instance with\n+         * the given {@code characteristics} value.\n+         *\n+         * <p> The {@code characteristics} value is an integer bit mask which defines\n+         * parameters of a forward lookup operation. These parameters define at least:\n+         * <ul>\n+         *     <li>the family type of the returned addresses<\/li>\n+         *     <li>the order in which a {@linkplain InetAddressResolver resolver}\n+         *         implementation should return its results<\/li>\n+         * <\/ul>\n+         *\n+         * <p> To request addresses of specific family types the following bit masks can be combined:\n+         * <ul>\n+         *     <li>{@link LookupPolicy#IPV4}: to request IPv4 addresses<\/li>\n+         *     <li>{@link LookupPolicy#IPV6}: to request IPv6 addresses<\/li>\n+         * <\/ul>\n+         * <br>It is an error if neither {@link LookupPolicy#IPV4} or {@link LookupPolicy#IPV6} are set.\n+         *\n+         * <p> To request a specific ordering of the results:\n+         * <ul>\n+         *     <li>{@link LookupPolicy#IPV4_FIRST}: return IPv4 addresses before any IPv6 address<\/li>\n+         *     <li>{@link LookupPolicy#IPV6_FIRST}: return IPv6 addresses before any IPv4 address<\/li>\n+         * <\/ul>\n+         * <br>If neither {@link LookupPolicy#IPV4_FIRST} or {@link LookupPolicy#IPV6_FIRST} are set it\n+         * implies <a href=\"{@docRoot}\/java.base\/java\/net\/doc-files\/net-properties.html#Ipv4IPv6\">\"system\"<\/a>\n+         * order of addresses.\n+         * It is an error to request both {@link LookupPolicy#IPV4_FIRST} and {@link LookupPolicy#IPV6_FIRST}.\n+         *\n+         * @param characteristics a value which represents the set of lookup characteristics\n+         * @return an instance of {@code InetAddressResolver.LookupPolicy}\n+         * @throws IllegalArgumentException if an illegal characteristics bit mask is provided\n+         * @see InetAddressResolver#lookupByName(String, LookupPolicy)\n+         *\/\n+        public static LookupPolicy of(int characteristics) {\n+            \/\/ At least one type of addresses should be requested\n+            if ((characteristics & IPV4) == 0 && (characteristics & IPV6) == 0) {\n+                throw new IllegalArgumentException(\"No address type specified\");\n+            }\n+\n+            \/\/ Requested order of addresses couldn't be determined\n+            if ((characteristics & IPV4_FIRST) != 0 && (characteristics & IPV6_FIRST) != 0) {\n+                throw new IllegalArgumentException(\"Addresses order cannot be determined\");\n+            }\n+\n+            \/\/ If IPv4 addresses requested to be returned first then they should be requested too\n+            if ((characteristics & IPV4_FIRST) != 0 && (characteristics & IPV4) == 0) {\n+                throw new IllegalArgumentException(\"Addresses order and type do not match\");\n+            }\n+\n+            \/\/ If IPv6 addresses requested to be returned first then they should be requested too\n+            if ((characteristics & IPV6_FIRST) != 0 && (characteristics & IPV6) == 0) {\n+                throw new IllegalArgumentException(\"Addresses order and type do not match\");\n+            }\n+            return new LookupPolicy(characteristics);\n+        }\n+\n+        \/**\n+         * Returns the set of characteristics of this lookup policy.\n+         *\n+         * @return a characteristics value\n+         * @see InetAddressResolver#lookupByName(String, LookupPolicy)\n+         *\/\n+        public int characteristics() {\n+            return characteristics;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/net\/spi\/InetAddressResolver.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.net.spi;\n+\n+import sun.net.ResolverProviderConfiguration;\n+\n+import java.net.InetAddress;\n+import java.util.ServiceLoader;\n+\n+\/**\n+ * Service-provider class for {@linkplain InetAddressResolver InetAddress resolvers}.\n+ *\n+ * <p> A resolver provider is a factory for custom implementations of {@linkplain\n+ * InetAddressResolver InetAddress resolvers}. A resolver defines operations for\n+ * looking up (resolving) host names and IP addresses.\n+ * <p>A resolver provider is a concrete subclass of this class that has a\n+ * zero-argument constructor and implements the abstract methods specified below.\n+ *\n+ * <p> A given invocation of the Java virtual machine maintains a single\n+ * system-wide resolver instance, which is used by\n+ * <a href=\"{@docRoot}\/java.base\/java\/net\/InetAddress.html#host-name-resolution\">\n+ * InetAddress<\/a>. It is set after the VM is fully initialized and when an\n+ * invocation of a method in {@link InetAddress} class triggers the first lookup\n+ * operation.\n+ *\n+ * <p id=\"system-wide-resolver\"> A resolver provider is located and loaded by\n+ * {@link InetAddress} to create the system-wide resolver as follows:\n+ * <ol>\n+ *  <li>The {@link ServiceLoader} mechanism is used to locate an\n+ *      {@code InetAddressResolverProvider} using the\n+ *      system class loader. The order in which providers are located is\n+ *      {@linkplain ServiceLoader#load(java.lang.Class, java.lang.ClassLoader)\n+ *      implementation specific}.\n+ *      The first provider found will be used to instantiate the\n+ *      {@link InetAddressResolver InetAddressResolver} by invoking the\n+ *      {@link InetAddressResolverProvider#get(InetAddressResolverProvider.Configuration)}\n+ *      method. The returned {@code InetAddressResolver} will be set as the\n+ *      system-wide resolver.\n+ *  <li>If the previous step fails to find any resolver provider the\n+ *      <a href=\"{@docRoot}\/java.base\/java\/net\/InetAddress.html#built-in-resolver\">\n+ *      built-in resolver<\/a> will be set as the system-wide resolver.\n+ * <\/ol>\n+ *\n+ * <p> If instantiating a custom resolver from a provider discovered in\n+ * step 1 throws an error or exception, the system-wide resolver will not be\n+ * set and the error or exception will be propagated to the calling thread.\n+ * Otherwise, any lookup operation will be performed using the\n+ * <i>system-wide resolver<\/i>.\n+ *\n+ * @implNote {@link InetAddress} will use the <i>built-in resolver<\/i> for any lookup operation\n+ * that might occur before the VM is fully booted.\n+ *\n+ * @since 18\n+ *\/\n+public abstract class InetAddressResolverProvider {\n+\n+    \/**\n+     * Initialize and return an {@link InetAddressResolver} provided by\n+     * this provider. This method is called by {@link InetAddress} when\n+     * <a href=\"#system-wide-resolver\">installing<\/a>\n+     * the system-wide resolver implementation.\n+     *\n+     * <p> Any error or exception thrown by this method is considered as\n+     * a failure of {@code InetAddressResolver} instantiation and will be propagated to\n+     * the calling thread.\n+     * @param configuration a {@link Configuration} instance containing platform built-in address\n+     *                     resolution configuration.\n+     * @return the resolver provided by this provider\n+     *\/\n+    public abstract InetAddressResolver get(Configuration configuration);\n+\n+    \/**\n+     * {@return the name of this provider, or {@code null} if unnamed}\n+     *\/\n+    public abstract String name();\n+\n+    \/**\n+     * The {@code RuntimePermission(\"inetAddressResolverProvider\")} is\n+     * necessary to subclass and instantiate the {@code InetAddressResolverProvider} class,\n+     * as well as to obtain resolver from an instance of that class,\n+     * and it is also required to obtain the operating system name resolution configurations.\n+     *\/\n+    private static final RuntimePermission INET_ADDRESS_RESOLVER_PERMISSION =\n+            new RuntimePermission(\"inetAddressResolverProvider\");\n+\n+    \/**\n+     * Creates a new instance of {@code InetAddressResolverProvider}.\n+     *\n+     * @throws SecurityException if a security manager is present and its\n+     *                           {@code checkPermission} method doesn't allow the\n+     *                           {@code RuntimePermission(\"inetAddressResolverProvider\")}.\n+     * @implNote It is recommended that an {@code InetAddressResolverProvider} service\n+     * implementation initialization should be as simple as possible, in order to avoid\n+     * possible risks of deadlock or class loading cycles during the instantiation of the\n+     * service provider.\n+     *\/\n+    protected InetAddressResolverProvider() {\n+        this(checkPermission());\n+    }\n+\n+    private InetAddressResolverProvider(Void unused) {\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static Void checkPermission() {\n+        final SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkPermission(INET_ADDRESS_RESOLVER_PERMISSION);\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * A {@code Configuration} object is supplied to the\n+     * {@link InetAddressResolverProvider#get(Configuration)} method when\n+     * setting the system-wide resolver.\n+     * A resolver implementation can then delegate to the built-in resolver\n+     * provided by this interface if it needs to.\n+     *\n+     * @since 18\n+     *\/\n+    public sealed interface Configuration permits ResolverProviderConfiguration {\n+        \/**\n+         * Returns the built-in {@linkplain InetAddressResolver resolver}.\n+         *\n+         * @return the JDK built-in resolver.\n+         *\/\n+        InetAddressResolver builtinResolver();\n+\n+        \/**\n+         * Reads the localhost name from the system configuration.\n+         *\n+         * @return the localhost name.\n+         *\/\n+        String lookupLocalHostName();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/net\/spi\/InetAddressResolverProvider.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * <p> Only developers who are defining new URL stream handler providers\n- * should need to make direct use of this package.\n+ * <p> Only developers who are defining new URL stream handler providers or implementing\n+ * a custom resolver provider should need to make direct use of this package.\n","filename":"src\/java.base\/share\/classes\/java\/net\/spi\/package-info.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -579,2 +579,3 @@\n-     * It must contain at least a {@code Locale}\n-     * instance equal to {@link java.util.Locale#US Locale.US}.\n+     * At a minimum, the returned array must contain a {@code Locale} instance equal to\n+     * {@link Locale#ROOT Locale.ROOT} and a {@code Locale} instance equal to\n+     * {@link Locale#US Locale.US}.\n","filename":"src\/java.base\/share\/classes\/java\/text\/BreakIterator.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -424,2 +424,3 @@\n-     * It must contain at least a Locale instance equal to\n-     * {@link java.util.Locale#US Locale.US}.\n+     * At a minimum, the returned array must contain a {@code Locale} instance equal to\n+     * {@link Locale#ROOT Locale.ROOT} and a {@code Locale} instance equal to\n+     * {@link Locale#US Locale.US}.\n","filename":"src\/java.base\/share\/classes\/java\/text\/Collator.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -639,2 +639,3 @@\n-     * It must contain at least a {@code Locale} instance equal to\n-     * {@link java.util.Locale#US Locale.US}.\n+     * At a minimum, the returned array must contain a {@code Locale} instance equal to\n+     * {@link Locale#ROOT Locale.ROOT} and a {@code Locale} instance equal to\n+     * {@link Locale#US Locale.US}.\n","filename":"src\/java.base\/share\/classes\/java\/text\/DateFormat.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -302,2 +302,3 @@\n-     * implementations.  It must contain at least a {@code Locale}\n-     * instance equal to {@link java.util.Locale#US Locale.US}.\n+     * implementations. At a minimum, the returned array must contain a\n+     * {@code Locale} instance equal to {@link Locale#ROOT Locale.ROOT} and\n+     * a {@code Locale} instance equal to {@link Locale#US Locale.US}.\n","filename":"src\/java.base\/share\/classes\/java\/text\/DateFormatSymbols.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,2 +125,3 @@\n-     * implementations.  It must contain at least a {@code Locale}\n-     * instance equal to {@link java.util.Locale#US Locale.US}.\n+     * implementations. At a minimum, the returned array must contain a\n+     * {@code Locale} instance equal to {@link Locale#ROOT Locale.ROOT} and\n+     * a {@code Locale} instance equal to {@link Locale#US Locale.US}.\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormatSymbols.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -685,2 +685,3 @@\n-     * It must contain at least a {@code Locale} instance equal to\n-     * {@link java.util.Locale#US Locale.US}.\n+     * At a minimum, the returned array must contain a {@code Locale} instance equal to\n+     * {@link Locale#ROOT Locale.ROOT} and a {@code Locale} instance equal to\n+     * {@link Locale#US Locale.US}.\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1900,1 +1900,1 @@\n-     * The output will be one of the following ISO-8601 formats:\n+     * The output will be one of the following formats:\n@@ -1909,1 +1909,2 @@\n-     * the time where the omitted parts are implied to be zero.\n+     * the time where the omitted parts are implied to be zero. The output\n+     * is compatible with ISO 8601 if the seconds in the offset are zero.\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetDateTime.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -2210,1 +2210,2 @@\n-     * The output is compatible with ISO-8601 if the offset and ID are the same.\n+     * The output is compatible with ISO-8601 if the offset and ID are the same,\n+     * and the seconds in the offset are zero.\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZonedDateTime.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,0 @@\n-import java.util.HashMap;\n@@ -124,35 +123,0 @@\n-    \/**\n-     * Narrow names for eras.\n-     *\/\n-    private static final HashMap<String, String[]> ERA_NARROW_NAMES = new HashMap<>();\n-    \/**\n-     * Short names for eras.\n-     *\/\n-    private static final HashMap<String, String[]> ERA_SHORT_NAMES = new HashMap<>();\n-    \/**\n-     * Full names for eras.\n-     *\/\n-    private static final HashMap<String, String[]> ERA_FULL_NAMES = new HashMap<>();\n-    \/**\n-     * Fallback language for the era names.\n-     *\/\n-    private static final String FALLBACK_LANGUAGE = \"en\";\n-    \/**\n-     * Language that has the era names.\n-     *\/\n-    private static final String TARGET_LANGUAGE = \"th\";\n-    \/**\n-     * Name data.\n-     *\/\n-    static {\n-        ERA_NARROW_NAMES.put(FALLBACK_LANGUAGE, new String[]{\"BB\", \"BE\"});\n-        ERA_NARROW_NAMES.put(TARGET_LANGUAGE, new String[]{\"BB\", \"BE\"});\n-        ERA_SHORT_NAMES.put(FALLBACK_LANGUAGE, new String[]{\"B.B.\", \"B.E.\"});\n-        ERA_SHORT_NAMES.put(TARGET_LANGUAGE,\n-                new String[]{\"\\u0e1e.\\u0e28.\",\n-                \"\\u0e1b\\u0e35\\u0e01\\u0e48\\u0e2d\\u0e19\\u0e04\\u0e23\\u0e34\\u0e2a\\u0e15\\u0e4c\\u0e01\\u0e32\\u0e25\\u0e17\\u0e35\\u0e48\"});\n-        ERA_FULL_NAMES.put(FALLBACK_LANGUAGE, new String[]{\"Before Buddhist\", \"Budhhist Era\"});\n-        ERA_FULL_NAMES.put(TARGET_LANGUAGE,\n-                new String[]{\"\\u0e1e\\u0e38\\u0e17\\u0e18\\u0e28\\u0e31\\u0e01\\u0e23\\u0e32\\u0e0a\",\n-                \"\\u0e1b\\u0e35\\u0e01\\u0e48\\u0e2d\\u0e19\\u0e04\\u0e23\\u0e34\\u0e2a\\u0e15\\u0e4c\\u0e01\\u0e32\\u0e25\\u0e17\\u0e35\\u0e48\"});\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/ThaiBuddhistChronology.java","additions":1,"deletions":37,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -691,2 +691,2 @@\n-     * If the field value in the date-time to be printed is invalid it\n-     * cannot be printed and an exception will be thrown.\n+     * If the field value in the date-time to be printed is outside the\n+     * range of valid values then an exception will be thrown.\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,1 +118,3 @@\n-     * The locale 'en_US' will always be present.\n+     * At a minimum, the returned {@code Set} must contain a {@code Locale} instance equal to\n+     * {@link Locale#ROOT Locale.ROOT} and a {@code Locale} instance equal to\n+     * {@link Locale#US Locale.US}.\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DecimalStyle.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1733,2 +1733,3 @@\n-     * The array returned must contain at least a {@code Locale}\n-     * instance equal to {@link java.util.Locale#US Locale.US}.\n+     * At a minimum, the returned array must contain a {@code Locale} instance equal to\n+     * {@link Locale#ROOT Locale.ROOT} and a {@code Locale} instance equal to\n+     * {@link Locale#US Locale.US}.\n","filename":"src\/java.base\/share\/classes\/java\/util\/Calendar.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1129,2 +1129,3 @@\n-     * implementations.  It must contain at least a {@code Locale}\n-     * instance equal to {@link java.util.Locale#US Locale.US}.\n+     * implementations. At a minimum, the returned array must contain a\n+     * {@code Locale} instance equal to {@link Locale#ROOT Locale.ROOT} and\n+     * a {@code Locale} instance equal to {@link Locale#US Locale.US}.\n","filename":"src\/java.base\/share\/classes\/java\/util\/Locale.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -471,2 +471,1 @@\n-        long hilo = mostSigBits ^ leastSigBits;\n-        return ((int)(hilo >> 32)) ^ (int) hilo;\n+        return Long.hashCode(mostSigBits ^ leastSigBits);\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n- * <table style=\"padding:0px 20px 0px 0px\">\n+ * <table class=\"striped\">\n@@ -239,1 +239,1 @@\n- *      <td style=\"text-align:left\">L128X1024MixRandom<\/td>\n+ *      <th scope=\"row\" style=\"text-align:left\">L128X1024MixRandom<\/th>\n@@ -246,1 +246,1 @@\n- *      <td style=\"text-align:left\">L128X128MixRandom<\/td>\n+ *      <th scope=\"row\" style=\"text-align:left\">L128X128MixRandom<\/th>\n@@ -253,1 +253,1 @@\n- *      <td style=\"text-align:left\">L128X256MixRandom<\/td>\n+ *      <th scope=\"row\" style=\"text-align:left\">L128X256MixRandom<\/th>\n@@ -260,1 +260,1 @@\n- *      <td style=\"text-align:left\">L32X64MixRandom<\/td>\n+ *      <th scope=\"row\" style=\"text-align:left\">L32X64MixRandom<\/th>\n@@ -267,1 +267,1 @@\n- *      <td style=\"text-align:left\">L64X1024MixRandom<\/td>\n+ *      <th scope=\"row\" style=\"text-align:left\">L64X1024MixRandom<\/th>\n@@ -274,1 +274,1 @@\n- *      <td style=\"text-align:left\">L64X128MixRandom<\/td>\n+ *      <th scope=\"row\" style=\"text-align:left\">L64X128MixRandom<\/th>\n@@ -281,1 +281,1 @@\n- *      <td style=\"text-align:left\">L64X128StarStarRandom<\/td>\n+ *      <th scope=\"row\" style=\"text-align:left\">L64X128StarStarRandom<\/th>\n@@ -288,1 +288,1 @@\n- *      <td style=\"text-align:left\">L64X256MixRandom<\/td>\n+ *      <th scope=\"row\" style=\"text-align:left\">L64X256MixRandom<\/th>\n@@ -295,1 +295,1 @@\n- *      <td style=\"text-align:left\">Random<\/td>\n+ *      <th scope=\"row\" style=\"text-align:left\">Random<\/th>\n@@ -302,1 +302,1 @@\n- *      <td style=\"text-align:left\">SplittableRandom<\/td>\n+ *      <th scope=\"row\" style=\"text-align:left\">SplittableRandom<\/th>\n@@ -309,1 +309,1 @@\n- *      <td style=\"text-align:left\">ThreadLocalRandom <sup>*<\/sup><\/td>\n+ *      <th scope=\"row\" style=\"text-align:left\">ThreadLocalRandom <sup>*<\/sup><\/th>\n@@ -316,1 +316,1 @@\n- *      <td style=\"text-align:left\">Xoroshiro128PlusPlus<\/td>\n+ *      <th scope=\"row\" style=\"text-align:left\">Xoroshiro128PlusPlus<\/th>\n@@ -323,1 +323,1 @@\n- *      <td style=\"text-align:left\">Xoshiro256PlusPlus<\/td>\n+ *      <th scope=\"row\" style=\"text-align:left\">Xoshiro256PlusPlus<\/th>\n@@ -469,1 +469,1 @@\n- * <table style=\"padding:0px 20px 0px 0px\">\n+ * <table class=\"striped\">\n@@ -479,1 +479,1 @@\n- *   <tr><td style=\"text-align:left\">\"L32X64MixRandom\"<\/td>\n+ *   <tr><th scope=\"row\" style=\"text-align:left\">\"L32X64MixRandom\"<\/th>\n@@ -484,1 +484,1 @@\n- *   <tr><td style=\"text-align:left\">\"L64X128StarStarRandom\"<\/td>\n+ *   <tr><th scope=\"row\" style=\"text-align:left\">\"L64X128StarStarRandom\"<\/th>\n@@ -489,1 +489,1 @@\n- *   <tr><td style=\"text-align:left\">\"L64X128MixRandom\"<\/td>\n+ *   <tr><th scope=\"row\" style=\"text-align:left\">\"L64X128MixRandom\"<\/th>\n@@ -494,1 +494,1 @@\n- *   <tr><td style=\"text-align:left\">\"L64X256MixRandom\"<\/td>\n+ *   <tr><th scope=\"row\" style=\"text-align:left\">\"L64X256MixRandom\"<\/th>\n@@ -499,1 +499,1 @@\n- *   <tr><td style=\"text-align:left\">\"L64X1024MixRandom\"<\/td>\n+ *   <tr><th scope=\"row\" style=\"text-align:left\">\"L64X1024MixRandom\"<\/th>\n@@ -504,1 +504,1 @@\n- *   <tr><td style=\"text-align:left\">\"L128X128MixRandom\"<\/td>\n+ *   <tr><th scope=\"row\" style=\"text-align:left\">\"L128X128MixRandom\"<\/th>\n@@ -509,1 +509,1 @@\n- *   <tr><td style=\"text-align:left\">\"L128X256MixRandom\"<\/td>\n+ *   <tr><th scope=\"row\" style=\"text-align:left\">\"L128X256MixRandom\"<\/th>\n@@ -514,1 +514,1 @@\n- *   <tr><td style=\"text-align:left\">\"L128X1024MixRandom\"<\/td>\n+ *   <tr><th scope=\"row\" style=\"text-align:left\">\"L128X1024MixRandom\"<\/th>\n@@ -578,1 +578,1 @@\n- * <table style=\"padding:0px 20px 0px 0px\">\n+ * <table class=\"striped\">\n@@ -588,1 +588,1 @@\n- *   <tr><td style=\"text-align:left\">\"L32X64MixRandom\"<\/td>\n+ *   <tr><th scope=\"row\" style=\"text-align:left\">\"L32X64MixRandom\"<\/th>\n@@ -593,1 +593,1 @@\n- *   <tr><td style=\"text-align:left\">\"L64X128StarStarRandom\" <\/td>\n+ *   <tr><th scope=\"row\" style=\"text-align:left\">\"L64X128StarStarRandom\" <\/th>\n@@ -598,1 +598,1 @@\n- *   <tr><td style=\"text-align:left\">\"L64X128MixRandom\"<\/td>\n+ *   <tr><th scope=\"row\" style=\"text-align:left\">\"L64X128MixRandom\"<\/th>\n@@ -603,1 +603,1 @@\n- *   <tr><td style=\"text-align:left\">\"L64X256MixRandom\"<\/td>\n+ *   <tr><th scope=\"row\" style=\"text-align:left\">\"L64X256MixRandom\"<\/th>\n@@ -608,1 +608,1 @@\n- *   <tr><td style=\"text-align:left\">\"L64X1024MixRandom\"<\/td>\n+ *   <tr><th scope=\"row\" style=\"text-align:left\">\"L64X1024MixRandom\"<\/th>\n@@ -613,1 +613,1 @@\n- *   <tr><td style=\"text-align:left\">\"L128X128MixRandom\"<\/td>\n+ *   <tr><th scope=\"row\" style=\"text-align:left\">\"L128X128MixRandom\"<\/th>\n@@ -618,1 +618,1 @@\n- *   <tr><td style=\"text-align:left\">\"L128X256MixRandom\"<\/td>\n+ *   <tr><th scope=\"row\" style=\"text-align:left\">\"L128X256MixRandom\"<\/th>\n@@ -623,1 +623,1 @@\n- *   <tr><td style=\"text-align:left\">\"L128X1024MixRandom\"<\/td>\n+ *   <tr><th scope=\"row\" style=\"text-align:left\">\"L128X1024MixRandom\"<\/th>\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/package-info.java","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -422,1 +422,3 @@\n-                input.position(inputPos + read);\n+                if (read > 0) {\n+                    input.position(inputPos + read);\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Inflater.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -342,1 +342,1 @@\n- * {code String} format for comparison.\n+ * {@code String} format for comparison.\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SSLEngine.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,1 +136,1 @@\n- * {code String} format for comparison.\n+ * {@code String} format for comparison.\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SSLSocket.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.reflect.*;\n@@ -35,2 +34,0 @@\n-import java.security.Permission;\n-import java.security.PermissionCollection;\n@@ -38,1 +35,0 @@\n-import java.security.PrivilegedAction;\n@@ -42,0 +38,4 @@\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletionException;\n+\n+import sun.security.action.GetBooleanAction;\n@@ -292,3 +292,4 @@\n-     *       and subject to removal in a future release. However, obtaining a\n-     *       Subject is useful independent of the Security Manager, so a\n-     *       replacement for this method may be added in a future release.\n+     *       and subject to removal in a future release. However,\n+     *       obtaining a Subject is useful independent of the Security Manager.\n+     *       Thus, a replacement API named {@link #current()} has been added\n+     *       which can be used to obtain the current subject.\n@@ -322,0 +323,106 @@\n+    \/\/ Store the current subject in a ThreadLocal when a system property is set.\n+    private static final boolean USE_TL = GetBooleanAction\n+            .privilegedGetProperty(\"jdk.security.auth.subject.useTL\");\n+\n+    private static final InheritableThreadLocal<Subject> SUBJECT_THREAD_LOCAL =\n+            USE_TL ?\n+            new InheritableThreadLocal<>() {\n+                @Override protected Subject initialValue() {\n+                    return null;\n+                }\n+            } : null;\n+\n+    \/**\n+     * Returns the current subject.\n+     * <p>\n+     * The current subject is installed by the {@link #callAs} method.\n+     * When {@code callAs(subject, action)} is called, {@code action} is\n+     * executed with {@code subject} as its current subject which can be\n+     * retrieved by this method. After {@code action} is finished, the current\n+     * subject is reset to its previous value. The current\n+     * subject is {@code null} before the first call of {@code callAs()}.\n+     * <p>\n+     * When a new thread is created, its current subject is the same as\n+     * the one of its parent thread, and will not change even if\n+     * its parent thread's current subject is changed to another value.\n+     *\n+     * @implNote\n+     * By default, this method returns the same value as\n+     * {@code Subject.getSubject(AccessController.getContext())}. This\n+     * preserves compatibility with code that may still be calling {@code doAs}\n+     * which installs the subject in an {@code AccessControlContext}. However,\n+     * if the system property {@systemProperty jdk.security.auth.subject.useTL}\n+     * is set to {@code true}, the subject is retrieved from an inheritable\n+     * {@code ThreadLocal} object. This behavior is subject to\n+     * change in a future version.\n+     *\n+     * @return the current subject, or {@code null} if a current subject is\n+     *      not installed or the current subject is set to {@code null}.\n+     * @see #callAs(Subject, Callable)\n+     * @since 18\n+     *\/\n+    @SuppressWarnings(\"removal\")\n+    public static Subject current() {\n+        return USE_TL\n+            ? SUBJECT_THREAD_LOCAL.get()\n+            : getSubject(AccessController.getContext());\n+    }\n+\n+    \/**\n+     * Executes a {@code Callable} with {@code subject} as the\n+     * current subject.\n+     *\n+     * @implNote\n+     * By default, this method calls {@link #doAs(Subject, PrivilegedExceptionAction)\n+     * Subject.doAs(subject, altAction)} which stores the subject in\n+     * a new {@code AccessControlContext}, where {@code altAction.run()}\n+     * is equivalent to {@code action.call()} and the exception thrown is\n+     * modified to match the specification of this method. This preserves\n+     * compatibility with code that may still be calling\n+     * {@code getSubject(AccessControlContext)} which retrieves the subject\n+     * from an {@code AccessControlContext}. However,\n+     * if the system property {@code jdk.security.auth.subject.useTL}\n+     * is set to {@code true}, the current subject will be stored in an inheritable\n+     * {@code ThreadLocal} object. This behavior is subject to change in a\n+     * future version.\n+     *\n+     * @param subject the {@code Subject} that the specified {@code action}\n+     *               will run as.  This parameter may be {@code null}.\n+     * @param action the code to be run with {@code subject} as its current\n+     *               subject. Must not be {@code null}.\n+     * @param <T> the type of value returned by the {@code call} method\n+     *            of {@code action}\n+     * @return the value returned by the {@code call} method of {@code action}\n+     * @throws NullPointerException if {@code action} is {@code null}\n+     * @throws CompletionException if {@code action.call()} throws an exception.\n+     *      The cause of the {@code CompletionException} is set to the exception\n+     *      thrown by {@code action.call()}.\n+     * @see #current()\n+     * @since 18\n+     *\/\n+    public static <T> T callAs(final Subject subject,\n+            final Callable<T> action) throws CompletionException {\n+        if (USE_TL) {\n+            Subject oldSubject = SUBJECT_THREAD_LOCAL.get();\n+            SUBJECT_THREAD_LOCAL.set(subject);\n+            try {\n+                return action.call();\n+            } catch (Exception e) {\n+                throw new CompletionException(e);\n+            } finally {\n+                SUBJECT_THREAD_LOCAL.set(oldSubject);\n+            }\n+        } else {\n+            try {\n+                PrivilegedExceptionAction<T> pa = () -> action.call();\n+                @SuppressWarnings(\"removal\")\n+                var result = doAs(subject, pa);\n+                return result;\n+            } catch (PrivilegedActionException e) {\n+                throw new CompletionException(e.getCause());\n+            } catch (Exception e) {\n+                throw new CompletionException(e);\n+            }\n+        }\n+    }\n+\n@@ -357,0 +464,8 @@\n+     *\n+     * @deprecated This method depends on {@link AccessControlContext}\n+     *       which, in conjunction with\n+     *       {@linkplain SecurityManager the Security Manager}, is deprecated\n+     *       and subject to removal in a future release. However, performing\n+     *       work as a Subject is useful independent of the Security Manager.\n+     *       Thus, a replacement API named {@link #callAs} has been added\n+     *       which can be used to perform the same work.\n@@ -359,0 +474,1 @@\n+    @Deprecated(since=\"18\", forRemoval=true)\n@@ -420,0 +536,8 @@\n+     *\n+     * @deprecated This method depends on {@link AccessControlContext}\n+     *       which, in conjunction with\n+     *       {@linkplain SecurityManager the Security Manager}, is deprecated\n+     *       and subject to removal in a future release. However, performing\n+     *       work as a Subject is useful independent of the Security Manager.\n+     *       Thus, a replacement API named {@link #callAs} has been added\n+     *       which can be used to perform the same work.\n@@ -422,0 +546,1 @@\n+    @Deprecated(since=\"18\", forRemoval=true)\n@@ -860,4 +985,1 @@\n-            if (!privCredentials.equals(thatPrivCredentials)) {\n-                return false;\n-            }\n-            return true;\n+            return privCredentials.equals(thatPrivCredentials);\n@@ -936,1 +1058,1 @@\n-        \/**\n+        \/*\n@@ -1247,1 +1369,1 @@\n-                    \/\/ If the caller does not have read permission for\n+                    \/\/ If the caller does not have read permission\n@@ -1319,1 +1441,1 @@\n-                if (this.contains(item) == false) {\n+                if (!this.contains(item)) {\n@@ -1537,1 +1659,1 @@\n-            \/\/ Check whether the caller has permisson to get\n+            \/\/ Check whether the caller has permission to get\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/Subject.java","additions":137,"deletions":15,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.net.UnknownHostException;\n@@ -40,9 +39,0 @@\n-    \/**\n-     * Get the InetAddress of the provided host. If an InetAddress is provided\n-     * then it will be the default address returned for all calls to either\n-     * form of getByName. This is required to maintain consistency when\n-     * caching addresses and hostnames.\n-     *\/\n-    InetAddress getByName(String hostName, InetAddress hostAddress)\n-            throws UnknownHostException;\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNetInetAddressAccess.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1996,2 +1996,8 @@\n-                                if (i >= 0xffff) {\n-                                    panic(FAULT);\n+                                \/\/          Restore the buffer offset\n+                                mBuffIdx = idx - 1;\n+                                for(char character : Character.toChars(i)) {\n+                                    if (character == ' ' || mInp.next != null) {\n+                                        bappend(character, flag);\n+                                    } else {\n+                                        bappend(character);\n+                                    }\n@@ -1999,1 +2005,0 @@\n-                                ch = (char) i;\n@@ -2003,7 +2008,0 @@\n-                            \/\/          Restore the buffer offset\n-                            mBuffIdx = idx - 1;\n-                            if (ch == ' ' || mInp.next != null) {\n-                                bappend(ch, flag);\n-                            } else {\n-                                bappend(ch);\n-                            }\n@@ -2037,2 +2035,8 @@\n-                                if (i >= 0xffff) {\n-                                    panic(FAULT);\n+                                \/\/          Restore the buffer offset\n+                                mBuffIdx = idx - 1;\n+                                for(char character : Character.toChars(i)) {\n+                                    if (character == ' ' || mInp.next != null) {\n+                                        bappend(character, flag);\n+                                    } else {\n+                                        bappend(character);\n+                                    }\n@@ -2040,1 +2044,0 @@\n-                                ch = (char) i;\n@@ -2044,7 +2047,0 @@\n-                            \/\/          Restore the buffer offset\n-                            mBuffIdx = idx - 1;\n-                            if (ch == ' ' || mInp.next != null) {\n-                                bappend(ch, flag);\n-                            } else {\n-                                bappend(ch);\n-                            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/xml\/impl\/Parser.java","additions":17,"deletions":21,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -363,0 +363,9 @@\n+    \/**\n+     * Writes character reference in hex format.\n+     *\/\n+    private void writeCharRef(int codePoint) throws XMLStreamException {\n+        _writer.write(ENCODING_PREFIX);\n+        _writer.write(Integer.toHexString(codePoint));\n+        _writer.write(SEMICOLON);\n+    }\n+\n@@ -386,4 +395,9 @@\n-                \/\/ Escape this char as underlying encoder cannot handle it\n-                _writer.write(ENCODING_PREFIX);\n-                _writer.write(Integer.toHexString(ch));\n-                _writer.write(SEMICOLON);\n+                \/\/ Check if current and next characters forms a surrogate pair\n+                \/\/ and escape it to avoid generation of invalid xml content\n+                if ( index != end - 1 && Character.isSurrogatePair(ch, content[index+1])) {\n+                    writeCharRef(Character.toCodePoint(ch, content[index+1]));\n+                    index++;\n+                } else {\n+                    writeCharRef(ch);\n+                }\n+\n@@ -458,4 +472,9 @@\n-                \/\/ Escape this char as underlying encoder cannot handle it\n-                _writer.write(ENCODING_PREFIX);\n-                _writer.write(Integer.toHexString(ch));\n-                _writer.write(SEMICOLON);\n+                \/\/ Check if current and next characters forms a surrogate pair\n+                \/\/ and escape it to avoid generation of invalid xml content\n+                if ( index != end - 1 && Character.isSurrogatePair(ch, content.charAt(index+1))) {\n+                    writeCharRef(Character.toCodePoint(ch, content.charAt(index+1)));\n+                    index++;\n+                } else {\n+                    writeCharRef(ch);\n+                }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/xml\/impl\/XMLStreamWriterImpl.java","additions":28,"deletions":9,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -372,0 +372,1 @@\n+    uses java.net.spi.InetAddressResolverProvider;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.net;\n+\n+import java.net.spi.InetAddressResolver;\n+import java.net.spi.InetAddressResolverProvider;\n+import java.util.function.Supplier;\n+\n+public final class ResolverProviderConfiguration implements\n+        InetAddressResolverProvider.Configuration {\n+\n+    private final InetAddressResolver builtinResolver;\n+    private final Supplier<String> localHostNameSupplier;\n+\n+    public ResolverProviderConfiguration(InetAddressResolver builtinResolver,\n+                                         Supplier<String> localHostNameSupplier) {\n+        this.builtinResolver = builtinResolver;\n+        this.localHostNameSupplier = localHostNameSupplier;\n+    }\n+\n+    @Override\n+    public InetAddressResolver builtinResolver() {\n+        return builtinResolver;\n+    }\n+\n+    @Override\n+    public String lookupLocalHostName() {\n+        return localHostNameSupplier.get();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/net\/ResolverProviderConfiguration.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import java.net.SocketException;\n@@ -386,1 +387,6 @@\n-            conSession.invalidate();\n+            \/\/ In the case of a low-layer transport error, we want to prevent\n+            \/\/ the session from being invalidated since this is not a TLS-level\n+            \/\/ error event.\n+            if (!(cause instanceof SocketException)) {\n+                conSession.invalidate();\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/TransportContext.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -356,1 +356,1 @@\n-            {\"Africa\/Juba\", EAT},\n+            {\"Africa\/Juba\", CAT},\n@@ -383,1 +383,3 @@\n-            {\"Africa\/Windhoek\", CAT},\n+            {\"Africa\/Windhoek\", new String[] {\"Central African Time\", \"CAT\",\n+                                              \"Western African Time\", \"WAT\",\n+                                              \"Central African Time\", \"CAT\"}},\n@@ -572,3 +574,3 @@\n-            {\"Antarctica\/Macquarie\", new String[] {\"Macquarie Island Standard Time\", \"MIST\",\n-                                                   \"Macquarie Island Daylight Time\", \"MIDT\",\n-                                                   \"Macquarie Island Time\", \"MIST\"}},\n+            {\"Antarctica\/Macquarie\", new String[] {\"Australian Eastern Standard Time (Macquarie)\", \"AEST\",\n+                                                   \"Australian Eastern Daylight Time (Macquarie)\", \"AEDT\",\n+                                                   \"Australian Eastern Time (Macquarie)\", \"AET\"}},\n","filename":"src\/java.base\/share\/classes\/sun\/util\/resources\/TimeZoneNames.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,0 @@\n-jfieldID ia_preferIPv6AddressID;\n@@ -64,2 +63,0 @@\n-        ia_preferIPv6AddressID = (*env)->GetStaticFieldID(env, ia_class, \"preferIPv6Address\", \"I\");\n-        CHECK_NULL(ia_preferIPv6AddressID);\n@@ -78,0 +75,9 @@\n+\n+\/*\n+ * Class:     java_net_InetAddress\n+ * Method:    isIPv4Available\n+ *\/\n+JNIEXPORT jboolean JNICALL\n+Java_java_net_InetAddress_isIPv4Available(JNIEnv *env, jclass clazz) {\n+    return ipv4_available();\n+}\n","filename":"src\/java.base\/share\/native\/libnet\/InetAddress.c","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"java_net_spi_InetAddressResolver_LookupPolicy.h\"\n@@ -335,0 +336,20 @@\n+\n+int lookupCharacteristicsToAddressFamily(int characteristics) {\n+    int ipv4 = characteristics & java_net_spi_InetAddressResolver_LookupPolicy_IPV4;\n+    int ipv6 = characteristics & java_net_spi_InetAddressResolver_LookupPolicy_IPV6;\n+\n+    if (ipv4 != 0 && ipv6 == 0) {\n+        return AF_INET;\n+    }\n+\n+    if (ipv4 == 0 && ipv6 != 0) {\n+        return AF_INET6;\n+    }\n+    return AF_UNSPEC;\n+}\n+\n+int addressesInSystemOrder(int characteristics) {\n+    return (characteristics &\n+           (java_net_spi_InetAddressResolver_LookupPolicy_IPV4_FIRST |\n+            java_net_spi_InetAddressResolver_LookupPolicy_IPV6_FIRST)) == 0;\n+}\n","filename":"src\/java.base\/share\/native\/libnet\/net_util.c","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-extern jfieldID ia_preferIPv6AddressID;\n@@ -195,0 +194,4 @@\n+int lookupCharacteristicsToAddressFamily(int characteristics);\n+\n+int addressesInSystemOrder(int characteristics);\n+\n","filename":"src\/java.base\/share\/native\/libnet\/net_util.h","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+#include \"java_net_spi_InetAddressResolver_LookupPolicy.h\"\n@@ -41,1 +42,2 @@\n-extern jobjectArray lookupIfLocalhost(JNIEnv *env, const char *hostname, jboolean includeV6);\n+extern jobjectArray lookupIfLocalhost(JNIEnv *env, const char *hostname, jboolean includeV6,\n+                                      int addressesOrder);\n@@ -114,1 +116,3 @@\n-        ret = lookupIfLocalhost(env, hostname, JNI_FALSE);\n+        \/\/ java_net_spi_InetAddressResolver_LookupPolicy_IPV4_FIRST and no ordering is ok\n+        \/\/ here since only AF_INET addresses will be returned.\n+        ret = lookupIfLocalhost(env, hostname, JNI_FALSE, java_net_spi_InetAddressResolver_LookupPolicy_IPV4);\n","filename":"src\/java.base\/unix\/native\/libnet\/Inet4AddressImpl.c","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,2 @@\n+#include \"java_net_spi_InetAddressResolver_LookupPolicy.h\"\n+\n@@ -77,1 +79,1 @@\n-lookupIfLocalhost(JNIEnv *env, const char *hostname, jboolean includeV6)\n+lookupIfLocalhost(JNIEnv *env, const char *hostname, jboolean includeV6, int characteristics)\n@@ -154,1 +156,1 @@\n-    if ((*env)->GetStaticBooleanField(env, ia_class, ia_preferIPv6AddressID)) {\n+    if ((characteristics & java_net_spi_InetAddressResolver_LookupPolicy_IPV6_FIRST) != 0) {\n@@ -207,1 +209,1 @@\n-                                                 jstring host) {\n+                                                 jstring host, jint characteristics) {\n@@ -227,1 +229,1 @@\n-    hints.ai_family = AF_UNSPEC;\n+    hints.ai_family = lookupCharacteristicsToAddressFamily(characteristics);\n@@ -234,1 +236,1 @@\n-        ret = lookupIfLocalhost(env, hostname, JNI_TRUE);\n+        ret = lookupIfLocalhost(env, hostname, JNI_TRUE, characteristics);\n@@ -245,2 +247,0 @@\n-        int addressPreference =\n-            (*env)->GetStaticIntField(env, ia_class, ia_preferIPv6AddressID);;\n@@ -325,1 +325,1 @@\n-        if (addressPreference == java_net_InetAddress_PREFER_IPV6_VALUE) {\n+        if ((characteristics & java_net_spi_InetAddressResolver_LookupPolicy_IPV6_FIRST) != 0) {\n@@ -328,1 +328,1 @@\n-        } else if (addressPreference == java_net_InetAddress_PREFER_IPV4_VALUE) {\n+        } else if ((characteristics & java_net_spi_InetAddressResolver_LookupPolicy_IPV4_FIRST) != 0) {\n@@ -331,1 +331,1 @@\n-        } else if (addressPreference == java_net_InetAddress_PREFER_SYSTEM_VALUE) {\n+        } else {\n@@ -374,1 +374,2 @@\n-            if (addressPreference == java_net_InetAddress_PREFER_SYSTEM_VALUE) {\n+            \/\/ Check if addresses are requested to be returned in SYSTEM order\n+            if (addressesInSystemOrder(characteristics)) {\n","filename":"src\/java.base\/unix\/native\/libnet\/Inet6AddressImpl.c","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"java_net_spi_InetAddressResolver_LookupPolicy.h\"\n@@ -59,1 +60,1 @@\n-                                                 jstring host) {\n+                                                 jstring host, jint characteristics) {\n@@ -79,1 +80,1 @@\n-    hints.ai_family = AF_UNSPEC;\n+    hints.ai_family = lookupCharacteristicsToAddressFamily(characteristics);\n@@ -91,2 +92,0 @@\n-        int addressPreference =\n-            (*env)->GetStaticIntField(env, ia_class, ia_preferIPv6AddressID);\n@@ -171,1 +170,1 @@\n-        if (addressPreference == java_net_InetAddress_PREFER_IPV6_VALUE) {\n+        if ((characteristics & java_net_spi_InetAddressResolver_LookupPolicy_IPV6_FIRST) != 0) {\n@@ -174,1 +173,1 @@\n-        } else if (addressPreference == java_net_InetAddress_PREFER_IPV4_VALUE) {\n+        } else if ((characteristics & java_net_spi_InetAddressResolver_LookupPolicy_IPV4_FIRST) != 0) {\n@@ -177,1 +176,1 @@\n-        } else if (addressPreference == java_net_InetAddress_PREFER_SYSTEM_VALUE) {\n+        } else {\n@@ -220,1 +219,2 @@\n-            if (addressPreference == java_net_InetAddress_PREFER_SYSTEM_VALUE) {\n+            \/\/ Check if addresses are requested to be returned in SYSTEM order\n+            if (addressesInSystemOrder(characteristics)) {\n","filename":"src\/java.base\/windows\/native\/libnet\/Inet6AddressImpl.c","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -62,1 +62,2 @@\n-     *  13: no changes (switch expressions and text blocks in preview)\n+     *  13: no changes (text blocks in preview; switch expressions in\n+     *      second preview)\n@@ -64,2 +65,6 @@\n-     *      preview, text blocks in preview again)\n-     *  15: text blocks (records and pattern matching in preview again)\n+     *      preview; text blocks in second preview)\n+     *  15: text blocks (sealed classes in preview; records and pattern\n+     *      matching in second preview)\n+     *  16: records and pattern matching (sealed classes in second preview)\n+     *  17: sealed classes, floating-point always strict\n+     *  18: TBD\n@@ -187,0 +192,1 @@\n+     * No major changes from the prior release.\n@@ -195,0 +201,1 @@\n+     * No major changes from the prior release.\n@@ -224,2 +231,2 @@\n-     * Additions in this release include pattern matching for {@code\n-     * instanceof} and records.\n+     * Additions in this release include records and pattern matching\n+     * for {@code instanceof}.\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/SourceVersion.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,2 @@\n-     * <p>Note that an annotation mirror of a marker annotation type\n+     * @apiNote\n+     * An annotation mirror of a marker annotation type\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/AnnotationMirror.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -120,2 +120,3 @@\n-     * Implicit modifiers, such as the {@code public} and {@code static}\n-     * modifiers of interface members, are included.\n+     * Implicit modifiers, such as the {@code public} and {@code\n+     * static} modifiers of interface members (JLS section {@jls\n+     * 9.3}), are included.\n@@ -233,0 +234,1 @@\n+     * @jls 8.10 Record Classes\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Element.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,2 @@\n- * as done for {@link visitModule visitModule}. The implementations of\n+ * as done for {@link visitModule visitModule} and {@link\n+ * visitRecordComponent visitRecordComponent}. The implementations of\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/ElementVisitor.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @jls 8.10.1 Record Components\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/RecordComponentElement.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+     * @jls 8.10.3 Record Members\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/TypeElement.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+ * @see javax.lang.model.util.Types#getNoType(TypeKind)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/NoType.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+ * @see javax.lang.model.util.Types#getNullType()\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/NullType.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+ * @see javax.lang.model.util.Types#getPrimitiveType(TypeKind)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/PrimitiveType.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -430,0 +430,1 @@\n+         * @jls 8.10.3 Record Members\n@@ -546,1 +547,1 @@\n-     * A {@link NestingKind#TOP_LEVEL top-level} class or\n+     * A {@linkplain NestingKind#TOP_LEVEL top-level} class or\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-    public final static long NOPOS = -1;\n+    public static final long NOPOS = -1;\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/Diagnostic.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -202,2 +202,2 @@\n-     * @return @{code true} if the variable is defined;\n-     *         @{code false} otherwise\n+     * @return {@code true} if the variable is defined;\n+     *         {@code false} otherwise\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/beans\/decoder\/DocumentHandler.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n- *     <td>{@link NumericShaper#ARABIC NumericShaper.ARABIC}\n+ *     <th scope=\"row\">{@link NumericShaper#ARABIC NumericShaper.ARABIC}\n@@ -126,1 +126,0 @@\n- *   <\/tr>\n@@ -128,1 +127,1 @@\n- *     <td>{@link NumericShaper.Range#ARABIC}\n+ *     <th scope=\"row\">{@link NumericShaper.Range#ARABIC}\n@@ -135,2 +134,2 @@\n- *     <th scope=\"row\">Tai Tham\n- *     <td>{@link NumericShaper.Range#TAI_THAM_HORA}\n+ *     <th scope=\"rowgroup\">Tai Tham\n+ *     <th scope=\"row\">{@link NumericShaper.Range#TAI_THAM_HORA}\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/font\/NumericShaper.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3678,1 +3678,1 @@\n-     * @param state if {@code true}, all parents of @{code path} and path are marked as expanded.\n+     * @param state if {@code true}, all parents of {@code path} and path are marked as expanded.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JTree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-     * Return {@code true} if @{code a} contains {@code b}\n+     * Return {@code true} if {@code a} contains {@code b}\n@@ -114,1 +114,1 @@\n-     * @return {@code true} if @{code a} contains {@code b}\n+     * @return {@code true} if {@code a} contains {@code b}\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/SwingUtilities.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-     * that does not specify an {@code InputEvent}, or @{code null}\n+     * that does not specify an {@code InputEvent}, or {@code null}\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/event\/HyperlinkEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-     * The Component that the @{code ComboBoxEditor} uses for editing.\n+     * The Component that the {@code ComboBoxEditor} uses for editing.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicComboBoxUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-    static abstract class NonNullMXBeanMapping extends MXBeanMapping {\n+    abstract static class NonNullMXBeanMapping extends MXBeanMapping {\n@@ -939,1 +939,1 @@\n-    private static abstract class CompositeBuilder {\n+    private abstract static class CompositeBuilder {\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/mbeanserver\/DefaultMXBeanMappingFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    final public static boolean ALLOW_NONPUBLIC_MBEAN;\n+    public static final boolean ALLOW_NONPUBLIC_MBEAN;\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/mbeanserver\/Introspector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-    final private static String[] attributeNames = new String[] {\n+    private static final String[] attributeNames = new String[] {\n@@ -109,1 +109,1 @@\n-    final public ObjectName preRegister (MBeanServer server, ObjectName name)\n+    public final ObjectName preRegister (MBeanServer server, ObjectName name)\n@@ -115,1 +115,1 @@\n-    final public void postRegister (Boolean registrationDone) {\n+    public final void postRegister (Boolean registrationDone) {\n@@ -118,1 +118,1 @@\n-    final public void preDeregister()\n+    public final void preDeregister()\n@@ -124,1 +124,1 @@\n-    final public void postDeregister() {\n+    public final void postDeregister() {\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/mbeanserver\/MBeanServerDelegateImpl.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-    private static abstract class Handler {\n+    private abstract static class Handler {\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/mbeanserver\/MXBeanProxy.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-    abstract protected NotificationResult fetchNotifs(long clientSequenceNumber,\n+    protected abstract NotificationResult fetchNotifs(long clientSequenceNumber,\n@@ -154,1 +154,1 @@\n-    abstract protected Integer addListenerForMBeanRemovedNotif()\n+    protected abstract Integer addListenerForMBeanRemovedNotif()\n@@ -157,1 +157,1 @@\n-    abstract protected void removeListenerForMBeanRemovedNotif(Integer id)\n+    protected abstract void removeListenerForMBeanRemovedNotif(Integer id)\n@@ -164,1 +164,1 @@\n-    abstract protected void lostNotifs(String message, long number);\n+    protected abstract void lostNotifs(String message, long number);\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/internal\/ClientNotifForwarder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-final public class HashedPasswordManager {\n+public final class HashedPasswordManager {\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/security\/HashedPasswordManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -358,1 +358,1 @@\n-    public synchronized static\n+    public static synchronized\n","filename":"src\/java.management\/share\/classes\/javax\/management\/MBeanServerFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -354,1 +354,1 @@\n-    static final private Property[] _Empty_property_array = new Property[0];\n+    private static final Property[] _Empty_property_array = new Property[0];\n","filename":"src\/java.management\/share\/classes\/javax\/management\/ObjectName.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-    final private AccessControlContext acc = AccessController.getContext();\n+    private final AccessControlContext acc = AccessController.getContext();\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/RequiredModelMBean.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,1 +130,1 @@\n-    final private Map<Integer,Object[]> timerTable =\n+    private final Map<Integer,Object[]> timerTable =\n@@ -165,1 +165,1 @@\n-    volatile private int counterID = 0;\n+    private volatile int counterID = 0;\n","filename":"src\/java.management\/share\/classes\/javax\/management\/timer\/Timer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,1 @@\n-    native static void setVerboseClass(boolean value);\n+    static native void setVerboseClass(boolean value);\n","filename":"src\/java.management\/share\/classes\/sun\/management\/ClassLoadingImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-    abstract public MBeanNotificationInfo[] getNotificationInfo();\n+    public abstract MBeanNotificationInfo[] getNotificationInfo();\n","filename":"src\/java.management\/share\/classes\/sun\/management\/NotificationEmitterSupport.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,2 +68,2 @@\n-    private native static String getVersion0();\n-    private native static void initOptionalSupportFields();\n+    private static native String getVersion0();\n+    private static native void initOptionalSupportFields();\n","filename":"src\/java.management\/share\/classes\/sun\/management\/VMManagementImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import java.security.AccessControlContext;\n@@ -316,2 +315,0 @@\n-        @SuppressWarnings(\"removal\")\n-        final AccessControlContext acc = AccessController.getContext();\n@@ -321,1 +318,1 @@\n-                AccessController.doPrivileged\n+                AccessController.doPrivilegedWithCombiner\n@@ -324,1 +321,1 @@\n-                        Subject accSubj = Subject.getSubject(acc);\n+                        Subject currSubj = Subject.current();\n@@ -326,1 +323,1 @@\n-                        if (accSubj != null) {\n+                        if (currSubj != null) {\n@@ -329,1 +326,1 @@\n-                                accSubj.getPrivateCredentials\n+                                currSubj.getPrivateCredentials\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/GSSUtil.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,1 +163,1 @@\n-    synchronized public MechanismFactory getMechFactory(Oid mechOid)\n+    public synchronized MechanismFactory getMechFactory(Oid mechOid)\n@@ -180,1 +180,1 @@\n-    synchronized public MechanismFactory getMechFactory(Oid mechOid,\n+    public synchronized MechanismFactory getMechFactory(Oid mechOid,\n@@ -338,1 +338,1 @@\n-    synchronized public void addProviderAtFront(Provider p, Oid mechOid)\n+    public synchronized void addProviderAtFront(Provider p, Oid mechOid)\n@@ -370,1 +370,1 @@\n-    synchronized public void addProviderAtEnd(Provider p, Oid mechOid)\n+    public synchronized void addProviderAtEnd(Provider p, Oid mechOid)\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/ProviderList.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,1 +150,1 @@\n-    synchronized public final void getProps(int number, MessageProp prop) {\n+    public final synchronized void getProps(int number, MessageProp prop) {\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/TokenTracker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.io.IOException;\n@@ -36,1 +35,0 @@\n-import java.security.AccessControlContext;\n@@ -68,1 +66,0 @@\n-        final AccessControlContext acc = AccessController.getContext();\n@@ -72,1 +69,1 @@\n-            creds = AccessController.doPrivileged(\n+            creds = AccessController.doPrivilegedWithCombiner(\n@@ -77,1 +74,1 @@\n-                        serverPrinc, acc);\n+                        serverPrinc);\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/krb5\/Krb5AcceptCredential.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.security.AccessControlContext;\n@@ -644,4 +643,0 @@\n-                    @SuppressWarnings(\"removal\")\n-                    final AccessControlContext acc =\n-                        AccessController.getContext();\n-\n@@ -653,1 +648,1 @@\n-                           var tmp = AccessController.doPrivileged(\n+                           var tmp = AccessController.doPrivilegedWithCombiner(\n@@ -668,2 +663,1 @@\n-                                        peerName.getKrb5PrincipalName().getName(),\n-                                        acc);\n+                                        peerName.getKrb5PrincipalName().getName());\n@@ -713,1 +707,1 @@\n-                                AccessController.doPrivileged(\n+                                AccessController.doPrivilegedWithCombiner(\n@@ -716,1 +710,1 @@\n-                                        return (Subject.getSubject(acc));\n+                                        return (Subject.current());\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/krb5\/Krb5Context.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.security.AccessControlContext;\n@@ -368,2 +367,0 @@\n-        final AccessControlContext acc = AccessController.getContext();\n-\n@@ -374,1 +371,1 @@\n-            return AccessController.doPrivileged(\n+            return AccessController.doPrivilegedWithCombiner(\n@@ -380,2 +377,1 @@\n-                        realCaller,\n-                        clientPrincipal, acc);\n+                        realCaller, clientPrincipal);\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/krb5\/Krb5InitCredential.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.security.AccessControlContext;\n@@ -65,4 +64,2 @@\n-        String clientPrincipal, String serverPrincipal,\n-        @SuppressWarnings(\"removal\") AccessControlContext acc) throws LoginException {\n-\n-        \/\/ Try to get ticket from acc's Subject\n+            String clientPrincipal, String serverPrincipal) {\n+        \/\/ Try to get ticket from current Subject\n@@ -70,1 +67,1 @@\n-        Subject accSubj = Subject.getSubject(acc);\n+        Subject currSubj = Subject.current();\n@@ -72,1 +69,1 @@\n-            SubjectComber.find(accSubj, serverPrincipal, clientPrincipal,\n+            SubjectComber.find(currSubj, serverPrincipal, clientPrincipal,\n@@ -86,2 +83,1 @@\n-            String clientPrincipal,\n-            @SuppressWarnings(\"removal\") AccessControlContext acc) throws LoginException {\n+            String clientPrincipal) throws LoginException {\n@@ -89,3 +85,1 @@\n-        \/\/ Try to get ticket from acc's Subject\n-        @SuppressWarnings(\"removal\")\n-        Subject accSubj = Subject.getSubject(acc);\n+        Subject currSubj = Subject.current();\n@@ -93,1 +87,1 @@\n-                SubjectComber.find(accSubj, null, clientPrincipal,\n+                SubjectComber.find(currSubj, null, clientPrincipal,\n@@ -109,2 +103,0 @@\n-     *\n-     * NOTE: This method is also used by JSSE Kerberos Cipher Suites\n@@ -113,2 +105,1 @@\n-        String serverPrincipal, @SuppressWarnings(\"removal\") AccessControlContext acc)\n-                throws LoginException {\n+            String serverPrincipal) throws LoginException {\n@@ -116,2 +107,1 @@\n-        @SuppressWarnings(\"removal\")\n-        Subject accSubj = Subject.getSubject(acc);\n+        Subject currSubj = Subject.current();\n@@ -119,2 +109,2 @@\n-        if (accSubj != null) {\n-            sc = ServiceCreds.getInstance(accSubj, serverPrincipal);\n+        if (currSubj != null) {\n+            sc = ServiceCreds.getInstance(currSubj, serverPrincipal);\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/krb5\/Krb5Util.java","additions":11,"deletions":21,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,1 @@\n-    private synchronized static KeyTab getInstance0(String s) {\n+    private static synchronized KeyTab getInstance0(String s) {\n@@ -432,1 +432,1 @@\n-    public synchronized static KeyTab create()\n+    public static synchronized KeyTab create()\n@@ -441,1 +441,1 @@\n-    public synchronized static KeyTab create(String name)\n+    public static synchronized KeyTab create(String name)\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/internal\/ktab\/KeyTab.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-    private final static long serialVersionUID = 1346879911706545215L;\n+    private static final long serialVersionUID = 1346879911706545215L;\n","filename":"src\/java.smartcardio\/share\/classes\/javax\/smartcardio\/CardNotPresentException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,6 +77,6 @@\n-    private final static int A_CONNECT              = 0x01;\n-    private final static int A_EXCLUSIVE            = 0x02;\n-    private final static int A_GET_BASIC_CHANNEL    = 0x04;\n-    private final static int A_OPEN_LOGICAL_CHANNEL = 0x08;\n-    private final static int A_RESET                = 0x10;\n-    private final static int A_TRANSMIT_CONTROL     = 0x20;\n+    private static final int A_CONNECT              = 0x01;\n+    private static final int A_EXCLUSIVE            = 0x02;\n+    private static final int A_GET_BASIC_CHANNEL    = 0x04;\n+    private static final int A_OPEN_LOGICAL_CHANNEL = 0x08;\n+    private static final int A_RESET                = 0x10;\n+    private static final int A_TRANSMIT_CONTROL     = 0x20;\n@@ -85,1 +85,1 @@\n-    private final static int A_ALL                  = 0x3f;\n+    private static final int A_ALL                  = 0x3f;\n@@ -87,1 +87,1 @@\n-    private final static int[] ARRAY_MASKS = {\n+    private static final int[] ARRAY_MASKS = {\n@@ -97,6 +97,6 @@\n-    private final static String S_CONNECT              = \"connect\";\n-    private final static String S_EXCLUSIVE            = \"exclusive\";\n-    private final static String S_GET_BASIC_CHANNEL    = \"getBasicChannel\";\n-    private final static String S_OPEN_LOGICAL_CHANNEL = \"openLogicalChannel\";\n-    private final static String S_RESET                = \"reset\";\n-    private final static String S_TRANSMIT_CONTROL     = \"transmitControl\";\n+    private static final String S_CONNECT              = \"connect\";\n+    private static final String S_EXCLUSIVE            = \"exclusive\";\n+    private static final String S_GET_BASIC_CHANNEL    = \"getBasicChannel\";\n+    private static final String S_OPEN_LOGICAL_CHANNEL = \"openLogicalChannel\";\n+    private static final String S_RESET                = \"reset\";\n+    private static final String S_TRANSMIT_CONTROL     = \"transmitControl\";\n@@ -104,1 +104,1 @@\n-    private final static String S_ALL                  = \"*\";\n+    private static final String S_ALL                  = \"*\";\n@@ -106,1 +106,1 @@\n-    private final static String[] ARRAY_STRINGS = {\n+    private static final String[] ARRAY_STRINGS = {\n","filename":"src\/java.smartcardio\/share\/classes\/javax\/smartcardio\/CardPermission.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-    private final static String PROP_NAME =\n+    private static final String PROP_NAME =\n@@ -94,1 +94,1 @@\n-    private final static String defaultType;\n+    private static final String defaultType;\n@@ -96,1 +96,1 @@\n-    private final static TerminalFactory defaultFactory;\n+    private static final TerminalFactory defaultFactory;\n@@ -136,1 +136,1 @@\n-        final static Provider INSTANCE = new NoneProvider();\n+        static final Provider INSTANCE = new NoneProvider();\n@@ -143,1 +143,1 @@\n-        final static TerminalFactorySpi INSTANCE = new NoneFactorySpi();\n+        static final TerminalFactorySpi INSTANCE = new NoneFactorySpi();\n@@ -153,1 +153,1 @@\n-        final static CardTerminals INSTANCE = new NoneCardTerminals();\n+        static final CardTerminals INSTANCE = new NoneCardTerminals();\n","filename":"src\/java.smartcardio\/share\/classes\/javax\/smartcardio\/TerminalFactory.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-    private final static boolean t0GetResponse =\n+    private static final boolean t0GetResponse =\n@@ -120,1 +120,1 @@\n-    private final static boolean t1GetResponse =\n+    private static final boolean t1GetResponse =\n@@ -123,1 +123,1 @@\n-    private final static boolean t1StripLe =\n+    private static final boolean t1StripLe =\n@@ -154,2 +154,2 @@\n-    private final static int RESPONSE_ITERATIONS = 256;\n-    private final static byte[] B0 = new byte[0];\n+    private static final int RESPONSE_ITERATIONS = 256;\n+    private static final byte[] B0 = new byte[0];\n","filename":"src\/java.smartcardio\/share\/classes\/sun\/security\/smartcardio\/ChannelImpl.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,39 +96,39 @@\n-    final static int SCARD_S_SUCCESS             = 0x00000000;\n-    final static int SCARD_E_CANCELLED           = 0x80100002;\n-    final static int SCARD_E_CANT_DISPOSE        = 0x8010000E;\n-    final static int SCARD_E_INSUFFICIENT_BUFFER = 0x80100008;\n-    final static int SCARD_E_INVALID_ATR         = 0x80100015;\n-    final static int SCARD_E_INVALID_HANDLE      = 0x80100003;\n-    final static int SCARD_E_INVALID_PARAMETER   = 0x80100004;\n-    final static int SCARD_E_INVALID_TARGET      = 0x80100005;\n-    final static int SCARD_E_INVALID_VALUE       = 0x80100011;\n-    final static int SCARD_E_NO_MEMORY           = 0x80100006;\n-    final static int SCARD_F_COMM_ERROR          = 0x80100013;\n-    final static int SCARD_F_INTERNAL_ERROR      = 0x80100001;\n-    final static int SCARD_F_UNKNOWN_ERROR       = 0x80100014;\n-    final static int SCARD_F_WAITED_TOO_LONG     = 0x80100007;\n-    final static int SCARD_E_UNKNOWN_READER      = 0x80100009;\n-    final static int SCARD_E_TIMEOUT             = 0x8010000A;\n-    final static int SCARD_E_SHARING_VIOLATION   = 0x8010000B;\n-    final static int SCARD_E_NO_SMARTCARD        = 0x8010000C;\n-    final static int SCARD_E_UNKNOWN_CARD        = 0x8010000D;\n-    final static int SCARD_E_PROTO_MISMATCH      = 0x8010000F;\n-    final static int SCARD_E_NOT_READY           = 0x80100010;\n-    final static int SCARD_E_SYSTEM_CANCELLED    = 0x80100012;\n-    final static int SCARD_E_NOT_TRANSACTED      = 0x80100016;\n-    final static int SCARD_E_READER_UNAVAILABLE  = 0x80100017;\n-\n-    final static int SCARD_W_UNSUPPORTED_CARD    = 0x80100065;\n-    final static int SCARD_W_UNRESPONSIVE_CARD   = 0x80100066;\n-    final static int SCARD_W_UNPOWERED_CARD      = 0x80100067;\n-    final static int SCARD_W_RESET_CARD          = 0x80100068;\n-    final static int SCARD_W_REMOVED_CARD        = 0x80100069;\n-    final static int SCARD_W_INSERTED_CARD       = 0x8010006A;\n-\n-    final static int SCARD_E_UNSUPPORTED_FEATURE = 0x8010001F;\n-    final static int SCARD_E_PCI_TOO_SMALL       = 0x80100019;\n-    final static int SCARD_E_READER_UNSUPPORTED  = 0x8010001A;\n-    final static int SCARD_E_DUPLICATE_READER    = 0x8010001B;\n-    final static int SCARD_E_CARD_UNSUPPORTED    = 0x8010001C;\n-    final static int SCARD_E_NO_SERVICE          = 0x8010001D;\n-    final static int SCARD_E_SERVICE_STOPPED     = 0x8010001E;\n+    static final int SCARD_S_SUCCESS             = 0x00000000;\n+    static final int SCARD_E_CANCELLED           = 0x80100002;\n+    static final int SCARD_E_CANT_DISPOSE        = 0x8010000E;\n+    static final int SCARD_E_INSUFFICIENT_BUFFER = 0x80100008;\n+    static final int SCARD_E_INVALID_ATR         = 0x80100015;\n+    static final int SCARD_E_INVALID_HANDLE      = 0x80100003;\n+    static final int SCARD_E_INVALID_PARAMETER   = 0x80100004;\n+    static final int SCARD_E_INVALID_TARGET      = 0x80100005;\n+    static final int SCARD_E_INVALID_VALUE       = 0x80100011;\n+    static final int SCARD_E_NO_MEMORY           = 0x80100006;\n+    static final int SCARD_F_COMM_ERROR          = 0x80100013;\n+    static final int SCARD_F_INTERNAL_ERROR      = 0x80100001;\n+    static final int SCARD_F_UNKNOWN_ERROR       = 0x80100014;\n+    static final int SCARD_F_WAITED_TOO_LONG     = 0x80100007;\n+    static final int SCARD_E_UNKNOWN_READER      = 0x80100009;\n+    static final int SCARD_E_TIMEOUT             = 0x8010000A;\n+    static final int SCARD_E_SHARING_VIOLATION   = 0x8010000B;\n+    static final int SCARD_E_NO_SMARTCARD        = 0x8010000C;\n+    static final int SCARD_E_UNKNOWN_CARD        = 0x8010000D;\n+    static final int SCARD_E_PROTO_MISMATCH      = 0x8010000F;\n+    static final int SCARD_E_NOT_READY           = 0x80100010;\n+    static final int SCARD_E_SYSTEM_CANCELLED    = 0x80100012;\n+    static final int SCARD_E_NOT_TRANSACTED      = 0x80100016;\n+    static final int SCARD_E_READER_UNAVAILABLE  = 0x80100017;\n+\n+    static final int SCARD_W_UNSUPPORTED_CARD    = 0x80100065;\n+    static final int SCARD_W_UNRESPONSIVE_CARD   = 0x80100066;\n+    static final int SCARD_W_UNPOWERED_CARD      = 0x80100067;\n+    static final int SCARD_W_RESET_CARD          = 0x80100068;\n+    static final int SCARD_W_REMOVED_CARD        = 0x80100069;\n+    static final int SCARD_W_INSERTED_CARD       = 0x8010006A;\n+\n+    static final int SCARD_E_UNSUPPORTED_FEATURE = 0x8010001F;\n+    static final int SCARD_E_PCI_TOO_SMALL       = 0x80100019;\n+    static final int SCARD_E_READER_UNSUPPORTED  = 0x8010001A;\n+    static final int SCARD_E_DUPLICATE_READER    = 0x8010001B;\n+    static final int SCARD_E_CARD_UNSUPPORTED    = 0x8010001C;\n+    static final int SCARD_E_NO_SERVICE          = 0x8010001D;\n+    static final int SCARD_E_SERVICE_STOPPED     = 0x8010001E;\n@@ -137,1 +137,1 @@\n-    final static int SCARD_E_NO_READERS_AVAILABLE = 0x8010002E;\n+    static final int SCARD_E_NO_READERS_AVAILABLE = 0x8010002E;\n@@ -139,2 +139,2 @@\n-    final static int WINDOWS_ERROR_INVALID_HANDLE = 6;\n-    final static int WINDOWS_ERROR_INVALID_PARAMETER = 87;\n+    static final int WINDOWS_ERROR_INVALID_HANDLE = 6;\n+    static final int WINDOWS_ERROR_INVALID_PARAMETER = 87;\n@@ -143,30 +143,30 @@\n-    final static int SCARD_SCOPE_USER      =  0x0000;\n-    final static int SCARD_SCOPE_TERMINAL  =  0x0001;\n-    final static int SCARD_SCOPE_SYSTEM    =  0x0002;\n-    final static int SCARD_SCOPE_GLOBAL    =  0x0003;\n-\n-    final static int SCARD_SHARE_EXCLUSIVE =  0x0001;\n-    final static int SCARD_SHARE_SHARED    =  0x0002;\n-    final static int SCARD_SHARE_DIRECT    =  0x0003;\n-\n-    final static int SCARD_LEAVE_CARD      =  0x0000;\n-    final static int SCARD_RESET_CARD      =  0x0001;\n-    final static int SCARD_UNPOWER_CARD    =  0x0002;\n-    final static int SCARD_EJECT_CARD      =  0x0003;\n-\n-    final static int SCARD_STATE_UNAWARE     = 0x0000;\n-    final static int SCARD_STATE_IGNORE      = 0x0001;\n-    final static int SCARD_STATE_CHANGED     = 0x0002;\n-    final static int SCARD_STATE_UNKNOWN     = 0x0004;\n-    final static int SCARD_STATE_UNAVAILABLE = 0x0008;\n-    final static int SCARD_STATE_EMPTY       = 0x0010;\n-    final static int SCARD_STATE_PRESENT     = 0x0020;\n-    final static int SCARD_STATE_ATRMATCH    = 0x0040;\n-    final static int SCARD_STATE_EXCLUSIVE   = 0x0080;\n-    final static int SCARD_STATE_INUSE       = 0x0100;\n-    final static int SCARD_STATE_MUTE        = 0x0200;\n-    final static int SCARD_STATE_UNPOWERED   = 0x0400;\n-\n-    final static int TIMEOUT_INFINITE = 0xffffffff;\n-\n-    private final static char[] hexDigits = \"0123456789abcdef\".toCharArray();\n+    static final int SCARD_SCOPE_USER      =  0x0000;\n+    static final int SCARD_SCOPE_TERMINAL  =  0x0001;\n+    static final int SCARD_SCOPE_SYSTEM    =  0x0002;\n+    static final int SCARD_SCOPE_GLOBAL    =  0x0003;\n+\n+    static final int SCARD_SHARE_EXCLUSIVE =  0x0001;\n+    static final int SCARD_SHARE_SHARED    =  0x0002;\n+    static final int SCARD_SHARE_DIRECT    =  0x0003;\n+\n+    static final int SCARD_LEAVE_CARD      =  0x0000;\n+    static final int SCARD_RESET_CARD      =  0x0001;\n+    static final int SCARD_UNPOWER_CARD    =  0x0002;\n+    static final int SCARD_EJECT_CARD      =  0x0003;\n+\n+    static final int SCARD_STATE_UNAWARE     = 0x0000;\n+    static final int SCARD_STATE_IGNORE      = 0x0001;\n+    static final int SCARD_STATE_CHANGED     = 0x0002;\n+    static final int SCARD_STATE_UNKNOWN     = 0x0004;\n+    static final int SCARD_STATE_UNAVAILABLE = 0x0008;\n+    static final int SCARD_STATE_EMPTY       = 0x0010;\n+    static final int SCARD_STATE_PRESENT     = 0x0020;\n+    static final int SCARD_STATE_ATRMATCH    = 0x0040;\n+    static final int SCARD_STATE_EXCLUSIVE   = 0x0080;\n+    static final int SCARD_STATE_INUSE       = 0x0100;\n+    static final int SCARD_STATE_MUTE        = 0x0200;\n+    static final int SCARD_STATE_UNPOWERED   = 0x0400;\n+\n+    static final int TIMEOUT_INFINITE = 0xffffffff;\n+\n+    private static final char[] hexDigits = \"0123456789abcdef\".toCharArray();\n","filename":"src\/java.smartcardio\/share\/classes\/sun\/security\/smartcardio\/PCSC.java","additions":73,"deletions":73,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    private final static String PROP_NAME = \"sun.security.smartcardio.library\";\n+    private static final String PROP_NAME = \"sun.security.smartcardio.library\";\n@@ -49,3 +49,3 @@\n-    private final static String LIB1 = \"\/usr\/$LIBISA\/libpcsclite.so\";\n-    private final static String LIB2 = \"\/usr\/local\/$LIBISA\/libpcsclite.so\";\n-    private final static String PCSC_FRAMEWORK = \"\/System\/Library\/Frameworks\/PCSC.framework\/Versions\/Current\/PCSC\";\n+    private static final String LIB1 = \"\/usr\/$LIBISA\/libpcsclite.so\";\n+    private static final String LIB2 = \"\/usr\/local\/$LIBISA\/libpcsclite.so\";\n+    private static final String PCSC_FRAMEWORK = \"\/System\/Library\/Frameworks\/PCSC.framework\/Versions\/Current\/PCSC\";\n@@ -141,11 +141,11 @@\n-    final static int SCARD_PROTOCOL_T0     =  0x0001;\n-    final static int SCARD_PROTOCOL_T1     =  0x0002;\n-    final static int SCARD_PROTOCOL_RAW    =  0x0004;\n-\n-    final static int SCARD_UNKNOWN         =  0x0001;\n-    final static int SCARD_ABSENT          =  0x0002;\n-    final static int SCARD_PRESENT         =  0x0004;\n-    final static int SCARD_SWALLOWED       =  0x0008;\n-    final static int SCARD_POWERED         =  0x0010;\n-    final static int SCARD_NEGOTIABLE      =  0x0020;\n-    final static int SCARD_SPECIFIC        =  0x0040;\n+    static final int SCARD_PROTOCOL_T0     =  0x0001;\n+    static final int SCARD_PROTOCOL_T1     =  0x0002;\n+    static final int SCARD_PROTOCOL_RAW    =  0x0004;\n+\n+    static final int SCARD_UNKNOWN         =  0x0001;\n+    static final int SCARD_ABSENT          =  0x0002;\n+    static final int SCARD_PRESENT         =  0x0004;\n+    static final int SCARD_SWALLOWED       =  0x0008;\n+    static final int SCARD_POWERED         =  0x0010;\n+    static final int SCARD_NEGOTIABLE      =  0x0020;\n+    static final int SCARD_SPECIFIC        =  0x0040;\n","filename":"src\/java.smartcardio\/unix\/classes\/sun\/security\/smartcardio\/PlatformPCSC.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -61,3 +61,3 @@\n-    final static int SCARD_PROTOCOL_T0     =  0x0001;\n-    final static int SCARD_PROTOCOL_T1     =  0x0002;\n-    final static int SCARD_PROTOCOL_RAW    =  0x10000;\n+    static final int SCARD_PROTOCOL_T0     =  0x0001;\n+    static final int SCARD_PROTOCOL_T1     =  0x0002;\n+    static final int SCARD_PROTOCOL_RAW    =  0x10000;\n@@ -65,7 +65,7 @@\n-    final static int SCARD_UNKNOWN         =  0x0000;\n-    final static int SCARD_ABSENT          =  0x0001;\n-    final static int SCARD_PRESENT         =  0x0002;\n-    final static int SCARD_SWALLOWED       =  0x0003;\n-    final static int SCARD_POWERED         =  0x0004;\n-    final static int SCARD_NEGOTIABLE      =  0x0005;\n-    final static int SCARD_SPECIFIC        =  0x0006;\n+    static final int SCARD_UNKNOWN         =  0x0000;\n+    static final int SCARD_ABSENT          =  0x0001;\n+    static final int SCARD_PRESENT         =  0x0002;\n+    static final int SCARD_SWALLOWED       =  0x0003;\n+    static final int SCARD_POWERED         =  0x0004;\n+    static final int SCARD_NEGOTIABLE      =  0x0005;\n+    static final int SCARD_SPECIFIC        =  0x0006;\n","filename":"src\/java.smartcardio\/windows\/classes\/sun\/security\/smartcardio\/PlatformPCSC.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-    private final static String PROTOCOL_VERSION = \"1\";\n+    private static final String PROTOCOL_VERSION = \"1\";\n@@ -141,1 +141,1 @@\n-    private final static int ATTACH_ERROR_BADVERSION = 101;\n+    private static final int ATTACH_ERROR_BADVERSION = 101;\n","filename":"src\/jdk.attach\/aix\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-    private final static String PROTOCOL_VERSION = \"1\";\n+    private static final String PROTOCOL_VERSION = \"1\";\n@@ -145,1 +145,1 @@\n-    private final static int ATTACH_ERROR_BADVERSION = 101;\n+    private static final int ATTACH_ERROR_BADVERSION = 101;\n","filename":"src\/jdk.attach\/linux\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-    private final static String PROTOCOL_VERSION = \"1\";\n+    private static final String PROTOCOL_VERSION = \"1\";\n@@ -141,1 +141,1 @@\n-    private final static int ATTACH_ERROR_BADVERSION = 101;\n+    private static final int ATTACH_ERROR_BADVERSION = 101;\n","filename":"src\/jdk.attach\/macosx\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -797,1 +797,1 @@\n-    public static abstract class TypeSymbol extends Symbol {\n+    public abstract static class TypeSymbol extends Symbol {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-    public static abstract class StructuralTypeMapping<S> extends Types.TypeMapping<S> {\n+    public abstract static class StructuralTypeMapping<S> extends Types.TypeMapping<S> {\n@@ -1789,1 +1789,1 @@\n-    public static abstract class DelegatedType extends Type {\n+    public abstract static class DelegatedType extends Type {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4899,1 +4899,1 @@\n-    public static abstract class DefaultTypeVisitor<R,S> implements Type.Visitor<R,S> {\n+    public abstract static class DefaultTypeVisitor<R,S> implements Type.Visitor<R,S> {\n@@ -4926,1 +4926,1 @@\n-    public static abstract class DefaultSymbolVisitor<R,S> implements Symbol.Visitor<R,S> {\n+    public abstract static class DefaultSymbolVisitor<R,S> implements Symbol.Visitor<R,S> {\n@@ -4949,1 +4949,1 @@\n-    public static abstract class SimpleVisitor<R,S> extends DefaultTypeVisitor<R,S> {\n+    public abstract static class SimpleVisitor<R,S> extends DefaultTypeVisitor<R,S> {\n@@ -4969,1 +4969,1 @@\n-    public static abstract class TypeRelation extends SimpleVisitor<Boolean,Type> {}\n+    public abstract static class TypeRelation extends SimpleVisitor<Boolean,Type> {}\n@@ -4979,1 +4979,1 @@\n-    public static abstract class UnaryVisitor<R> extends SimpleVisitor<R,Void> {\n+    public abstract static class UnaryVisitor<R> extends SimpleVisitor<R,Void> {\n@@ -5044,1 +5044,1 @@\n-    public static abstract class SignatureGenerator {\n+    public abstract static class SignatureGenerator {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -344,1 +344,1 @@\n-    static abstract class BaseAnalyzer extends TreeScanner {\n+    abstract static class BaseAnalyzer extends TreeScanner {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    public synchronized static JRTIndex getSharedInstance() {\n+    public static synchronized JRTIndex getSharedInstance() {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/JRTIndex.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -447,1 +447,1 @@\n-    protected static abstract class LocationHandler {\n+    protected abstract static class LocationHandler {\n@@ -516,1 +516,1 @@\n-    private static abstract class BasicLocationHandler extends LocationHandler {\n+    private abstract static class BasicLocationHandler extends LocationHandler {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/Locations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -257,1 +257,1 @@\n-    private static abstract class Indy extends StringConcat {\n+    private abstract static class Indy extends StringConcat {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/StringConcat.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -262,1 +262,1 @@\n-                transient final Method method;\n+                final transient Method method;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/AnnotationProxyMaker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1118,1 +1118,1 @@\n-    private static abstract class TagParser {\n+    private abstract static class TagParser {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/DocCommentParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3034,0 +3034,1 @@\n+            JCCaseLabel defaultPattern = toP(F.at(pos).DefaultCaseLabel());\n@@ -3036,1 +3037,0 @@\n-            int patternPos = token.pos;\n@@ -3052,1 +3052,0 @@\n-            JCCaseLabel defaultPattern = toP(F.at(patternPos).DefaultCaseLabel());\n@@ -4991,1 +4990,1 @@\n-    protected static abstract class AbstractEndPosTable implements EndPosTable {\n+    protected abstract static class AbstractEndPosTable implements EndPosTable {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -297,1 +297,1 @@\n-    public static abstract class DCEndPosTree<T extends DCEndPosTree<T>> extends DCTree {\n+    public abstract static class DCEndPosTree<T extends DCEndPosTree<T>> extends DCTree {\n@@ -384,1 +384,1 @@\n-    public static abstract class DCBlockTag extends DCTree implements BlockTagTree {\n+    public abstract static class DCBlockTag extends DCTree implements BlockTagTree {\n@@ -391,1 +391,1 @@\n-    public static abstract class DCInlineTag extends DCEndPosTree<DCInlineTag> implements InlineTagTree {\n+    public abstract static class DCInlineTag extends DCEndPosTree<DCInlineTag> implements InlineTagTree {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DCTree.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -692,1 +692,1 @@\n-    public static abstract class JCStatement extends JCTree implements StatementTree {\n+    public abstract static class JCStatement extends JCTree implements StatementTree {\n@@ -705,1 +705,1 @@\n-    public static abstract class JCCaseLabel extends JCTree implements CaseLabelTree {\n+    public abstract static class JCCaseLabel extends JCTree implements CaseLabelTree {\n@@ -713,1 +713,1 @@\n-    public static abstract class JCExpression extends JCCaseLabel implements ExpressionTree {\n+    public abstract static class JCExpression extends JCCaseLabel implements ExpressionTree {\n@@ -743,1 +743,1 @@\n-    public static abstract class JCPolyExpression extends JCExpression {\n+    public abstract static class JCPolyExpression extends JCExpression {\n@@ -765,1 +765,1 @@\n-    public static abstract class JCFunctionalExpression extends JCPolyExpression {\n+    public abstract static class JCFunctionalExpression extends JCPolyExpression {\n@@ -2059,1 +2059,1 @@\n-    public static abstract class JCOperatorExpression extends JCExpression {\n+    public abstract static class JCOperatorExpression extends JCExpression {\n@@ -2241,1 +2241,1 @@\n-    public static abstract class JCPattern extends JCCaseLabel\n+    public abstract static class JCPattern extends JCCaseLabel\n@@ -2992,1 +2992,1 @@\n-    public static abstract class JCDirective extends JCTree\n+    public abstract static class JCDirective extends JCTree\n@@ -3404,1 +3404,1 @@\n-    public static abstract class Visitor {\n+    public abstract static class Visitor {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-        public static abstract class Node extends GraphUtils.AbstractNode<ClassSymbol, Node>\n+        public abstract static class Node extends GraphUtils.AbstractNode<ClassSymbol, Node>\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Dependencies.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-    static abstract class NodeVisitor<D, N extends Node<D, N>, A> {\n+    abstract static class NodeVisitor<D, N extends Node<D, N>, A> {\n@@ -95,1 +95,1 @@\n-    public static abstract class AbstractNode<D, N extends AbstractNode<D, N>> implements Node<D, N> {\n+    public abstract static class AbstractNode<D, N extends AbstractNode<D, N>> implements Node<D, N> {\n@@ -132,1 +132,1 @@\n-    public static abstract class TarjanNode<D, N extends TarjanNode<D, N>> extends AbstractNode<D, N>\n+    public abstract static class TarjanNode<D, N extends TarjanNode<D, N>> extends AbstractNode<D, N>\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/GraphUtils.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -482,1 +482,1 @@\n-    public static abstract class DiagnosticInfo {\n+    public abstract static class DiagnosticInfo {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/JCDiagnostic.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    public static abstract class DiagnosticHandler {\n+    public abstract static class DiagnosticHandler {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Log.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -208,1 +208,1 @@\n-    public static abstract class Table {\n+    public abstract static class Table {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Name.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-    private final static int NETSCAPE_SLOT_ID = 0x1;\n+    private static final int NETSCAPE_SLOT_ID = 0x1;\n@@ -81,1 +81,1 @@\n-    private final static int PRIVATE_KEY_SLOT_ID = 0x2;\n+    private static final int PRIVATE_KEY_SLOT_ID = 0x2;\n@@ -83,1 +83,1 @@\n-    private final static int FIPS_SLOT_ID = 0x3;\n+    private static final int FIPS_SLOT_ID = 0x3;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Secmod.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n- * This class holds only final static member variables that are constants\n+ * This class holds only static final member variables that are constants\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/Constants.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-    private native static void cleanUp(long hCryptProv, long hCryptKey);\n+    private static native void cleanUp(long hCryptProv, long hCryptKey);\n@@ -105,1 +105,1 @@\n-    protected native static String getContainerName(long hCryptProv);\n+    protected static native String getContainerName(long hCryptProv);\n@@ -107,1 +107,1 @@\n-    protected native static String getKeyType(long hCryptKey);\n+    protected static native String getKeyType(long hCryptKey);\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/CKey.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -508,1 +508,1 @@\n-    private native static byte[] encryptDecrypt(byte[] data, int dataSize,\n+    private static native byte[] encryptDecrypt(byte[] data, int dataSize,\n@@ -510,1 +510,1 @@\n-    private native static byte[] cngEncryptDecrypt(byte[] data, int dataSize,\n+    private static native byte[] cngEncryptDecrypt(byte[] data, int dataSize,\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/CRSACipher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -746,1 +746,1 @@\n-    native static byte[] signCngHash(\n+    static native byte[] signCngHash(\n@@ -756,1 +756,1 @@\n-    private native static boolean verifyCngSignedHash(\n+    private static native boolean verifyCngSignedHash(\n@@ -848,1 +848,1 @@\n-    private native static byte[] signHash(boolean noHashOID, byte[] hash,\n+    private static native byte[] signHash(boolean noHashOID, byte[] hash,\n@@ -855,1 +855,1 @@\n-    private native static boolean verifySignedHash(byte[] hash, int hashSize,\n+    private static native boolean verifySignedHash(byte[] hash, int hashSize,\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/CSignature.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-  public static abstract class OopTypes {\n+  public abstract static class OopTypes {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/compiler\/OopMapValue.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-    private native static void init0()\n+    private static native void init0()\n@@ -111,1 +111,1 @@\n-    public native static int  getAddressSize() ;\n+    public static native int  getAddressSize() ;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/BsdDebuggerLocal.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-final public class BsdAARCH64CFrame extends BasicCFrame {\n+public final class BsdAARCH64CFrame extends BasicCFrame {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/aarch64\/BsdAARCH64CFrame.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-final public class BsdAMD64CFrame extends BasicCFrame {\n+public final class BsdAMD64CFrame extends BasicCFrame {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/amd64\/BsdAMD64CFrame.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-final public class BsdX86CFrame extends BasicCFrame {\n+public final class BsdX86CFrame extends BasicCFrame {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/x86\/BsdX86CFrame.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-    private native static void init0()\n+    private static native void init0()\n@@ -118,1 +118,1 @@\n-    public native static int  getAddressSize() ;\n+    public static native int  getAddressSize() ;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/LinuxDebuggerLocal.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-final public class LinuxAARCH64CFrame extends BasicCFrame {\n+public final class LinuxAARCH64CFrame extends BasicCFrame {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/aarch64\/LinuxAARCH64CFrame.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-final public class LinuxAMD64CFrame extends BasicCFrame {\n+public final class LinuxAMD64CFrame extends BasicCFrame {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/amd64\/LinuxAMD64CFrame.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-final public class LinuxPPC64CFrame extends BasicCFrame {\n+public final class LinuxPPC64CFrame extends BasicCFrame {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/ppc64\/LinuxPPC64CFrame.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-final public class LinuxX86CFrame extends BasicCFrame {\n+public final class LinuxX86CFrame extends BasicCFrame {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/x86\/LinuxX86CFrame.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    static private long hrmFieldOffset;\n+    private static long hrmFieldOffset;\n@@ -53,1 +53,1 @@\n-    static private long g1ReservedFieldOffset;\n+    private static long g1ReservedFieldOffset;\n@@ -55,1 +55,1 @@\n-    static private CIntegerField summaryBytesUsedField;\n+    private static CIntegerField summaryBytesUsedField;\n@@ -57,1 +57,1 @@\n-    static private AddressField monitoringSupportField;\n+    private static AddressField monitoringSupportField;\n@@ -59,1 +59,1 @@\n-    static private long oldSetFieldOffset;\n+    private static long oldSetFieldOffset;\n@@ -61,1 +61,1 @@\n-    static private long archiveSetFieldOffset;\n+    private static long archiveSetFieldOffset;\n@@ -63,1 +63,1 @@\n-    static private long humongousSetFieldOffset;\n+    private static long humongousSetFieldOffset;\n@@ -73,1 +73,1 @@\n-    static private synchronized void initialize(TypeDataBase db) {\n+    private static synchronized void initialize(TypeDataBase db) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/G1CollectedHeap.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-    static private AddressField baseField;\n+    private static AddressField baseField;\n@@ -47,1 +47,1 @@\n-    static private CIntegerField lengthField;\n+    private static CIntegerField lengthField;\n@@ -49,1 +49,1 @@\n-    static private AddressField biasedBaseField;\n+    private static AddressField biasedBaseField;\n@@ -51,1 +51,1 @@\n-    static private CIntegerField biasField;\n+    private static CIntegerField biasField;\n@@ -53,1 +53,1 @@\n-    static private CIntegerField shiftByField;\n+    private static CIntegerField shiftByField;\n@@ -63,1 +63,1 @@\n-    static private synchronized void initialize(TypeDataBase db) {\n+    private static synchronized void initialize(TypeDataBase db) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/G1HeapRegionTable.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    static private CIntegerField edenSpaceCommittedField;\n+    private static CIntegerField edenSpaceCommittedField;\n@@ -43,1 +43,1 @@\n-    static private CIntegerField edenSpaceUsedField;\n+    private static CIntegerField edenSpaceUsedField;\n@@ -45,1 +45,1 @@\n-    static private CIntegerField survivorSpaceCommittedField;\n+    private static CIntegerField survivorSpaceCommittedField;\n@@ -47,1 +47,1 @@\n-    static private CIntegerField survivorSpaceUsedField;\n+    private static CIntegerField survivorSpaceUsedField;\n@@ -49,1 +49,1 @@\n-    static private CIntegerField oldGenCommittedField;\n+    private static CIntegerField oldGenCommittedField;\n@@ -51,1 +51,1 @@\n-    static private CIntegerField oldGenUsedField;\n+    private static CIntegerField oldGenUsedField;\n@@ -61,1 +61,1 @@\n-    static private synchronized void initialize(TypeDataBase db) {\n+    private static synchronized void initialize(TypeDataBase db) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/G1MonitoringSupport.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-    static private AddressField topField;\n+    private static AddressField topField;\n@@ -53,1 +53,1 @@\n-    static private CIntegerField grainBytesField;\n+    private static CIntegerField grainBytesField;\n@@ -67,1 +67,1 @@\n-    static private synchronized void initialize(TypeDataBase db) {\n+    private static synchronized void initialize(TypeDataBase db) {\n@@ -81,1 +81,1 @@\n-    static public long grainBytes() {\n+    public static long grainBytes() {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/HeapRegion.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-    static private long regionsFieldOffset;\n+    private static long regionsFieldOffset;\n@@ -54,1 +54,1 @@\n-    static private synchronized void initialize(TypeDataBase db) {\n+    private static synchronized void initialize(TypeDataBase db) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/HeapRegionManager.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-    static private CIntegerField lengthField;\n+    private static CIntegerField lengthField;\n@@ -55,1 +55,1 @@\n-    static private synchronized void initialize(TypeDataBase db) {\n+    private static synchronized void initialize(TypeDataBase db) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/HeapRegionSetBase.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-abstract public class GenCollectedHeap extends CollectedHeap {\n+public abstract class GenCollectedHeap extends CollectedHeap {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/shared\/GenCollectedHeap.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2017, 2021, Red Hat, Inc. All rights reserved.\n@@ -45,5 +45,5 @@\n-    static private CIntegerField numRegions;\n-    static private CIntegerField used;\n-    static private CIntegerField committed;\n-    static private AddressField  regions;\n-    static private CIntegerField logMinObjAlignmentInBytes;\n+    private static CIntegerField numRegions;\n+    private static CIntegerField used;\n+    private static CIntegerField committed;\n+    private static AddressField  regions;\n+    private static CIntegerField logMinObjAlignmentInBytes;\n@@ -51,1 +51,1 @@\n-    static private long regionPtrFieldSize;\n+    private static long regionPtrFieldSize;\n@@ -60,1 +60,1 @@\n-    static private synchronized void initialize(TypeDataBase db) {\n+    private static synchronized void initialize(TypeDataBase db) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/shenandoah\/ShenandoahHeap.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2017, 2021, Red Hat, Inc. All rights reserved.\n@@ -77,1 +77,1 @@\n-    static private synchronized void initialize(TypeDataBase db) {\n+    private static synchronized void initialize(TypeDataBase db) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/shenandoah\/ShenandoahHeapRegion.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    static private synchronized void initialize(TypeDataBase db) {\n+    private static synchronized void initialize(TypeDataBase db) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZAttachedArrayForForwarding.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    static private synchronized void initialize(TypeDataBase db) {\n+    private static synchronized void initialize(TypeDataBase db) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZForwarding.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    static private synchronized void initialize(TypeDataBase db) {\n+    private static synchronized void initialize(TypeDataBase db) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZForwardingEntry.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    static private synchronized void initialize(TypeDataBase db) {\n+    private static synchronized void initialize(TypeDataBase db) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZForwardingTable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    static private synchronized void initialize(TypeDataBase db) {\n+    private static synchronized void initialize(TypeDataBase db) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZGlobals.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-    static private synchronized void initialize(TypeDataBase db) {\n+    private static synchronized void initialize(TypeDataBase db) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZGlobalsForVMStructs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    static private synchronized void initialize(TypeDataBase db) {\n+    private static synchronized void initialize(TypeDataBase db) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZGranuleMapForForwarding.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    static private synchronized void initialize(TypeDataBase db) {\n+    private static synchronized void initialize(TypeDataBase db) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZGranuleMapForPageTable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    static private synchronized void initialize(TypeDataBase db) {\n+    private static synchronized void initialize(TypeDataBase db) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZPage.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-    static private synchronized void initialize(TypeDataBase db) {\n+    private static synchronized void initialize(TypeDataBase db) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZPageAllocator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    static private synchronized void initialize(TypeDataBase db) {\n+    private static synchronized void initialize(TypeDataBase db) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZPageTable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-    static private synchronized void initialize(TypeDataBase db) {\n+    private static synchronized void initialize(TypeDataBase db) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZRelocate.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-    static private synchronized void initialize(TypeDataBase db) {\n+    private static synchronized void initialize(TypeDataBase db) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZVirtualMemory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -480,1 +480,1 @@\n-  final private static String[] nameForTag = new String[] {\n+  private static final String[] nameForTag = new String[] {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ConstantPool.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-  static public int computeSizeInBytes(int cellCount) {\n+  public static int computeSizeInBytes(int cellCount) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/DataLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-abstract public class DefaultMetadataVisitor implements MetadataVisitor {\n+public abstract class DefaultMetadataVisitor implements MetadataVisitor {\n@@ -49,1 +49,1 @@\n-  abstract public void doMetadata(MetadataField field, boolean isVMField);\n+  public abstract void doMetadata(MetadataField field, boolean isVMField);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/DefaultMetadataVisitor.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-abstract public class Metadata extends VMObject {\n+public abstract class Metadata extends VMObject {\n@@ -89,1 +89,1 @@\n-  abstract public void printValueOn(PrintStream tty);\n+  public abstract void printValueOn(PrintStream tty);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Metadata.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -334,1 +334,1 @@\n-  static public int extraNbCells(DataLayout dataLayout) {\n+  public static int extraNbCells(DataLayout dataLayout) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/MethodData.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-  static public int typeIndex(int i) {\n+  public static int typeIndex(int i) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ParametersTypeData.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-  static public int methodIndex() {\n+  public static int methodIndex() {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/SpeculativeTrapData.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-  static private AddressField nameField;\n+  private static AddressField nameField;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/CallRuntimeNode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-  static private AddressField nameField;\n+  private static AddressField nameField;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/CallStaticJavaNode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-  static abstract class Instantiator {\n+  abstract static class Instantiator {\n@@ -81,1 +81,1 @@\n-  static public Node create(Address addr) {\n+  public static Node create(Address addr) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/opto\/Node.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-abstract public class InstanceConstructor<T> {\n+public abstract class InstanceConstructor<T> {\n@@ -45,1 +45,1 @@\n-  abstract public T instantiateWrapperFor(Address addr) throws WrongTypeException;\n+  public abstract T instantiateWrapperFor(Address addr) throws WrongTypeException;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/InstanceConstructor.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -655,1 +655,1 @@\n-  static public long getAddressValue(Address addr) {\n+  public static long getAddressValue(Address addr) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/VM.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-    static private void writeShort(byte[] buf, int index, short value) {\n+    private static void writeShort(byte[] buf, int index, short value) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/jcore\/ByteCodeRewriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,2 @@\n-  final private Address addr;\n-  final private Type type;\n+  private final Address addr;\n+  private final Type type;\n@@ -68,2 +68,2 @@\n-    final private Field field;\n-    final private Type holder;\n+    private final Field field;\n+    private final Type holder;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ui\/tree\/CTypeTreeNodeAdapter.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,1 +130,1 @@\n-    abstract protected int calculateOopDumpRecordSize(Oop oop) throws IOException;\n+    protected abstract int calculateOopDumpRecordSize(Oop oop) throws IOException;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/AbstractHeapGraphWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,5 @@\n+\n+\/\/ Simple dummy function so this library appears as a normal library to tooling.\n+char* syslookup() {\n+  return \"syslookup\";\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/native\/libsyslookup\/syslookup.c","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -510,4 +510,4 @@\n-            for (int i = 0; i < queryArgs.length; i++) {\n-                if (queryArgs[i].startsWith(\"mode=\")) {\n-                    int index = queryArgs[i].indexOf('=');\n-                    return queryArgs[i].substring(index+1);\n+            for (String queryArg : queryArgs) {\n+                if (queryArg.startsWith(\"mode=\")) {\n+                    int index = queryArg.indexOf('=');\n+                    return queryArg.substring(index + 1);\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/monitor\/HostIdentifier.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -388,4 +388,4 @@\n-            for (int i = 0; i < queryArgs.length; i++) {\n-                if (queryArgs[i].startsWith(\"mode=\")) {\n-                    int index = queryArgs[i].indexOf('=');\n-                    return queryArgs[i].substring(index+1);\n+            for (String queryArg : queryArgs) {\n+                if (queryArg.startsWith(\"mode=\")) {\n+                    int index = queryArg.indexOf('=');\n+                    return queryArg.substring(index + 1);\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/monitor\/VmIdentifier.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -208,2 +208,1 @@\n-                for (Iterator<String> i = al.iterator(); i.hasNext() && m == null; ) {\n-                    String alias = i.next();\n+                for (String alias : al) {\n@@ -211,0 +210,3 @@\n+                    if (m != null) {\n+                        break;\n+                    }\n@@ -296,2 +298,1 @@\n-        for (Iterator<Map.Entry<String, Monitor>> i = monitorSet.iterator(); i.hasNext(); \/* empty *\/) {\n-            Map.Entry<String, Monitor> me = i.next();\n+        for (Map.Entry<String, Monitor> me : monitorSet) {\n@@ -306,1 +307,1 @@\n-                 matches.add(me.getValue());\n+                matches.add(me.getValue());\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/perfdata\/monitor\/PerfDataBufferImpl.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-import java.lang.reflect.*;\n-import java.io.*;\n@@ -155,2 +153,1 @@\n-        for (Iterator<VmListener> i = registered.iterator(); i.hasNext(); \/* empty *\/) {\n-            VmListener l = i.next();\n+        for (VmListener l : registered) {\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/perfdata\/monitor\/protocol\/local\/LocalMonitoredVm.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import sun.jvmstat.monitor.*;\n-import sun.jvmstat.monitor.event.*;\n@@ -108,2 +106,2 @@\n-            for (int i = 0 ; i < dirs.length; i ++) {\n-                if (!dirs[i].isDirectory()) {\n+            for (File subDir : dirs) {\n+                if (!subDir.isDirectory()) {\n@@ -114,1 +112,1 @@\n-                File[] files = dirs[i].listFiles(userDirFileFilter);\n+                File[] files = subDir.listFiles(userDirFileFilter);\n@@ -116,3 +114,3 @@\n-                    for (int j = 0; j < files.length; j++) {\n-                        if (files[j].isFile() && files[j].canRead()) {\n-                            int vmid = PerfDataFile.getLocalVmId(files[j]);\n+                    for (File file : files) {\n+                        if (file.isFile() && file.canRead()) {\n+                            int vmid = PerfDataFile.getLocalVmId(file);\n@@ -120,1 +118,1 @@\n-                              jvmSet.add(vmid);\n+                                jvmSet.add(vmid);\n@@ -130,3 +128,3 @@\n-                for (int j = 0; j < files.length; j++) {\n-                    if (files[j].isFile() && files[j].canRead()) {\n-                        int vmid = PerfDataFile.getLocalVmId(files[j]);\n+                for (File file : files) {\n+                    if (file.isFile() && file.canRead()) {\n+                        int vmid = PerfDataFile.getLocalVmId(file);\n@@ -134,1 +132,1 @@\n-                          jvmSet.add(vmid);\n+                            jvmSet.add(vmid);\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/perfdata\/monitor\/protocol\/local\/LocalVmManager.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -173,2 +173,1 @@\n-        for (Iterator<HostListener> i = registered.iterator(); i.hasNext(); \/* empty *\/) {\n-            HostListener l = i.next();\n+        for (HostListener l : registered) {\n@@ -201,2 +200,1 @@\n-            for (Iterator<Integer> i = activeVms.iterator(); i.hasNext(); \/* empty *\/) {\n-                Integer vmid = i.next();\n+            for (Integer vmid : activeVms) {\n@@ -209,3 +207,1 @@\n-            for (Iterator<Integer> i = lastActiveVms.iterator(); i.hasNext();\n-                    \/* empty *\/) {\n-                Integer o = i.next();\n+            for (Integer o : lastActiveVms) {\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/perfdata\/monitor\/protocol\/local\/MonitoredHostProvider.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,3 +84,3 @@\n-        for (int j = 0; j < basicTypes.length; j++) {\n-            if (basicTypes[j].value == c) {\n-                return (basicTypes[j]);\n+        for (TypeCode basicType : basicTypes) {\n+            if (basicType.value == c) {\n+                return basicType;\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/perfdata\/monitor\/v2_0\/TypeCode.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    private final static int MAX_ESCAPE_SEQUENCE_LENGTH = 100;\n+    private static final int MAX_ESCAPE_SEQUENCE_LENGTH = 100;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/AnsiWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-    private final static int MAX_ESCAPE_SEQUENCE_LENGTH = 100;\n+    private static final int MAX_ESCAPE_SEQUENCE_LENGTH = 100;\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/WindowsAnsiWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -242,1 +242,1 @@\n-    static abstract class Option {\n+    abstract static class Option {\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/GNUStyleOptions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.AnnotationValue;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.Comment;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeMemberWriter;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;\n+\n+\n+\/**\n+ * Writes annotation interface member documentation in HTML format.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class AnnotationTypeMemberWriterImpl extends AbstractMemberWriter\n+    implements AnnotationTypeMemberWriter, MemberSummaryWriter {\n+\n+    \/**\n+     * We generate separate summaries for required and optional annotation interface members,\n+     * so we need dedicated writer instances for each kind. For the details section, a single\n+     * shared list is generated so a special {@code ANY} value is provided for this case.\n+     *\/\n+    enum Kind {\n+        OPTIONAL,\n+        REQUIRED,\n+        ANY\n+    }\n+\n+    private final Kind kind;\n+\n+    \/**\n+     * Constructs a new AnnotationTypeMemberWriterImpl for any kind of member.\n+     *\n+     * @param writer The writer for the class that the member belongs to.\n+     *\/\n+    public AnnotationTypeMemberWriterImpl(SubWriterHolderWriter writer) {\n+        super(writer);\n+        this.kind = Kind.ANY;\n+    }\n+\n+    \/**\n+     * Constructs a new AnnotationTypeMemberWriterImpl for a specific kind of member.\n+     *\n+     * @param writer         the writer that will write the output.\n+     * @param annotationType the AnnotationType that holds this member.\n+     * @param kind           the kind of annotation interface members to handle.\n+     *\/\n+    public AnnotationTypeMemberWriterImpl(SubWriterHolderWriter writer,\n+                                          TypeElement annotationType,\n+                                          Kind kind) {\n+        super(writer, annotationType);\n+        this.kind = kind;\n+    }\n+\n+    @Override\n+    public Content getMemberSummaryHeader(TypeElement typeElement,\n+            Content memberSummaryTree) {\n+        switch (kind) {\n+            case OPTIONAL -> memberSummaryTree.add(selectComment(\n+                    MarkerComments.START_OF_ANNOTATION_TYPE_OPTIONAL_MEMBER_SUMMARY,\n+                    MarkerComments.START_OF_ANNOTATION_INTERFACE_OPTIONAL_MEMBER_SUMMARY));\n+            case REQUIRED -> memberSummaryTree.add(selectComment(\n+                    MarkerComments.START_OF_ANNOTATION_TYPE_REQUIRED_MEMBER_SUMMARY,\n+                    MarkerComments.START_OF_ANNOTATION_INTERFACE_REQUIRED_MEMBER_SUMMARY));\n+            case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n+        }\n+        Content memberTree = new ContentBuilder();\n+        writer.addSummaryHeader(this, memberTree);\n+        return memberTree;\n+    }\n+\n+    @Override\n+    public Content getMemberTreeHeader() {\n+        return writer.getMemberTreeHeader();\n+    }\n+\n+    @Override\n+    public void addSummary(Content summariesList, Content content) {\n+        writer.addSummary(HtmlStyle.memberSummary,\n+                switch (kind) {\n+                    case REQUIRED -> HtmlIds.ANNOTATION_TYPE_REQUIRED_ELEMENT_SUMMARY;\n+                    case OPTIONAL -> HtmlIds.ANNOTATION_TYPE_OPTIONAL_ELEMENT_SUMMARY;\n+                    case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n+                },\n+                summariesList, content);\n+    }\n+\n+    @Override\n+    public void addAnnotationDetailsMarker(Content memberDetails) {\n+        memberDetails.add(selectComment(\n+                MarkerComments.START_OF_ANNOTATION_TYPE_DETAILS,\n+                MarkerComments.START_OF_ANNOTATION_INTERFACE_DETAILS));\n+    }\n+\n+    @Override\n+    public Content getAnnotationDetailsTreeHeader() {\n+        Content memberDetailsTree = new ContentBuilder();\n+        Content heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n+                contents.annotationTypeDetailsLabel);\n+        memberDetailsTree.add(heading);\n+        return memberDetailsTree;\n+    }\n+\n+    @Override\n+    public Content getAnnotationDocTreeHeader(Element member) {\n+        Content annotationDocTree = new ContentBuilder();\n+        Content heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n+                Text.of(name(member)));\n+        annotationDocTree.add(heading);\n+        return HtmlTree.SECTION(HtmlStyle.detail, annotationDocTree)\n+                .setId(htmlIds.forMember(typeElement, (ExecutableElement) member));\n+    }\n+\n+    @Override\n+    public Content getSignature(Element member) {\n+        return new Signatures.MemberSignature(member, this)\n+                .setType(getType(member))\n+                .setAnnotations(writer.getAnnotationInfo(member, true))\n+                .toContent();\n+    }\n+\n+    @Override\n+    public void addDeprecated(Element member, Content annotationDocTree) {\n+        addDeprecatedInfo(member, annotationDocTree);\n+    }\n+\n+    @Override\n+    public void addPreview(Element member, Content contentTree) {\n+        addPreviewInfo(member, contentTree);\n+    }\n+\n+    @Override\n+    public void addComments(Element member, Content annotationDocTree) {\n+        addComment(member, annotationDocTree);\n+    }\n+\n+    @Override\n+    public void addTags(Element member, Content annotationDocTree) {\n+        writer.addTagsInfo(member, annotationDocTree);\n+    }\n+\n+    @Override\n+    public Content getAnnotationDetails(Content annotationDetailsTreeHeader, Content annotationDetailsTree) {\n+        Content annotationDetails = new ContentBuilder(annotationDetailsTreeHeader, annotationDetailsTree);\n+        return getMemberTree(HtmlTree.SECTION(HtmlStyle.memberDetails, annotationDetails));\n+    }\n+\n+    @Override\n+    public void addSummaryLabel(Content memberTree) {\n+        HtmlTree label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n+                switch (kind) {\n+                    case REQUIRED -> contents.annotateTypeRequiredMemberSummaryLabel;\n+                    case OPTIONAL -> contents.annotateTypeOptionalMemberSummaryLabel;\n+                    case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n+                });\n+        memberTree.add(label);\n+    }\n+\n+    \/**\n+     * Get the caption for the summary table.\n+     * @return the caption\n+     *\/\n+    protected Content getCaption() {\n+        return contents.getContent(\n+                switch (kind) {\n+                    case REQUIRED -> \"doclet.Annotation_Type_Required_Members\";\n+                    case OPTIONAL -> \"doclet.Annotation_Type_Optional_Members\";\n+                    case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n+                });\n+    }\n+\n+    @Override\n+    public TableHeader getSummaryTableHeader(Element member) {\n+        return new TableHeader(contents.modifierAndTypeLabel,\n+                switch (kind) {\n+                    case REQUIRED -> contents.annotationTypeRequiredMemberLabel;\n+                    case OPTIONAL -> contents.annotationTypeOptionalMemberLabel;\n+                    case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n+                },\n+                contents.descriptionLabel);\n+    }\n+\n+    @Override\n+    protected Table createSummaryTable() {\n+        return new Table(HtmlStyle.summaryTable)\n+                .setCaption(getCaption())\n+                .setHeader(getSummaryTableHeader(typeElement))\n+                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colSecond, HtmlStyle.colLast);\n+    }\n+\n+    @Override\n+    public void addInheritedSummaryLabel(TypeElement typeElement, Content inheritedTree) {\n+    }\n+\n+    @Override\n+    protected void addSummaryLink(HtmlLinkInfo.Kind context, TypeElement typeElement, Element member,\n+                                  Content tdSummary) {\n+        Content memberLink = writer.getDocLink(context, utils.getEnclosingTypeElement(member), member,\n+                name(member), HtmlStyle.memberNameLink);\n+        Content code = HtmlTree.CODE(memberLink);\n+        tdSummary.add(code);\n+    }\n+\n+    @Override\n+    protected void addInheritedSummaryLink(TypeElement typeElement,\n+            Element member, Content linksTree) {\n+        \/\/Not applicable.\n+    }\n+\n+    @Override\n+    protected void addSummaryType(Element member, Content tdSummaryType) {\n+        addModifierAndType(member, getType(member), tdSummaryType);\n+    }\n+\n+    @Override\n+    protected Content getSummaryLink(Element member) {\n+        String name = utils.getFullyQualifiedName(member) + \".\" + member.getSimpleName();\n+        return writer.getDocLink(HtmlLinkInfo.Kind.MEMBER_DEPRECATED_PREVIEW, member, name);\n+    }\n+\n+    protected Comment selectComment(Comment c1, Comment c2) {\n+        HtmlConfiguration configuration = writer.configuration;\n+        SourceVersion sv = configuration.docEnv.getSourceVersion();\n+        return sv.compareTo(SourceVersion.RELEASE_16) < 0 ? c1 : c2;\n+    }\n+\n+    private TypeMirror getType(Element member) {\n+        return utils.isExecutableElement(member)\n+                ? utils.getReturnType(typeElement, (ExecutableElement) member)\n+                : member.asType();\n+    }\n+\n+    public void addDefaultValueInfo(Element member, Content annotationDocTree) {\n+        if (utils.isAnnotationType(member)) {\n+            ExecutableElement ee = (ExecutableElement) member;\n+            AnnotationValue value = ee.getDefaultValue();\n+            if (value != null) {\n+                Content dl = HtmlTree.DL(HtmlStyle.notes);\n+                dl.add(HtmlTree.DT(contents.default_));\n+                dl.add(HtmlTree.DD(Text.of(value.toString())));\n+                annotationDocTree.add(dl);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AnnotationTypeMemberWriterImpl.java","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import javax.lang.model.element.AnnotationValue;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeOptionalMemberWriter;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;\n-\n-\n-\/**\n- * Writes annotation type optional member documentation in HTML format.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class AnnotationTypeOptionalMemberWriterImpl extends\n-        AnnotationTypeRequiredMemberWriterImpl\n-    implements AnnotationTypeOptionalMemberWriter, MemberSummaryWriter {\n-\n-    \/**\n-     * Construct a new AnnotationTypeOptionalMemberWriterImpl.\n-     *\n-     * @param writer         the writer that will write the output.\n-     * @param annotationType the AnnotationType that holds this member.\n-     *\/\n-    public AnnotationTypeOptionalMemberWriterImpl(SubWriterHolderWriter writer,\n-        TypeElement annotationType) {\n-        super(writer, annotationType);\n-    }\n-\n-    @Override\n-    public Content getMemberSummaryHeader(TypeElement typeElement,\n-            Content memberSummaryTree) {\n-        memberSummaryTree.add(selectComment(\n-                MarkerComments.START_OF_ANNOTATION_TYPE_OPTIONAL_MEMBER_SUMMARY,\n-                MarkerComments.START_OF_ANNOTATION_INTERFACE_OPTIONAL_MEMBER_SUMMARY));\n-        Content memberTree = new ContentBuilder();\n-        writer.addSummaryHeader(this, memberTree);\n-        return memberTree;\n-    }\n-\n-    @Override\n-    public void addSummary(Content summariesList, Content content) {\n-        writer.addSummary(HtmlStyle.memberSummary,\n-                HtmlIds.ANNOTATION_TYPE_OPTIONAL_ELEMENT_SUMMARY, summariesList, content);\n-    }\n-\n-    @Override\n-    public void addDefaultValueInfo(Element member, Content annotationDocTree) {\n-        if (utils.isAnnotationType(member)) {\n-            ExecutableElement ee = (ExecutableElement) member;\n-            AnnotationValue value = ee.getDefaultValue();\n-            if (value != null) {\n-                Content dl = HtmlTree.DL(HtmlStyle.notes);\n-                dl.add(HtmlTree.DT(contents.default_));\n-                dl.add(HtmlTree.DD(Text.of(value.toString())));\n-                annotationDocTree.add(dl);\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void addSummaryLabel(Content memberTree) {\n-        Content label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n-                contents.annotateTypeOptionalMemberSummaryLabel);\n-        memberTree.add(label);\n-    }\n-\n-    @Override\n-    protected Content getCaption() {\n-        return contents.getContent(\"doclet.Annotation_Type_Optional_Members\");\n-    }\n-\n-    @Override\n-    public TableHeader getSummaryTableHeader(Element member) {\n-        return new TableHeader(contents.modifierAndTypeLabel,\n-                contents.annotationTypeOptionalMemberLabel, contents.descriptionLabel);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AnnotationTypeOptionalMemberWriterImpl.java","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -1,222 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-import jdk.javadoc.internal.doclets.formats.html.markup.Comment;\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeRequiredMemberWriter;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;\n-\n-\n-\/**\n- * Writes annotation type required member documentation in HTML format.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class AnnotationTypeRequiredMemberWriterImpl extends AbstractMemberWriter\n-    implements AnnotationTypeRequiredMemberWriter, MemberSummaryWriter {\n-\n-    \/**\n-     * Construct a new AnnotationTypeRequiredMemberWriterImpl.\n-     *\n-     * @param writer         the writer that will write the output.\n-     * @param annotationType the AnnotationType that holds this member.\n-     *\/\n-    public AnnotationTypeRequiredMemberWriterImpl(SubWriterHolderWriter writer,\n-            TypeElement annotationType) {\n-        super(writer, annotationType);\n-    }\n-\n-    @Override\n-    public Content getMemberSummaryHeader(TypeElement typeElement,\n-            Content memberSummaryTree) {\n-        memberSummaryTree.add(selectComment(\n-                MarkerComments.START_OF_ANNOTATION_TYPE_REQUIRED_MEMBER_SUMMARY,\n-                MarkerComments.START_OF_ANNOTATION_INTERFACE_REQUIRED_MEMBER_SUMMARY));\n-        Content memberTree = new ContentBuilder();\n-        writer.addSummaryHeader(this, memberTree);\n-        return memberTree;\n-    }\n-\n-    @Override\n-    public Content getMemberTreeHeader() {\n-        return writer.getMemberTreeHeader();\n-    }\n-\n-    @Override\n-    public void addSummary(Content summariesList, Content content) {\n-        writer.addSummary(HtmlStyle.memberSummary,\n-                HtmlIds.ANNOTATION_TYPE_REQUIRED_ELEMENT_SUMMARY, summariesList, content);\n-    }\n-\n-    @Override\n-    public void addAnnotationDetailsMarker(Content memberDetails) {\n-        memberDetails.add(selectComment(\n-                MarkerComments.START_OF_ANNOTATION_TYPE_DETAILS,\n-                MarkerComments.START_OF_ANNOTATION_INTERFACE_DETAILS));\n-    }\n-\n-    @Override\n-    public Content getAnnotationDetailsTreeHeader() {\n-        Content memberDetailsTree = new ContentBuilder();\n-        if (!writer.printedAnnotationHeading) {\n-            Content heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n-                    contents.annotationTypeDetailsLabel);\n-            memberDetailsTree.add(heading);\n-            writer.printedAnnotationHeading = true;\n-        }\n-        return memberDetailsTree;\n-    }\n-\n-    @Override\n-    public Content getAnnotationDocTreeHeader(Element member) {\n-        Content annotationDocTree = new ContentBuilder();\n-        Content heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n-                Text.of(name(member)));\n-        annotationDocTree.add(heading);\n-        return HtmlTree.SECTION(HtmlStyle.detail, annotationDocTree)\n-                .setId(htmlIds.forMember(typeElement, (ExecutableElement) member));\n-    }\n-\n-    @Override\n-    public Content getSignature(Element member) {\n-        return new Signatures.MemberSignature(member, this)\n-                .setType(getType(member))\n-                .setAnnotations(writer.getAnnotationInfo(member, true))\n-                .toContent();\n-    }\n-\n-    @Override\n-    public void addDeprecated(Element member, Content annotationDocTree) {\n-        addDeprecatedInfo(member, annotationDocTree);\n-    }\n-\n-    @Override\n-    public void addPreview(Element member, Content contentTree) {\n-        addPreviewInfo(member, contentTree);\n-    }\n-\n-    @Override\n-    public void addComments(Element member, Content annotationDocTree) {\n-        addComment(member, annotationDocTree);\n-    }\n-\n-    @Override\n-    public void addTags(Element member, Content annotationDocTree) {\n-        writer.addTagsInfo(member, annotationDocTree);\n-    }\n-\n-    @Override\n-    public Content getAnnotationDetails(Content annotationDetailsTreeHeader, Content annotationDetailsTree) {\n-        Content annotationDetails = new ContentBuilder(annotationDetailsTreeHeader, annotationDetailsTree);\n-        return getMemberTree(HtmlTree.SECTION(HtmlStyle.memberDetails, annotationDetails));\n-    }\n-\n-    @Override\n-    public void addSummaryLabel(Content memberTree) {\n-        HtmlTree label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n-                contents.annotateTypeRequiredMemberSummaryLabel);\n-        memberTree.add(label);\n-    }\n-\n-    \/**\n-     * Get the caption for the summary table.\n-     * @return the caption\n-     *\/\n-    \/\/ Overridden by AnnotationTypeOptionalMemberWriterImpl\n-    protected Content getCaption() {\n-        return contents.getContent(\"doclet.Annotation_Type_Required_Members\");\n-    }\n-\n-    @Override\n-    public TableHeader getSummaryTableHeader(Element member) {\n-        return new TableHeader(contents.modifierAndTypeLabel,\n-                contents.annotationTypeRequiredMemberLabel, contents.descriptionLabel);\n-    }\n-\n-    @Override\n-    protected Table createSummaryTable() {\n-        return new Table(HtmlStyle.summaryTable)\n-                .setCaption(getCaption())\n-                .setHeader(getSummaryTableHeader(typeElement))\n-                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colSecond, HtmlStyle.colLast);\n-    }\n-\n-    @Override\n-    public void addInheritedSummaryLabel(TypeElement typeElement, Content inheritedTree) {\n-    }\n-\n-    @Override\n-    protected void addSummaryLink(HtmlLinkInfo.Kind context, TypeElement typeElement, Element member,\n-                                  Content tdSummary) {\n-        Content memberLink = writer.getDocLink(context, utils.getEnclosingTypeElement(member), member,\n-                name(member), HtmlStyle.memberNameLink);\n-        Content code = HtmlTree.CODE(memberLink);\n-        tdSummary.add(code);\n-    }\n-\n-    @Override\n-    protected void addInheritedSummaryLink(TypeElement typeElement,\n-            Element member, Content linksTree) {\n-        \/\/Not applicable.\n-    }\n-\n-    @Override\n-    protected void addSummaryType(Element member, Content tdSummaryType) {\n-        addModifierAndType(member, getType(member), tdSummaryType);\n-    }\n-\n-    @Override\n-    protected Content getSummaryLink(Element member) {\n-        String name = utils.getFullyQualifiedName(member) + \".\" + member.getSimpleName();\n-        return writer.getDocLink(HtmlLinkInfo.Kind.MEMBER_DEPRECATED_PREVIEW, member, name);\n-    }\n-\n-    protected Comment selectComment(Comment c1, Comment c2) {\n-        HtmlConfiguration configuration = writer.configuration;\n-        SourceVersion sv = configuration.docEnv.getSourceVersion();\n-        return sv.compareTo(SourceVersion.RELEASE_16) < 0 ? c1 : c2;\n-    }\n-\n-    private TypeMirror getType(Element member) {\n-        return utils.isExecutableElement(member)\n-                ? utils.getReturnType(typeElement, (ExecutableElement) member)\n-                : member.asType();\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AnnotationTypeRequiredMemberWriterImpl.java","additions":0,"deletions":222,"binary":false,"changes":222,"status":"deleted"},{"patch":"@@ -299,6 +299,0 @@\n-            } else if (packages.size() == 1 && packages.first().isUnnamed()) {\n-                List<TypeElement> classes = new ArrayList<>(getIncludedTypeElements());\n-                if (!classes.isEmpty()) {\n-                    TypeElement te = getValidClass(classes);\n-                    topFile = docPaths.forClass(te);\n-                }\n@@ -388,0 +382,7 @@\n+    public List<DocPath> getAdditionalScripts() {\n+        return options.additionalScripts().stream()\n+                .map(sf -> DocFile.createFileForInput(this, sf))\n+                .map(file -> DocPath.create(file.getName()))\n+                .collect(Collectors.toCollection(ArrayList::new));\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlConfiguration.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import java.io.OutputStream;\n-import java.io.Writer;\n@@ -218,1 +216,1 @@\n-            SourceToHTMLConverter.convertRoot(configuration,DocPaths.SOURCE_OUTPUT);\n+            SourceToHTMLConverter.convertRoot(configuration, DocPaths.SOURCE_OUTPUT);\n@@ -228,2 +226,2 @@\n-        performCopy(options.helpFile());\n-        performCopy(options.stylesheetFile());\n+        performCopy(options.helpFile(), DocPath.empty);\n+        performCopy(options.stylesheetFile(), DocPath.empty);\n@@ -231,1 +229,4 @@\n-            performCopy(stylesheet);\n+            performCopy(stylesheet, DocPath.empty);\n+        }\n+        for (String script : options.additionalScripts()) {\n+            performCopy(script, DocPaths.SCRIPT_DIR);\n@@ -332,1 +333,1 @@\n-            DocPath filePath = DocPaths.JQUERY_FILES.resolve(file);\n+            DocPath filePath = DocPaths.SCRIPT_DIR.resolve(file);\n@@ -431,2 +432,2 @@\n-    private void performCopy(String filename) throws DocFileIOException {\n-        if (filename.isEmpty())\n+    private void performCopy(String filename, DocPath targetPath) throws DocFileIOException {\n+        if (filename.isEmpty()) {\n@@ -434,0 +435,1 @@\n+        }\n@@ -436,1 +438,1 @@\n-        DocPath path = DocPath.create(fromfile.getName());\n+        DocPath path = targetPath.resolve(fromfile.getName());\n@@ -438,1 +440,1 @@\n-        if (toFile.isSameFile(fromfile))\n+        if (toFile.isSameFile(fromfile)) {\n@@ -440,0 +442,1 @@\n+        }\n@@ -442,1 +445,1 @@\n-                fromfile.toString(), path.getPath());\n+                fromfile.getPath(), path.getPath());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -180,5 +180,0 @@\n-    \/**\n-     * To check whether annotation heading is printed or not.\n-     *\/\n-    protected boolean printedAnnotationHeading = false;\n-\n@@ -467,0 +462,1 @@\n+                .setAdditionalScripts(configuration.getAdditionalScripts())\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -445,0 +445,2 @@\n+            \/\/ We generate separate summaries for optional and required annotation members\n+            case ANNOTATION_TYPE_MEMBER -> throw new IllegalArgumentException(\"unsupported member kind\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlIds.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,5 @@\n+    \/**\n+     * Argument for command-line option {@code --add-script}.\n+     *\/\n+    private List<String> additionalScripts = new ArrayList<>();\n+\n@@ -202,0 +207,8 @@\n+                new Option(resources, \"--add-script\", 1) {\n+                    @Override\n+                    public boolean process(String opt, List<String> args) {\n+                        additionalScripts.add(args.get(0));\n+                        return true;\n+                    }\n+                },\n+\n@@ -503,1 +516,8 @@\n-\n+        \/\/ check if additional scripts exists\n+        for (String script : additionalScripts) {\n+            DocFile sfile = DocFile.createFileForInput(config, script);\n+            if (!sfile.exists()) {\n+                messages.error(\"doclet.File_not_found\", script);\n+                return false;\n+            }\n+        }\n@@ -517,0 +537,7 @@\n+    \/**\n+     * Argument for command-line option {@code --add-script}.\n+     *\/\n+    List<String> additionalScripts() {\n+        return additionalScripts;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlOptions.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -392,13 +392,3 @@\n-            if (element.getKind() == ElementKind.ANNOTATION_TYPE) {\n-                \/\/ Handle annotation interfaces separately as required and optional elements\n-                \/\/ share a combined details section.\n-                addTypeDetailLink(FIELDS, !vmt.getVisibleMembers(FIELDS).isEmpty(), listContents);\n-                boolean hasAnnotationElements =\n-                        !vmt.getVisibleMembers(ANNOTATION_TYPE_MEMBER_OPTIONAL).isEmpty()\n-                                || !vmt.getVisibleMembers(ANNOTATION_TYPE_MEMBER_REQUIRED).isEmpty();\n-                addTypeDetailLink(ANNOTATION_TYPE_MEMBER_REQUIRED, hasAnnotationElements, listContents);\n-            } else {\n-                Set<VisibleMemberTable.Kind> detailSet = VisibleMemberTable.Kind.forDetailsOf(element.getKind());\n-                for (VisibleMemberTable.Kind kind : detailSet) {\n-                    addTypeDetailLink(kind, !vmt.getVisibleMembers(kind).isEmpty(), listContents);\n-                }\n+            Set<VisibleMemberTable.Kind> detailSet = VisibleMemberTable.Kind.forDetailsOf(element.getKind());\n+            for (VisibleMemberTable.Kind kind : detailSet) {\n+                addTypeDetailLink(kind, !vmt.getVisibleMembers(kind).isEmpty(), listContents);\n@@ -435,4 +425,2 @@\n-            case ANNOTATION_TYPE_MEMBER_REQUIRED,\n-                 ANNOTATION_TYPE_MEMBER_OPTIONAL ->\n-                    links.createLink(HtmlIds.ANNOTATION_TYPE_ELEMENT_DETAIL,\n-                            contents.navAnnotationTypeMember, link);\n+            case ANNOTATION_TYPE_MEMBER -> links.createLink(HtmlIds.ANNOTATION_TYPE_ELEMENT_DETAIL,\n+                    contents.navAnnotationTypeMember, link);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Navigation.java","additions":5,"deletions":17,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -108,7 +108,5 @@\n-                if (!pkg.isUnnamed()) {\n-                    if (!(options.noDeprecated() && utils.isDeprecated(pkg))) {\n-                        Content packageLinkContent = getPackageLink(pkg, getLocalizedPackageName(pkg));\n-                        Content summaryContent = new ContentBuilder();\n-                        addSummaryComment(pkg, summaryContent);\n-                        table.addRow(pkg, packageLinkContent, summaryContent);\n-                    }\n+                if (!(options.noDeprecated() && utils.isDeprecated(pkg))) {\n+                    Content packageLinkContent = getPackageLink(pkg, getLocalizedPackageName(pkg));\n+                    Content summaryContent = new ContentBuilder();\n+                    addSummaryComment(pkg, summaryContent);\n+                    table.addRow(pkg, packageLinkContent, summaryContent);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PackageIndexWriter.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -257,1 +257,2 @@\n-            default -> new AnnotationTypeOptionalMemberWriterImpl(this, null);\n+            default ->\n+                throw new UnsupportedOperationException(\"Unsupported element kind: \" + e.getKind());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SummaryListWriter.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -450,1 +450,4 @@\n-                HtmlTree.A(\"#\", new HtmlTree(TagName.IMG)\n+                new HtmlTree(TagName.BUTTON)\n+                        .add(HtmlTree.SPAN(Text.of(copyText))\n+                                .put(HtmlAttr.DATA_COPIED, copiedText))\n+                        .add(new HtmlTree(TagName.IMG)\n@@ -454,3 +457,1 @@\n-                        .put(HtmlAttr.ONCLICK, \"copySnippet(this)\")\n-                        .put(HtmlAttr.ARIA_LABEL, copyText)\n-                        .put(HtmlAttr.DATA_COPIED, copiedText));\n+                        .put(HtmlAttr.ONCLICK, \"copySnippet(this)\"));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeOptionalMemberWriter;\n-import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeRequiredMemberWriter;\n@@ -83,1 +81,1 @@\n-    public AnnotationTypeOptionalMemberWriter getAnnotationTypeOptionalMemberWriter(\n+    public AnnotationTypeMemberWriterImpl getAnnotationTypeMemberWriter(\n@@ -86,2 +84,2 @@\n-        return new AnnotationTypeOptionalMemberWriterImpl(\n-                (ClassWriterImpl) classWriter, te);\n+        return new AnnotationTypeMemberWriterImpl(\n+                (ClassWriterImpl) classWriter, te, AnnotationTypeMemberWriterImpl.Kind.ANY);\n@@ -91,1 +89,1 @@\n-    public AnnotationTypeRequiredMemberWriter getAnnotationTypeRequiredMemberWriter(\n+    public AnnotationTypeMemberWriterImpl getAnnotationTypeOptionalMemberWriter(\n@@ -94,2 +92,10 @@\n-        return new AnnotationTypeRequiredMemberWriterImpl(\n-            (ClassWriterImpl) classWriter, te);\n+        return new AnnotationTypeMemberWriterImpl(\n+                (ClassWriterImpl) classWriter, te, AnnotationTypeMemberWriterImpl.Kind.OPTIONAL);\n+    }\n+\n+    @Override\n+    public AnnotationTypeMemberWriterImpl getAnnotationTypeRequiredMemberWriter(\n+            ClassWriter classWriter) {\n+        TypeElement te = classWriter.getTypeElement();\n+        return new AnnotationTypeMemberWriterImpl(\n+            (ClassWriterImpl) classWriter, te, AnnotationTypeMemberWriterImpl.Kind.REQUIRED);\n@@ -135,2 +141,1 @@\n-                return (AnnotationTypeOptionalMemberWriterImpl)\n-                        getAnnotationTypeOptionalMemberWriter(classWriter);\n+                return getAnnotationTypeOptionalMemberWriter(classWriter);\n@@ -138,2 +143,1 @@\n-                return (AnnotationTypeRequiredMemberWriterImpl)\n-                        getAnnotationTypeRequiredMemberWriter(classWriter);\n+                return getAnnotationTypeRequiredMemberWriter(classWriter);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/WriterFactoryImpl.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,2 @@\n+    \/\/ Scripts added via --add-script option\n+    private List<DocPath> additionalScripts = Collections.emptyList();\n@@ -171,0 +173,13 @@\n+    \/**\n+     * Sets the list of additional script files to be added to the HEAD element.\n+     * The path for the script files must be relative to the root of the generated\n+     * documentation hierarchy.\n+     *\n+     * @param scripts the list of additional script files\n+     * @return this object\n+     *\/\n+    public Head setAdditionalScripts(List<DocPath> scripts) {\n+        this.additionalScripts = scripts;\n+        return this;\n+    }\n+\n@@ -318,1 +333,1 @@\n-            addStylesheet(tree, DocPaths.JQUERY_FILES.resolve(DocPaths.JQUERY_UI_CSS));\n+            addStylesheet(tree, DocPaths.SCRIPT_DIR.resolve(DocPaths.JQUERY_UI_CSS));\n@@ -340,2 +355,5 @@\n-            addJQueryFile(tree, DocPaths.JQUERY_JS);\n-            addJQueryFile(tree, DocPaths.JQUERY_UI_JS);\n+            addScriptElement(tree, DocPaths.JQUERY_JS);\n+            addScriptElement(tree, DocPaths.JQUERY_UI_JS);\n+        }\n+        for (DocPath path : additionalScripts) {\n+            addScriptElement(tree, path);\n@@ -348,3 +366,3 @@\n-    private void addJQueryFile(HtmlTree tree, DocPath filePath) {\n-        DocPath jqueryFile = pathToRoot.resolve(DocPaths.JQUERY_FILES.resolve(filePath));\n-        tree.add(HtmlTree.SCRIPT(jqueryFile.getPath()));\n+    private void addScriptElement(HtmlTree tree, DocPath filePath) {\n+        DocPath scriptFile = pathToRoot.resolve(DocPaths.SCRIPT_DIR).resolve(filePath);\n+        tree.add(HtmlTree.SCRIPT(scriptFile.getPath()));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Head.java","additions":25,"deletions":7,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -384,0 +384,4 @@\n+doclet.usage.add-script.parameters=\\\n+    <file>\n+doclet.usage.add-script.description=\\\n+    Add a script file to the generated documentation\n@@ -387,1 +391,1 @@\n-    Additional stylesheet file for the generated documentation\n+    Add a stylesheet file to the generated documentation\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit;\n+\n+import javax.lang.model.element.Element;\n+\n+\/**\n+ * The interface for writing annotation type required member output.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+\n+public interface AnnotationTypeMemberWriter extends MemberWriter {\n+\n+    \/**\n+     * Adds the annotation type member tree header.\n+     *\n+     * @return content tree for the member tree header\n+     *\/\n+    Content getMemberTreeHeader();\n+\n+    \/**\n+     * Adds the annotation type details marker.\n+     *\n+     * @param memberDetails the content tree representing details marker\n+     *\/\n+    void addAnnotationDetailsMarker(Content memberDetails);\n+\n+    \/**\n+     * Adds the annotation type details tree header.\n+     *\n+     * @return content tree for the annotation details header\n+     *\/\n+    Content getAnnotationDetailsTreeHeader();\n+\n+    \/**\n+     * Gets the annotation type documentation tree header.\n+     *\n+     * @param member the annotation type being documented\n+     * @return content tree for the annotation type documentation header\n+     *\/\n+    Content getAnnotationDocTreeHeader(Element member);\n+\n+    \/**\n+     * Gets the annotation type details tree.\n+     *\n+     * @param annotationDetailsTreeHeader the content tree representing annotation type details header\n+     * @param annotationDetailsTree the content tree representing annotation type details\n+     * @return content tree for the annotation type details\n+     *\/\n+    Content getAnnotationDetails(Content annotationDetailsTreeHeader, Content annotationDetailsTree);\n+\n+    \/**\n+     * Gets the signature for the given member.\n+     *\n+     * @param member the member being documented\n+     * @return content tree for the annotation type signature\n+     *\/\n+    Content getSignature(Element member);\n+\n+    \/**\n+     * Adds the deprecated output for the given member.\n+     *\n+     * @param member the member being documented\n+     * @param annotationDocTree content tree to which the deprecated information will be added\n+     *\/\n+    void addDeprecated(Element member, Content annotationDocTree);\n+\n+    \/**\n+     * Adds the preview output for the given member.\n+     *\n+     * @param member the member being documented\n+     * @param contentTree content tree to which the preview information will be added\n+     *\/\n+    void addPreview(Element member, Content contentTree);\n+\n+    \/**\n+     * Adds the comments for the given member.\n+     *\n+     * @param member the member being documented\n+     * @param annotationDocTree the content tree to which the comments will be added\n+     *\/\n+    void addComments(Element member, Content annotationDocTree);\n+\n+    \/**\n+     * Adds the tags for the given member.\n+     *\n+     * @param member the member being documented\n+     * @param annotationDocTree the content tree to which the tags will be added\n+     *\/\n+    void addTags(Element member, Content annotationDocTree);\n+\n+    \/**\n+     * Adds the default value documentation if the member has one.\n+     *\n+     * @param member the member being documented\n+     * @param annotationDocTree content tree to which the default value will be added\n+     *\/\n+    void addDefaultValueInfo(Element member, Content annotationDocTree);\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/AnnotationTypeMemberWriter.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import javax.lang.model.element.Element;\n-\n-\/**\n- * The interface for writing annotation type optional member output.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-\n-public interface AnnotationTypeOptionalMemberWriter extends\n-        AnnotationTypeRequiredMemberWriter {\n-\n-    \/**\n-     * Add the the default value documentation.\n-     *\n-     * @param member the member being documented\n-     * @param annotationDocTree content tree to which the default value will be added\n-     *\/\n-    void addDefaultValueInfo(Element member, Content annotationDocTree);\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/AnnotationTypeOptionalMemberWriter.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,118 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import javax.lang.model.element.Element;\n-\n-\/**\n- * The interface for writing annotation type required member output.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-\n-public interface AnnotationTypeRequiredMemberWriter extends MemberWriter {\n-\n-    \/**\n-     * Add the annotation type member tree header.\n-     *\n-     * @return content tree for the member tree header\n-     *\/\n-    Content getMemberTreeHeader();\n-\n-    \/**\n-     * Add the annotation type details marker.\n-     *\n-     * @param memberDetails the content tree representing details marker\n-     *\/\n-    void addAnnotationDetailsMarker(Content memberDetails);\n-\n-    \/**\n-     * Add the annotation type details tree header.\n-     *\n-     * @return content tree for the annotation details header\n-     *\/\n-    Content getAnnotationDetailsTreeHeader();\n-\n-    \/**\n-     * Get the annotation type documentation tree header.\n-     *\n-     * @param member the annotation type being documented\n-     * @return content tree for the annotation type documentation header\n-     *\/\n-    Content getAnnotationDocTreeHeader(Element member);\n-\n-    \/**\n-     * Get the annotation type details tree.\n-     *\n-     * @param annotationDetailsTreeHeader the content tree representing annotation type details header\n-     * @param annotationDetailsTree the content tree representing annotation type details\n-     * @return content tree for the annotation type details\n-     *\/\n-    Content getAnnotationDetails(Content annotationDetailsTreeHeader, Content annotationDetailsTree);\n-\n-    \/**\n-     * Get the signature for the given member.\n-     *\n-     * @param member the member being documented\n-     * @return content tree for the annotation type signature\n-     *\/\n-    Content getSignature(Element member);\n-\n-    \/**\n-     * Add the deprecated output for the given member.\n-     *\n-     * @param member the member being documented\n-     * @param annotationDocTree content tree to which the deprecated information will be added\n-     *\/\n-    void addDeprecated(Element member, Content annotationDocTree);\n-\n-    \/**\n-     * Add the preview output for the given member.\n-     *\n-     * @param member the member being documented\n-     * @param annotationDocTree content tree to which the preview information will be added\n-     *\/\n-    void addPreview(Element member, Content contentTree);\n-\n-    \/**\n-     * Add the comments for the given member.\n-     *\n-     * @param member the member being documented\n-     * @param annotationDocTree the content tree to which the comments will be added\n-     *\/\n-    void addComments(Element member, Content annotationDocTree);\n-\n-    \/**\n-     * Add the tags for the given member.\n-     *\n-     * @param member the member being documented\n-     * @param annotationDocTree the content tree to which the tags will be added\n-     *\/\n-    void addTags(Element member, Content annotationDocTree);\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/AnnotationTypeRequiredMemberWriter.java","additions":0,"deletions":118,"binary":false,"changes":118,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,0 +92,10 @@\n+    \/**\n+     * Return the annotation type member writer for a given annotation\n+     * type, or null if this writer is not supported by the doclet.\n+     *\n+     * @param classWriter the writer for the annotation type being documented\n+     * @return the member writer\n+     *\/\n+    AnnotationTypeMemberWriter getAnnotationTypeMemberWriter(\n+            ClassWriter classWriter);\n+\n@@ -99,1 +109,1 @@\n-    AnnotationTypeOptionalMemberWriter getAnnotationTypeOptionalMemberWriter(\n+    AnnotationTypeMemberWriter getAnnotationTypeOptionalMemberWriter(\n@@ -109,1 +119,1 @@\n-    AnnotationTypeRequiredMemberWriter getAnnotationTypeRequiredMemberWriter(\n+    AnnotationTypeMemberWriter getAnnotationTypeRequiredMemberWriter(\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/WriterFactory.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-    protected List<? extends Element> getVisibleMembers(Kind kind) {\n+    protected List<Element> getVisibleMembers(Kind kind) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/AbstractMemberBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.builders;\n+\n+import java.util.*;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.TypeElement;\n+\n+import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeMemberWriter;\n+import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.DocletException;\n+\n+import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;\n+\n+\/**\n+ * Builds documentation for required annotation type members.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class AnnotationTypeMemberBuilder extends AbstractMemberBuilder {\n+\n+    \/**\n+     * The writer to output the member documentation.\n+     *\/\n+    protected AnnotationTypeMemberWriter writer;\n+\n+    \/**\n+     * The list of members being documented.\n+     *\/\n+    protected List<Element> members;\n+\n+    \/**\n+     * The index of the current member that is being documented at this point\n+     * in time.\n+     *\/\n+    protected Element currentMember;\n+\n+    \/**\n+     * Construct a new AnnotationTypeRequiredMemberBuilder.\n+     *\n+     * @param context  the build context.\n+     * @param typeElement the class whose members are being documented.\n+     * @param writer the doclet specific writer.\n+     *\/\n+    protected AnnotationTypeMemberBuilder(Context context,\n+                                          TypeElement typeElement,\n+                                          AnnotationTypeMemberWriter writer) {\n+        super(context, typeElement);\n+        this.writer = Objects.requireNonNull(writer);\n+        \/\/ In contrast to the annotation interface member summaries the details generated\n+        \/\/ by this builder share a single list for both required and optional members.\n+        this.members = getVisibleMembers(ANNOTATION_TYPE_MEMBER);\n+    }\n+\n+\n+    \/**\n+     * Construct a new AnnotationTypeMemberBuilder.\n+     *\n+     * @param context  the build context.\n+     * @param typeElement the class whose members are being documented.\n+     * @param writer the doclet specific writer.\n+     * @return an instance of this object\n+     *\/\n+    public static AnnotationTypeMemberBuilder getInstance(\n+            Context context, TypeElement typeElement,\n+            AnnotationTypeMemberWriter writer) {\n+        return new AnnotationTypeMemberBuilder(context, typeElement,\n+                writer);\n+    }\n+\n+    \/**\n+     * Returns whether or not there are members to document.\n+     * @return whether or not there are members to document\n+     *\/\n+    @Override\n+    public boolean hasMembersToDocument() {\n+        return !members.isEmpty();\n+    }\n+\n+    @Override\n+    public void build(Content contentTree) throws DocletException {\n+        buildAnnotationTypeMember(contentTree);\n+    }\n+\n+    \/**\n+     * Build the member documentation.\n+     *\n+     * @param detailsList the content tree to which the documentation will be added\n+     * @throws DocletException if an error occurs\n+     *\/\n+    protected void buildAnnotationTypeMember(Content detailsList)\n+            throws DocletException {\n+        if (hasMembersToDocument()) {\n+            writer.addAnnotationDetailsMarker(detailsList);\n+            Content annotationDetailsTreeHeader = writer.getAnnotationDetailsTreeHeader();\n+            Content memberList = writer.getMemberList();\n+\n+            for (Element member : members) {\n+                currentMember = member;\n+                Content annotationDocTree = writer.getAnnotationDocTreeHeader(currentMember);\n+\n+                buildAnnotationTypeMemberChildren(annotationDocTree);\n+\n+                memberList.add(writer.getMemberListItem(annotationDocTree));\n+            }\n+            Content annotationDetails = writer.getAnnotationDetails(annotationDetailsTreeHeader, memberList);\n+            detailsList.add(annotationDetails);\n+        }\n+    }\n+\n+    protected void buildAnnotationTypeMemberChildren(Content annotationDocTree) {\n+        buildSignature(annotationDocTree);\n+        buildDeprecationInfo(annotationDocTree);\n+        buildPreviewInfo(annotationDocTree);\n+        buildMemberComments(annotationDocTree);\n+        buildTagInfo(annotationDocTree);\n+        buildDefaultValueInfo(annotationDocTree);\n+    }\n+\n+    \/**\n+     * Build the signature.\n+     *\n+     * @param annotationDocTree the content tree to which the documentation will be added\n+     *\/\n+    protected void buildSignature(Content annotationDocTree) {\n+        annotationDocTree.add(writer.getSignature(currentMember));\n+    }\n+\n+    \/**\n+     * Build the deprecation information.\n+     *\n+     * @param annotationDocTree the content tree to which the documentation will be added\n+     *\/\n+    protected void buildDeprecationInfo(Content annotationDocTree) {\n+        writer.addDeprecated(currentMember, annotationDocTree);\n+    }\n+\n+    \/**\n+     * Build the preview information.\n+     *\n+     * @param annotationDocTree the content tree to which the documentation will be added\n+     *\/\n+    protected void buildPreviewInfo(Content annotationDocTree) {\n+        writer.addPreview(currentMember, annotationDocTree);\n+    }\n+\n+    \/**\n+     * Build the comments for the member.  Do nothing if\n+     * {@link BaseOptions#noComment()} is set to true.\n+     *\n+     * @param annotationDocTree the content tree to which the documentation will be added\n+     *\/\n+    protected void buildMemberComments(Content annotationDocTree) {\n+        if (!options.noComment()) {\n+            writer.addComments(currentMember, annotationDocTree);\n+        }\n+    }\n+\n+    \/**\n+     * Build the tag information.\n+     *\n+     * @param annotationDocTree the content tree to which the documentation will be added\n+     *\/\n+    protected void buildTagInfo(Content annotationDocTree) {\n+        writer.addTags(currentMember, annotationDocTree);\n+    }\n+\n+    \/**\n+     * Build the default value for this optional member.\n+     *\n+     * @param annotationDocTree the content tree to which the documentation will be added\n+     *\/\n+    protected void buildDefaultValueInfo(Content annotationDocTree) {\n+        writer.addDefaultValueInfo(currentMember, annotationDocTree);\n+    }\n+\n+    \/**\n+     * Return the annotation type required member writer for this builder.\n+     *\n+     * @return the annotation type required member constant writer for this\n+     * builder.\n+     *\/\n+    public AnnotationTypeMemberWriter getWriter() {\n+        return writer;\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/AnnotationTypeMemberBuilder.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -1,112 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeOptionalMemberWriter;\n-import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeRequiredMemberWriter;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-\n-import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;\n-\n-\/**\n- * Builds documentation for optional annotation type members.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class AnnotationTypeOptionalMemberBuilder extends AnnotationTypeRequiredMemberBuilder {\n-\n-    \/**\n-     * Construct a new AnnotationTypeMemberBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     *\/\n-    private AnnotationTypeOptionalMemberBuilder(Context context,\n-            TypeElement typeElement,\n-            AnnotationTypeOptionalMemberWriter writer) {\n-        super(context, typeElement, writer, ANNOTATION_TYPE_MEMBER_OPTIONAL);\n-    }\n-\n-\n-    \/**\n-     * Construct a new AnnotationTypeMemberBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     * @return the new AnnotationTypeMemberBuilder\n-     *\/\n-    public static AnnotationTypeOptionalMemberBuilder getInstance(\n-            Context context, TypeElement typeElement,\n-            AnnotationTypeOptionalMemberWriter writer) {\n-        return new AnnotationTypeOptionalMemberBuilder(context,\n-                typeElement, writer);\n-    }\n-\n-    @Override\n-    public void build(Content contentTree) throws DocletException {\n-        buildAnnotationTypeOptionalMember(contentTree);\n-    }\n-\n-    \/**\n-     * Build the annotation type optional member documentation.\n-     *\n-     * @param memberDetailsTree the content tree to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildAnnotationTypeOptionalMember(Content memberDetailsTree)\n-                throws DocletException {\n-        buildAnnotationTypeMember(memberDetailsTree);\n-    }\n-\n-    @Override\n-    protected void buildAnnotationTypeMemberChildren(Content annotationDocTree) {\n-        super.buildAnnotationTypeMemberChildren(annotationDocTree);\n-        buildDefaultValueInfo(annotationDocTree);\n-    }\n-\n-    \/**\n-     * Build the default value for this optional member.\n-     *\n-     * @param annotationDocTree the content tree to which the documentation will be added\n-     *\/\n-    protected void buildDefaultValueInfo(Content annotationDocTree) {\n-        ((AnnotationTypeOptionalMemberWriter) writer).addDefaultValueInfo(currentMember,\n-                annotationDocTree);\n-    }\n-\n-    @Override\n-    public AnnotationTypeRequiredMemberWriter getWriter() {\n-        return writer;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/AnnotationTypeOptionalMemberBuilder.java","additions":0,"deletions":112,"binary":false,"changes":112,"status":"deleted"},{"patch":"@@ -1,218 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.*;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.TypeElement;\n-import jdk.javadoc.internal.doclets.formats.html.AbstractMemberWriter;\n-\n-import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeRequiredMemberWriter;\n-import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n-\n-import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;\n-\n-\/**\n- * Builds documentation for required annotation type members.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class AnnotationTypeRequiredMemberBuilder extends AbstractMemberBuilder {\n-\n-\n-    \/**\n-     * The writer to output the member documentation.\n-     *\/\n-    protected AnnotationTypeRequiredMemberWriter writer;\n-\n-    \/**\n-     * The list of members being documented.\n-     *\/\n-    protected List<? extends Element> members;\n-\n-    \/**\n-     * The index of the current member that is being documented at this point\n-     * in time.\n-     *\/\n-    protected Element currentMember;\n-\n-    \/**\n-     * Construct a new AnnotationTypeRequiredMemberBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     * @param memberType the kind of member this builder processes.\n-     *\/\n-    protected AnnotationTypeRequiredMemberBuilder(Context context,\n-            TypeElement typeElement,\n-            AnnotationTypeRequiredMemberWriter writer,\n-            VisibleMemberTable.Kind memberType) {\n-        super(context, typeElement);\n-        this.writer = Objects.requireNonNull(writer);\n-        this.members = getVisibleMembers(memberType);\n-    }\n-\n-\n-    \/**\n-     * Construct a new AnnotationTypeMemberBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     * @return an instance of this object\n-     *\/\n-    public static AnnotationTypeRequiredMemberBuilder getInstance(\n-            Context context, TypeElement typeElement,\n-            AnnotationTypeRequiredMemberWriter writer) {\n-        return new AnnotationTypeRequiredMemberBuilder(context, typeElement,\n-                writer, ANNOTATION_TYPE_MEMBER_REQUIRED);\n-    }\n-\n-    \/**\n-     * Returns whether or not there are members to document.\n-     * @return whether or not there are members to document\n-     *\/\n-    @Override\n-    public boolean hasMembersToDocument() {\n-        return !members.isEmpty();\n-    }\n-\n-    @Override\n-    public void build(Content contentTree) throws DocletException {\n-        buildAnnotationTypeRequiredMember(contentTree);\n-    }\n-\n-    \/**\n-     * Build the annotation type required member documentation.\n-     *\n-     * @param memberDetailsTree the content tree to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildAnnotationTypeRequiredMember(Content memberDetailsTree)\n-            throws DocletException {\n-        buildAnnotationTypeMember(memberDetailsTree);\n-    }\n-\n-    \/**\n-     * Build the member documentation.\n-     *\n-     * @param detailsList the content tree to which the documentation will be added\n-     * @throws DocletException if an error occurs\n-     *\/\n-    protected void buildAnnotationTypeMember(Content detailsList)\n-            throws DocletException {\n-        if (hasMembersToDocument()) {\n-            writer.addAnnotationDetailsMarker(detailsList);\n-            Content annotationDetailsTreeHeader = writer.getAnnotationDetailsTreeHeader();\n-            Content memberList = writer.getMemberList();\n-\n-            for (Element member : members) {\n-                currentMember = member;\n-                Content annotationDocTree = writer.getAnnotationDocTreeHeader(currentMember);\n-\n-                buildAnnotationTypeMemberChildren(annotationDocTree);\n-\n-                memberList.add(writer.getMemberListItem(annotationDocTree));\n-            }\n-            Content annotationDetails = writer.getAnnotationDetails(annotationDetailsTreeHeader, memberList);\n-            detailsList.add(annotationDetails);\n-        }\n-    }\n-\n-    protected void buildAnnotationTypeMemberChildren(Content annotationDocTree) {\n-        buildSignature(annotationDocTree);\n-        buildDeprecationInfo(annotationDocTree);\n-        buildPreviewInfo(annotationDocTree);\n-        buildMemberComments(annotationDocTree);\n-        buildTagInfo(annotationDocTree);\n-    }\n-\n-    \/**\n-     * Build the signature.\n-     *\n-     * @param annotationDocTree the content tree to which the documentation will be added\n-     *\/\n-    protected void buildSignature(Content annotationDocTree) {\n-        annotationDocTree.add(writer.getSignature(currentMember));\n-    }\n-\n-    \/**\n-     * Build the deprecation information.\n-     *\n-     * @param annotationDocTree the content tree to which the documentation will be added\n-     *\/\n-    protected void buildDeprecationInfo(Content annotationDocTree) {\n-        writer.addDeprecated(currentMember, annotationDocTree);\n-    }\n-\n-    \/**\n-     * Build the preview information.\n-     *\n-     * @param annotationDocTree the content tree to which the documentation will be added\n-     *\/\n-    protected void buildPreviewInfo(Content annotationDocTree) {\n-        writer.addPreview(currentMember, annotationDocTree);\n-    }\n-\n-    \/**\n-     * Build the comments for the member.  Do nothing if\n-     * {@link BaseOptions#noComment()} is set to true.\n-     *\n-     * @param annotationDocTree the content tree to which the documentation will be added\n-     *\/\n-    protected void buildMemberComments(Content annotationDocTree) {\n-        if (!options.noComment()) {\n-            writer.addComments(currentMember, annotationDocTree);\n-        }\n-    }\n-\n-    \/**\n-     * Build the tag information.\n-     *\n-     * @param annotationDocTree the content tree to which the documentation will be added\n-     *\/\n-    protected void buildTagInfo(Content annotationDocTree) {\n-        writer.addTags(currentMember, annotationDocTree);\n-    }\n-\n-    \/**\n-     * Return the annotation type required member writer for this builder.\n-     *\n-     * @return the annotation type required member constant writer for this\n-     * builder.\n-     *\/\n-    public AnnotationTypeRequiredMemberWriter getWriter() {\n-        return writer;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/AnnotationTypeRequiredMemberBuilder.java","additions":0,"deletions":218,"binary":false,"changes":218,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,3 +41,0 @@\n-\n-\n-\n@@ -136,16 +133,1 @@\n-    public AbstractMemberBuilder getAnnotationTypeOptionalMemberBuilder(\n-            ClassWriter classWriter) {\n-        return AnnotationTypeOptionalMemberBuilder.getInstance(context,\n-            classWriter.getTypeElement(),\n-            writerFactory.getAnnotationTypeOptionalMemberWriter(classWriter));\n-    }\n-\n-    \/**\n-     * Return an instance of the annotation type member builder for the given\n-     * class.\n-     *\n-     * @param classWriter the writer for the enclosing annotation type\n-     * @return an instance of the annotation type member builder for the given\n-     *         annotation type.\n-     *\/\n-    public AbstractMemberBuilder getAnnotationTypeRequiredMemberBuilder(\n+    public AbstractMemberBuilder getAnnotationTypeMemberBuilder(\n@@ -153,1 +135,1 @@\n-        return AnnotationTypeRequiredMemberBuilder.getInstance(context,\n+        return AnnotationTypeMemberBuilder.getInstance(context,\n@@ -155,1 +137,1 @@\n-            writerFactory.getAnnotationTypeRequiredMemberWriter(classWriter));\n+            writerFactory.getAnnotationTypeMemberWriter(classWriter));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/BuilderFactory.java","additions":4,"deletions":22,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,7 +89,2 @@\n-            case ENUM:\n-                setEnumDocumentation(typeElement);\n-                break;\n-\n-            case RECORD:\n-                setRecordDocumentation(typeElement);\n-                break;\n+            case ENUM   -> setEnumDocumentation(typeElement);\n+            case RECORD -> setRecordDocumentation(typeElement);\n@@ -122,21 +117,9 @@\n-        String key;\n-         switch (typeElement.getKind()) {\n-             case INTERFACE:\n-                 key = \"doclet.Interface\";\n-                 break;\n-             case ENUM:\n-                 key = \"doclet.Enum\";\n-                 break;\n-             case RECORD:\n-                 key = \"doclet.RecordClass\";\n-                 break;\n-             case ANNOTATION_TYPE:\n-                 key = \"doclet.AnnotationType\";\n-                 break;\n-             case CLASS:\n-                 key = \"doclet.Class\";\n-                 break;\n-             default:\n-                 throw new IllegalStateException(typeElement.getKind() + \" \" + typeElement);\n-         }\n-        Content contentTree = writer.getHeader(resources.getText(key) + \" \"\n+        String key = switch (typeElement.getKind()) {\n+            case INTERFACE       -> \"doclet.Interface\";\n+            case ENUM            -> \"doclet.Enum\";\n+            case RECORD          -> \"doclet.RecordClass\";\n+            case ANNOTATION_TYPE -> \"doclet.AnnotationType\";\n+            case CLASS           -> \"doclet.Class\";\n+            default -> throw new IllegalStateException(typeElement.getKind() + \" \" + typeElement);\n+        };\n+         Content contentTree = writer.getHeader(resources.getText(key) + \" \"\n@@ -344,2 +327,1 @@\n-        buildAnnotationTypeRequiredMemberDetails(detailsList);\n-        buildAnnotationTypeOptionalMemberDetails(detailsList);\n+        buildAnnotationTypeMemberDetails(detailsList);\n@@ -407,12 +389,1 @@\n-    protected void buildAnnotationTypeOptionalMemberDetails(Content memberDetailsTree)\n-            throws DocletException {\n-        builderFactory.getAnnotationTypeOptionalMemberBuilder(writer).build(memberDetailsTree);\n-    }\n-\n-    \/**\n-     * Build the annotation type required member documentation.\n-     *\n-     * @param memberDetailsTree the content tree to which the documentation will be added\n-     * @throws DocletException if there is a problem building the documentation\n-     *\/\n-    protected void buildAnnotationTypeRequiredMemberDetails(Content memberDetailsTree)\n+    protected void buildAnnotationTypeMemberDetails(Content memberDetailsTree)\n@@ -420,1 +391,1 @@\n-        builderFactory.getAnnotationTypeRequiredMemberBuilder(writer).build(memberDetailsTree);\n+        builderFactory.getAnnotationTypeMemberBuilder(writer).build(memberDetailsTree);\n@@ -470,1 +441,4 @@\n-        for (VariableElement ve : utils.getFields(elem)) {\n+        var fields = utils.isSerializable(elem)\n+                ? utils.getFieldsUnfiltered(elem)\n+                : utils.getFields(elem);\n+        for (VariableElement ve : fields) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/ClassBuilder.java","additions":19,"deletions":45,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-function copySnippet(link) {\n+function copySnippet(button) {\n@@ -113,1 +113,1 @@\n-    textarea.value = link.nextElementSibling.innerText;\n+    textarea.value = button.nextElementSibling.innerText;\n@@ -117,5 +117,10 @@\n-    link.classList.add(\"copied\");\n-    var parent = link.parentElement;\n-    parent.onmouseleave = parent.ontouchend = function() {\n-        link.classList.remove(\"copied\");\n-    };\n+    var span = button.firstElementChild;\n+    var copied = span.getAttribute(\"data-copied\");\n+    if (span.innerHTML !== copied) {\n+        var initialLabel = span.innerHTML;\n+        span.innerHTML = copied;\n+        var parent = button.parentElement;\n+        parent.onmouseleave = parent.ontouchend = function() {\n+            span.innerHTML = initialLabel;\n+        };\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/script.js","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -589,1 +589,1 @@\n-ul.ui-autocomplete  li {\n+ul.ui-autocomplete li {\n@@ -592,1 +592,1 @@\n-    width:100%;\n+    min-width:100%;\n@@ -939,1 +939,1 @@\n-a.snippet-copy {\n+button.snippet-copy {\n@@ -941,2 +941,9 @@\n-    top: 8px;\n-    right: 8px;\n+    top: 6px;\n+    right: 6px;\n+    height: 1.7em;\n+    opacity: 50%;\n+    transition: opacity 0.2s;\n+    padding: 2px;\n+    border: none;\n+    cursor: pointer;\n+    background: none;\n@@ -944,1 +951,1 @@\n-a.snippet-copy img {\n+button.snippet-copy img {\n@@ -948,2 +955,1 @@\n-    opacity: 50%;\n-    transition: opacity 0.2s;\n+    background: none;\n@@ -951,1 +957,1 @@\n-div.snippet-container:hover a.snippet-copy img {\n+div.snippet-container:hover button.snippet-copy {\n@@ -954,5 +960,1 @@\n-div.snippet-container a.snippet-copy:hover img {\n-    opacity: 100%;\n-}\n-a.snippet-copy:active img {\n-    background: #d3d3d3;\n+div.snippet-container button.snippet-copy:hover {\n@@ -961,1 +963,1 @@\n-a.snippet-copy::before {\n+button.snippet-copy span {\n@@ -968,3 +970,1 @@\n-    position: absolute;\n-    opacity: 80%;\n-    transition: opacity 0.2s;\n+    position: relative;\n@@ -972,2 +972,1 @@\n-    top: -0.01em;\n-    right: 1.5em;\n+    top: -0.5em;\n@@ -976,2 +975,2 @@\n-div.snippet-container:hover a.snippet-copy::before {\n-    display: inherit;\n+div.snippet-container:hover button.snippet-copy span {\n+    display: inline;\n@@ -979,1 +978,2 @@\n-div.snippet-container a.snippet-copy:hover::before {\n+button.snippet-copy:active {\n+    background: #d3d3d3;\n@@ -982,6 +982,0 @@\n-a.snippet-copy.copied::before {\n-    content: attr(data-copied);\n-}\n-a.snippet-copy:active::before {\n-    background-color: #dadada;\n-}\n@@ -992,3 +986,3 @@\n-    a.snippet-copy {\n-        top: 6px;\n-        right: 6px;\n+    button.snippet-copy {\n+        top: 4px;\n+        right: 4px;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/stylesheet.css","additions":26,"deletions":32,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -106,3 +106,0 @@\n-    \/** The name of the directory for the jQuery files. *\/\n-    public static final DocPath JQUERY_FILES = DocPath.create(\"script-dir\");\n-\n@@ -127,0 +124,3 @@\n+    \/** The name of the file for new elements. *\/\n+    public static final DocPath NEW_LIST = DocPath.create(\"new-list.html\");\n+\n@@ -151,2 +151,2 @@\n-    \/** The name of the file for new elements. *\/\n-    public static final DocPath NEW_LIST = DocPath.create(\"new-list.html\");\n+    \/** The name of the directory for the script files. *\/\n+    public static final DocPath SCRIPT_DIR = DocPath.create(\"script-dir\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocPaths.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-        ANNOTATION_TYPE_MEMBER_OPTIONAL,\n+        ANNOTATION_TYPE_MEMBER,\n@@ -108,0 +108,1 @@\n+        ANNOTATION_TYPE_MEMBER_OPTIONAL,\n@@ -115,1 +116,1 @@\n-                FIELDS, ANNOTATION_TYPE_MEMBER_OPTIONAL, ANNOTATION_TYPE_MEMBER_REQUIRED);\n+                FIELDS, ANNOTATION_TYPE_MEMBER_REQUIRED, ANNOTATION_TYPE_MEMBER_OPTIONAL);\n@@ -120,0 +121,2 @@\n+        private static final EnumSet<Kind> annotationDetailSet = EnumSet.of(\n+                FIELDS, ANNOTATION_TYPE_MEMBER);\n@@ -138,3 +141,5 @@\n-            return kind == ElementKind.ENUM\n-                    ? enumDetailSet\n-                    : defaultDetailSet;\n+            return switch (kind) {\n+                case ANNOTATION_TYPE -> annotationDetailSet;\n+                case ENUM -> enumDetailSet;\n+                default -> defaultDetailSet;\n+            };\n@@ -216,1 +221,1 @@\n-    public List<? extends Element> getAllVisibleMembers(Kind kind) {\n+    public List<Element> getAllVisibleMembers(Kind kind) {\n@@ -228,1 +233,1 @@\n-    public List<? extends Element> getVisibleMembers(Kind kind, Predicate<Element> p) {\n+    public List<Element> getVisibleMembers(Kind kind, Predicate<Element> p) {\n@@ -243,1 +248,1 @@\n-    public List<? extends Element> getVisibleMembers(Kind kind) {\n+    public List<Element> getVisibleMembers(Kind kind) {\n@@ -258,1 +263,1 @@\n-    public List<? extends Element> getMembers(Kind kind) {\n+    public List<Element> getMembers(Kind kind) {\n@@ -780,0 +785,1 @@\n+                            addMember(e, Kind.ANNOTATION_TYPE_MEMBER);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-final public class JInfo {\n+public final class JInfo {\n","filename":"src\/jdk.jcmd\/share\/classes\/sun\/tools\/jinfo\/JInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-.\\\" Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+.\\\" Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -182,0 +182,9 @@\n+.B \\f[CB]Compiler.perfmap\\f[R] (Linux only)\n+Write map file for Linux perf tool.\n+.RS\n+.PP\n+Impact: Low\n+.PP\n+Permission: \\f[CB]java.lang.management.ManagementPermission(monitor)\\f[R]\n+.RE\n+.TP\n@@ -249,0 +258,8 @@\n+.IP \\[bu] 2\n+\\f[CB]\\-parallel\\f[R]: (Optional) Number of parallel threads to use for\n+heap inspection.\n+0 (the default) means let the VM determine the number of threads to use.\n+1 means use one thread (disable parallelism).\n+For any other value the VM will try to use the specified number of\n+threads, but might use fewer.\n+(INT, 0)\n@@ -278,0 +295,8 @@\n+.IP \\[bu] 2\n+\\f[CB]\\-gz\\f[R]: (Optional) If specified, the heap dump is written in\n+gzipped format using the given compression level.\n+1 (recommended) is the fastest, 9 the strongest compression.\n+(INT, 1)\n+.IP \\[bu] 2\n+\\f[CB]\\-overwrite\\f[R]: (Optional) If specified, the dump file will be\n+overwritten if it exists (BOOLEAN, false)\n@@ -444,2 +469,0 @@\n-If \\f[CB]%p\\f[R] and\/or \\f[CB]%t\\f[R] is specified in the filename, it\n-expands to the JVM\\[aq]s PID and the current timestamp, respectively.\n@@ -514,2 +537,0 @@\n-If \\f[CB]%p\\f[R] and\/or \\f[CB]%t\\f[R] is specified in the filename, it\n-expands to the JVM\\[aq]s PID and the current timestamp, respectively.\n@@ -607,2 +628,0 @@\n-If \\f[CB]%p\\f[R] and\/or \\f[CB]%t\\f[R] is specified in the filename, it\n-expands to the JVM\\[aq]s PID and the current timestamp, respectively.\n@@ -754,0 +773,9 @@\n+.B \\f[CB]System.trim_native_heap\\f[R] (Linux only)\n+Attempts to free up memory by trimming the C\\-heap.\n+.RS\n+.PP\n+Impact: Low\n+.PP\n+Permission: \\f[CB]java.lang.management.ManagementPermission(control)\\f[R]\n+.RE\n+.TP\n@@ -769,0 +797,3 @@\n+\\f[CB]\\-e\\f[R]: (Optional) Print extended thread information (BOOLEAN,\n+false)\n+.IP \\[bu] 2\n@@ -773,0 +804,42 @@\n+.B \\f[CB]VM.cds\\f[R] [\\f[I]arguments\\f[R]]\n+Dump a static or dynamic shared archive including all shareable classes.\n+.RS\n+.PP\n+Impact: Medium \\-\\-\\- pause time depends on number of loaded classes\n+.PP\n+Permission: \\f[CB]java.lang.management.ManagementPermission(monitor)\\f[R]\n+.PP\n+\\f[I]arguments\\f[R]:\n+.IP \\[bu] 2\n+\\f[CB]subcmd\\f[R]: \\f[CB]static_dump\\f[R] | \\f[CB]dynamic_dump\\f[R] (STRING,\n+no default value)\n+.IP \\[bu] 2\n+\\f[CB]filename\\f[R]: (Optional) Name of the shared archive to be dumped\n+(STRING, no default value)\n+.RE\n+.TP\n+.B \\f[CB]VM.classloaders\\f[R] [\\f[I]options\\f[R]]\n+Prints classloader hierarchy.\n+.RS\n+.PP\n+Impact: Medium \\-\\-\\- Depends on number of class loaders and classes\n+loaded.\n+.PP\n+Permission: \\f[CB]java.lang.management.ManagementPermission(monitor)\\f[R]\n+.PP\n+The following \\f[I]options\\f[R] must be specified using either\n+\\f[I]key\\f[R] or \\f[I]key\\f[R]\\f[CB]=\\f[R]\\f[I]value\\f[R] syntax.\n+.PP\n+\\f[I]options\\f[R]:\n+.IP \\[bu] 2\n+\\f[CB]show\\-classes\\f[R]: (Optional) Print loaded classes.\n+(BOOLEAN, false)\n+.IP \\[bu] 2\n+\\f[CB]verbose\\f[R]: (Optional) Print detailed information.\n+(BOOLEAN, false)\n+.IP \\[bu] 2\n+\\f[CB]fold\\f[R]: (Optional) Show loaders of the same name and class as\n+one.\n+(BOOLEAN, true)\n+.RE\n+.TP\n@@ -834,0 +907,25 @@\n+.B \\f[CB]VM.events\\f[R] [\\f[I]options\\f[R]]\n+Print VM event logs\n+.RS\n+.PP\n+Impact: Low \\-\\-\\- Depends on event log size.\n+.PP\n+Permission: \\f[CB]java.lang.management.ManagementPermission(monitor)\\f[R]\n+.PP\n+\\f[I]options\\f[R]:\n+.PP\n+\\f[B]Note:\\f[R]\n+.PP\n+The following \\f[I]options\\f[R] must be specified using either\n+\\f[I]key\\f[R] or \\f[I]key\\f[R]\\f[CB]=\\f[R]\\f[I]value\\f[R] syntax.\n+.IP \\[bu] 2\n+\\f[CB]log\\f[R]: (Optional) Name of log to be printed.\n+If omitted, all logs are printed.\n+(STRING, no default value)\n+.IP \\[bu] 2\n+\\f[CB]max\\f[R]: (Optional) Maximum number of events to be printed (newest\n+first).\n+If omitted, all events are printed.\n+(STRING, no default value)\n+.RE\n+.TP\n@@ -903,0 +1001,42 @@\n+.B \\f[CB]VM.metaspace\\f[R] [\\f[I]options\\f[R]]\n+Prints the statistics for the metaspace\n+.RS\n+.PP\n+Impact: Medium \\-\\-\\- Depends on number of classes loaded.\n+.PP\n+Permission: \\f[CB]java.lang.management.ManagementPermission(monitor)\\f[R]\n+.PP\n+\\f[B]Note:\\f[R]\n+.PP\n+The following \\f[I]options\\f[R] must be specified using either\n+\\f[I]key\\f[R] or \\f[I]key\\f[R]\\f[CB]=\\f[R]\\f[I]value\\f[R] syntax.\n+.PP\n+\\f[I]options\\f[R]:\n+.IP \\[bu] 2\n+\\f[CB]basic\\f[R]: (Optional) Prints a basic summary (does not need a\n+safepoint).\n+(BOOLEAN, false)\n+.IP \\[bu] 2\n+\\f[CB]show\\-loaders\\f[R]: (Optional) Shows usage by class loader.\n+(BOOLEAN, false)\n+.IP \\[bu] 2\n+\\f[CB]show\\-classes\\f[R]: (Optional) If show\\-loaders is set, shows loaded\n+classes for each loader.\n+(BOOLEAN, false)\n+.IP \\[bu] 2\n+\\f[CB]by\\-chunktype\\f[R]: (Optional) Break down numbers by chunk type.\n+(BOOLEAN, false)\n+.IP \\[bu] 2\n+\\f[CB]by\\-spacetype\\f[R]: (Optional) Break down numbers by loader type.\n+(BOOLEAN, false)\n+.IP \\[bu] 2\n+\\f[CB]vslist\\f[R]: (Optional) Shows details about the underlying virtual\n+space.\n+(BOOLEAN, false)\n+.IP \\[bu] 2\n+\\f[CB]scale\\f[R]: (Optional) Memory usage in which to scale.\n+Valid values are: 1, KB, MB or GB (fixed scale) or \"dynamic\" for a\n+dynamically chosen scale.\n+(STRING, dynamic)\n+.RE\n+.TP\n","filename":"src\/jdk.jcmd\/share\/man\/jcmd.1","additions":147,"deletions":7,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-    static abstract class XOpenTypeData extends JTable {\n+    abstract static class XOpenTypeData extends JTable {\n","filename":"src\/jdk.jconsole\/share\/classes\/sun\/tools\/jconsole\/inspector\/XOpenTypeViewer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-    static public synchronized VirtualMachineManager virtualMachineManager() {\n+    public static synchronized VirtualMachineManager virtualMachineManager() {\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/Bootstrap.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-    public static abstract class Capabilities {\n+    public abstract static class Capabilities {\n@@ -239,1 +239,1 @@\n-    public static abstract class ListenKey {\n+    public abstract static class ListenKey {\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/connect\/spi\/TransportService.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,1 +120,1 @@\n-  final public void Type() throws ParseException {\n+  public final void Type() throws ParseException {\n@@ -155,1 +155,1 @@\n-  final public void PrimitiveType() throws ParseException {\n+  public final void PrimitiveType() throws ParseException {\n@@ -188,1 +188,1 @@\n-  final public String Name() throws ParseException {\n+  public final String Name() throws ParseException {\n@@ -207,1 +207,1 @@\n-  final public void NameList() throws ParseException {\n+  public final void NameList() throws ParseException {\n@@ -227,1 +227,1 @@\n-  final public void Expression() throws ParseException {\n+  public final void Expression() throws ParseException {\n@@ -260,1 +260,1 @@\n-  final public void Assignment() throws ParseException {\n+  public final void Assignment() throws ParseException {\n@@ -267,1 +267,1 @@\n-  final public void AssignmentOperator() throws ParseException {\n+  public final void AssignmentOperator() throws ParseException {\n@@ -312,1 +312,1 @@\n-  final public void ConditionalExpression() throws ParseException {\n+  public final void ConditionalExpression() throws ParseException {\n@@ -335,1 +335,1 @@\n-  final public void ConditionalOrExpression() throws ParseException {\n+  public final void ConditionalOrExpression() throws ParseException {\n@@ -353,1 +353,1 @@\n-  final public void ConditionalAndExpression() throws ParseException {\n+  public final void ConditionalAndExpression() throws ParseException {\n@@ -371,1 +371,1 @@\n-  final public void InclusiveOrExpression() throws ParseException {\n+  public final void InclusiveOrExpression() throws ParseException {\n@@ -389,1 +389,1 @@\n-  final public void ExclusiveOrExpression() throws ParseException {\n+  public final void ExclusiveOrExpression() throws ParseException {\n@@ -407,1 +407,1 @@\n-  final public void AndExpression() throws ParseException {\n+  public final void AndExpression() throws ParseException {\n@@ -425,1 +425,1 @@\n-  final public void EqualityExpression() throws ParseException {\n+  public final void EqualityExpression() throws ParseException {\n@@ -457,1 +457,1 @@\n-  final public void InstanceOfExpression() throws ParseException {\n+  public final void InstanceOfExpression() throws ParseException {\n@@ -471,1 +471,1 @@\n-  final public void RelationalExpression() throws ParseException {\n+  public final void RelationalExpression() throws ParseException {\n@@ -511,1 +511,1 @@\n-  final public void ShiftExpression() throws ParseException {\n+  public final void ShiftExpression() throws ParseException {\n@@ -545,1 +545,1 @@\n-  final public void AdditiveExpression() throws ParseException {\n+  public final void AdditiveExpression() throws ParseException {\n@@ -577,1 +577,1 @@\n-  final public void MultiplicativeExpression() throws ParseException {\n+  public final void MultiplicativeExpression() throws ParseException {\n@@ -613,1 +613,1 @@\n-  final public void UnaryExpression() throws ParseException {\n+  public final void UnaryExpression() throws ParseException {\n@@ -662,1 +662,1 @@\n-  final public void PreIncrementExpression() throws ParseException {\n+  public final void PreIncrementExpression() throws ParseException {\n@@ -668,1 +668,1 @@\n-  final public void PreDecrementExpression() throws ParseException {\n+  public final void PreDecrementExpression() throws ParseException {\n@@ -674,1 +674,1 @@\n-  final public void UnaryExpressionNotPlusMinus() throws ParseException {\n+  public final void UnaryExpressionNotPlusMinus() throws ParseException {\n@@ -726,1 +726,1 @@\n-  final public void CastLookahead() throws ParseException {\n+  public final void CastLookahead() throws ParseException {\n@@ -786,1 +786,1 @@\n-  final public void PostfixExpression() throws ParseException {\n+  public final void PostfixExpression() throws ParseException {\n@@ -811,1 +811,1 @@\n-  final public void CastExpression() throws ParseException {\n+  public final void CastExpression() throws ParseException {\n@@ -859,1 +859,1 @@\n-  final public void PrimaryExpression() throws ParseException {\n+  public final void PrimaryExpression() throws ParseException {\n@@ -877,1 +877,1 @@\n-  final public void PrimaryPrefix() throws ParseException {\n+  public final void PrimaryPrefix() throws ParseException {\n@@ -918,1 +918,1 @@\n-  final public void PrimarySuffix() throws ParseException {\n+  public final void PrimarySuffix() throws ParseException {\n@@ -944,1 +944,1 @@\n-  final public void Literal() throws ParseException {\n+  public final void Literal() throws ParseException {\n@@ -978,1 +978,1 @@\n-  final public void BooleanLiteral() throws ParseException {\n+  public final void BooleanLiteral() throws ParseException {\n@@ -993,1 +993,1 @@\n-  final public void NullLiteral() throws ParseException {\n+  public final void NullLiteral() throws ParseException {\n@@ -997,1 +997,1 @@\n-  final public List<Value> Arguments() throws ParseException {\n+  public final List<Value> Arguments() throws ParseException {\n@@ -1030,1 +1030,1 @@\n-  final public void ArgumentList(List<Value> argList) throws ParseException {\n+  public final void ArgumentList(List<Value> argList) throws ParseException {\n@@ -1049,1 +1049,1 @@\n-  final public void AllocationExpression() throws ParseException {\n+  public final void AllocationExpression() throws ParseException {\n@@ -1087,1 +1087,1 @@\n-  final public void ArrayDimensions() throws ParseException {\n+  public final void ArrayDimensions() throws ParseException {\n@@ -2053,5 +2053,5 @@\n-  final private int[] jj_la1 = new int[44];\n-  static private int[] jj_la1_0;\n-  static private int[] jj_la1_1;\n-  static private int[] jj_la1_2;\n-  static private int[] jj_la1_3;\n+  private final int[] jj_la1 = new int[44];\n+  private static int[] jj_la1_0;\n+  private static int[] jj_la1_1;\n+  private static int[] jj_la1_2;\n+  private static int[] jj_la1_3;\n@@ -2076,1 +2076,1 @@\n-  final private JJCalls[] jj_2_rtns = new JJCalls[9];\n+  private final JJCalls[] jj_2_rtns = new JJCalls[9];\n@@ -2177,2 +2177,2 @@\n-  static private final class LookaheadSuccess extends java.lang.Error { }\n-  final private LookaheadSuccess jj_ls = new LookaheadSuccess();\n+  private static final class LookaheadSuccess extends java.lang.Error { }\n+  private final LookaheadSuccess jj_ls = new LookaheadSuccess();\n@@ -2202,1 +2202,1 @@\n-  final public Token getNextToken() {\n+  public final Token getNextToken() {\n@@ -2211,1 +2211,1 @@\n-  final public Token getToken(int index) {\n+  public final Token getToken(int index) {\n@@ -2302,1 +2302,1 @@\n-  final public void enable_tracing() {\n+  public final void enable_tracing() {\n@@ -2306,1 +2306,1 @@\n-  final public void disable_tracing() {\n+  public final void disable_tracing() {\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/expr\/ExpressionParser.java","additions":49,"deletions":49,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,1 @@\n-    static private List<String> excludes() {\n+    private static List<String> excludes() {\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/Env.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -307,1 +307,1 @@\n-    static private boolean isPreviousCharWhitespace(char[] arr, int curr_pos) {\n+    private static boolean isPreviousCharWhitespace(char[] arr, int curr_pos) {\n@@ -311,1 +311,1 @@\n-    static private boolean isNextCharWhitespace(char[] arr, int curr_pos) {\n+    private static boolean isNextCharWhitespace(char[] arr, int curr_pos) {\n@@ -315,1 +315,1 @@\n-    static private boolean isCharWhitespace(char[] arr, int pos) {\n+    private static boolean isCharWhitespace(char[] arr, int pos) {\n@@ -326,1 +326,1 @@\n-    static private boolean isLastChar(char[] arr, int pos) {\n+    private static boolean isLastChar(char[] arr, int pos) {\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/VMConnection.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-    abstract public VirtualMachine\n+    public abstract VirtualMachine\n@@ -54,1 +54,1 @@\n-    abstract public String name();\n+    public abstract String name();\n@@ -56,1 +56,1 @@\n-    abstract public String description();\n+    public abstract String description();\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/AbstractLauncher.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-final public class ClassTypeImpl extends InvokableTypeImpl\n+public final class ClassTypeImpl extends InvokableTypeImpl\n@@ -49,1 +49,1 @@\n-        final private JDWP.ClassType.InvokeMethod rslt;\n+        private final JDWP.ClassType.InvokeMethod rslt;\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/ClassTypeImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    static private class SoftLocationXRefs {\n+    private static class SoftLocationXRefs {\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/ConcreteMethodImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-final public class InterfaceTypeImpl extends InvokableTypeImpl\n+public final class InterfaceTypeImpl extends InvokableTypeImpl\n@@ -43,1 +43,1 @@\n-        final private JDWP.InterfaceType.InvokeMethod rslt;\n+        private final JDWP.InterfaceType.InvokeMethod rslt;\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/InterfaceTypeImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-    final public Value invokeMethod(ThreadReference threadIntf, Method methodIntf,\n+    public final Value invokeMethod(ThreadReference threadIntf, Method methodIntf,\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/InvokableTypeImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,3 +31,3 @@\n-    public final static short NoFlags = 0x0;\n-    public final static short Reply = 0x80;\n-    public final static short ReplyNoError = 0x0;\n+    public static final short NoFlags = 0x0;\n+    public static final short Reply = 0x80;\n+    public static final short ReplyNoError = 0x0;\n@@ -36,1 +36,1 @@\n-    final static byte[] nullData = new byte[0];\n+    static final byte[] nullData = new byte[0];\n@@ -124,1 +124,1 @@\n-    static synchronized private int uniqID() {\n+    private static synchronized int uniqID() {\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/Packet.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,8 +42,8 @@\n-    abstract public boolean booleanValue();\n-    abstract public byte byteValue();\n-    abstract public char charValue();\n-    abstract public short shortValue();\n-    abstract public int intValue();\n-    abstract public long longValue();\n-    abstract public float floatValue();\n-    abstract public double doubleValue();\n+    public abstract boolean booleanValue();\n+    public abstract byte byteValue();\n+    public abstract char charValue();\n+    public abstract short shortValue();\n+    public abstract int intValue();\n+    public abstract long longValue();\n+    public abstract float floatValue();\n+    public abstract double doubleValue();\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/PrimitiveValueImpl.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,3 +41,3 @@\n-    static private final String ARG_COMMAND = \"command\";\n-    static private final String ARG_ADDRESS = \"address\";\n-    static private final String ARG_QUOTE   = \"quote\";\n+    private static final String ARG_COMMAND = \"command\";\n+    private static final String ARG_ADDRESS = \"address\";\n+    private static final String ARG_QUOTE   = \"quote\";\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/RawCommandLineLauncher.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -568,1 +568,1 @@\n-    abstract public List<Method> allMethods();\n+    public abstract List<Method> allMethods();\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/ReferenceTypeImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,6 +43,6 @@\n-    static private final String ARG_HOME = \"home\";\n-    static private final String ARG_OPTIONS = \"options\";\n-    static private final String ARG_MAIN = \"main\";\n-    static private final String ARG_INIT_SUSPEND = \"suspend\";\n-    static private final String ARG_QUOTE = \"quote\";\n-    static private final String ARG_VM_EXEC = \"vmexec\";\n+    private static final String ARG_HOME = \"home\";\n+    private static final String ARG_OPTIONS = \"options\";\n+    private static final String ARG_MAIN = \"main\";\n+    private static final String ARG_INIT_SUSPEND = \"suspend\";\n+    private static final String ARG_QUOTE = \"quote\";\n+    private static final String ARG_VM_EXEC = \"vmexec\";\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/SunCommandLineLauncher.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n-    static private final int OVERLOADED_QUEUE = 10000;\n-    static private final int UNDERLOADED_QUEUE = 100;\n+    private static final int OVERLOADED_QUEUE = 10000;\n+    private static final int UNDERLOADED_QUEUE = 100;\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/TargetVM.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -410,1 +410,1 @@\n-    synchronized private List<StackFrame> privateFrames(int start, int length)\n+    private synchronized List<StackFrame> privateFrames(int start, int length)\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/ThreadReferenceImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-abstract public class TypeComponentImpl extends MirrorImpl\n+public abstract class TypeComponentImpl extends MirrorImpl\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/TypeComponentImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-    static private final int DISPOSE_THRESHOLD = 50;\n+    private static final int DISPOSE_THRESHOLD = 50;\n@@ -1551,1 +1551,1 @@\n-   static private class SoftObjectReference extends SoftReference<ObjectReferenceImpl> {\n+   private static class SoftObjectReference extends SoftReference<ObjectReferenceImpl> {\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/VirtualMachineImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-                    pInstallOptions = \"\";\n+                    pInstallOptions = I18N.getString(\"MSG_Help_mac_install\");\n@@ -82,1 +82,2 @@\n-                            + I18N.getString(\"MSG_Help_linux_install\");\n+                            + I18N.getString(\"MSG_Help_linux_install\")\n+                            + I18N.getString(\"MSG_Help_mac_install\");\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/CLIHelp.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -236,0 +236,5 @@\n+MSG_Help_mac_install=\\\n+\\  --mac-dmg-content <additional content path>[,<additional content path>...]\\n\\\n+\\          Include all the referenced content in the dmg.\\n\\\n+\\          This option can be used multiple times. \\n\\\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/HelpResources.properties","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -228,0 +228,6 @@\n+\n+MSG_Help_mac_install=\\\n+\\  --mac-dmg-content <additional content path>[,<additional content path>...]\\n\\\n+\\          Include all the referenced content in the dmg.\\n\\\n+\\          This option can be used multiple times. \\n\\\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/HelpResources_ja.properties","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -227,0 +227,6 @@\n+\n+MSG_Help_mac_install=\\\n+\\  --mac-dmg-content <additional content path>[,<additional content path>...]\\n\\\n+\\          Include all the referenced content in the dmg.\\n\\\n+\\          This option can be used multiple times. \\n\\\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/HelpResources_zh_CN.properties","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -560,3 +560,5 @@\n-                \/\/ token wasn't a terminating one.  Special case: within braces,\n-                \/\/ comma can proceed semicolon, e.g. the values list in enum\n-                if (ct.kind.isStart() && !prevTK.isOkToTerminate() && prevTK != COMMA) {\n+                \/\/ token wasn't a terminating one.  Special cases:\n+                \/\/ -within braces, comma can procede semicolon, e.g. the values list in enum\n+                \/\/ -arrow can be followed by a throw, e.g. in a switch\/switch expression\n+                if (ct.kind.isStart() && !prevTK.isOkToTerminate() && prevTK != COMMA &&\n+                    !(prevTK == ARROW && ct.kind == THROW)) {\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/CompletenessAnalyzer.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-    static abstract class PersistentKey extends Key {\n+    abstract static class PersistentKey extends Key {\n@@ -98,1 +98,1 @@\n-    static abstract class DeclarationKey extends PersistentKey {\n+    abstract static class DeclarationKey extends PersistentKey {\n@@ -204,1 +204,1 @@\n-    static abstract class UniqueKey extends Key {\n+    abstract static class UniqueKey extends Key {\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/Key.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-    static abstract class MemoryJavaFileObject extends SimpleJavaFileObject {\n+    abstract static class MemoryJavaFileObject extends SimpleJavaFileObject {\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/MemoryFileManager.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1384,2 +1384,1 @@\n-                URI uri = URI.create(\"jar:\" + srcZip.toUri());\n-                zipFO = FileSystems.newFileSystem(uri, Collections.emptyMap());\n+                zipFO = FileSystems.newFileSystem(srcZip, Collections.emptyMap());\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/SourceCodeAnalysisImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -340,1 +340,1 @@\n-    public static abstract class ExecutionControlException extends Exception {\n+    public abstract static class ExecutionControlException extends Exception {\n@@ -413,1 +413,1 @@\n-    public static abstract class RunException extends ExecutionControlException {\n+    public abstract static class RunException extends ExecutionControlException {\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/spi\/ExecutionControl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -354,1 +354,1 @@\n-            {\"Africa\/Juba\", EAT},\n+            {\"Africa\/Juba\", CAT},\n@@ -381,1 +381,3 @@\n-            {\"Africa\/Windhoek\", CAT},\n+            {\"Africa\/Windhoek\", new String[] {\"Central African Time\", \"CAT\",\n+                                              \"Western African Time\", \"WAT\",\n+                                              \"Central African Time\", \"CAT\"}},\n@@ -567,3 +569,3 @@\n-            {\"Antarctica\/Macquarie\", new String[] {\"Macquarieinsel Zeit\", \"MIST\",\n-                                                   \"Macquarieinsel Sommerzeit\", \"MIST\",\n-                                                   \"Macquarieinsel Zeit\", \"MIST\"}},\n+            {\"Antarctica\/Macquarie\", new String[] {\"Australian Eastern Standard Time (Macquarie)\", \"AEST\",\n+                                                   \"Australian Eastern Daylight Time (Macquarie)\", \"AEDT\",\n+                                                   \"Australian Eastern Time (Macquarie)\", \"AET\"}},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_de.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -354,1 +354,1 @@\n-            {\"Africa\/Juba\", EAT},\n+            {\"Africa\/Juba\", CAT},\n@@ -381,1 +381,3 @@\n-            {\"Africa\/Windhoek\", CAT},\n+            {\"Africa\/Windhoek\", new String[] {\"Central African Time\", \"CAT\",\n+                                              \"Western African Time\", \"WAT\",\n+                                              \"Central African Time\", \"CAT\"}},\n@@ -567,3 +569,3 @@\n-            {\"Antarctica\/Macquarie\", new String[] {\"Hora de Isla Macquarie\", \"MIST\",\n-                                                   \"Hora de verano de Isla Macquarie\", \"MIST\",\n-                                                   \"Hora de Isla Macquarie\", \"MIST\"}},\n+            {\"Antarctica\/Macquarie\", new String[] {\"Australian Eastern Standard Time (Macquarie)\", \"AEST\",\n+                                                   \"Australian Eastern Daylight Time (Macquarie)\", \"AEDT\",\n+                                                   \"Australian Eastern Time (Macquarie)\", \"AET\"}},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_es.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -354,1 +354,1 @@\n-            {\"Africa\/Juba\", EAT},\n+            {\"Africa\/Juba\", CAT},\n@@ -381,1 +381,3 @@\n-            {\"Africa\/Windhoek\", CAT},\n+            {\"Africa\/Windhoek\", new String[] {\"Central African Time\", \"CAT\",\n+                                              \"Western African Time\", \"WAT\",\n+                                              \"Central African Time\", \"CAT\"}},\n@@ -567,3 +569,3 @@\n-            {\"Antarctica\/Macquarie\", new String[] {\"Heure de l'Ile Macquarie\", \"MIST\",\n-                                                   \"Heure d'\\u00E9t\\u00E9 de l'Ile Macquarie\", \"MIST\",\n-                                                   \"Heure de l'Ile Macquarie\", \"MIST\"}},\n+            {\"Antarctica\/Macquarie\", new String[] {\"Australian Eastern Standard Time (Macquarie)\", \"AEST\",\n+                                                   \"Australian Eastern Daylight Time (Macquarie)\", \"AEDT\",\n+                                                   \"Australian Eastern Time (Macquarie)\", \"AET\"}},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_fr.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -354,1 +354,1 @@\n-            {\"Africa\/Juba\", EAT},\n+            {\"Africa\/Juba\", CAT},\n@@ -381,1 +381,3 @@\n-            {\"Africa\/Windhoek\", CAT},\n+            {\"Africa\/Windhoek\", new String[] {\"Central African Time\", \"CAT\",\n+                                              \"Western African Time\", \"WAT\",\n+                                              \"Central African Time\", \"CAT\"}},\n@@ -567,3 +569,3 @@\n-            {\"Antarctica\/Macquarie\", new String[] {\"Ora dell'Isola Macquarie\", \"MIST\",\n-                                                   \"Ora estiva dell'Isola Macquarie\", \"MIST\",\n-                                                   \"Ora dell'Isola Macquarie\", \"MIST\"}},\n+            {\"Antarctica\/Macquarie\", new String[] {\"Australian Eastern Standard Time (Macquarie)\", \"AEST\",\n+                                                   \"Australian Eastern Daylight Time (Macquarie)\", \"AEDT\",\n+                                                   \"Australian Eastern Time (Macquarie)\", \"AET\"}},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_it.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -354,1 +354,1 @@\n-            {\"Africa\/Juba\", EAT},\n+            {\"Africa\/Juba\", CAT},\n@@ -381,1 +381,3 @@\n-            {\"Africa\/Windhoek\", CAT},\n+            {\"Africa\/Windhoek\", new String[] {\"Central African Time\", \"CAT\",\n+                                              \"Western African Time\", \"WAT\",\n+                                              \"Central African Time\", \"CAT\"}},\n@@ -567,3 +569,3 @@\n-            {\"Antarctica\/Macquarie\", new String[] {\"\\u30DE\\u30C3\\u30B3\\u30FC\\u30EA\\u30FC\\u5CF6\\u6642\\u9593\", \"MIST\",\n-                                                   \"\\u30DE\\u30C3\\u30B3\\u30FC\\u30EA\\u30FC\\u5CF6\\u590F\\u6642\\u9593\", \"MIST\",\n-                                                   \"\\u30DE\\u30C3\\u30B3\\u30FC\\u30EA\\u30FC\\u5CF6\\u6642\\u9593\", \"MIST\"}},\n+            {\"Antarctica\/Macquarie\", new String[] {\"Australian Eastern Standard Time (Macquarie)\", \"AEST\",\n+                                                   \"Australian Eastern Daylight Time (Macquarie)\", \"AEDT\",\n+                                                   \"Australian Eastern Time (Macquarie)\", \"AET\"}},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_ja.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -354,1 +354,1 @@\n-            {\"Africa\/Juba\", EAT},\n+            {\"Africa\/Juba\", CAT},\n@@ -381,1 +381,3 @@\n-            {\"Africa\/Windhoek\", CAT},\n+            {\"Africa\/Windhoek\", new String[] {\"Central African Time\", \"CAT\",\n+                                              \"Western African Time\", \"WAT\",\n+                                              \"Central African Time\", \"CAT\"}},\n@@ -567,3 +569,3 @@\n-            {\"Antarctica\/Macquarie\", new String[] {\"\\uB9E4\\uCF70\\uB9AC \\uC12C \\uD45C\\uC900\\uC2DC\", \"MIST\",\n-                                                   \"\\uB9E4\\uCF70\\uB9AC \\uC12C \\uC77C\\uAD11 \\uC808\\uC57D \\uC2DC\\uAC04\", \"MIST\",\n-                                                   \"\\uB9E4\\uCF70\\uB9AC \\uC12C \\uD45C\\uC900\\uC2DC\", \"MIST\"}},\n+            {\"Antarctica\/Macquarie\", new String[] {\"Australian Eastern Standard Time (Macquarie)\", \"AEST\",\n+                                                   \"Australian Eastern Daylight Time (Macquarie)\", \"AEDT\",\n+                                                   \"Australian Eastern Time (Macquarie)\", \"AET\"}},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_ko.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -354,1 +354,1 @@\n-            {\"Africa\/Juba\", EAT},\n+            {\"Africa\/Juba\", CAT},\n@@ -381,1 +381,3 @@\n-            {\"Africa\/Windhoek\", CAT},\n+            {\"Africa\/Windhoek\", new String[] {\"Central African Time\", \"CAT\",\n+                                              \"Western African Time\", \"WAT\",\n+                                              \"Central African Time\", \"CAT\"}},\n@@ -567,3 +569,3 @@\n-            {\"Antarctica\/Macquarie\", new String[] {\"Fuso Hor\\u00E1rio da Ilha de Macquarie\", \"MIST\",\n-                                                   \"Fuso Hor\\u00E1rio de Ver\\u00E3o da Ilha de Macquarie\", \"MIST\",\n-                                                   \"Fuso Hor\\u00E1rio da Ilha de Macquarie\", \"MIST\"}},\n+            {\"Antarctica\/Macquarie\", new String[] {\"Australian Eastern Standard Time (Macquarie)\", \"AEST\",\n+                                                   \"Australian Eastern Daylight Time (Macquarie)\", \"AEDT\",\n+                                                   \"Australian Eastern Time (Macquarie)\", \"AET\"}},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_pt_BR.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -354,1 +354,1 @@\n-            {\"Africa\/Juba\", EAT},\n+            {\"Africa\/Juba\", CAT},\n@@ -381,1 +381,3 @@\n-            {\"Africa\/Windhoek\", CAT},\n+            {\"Africa\/Windhoek\", new String[] {\"Central African Time\", \"CAT\",\n+                                              \"Western African Time\", \"WAT\",\n+                                              \"Central African Time\", \"CAT\"}},\n@@ -567,3 +569,3 @@\n-            {\"Antarctica\/Macquarie\", new String[] {\"Macquarie\\u00F6n, normaltid\", \"MIST\",\n-                                                   \"Macquarie\\u00F6n, sommartid\", \"MIST\",\n-                                                   \"Macquarie\\u00F6n, normaltid\", \"MIST\"}},\n+            {\"Antarctica\/Macquarie\", new String[] {\"Australian Eastern Standard Time (Macquarie)\", \"AEST\",\n+                                                   \"Australian Eastern Daylight Time (Macquarie)\", \"AEDT\",\n+                                                   \"Australian Eastern Time (Macquarie)\", \"AET\"}},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_sv.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -354,1 +354,1 @@\n-            {\"Africa\/Juba\", EAT},\n+            {\"Africa\/Juba\", CAT},\n@@ -381,1 +381,3 @@\n-            {\"Africa\/Windhoek\", CAT},\n+            {\"Africa\/Windhoek\", new String[] {\"Central African Time\", \"CAT\",\n+                                              \"Western African Time\", \"WAT\",\n+                                              \"Central African Time\", \"CAT\"}},\n@@ -567,3 +569,3 @@\n-            {\"Antarctica\/Macquarie\", new String[] {\"\\u9EA6\\u5938\\u91CC\\u5C9B\\u65F6\\u95F4\", \"MIST\",\n-                                                   \"\\u9EA6\\u5938\\u91CC\\u5C9B\\u590F\\u4EE4\\u65F6\", \"MIST\",\n-                                                   \"\\u9EA6\\u5938\\u91CC\\u5C9B\\u65F6\\u95F4\", \"MIST\"}},\n+            {\"Antarctica\/Macquarie\", new String[] {\"Australian Eastern Standard Time (Macquarie)\", \"AEST\",\n+                                                   \"Australian Eastern Daylight Time (Macquarie)\", \"AEDT\",\n+                                                   \"Australian Eastern Time (Macquarie)\", \"AET\"}},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_zh_CN.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -354,1 +354,1 @@\n-            {\"Africa\/Juba\", EAT},\n+            {\"Africa\/Juba\", CAT},\n@@ -381,1 +381,3 @@\n-            {\"Africa\/Windhoek\", CAT},\n+            {\"Africa\/Windhoek\", new String[] {\"Central African Time\", \"CAT\",\n+                                              \"Western African Time\", \"WAT\",\n+                                              \"Central African Time\", \"CAT\"}},\n@@ -567,3 +569,3 @@\n-            {\"Antarctica\/Macquarie\", new String[] {\"\\u9EA5\\u5938\\u5229\\u5CF6\\u6642\\u9593\", \"MIST\",\n-                                                   \"\\u9EA5\\u5938\\u5229\\u5CF6\\u590F\\u4EE4\\u6642\\u9593\", \"MIST\",\n-                                                   \"\\u9EA5\\u5938\\u5229\\u5CF6\\u6642\\u9593\", \"MIST\"}},\n+            {\"Antarctica\/Macquarie\", new String[] {\"Australian Eastern Standard Time (Macquarie)\", \"AEST\",\n+                                                   \"Australian Eastern Daylight Time (Macquarie)\", \"AEDT\",\n+                                                   \"Australian Eastern Time (Macquarie)\", \"AET\"}},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_zh_TW.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,1 @@\n-    private static abstract class StatusCollector {\n+    private abstract static class StatusCollector {\n@@ -96,2 +96,2 @@\n-        final protected StringBuilder sb = new StringBuilder();\n-        final public String collect() {\n+        protected final StringBuilder sb = new StringBuilder();\n+        public final String collect() {\n@@ -172,9 +172,9 @@\n-        abstract protected void addAgentStatus(boolean enabled);\n-        abstract protected void appendConnectionsHeader();\n-        abstract protected void appendConnectionsFooter();\n-        abstract protected void addConnectionDetails(JMXServiceURL u);\n-        abstract protected void appendConnectionHeader(boolean remote);\n-        abstract protected void appendConnectionFooter(boolean remote);\n-        abstract protected void appendConfigPropsHeader();\n-        abstract protected void appendConfigPropsFooter();\n-        abstract protected void addConfigProp(Map.Entry<?, ?> prop);\n+        protected abstract void addAgentStatus(boolean enabled);\n+        protected abstract void appendConnectionsHeader();\n+        protected abstract void appendConnectionsFooter();\n+        protected abstract void addConnectionDetails(JMXServiceURL u);\n+        protected abstract void appendConnectionHeader(boolean remote);\n+        protected abstract void appendConnectionFooter(boolean remote);\n+        protected abstract void appendConfigPropsHeader();\n+        protected abstract void appendConfigPropsFooter();\n+        protected abstract void addConfigProp(Map.Entry<?, ?> prop);\n@@ -186,1 +186,1 @@\n-    final private static class TextStatusCollector extends StatusCollector {\n+    private static final class TextStatusCollector extends StatusCollector {\n","filename":"src\/jdk.management.agent\/share\/classes\/jdk\/internal\/agent\/Agent.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-    public final static String UUID_KEY = \"DISCOVERABLE_SESSION_UUID\";\n+    public static final String UUID_KEY = \"DISCOVERABLE_SESSION_UUID\";\n@@ -58,1 +58,1 @@\n-    public final static String MAIN_CLASS_KEY = \"MAIN_CLASS\";\n+    public static final String MAIN_CLASS_KEY = \"MAIN_CLASS\";\n@@ -62,1 +62,1 @@\n-    public final static String JMX_SERVICE_URL_KEY = \"JMX_SERVICE_URL\";\n+    public static final String JMX_SERVICE_URL_KEY = \"JMX_SERVICE_URL\";\n@@ -66,1 +66,1 @@\n-    public final static String INSTANCE_NAME_KEY = \"INSTANCE_NAME\";\n+    public static final String INSTANCE_NAME_KEY = \"INSTANCE_NAME\";\n@@ -70,1 +70,1 @@\n-    public final static String PROCESS_ID_KEY = \"PROCESS_ID\";\n+    public static final String PROCESS_ID_KEY = \"PROCESS_ID\";\n@@ -75,1 +75,1 @@\n-    public final static String RMI_HOSTNAME_KEY = \"RMI_HOSTNAME\";\n+    public static final String RMI_HOSTNAME_KEY = \"RMI_HOSTNAME\";\n@@ -79,1 +79,1 @@\n-    public final static String BROADCAST_INTERVAL_KEY = \"BROADCAST_INTERVAL\";\n+    public static final String BROADCAST_INTERVAL_KEY = \"BROADCAST_INTERVAL\";\n","filename":"src\/jdk.management.agent\/share\/classes\/sun\/management\/jdp\/JdpJmxPacket.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -338,1 +338,1 @@\n-    private final static String notifName =\n+    private static final String notifName =\n@@ -341,1 +341,1 @@\n-    private final static String[] diagFramNotifTypes = {\n+    private static final String[] diagFramNotifTypes = {\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/DiagnosticCommandImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-    private final static String notifName =\n+    private static final String notifName =\n@@ -76,1 +76,1 @@\n-    private final static String[] gcNotifTypes = {\n+    private static final String[] gcNotifTypes = {\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/GarbageCollectorExtImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    final static String DIAGNOSTIC_COMMAND_MBEAN_NAME =\n+    static final String DIAGNOSTIC_COMMAND_MBEAN_NAME =\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/PlatformMBeanProviderImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+\n+#include \"gc\/g1\/g1BlockOffsetTable.inline.hpp\"\n+#include \"gc\/g1\/g1CardSet.inline.hpp\"\n@@ -26,0 +29,6 @@\n+#include \"gc\/g1\/g1RegionToSpaceMapper.hpp\"\n+#include \"gc\/g1\/heapRegion.inline.hpp\"\n+#include \"gc\/g1\/heapRegionSet.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/memRegion.hpp\"\n+#include \"memory\/virtualspace.hpp\"\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_freeRegionList.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -712,5 +712,1 @@\n-#if defined(__APPLE__)  \/\/ See JDK-8273967.\n-  TEST_VM(os, DISABLED_dll_address_to_function_and_library_name) {\n-#else\n-  TEST_VM(os, dll_address_to_function_and_library_name) {\n-#endif\n+TEST_VM(os, dll_address_to_function_and_library_name) {\n@@ -729,0 +725,1 @@\n+  LOG(\"os::print_function_and_library_name(st, -1) expects FALSE.\");\n@@ -731,0 +728,1 @@\n+  LOG(\"os::print_function_and_library_name(st, NULL) expects FALSE.\");\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress randomness\n+ * @bug 8271056\n+ * @summary A dead data loop is created when applying an unsafe case of Cmov'ing identity.\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileCommand=compileonly,compiler.c2.TestDeadDataLoopCmoveIdentity::*\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN -XX:StressSeed=359948366 compiler.c2.TestDeadDataLoopCmoveIdentity\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileCommand=compileonly,compiler.c2.TestDeadDataLoopCmoveIdentity::*\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN compiler.c2.TestDeadDataLoopCmoveIdentity\n+ *\/\n+\n+package compiler.c2;\n+\n+public class TestDeadDataLoopCmoveIdentity {\n+    static boolean bFld;\n+\n+    public static void main(String[] strArr) {\n+        test();\n+        test2();\n+    }\n+\n+    static void test() {\n+        int i33 = 51925, iArr3[] = new int[10];\n+        if (bFld) {\n+            ;\n+        } else if (bFld) {\n+            for (int i = 0; i < 100; i++) { }\n+            do {\n+                if (i33 != 0) {\n+                }\n+                int i34 = 1;\n+                do {\n+                    switch (0) {\n+                        case 122: { }\n+                    }\n+                } while (i34 < 1);\n+                i33 += i33 + 3;\n+            } while (i33 < 5);\n+        }\n+    }\n+\n+    static void test2() {\n+        int i33 = 51925, iArr3[] = new int[10];\n+        if (bFld) {\n+            ;\n+        } else if (bFld) {\n+            do {\n+                if (i33 != 0) {\n+                }\n+                int i34 = 1;\n+                do {\n+                    switch (0) {\n+                        case 122: {}\n+                    }\n+                } while (i34 < 1);\n+            } while (++i33 < 5);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestDeadDataLoopCmoveIdentity.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8275847\n+ * @requires vm.compiler2.enabled\n+ * @summary Test that small method with runtime calls can be scheduled.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestScheduleSmallMethod\n+ *\/\n+public class TestScheduleSmallMethod {\n+\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework();\n+        Scenario schedulerOn = new Scenario(0, \"-XX:+OptoScheduling\");\n+        Scenario schedulerOff = new Scenario(1, \"-XX:-OptoScheduling\");\n+        framework.addScenarios(schedulerOn, schedulerOff).start();\n+    }\n+\n+    @Test\n+    public double testSmallMethodTwoRuntimeCalls(double value) {\n+        \/\/ The two intrinsified Math calls below caused the scheduler to\n+        \/\/ bail out with \"too many D-U pinch points\". See bug 8275847.\n+        return Math.log(Math.sin(value));\n+    }\n+\n+    @Run(test = \"testSmallMethodTwoRuntimeCalls\")\n+    public void checkTestSmallMethodTwoRuntimeCalls() throws Throwable {\n+        Asserts.assertLessThan(testSmallMethodTwoRuntimeCalls(Math.PI\/2), 0.00001);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestScheduleSmallMethod.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n- * @summary Verify that box object identity matches after deoptimization When it is eliminated.\n+ * @summary Verify that box object identity matches after deoptimization when it is eliminated.\n@@ -31,1 +31,1 @@\n- * @run main\/othervm -Xbatch compiler.c2.TestIdentityWithEliminateBoxInDebugInfo\n+ * @run main\/othervm -Xbatch compiler.eliminateAutobox.TestIdentityWithEliminateBoxInDebugInfo\n@@ -33,1 +33,2 @@\n-package compiler.c2;\n+\n+package compiler.eliminateAutobox;\n@@ -43,6 +44,6 @@\n-      \/\/ warmup\n-      for(int i = 0; i < 100000; i++) {\n-        f.apply(true);\n-      }\n-      \/\/ deoptimize\n-      f.apply(false);\n+        \/\/ warmup\n+        for (int i = 0; i < 100000; i++) {\n+            f.apply(true);\n+        }\n+        \/\/ deoptimize\n+        f.apply(false);\n","filename":"test\/hotspot\/jtreg\/compiler\/eliminateAutobox\/TestIdentityWithEliminateBoxInDebugInfo.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @bug 8276112\n+ * @summary Verify consistency of safepoint debug info when boxes are scalar\n+ *          replaced during incremental inlining.\n+ * @library \/test\/lib\n+ * @run main\/othervm -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline\n+ *                   -XX:CompileCommand=compileonly,compiler.eliminateAutobox.TestSafepointDebugInfo::test*\n+ *                   compiler.eliminateAutobox.TestSafepointDebugInfo\n+ *\/\n+\n+package compiler.eliminateAutobox;\n+\n+import java.util.Random;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+public class TestSafepointDebugInfo {\n+\n+    private static final Random random = Utils.getRandomInstance();\n+\n+    static Integer fBox;\n+\n+    public static Integer helper(int i) {\n+        return Integer.valueOf(i);\n+    }\n+\n+    \/\/ assert(local) failed: use _top instead of null\n+    public static int test1(int i) {\n+        Integer box = helper(i);\n+        fBox = Integer.valueOf(i);\n+        return box.intValue();\n+    }\n+\n+    \/\/ Wrong execution, same types\n+    public static int test2(int i1, int i2) {\n+        Integer box1 = helper(i1);\n+        Integer box2 = Integer.valueOf(i2);\n+        fBox = Integer.valueOf(i1);\n+        return box1.intValue() + box2.intValue();\n+    }\n+\n+    \/\/ Wrong execution, different types\n+    public static long test3(int i1, long i2) {\n+        Integer box1 = helper(i1);\n+        Long box2 = Long.valueOf(i2);\n+        fBox = Integer.valueOf(i1);\n+        return box1.intValue() + box2.longValue();\n+    }\n+\n+    \/\/ assert(i < _max) failed: oob: i=16, _max=16\n+    public static int test4(int i1, int i2) {\n+        Integer box1 = helper(i1);\n+        Integer box2 = helper(i2);\n+        fBox = Integer.valueOf(i1);\n+        return box1.intValue() + box2.intValue();\n+    }\n+\n+    public static Integer test5_helper(int i1, int i2) {\n+        Integer box1 = helper(i1);\n+        Integer box2 = helper(i2);\n+        fBox = Integer.valueOf(i1);\n+        return box1.intValue() + box2.intValue();\n+    }\n+\n+    \/\/ assert(local) failed: use _top instead of null\n+    \/\/ Variant with deeper inlining\n+    public static int test5(int i1, int i2) {\n+        return test5_helper(i1, i2);\n+    }\n+\n+    public static int test6_helper(int i1, int i2) {\n+        Integer box = helper(i1);\n+        fBox = Integer.valueOf(i2);\n+        return box.intValue();\n+    }\n+\n+    \/\/ Wrong execution, variant with more arguments\n+    public static int test6(int i1, int i2, int i3, int i4) {\n+        Integer box1 = helper(i1);\n+        Integer box2 = helper(i2);\n+        int res = test6_helper(i3, i4);\n+        res += box1.intValue() + box2.intValue();\n+        return res;\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Warmup\n+        for (int i = 0; i < 100_000; ++i) {\n+            int val = (i % 10);\n+            Asserts.assertEquals(test1(val), val);\n+            Asserts.assertEquals(fBox, val);\n+            Asserts.assertEquals(test2(val, val), 2*val);\n+            Asserts.assertEquals(fBox, val);\n+            Asserts.assertEquals(test3(val, val), 2L*val);\n+            Asserts.assertEquals(fBox, val);\n+            Asserts.assertEquals(test4(val, val), 2*val);\n+            Asserts.assertEquals(fBox, val);\n+            Asserts.assertEquals(test5(val, val), 2*val);\n+            Asserts.assertEquals(fBox, val);\n+            Asserts.assertEquals(test6(val, val, val, val), 3*val);\n+            Asserts.assertEquals(fBox, val);\n+        }\n+\n+        \/\/ Trigger deoptimization by choosing a value that does not\n+        \/\/ fit in the Integer cache and check the result.\n+        int val = 4000;\n+        Asserts.assertEquals(test1(val), val);\n+        switch (random.nextInt(3)) {\n+            case 0:\n+                Asserts.assertEquals(test2(val, 1), val + 1);\n+                Asserts.assertEquals(fBox, val);\n+                Asserts.assertEquals(test3(val, 1), (long)val + 1);\n+                Asserts.assertEquals(fBox, val);\n+                Asserts.assertEquals(test4(val, 1), val + 1);\n+                Asserts.assertEquals(fBox, val);\n+                Asserts.assertEquals(test5(val, 1), val + 1);\n+                Asserts.assertEquals(fBox, val);\n+                Asserts.assertEquals(test6(val, 1, 2, 3), val + 3);\n+                Asserts.assertEquals(fBox, 3);\n+                break;\n+           case 1:\n+                Asserts.assertEquals(test2(1, val), val + 1);\n+                Asserts.assertEquals(fBox, 1);\n+                Asserts.assertEquals(test3(1, val), (long)val + 1);\n+                Asserts.assertEquals(fBox, 1);\n+                Asserts.assertEquals(test4(1, val), val + 1);\n+                Asserts.assertEquals(fBox, 1);\n+                Asserts.assertEquals(test5(1, val), val + 1);\n+                Asserts.assertEquals(fBox, 1);\n+                Asserts.assertEquals(test6(1, val, 2, 3), val + 3);\n+                Asserts.assertEquals(fBox, 3);\n+                break;\n+           case 2:\n+                Asserts.assertEquals(test2(1, 2), 3);\n+                Asserts.assertEquals(fBox, 1);\n+                Asserts.assertEquals(test3(1, 2), 3L);\n+                Asserts.assertEquals(fBox, 1);\n+                Asserts.assertEquals(test4(1, 2), 3);\n+                Asserts.assertEquals(fBox, 1);\n+                Asserts.assertEquals(test5(1, 2), 3);\n+                Asserts.assertEquals(fBox, 1);\n+                Asserts.assertEquals(test6(1, 2, 3, val), 6);\n+                Asserts.assertEquals(fBox, val);\n+                break;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/eliminateAutobox\/TestSafepointDebugInfo.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -125,0 +125,1 @@\n+                    \"CompileThreshold\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.stream.Collectors;\n@@ -100,1 +101,2 @@\n-        String[] jtregVMFlags = Utils.getTestJavaOpts();\n+        \/\/ Ignore CompileCommand flags which have an impact on the profiling information.\n+        List<String> jtregVMFlags = Arrays.stream(Utils.getTestJavaOpts()).filter(s -> !s.contains(\"CompileThreshold\")).collect(Collectors.toList());\n@@ -102,1 +104,1 @@\n-            cmds.addAll(Arrays.asList(jtregVMFlags));\n+            cmds.addAll(jtregVMFlags);\n@@ -114,1 +116,1 @@\n-            cmds.addAll(Arrays.asList(jtregVMFlags));\n+            cmds.addAll(jtregVMFlags);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/TestVMProcess.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8275854\n+ * @summary Crashes in PhaseIdealLoop::transform_long_counted_loop\n+ * @requires vm.compiler2.enabled\n+ *\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=compileonly,TestLoopEndNodeEliminate::lMeth TestLoopEndNodeEliminate\n+ *\n+ *\/\n+\n+public class TestLoopEndNodeEliminate {\n+     public volatile boolean bFld=true;\n+     public volatile byte byFld=0;\n+     public volatile short sArrFld[]=new short[N];\n+     public int iArrFld[]=new int[N];\n+     public boolean bArrFld[]=new boolean[N];\n+\n+     public static int iFld=10;\n+     public static final int N = 400;\n+     public static long instanceCount=0L;\n+     public static long lMeth_check_sum = 0;\n+\n+     public long lMeth() {\n+         long l1=-33582180L;\n+         int i14=-5, i15=-14, i16=0, i17=25699, i18=97, i19=-3, i20=0, i21=0, i22=42, i23=0, i24=25699, i25=97;\n+\n+         for (l1 = 286; l1 > 16; l1 -= 3) {\n+             for (i15 = 17; i15 > l1; --i15) {\n+                 switch (((iArrFld[i15] >>> 1) % 7) + 101) {\n+                 case 101:\n+                 case 102:\n+                 case 103:\n+                 case 104:\n+                     for (i17 = (int)(l1); i17 < 1; i17++) {\n+                         bArrFld[i17] = bFld;\n+                     }\n+                     break;\n+                 case 105:\n+                 case 106:\n+                 case 107:\n+                 }\n+             }\n+             for (i19 = 1; i19 < 270; ++i19) {\n+                 TestLoopEndNodeEliminate.iFld += byFld;\n+                 i21 = 1;\n+                 while (++i21 < 2) {\n+                     bFld = true;\n+                 }\n+                 for (i22 = 1; 2 > i22; ++i22) {\n+                     bFld = true;\n+                 }\n+                 for (i24 = 1; 2 > i24; ++i24) {\n+                     bFld = true;\n+                 }\n+                 bArrFld[(int)(l1) % N] = bFld;\n+                 sArrFld[i19 - 1] ^= (short)(++TestLoopEndNodeEliminate.instanceCount);\n+             }\n+         }\n+         long meth_res = l1 + i14 + i15 + i16 + i17 + i18 + i19 + i20 + i21 + i22 + i23 + i24 + i25;\n+         lMeth_check_sum += meth_res;\n+         return (long)meth_res;\n+     }\n+\n+     public static void main(String[] strArr) {\n+        TestLoopEndNodeEliminate _instance = new TestLoopEndNodeEliminate();\n+        for (int i = 0; i < 10000; i++ ) {\n+            _instance.lMeth();\n+        }\n+     }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestLoopEndNodeEliminate.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8273277\n+ * @summary Skeleton predicates sometimes need to be negated\n+ * @run main compiler.loopopts.TestSkeletonPredicateNegation\n+ *\n+ *\/\n+\n+package compiler.loopopts;\n+\n+public class TestSkeletonPredicateNegation {\n+    public static int in0 = 2;\n+\n+    public static void main(String[] args) {\n+        try {\n+            TestSkeletonPredicateNegation instance = new TestSkeletonPredicateNegation();\n+            for (int i = 0; i < 10000; ++i) {\n+                instance.mainTest(args);\n+            }\n+        } catch (Exception ex) {\n+            System.out.println(ex.getClass().getCanonicalName());\n+        } catch (OutOfMemoryError e) {\n+            System.out.println(\"OOM Error\");\n+        }\n+    }\n+\n+    public void mainTest (String[] args){\n+        long loa11[] = new long[1987];\n+\n+        for (long lo14 : loa11) {\n+            TestSkeletonPredicateNegation.in0 = -128;\n+            for (int i18 = 0; i18 < 52; i18++) {\n+                try {\n+                    loa11[TestSkeletonPredicateNegation.in0] %= 2275269548L;\n+                    Math.ceil(1374905370.2785515599);\n+                } catch (Exception a_e) {\n+                    TestSkeletonPredicateNegation.in0--;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestSkeletonPredicateNegation.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2021, Amazon.com Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test TestOnSpinWaitAArch64\n+ * @summary Checks that java.lang.Thread.onSpinWait is intrinsified with instructions specified with '-XX:OnSpinWaitInst' and '-XX:OnSpinWaitInstCount'\n+ * @bug 8186670\n+ * @library \/test\/lib\n+ *\n+ * @requires vm.flagless\n+ * @requires os.arch==\"aarch64\"\n+ *\n+ * @run driver compiler.onSpinWait.TestOnSpinWaitAArch64 c2 nop 7\n+ * @run driver compiler.onSpinWait.TestOnSpinWaitAArch64 c2 isb 3\n+ * @run driver compiler.onSpinWait.TestOnSpinWaitAArch64 c2 yield 1\n+ * @run driver compiler.onSpinWait.TestOnSpinWaitAArch64 c1 nop 7\n+ * @run driver compiler.onSpinWait.TestOnSpinWaitAArch64 c1 isb 3\n+ * @run driver compiler.onSpinWait.TestOnSpinWaitAArch64 c1 yield\n+ *\/\n+\n+package compiler.onSpinWait;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.ListIterator;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestOnSpinWaitAArch64 {\n+    public static void main(String[] args) throws Exception {\n+        String compiler = args[0];\n+        String spinWaitInst = args[1];\n+        String spinWaitInstCount = (args.length == 3) ? args[2] : \"1\";\n+        ArrayList<String> command = new ArrayList<String>();\n+        command.add(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        command.add(\"-showversion\");\n+        command.add(\"-XX:-BackgroundCompilation\");\n+        command.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        command.add(\"-XX:+PrintAssembly\");\n+        if (compiler.equals(\"c2\")) {\n+            command.add(\"-XX:-TieredCompilation\");\n+        } else if (compiler.equals(\"c1\")) {\n+            command.add(\"-XX:+TieredCompilation\");\n+            command.add(\"-XX:TieredStopAtLevel=1\");\n+        } else {\n+            throw new RuntimeException(\"Unknown compiler: \" + compiler);\n+        }\n+        command.add(\"-Xbatch\");\n+        command.add(\"-XX:OnSpinWaitInst=\" + spinWaitInst);\n+        command.add(\"-XX:OnSpinWaitInstCount=\" + spinWaitInstCount);\n+        command.add(\"-XX:CompileCommand=compileonly,\" + Launcher.class.getName() + \"::\" + \"test\");\n+        command.add(Launcher.class.getName());\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(command);\n+\n+        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+\n+        analyzer.shouldHaveExitValue(0);\n+\n+        System.out.println(analyzer.getOutput());\n+\n+        checkOutput(analyzer, spinWaitInst, Integer.parseInt(spinWaitInstCount));\n+    }\n+\n+    private static String getSpinWaitInstHex(String spinWaitInst) {\n+      if (\"nop\".equals(spinWaitInst)) {\n+          return \"1f20 03d5\";\n+      } else if (\"isb\".equals(spinWaitInst)) {\n+          return \"df3f 03d5\";\n+      } else if (\"yield\".equals(spinWaitInst)) {\n+          return \"3f20 03d5\";\n+      } else {\n+          throw new RuntimeException(\"Unknown spin wait instruction: \" + spinWaitInst);\n+      }\n+    }\n+\n+    private static void addInstrs(String line, ArrayList<String> instrs) {\n+        for (String instr : line.split(\"\\\\|\")) {\n+            instrs.add(instr.trim());\n+        }\n+    }\n+\n+    \/\/ The expected output of PrintAssembly for example for a spin wait with three NOPs:\n+    \/\/\n+    \/\/ # {method} {0x0000ffff6ac00370} 'test' '()V' in 'compiler\/onSpinWait\/TestOnSpinWaitAArch64$Launcher'\n+    \/\/ #           [sp+0x40]  (sp of caller)\n+    \/\/ 0x0000ffff9d557680: 1f20 03d5 | e953 40d1 | 3f01 00f9 | ff03 01d1 | fd7b 03a9 | 1f20 03d5 | 1f20 03d5\n+    \/\/\n+    \/\/ 0x0000ffff9d5576ac: ;*invokestatic onSpinWait {reexecute=0 rethrow=0 return_oop=0}\n+    \/\/                     ; - compiler.onSpinWait.TestOnSpinWaitAArch64$Launcher::test@0 (line 161)\n+    \/\/ 0x0000ffff9d5576ac: 1f20 03d5 | fd7b 43a9 | ff03 0191\n+    \/\/\n+    \/\/ The checkOutput method adds hex instructions before 'invokestatic onSpinWait' and from the line after\n+    \/\/ it to a list. The list is traversed from the end to count spin wait instructions.\n+    \/\/\n+    \/\/ If JVM finds the hsdis library the output is like:\n+    \/\/\n+    \/\/ # {method} {0x0000ffff63000370} 'test' '()V' in 'compiler\/onSpinWait\/TestOnSpinWaitAArch64$Launcher'\n+    \/\/ #           [sp+0x20]  (sp of caller)\n+    \/\/ 0x0000ffffa409da80:   nop\n+    \/\/ 0x0000ffffa409da84:   sub sp, sp, #0x20\n+    \/\/ 0x0000ffffa409da88:   stp x29, x30, [sp, #16]         ;*synchronization entry\n+    \/\/                                                       ; - compiler.onSpinWait.TestOnSpinWaitAArch64$Launcher::test@-1 (line 187)\n+    \/\/ 0x0000ffffa409da8c:   nop\n+    \/\/ 0x0000ffffa409da90:   nop\n+    \/\/ 0x0000ffffa409da94:   nop\n+    \/\/ 0x0000ffffa409da98:   nop\n+    \/\/ 0x0000ffffa409da9c:   nop\n+    \/\/ 0x0000ffffa409daa0:   nop\n+    \/\/ 0x0000ffffa409daa4:   nop                                 ;*invokestatic onSpinWait {reexecute=0 rethrow=0 return_oop=0}\n+    \/\/                                                           ; - compiler.onSpinWait.TestOnSpinWaitAArch64$Launcher::test@0 (line 187)\n+    private static void checkOutput(OutputAnalyzer output, String spinWaitInst, int spinWaitInstCount) {\n+        Iterator<String> iter = output.asLines().listIterator();\n+\n+        String match = skipTo(iter, \"'test' '()V' in 'compiler\/onSpinWait\/TestOnSpinWaitAArch64$Launcher'\");\n+        if (match == null) {\n+            throw new RuntimeException(\"Missing compiler output for the method compiler.onSpinWait.TestOnSpinWaitAArch64$Launcher::test\");\n+        }\n+\n+        ArrayList<String> instrs = new ArrayList<String>();\n+        String line = null;\n+        boolean hasHexInstInOutput = false;\n+        while (iter.hasNext()) {\n+            line = iter.next();\n+            if (line.contains(\"*invokestatic onSpinWait\")) {\n+                break;\n+            }\n+            if (!hasHexInstInOutput) {\n+                hasHexInstInOutput = line.contains(\"|\");\n+            }\n+            if (line.contains(\"0x\") && !line.contains(\";\")) {\n+                addInstrs(line, instrs);\n+            }\n+        }\n+\n+        if (!iter.hasNext() || !iter.next().contains(\"- compiler.onSpinWait.TestOnSpinWaitAArch64$Launcher::test@0\") || !iter.hasNext()) {\n+            throw new RuntimeException(\"Missing compiler output for Thread.onSpinWait intrinsic\");\n+        }\n+\n+        String strToSearch = null;\n+        if (!hasHexInstInOutput) {\n+            instrs.add(line.split(\";\")[0].trim());\n+            strToSearch = spinWaitInst;\n+        } else {\n+            line = iter.next();\n+            if (!line.contains(\"0x\") || line.contains(\";\")) {\n+                throw new RuntimeException(\"Expected hex instructions\");\n+            }\n+\n+            addInstrs(line, instrs);\n+            strToSearch = getSpinWaitInstHex(spinWaitInst);\n+        }\n+\n+        int foundInstCount = 0;\n+\n+        ListIterator<String> instrReverseIter = instrs.listIterator(instrs.size());\n+        while (instrReverseIter.hasPrevious()) {\n+            if (instrReverseIter.previous().endsWith(strToSearch)) {\n+                foundInstCount = 1;\n+                break;\n+            }\n+        }\n+\n+        while (instrReverseIter.hasPrevious()) {\n+            if (!instrReverseIter.previous().endsWith(strToSearch)) {\n+                break;\n+            }\n+            ++foundInstCount;\n+        }\n+\n+        if (foundInstCount != spinWaitInstCount) {\n+            throw new RuntimeException(\"Wrong instruction \" + strToSearch + \" count \" + foundInstCount + \"!\\n  -- expecting \" + spinWaitInstCount);\n+        }\n+    }\n+\n+    private static String skipTo(Iterator<String> iter, String substring) {\n+        while (iter.hasNext()) {\n+            String nextLine = iter.next();\n+            if (nextLine.contains(substring)) {\n+                return nextLine;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    static class Launcher {\n+        public static void main(final String[] args) throws Exception {\n+            int end = 20_000;\n+\n+            for (int i=0; i < end; i++) {\n+                test();\n+            }\n+        }\n+        static void test() {\n+            java.lang.Thread.onSpinWait();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/onSpinWait\/TestOnSpinWaitAArch64.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2021, Amazon.com Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test TestOnSpinWaitNoneAArch64\n+ * @summary Checks that java.lang.Thread.onSpinWait is not intrinsified when '-XX:OnSpinWaitInst=none' is used\n+ * @bug 8186670\n+ * @library \/test\/lib\n+ *\n+ * @requires vm.flagless\n+ * @requires os.arch==\"aarch64\"\n+ *\n+ * @run driver compiler.onSpinWait.TestOnSpinWaitNoneAArch64\n+ *\/\n+\n+package compiler.onSpinWait;\n+\n+import java.util.ArrayList;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestOnSpinWaitNoneAArch64 {\n+\n+    public static void main(String[] args) throws Exception {\n+        ArrayList<String> command = new ArrayList<String>();\n+        command.add(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        command.add(\"-showversion\");\n+        command.add(\"-XX:-TieredCompilation\");\n+        command.add(\"-Xbatch\");\n+        command.add(\"-XX:+PrintCompilation\");\n+        command.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        command.add(\"-XX:+PrintInlining\");\n+        command.add(\"-XX:OnSpinWaitInst=none\");\n+        command.add(Launcher.class.getName());\n+\n+        \/\/ Test C2 compiler\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(command);\n+\n+        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+\n+        analyzer.shouldHaveExitValue(0);\n+\n+        \/\/ The test is applicable only to C2 (present in Server VM).\n+        if (analyzer.getStderr().contains(\"Server VM\")) {\n+            analyzer.shouldNotContain(\"java.lang.Thread::onSpinWait (1 bytes)   (intrinsic)\");\n+        }\n+    }\n+\n+    static class Launcher {\n+\n+        public static void main(final String[] args) throws Exception {\n+            int end = 20_000;\n+\n+            for (int i=0; i < end; i++) {\n+                test();\n+            }\n+        }\n+        static void test() {\n+            java.lang.Thread.onSpinWait();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/onSpinWait\/TestOnSpinWaitNoneAArch64.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- * @test TestSystemGCSerial\n+ * @test id=Serial\n@@ -31,0 +31,1 @@\n+ * @run main\/othervm -XX:+UseSerialGC -XX:+UseLargePages gc.TestSystemGC\n@@ -34,1 +35,1 @@\n- * @test TestSystemGCParallel\n+ * @test id=Parallel\n@@ -38,0 +39,1 @@\n+ * @run main\/othervm -XX:+UseParallelGC -XX:+UseLargePages gc.TestSystemGC\n@@ -41,1 +43,1 @@\n- * @test TestSystemGCG1\n+ * @test id=G1\n@@ -46,0 +48,1 @@\n+ * @run main\/othervm -XX:+UseG1GC -XX:+UseLargePages gc.TestSystemGC\n@@ -49,1 +52,1 @@\n- * @test TestSystemGCShenandoah\n+ * @test id=Shenandoah\n@@ -52,2 +55,3 @@\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC gc.TestSystemGC\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:+ExplicitGCInvokesConcurrent gc.TestSystemGC\n+ * @run main\/othervm -XX:+UseShenandoahGC gc.TestSystemGC\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+ExplicitGCInvokesConcurrent gc.TestSystemGC\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseLargePages gc.TestSystemGC\n@@ -57,1 +61,4 @@\n- * @test TestSystemGCLargePages\n+ * @test id=Z\n+ * @requires vm.gc.Z\n+ * @comment ZGC will not start when LargePages cannot be allocated, therefore\n+ *          we do not run such configuration.\n@@ -59,1 +66,1 @@\n- * @run main\/othervm -XX:+UseLargePages gc.TestSystemGC\n+ * @run main\/othervm -XX:+UseZGC gc.TestSystemGC\n","filename":"test\/hotspot\/jtreg\/gc\/TestSystemGC.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,1 @@\n-            C = new Clazz(getPackageName(packageId) + \"Helper\", -1, ACC_PUBLIC);\n+            C = new Clazz(getPackageName(packageId) + \"Helper\", ACC_PUBLIC, -1);\n","filename":"test\/hotspot\/jtreg\/runtime\/SelectionResolution\/classes\/selectionresolution\/ClassBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-        super(name, extending == null ? \"java\/lang\/Object\" : extending, access + ACC_SUPER, classFileVersion, index, implementing);\n+        super(name, extending == null ? \"java\/lang\/Object\" : extending, access | ACC_SUPER, classFileVersion, index, implementing);\n","filename":"test\/hotspot\/jtreg\/runtime\/SelectionResolution\/classes\/selectionresolution\/Clazz.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-        testClass = new Clazz(\"Test\", null, -1, ACC_PUBLIC);\n+        testClass = new Clazz(\"Test\", null, ACC_PUBLIC, -1);\n","filename":"test\/hotspot\/jtreg\/runtime\/SelectionResolution\/classes\/selectionresolution\/TestBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -225,9 +225,9 @@\n-        \/\/ modify _base_archive_path_offet to non-zero\n-        System.out.println(\"\\n8. modify _base_archive_path_offset to non-zero\\n\");\n-        String baseArchivePathOffsetName = startNewArchive(\"base-arhive-path-offset\");\n-        copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, baseArchivePathOffsetName);\n-        int baseArchivePathOffset = CDSArchiveUtils.baseArchivePathOffset(copiedJsa);\n-        System.out.println(\"    baseArchivePathOffset = \" + baseArchivePathOffset);\n-        CDSArchiveUtils.writeData(copiedJsa, CDSArchiveUtils.offsetBaseArchivePathOffset(), 1024);\n-        baseArchivePathOffset = CDSArchiveUtils.baseArchivePathOffset(copiedJsa);\n-        System.out.println(\"new baseArchivePathOffset = \" + baseArchivePathOffset);\n+        \/\/ modify _base_archive_name_offet to non-zero\n+        System.out.println(\"\\n8. modify _base_archive_name_offset to non-zero\\n\");\n+        String baseArchiveNameOffsetName = startNewArchive(\"base-arhive-path-offset\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, baseArchiveNameOffsetName);\n+        int baseArchiveNameOffset = CDSArchiveUtils.baseArchiveNameOffset(copiedJsa);\n+        System.out.println(\"    baseArchiveNameOffset = \" + baseArchiveNameOffset);\n+        CDSArchiveUtils.writeData(copiedJsa, CDSArchiveUtils.offsetBaseArchiveNameOffset(), 1024);\n+        baseArchiveNameOffset = CDSArchiveUtils.baseArchiveNameOffset(copiedJsa);\n+        System.out.println(\"new baseArchiveNameOffset = \" + baseArchiveNameOffset);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SharedArchiveConsistency.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-               new String[] {\"_header_size should be equal to _base_archive_path_offset plus _base_archive_name_size\",\n+               new String[] {\"_header_size should be equal to _base_archive_name_offset plus _base_archive_name_size\",\n@@ -120,2 +120,2 @@\n-        String wrongBaseArchivePathOffset = getNewArchiveName(\"wrongBaseArchivePathOffset\");\n-        copiedJsa = CDSArchiveUtils.copyArchiveFile(jsa, wrongBaseArchivePathOffset);\n+        String wrongBaseArchiveNameOffset = getNewArchiveName(\"wrongBaseArchiveNameOffset\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(jsa, wrongBaseArchiveNameOffset);\n@@ -123,3 +123,3 @@\n-        int baseArchivePathOffset = CDSArchiveUtils.baseArchivePathOffset(copiedJsa);\n-        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetBaseArchivePathOffset(), baseArchivePathOffset + 1024);\n-        runTwo(baseArchiveName, wrongBaseArchivePathOffset,\n+        int baseArchiveNameOffset = CDSArchiveUtils.baseArchiveNameOffset(copiedJsa);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetBaseArchiveNameOffset(), baseArchiveNameOffset + 1024);\n+        runTwo(baseArchiveName, wrongBaseArchiveNameOffset,\n@@ -127,1 +127,1 @@\n-               new String[] {\"_header_size should be equal to _base_archive_path_offset plus _base_archive_name_size\",\n+               new String[] {\"_header_size should be equal to _base_archive_name_offset plus _base_archive_name_size\",\n@@ -133,2 +133,2 @@\n-        String wrongBasePathOffset = getNewArchiveName(\"wrongBasePathOffset\");\n-        copiedJsa = CDSArchiveUtils.copyArchiveFile(jsa, wrongBasePathOffset);\n+        String wrongBaseNameOffset = getNewArchiveName(\"wrongBaseNameOffset\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(jsa, wrongBaseNameOffset);\n@@ -136,4 +136,4 @@\n-        baseArchivePathOffset = CDSArchiveUtils.baseArchivePathOffset(copiedJsa);\n-        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, baseArchivePathOffset,\n-                                             baseArchivePathOffset + baseArchiveNameSize\/2);\n-        runTwo(baseArchiveName, wrongBasePathOffset,\n+        baseArchiveNameOffset = CDSArchiveUtils.baseArchiveNameOffset(copiedJsa);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, baseArchiveNameOffset,\n+                                             baseArchiveNameOffset + baseArchiveNameSize\/2);\n+        runTwo(baseArchiveName, wrongBaseNameOffset,\n@@ -144,0 +144,1 @@\n+\n@@ -148,1 +149,1 @@\n-        baseArchivePathOffset = CDSArchiveUtils.baseArchivePathOffset(copiedJsa);\n+        baseArchiveNameOffset = CDSArchiveUtils.baseArchiveNameOffset(copiedJsa);\n@@ -150,1 +151,1 @@\n-        long offset = baseArchivePathOffset + baseArchiveNameSize - 1;  \/\/ end of line\n+        long offset = baseArchiveNameOffset + baseArchiveNameSize - 1;  \/\/ end of line\n@@ -155,2 +156,19 @@\n-               new String[] {\"Base archive \" + baseArchiveName,\n-                             \" does not exist\",\n+               new String[] {\"Base archive name is damaged\",\n+                             \"Header checksum verification failed\"});\n+\n+        \/\/ 6. Modify base archive name to a file that doesn't exist.\n+        System.out.println(\"\\n6. Modify base archive name to a file that doesn't exist\");\n+        String wrongBaseName2 = getNewArchiveName(\"wrongBaseName2\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(jsa, wrongBaseName2);\n+        baseArchiveNameOffset = CDSArchiveUtils.baseArchiveNameOffset(copiedJsa);\n+        baseArchiveNameSize = CDSArchiveUtils.baseArchiveNameSize(copiedJsa);\n+        offset = baseArchiveNameOffset + baseArchiveNameSize - 2;  \/\/ the \"a\" in \".jsa\"\n+        CDSArchiveUtils.writeData(copiedJsa, offset, new byte[] {(byte)'b'}); \/\/ .jsa -> .jsb\n+\n+        \/\/ Make sure it doesn't exist\n+        String badName = baseArchiveName.replace(\".jsa\", \".jsb\");\n+        (new File(badName)).delete();\n+\n+        runTwo(baseArchiveName, wrongBaseName2,\n+               appJar, mainClass, 1,\n+               new String[] {\"Base archive \" + badName + \" does not exist\",\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/ArchiveConsistency.java","additions":35,"deletions":17,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.driver.IRViolationException;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8276546\n+ * @requires vm.debug == true & vm.compMode != \"Xint\" & vm.compMode != \"Xcomp\" & vm.compiler1.enabled & vm.compiler2.enabled & vm.flagless\n+ * @summary Test that CompileThreshold flag is ignored when passed as Java\/VM option to the framework.\n+ *          Normally, the framework should be called with driver.\n+ * @library \/test\/lib \/testlibrary_tests \/\n+ * @run main\/othervm -XX:CompileThreshold=12 -XX:+UseG1GC ir_framework.tests.TestCompileThreshold\n+ *\/\n+\n+public class TestCompileThreshold {\n+    public int iFld = 0;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            \/\/ CompileThreshold=12 passed to the JTreg test is ignored even though we prefer command line flags.\n+            \/\/ CompileThreshold=10 is user defined and passed directly to the framework and thus not ignored.\n+            \/\/ InterpreterProfilePercentage=0 ensures that we compile exactly after 10 invocations.\n+            TestFramework.runWithFlags(\"-XX:CompileThreshold=10\", \"-XX:InterpreterProfilePercentage=0\",\n+                                       \"-XX:-TieredCompilation\", \"-DTest=testWithCompileThreshold\",\n+                                       \"-DPreferCommandLineFlags=true\");\n+        } catch (IRViolationException e) {\n+            Asserts.assertTrue(e.getExceptionInfo().contains(\"Failed IR Rules (1)\"), \"exactly one rule failed\");\n+            Asserts.assertTrue(e.getExceptionInfo().contains(\"testWithCompileThreshold()\"),\n+                               \"testWithCompileThreshold() failed\");\n+        }\n+\n+        try {\n+            TestFramework.runWithFlags(\"-XX:InterpreterProfilePercentage=0\", \"-XX:-TieredCompilation\",\n+                                       \"-DTest=testWithoutCompileThreshold\");\n+        } catch (IRViolationException e) {\n+            Asserts.assertTrue(e.getExceptionInfo().contains(\"Failed IR Rules (1)\"), \"exactly one rule failed\");\n+            Asserts.assertTrue(e.getExceptionInfo().contains(\"testWithoutCompileThreshold()\"),\n+                               \"testWithoutCompileThreshold() failed\");\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CALL, \"1\"}) \/\/ fails\n+    public void testWithCompileThreshold() {\n+        iFld++;\n+    }\n+\n+    @Run(test = \"testWithCompileThreshold\")\n+    @Warmup(20)\n+    public void runTestWithCompileThreshold(RunInfo info) {\n+        if (iFld == 10) {\n+            TestFramework.assertNotCompiled(info.getTest());\n+        } else if (iFld == 11) {\n+            \/\/ CompileThreshold=10 is passed directly as a flag to the framework.\n+            \/\/ Therefore, testWithCompileThreshold() must be compiled by now.\n+            TestFramework.assertCompiled(info.getTest());\n+        }\n+        testWithCompileThreshold();\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.CALL, \"1\"}) \/\/ fails\n+    public void testWithoutCompileThreshold() {\n+        iFld++;\n+    }\n+\n+    @Run(test = \"testWithoutCompileThreshold\")\n+    @Warmup(20)\n+    public void runTestWithoutCompileThreshold(RunInfo info) {\n+        testWithCompileThreshold();\n+        if (info.isWarmUp()) {\n+            \/\/ CompileThreshold=12 is passed to the JTreg test but not directly to the framework.\n+            \/\/ Therefore, it is ignored and we do not trigger a compilation until the framework does.\n+            TestFramework.assertNotCompiled(info.getTest());\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestCompileThreshold.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8273277\n@@ -33,0 +34,1 @@\n+ * @run main\/othervm -XX:-OmitStackTraceInFastThrow -Xbatch -XX:Tier0BackedgeNotifyFreqLog=0 -XX:Tier2BackedgeNotifyFreqLog=0 -XX:Tier3BackedgeNotifyFreqLog=0 -XX:Tier2BackEdgeThreshold=1 -XX:Tier3BackEdgeThreshold=1 -XX:Tier4BackEdgeThreshold=1 jit.t.t105.t105\n@@ -34,1 +36,1 @@\n- * This test must be run with ProfileTraps disabled to avoid preallocated\n+ * This test must be run with OmitStackTraceInFastThrow disabled to avoid preallocated\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/jit\/t\/t105\/t105.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-java\/awt\/Frame\/FrameLocation\/FrameLocation.java 8233703 linux-all\n+java\/awt\/Frame\/FrameLocation\/FrameLocation.java 8238436 linux-all\n@@ -148,1 +148,0 @@\n-java\/awt\/KeyboardFocusmanager\/TypeAhead\/TestDialogTypeAhead.java 8198626 macosx-all\n@@ -192,1 +191,1 @@\n-java\/awt\/EventDispatchThread\/HandleExceptionOnEDT\/HandleExceptionOnEDT.java 8203047 macosx-all\n+java\/awt\/EventDispatchThread\/HandleExceptionOnEDT\/HandleExceptionOnEDT.java 8072110 macosx-all\n@@ -207,1 +206,1 @@\n-java\/awt\/GridLayout\/LayoutExtraGaps\/LayoutExtraGaps.java 8000171 windows-all\n+java\/awt\/GridLayout\/LayoutExtraGaps\/LayoutExtraGaps.java 8196100 windows-all\n@@ -254,1 +253,1 @@\n-java\/awt\/FullScreen\/DisplayChangeVITest\/DisplayChangeVITest.java 8169469,8273618 windows-all,macosx-aarch64\n+java\/awt\/FullScreen\/DisplayChangeVITest\/DisplayChangeVITest.java 8169469,8273617 windows-all,macosx-aarch64\n@@ -258,1 +257,1 @@\n-java\/awt\/Choice\/ChoiceMouseWheelTest\/ChoiceMouseWheelTest.java 7100044 macosx-all,linux-all\n+java\/awt\/Choice\/ChoiceMouseWheelTest\/ChoiceMouseWheelTest.java 6849371 macosx-all,linux-all\n@@ -262,1 +261,1 @@\n-java\/awt\/Frame\/MiscUndecorated\/RepaintTest.java 8079267,8266244 windows-all,linux-all,macosx-aarch64\n+java\/awt\/Frame\/MiscUndecorated\/RepaintTest.java 8266244 macosx-aarch64\n@@ -555,5 +554,0 @@\n-java\/lang\/management\/MemoryMXBean\/Pending.java                  8158837 generic-all\n-java\/lang\/management\/MemoryMXBean\/PendingAllGC.sh               8158837 generic-all\n-\n-javax\/management\/monitor\/DerivedGaugeMonitorTest.java         8042211 generic-all\n-\n@@ -574,0 +568,2 @@\n+java\/lang\/management\/MemoryMXBean\/Pending.java                  8158837 generic-all\n+java\/lang\/management\/MemoryMXBean\/PendingAllGC.sh               8158837 generic-all\n@@ -586,0 +582,2 @@\n+javax\/management\/monitor\/DerivedGaugeMonitorTest.java           8042211 generic-all\n+\n@@ -759,2 +757,0 @@\n-tools\/jlink\/JLinkReproducibleTest.java                          8217166 windows-all,linux-aarch64\n-tools\/jlink\/JLinkReproducible3Test.java                         8253688 linux-aarch64\n@@ -794,1 +790,1 @@\n-sun\/tools\/jhsdb\/BasicLauncherTest.java                          8211767 linux-ppc64,linux-ppc64le\n+sun\/tools\/jhsdb\/BasicLauncherTest.java                          8228649 linux-ppc64,linux-ppc64le\n@@ -817,2 +813,2 @@\n-jdk\/jfr\/event\/runtime\/TestNetworkUtilizationEvent.java          8228990,8229370    generic-all\n-jdk\/jfr\/event\/compiler\/TestCodeSweeper.java                     8225209    generic-all\n+jdk\/jfr\/event\/runtime\/TestNetworkUtilizationEvent.java          8228990 generic-all\n+jdk\/jfr\/event\/compiler\/TestCodeSweeper.java                     8225209 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n-import java.security.*;\n@@ -43,0 +42,1 @@\n+import java.util.concurrent.Callable;\n@@ -87,2 +87,2 @@\n-            Subject.doAs(clntSubj, new PrivilegedExceptionAction() {\n-                public Object run() throws Exception {\n+            Subject.callAs(clntSubj, new Callable<>() {\n+                public Object call() throws Exception {\n@@ -100,2 +100,2 @@\n-            Subject.doAs(srvSubj, new PrivilegedExceptionAction() {\n-                public Object run() throws Exception {\n+            Subject.callAs(srvSubj, new Callable<Object>() {\n+                public Object call() throws Exception {\n@@ -120,5 +120,2 @@\n-        response = (byte[]) Subject.doAs(clntSubj,\n-            new PrivilegedExceptionAction() {\n-            public Object run() throws Exception {\n-                return (clnt.hasInitialResponse()? clnt.evaluateChallenge(EMPTY) : EMPTY);\n-            }});\n+        response = (byte[]) Subject.callAs(clntSubj,\n+                () -> (clnt.hasInitialResponse()? clnt.evaluateChallenge(EMPTY) : EMPTY));\n@@ -128,5 +125,2 @@\n-            challenge = (byte[]) Subject.doAs(srvSubj,\n-                new PrivilegedExceptionAction() {\n-                public Object run() throws Exception {\n-                    return srv.evaluateResponse(responseCopy);\n-                }});\n+            challenge = (byte[]) Subject.callAs(srvSubj,\n+                    () -> srv.evaluateResponse(responseCopy));\n@@ -136,5 +130,2 @@\n-                response = (byte[]) Subject.doAs(clntSubj,\n-                    new PrivilegedExceptionAction() {\n-                    public Object run() throws Exception {\n-                        return clnt.evaluateChallenge(challengeCopy);\n-                    }});\n+                response = (byte[]) Subject.callAs(clntSubj,\n+                        () -> clnt.evaluateChallenge(challengeCopy));\n","filename":"test\/jdk\/com\/sun\/security\/sasl\/gsskerb\/AuthOnly.java","additions":12,"deletions":21,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import java.security.*;\n@@ -88,3 +87,1 @@\n-            Subject.doAs(clntSubj, new PrivilegedExceptionAction() {\n-                public Object run() throws Exception {\n-                    return Sasl.createSaslClient(\n+            Subject.callAs(clntSubj, () ->Sasl.createSaslClient(\n@@ -92,3 +89,1 @@\n-                        clntprops, null);\n-                }\n-            });\n+                        clntprops, null));\n@@ -101,6 +96,3 @@\n-            Subject.doAs(srvSubj, new PrivilegedExceptionAction() {\n-                public Object run() throws Exception {\n-                    return Sasl.createSaslServer(MECH, PROTOCOL, SERVER_FQDN,\n-                        srvprops, srvCbh);\n-                }\n-            });\n+            Subject.callAs(srvSubj, () ->\n+                    Sasl.createSaslServer(MECH, PROTOCOL, SERVER_FQDN,\n+                        srvprops, srvCbh));\n@@ -121,5 +113,2 @@\n-        response = (byte[]) Subject.doAs(clntSubj,\n-            new PrivilegedExceptionAction() {\n-            public Object run() throws Exception {\n-                return (clnt.hasInitialResponse()? clnt.evaluateChallenge(EMPTY) : EMPTY);\n-            }});\n+        response = Subject.callAs(clntSubj,\n+                () -> (clnt.hasInitialResponse()? clnt.evaluateChallenge(EMPTY) : EMPTY));\n@@ -129,5 +118,2 @@\n-            challenge = (byte[]) Subject.doAs(srvSubj,\n-                new PrivilegedExceptionAction() {\n-                public Object run() throws Exception {\n-                    return srv.evaluateResponse(responseCopy);\n-                }});\n+            challenge = Subject.callAs(srvSubj,\n+                    () -> srv.evaluateResponse(responseCopy));\n@@ -137,5 +123,2 @@\n-                response = (byte[]) Subject.doAs(clntSubj,\n-                    new PrivilegedExceptionAction() {\n-                    public Object run() throws Exception {\n-                        return clnt.evaluateChallenge(challengeCopy);\n-                    }});\n+                response = Subject.callAs(clntSubj,\n+                        () -> clnt.evaluateChallenge(challengeCopy));\n","filename":"test\/jdk\/com\/sun\/security\/sasl\/gsskerb\/ConfSecurityLayer.java","additions":12,"deletions":29,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import java.security.*;\n@@ -87,4 +86,3 @@\n-        final SaslClient clnt = (SaslClient)\n-            Subject.doAs(clntSubj, new PrivilegedExceptionAction() {\n-                public Object run() throws Exception {\n-                    return Sasl.createSaslClient(\n+        final SaslClient clnt =\n+            Subject.callAs(clntSubj, () ->\n+                    Sasl.createSaslClient(\n@@ -92,3 +90,1 @@\n-                        clntprops, null);\n-                }\n-            });\n+                        clntprops, null));\n@@ -100,7 +96,4 @@\n-        final SaslServer srv = (SaslServer)\n-            Subject.doAs(srvSubj, new PrivilegedExceptionAction() {\n-                public Object run() throws Exception {\n-                    return Sasl.createSaslServer(MECH, PROTOCOL, SERVER_FQDN,\n-                        srvprops, srvCbh);\n-                }\n-            });\n+        final SaslServer srv =\n+            Subject.callAs(srvSubj, () ->\n+                Sasl.createSaslServer(MECH, PROTOCOL, SERVER_FQDN,\n+                        srvprops, srvCbh));\n@@ -121,5 +114,2 @@\n-        response = (byte[]) Subject.doAs(clntSubj,\n-            new PrivilegedExceptionAction() {\n-            public Object run() throws Exception {\n-                return (clnt.hasInitialResponse()? clnt.evaluateChallenge(EMPTY) : EMPTY);\n-            }});\n+        response = Subject.callAs(clntSubj,\n+                () -> (clnt.hasInitialResponse()? clnt.evaluateChallenge(EMPTY) : EMPTY));\n@@ -129,5 +119,2 @@\n-            challenge = (byte[]) Subject.doAs(srvSubj,\n-                new PrivilegedExceptionAction() {\n-                public Object run() throws Exception {\n-                    return srv.evaluateResponse(responseCopy);\n-                }});\n+            challenge = Subject.callAs(srvSubj,\n+                    () -> srv.evaluateResponse(responseCopy));\n@@ -137,5 +124,2 @@\n-                response = (byte[]) Subject.doAs(clntSubj,\n-                    new PrivilegedExceptionAction() {\n-                    public Object run() throws Exception {\n-                        return clnt.evaluateChallenge(challengeCopy);\n-                    }});\n+                response = Subject.callAs(clntSubj,\n+                        () -> clnt.evaluateChallenge(challengeCopy));\n","filename":"test\/jdk\/com\/sun\/security\/sasl\/gsskerb\/NoSecurityLayer.java","additions":15,"deletions":31,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,11 @@\n-import java.awt.*;\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.TextField;\n+import java.awt.Toolkit;\n@@ -42,2 +52,3 @@\n-import java.io.*;\n-import java.awt.image.*;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.PixelGrabber;\n+import java.io.File;\n@@ -46,1 +57,1 @@\n-    private static int delay = 150;\n+    private static final int delay = 150;\n@@ -53,1 +64,1 @@\n-    private Object buttonLock = new Object();\n+    private final Object buttonLock = new Object();\n@@ -56,1 +67,1 @@\n-    private int MAX_TOLERANCE_LEVEL = 10;\n+    private final int MAX_TOLERANCE_LEVEL = 10;\n@@ -84,19 +95,0 @@\n-    \/**\n-     * Do screen capture and save it as image\n-     *\/\n-    private static void captureScreenAndSave() {\n-\n-        try {\n-            Robot robot = new Robot();\n-            Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n-            Rectangle rectangle = new Rectangle(0, 0, screenSize.width, screenSize.height);\n-            System.out.println(\"About to screen capture - \" + rectangle);\n-            BufferedImage image = robot.createScreenCapture(rectangle);\n-            javax.imageio.ImageIO.write(image, \"jpg\", new File(\"ScreenImage.jpg\"));\n-            robot.delay(3000);\n-        } catch (Throwable t) {\n-            System.out.println(\"WARNING: Exception thrown while screen capture!\");\n-            t.printStackTrace();\n-        }\n-    }\n-\n@@ -118,0 +110,1 @@\n+        frame.setLocationRelativeTo(null);\n@@ -121,1 +114,0 @@\n-        frame.toFront();\n@@ -139,1 +131,1 @@\n-        }else {\n+        } else {\n@@ -178,0 +170,2 @@\n+\n+        robot.click();\n@@ -179,3 +173,0 @@\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n-        robot.waitForIdle(delay);\n-        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n@@ -233,1 +224,0 @@\n-                    frame.toFront();\n","filename":"test\/jdk\/java\/awt\/Frame\/MiscUndecorated\/RepaintTest.java","additions":22,"deletions":32,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,3 +29,0 @@\n-  @library    ..\/..\/regtesthelpers\n-  @modules java.desktop\/sun.awt\n-  @build      Util\n@@ -35,2 +32,20 @@\n-import java.awt.*;\n-import java.awt.event.*;\n+\n+import java.awt.AWTEvent;\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.DefaultKeyboardFocusManager;\n+import java.awt.Dialog;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.KeyboardFocusManager;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.KeyAdapter;\n+import java.awt.event.KeyEvent;\n@@ -52,2 +67,11 @@\n-        app.init();\n-        app.start();\n+        try {\n+            app.init();\n+            app.start();\n+        } finally {\n+            if (d != null) {\n+                d.dispose();\n+            }\n+            if (f != null) {\n+                f.dispose();\n+            }\n+        }\n@@ -76,2 +100,0 @@\n-                    d.dispose();\n-                    f.dispose();\n@@ -83,0 +105,1 @@\n+\n@@ -115,0 +138,1 @@\n+            robot.setAutoDelay(100);\n@@ -131,0 +155,1 @@\n+\n@@ -152,1 +177,0 @@\n-\n@@ -155,1 +179,1 @@\n-    private void moveMouseOver(Container c) {\n+    private void moveMouseOver(Component c) {\n@@ -158,1 +182,2 @@\n-        robot.mouseMove(p.x + (int)(d.getWidth()\/2), p.y + (int)(d.getHeight()\/2));\n+        robot.mouseMove(p.x + (int)(d.getWidth()\/2),\n+                p.y + (int)(d.getHeight()\/2));\n@@ -212,1 +237,4 @@\n-            throw new RuntimeException(\"Can't make \" + comp + \" focused, current owner is \" + KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner());\n+            throw new RuntimeException(\"Can't make \" + comp + \" focused,\"\n+                    + \"current owner is \"\n+                    + KeyboardFocusManager\n+                    .getCurrentKeyboardFocusManager().getFocusOwner());\n@@ -260,1 +288,0 @@\n-\n","filename":"test\/jdk\/java\/awt\/KeyboardFocusmanager\/TypeAhead\/TestDialogTypeAhead.java","additions":42,"deletions":15,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @run main\/othervm -Djava.security.manager=allow CheckPrivilege\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/CheckPrivilege.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,1 +52,2 @@\n-            rt.exec(\"no-such-file\");\n+            String[] cmd = {\"no-such-file\"};\n+            rt.exec(cmd);\n@@ -57,1 +58,2 @@\n-            rt.exec(\".\");\n+            String[] cmd = {\".\"};\n+            rt.exec(cmd);\n@@ -62,1 +64,2 @@\n-            rt.exec(TrueCommand, null, new File(\"no-such-dir\"));\n+            String[] cmd = {TrueCommand};\n+            rt.exec(cmd, null, new File(\"no-such-dir\"));\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/Zombies.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+    @SuppressWarnings(\"deprecation\")\n","filename":"test\/jdk\/java\/lang\/RuntimeTests\/exec\/BadEnvp.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4750978\n- * @run main\/othervm\/timeout=300 ExecWithDir\n- * @summary Ensure that we can fork-and-exec repeatedly when a new working\n- *          directory is specified\n- *\/\n-\n-import java.io.File;\n-\n-public class ExecWithDir {\n-\n-    private static final int N = 500;\n-\n-    public static void main(String args[]) throws Exception {\n-        if (! UnixCommands.isUnix) {\n-            System.out.println(\"For UNIX only\");\n-            return;\n-        }\n-        UnixCommands.ensureCommandsAvailable(\"true\");\n-\n-        final String trueCmd = UnixCommands.findCommand(\"true\");\n-        File dir = new File(\".\");\n-        for (int i = 1; i <= N; i++) {\n-            System.out.print(i);\n-            System.out.print(\" e\");\n-            Process p = Runtime.getRuntime().exec(trueCmd, null, dir);\n-            System.out.print('w');\n-            int s = p.waitFor();\n-            System.out.println(\"x \" + s);\n-            if (s != 0) throw new Error(\"Unexpected return code \" + s);\n-\n-            \/\/ Avoid \"Too many open files\"\n-            p.getInputStream().close();\n-            p.getOutputStream().close();\n-            p.getErrorStream().close();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/RuntimeTests\/exec\/ExecWithDir.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -65,0 +65,1 @@\n+        @SuppressWarnings(\"deprecation\")\n","filename":"test\/jdk\/java\/lang\/RuntimeTests\/exec\/SetCwd.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,0 +151,3 @@\n+            { \"1.0-1.1\",       \"1.0-1..1\" },\n+            { \"1.0-1+1\",       \"1.0-1.+1\" },\n+            { \"1.0-1+1.1\",     \"1.0-1+1..1\" },\n","filename":"test\/jdk\/java\/lang\/module\/VersionTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import impl.SimpleResolverProviderImpl;\n+\n+\n+\/*\n+ * @test\n+ * @summary Test that InetAddress caching security properties work as expected\n+ *  when a custom resolver is installed.\n+ * @library lib providers\/simple\n+ * @build test.library\/testlib.ResolutionRegistry\n+ *  simple.provider\/impl.SimpleResolverProviderImpl AddressesCachingTest\n+ * @run testng\/othervm -Djava.security.properties=${test.src}\/NeverCache.props\n+ *  -Dtest.cachingDisabled=true AddressesCachingTest\n+ * @run testng\/othervm -Djava.security.properties=${test.src}\/ForeverCache.props\n+ *  -Dtest.cachingDisabled=false AddressesCachingTest\n+ *\/\n+public class AddressesCachingTest {\n+\n+    @Test\n+    public void testPositiveCaching() {\n+        boolean observedTwoLookups = performLookups(false);\n+        if (CACHING_DISABLED) {\n+            Assert.assertTrue(observedTwoLookups,\n+                    \"Two positive lookups are expected with caching disabled\");\n+        } else {\n+            Assert.assertFalse(observedTwoLookups,\n+                    \"Only one positive lookup is expected with caching enabled\");\n+        }\n+    }\n+\n+    @Test\n+    public void testNegativeCaching() {\n+        boolean observedTwoLookups = performLookups(true);\n+        if (CACHING_DISABLED) {\n+            Assert.assertTrue(observedTwoLookups,\n+                    \"Two negative lookups are expected with caching disabled\");\n+        } else {\n+            Assert.assertFalse(observedTwoLookups,\n+                    \"Only one negative lookup is expected with caching enabled\");\n+        }\n+    }\n+\n+    \/*\n+     * Performs two subsequent positive or negative lookups.\n+     * Returns true if the timestamp of this lookups differs,\n+     * false otherwise.\n+     *\/\n+    private static boolean performLookups(boolean performNegativeLookup) {\n+        doLookup(performNegativeLookup);\n+        long firstTimestamp = SimpleResolverProviderImpl.getLastLookupTimestamp();\n+        doLookup(performNegativeLookup);\n+        long secondTimestamp = SimpleResolverProviderImpl.getLastLookupTimestamp();\n+        return firstTimestamp != secondTimestamp;\n+    }\n+\n+    \/\/ Performs negative or positive lookup.\n+    \/\/ It is a test error if UnknownHostException is thrown during positive lookup.\n+    \/\/ It is a test error if UnknownHostException is NOT thrown during negative lookup.\n+    private static void doLookup(boolean performNegativeLookup) {\n+        String hostName = performNegativeLookup ? \"notKnowHost.org\" : \"javaTest.org\";\n+        try {\n+            InetAddress.getByName(hostName);\n+            if (performNegativeLookup) {\n+                Assert.fail(\"Host name is expected to get unresolved\");\n+            }\n+        } catch (UnknownHostException uhe) {\n+            if (!performNegativeLookup) {\n+                Assert.fail(\"Host name is expected to get resolved\");\n+            }\n+        }\n+    }\n+\n+    \/\/ Helper system property that signals to the test if both negative and positive\n+    \/\/ caches are disabled.\n+    private static final boolean CACHING_DISABLED = Boolean.getBoolean(\"test.cachingDisabled\");\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/AddressesCachingTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.InetAddress;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import static impl.WithBootstrapResolverUsageProvider.numberOfGetCalls;\n+\n+\/**\n+ * @test\n+ * @summary Test that InetAddress class properly avoids stack-overflow by\n+ * correctly tracking the bootstrap resolver instance when\n+ * InetAddressResolverProvider.get method uses InetAddress lookup API.\n+ * @library providers\/bootstrapUsage\n+ * @build bootstrap.usage.provider\/impl.WithBootstrapResolverUsageProvider\n+ * @run testng\/othervm BootstrapResolverUsageTest\n+ *\/\n+\n+public class BootstrapResolverUsageTest {\n+\n+    @Test\n+    public void testSuccessfulProviderInstantiationTest() throws Exception {\n+        System.err.println(InetAddress.getAllByName(InetAddress.getLocalHost().getHostName()));\n+        Assert.assertEquals(numberOfGetCalls, 1,\n+                \"InetAddressResolverProvider.get was called more than once\");\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/BootstrapResolverUsageTest.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Field;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.spi.InetAddressResolver;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @summary white-box test to check that the built-in resolver\n+ *  is used by default.\n+ * @modules java.base\/java.net:open\n+ * @run testng\/othervm BuiltInResolverTest\n+ *\/\n+\n+public class BuiltInResolverTest {\n+\n+    private Field builtInResolverField, resolverField;\n+\n+    @BeforeTest\n+    public void beforeTest() throws NoSuchFieldException {\n+        Class<InetAddress> inetAddressClass = InetAddress.class;\n+        \/\/ Needs to happen for InetAddress.resolver to be initialized\n+        try {\n+            InetAddress.getByName(\"test\");\n+        } catch (UnknownHostException e) {\n+            \/\/ Do nothing, only want to assign resolver\n+        }\n+        builtInResolverField = inetAddressClass.getDeclaredField(\"BUILTIN_RESOLVER\");\n+        builtInResolverField.setAccessible(true);\n+        resolverField = inetAddressClass.getDeclaredField(\"resolver\");\n+        resolverField.setAccessible(true);\n+    }\n+\n+    @Test\n+    public void testDefaultNSContext() throws IllegalAccessException {\n+        \/\/ Test that the resolver used by default is the BUILTIN_RESOLVER\n+        Object defaultResolverObject = builtInResolverField.get(InetAddressResolver.class);\n+        Object usedResolverObject = resolverField.get(InetAddressResolver.class);\n+\n+        assertTrue(defaultResolverObject == usedResolverObject);\n+\n+        String defaultClassName = defaultResolverObject.getClass().getCanonicalName();\n+        String currentClassName = usedResolverObject.getClass().getCanonicalName();\n+\n+        assertNotNull(defaultClassName, \"defaultClassName not set\");\n+        assertNotNull(currentClassName, \"currentClassName name not set\");\n+\n+        assertEquals(currentClassName, defaultClassName,\n+                \"BUILTIN_RESOLVER resolver was not used.\");\n+        System.err.println(\"Resolver used by default is the built-in resolver\");\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/BuiltInResolverTest.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Arrays;\n+\n+\/*\n+ * @test\n+ * @summary checks that InetAddress forward lookup API throw UnknownHostException\n+ *   when resolver returns empty address stream.\n+ * @library providers\/empty\n+ * @build empty.results.provider\/impl.EmptyResultsProviderImpl\n+ * @run testng\/othervm EmptyResultsStreamTest\n+ *\/\n+public class EmptyResultsStreamTest {\n+\n+    @Test(expectedExceptions = UnknownHostException.class)\n+    public void getAllByNameTest() throws UnknownHostException {\n+        System.err.println(\"getAllByName unexpectedly completed: \" +\n+                Arrays.deepToString(InetAddress.getAllByName(\"test1.org\")));\n+    }\n+\n+    @Test(expectedExceptions = UnknownHostException.class)\n+    public void getByNameTest() throws UnknownHostException {\n+        System.err.println(\"getByName unexpectedly completed: \" +\n+                InetAddress.getByName(\"test2.org\"));\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/EmptyResultsStreamTest.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+networkaddress.cache.ttl=-1\n+networkaddress.cache.negative.ttl=-1\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/ForeverCache.props","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.net.InetAddress;\n+\n+\/**\n+ * @test\n+ * @summary Test that provider which uses InetAddress APIs during its initialization\n+ * wouldn't cause stack overflow and will be successfully installed.\n+ * @library providers\/recursive\n+ * @build recursive.init.provider\/impl.InetAddressUsageInGetProviderImpl\n+ * @run testng\/othervm InetAddressUsageInGetProviderTest\n+ *\/\n+\n+public class InetAddressUsageInGetProviderTest {\n+\n+    @Test\n+    public void testSuccessfulProviderInstantiationTest() throws Exception {\n+        System.err.println(InetAddress.getAllByName(InetAddress.getLocalHost().getHostName()));\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/InetAddressUsageInGetProviderTest.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.InetAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV4;\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV4_FIRST;\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV6;\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV6_FIRST;\n+\n+import jdk.test.lib.net.IPSupport;\n+import jdk.test.lib.NetworkConfiguration;\n+import org.testng.annotations.Test;\n+import org.testng.Assert;\n+import org.testng.SkipException;\n+\n+\/*\n+ * @test\n+ * @summary Test that platform lookup characteristic value is correctly initialized from\n+ *  system properties affecting order and type of queried addresses.\n+ * @library lib providers\/simple \/test\/lib\n+ * @build test.library\/testlib.ResolutionRegistry simple.provider\/impl.SimpleResolverProviderImpl\n+ *        jdk.test.lib.net.IPSupport LookupPolicyMappingTest\n+ * @run testng\/othervm LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack=true -Djava.net.preferIPv6Addresses=true LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack=true -Djava.net.preferIPv6Addresses=false LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack=true -Djava.net.preferIPv6Addresses=system LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack=true -Djava.net.preferIPv6Addresses LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack=true LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack=false -Djava.net.preferIPv6Addresses=true LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack=false -Djava.net.preferIPv6Addresses=false LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack=false -Djava.net.preferIPv6Addresses=system LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack=false -Djava.net.preferIPv6Addresses LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack=false LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack -Djava.net.preferIPv6Addresses=true LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack -Djava.net.preferIPv6Addresses=false LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack -Djava.net.preferIPv6Addresses=system LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack -Djava.net.preferIPv6Addresses LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv4Stack LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv6Addresses=true LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv6Addresses=false LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv6Addresses=system LookupPolicyMappingTest\n+ * @run testng\/othervm -Djava.net.preferIPv6Addresses LookupPolicyMappingTest\n+ *\/\n+\n+public class LookupPolicyMappingTest {\n+\n+    @Test\n+    public void testSystemProperties() throws Exception {\n+\n+        \/\/ Check if platform network configuration matches the test requirements,\n+        \/\/ if not throw a SkipException\n+        checkPlatformNetworkConfiguration();\n+\n+        System.err.println(\"javaTest.org resolved to:\" + Arrays.deepToString(\n+                InetAddress.getAllByName(\"javaTest.org\")));\n+\n+        \/\/ Acquire runtime characteristics from the test NSP\n+        int runtimeCharacteristics = impl.SimpleResolverProviderImpl.lastLookupPolicy().characteristics();\n+\n+        \/\/ Calculate expected lookup policy characteristic\n+        String preferIPv4Stack = System.getProperty(\"java.net.preferIPv4Stack\");\n+        String preferIPv6Addresses = System.getProperty(\"java.net.preferIPv6Addresses\");\n+        String expectedResultsKey = calculateMapKey(preferIPv4Stack, preferIPv6Addresses);\n+        int expectedCharacteristics = EXPECTED_RESULTS_MAP.get(expectedResultsKey);\n+\n+        Assert.assertTrue(characteristicsMatch(\n+                runtimeCharacteristics, expectedCharacteristics), \"Unexpected LookupPolicy observed\");\n+    }\n+\n+    \/\/ Throws SkipException if platform doesn't support required IP address types\n+    static void checkPlatformNetworkConfiguration() {\n+        IPSupport.throwSkippedExceptionIfNonOperational();\n+        IPSupport.printPlatformSupport(System.err);\n+        NetworkConfiguration.printSystemConfiguration(System.err);\n+        \/\/ If preferIPv4=true and no IPv4 - skip\n+        if (IPSupport.preferIPv4Stack()) {\n+            if (!IPSupport.hasIPv4()) {\n+                throw new SkipException(\"Skip tests - IPv4 support required\");\n+            }\n+            return;\n+        }\n+    }\n+\n+    record ExpectedResult(String ipv4stack, String ipv6addresses, int characteristics) {\n+        ExpectedResult {\n+            if (!IPSupport.hasIPv4()) {\n+                characteristics = IPV6;\n+            } else if (!IPSupport.hasIPv6()) {\n+                characteristics = IPV4;\n+            }\n+        }\n+\n+        public String key() {\n+            return calculateMapKey(ipv4stack, ipv6addresses);\n+        }\n+    }\n+\n+    \/*\n+     *  Each row describes a combination of 'preferIPv4Stack', 'preferIPv6Addresses'\n+     *  values and the expected characteristic value\n+     *\/\n+    private static List<ExpectedResult> EXPECTED_RESULTS_TABLE = List.of(\n+            new ExpectedResult(\"true\", \"true\", IPV4),\n+            new ExpectedResult(\"true\", \"false\", IPV4),\n+            new ExpectedResult(\"true\", \"system\", IPV4),\n+            new ExpectedResult(\"true\", \"\", IPV4),\n+            new ExpectedResult(\"true\", null, IPV4),\n+\n+            new ExpectedResult(\"false\", \"true\", IPV4 | IPV6 | IPV6_FIRST),\n+            new ExpectedResult(\"false\", \"false\", IPV4 | IPV6 | IPV4_FIRST),\n+            new ExpectedResult(\"false\", \"system\", IPV4 | IPV6),\n+            new ExpectedResult(\"false\", \"\", IPV4 | IPV6 | IPV4_FIRST),\n+            new ExpectedResult(\"false\", null, IPV4 | IPV6 | IPV4_FIRST),\n+\n+            new ExpectedResult(\"\", \"true\", IPV4 | IPV6 | IPV6_FIRST),\n+            new ExpectedResult(\"\", \"false\", IPV4 | IPV6 | IPV4_FIRST),\n+            new ExpectedResult(\"\", \"system\", IPV4 | IPV6),\n+            new ExpectedResult(\"\", \"\", IPV4 | IPV6 | IPV4_FIRST),\n+            new ExpectedResult(\"\", null, IPV4 | IPV6 | IPV4_FIRST),\n+\n+            new ExpectedResult(null, \"true\", IPV4 | IPV6 | IPV6_FIRST),\n+            new ExpectedResult(null, \"false\", IPV4 | IPV6 | IPV4_FIRST),\n+            new ExpectedResult(null, \"system\", IPV4 | IPV6),\n+            new ExpectedResult(null, \"\", IPV4 | IPV6 | IPV4_FIRST),\n+            new ExpectedResult(null, null, IPV4 | IPV6 | IPV4_FIRST));\n+\n+    private static final Map<String, Integer> EXPECTED_RESULTS_MAP = calculateExpectedCharacteristics();\n+\n+    private static Map<String, Integer> calculateExpectedCharacteristics() {\n+        return EXPECTED_RESULTS_TABLE.stream()\n+                .collect(Collectors.toUnmodifiableMap(\n+                        ExpectedResult::key,\n+                        ExpectedResult::characteristics)\n+                );\n+    }\n+\n+    private static String calculateMapKey(String ipv4stack, String ipv6addresses) {\n+        return ipv4stack + \"_\" + ipv6addresses;\n+    }\n+\n+    private static boolean characteristicsMatch(int actual, int expected) {\n+        System.err.printf(\"Comparing characteristics:%n\\tActual: %s%n\\tExpected: %s%n\",\n+                Integer.toBinaryString(actual),\n+                Integer.toBinaryString(expected));\n+        return (actual & (IPV4 | IPV6 | IPV4_FIRST | IPV6_FIRST)) == expected;\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/LookupPolicyMappingTest.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary check if LookupPolicy.of correctly handles valid and illegal\n+ * combinations of characteristics bit mask flags.\n+ * @run testng LookupPolicyOfTest\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.net.spi.InetAddressResolver.LookupPolicy;\n+import java.util.List;\n+\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV4;\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV4_FIRST;\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV6;\n+import static java.net.spi.InetAddressResolver.LookupPolicy.IPV6_FIRST;\n+\n+public class LookupPolicyOfTest {\n+\n+    @Test(dataProvider = \"validCharacteristics\")\n+    public void testValidCharacteristicCombinations(List<Integer> validCombination) {\n+        LookupPolicy.of(bitFlagsToCharacteristicsValue(validCombination));\n+    }\n+\n+    @Test(dataProvider = \"invalidCharacteristics\", expectedExceptions = IllegalArgumentException.class)\n+    public void testInvalidCharacteristicCombinations(List<Integer> invalidCombination) {\n+        LookupPolicy.of(bitFlagsToCharacteristicsValue(invalidCombination));\n+    }\n+\n+    @DataProvider(name = \"validCharacteristics\")\n+    public Object[][] validCharacteristicValue() {\n+        return new Object[][]{\n+                {List.of(IPV4)},\n+                {List.of(IPV4, IPV4_FIRST)},\n+                {List.of(IPV6)},\n+                {List.of(IPV6, IPV6_FIRST)},\n+                {List.of(IPV4, IPV6)},\n+                {List.of(IPV4, IPV6, IPV4_FIRST)},\n+                {List.of(IPV4, IPV6, IPV6_FIRST)},\n+                \/\/ Custom flag values alongside to address type flags\n+                \/\/ that could be used by custom providers\n+                {List.of(IPV4, IPV6, 0x10)},\n+                {List.of(IPV4, IPV6, 0x20)},\n+        };\n+    }\n+\n+    @DataProvider(name = \"invalidCharacteristics\")\n+    public Object[][] illegalCharacteristicValue() {\n+        return new Object[][]{\n+                {List.of()},\n+                {List.of(IPV4_FIRST)},\n+                {List.of(IPV6_FIRST)},\n+                {List.of(IPV4_FIRST, IPV6_FIRST)},\n+                {List.of(IPV4, IPV6_FIRST)},\n+                {List.of(IPV6, IPV4_FIRST)},\n+                {List.of(IPV4, IPV6, IPV4_FIRST, IPV6_FIRST)},\n+        };\n+    }\n+\n+    private static int bitFlagsToCharacteristicsValue(List<Integer> bitFlagsList) {\n+        return bitFlagsList.stream()\n+                .reduce(0, (flag1, flag2) -> flag1 | flag2);\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/LookupPolicyOfTest.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+networkaddress.cache.ttl=0\n+networkaddress.cache.negative.ttl=0\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/NeverCache.props","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.InetAddress;\n+import java.util.Arrays;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import static impl.FaultyResolverProviderGetImpl.EXCEPTION_MESSAGE;\n+\n+\/*\n+ * @test\n+ * @summary Test that InetAddress fast-fails if custom provider fails to\n+ *  instantiate a resolver.\n+ * @library providers\/faulty\n+ * @build faulty.provider\/impl.FaultyResolverProviderGetImpl\n+ * @run testng\/othervm ProviderGetExceptionTest\n+ *\/\n+\n+public class ProviderGetExceptionTest {\n+\n+    @Test\n+    public void getByNameExceptionTest() {\n+        String hostName = \"test.host\";\n+        System.out.println(\"Looking up address for the following host name:\" + hostName);\n+        callInetAddressAndCheckException(() -> InetAddress.getByName(hostName));\n+    }\n+\n+    @Test\n+    public void getByAddressExceptionTest() {\n+        byte[] address = new byte[]{1, 2, 3, 4};\n+        System.out.println(\"Looking up host name for the following address:\" + Arrays.toString(address));\n+        callInetAddressAndCheckException(() -> InetAddress.getByAddress(address).getHostName());\n+    }\n+\n+    private void callInetAddressAndCheckException(Assert.ThrowingRunnable apiCall) {\n+        IllegalArgumentException iae = Assert.expectThrows(IllegalArgumentException.class, apiCall);\n+        System.out.println(\"Got exception of expected type:\" + iae);\n+        Assert.assertNull(iae.getCause(), \"cause is not null\");\n+        Assert.assertEquals(iae.getMessage(), EXCEPTION_MESSAGE);\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/ProviderGetExceptionTest.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+\n+import impl.ThrowingLookupsProviderImpl;\n+\n+import static impl.ThrowingLookupsProviderImpl.RUNTIME_EXCEPTION_MESSAGE;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @summary Test that only UnknownHostException is thrown if resolver\n+ * implementation throws RuntimeException during forward or reverse lookup.\n+ * @library providers\/throwing\n+ * @build throwing.lookups.provider\/impl.ThrowingLookupsProviderImpl\n+ * @run testng\/othervm ResolutionWithExceptionTest\n+ *\/\n+\n+public class ResolutionWithExceptionTest {\n+\n+    @Test\n+    public void getByNameUnknownHostException() {\n+        ThrowingLookupsProviderImpl.throwRuntimeException = false;\n+        runGetByNameTest();\n+    }\n+\n+    @Test\n+    public void getByNameRuntimeException() {\n+        ThrowingLookupsProviderImpl.throwRuntimeException = true;\n+        runGetByNameTest();\n+    }\n+\n+    @Test\n+    public void getByAddressUnknownHostException() throws UnknownHostException {\n+        ThrowingLookupsProviderImpl.throwRuntimeException = false;\n+        runGetByAddressTest();\n+    }\n+\n+    @Test\n+    public void getByAddressRuntimeException() throws UnknownHostException {\n+        ThrowingLookupsProviderImpl.throwRuntimeException = true;\n+        runGetByAddressTest();\n+    }\n+\n+    private void runGetByNameTest() {\n+        \/\/ InetAddress.getByName() is expected to throw UnknownHostException in all cases\n+        UnknownHostException uhe = Assert.expectThrows(UnknownHostException.class,\n+                () -> InetAddress.getByName(\"doesnt.matter.com\"));\n+        \/\/ If provider is expected to throw RuntimeException - check that UnknownHostException\n+        \/\/ is set as its cause\n+        if (ThrowingLookupsProviderImpl.throwRuntimeException) {\n+            Throwable cause = uhe.getCause();\n+            if (cause instanceof RuntimeException re) {\n+                \/\/ Check RuntimeException message\n+                Assert.assertEquals(re.getMessage(), RUNTIME_EXCEPTION_MESSAGE,\n+                        \"incorrect exception message\");\n+            } else {\n+                Assert.fail(\"UnknownHostException cause is not RuntimeException\");\n+            }\n+        }\n+    }\n+\n+    private void runGetByAddressTest() throws UnknownHostException {\n+        \/\/ getCanonicalHostName is not expected to throw an exception:\n+        \/\/ if there is an error during reverse lookup operation the literal IP\n+        \/\/ address String will be returned.\n+        String literalIP = InetAddress.getByAddress(new byte[]{1, 2, 3, 4}).getCanonicalHostName();\n+        Assert.assertEquals(literalIP, \"1.2.3.4\");\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/ResolutionWithExceptionTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.InetAddress;\n+import java.net.SocketPermission;\n+import java.net.UnknownHostException;\n+import java.security.Permission;\n+import java.util.logging.Logger;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @summary Test that resolution of host name requires SocketPermission(\"resolve\", <host name>)\n+ * permission when running with security manager and custom resolver provider installed.\n+ * @library lib providers\/simple\n+ * @build test.library\/testlib.ResolutionRegistry simple.provider\/impl.SimpleResolverProviderImpl\n+ *        ResolvePermissionTest\n+ * @run testng\/othervm -Dtest.dataFileName=nonExistentFile -Djava.security.manager=allow\n+ *                      ResolvePermissionTest\n+ *\/\n+\n+public class ResolvePermissionTest {\n+\n+    @Test\n+    public void withResolvePermission() throws Exception {\n+        testResolvePermission(true);\n+    }\n+\n+    @Test\n+    public void noResolvePermission() throws Exception {\n+        testResolvePermission(false);\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private void testResolvePermission(boolean grantResolvePermission) throws Exception {\n+        \/\/ Set security manager which grants or denies permission to resolve 'javaTest.org' host\n+        var securityManager = new ResolvePermissionTest.TestSecurityManager(grantResolvePermission);\n+        try {\n+            System.setSecurityManager(securityManager);\n+            Class expectedExceptionClass = grantResolvePermission ?\n+                    UnknownHostException.class : SecurityException.class;\n+            var exception = Assert.expectThrows(expectedExceptionClass, () -> InetAddress.getByName(\"javaTest.org\"));\n+            LOGGER.info(\"Got expected exception: \" + exception);\n+        } finally {\n+            System.setSecurityManager(null);\n+        }\n+    }\n+\n+    static class TestSecurityManager extends SecurityManager {\n+        final boolean allowJavaTestOrgResolve;\n+\n+        public TestSecurityManager(boolean allowJavaTestOrgResolve) {\n+            this.allowJavaTestOrgResolve = allowJavaTestOrgResolve;\n+        }\n+\n+        @Override\n+        public void checkPermission(Permission permission) {\n+            if (permission instanceof java.net.SocketPermission) {\n+                SocketPermission sockPerm = (SocketPermission) permission;\n+                if (\"resolve\".equals(sockPerm.getActions())) {\n+                    String host = sockPerm.getName();\n+                    LOGGER.info(\"Checking 'resolve' SocketPermission: \" + permission);\n+                    if (\"javaTest.org\".equals(host) && !allowJavaTestOrgResolve) {\n+                        LOGGER.info(\"Denying 'resolve' permission for 'javaTest.org'\");\n+                        throw new SecurityException(\"Access Denied\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static final Logger LOGGER = Logger.getLogger(ResolvePermissionTest.class.getName());\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/ResolvePermissionTest.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import impl.DelegatingProviderImpl;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+\n+import static impl.DelegatingProviderImpl.changeReverseLookupAddress;\n+import static impl.DelegatingProviderImpl.lastReverseLookupThrowable;\n+\n+\/*\n+ * @test\n+ * @summary checks delegation of illegal reverse lookup request to the built-in\n+ *  InetAddressResolver.\n+ * @library providers\/delegating\n+ * @build delegating.provider\/impl.DelegatingProviderImpl\n+ * @run testng\/othervm ReverseLookupDelegationTest\n+ *\/\n+public class ReverseLookupDelegationTest {\n+\n+    @Test\n+    public void delegateHostNameLookupWithWrongByteArray() throws UnknownHostException {\n+        \/\/ The underlying resolver implementation will ignore the supplied\n+        \/\/ byte array and will replace it with byte array of incorrect size.\n+        changeReverseLookupAddress = true;\n+        String canonicalHostName = InetAddress.getByAddress(new byte[]{1, 2, 3, 4}).getCanonicalHostName();\n+        \/\/ Output canonical host name and the exception thrown by the built-in resolver\n+        System.err.println(\"Canonical host name:\" + canonicalHostName);\n+        System.err.println(\"Exception thrown by the built-in resolver:\" + lastReverseLookupThrowable);\n+\n+        \/\/ Check that originally supplied byte array was used to construct canonical host name after\n+        \/\/ failed reverse lookup.\n+        Assert.assertEquals(\"1.2.3.4\", canonicalHostName, \"unexpected canonical hostname\");\n+\n+        \/\/ Check that on a provider side the IllegalArgumentException has been thrown by the built-in resolver\n+        Assert.assertTrue(lastReverseLookupThrowable instanceof IllegalArgumentException,\n+                \"wrong exception type is thrown by the built-in resolver\");\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/ReverseLookupDelegationTest.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.net.InetAddress;\n+import java.security.Permission;\n+import java.util.ServiceConfigurationError;\n+import java.util.logging.Logger;\n+\n+\/*\n+ * @test\n+ * @summary Test that instantiation of InetAddressResolverProvider requires \"inetAddressResolverProvider\"\n+ *          RuntimePermission when running with security manager.\n+ * @library lib providers\/simple\n+ * @build test.library\/testlib.ResolutionRegistry simple.provider\/impl.SimpleResolverProviderImpl\n+ *        RuntimePermissionTest\n+ * @run testng\/othervm -Djava.security.manager=allow RuntimePermissionTest\n+ *\/\n+\n+public class RuntimePermissionTest {\n+\n+    @Test\n+    public void withRuntimePermission() throws Exception {\n+        testRuntimePermission(true);\n+    }\n+\n+    @Test\n+    public void noRuntimePermission() throws Exception {\n+        testRuntimePermission(false);\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private void testRuntimePermission(boolean permitInetAddressResolver) throws Exception {\n+        \/\/ Set security manager which grants all permissions + RuntimePermission(\"inetAddressResolverProvider\")\n+        var securityManager = new TestSecurityManager(permitInetAddressResolver);\n+        try {\n+            System.setSecurityManager(securityManager);\n+            if (permitInetAddressResolver) {\n+                InetAddress.getByName(\"javaTest.org\");\n+            } else {\n+                ServiceConfigurationError sce =\n+                        Assert.expectThrows(ServiceConfigurationError.class,\n+                                            () -> InetAddress.getByName(\"javaTest.org\"));\n+                LOGGER.info(\"Got ServiceConfigurationError: \" + sce);\n+                Throwable cause = sce.getCause();\n+                Assert.assertTrue(cause instanceof SecurityException);\n+                Assert.assertTrue(cause.getMessage().contains(RUNTIME_PERMISSION_NAME));\n+            }\n+        } finally {\n+            System.setSecurityManager(null);\n+        }\n+    }\n+\n+    static class TestSecurityManager extends SecurityManager {\n+        final boolean permitInetAddressResolver;\n+\n+        public TestSecurityManager(boolean permitInetAddressResolver) {\n+            this.permitInetAddressResolver = permitInetAddressResolver;\n+            LOGGER.info(\"inetAddressResolverProvider permission is \" +\n+                        (permitInetAddressResolver ? \"granted\" : \"not granted\"));\n+        }\n+\n+        @Override\n+        public void checkPermission(Permission permission) {\n+            if (permission instanceof RuntimePermission) {\n+                LOGGER.info(\"Checking RuntimePermission: \" + permission);\n+                if (RUNTIME_PERMISSION_NAME.equals(permission.getName()) && !permitInetAddressResolver) {\n+                    LOGGER.info(\"Denying '\" + RUNTIME_PERMISSION_NAME + \"' permission\");\n+                    throw new SecurityException(\"Access Denied: \" + RUNTIME_PERMISSION_NAME);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static final String RUNTIME_PERMISSION_NAME = \"inetAddressResolverProvider\";\n+    private static final Logger LOGGER = Logger.getLogger(RuntimePermissionTest.class.getName());\n+\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/RuntimePermissionTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+# Test data file for InetAddressResolverProvider SPI tests\n+# Format: <IP address> <Host Name>\n+# If multiple IP addresses are required for host:\n+#    multiple lines could be added\n+\n+1.2.3.4    javaTest.org\n+[ca:fe:ba:be::1] javaTest.org\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/addresses.txt","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module test.library {\n+    exports testlib;\n+    requires java.logging;\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/lib\/test.library\/module-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package testlib;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.spi.InetAddressResolver.LookupPolicy;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Predicate;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.Comparator;\n+\n+import static java.net.spi.InetAddressResolver.LookupPolicy.*;\n+\n+public class ResolutionRegistry {\n+\n+    \/\/ Map to store hostName -> InetAddress mappings\n+    private final Map<String, List<byte[]>> registry;\n+    private static final int IPV4_RAW_LEN = 4;\n+    private static final int IPV6_RAW_LEN = 16;\n+\n+    private static final Logger LOGGER = Logger.getLogger(ResolutionRegistry.class.getName());\n+\n+    public ResolutionRegistry() {\n+\n+        \/\/ Populate registry from test data file\n+        String fileName = System.getProperty(\"test.dataFileName\", \"addresses.txt\");\n+        Path addressesFile = Paths.get(System.getProperty(\"test.src\", \".\")).resolve(fileName);\n+        LOGGER.info(\"Creating ResolutionRegistry instance from file:\" + addressesFile);\n+        registry = parseDataFile(addressesFile);\n+    }\n+\n+    private Map<String, List<byte[]>> parseDataFile(Path addressesFile) {\n+        try {\n+            if (addressesFile.toFile().isFile()) {\n+                Map<String, List<byte[]>> resReg = new ConcurrentHashMap<>();\n+                \/\/ Prepare list of hostname\/address entries\n+                List<String[]> entriesList = Files.readAllLines(addressesFile).stream()\n+                        .map(String::trim)\n+                        .filter(Predicate.not(String::isBlank))\n+                        .filter(s -> !s.startsWith(\"#\"))\n+                        .map(s -> s.split(\"\\\\s+\"))\n+                        .filter(sarray -> sarray.length == 2)\n+                        .filter(ResolutionRegistry::hasLiteralAddress)\n+                        .filter(Objects::nonNull)\n+                        .collect(Collectors.toList());\n+                \/\/ Convert list of entries into registry Map\n+                for (var entry : entriesList) {\n+                    String ipAddress = entry[0].trim();\n+                    String hostName = entry[1].trim();\n+                    byte[] addrBytes = toByteArray(ipAddress);\n+                    if (addrBytes != null) {\n+                        var list = resReg.containsKey(hostName) ? resReg.get(hostName) : new ArrayList();\n+                        list.add(addrBytes);\n+                        if (!resReg.containsKey(hostName)) {\n+                            resReg.put(hostName, list);\n+                        }\n+                    }\n+                }\n+                resReg.replaceAll((k, v) -> Collections.unmodifiableList(v));\n+                \/\/ Print constructed registry\n+                StringBuilder sb = new StringBuilder(\"Constructed addresses registry:\" + System.lineSeparator());\n+                for (var entry : resReg.entrySet()) {\n+                    sb.append(\"\\t\" + entry.getKey() + \": \");\n+                    for (byte[] addr : entry.getValue()) {\n+                        sb.append(addressBytesToString(addr) + \" \");\n+                    }\n+                    sb.append(System.lineSeparator());\n+                }\n+                LOGGER.info(sb.toString());\n+                return resReg;\n+            } else {\n+                \/\/ If file doesn't exist - return empty map\n+                return Collections.emptyMap();\n+            }\n+        } catch (IOException ioException) {\n+            \/\/ If any problems parsing the file - log a warning and return an empty map\n+            LOGGER.log(Level.WARNING, \"Error reading data file\", ioException);\n+            return Collections.emptyMap();\n+        }\n+    }\n+\n+    \/\/ Line is not a blank and not a comment\n+    private static boolean hasLiteralAddress(String[] lineFields) {\n+        String addressString = lineFields[0].trim();\n+        return addressString.charAt(0) == '[' ||\n+                Character.digit(addressString.charAt(0), 16) != -1 ||\n+                (addressString.charAt(0) == ':');\n+    }\n+\n+    \/\/ Line is not blank and not comment\n+    private static byte[] toByteArray(String addressString) {\n+        InetAddress address;\n+        \/\/ Will reuse InetAddress functionality to parse literal IP address\n+        \/\/ strings. This call is guarded by 'hasLiteralAddress' method.\n+        try {\n+            address = InetAddress.getByName(addressString);\n+        } catch (UnknownHostException unknownHostException) {\n+            LOGGER.warning(\"Can't parse address string:'\" + addressString + \"'\");\n+            return null;\n+        }\n+        return address.getAddress();\n+    }\n+\n+    public Stream<InetAddress> lookupHost(String host, LookupPolicy lookupPolicy)\n+            throws UnknownHostException {\n+        LOGGER.info(\"Looking-up '\" + host + \"' address\");\n+        if (!registry.containsKey(host)) {\n+            LOGGER.info(\"Registry doesn't contain addresses for '\" + host + \"'\");\n+            throw new UnknownHostException(host);\n+        }\n+\n+        int characteristics = lookupPolicy.characteristics();\n+        \/\/ Filter IPV4 or IPV6 as needed. Then sort with\n+        \/\/ comparator for IPV4_FIRST or IPV6_FIRST.\n+        return registry.get(host)\n+                .stream()\n+                .filter(ba -> filterAddressByLookupPolicy(ba, characteristics))\n+                .sorted(new AddressOrderPref(characteristics))\n+                .map(ba -> constructInetAddress(host, ba))\n+                .filter(Objects::nonNull);\n+    }\n+\n+    private static boolean filterAddressByLookupPolicy(byte[] ba, int ch) {\n+        \/\/ If 0011, return both. If 0001, IPv4. If 0010, IPv6\n+        boolean ipv4Flag = (ch & IPV4) == IPV4;\n+        boolean ipv6Flag = (ch & IPV6) == IPV6;\n+\n+        if (ipv4Flag && ipv6Flag)\n+            return true; \/\/ Return regardless of length\n+        else if (ipv4Flag)\n+            return (ba.length == IPV4_RAW_LEN);\n+        else if (ipv6Flag)\n+            return (ba.length == IPV6_RAW_LEN);\n+\n+        throw new RuntimeException(\"Lookup policy characteristics were improperly set. \" +\n+                \"Characteristics: \" + Integer.toString(ch, 2));\n+    }\n+\n+    private static InetAddress constructInetAddress(String host, byte[] address) {\n+        try {\n+            return InetAddress.getByAddress(host, address);\n+        } catch (UnknownHostException unknownHostException) {\n+            return null;\n+        }\n+    }\n+\n+    public String lookupAddress(byte[] addressBytes) {\n+        for (var entry : registry.entrySet()) {\n+            if (entry.getValue()\n+                    .stream()\n+                    .filter(ba -> Arrays.equals(ba, addressBytes))\n+                    .findAny()\n+                    .isPresent()) {\n+                return entry.getKey();\n+            }\n+        }\n+        try {\n+            return InetAddress.getByAddress(addressBytes).getHostAddress();\n+        } catch (UnknownHostException unknownHostException) {\n+            throw new IllegalArgumentException();\n+        }\n+    }\n+\n+    public boolean containsAddressMapping(InetAddress address) {\n+        String hostName = address.getHostName();\n+        if (registry.containsKey(hostName)) {\n+            var mappedBytes = registry.get(address.getHostName());\n+            for (byte[] mappedAddr : mappedBytes) {\n+                if (Arrays.equals(mappedAddr, address.getAddress())) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public static String addressBytesToString(byte[] bytes) {\n+        try {\n+            return InetAddress.getByAddress(bytes).toString();\n+        } catch (UnknownHostException unknownHostException) {\n+            return Arrays.toString(bytes);\n+        }\n+    }\n+\n+    private class AddressOrderPref implements Comparator<byte[]> {\n+\n+        private final int ch;\n+\n+        AddressOrderPref(int ch) {\n+            this.ch = ch;\n+        }\n+\n+        @Override\n+        public int compare(byte[] o1, byte[] o2) {\n+            \/\/ Compares based on address length, 4 bytes for IPv4,\n+            \/\/ 16 bytes for IPv6.\n+            return ((ch & IPV4_FIRST) == IPV4_FIRST) ?\n+                    Integer.compare(o1.length, o2.length) :\n+                    Integer.compare(o2.length, o1.length);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/lib\/test.library\/testlib\/ResolutionRegistry.java","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package impl;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.spi.InetAddressResolver;\n+import java.net.spi.InetAddressResolverProvider;\n+import java.util.stream.Stream;\n+\n+public class WithBootstrapResolverUsageProvider extends InetAddressResolverProvider {\n+\n+    public static volatile long numberOfGetCalls;\n+\n+    @Override\n+    public InetAddressResolver get(Configuration configuration) {\n+        numberOfGetCalls++;\n+        System.out.println(\"The following provider will be used by current test:\" +\n+                this.getClass().getCanonicalName());\n+        System.out.println(\"InetAddressResolverProvider::get() called \" + numberOfGetCalls + \" times\");\n+\n+        \/\/ We use different names to avoid InetAddress-level caching\n+        doLookup(\"foo\" + numberOfGetCalls + \".A.org\");\n+\n+        \/\/ We need second call to test how InetAddress internals maintain reference to a bootstrap resolver\n+        doLookup(\"foo\" + numberOfGetCalls + \".B.org\");\n+\n+        return new InetAddressResolver() {\n+            @Override\n+            public Stream<InetAddress> lookupByName(String host, LookupPolicy lookupPolicy)\n+                    throws UnknownHostException {\n+                return Stream.of(InetAddress.getByAddress(host, new byte[]{127, 0, 2, 1}));\n+            }\n+\n+            @Override\n+            public String lookupByAddress(byte[] addr) throws UnknownHostException {\n+                return configuration.builtinResolver().lookupByAddress(addr);\n+            }\n+        };\n+    }\n+\n+    \/\/ Perform an InetAddress resolution lookup operation\n+    private static void doLookup(String hostName) {\n+        try {\n+            InetAddress.getByName(hostName);\n+        } catch (UnknownHostException e) {\n+            \/\/ Ignore UHE since the bootstrap resolver is used here\n+        }\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"WithBootstrapResolverUsageProvider\";\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/bootstrapUsage\/bootstrap.usage.provider\/impl\/WithBootstrapResolverUsageProvider.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.spi.InetAddressResolverProvider;\n+\n+module bootstrap.usage.provider {\n+    exports impl;\n+    requires java.logging;\n+    provides InetAddressResolverProvider with impl.WithBootstrapResolverUsageProvider;\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/bootstrapUsage\/bootstrap.usage.provider\/module-info.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package impl;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.spi.InetAddressResolver;\n+import java.net.spi.InetAddressResolverProvider;\n+import java.util.stream.Stream;\n+\n+public class DelegatingProviderImpl extends InetAddressResolverProvider {\n+\n+    public static volatile boolean changeReverseLookupAddress;\n+    public static volatile Throwable lastReverseLookupThrowable;\n+\n+    @Override\n+    public InetAddressResolver get(Configuration configuration) {\n+        System.out.println(\"The following provider will be used by current test:\" +\n+                this.getClass().getCanonicalName());\n+        return new InetAddressResolver() {\n+            @Override\n+            public Stream<InetAddress> lookupByName(String host, LookupPolicy lookupPolicy) throws UnknownHostException {\n+                return configuration.builtinResolver().lookupByName(host, lookupPolicy);\n+            }\n+\n+            @Override\n+            public String lookupByAddress(byte[] addr) throws UnknownHostException {\n+                try {\n+                    if (!changeReverseLookupAddress) {\n+                        return configuration.builtinResolver().lookupByAddress(addr);\n+                    } else {\n+                        \/\/ Deliberately supply address bytes array with wrong size\n+                        return configuration.builtinResolver().lookupByAddress(new byte[]{1, 2, 3});\n+                    }\n+                } catch (Throwable t) {\n+                    lastReverseLookupThrowable = t;\n+                    throw t;\n+                }\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"DelegatingProvider\";\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/delegating\/delegating.provider\/impl\/DelegatingProviderImpl.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+*\/\n+\n+import java.net.spi.InetAddressResolverProvider;\n+\n+module delegating.provider {\n+    exports impl;\n+    provides InetAddressResolverProvider with impl.DelegatingProviderImpl;\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/delegating\/delegating.provider\/module-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package impl;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.spi.InetAddressResolver;\n+import java.net.spi.InetAddressResolverProvider;\n+import java.util.stream.Stream;\n+\n+public class EmptyResultsProviderImpl extends InetAddressResolverProvider {\n+    @Override\n+    public InetAddressResolver get(Configuration configuration) {\n+        System.out.println(\"The following provider will be used by current test:\" +\n+                this.getClass().getCanonicalName());\n+\n+        return new InetAddressResolver() {\n+            @Override\n+            public Stream<InetAddress> lookupByName(String host, LookupPolicy lookupPolicy)\n+                    throws UnknownHostException {\n+                return Stream.empty();\n+            }\n+\n+            @Override\n+            public String lookupByAddress(byte[] addr) throws UnknownHostException {\n+                return configuration.builtinResolver().lookupByAddress(addr);\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"EmptyForwardLookupResultsProvider\";\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/empty\/empty.results.provider\/impl\/EmptyResultsProviderImpl.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+*\/\n+\n+import java.net.spi.InetAddressResolverProvider;\n+\n+module empty.results.provider {\n+    exports impl;\n+    provides InetAddressResolverProvider with impl.EmptyResultsProviderImpl;\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/empty\/empty.results.provider\/module-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package impl;\n+\n+import java.net.spi.InetAddressResolverProvider;\n+import java.net.spi.InetAddressResolver;\n+\n+public class FaultyResolverProviderGetImpl extends InetAddressResolverProvider {\n+    public static final String EXCEPTION_MESSAGE = \"This provider provides nothing\";\n+\n+    @Override\n+    public InetAddressResolver get(Configuration configuration) {\n+        System.out.println(\"The following provider will be used by current test:\" + this.getClass().getCanonicalName());\n+        throw new IllegalArgumentException(EXCEPTION_MESSAGE);\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"faultyInetAddressResolverGet\";\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/faulty\/faulty.provider\/impl\/FaultyResolverProviderGetImpl.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+*\/\n+\n+import java.net.spi.InetAddressResolverProvider;\n+\n+module faulty.provider {\n+    exports impl;\n+    requires java.logging;\n+    provides InetAddressResolverProvider with impl.FaultyResolverProviderGetImpl;\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/faulty\/faulty.provider\/module-info.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package impl;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.spi.InetAddressResolver;\n+import java.net.spi.InetAddressResolverProvider;\n+import java.util.stream.Stream;\n+\n+public class InetAddressUsageInGetProviderImpl extends InetAddressResolverProvider {\n+    @Override\n+    public InetAddressResolver get(Configuration configuration) {\n+        System.out.println(\"The following provider will be used by current test:\" + this.getClass().getCanonicalName());\n+        String localHostName;\n+        try {\n+            localHostName = InetAddress.getLocalHost().getHostName();\n+        } catch (UnknownHostException e) {\n+            throw new RuntimeException(\"Provider failed to initialize\");\n+        }\n+        return new InetAddressResolver() {\n+            @Override\n+            public Stream<InetAddress> lookupByName(String host, LookupPolicy lookupPolicy) throws UnknownHostException {\n+                if (host.equals(localHostName)) {\n+                    return configuration.builtinResolver().lookupByName(host, lookupPolicy);\n+                } else {\n+                    throw new UnknownHostException(host);\n+                }\n+            }\n+\n+            @Override\n+            public String lookupByAddress(byte[] addr) throws UnknownHostException {\n+                return configuration.builtinResolver().lookupByAddress(addr);\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"ProviderWithInetAddressUsageInGet\";\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/recursive\/recursive.init.provider\/impl\/InetAddressUsageInGetProviderImpl.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+*\/\n+\n+import java.net.spi.InetAddressResolverProvider;\n+\n+module recursive.init.provider {\n+    exports impl;\n+    requires java.logging;\n+    provides InetAddressResolverProvider with impl.InetAddressUsageInGetProviderImpl;\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/recursive\/recursive.init.provider\/module-info.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package impl;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.spi.InetAddressResolver;\n+import java.net.spi.InetAddressResolver.LookupPolicy;\n+import java.net.spi.InetAddressResolverProvider;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import java.util.stream.Stream;\n+\n+import testlib.ResolutionRegistry;\n+\n+public class SimpleResolverProviderImpl extends InetAddressResolverProvider {\n+\n+    public static ResolutionRegistry registry = new ResolutionRegistry();\n+    private static List<LookupPolicy> LOOKUP_HISTORY = Collections.synchronizedList(new ArrayList<>());\n+    private static volatile long LAST_LOOKUP_TIMESTAMP;\n+    private static Logger LOGGER = Logger.getLogger(SimpleResolverProviderImpl.class.getName());\n+\n+    @Override\n+    public InetAddressResolver get(Configuration configuration) {\n+        System.out.println(\"The following provider will be used by current test:\" + this.getClass().getCanonicalName());\n+        return new InetAddressResolver() {\n+            @Override\n+            public Stream<InetAddress> lookupByName(String host, LookupPolicy lookupPolicy) throws UnknownHostException {\n+                LOGGER.info(\"Looking-up addresses for '\" + host + \"'. Lookup characteristics:\" +\n+                        Integer.toString(lookupPolicy.characteristics(), 2));\n+                LOOKUP_HISTORY.add(lookupPolicy);\n+                LAST_LOOKUP_TIMESTAMP = System.nanoTime();\n+                return registry.lookupHost(host, lookupPolicy);\n+            }\n+\n+            @Override\n+            public String lookupByAddress(byte[] addr) throws UnknownHostException {\n+                LOGGER.info(\"Looking host name for the following address:\" + ResolutionRegistry.addressBytesToString(addr));\n+                return registry.lookupAddress(addr);\n+            }\n+        };\n+    }\n+\n+    \/\/ Utility methods\n+    public static LookupPolicy lastLookupPolicy() {\n+        return lookupPolicyHistory(0);\n+    }\n+\n+    public static long getLastLookupTimestamp() {\n+        return LAST_LOOKUP_TIMESTAMP;\n+    }\n+\n+    public static LookupPolicy lookupPolicyHistory(int position) {\n+        if (LOOKUP_HISTORY.isEmpty()) {\n+            throw new RuntimeException(\"No registered lookup policies\");\n+        }\n+        if (position >= LOOKUP_HISTORY.size()) {\n+            throw new IllegalArgumentException(\"No element available with provided position\");\n+        }\n+        return LOOKUP_HISTORY.get(LOOKUP_HISTORY.size() - position - 1);\n+    }\n+\n+\n+    @Override\n+    public String name() {\n+        return \"simpleInetAddressResolver\";\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/simple\/simple.provider\/impl\/SimpleResolverProviderImpl.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+*\/\n+\n+import java.net.spi.InetAddressResolverProvider;\n+\n+module simple.provider {\n+    exports impl;\n+    requires java.logging;\n+    requires test.library;\n+    provides InetAddressResolverProvider with impl.SimpleResolverProviderImpl;\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/simple\/simple.provider\/module-info.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package impl;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.spi.InetAddressResolver;\n+import java.net.spi.InetAddressResolverProvider;\n+import java.util.stream.Stream;\n+\n+public class ThrowingLookupsProviderImpl extends InetAddressResolverProvider {\n+    @Override\n+    public InetAddressResolver get(Configuration configuration) {\n+        System.out.println(\"The following provider will be used by current test:\" +\n+                this.getClass().getCanonicalName());\n+\n+        return new InetAddressResolver() {\n+            @Override\n+            public Stream<InetAddress> lookupByName(String host, LookupPolicy lookupPolicy)\n+                    throws UnknownHostException {\n+                if (throwRuntimeException) {\n+                    System.err.println(name()+\" forward lookup: throwing RuntimeException\");\n+                    throw new RuntimeException(RUNTIME_EXCEPTION_MESSAGE);\n+                } else {\n+                    System.err.println(name()+\" forward lookup: throwing UnknownHostException\");\n+                    throw new UnknownHostException();\n+                }\n+            }\n+\n+            @Override\n+            public String lookupByAddress(byte[] addr) throws UnknownHostException {\n+                if (throwRuntimeException) {\n+                    System.err.println(name()+\" reverse lookup: throwing RuntimeException\");\n+                    throw new RuntimeException(RUNTIME_EXCEPTION_MESSAGE);\n+                } else {\n+                    System.err.println(name()+\" reverse lookup: throwing UnknownHostException\");\n+                    throw new UnknownHostException();\n+                }\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"ThrowingLookupsProvider\";\n+    }\n+\n+    \/\/ Indicates if provider need to throw RuntimeException for forward and reverse lookup operations.\n+    \/\/ If it is set to 'false' then UnknownHostException will thrown for each operation.\n+    public static volatile boolean throwRuntimeException;\n+    public static final String RUNTIME_EXCEPTION_MESSAGE = \"This provider only throws exceptions\";\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/throwing\/throwing.lookups.provider\/impl\/ThrowingLookupsProviderImpl.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+*\/\n+\n+import java.net.spi.InetAddressResolverProvider;\n+\n+module throwing.lookups.provider {\n+    exports impl;\n+    provides InetAddressResolverProvider with impl.ThrowingLookupsProviderImpl;\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/throwing\/throwing.lookups.provider\/module-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.InetAddress;\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertThrows;\n+\n+\/*\n+ * @test\n+ * @summary Test that InetAddressResolverProvider implementation can be installed to a class path.\n+ * @library ..\/..\/lib\n+ * @build test.library\/testlib.ResolutionRegistry ClasspathResolverProviderImpl\n+ * @run testng\/othervm ClasspathProviderTest\n+ *\/\n+\n+public class ClasspathProviderTest {\n+\n+    @Test\n+    public void testResolution() throws Exception {\n+        InetAddress inetAddress = InetAddress.getByName(\"classpath-provider-test.org\");\n+        System.err.println(\"Resolved address:\" + inetAddress);\n+\n+        if (!ClasspathResolverProviderImpl.registry.containsAddressMapping(inetAddress)) {\n+            throw new RuntimeException(\"InetAddressResolverProvider was not properly installed\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/serviceProviderOriginType\/classpath\/ClasspathProviderTest.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.net.spi.InetAddressResolverProvider;\n+import java.net.spi.InetAddressResolver;\n+import java.net.spi.InetAddressResolver.LookupPolicy;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import java.util.stream.Stream;\n+\n+import testlib.ResolutionRegistry;\n+\n+public class ClasspathResolverProviderImpl extends InetAddressResolverProvider {\n+\n+    public static ResolutionRegistry registry = new ResolutionRegistry();\n+    private static List<LookupPolicy> LOOKUP_HISTORY = Collections.synchronizedList(new ArrayList<>());\n+    private static Logger LOGGER = Logger.getLogger(ClasspathResolverProviderImpl.class.getName());\n+\n+    @Override\n+    public InetAddressResolver get(Configuration configuration) {\n+        System.out.println(\"The following provider will be used by current test:\" + this.getClass().getCanonicalName());\n+        return new InetAddressResolver() {\n+            @Override\n+            public Stream<InetAddress> lookupByName(String host, LookupPolicy lookupPolicy) throws UnknownHostException {\n+                LOGGER.info(\"Looking-up addresses for '\" + host + \"'. Lookup characteristics:\" +\n+                        Integer.toString(lookupPolicy.characteristics(), 2));\n+                LOOKUP_HISTORY.add(lookupPolicy);\n+                return registry.lookupHost(host, lookupPolicy);\n+            }\n+\n+            @Override\n+            public String lookupByAddress(byte[] addr) throws UnknownHostException {\n+                LOGGER.info(\"Looking host name for the following address:\" + ResolutionRegistry.addressBytesToString(addr));\n+                return registry.lookupAddress(addr);\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"classpathINSP\";\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/serviceProviderOriginType\/classpath\/ClasspathResolverProviderImpl.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+ClasspathResolverProviderImpl\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/serviceProviderOriginType\/classpath\/META-INF\/services\/java.net.spi.InetAddressResolverProvider","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+# Test data file for classpath origin type tests.\n+# Format: <IP address> <Host Name>\n+# If multiple IP addresses are required for host:\n+#    multiple lines could be added\n+\n+1.2.3.4    classpath-provider-test.org\n+[ca:fe:ba:be::1] classpath-provider-test.org\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/serviceProviderOriginType\/classpath\/addresses.txt","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.InetAddress;\n+\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @summary Test that implementation of InetAddressResolverProvider can be installed to a module path.\n+ * @library ..\/..\/lib ..\/..\/providers\/simple\n+ * @build test.library\/testlib.ResolutionRegistry simple.provider\/impl.SimpleResolverProviderImpl\n+ *        ModularProviderTest\n+ * @run testng\/othervm ModularProviderTest\n+ *\/\n+\n+\n+public class ModularProviderTest {\n+\n+    @Test\n+    public void testResolution() throws Exception {\n+        InetAddress inetAddress = InetAddress.getByName(\"modular-provider-test.org\");\n+        System.err.println(\"Resolved address:\" + inetAddress);\n+\n+        if (!impl.SimpleResolverProviderImpl.registry.containsAddressMapping(inetAddress)) {\n+            throw new RuntimeException(\"InetAddressResolverProvider was not properly installed\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/serviceProviderOriginType\/module\/ModularProviderTest.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+# Test data file for tests in modularTests directory\n+# Format: <IP address> <Host Name>\n+# If multiple IP addresses are required for host:\n+#    multiple lines could be added\n+\n+1.2.3.4    modular-provider-test.org\n+[ca:fe:ba:be::1] modular-provider-test.org\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/serviceProviderOriginType\/module\/addresses.txt","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -55,1 +55,1 @@\n- * @run testng TransferTo\n+ * @run testng\/othervm\/timeout=180 TransferTo\n@@ -141,14 +141,28 @@\n-        \/\/ preparing two temporary files which will be compared at the end of the test\n-        Path sourceFile = Files.createTempFile(null, null);\n-        Path targetFile = Files.createTempFile(null, null);\n-\n-        \/\/ writing 3 GB of random bytes into source file\n-        for (int i = 0; i < NUM_WRITES; i++)\n-            Files.write(sourceFile, createRandomBytes(BYTES_PER_WRITE, 0), StandardOpenOption.APPEND);\n-\n-        \/\/ performing actual transfer, effectively by multiple invocations of Filechannel.transferTo(FileChannel)\n-        long count;\n-        try (InputStream inputStream = Channels.newInputStream(FileChannel.open(sourceFile));\n-                OutputStream outputStream = Channels\n-                        .newOutputStream(FileChannel.open(targetFile, StandardOpenOption.WRITE))) {\n-            count = inputStream.transferTo(outputStream);\n+        Path sourceFile = Files.createTempFile(\"test2GBSource\", null);\n+        try {\n+            \/\/ preparing two temporary files which will be compared at the end of the test\n+            Path targetFile = Files.createTempFile(\"test2GBtarget\", null);\n+            try {\n+                \/\/ writing 3 GB of random bytes into source file\n+                for (int i = 0; i < NUM_WRITES; i++)\n+                    Files.write(sourceFile, createRandomBytes(BYTES_PER_WRITE, 0), StandardOpenOption.APPEND);\n+\n+                \/\/ performing actual transfer, effectively by multiple invocations of Filechannel.transferTo(FileChannel)\n+                long count;\n+                try (InputStream inputStream = Channels.newInputStream(FileChannel.open(sourceFile));\n+                     OutputStream outputStream = Channels\n+                             .newOutputStream(FileChannel.open(targetFile, StandardOpenOption.WRITE))) {\n+                    count = inputStream.transferTo(outputStream);\n+                }\n+\n+                \/\/ comparing reported transferred bytes, must be 3 GB\n+                assertEquals(count, BYTES_WRITTEN);\n+\n+                \/\/ comparing content of both files, failing in case of any difference\n+                assertEquals(Files.mismatch(sourceFile, targetFile), -1);\n+\n+            } finally {\n+                 Files.delete(targetFile);\n+            }\n+        } finally {\n+            Files.delete(sourceFile);\n@@ -156,6 +170,0 @@\n-\n-        \/\/ comparing reported transferred bytes, must be 3 GB\n-        assertEquals(count, BYTES_WRITTEN);\n-\n-        \/\/ comparing content of both files, failing in case of any difference\n-        assertEquals(Files.mismatch(sourceFile, targetFile), -1);\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/TransferTo.java","additions":29,"deletions":21,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,1 +161,1 @@\n-            s.setSoTimeout(1000);\n+            s.setSoTimeout(60_000);\n@@ -174,1 +174,1 @@\n-            s.setSoTimeout(5000);\n+            s.setSoTimeout(60_000);\n@@ -186,1 +186,1 @@\n-            s.setSoTimeout(1000);\n+            s.setSoTimeout(500);\n@@ -199,1 +199,1 @@\n-            s.setSoTimeout(60*1000);\n+            s.setSoTimeout(60_000);\n@@ -213,1 +213,1 @@\n-                s.setSoTimeout(60*1000);\n+                s.setSoTimeout(60_000);\n@@ -231,1 +231,1 @@\n-                s.setSoTimeout(60*1000);\n+                s.setSoTimeout(60_000);\n@@ -399,1 +399,1 @@\n-            s.setSoTimeout(60*1000);\n+            s.setSoTimeout(60_000);\n@@ -424,1 +424,1 @@\n-            s.setSoTimeout(60*1000);\n+            s.setSoTimeout(60_000);\n@@ -439,1 +439,1 @@\n-                s.setSoTimeout(60*1000);\n+                s.setSoTimeout(60_000);\n","filename":"test\/jdk\/java\/nio\/channels\/SocketChannel\/AdaptorStreams.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.nio.channels.FileChannel;\n@@ -176,0 +177,10 @@\n+    @Override\n+    public FileChannel newFileChannel(Path file,\n+                                      Set<? extends OpenOption> options,\n+                                      FileAttribute<?>... attrs)\n+        throws IOException\n+    {\n+        Path delegate = theFileSystem.unwrap(file);\n+        return defaultProvider.newFileChannel(delegate, options, attrs);\n+    }\n+\n","filename":"test\/jdk\/java\/nio\/file\/spi\/TestProvider.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.util.concurrent.Callable;\n@@ -41,2 +42,2 @@\n-        String result = (String)Subject.doAs(s, new PrivilegedAction() {\n-            public Object run() {\n+        String result = Subject.callAs(s, new Callable<String>() {\n+            public String call() {\n@@ -45,3 +46,2 @@\n-                Subject doAsSubject =\n-                        Subject.getSubject(AccessController.getContext());\n-                if (doAsSubject == null) {\n+                Subject callAsSubject = Subject.current();\n+                if (callAsSubject == null) {\n@@ -50,1 +50,1 @@\n-                    System.out.println(doAsSubject);\n+                    System.out.println(callAsSubject);\n@@ -59,2 +59,1 @@\n-                        Subject doPrivSubject =\n-                            Subject.getSubject(AccessController.getContext());\n+                        Subject doPrivSubject = Subject.current();\n@@ -82,2 +81,1 @@\n-                            Subject doPrivSubject = Subject.getSubject\n-                                (AccessController.getContext());\n+                            Subject doPrivSubject = Subject.current();\n","filename":"test\/jdk\/java\/security\/AccessController\/PreserveCombiner.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/**\n+ * @test\n+ * @bug 8276186\n+ * @summary Checks whether getAvailableLocales() returns at least Locale.ROOT and\n+ *      Locale.US instances.\n+ * @run testng\/othervm -Djava.locale.providers=COMPAT RequiredAvailableLocalesTest\n+ * @run testng\/othervm -Djava.locale.providers=CLDR RequiredAvailableLocalesTest\n+ *\/\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.text.*;\n+import java.time.format.DecimalStyle;\n+import java.util.*;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertTrue;\n+\n+@Test\n+public class RequiredAvailableLocalesTest {\n+\n+    private static final Set<Locale> REQUIRED_LOCALES = Set.of(Locale.ROOT, Locale.US);\n+    private static final MethodType ARRAY_RETURN_TYPE = MethodType.methodType(Locale.class.arrayType());\n+    private static final MethodType SET_RETURN_TYPE = MethodType.methodType(Set.class);\n+\n+    @DataProvider\n+    public Object[][] availableLocalesClasses() {\n+        return new Object[][] {\n+            {BreakIterator.class, ARRAY_RETURN_TYPE},\n+            {Calendar.class, ARRAY_RETURN_TYPE},\n+            {Collator.class, ARRAY_RETURN_TYPE},\n+            {DateFormat.class, ARRAY_RETURN_TYPE},\n+            {DateFormatSymbols.class, ARRAY_RETURN_TYPE},\n+            {DecimalFormatSymbols.class, ARRAY_RETURN_TYPE},\n+            {DecimalStyle.class, SET_RETURN_TYPE},\n+            {Locale.class, ARRAY_RETURN_TYPE},\n+            {NumberFormat.class, ARRAY_RETURN_TYPE},\n+        };\n+    }\n+\n+    @Test (dataProvider = \"availableLocalesClasses\")\n+    public void checkRequiredLocales(Class<?> c, MethodType mt) throws Throwable {\n+        var ret = MethodHandles.lookup().findStatic(c, \"getAvailableLocales\", mt).invoke();\n+\n+        if (ret instanceof Locale[] a) {\n+            assertTrue(Arrays.asList(a).containsAll(REQUIRED_LOCALES));\n+        } else if (ret instanceof Set<?> s) {\n+            assertTrue(s.containsAll(REQUIRED_LOCALES));\n+        } else {\n+            throw new RuntimeException(\"return type mismatch\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Locale\/RequiredAvailableLocalesTest.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8000354 8000685 8004371 8043119\n+ * @bug 8000354 8000685 8004371 8043119 8276207\n@@ -141,0 +141,1 @@\n+        props.put(\"k6\", \"\\uD834\\uDD1E\");\n@@ -246,0 +247,25 @@\n+    \/**\n+     * Test loadFromXML with supplementary characters\n+     *\/\n+    static void testLoadWithSupplementaryCharacters() throws IOException {\n+        System.out.println(\"testLoadWithSupplementaryCharacters\");\n+\n+        Properties expected = new Properties();\n+        expected.put(\"\\uD834\\uDD1E\", \"\\uD834\\uDD1E\");\n+\n+        String s = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\" +\n+                   \"<!DOCTYPE properties SYSTEM \\\"http:\/\/java.sun.com\/dtd\/properties.dtd\\\">\" +\n+                   \"<properties>\" +\n+                   \"<entry key=\\\"&#119070;\\\">&#x1d11e;<\/entry>\" +\n+                   \"<\/properties>\";\n+\n+        ByteArrayInputStream in = new ByteArrayInputStream(s.getBytes(\"UTF-8\"));\n+        Properties props = new Properties();\n+        props.loadFromXML(in);\n+\n+        if (!props.equals(expected)) {\n+            System.err.println(\"loaded: \" + props + \", expected: \" + expected);\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+    }\n+\n@@ -257,0 +283,1 @@\n+        testLoadWithSupplementaryCharacters();\n","filename":"test\/jdk\/java\/util\/Properties\/LoadAndStoreXML.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-    private final CountDownLatch serverCondition = new CountDownLatch(1);\n+    protected final CountDownLatch serverCondition = new CountDownLatch(1);\n@@ -218,1 +218,1 @@\n-    private final CountDownLatch clientCondition = new CountDownLatch(1);\n+    protected final CountDownLatch clientCondition = new CountDownLatch(1);\n@@ -485,1 +485,9 @@\n-    private static final boolean separateServerThread = false;\n+    private final boolean separateServerThread;\n+\n+    public SSLSocketTemplate() {\n+        this(false);\n+    }\n+\n+    public SSLSocketTemplate(boolean sepSrvThread) {\n+        this.separateServerThread = sepSrvThread;\n+    }\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLSocketTemplate.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.security.auth.Subject;\n+import java.security.AccessController;\n+import java.security.Principal;\n+import java.security.PrivilegedAction;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\/*\n+ * @test\n+ * @bug 8267108\n+ * @summary confirm current subject specification\n+ * @run main\/othervm\n+ *      -Djdk.security.auth.subject.useTL=false -Dtest=both CurrentSubject\n+ * @run main\/othervm\n+ *      -Djdk.security.auth.subject.useTL=true -Dtest=old CurrentSubject\n+ * @run main\/othervm\n+ *      -Djdk.security.auth.subject.useTL=true -Dtest=new CurrentSubject\n+ *\/\n+public class CurrentSubject {\n+\n+    static final boolean TEST_NEW = !System.getProperty(\"test\").equals(\"old\");\n+    static final boolean TEST_OLD = !System.getProperty(\"test\").equals(\"new\");\n+\n+    static transient boolean failed = false;\n+    static CountDownLatch cl = new CountDownLatch(1);\n+    static AtomicInteger count = new AtomicInteger();\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ At the beginning, current subject is null\n+        test(\"\", null);\n+        cl.await();\n+        if (failed) {\n+            throw new Exception(\"Failed\");\n+        }\n+    }\n+\n+    \/**\n+     * Ensure the current subject is the expected Subject object.\n+     *\n+     * @param label label to print out\n+     * @param expected the expected Subject\n+     *\/\n+    synchronized static void check(String label, Subject expected) {\n+        Subject cas = Subject.current();\n+        Subject accs = Subject.getSubject(AccessController.getContext());\n+        if (TEST_NEW && TEST_OLD && cas != accs) {\n+            failed = true;\n+            System.out.println(label + \": current \" + s2s(cas)\n+                    + \" but getSubject is \" + s2s(accs));\n+        }\n+        Subject interested = TEST_NEW ? cas : accs;\n+        if (interested != expected) {\n+            failed = true;\n+            System.out.println(label + \": expected \" + s2s(expected)\n+                    + \" but see \" + s2s(interested));\n+        } else {\n+            System.out.println(label + \": \" + s2s(expected));\n+        }\n+    }\n+\n+    \/**\n+     * Recursively testing on current subject with getAs() and thread creations.\n+     *\n+     * @param name the current label\n+     * @param expected the expected Subject\n+     *\/\n+    static Void test(String name, Subject expected) {\n+        \/\/ Now it's the expected current subject\n+        check(\" \".repeat(name.length()) + \"-> \" + name, expected);\n+        \/\/ Recursively check, do not go infinity\n+        if (name.length() < 4) {\n+            Subject another = new Subject();\n+            another.getPrincipals().add(new RawPrincipal(name + \"d\"));\n+            \/\/ run with a new subject, inside current subject will be the new subject\n+            if (TEST_NEW) Subject.callAs(another, () -> test(name + 'c', another));\n+            if (TEST_OLD) Subject.doAs(another, (PrivilegedAction<Void>) () -> test(name + 'd', another));\n+            \/\/ run with null, inside current subject will be null\n+            if (TEST_NEW) Subject.callAs(null, () -> test(name + 'C', null));\n+            if (TEST_OLD) Subject.doAs(null, (PrivilegedAction<Void>) () -> test(name + 'D', null));\n+            \/\/ new thread, inside current subject is unchanged\n+            count.incrementAndGet();\n+            new Thread(() -> {\n+                try {\n+                    test(name + 't', expected);\n+                    try {\n+                        Thread.sleep(500);\n+                    } catch (Exception e) {\n+                        throw new AssertionError(e);\n+                    }\n+                    \/\/ by this time, parent thread should have exited the\n+                    \/\/ action and current subject reset, but here\n+                    \/\/ current subject unchanged.\n+                    test(name + 'T', expected);\n+                } finally {\n+                    var n = count.decrementAndGet();\n+                    if (n == 0) {\n+                        cl.countDown();\n+                    }\n+                    assert n >= 0;\n+                }\n+            }).start();\n+        }\n+        \/\/ Now it's reset to original\n+        check(\" \".repeat(name.length()) + \"<- \" + name, expected);\n+        return null;\n+    }\n+\n+    static class RawPrincipal implements Principal {\n+\n+        String name;\n+        RawPrincipal(String name) {\n+            this.name = name;\n+        }\n+        @Override\n+        public String getName() {\n+            return name;\n+        }\n+    }\n+\n+    static String s2s(Subject s) {\n+        return s == null ? null\n+                : s.getPrincipals().iterator().next().getName();\n+    }\n+}\n","filename":"test\/jdk\/javax\/security\/auth\/Subject\/CurrentSubject.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,4 +29,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.security.PrivilegedExceptionAction;\n@@ -47,3 +43,2 @@\n-            Subject.doAs(subject, (PrivilegedExceptionAction<Integer>)() -> {\n-                AccessControlContext c1 = AccessController.getContext();\n-                Subject s = Subject.getSubject(c1);\n+            Subject.callAs(subject, () -> {\n+                Subject s = Subject.current();\n","filename":"test\/jdk\/javax\/security\/auth\/Subject\/DoAs.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8267108\n+ * @library \/test\/lib\n+ * @summary Check that callAs and doAs throw the specified exceptions\n+ * @run main\/othervm -Djava.security.manager=allow -Djdk.security.auth.subject.useTL=true Exceptions\n+ * @run main\/othervm -Djava.security.manager=allow -Djdk.security.auth.subject.useTL=false Exceptions\n+ *\/\n+import jdk.test.lib.Asserts;\n+\n+import javax.security.auth.Subject;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletionException;\n+\n+public class Exceptions {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ Checked exceptions are always wrapped\n+        new TestCase(() -> { throw new Exception(\"Hi\"); })\n+                .testDoAs(PrivilegedActionException.class, Exception.class)\n+                .testCallAs(CompletionException.class, Exception.class);\n+        \/\/ PrivilegedActionException itself is checked\n+        new TestCase(() -> { throw new PrivilegedActionException(new Exception(\"Hi\")); })\n+                .testDoAs(PrivilegedActionException.class, PrivilegedActionException.class, Exception.class)\n+                .testCallAs(CompletionException.class, PrivilegedActionException.class, Exception.class);\n+\n+        \/\/ Unchecked exception: rethrown by doAs(), wrapped by callAs()\n+        new TestCase(() -> { throw new RuntimeException(\"Hi\"); })\n+                .testDoAs(RuntimeException.class)\n+                .testCallAs(CompletionException.class, RuntimeException.class);\n+        \/\/ CompletionException itself is unchecked\n+        new TestCase(() -> { throw new CompletionException(new Exception(\"Hi\")); })\n+                .testDoAs(CompletionException.class, Exception.class)\n+                .testCallAs(CompletionException.class, CompletionException.class, Exception.class);\n+    }\n+\n+    static class TestCase {\n+\n+        final Callable<Void> action;\n+        TestCase(Callable<Void> action) {\n+            this.action = action;\n+        }\n+\n+        TestCase testDoAs(Class<?>... exceptions) {\n+            return test(true, exceptions);\n+        }\n+\n+        TestCase testCallAs(Class<?>... exceptions) {\n+            return test(false, exceptions);\n+        }\n+\n+        \/\/ Perform the action in doAs() or callAs() and inspect\n+        \/\/ the exception (and its causes, recursively) it throws\n+        private TestCase test(boolean doAs, Class<?>... exceptions) {\n+            int pos = 0;\n+            try {\n+                if (doAs) {\n+                    Subject.doAs(null, (PrivilegedExceptionAction<Object>) action::call);\n+                } else {\n+                    Subject.callAs(null, action::call);\n+                }\n+            } catch (Exception e) {\n+                while (e != null) {\n+                    Asserts.assertEQ(e.getClass(), exceptions[pos++]);\n+                    e = (Exception) e.getCause();\n+                }\n+            }\n+            \/\/ Make sure the list is the exact size\n+            Asserts.assertTrue(pos == exceptions.length);\n+            return this;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/security\/auth\/Subject\/Exceptions.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.security.auth.Subject;\n+import javax.security.auth.x500.X500Principal;\n+import java.security.AccessControlContext;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+\n+\/*\n+ * @test\n+ * @bug 8267108\n+ * @summary confirm current installed subject specification\n+ * @run main\/othervm -Djava.security.manager=allow FromACC\n+ * @run main\/othervm -Djava.security.manager=disallow FromACC\n+ *\/\n+public class FromACC {\n+    public static void main(String[] args) throws Exception {\n+        var n = Subject.doAs(from(\"a\"), (PrivilegedAction<AccessControlContext>)\n+                () -> AccessController.getContext());\n+        if (!get(Subject.getSubject(n)).equals(\"CN=a\")) {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    static Subject from(String name) {\n+        Subject s = new Subject();\n+        s.getPrincipals().add(new X500Principal(\"CN=\" + name));\n+        return s;\n+    }\n+\n+    static String get(Subject s) {\n+        if (s == null) {\n+            return \"none\";\n+        }\n+        var v = s.getPrincipals(X500Principal.class);\n+        if (v == null || v.isEmpty()) {\n+            return \"none\";\n+        } else {\n+            return v.iterator().next().getName();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/security\/auth\/Subject\/FromACC.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.security.PrivilegedAction;\n@@ -34,0 +33,1 @@\n+import java.util.concurrent.Callable;\n@@ -55,1 +55,1 @@\n-            Subject.doAs(\n+            Subject.callAs(\n@@ -57,3 +57,3 @@\n-                new PrivilegedAction() {\n-                    public Object run() {\n-                        return Subject.doAs(\n+                new Callable() {\n+                    public Object call() {\n+                        return Subject.callAs(\n@@ -65,2 +65,2 @@\n-                            new PrivilegedAction() {\n-                                public Object run() {\n+                            new Callable() {\n+                                public Object call() {\n","filename":"test\/jdk\/javax\/security\/auth\/Subject\/Synch.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,247 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import com.sun.jdi.Bootstrap;\n-import com.sun.jdi.VMDisconnectedException;\n-import com.sun.jdi.VirtualMachine;\n-import com.sun.jdi.connect.Connector;\n-import com.sun.jdi.connect.LaunchingConnector;\n-import com.sun.jdi.event.Event;\n-import com.sun.jdi.event.EventSet;\n-import com.sun.jdi.event.MethodEntryEvent;\n-import com.sun.jdi.request.MethodEntryRequest;\n-\n-import java.security.AlgorithmParameters;\n-import java.security.KeyPair;\n-import java.security.KeyPairGenerator;\n-import java.security.SecureRandom;\n-import java.security.Signature;\n-import java.security.SignatureException;\n-import java.security.interfaces.ECPrivateKey;\n-import java.security.interfaces.ECPublicKey;\n-import java.security.spec.ECGenParameterSpec;\n-import java.security.spec.ECParameterSpec;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Random;\n-\n-\/*\n- * @test\n- * @bug 8237218 8239928\n- * @modules jdk.crypto.ec\n- *          jdk.jdi\n- * @requires os.family != \"windows\"\n- * @run main ECDSAJavaVerify debug\n- * @summary Support NIST Curves verification in java implementation.\n- *  This test does not run stable on Windows. VMDisconnectedException\n- *  might not be thrown at all.\n- *\/\n-\n-\/\/ ATTENTION: This test depends on method names inside the non-exported\n-\/\/ class sun.security.ec.ECDSASignature.\n-public class ECDSAJavaVerify {\n-\n-    static final String[] ALL_ALGS = new String[] {\n-            \"SHA1withECDSA\", \"SHA256withECDSA\", \"SHA384withECDSA\", \"SHA512withECDSA\"};\n-\n-    static final String[] ALL_CURVES = new String[] {\n-            \"secp256r1\", \"secp384r1\", \"secp521r1\"};\n-\n-    public static void main(String[] args) throws Exception {\n-        if (args.length == 1) {\n-            \/\/ Debugging a new process with no arg\n-            debug();\n-        } else if (args.length == 3) {\n-            \/\/ If one test case fail, re-run it with first 3 columns\n-            new Test().run(Integer.parseInt(args[0]), args[1], args[2]);\n-        } else {\n-            \/\/ Run all test cases\n-            Test t = new Test();\n-            Random r = new Random();\n-\n-            for (String sigAlg : ALL_ALGS) {\n-                for (String curve : ALL_CURVES) {\n-                    t.run(r.nextInt(1000000), sigAlg, curve);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void debug() throws Exception {\n-\n-        LaunchingConnector launchingConnector = Bootstrap\n-                .virtualMachineManager().defaultConnector();\n-\n-        Map<String, Connector.Argument> arguments\n-                = launchingConnector.defaultArguments();\n-        arguments.get(\"main\").setValue(ECDSAJavaVerify.class.getName());\n-        arguments.get(\"options\").setValue(\n-                \"-cp \" + System.getProperty(\"test.classes\"));\n-        VirtualMachine vm = launchingConnector.launch(arguments);\n-\n-        MethodEntryRequest req = vm.eventRequestManager()\n-                .createMethodEntryRequest();\n-        req.addClassFilter(\"sun.security.ec.ECDSASignature\");\n-        req.enable();\n-\n-        int numberOfTests = ALL_ALGS.length * ALL_CURVES.length * 2;\n-\n-        \/\/ Expected methods to call. 'J' for java impl, 'N' for native impl\n-        char[] expected = new char[numberOfTests];\n-\n-        int pos = 0;\n-        for (String dummy : ALL_ALGS) {\n-            for (String curve : ALL_CURVES) {\n-                char caller = 'J';\n-                \/\/ For each case, Signature::verify is called twice\n-                expected[pos++] = caller;\n-                expected[pos++] = caller;\n-            }\n-        }\n-\n-        \/\/ Test result\n-        \/\/ '.': not run yet\n-        \/\/ '-': enter engineVerify\n-        \/\/ 'v': expected impl called\n-        \/\/ 'x': unexpected impl called\n-        \/\/ Note: some error cases fail before any impl called. Ex: if there\n-        \/\/ is a DER encoding error.\n-        char[] result = new char[numberOfTests];\n-        Arrays.fill(result, '.');\n-\n-        String stdout, stderr;\n-\n-        try {\n-            EventSet eventSet;\n-            pos = -1; \/\/ will become 0 when entering 'engineVerify'\n-            while ((eventSet = vm.eventQueue().remove()) != null) {\n-                for (Event event : eventSet) {\n-                    if (event instanceof MethodEntryEvent) {\n-                        MethodEntryEvent e = (MethodEntryEvent)event;\n-                        switch (e.method().name()) {\n-                            case \"engineVerify\":\n-                                result[++pos] = '-';\n-                                break;\n-                            case \"verifySignedDigestImpl\": \/\/ the java impl\n-                                result[pos] = expected[pos] != 'J' ? 'x' : 'v';\n-                                break;\n-                        }\n-                    }\n-                    vm.resume();\n-                }\n-            }\n-        } catch (VMDisconnectedException e) {\n-            System.out.println(\"Virtual Machine is disconnected.\");\n-        } finally {\n-            stderr = new String(vm.process().getErrorStream().readAllBytes());\n-            stdout = new String(vm.process().getInputStream().readAllBytes());\n-        }\n-\n-        int exitCode = vm.process().waitFor();\n-        System.out.println(\"  exit: \" + exitCode);\n-        System.out.println(\"stderr:\\n\" + stderr);\n-        System.out.println(\"stdout:\\n\" + stdout);\n-\n-        String sResult = new String(result);\n-\n-        System.out.println(\" Cases: \" + new String(expected));\n-        System.out.println(\"Result: \" + sResult);\n-\n-        if (pos != numberOfTests - 1 || sResult.contains(\"x\")\n-                || sResult.contains(\".\")) {\n-            throw new Exception(\"Unexpected result\");\n-        }\n-\n-        if (stdout.contains(\"fail\") || exitCode != 0) {\n-            throw new Exception(\"Test failed\");\n-        }\n-    }\n-\n-    static class Test {\n-\n-        public boolean run(int seed, String sigAlg, String curve)\n-                throws Exception {\n-\n-            \/\/ A determined SecureRandom based on seed. If there is anything\n-            \/\/ wrong, we can reproduce the problem using the seed.\n-            Random r = new Random(seed);\n-            SecureRandom rand = new SecureRandom() {\n-                @Override\n-                public void nextBytes(byte[] bytes) {\n-                    r.nextBytes(bytes);\n-                }\n-            };\n-\n-            AlgorithmParameters ap = AlgorithmParameters.getInstance(\"EC\", \"SunEC\");\n-            ap.init(new ECGenParameterSpec(curve));\n-            ECParameterSpec spec = ap.getParameterSpec(ECParameterSpec.class);\n-\n-            KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"EC\", \"SunEC\");\n-            kpg.initialize(spec, rand);\n-            KeyPair kp = kpg.generateKeyPair();\n-            ECPrivateKey ecPrivateKey = (ECPrivateKey) kp.getPrivate();\n-            ECPublicKey ecPublicKey = (ECPublicKey) kp.getPublic();\n-\n-            Signature s1 = Signature.getInstance(sigAlg, \"SunEC\");\n-            s1.initSign(ecPrivateKey, rand);\n-            byte[] msg = new byte[1234];\n-            rand.nextBytes(msg);\n-            s1.update(msg);\n-            byte[] sig = s1.sign();\n-\n-            Signature s2 = Signature.getInstance(sigAlg, \"SunEC\");\n-            s2.initVerify(ecPublicKey);\n-            s2.update(msg);\n-\n-            boolean result1 = s2.verify(sig);\n-\n-            s2.initVerify(ecPublicKey);\n-            \/\/ modify the signature in some random manner\n-            if (rand.nextInt(10) < 8) {\n-                sig[rand.nextInt(10000) % sig.length]\n-                        = (byte) rand.nextInt(10000);\n-            } else {\n-                int newLength = rand.nextInt(100);\n-                if (newLength == sig.length) {\n-                    newLength += 1 + rand.nextInt(2);\n-                }\n-                sig = Arrays.copyOf(sig, newLength);\n-            }\n-\n-            boolean result2;\n-            try {\n-                result2 = s2.verify(sig);\n-            } catch (SignatureException se) {\n-                result2 = false;\n-            }\n-\n-            boolean finalResult = result1 && !result2;\n-            System.out.printf(\"%10d %20s %20s -- %5s %5s -- %s\\n\",\n-                    seed, sigAlg, curve, result1, result2,\n-                    finalResult ? \"succeed\" : \"fail\");\n-\n-            return finalResult;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/security\/ec\/ECDSAJavaVerify.java","additions":0,"deletions":247,"binary":false,"changes":247,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-import java.security.PrivilegedExceptionAction;\n+import java.util.concurrent.Callable;\n@@ -62,2 +62,2 @@\n-        Subject.doAs(subj, new PrivilegedExceptionAction() {\n-            public Object run() throws Exception {\n+        Subject.callAs(subj, new Callable<>() {\n+            public Object call() throws Exception {\n","filename":"test\/jdk\/sun\/security\/krb5\/KrbCredSubKey.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -35,0 +33,2 @@\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletionException;\n@@ -125,2 +125,2 @@\n-            String result = Subject.doAs(\n-                    subj, new PrivilegedExceptionAction<String>() {\n+            String result = Subject.callAs(\n+                    subj, new Callable<String>() {\n@@ -128,1 +128,1 @@\n-                public String run() throws GSSException {\n+                public String call() throws GSSException {\n@@ -142,1 +142,1 @@\n-        } catch (PrivilegedActionException e) {\n+        } catch (CompletionException e) {\n","filename":"test\/jdk\/sun\/security\/krb5\/ServiceCredsCombination.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -58,0 +56,2 @@\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletionException;\n@@ -103,1 +103,1 @@\n-            out.cred = Subject.doAs(s, new PrivilegedExceptionAction<GSSCredential>() {\n+            out.cred = Subject.callAs(s, new Callable<GSSCredential>() {\n@@ -105,1 +105,1 @@\n-                public GSSCredential run() throws Exception {\n+                public GSSCredential call() throws Exception {\n@@ -114,2 +114,2 @@\n-        } catch (PrivilegedActionException pae) {\n-            throw pae.getException();\n+        } catch (CompletionException ce) {\n+            throw (Exception) ce.getCause();\n@@ -342,1 +342,1 @@\n-            return Subject.doAs(s, new PrivilegedExceptionAction<byte[]>() {\n+            return Subject.callAs(s, new Callable<byte[]>() {\n@@ -345,1 +345,1 @@\n-                public byte[] run() throws Exception {\n+                public byte[] call() throws Exception {\n@@ -349,2 +349,2 @@\n-        } catch (PrivilegedActionException pae) {\n-            throw pae.getException();\n+        } catch (CompletionException ce) {\n+            throw (Exception) ce.getCause();\n@@ -615,1 +615,1 @@\n-            GSSCredential creds = Subject.doAs(s, new PrivilegedExceptionAction<GSSCredential>() {\n+            GSSCredential creds = Subject.callAs(s, new Callable<GSSCredential>() {\n@@ -617,1 +617,1 @@\n-                public GSSCredential run() throws Exception {\n+                public GSSCredential call() throws Exception {\n@@ -634,2 +634,2 @@\n-        } catch (PrivilegedActionException pae) {\n-            Exception e = pae.getException();\n+        } catch (CompletionException ce) {\n+            Exception e = (Exception) ce.getCause();\n","filename":"test\/jdk\/sun\/security\/krb5\/auto\/Context.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,0 +86,2 @@\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletionException;\n@@ -378,3 +380,3 @@\n-        final PrivilegedExceptionAction<Object> test_action\n-                = new PrivilegedExceptionAction<Object>() {\n-            public Object run() throws Exception {\n+        final Callable<Object> test_action\n+                = new Callable<Object>() {\n+            public Object call() throws Exception {\n@@ -390,1 +392,1 @@\n-            Subject.doAs(subject, test_action);\n+            Subject.callAs(subject, test_action);\n@@ -393,1 +395,1 @@\n-        } catch (PrivilegedActionException e) {\n+        } catch (CompletionException e) {\n@@ -469,1 +471,1 @@\n-            cred = Subject.doAs(s, new PrivilegedExceptionAction<GSSCredential>() {\n+            cred = Subject.callAs(s, new Callable<GSSCredential>() {\n@@ -471,1 +473,1 @@\n-                public GSSCredential run() throws Exception {\n+                public GSSCredential call() throws Exception {\n@@ -497,6 +499,1 @@\n-                    c = Subject.doAs(s, new PrivilegedExceptionAction<GSSContext>() {\n-                        @Override\n-                        public GSSContext run() throws Exception {\n-                            return m.createContext(cred);\n-                        }\n-                    });\n+                    c = Subject.callAs(s, () -> m.createContext(cred));\n","filename":"test\/jdk\/sun\/security\/krb5\/auto\/HttpNegotiateServer.java","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import java.security.PrivilegedExceptionAction;\n@@ -75,2 +74,1 @@\n-        GSSCredential cred = Subject.doAs(c.s(),\n-                (PrivilegedExceptionAction<GSSCredential>)\n+        GSSCredential cred = Subject.callAs(c.s(),\n","filename":"test\/jdk\/sun\/security\/krb5\/auto\/LongLife.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,411 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\/\/\n+\n+\/*\n+ * @test\n+ * @bug 8274736\n+ * @summary Concurrent read\/close of SSLSockets causes SSLSessions to be\n+ *          invalidated unnecessarily\n+ * @library \/javax\/net\/ssl\/templates\n+ * @run main\/othervm NoInvalidateSocketException TLSv1.3\n+ * @run main\/othervm NoInvalidateSocketException TLSv1.2\n+ * @run main\/othervm -Djdk.tls.client.enableSessionTicketExtension=false\n+ *      NoInvalidateSocketException TLSv1.2\n+ *\/\n+\n+\n+\n+import java.io.*;\n+import javax.net.ssl.*;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+\n+public class NoInvalidateSocketException extends SSLSocketTemplate {\n+    private static final int ITERATIONS = 10;\n+\n+    \/\/ This controls how long the main thread waits before closing the socket.\n+    \/\/ This may need tweaking for different environments to get the timing\n+    \/\/ right.\n+    private static final int CLOSE_DELAY = 10;\n+\n+    private static SSLContext clientSSLCtx;\n+    private static SSLSocket theSSLSocket;\n+    private static SSLSession theSSLSession;\n+    private static InputStream theInputStream;\n+    private static String theSSLSocketHashCode;\n+    private static SSLSession lastSSLSession;\n+    private static final List<SSLSocket> serverCleanupList = new ArrayList<>();\n+    private static String tlsVersion = null;\n+\n+    private static int invalidSessCount = 0;\n+    private static volatile boolean readFromSocket = false;\n+    private static volatile boolean finished = false;\n+\n+    public static void main(String[] args) throws Exception {\n+        if (System.getProperty(\"javax.net.debug\") == null) {\n+            System.setProperty(\"javax.net.debug\", \"session\");\n+        }\n+\n+        if (args != null && args.length >= 1) {\n+            tlsVersion = args[0];\n+        }\n+\n+        new NoInvalidateSocketException(true).run();\n+        if (invalidSessCount > 0) {\n+            throw new RuntimeException(\"One or more sessions were improperly \" +\n+                    \"invalidated.\");\n+        }\n+    }\n+\n+    public NoInvalidateSocketException(boolean sepSrvThread) {\n+        super(sepSrvThread);\n+    }\n+\n+    @Override\n+    public boolean isCustomizedClientConnection() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void runClientApplication(int serverPort) {\n+        Thread.currentThread().setName(\"Main Client Thread\");\n+\n+        \/\/ Create the SSLContext we'll use for client sockets for the\n+        \/\/ duration of the test.\n+        try {\n+            clientSSLCtx = createClientSSLContext();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create client ctx\", e);\n+        }\n+\n+        \/\/ Create the reader thread\n+        ReaderThread readerThread = new ReaderThread();\n+        readerThread.setName(\"Client Reader Thread\");\n+        readerThread.start();\n+\n+        try {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                openSSLSocket();\n+                doHandshake();\n+                getInputStream();\n+                getAndCompareSession();\n+\n+                \/\/ Perform the Close\/Read MT collision\n+                readCloseMultiThreaded();\n+\n+                \/\/ Check to make sure that the initially negotiated session\n+                \/\/ remains intact.\n+                isSessionValid();\n+\n+                lastSSLSession = theSSLSession;\n+\n+                \/\/ Insert a short gap between iterations\n+                Thread.sleep(1000);\n+                System.out.println();\n+            }\n+        } catch (Exception e) {\n+            logToConsole(\"Unexpected Exception: \" + e);\n+        } finally {\n+            \/\/ Tell the reader thread to finish\n+            finished = true;\n+        }\n+    }\n+\n+    private void readCloseMultiThreaded() throws IOException,\n+            InterruptedException {\n+        \/\/ Tell the reader thread to start trying to read from this\n+        \/\/ socket\n+        readFromSocket = true;\n+\n+        \/\/ Short pause to give the reader thread time to start\n+        \/\/ reading.\n+        if (CLOSE_DELAY > 0) {\n+            Thread.sleep(CLOSE_DELAY);\n+        }\n+\n+        \/\/ The problem happens when the reader thread tries to read\n+        \/\/ from the socket while this thread is in the close() call\n+        closeSSLSocket();\n+\n+        \/\/ Pause to give the reader thread time to discover that the\n+        \/\/ socket is closed and throw a SocketException\n+        Thread.sleep(500);\n+    }\n+\n+    private class ReaderThread extends Thread {\n+        public void run() {\n+            \/\/ This thread runs in a tight loop until\n+            \/\/ readFromSocket == true\n+            while (!finished) {\n+                if (readFromSocket) {\n+                    int result = 0;\n+                    try {\n+                        \/\/ If the timing is just\n+                        \/\/ right, this will throw a SocketException\n+                        \/\/ and the SSLSession will be\n+                        \/\/ invalidated.\n+                        result = readFromSSLSocket();\n+                    } catch (Exception e) {\n+                        logToConsole(\"Exception reading from SSLSocket@\" +\n+                                theSSLSocketHashCode + \": \" + e);\n+                        e.printStackTrace(System.out);\n+\n+                        \/\/ Stop trying to read from\n+                        \/\/ the socket now\n+                        readFromSocket = false;\n+                    }\n+\n+                    if (result == -1) {\n+                        logToConsole(\"Reached end of stream reading from \" +\n+                                \"SSLSocket@\" + theSSLSocketHashCode);\n+\n+                        \/\/ Stop trying to read from\n+                        \/\/ the socket now\n+                        readFromSocket = false;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void openSSLSocket() throws IOException {\n+        theSSLSocket = (SSLSocket)clientSSLCtx.getSocketFactory().\n+                createSocket(serverAddress, serverPort);\n+        if (tlsVersion != null) {\n+            theSSLSocket.setEnabledProtocols(new String[] { tlsVersion });\n+        }\n+        theSSLSocketHashCode = String.format(\"%08x\", theSSLSocket.hashCode());\n+        logToConsole(\"Opened SSLSocket@\" + theSSLSocketHashCode);\n+    }\n+\n+    private void doHandshake() throws IOException {\n+        logToConsole(\"Started handshake on SSLSocket@\" +\n+                theSSLSocketHashCode);\n+        theSSLSocket.startHandshake();\n+        logToConsole(\"Finished handshake on SSLSocket@\" +\n+                theSSLSocketHashCode);\n+    }\n+\n+    private void getInputStream() throws IOException {\n+        theInputStream = theSSLSocket.getInputStream();\n+    }\n+\n+    private void getAndCompareSession() {\n+        theSSLSession = theSSLSocket.getSession();\n+\n+        \/\/ Have we opened a new session or re-used the last one?\n+        if (lastSSLSession == null ||\n+                !theSSLSession.equals(lastSSLSession)) {\n+            logToConsole(\"*** OPENED NEW SESSION ***: \" +\n+                    theSSLSession);\n+        } else {\n+            logToConsole(\"*** RE-USING PREVIOUS SESSION ***: \" +\n+                    theSSLSession + \")\");\n+        }\n+    }\n+\n+    private void closeSSLSocket() throws IOException {\n+        logToConsole(\"Closing SSLSocket@\" + theSSLSocketHashCode);\n+        theSSLSocket.close();\n+        logToConsole(\"Closed SSLSocket@\" + theSSLSocketHashCode);\n+    }\n+\n+    private int readFromSSLSocket() throws Exception {\n+        logToConsole(\"Started reading from SSLSocket@\" +\n+                theSSLSocketHashCode);\n+        int result = theInputStream.read();\n+        logToConsole(\"Finished reading from SSLSocket@\" +\n+                theSSLSocketHashCode + \": result = \" + result);\n+        return result;\n+    }\n+\n+    private void isSessionValid() {\n+        \/\/ Is the session still valid?\n+        if (theSSLSession.isValid()) {\n+            logToConsole(\"*** \" + theSSLSession + \" IS VALID ***\");\n+        } else {\n+            logToConsole(\"*** \" + theSSLSession + \" IS INVALID ***\");\n+            invalidSessCount++;\n+        }\n+    }\n+\n+    private static void logToConsole(String s) {\n+        System.out.println(System.nanoTime() + \": \" +\n+                Thread.currentThread().getName() + \": \" + s);\n+    }\n+\n+    @Override\n+    public void doServerSide() throws Exception {\n+        Thread.currentThread().setName(\"Server Listener Thread\");\n+        SSLContext context = createServerSSLContext();\n+        SSLServerSocketFactory sslssf = context.getServerSocketFactory();\n+        InetAddress serverAddress = this.serverAddress;\n+        SSLServerSocket sslServerSocket = serverAddress == null ?\n+                (SSLServerSocket)sslssf.createServerSocket(serverPort)\n+                : (SSLServerSocket)sslssf.createServerSocket();\n+        if (serverAddress != null) {\n+            sslServerSocket.bind(new InetSocketAddress(serverAddress,\n+                    serverPort));\n+        }\n+        configureServerSocket(sslServerSocket);\n+        serverPort = sslServerSocket.getLocalPort();\n+        logToConsole(\"Listening on \" + sslServerSocket.getLocalSocketAddress());\n+\n+        \/\/ Signal the client, the server is ready to accept connection.\n+        serverCondition.countDown();\n+\n+        \/\/ Try to accept a connection in 5 seconds.\n+        \/\/ We will do this in a loop until the client flips the\n+        \/\/ finished variable to true\n+        SSLSocket sslSocket;\n+\n+        int timeoutCount = 0;\n+        try {\n+            do {\n+                try {\n+                    sslSocket = (SSLSocket) sslServerSocket.accept();\n+                    timeoutCount = 0;   \/\/ Reset the timeout counter;\n+                    logToConsole(\"Accepted connection from \" +\n+                            sslSocket.getRemoteSocketAddress());\n+\n+                    \/\/ Add the socket to the cleanup list so it can get\n+                    \/\/ closed at the end of the test\n+                    serverCleanupList.add(sslSocket);\n+\n+                    boolean clientIsReady =\n+                            clientCondition.await(30L, TimeUnit.SECONDS);\n+                    if (clientIsReady) {\n+                        \/\/ Handle the connection in a new thread\n+                        ServerHandlerThread sht = null;\n+                        try {\n+                             sht = new ServerHandlerThread(sslSocket);\n+                             sht.start();\n+                        } finally {\n+                            if (sht != null) {\n+                                sht.join();\n+                            }\n+                        }\n+                    }\n+                } catch (SocketTimeoutException ste) {\n+                    timeoutCount++;\n+                    \/\/ If we are finished then we can return, otherwise\n+                    \/\/ check if we've timed out too many times (an exception\n+                    \/\/ case).  One way or the other we will exit eventually.\n+                    if (finished) {\n+                        return;\n+                    } else if (timeoutCount >= 3) {\n+                        logToConsole(\"Server accept timeout exceeded\");\n+                        throw ste;\n+                    }\n+                }\n+            } while (!finished);\n+        } finally {\n+            sslServerSocket.close();\n+            \/\/ run through the server cleanup list and close those sockets\n+            \/\/ as well.\n+            for (SSLSocket sock : serverCleanupList) {\n+                try {\n+                    if (sock != null) {\n+                        sock.close();\n+                    }\n+                } catch (IOException ioe) {\n+                    \/\/ Swallow these close failures as the server itself\n+                    \/\/ is shutting down anyway.\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void configureServerSocket(SSLServerSocket socket) {\n+        try {\n+            socket.setReuseAddress(true);\n+            socket.setSoTimeout(5000);\n+        } catch (SocketException se) {\n+            \/\/ Rethrow as unchecked to satisfy the override signature\n+            throw new RuntimeException(se);\n+        }\n+    }\n+\n+    @Override\n+    public void runServerApplication(SSLSocket sslSocket) {\n+        Thread.currentThread().setName(\"Server Reader Thread\");\n+        SSLSocket sock = null;\n+        sock = sslSocket;\n+        try {\n+            BufferedReader is = new BufferedReader(\n+                    new InputStreamReader(sock.getInputStream()));\n+            PrintWriter os = new PrintWriter(new BufferedWriter(\n+                    new OutputStreamWriter(sock.getOutputStream())));\n+\n+            \/\/ Only handle a single burst of data\n+            char[] buf = new char[1024];\n+            int dataRead = is.read(buf);\n+            logToConsole(String.format(\"Received: %d bytes of data\\n\",\n+                    dataRead));\n+\n+            os.println(\"Received connection from client\");\n+            os.flush();\n+        } catch (IOException ioe) {\n+            \/\/ Swallow these exceptions for this test\n+        }\n+    }\n+\n+    private class ServerHandlerThread extends Thread {\n+        SSLSocket sock;\n+        ServerHandlerThread(SSLSocket socket) {\n+            this.sock = Objects.requireNonNull(socket, \"Illegal null socket\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                runServerApplication(sock);\n+            } catch (Exception exc) {\n+                \/\/ Wrap inside an unchecked exception to satisfy Runnable\n+                throw new RuntimeException(exc);\n+            }\n+        }\n+\n+        void close() {\n+            try {\n+                sock.close();\n+            } catch (IOException e) {\n+                \/\/ swallow this exception\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/NoInvalidateSocketException.java","additions":411,"deletions":0,"binary":false,"changes":411,"status":"added"},{"patch":"@@ -50,0 +50,1 @@\n+        \"jaccessinspector-32\", \/\/ gui, don't test, win-32 only\n@@ -51,0 +52,1 @@\n+        \"jaccesswalker-32\", \/\/ gui, don't test, win-32 only\n","filename":"test\/jdk\/tools\/launcher\/HelpFlagsTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-             8242056 8261976\n+             8242056 8261976 8223358\n@@ -75,0 +75,1 @@\n+                    <ul class=\"sub-nav-list\">\n@@ -76,1 +77,4 @@\n-                    <li>Field&nbsp;|&nbsp;<\/li>\"\"\",\n+                    <li>Field&nbsp;|&nbsp;<\/li>\n+                    <li><a href=\"#annotation-interface-required-element-summary\">Required<\/a>&nbsp;|&nbsp;<\/li>\n+                    <li><a href=\"#annotation-interface-optional-element-summary\">Optional<\/a><\/li>\n+                    <\/ul>\"\"\",\n@@ -78,0 +82,1 @@\n+                    <ul class=\"sub-nav-list\">\n@@ -79,1 +84,3 @@\n-                    <li>Field&nbsp;|&nbsp;<\/li>\"\"\");\n+                    <li>Field&nbsp;|&nbsp;<\/li>\n+                    <li><a href=\"#annotation-interface-element-detail\">Element<\/a><\/li>\n+                    <\/ul>\"\"\");\n@@ -82,14 +89,64 @@\n-                    \"<!-- ============ ANNOTATION INTERFACE MEMBER DETAIL =========== -->\",\n-                    \"<ul class=\\\"member-list\\\">\",\n-                    \"<li>\",\n-                    \"\"\"\n-                        <section class=\"details\" id=\"annotation-interface-element-detail\">\"\"\",\n-                    \"<h2>Element Details<\/h2>\",\n-                    \"<\/a>\",\n-                    \"<ul class=\\\"member-list\\\">\",\n-                    \"<li>\",\n-                    \"\"\"\n-                        <section class=\"detail\" id=\"value()\">\"\"\",\n-                    \"<h3>value<\/h3>\\n\",\n-                    \"\"\"\n-                        <div class=\"member-signature\"><span class=\"return-type\">int<\/span>&nbsp;<span class=\"element-name\">value<\/span><\/div>\"\"\");\n+                \"\"\"\n+                    <section class=\"summary\">\n+                    <ul class=\"summary-list\">\n+                    <!-- =========== ANNOTATION INTERFACE REQUIRED MEMBER SUMMARY =========== -->\n+                    <li>\n+                    <section class=\"member-summary\" id=\"annotation-interface-required-element-summary\">\n+                    <h2>Required Element Summary<\/h2>\n+                    <div class=\"caption\"><span>Required Elements<\/span><\/div>\n+                    <div class=\"summary-table three-column-summary\">\n+                    <div class=\"table-header col-first\">Modifier and Type<\/div>\n+                    <div class=\"table-header col-second\">Required Element<\/div>\n+                    <div class=\"table-header col-last\">Description<\/div>\n+                    <div class=\"col-first even-row-color\"><code>int<\/code><\/div>\n+                    <div class=\"col-second even-row-color\"><code><a href=\"#value()\" class=\"member-name-link\">value<\/a><\/code><\/div>\n+                    <div class=\"col-last even-row-color\">&nbsp;<\/div>\n+                    <\/div>\n+                    <\/section>\n+                    <\/li>\n+                    <!-- =========== ANNOTATION INTERFACE OPTIONAL MEMBER SUMMARY =========== -->\n+                    <li>\n+                    <section class=\"member-summary\" id=\"annotation-interface-optional-element-summary\">\n+                    <h2>Optional Element Summary<\/h2>\n+                    <div class=\"caption\"><span>Optional Elements<\/span><\/div>\n+                    <div class=\"summary-table three-column-summary\">\n+                    <div class=\"table-header col-first\">Modifier and Type<\/div>\n+                    <div class=\"table-header col-second\">Optional Element<\/div>\n+                    <div class=\"table-header col-last\">Description<\/div>\n+                    <div class=\"col-first even-row-color\"><code>java.lang.String<\/code><\/div>\n+                    <div class=\"col-second even-row-color\"><code><a href=\"#optional()\" class=\"member-name-link\">optional<\/a><\/code><\/div>\n+                    <div class=\"col-last even-row-color\">&nbsp;<\/div>\n+                    <\/div>\n+                    <\/section>\n+                    <\/li>\n+                    <\/ul>\n+                    <\/section>\"\"\",\n+                \"\"\"\n+                    <section class=\"details\" id=\"annotation-interface-element-detail\">\n+                    <ul class=\"details-list\">\n+                    <!-- ============ ANNOTATION INTERFACE MEMBER DETAIL =========== -->\n+                    <li>\n+                    <section class=\"member-details\">\n+                    <h2>Element Details<\/h2>\n+                    <ul class=\"member-list\">\n+                    <li>\n+                    <section class=\"detail\" id=\"value()\">\n+                    <h3>value<\/h3>\n+                    <div class=\"member-signature\"><span class=\"return-type\">int<\/span>&nbsp;<span class=\"element-name\">value<\/span><\/div>\n+                    <\/section>\n+                    <\/li>\n+                    <li>\n+                    <section class=\"detail\" id=\"optional()\">\n+                    <h3>optional<\/h3>\n+                    <div class=\"member-signature\"><span class=\"return-type\">java.lang.String<\/span>&nbsp;<span class=\"element-name\">optional<\/span><\/div>\n+                    <dl class=\"notes\">\n+                    <dt>Default:<\/dt>\n+                    <dd>\"\"<\/dd>\n+                    <\/dl>\n+                    <\/section>\n+                    <\/li>\n+                    <\/ul>\n+                    <\/section>\n+                    <\/li>\n+                    <\/ul>\n+                    <\/section>\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testAnnotationTypes\/TestAnnotationTypes.java","additions":74,"deletions":17,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+    String optional() default \"\";\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testAnnotationTypes\/pkg\/AnnotationType.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -168,0 +168,1 @@\n+                \"--add-script\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHelpOption\/TestHelpOption.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,2 +27,4 @@\n- * @summary  Test the output for -header, -footer, -nooverview, -nodeprecatedlist, -nonavbar, -notree,\n- *           -stylesheetfile, --main-stylesheet, --add-stylesheet options.\n+ *           8275786\n+ * @summary  Test the output for -header, -footer, -nooverview, -nodeprecatedlist,\n+ *           -nonavbar, -notree, -stylesheetfile, --main-stylesheet, --add-stylesheet,\n+ *           --add-script options.\n@@ -181,0 +183,31 @@\n+    @Test\n+    public void testAdditionalScriptFile() {\n+        javadoc(\"-d\", \"out-additional-script\",\n+                \"--add-script\", new File(testSrc, \"additional-script-1.js\").getAbsolutePath(),\n+                \"--add-script\", new File(testSrc, \"additional-script-2.js\").getAbsolutePath(),\n+                \"-sourcepath\", testSrc,\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"script-dir\/additional-script-1.js\", true, \"Additional script file 1\");\n+        checkOutput(\"script-dir\/additional-script-2.js\", true, \"Additional script file 2\");\n+        checkOutput(\"pkg\/Foo.html\", true,\n+                \"\"\"\n+                    <script type=\"text\/javascript\" src=\"..\/script-dir\/additional-script-1.js\"><\/script>\n+                    <script type=\"text\/javascript\" src=\"..\/script-dir\/additional-script-2.js\"><\/script>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testInvalidAdditionalScriptFile() {\n+        javadoc(\"-d\", \"out-invalid-additional-script\",\n+                \"--add-script\", new File(testSrc, \"additional-script-3.js\").getAbsolutePath(),\n+                \"-sourcepath\", testSrc,\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+\n+        checkOutput(Output.OUT, true,\n+                \"error: File not found:\",\n+                \"additional-script-3.js\");\n+    }\n+\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOptions\/TestOptions.java","additions":35,"deletions":2,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,3 @@\n+\/\/ Additional script file 1\n+\n+console.log(\"hello world\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOptions\/additional-script-1.js","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+\/\/ Additional script file 2\n+\n+console.log(\"goodbye\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOptions\/additional-script-2.js","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug      8225055 8239804 8246774 8258338 8261976\n+ * @bug      8225055 8239804 8246774 8258338 8261976 8275199\n@@ -54,3 +54,1 @@\n-    \/\/ The following constants are set up for use with -linkoffline\n-    \/\/ (but note: JDK 11 does not include java.lang.Record, so expect\n-    \/\/ some 404 broken links until we can update this to a stable version.)\n+    \/\/ The following constants are set up for use with -linkoffline.\n@@ -58,1 +56,1 @@\n-        \"https:\/\/docs.oracle.com\/en\/java\/javase\/11\/docs\/api\";\n+        \"https:\/\/docs.oracle.com\/en\/java\/javase\/17\/docs\/api\";\n@@ -60,1 +58,1 @@\n-        Path.of(testSrc).resolve(\"jdk11\").toUri().toString();\n+        Path.of(testSrc).resolve(\"jdk17\").toUri().toString();\n@@ -394,1 +392,1 @@\n-    public void testExamples(Path base) throws IOException {\n+    public void testExamples(Path base) {\n@@ -397,1 +395,1 @@\n-                \"-sourcepath\", testSrc.toString(),\n+                \"-sourcepath\", testSrc,\n@@ -404,1 +402,1 @@\n-                \"-sourcepath\", testSrc.toString(),\n+                \"-sourcepath\", testSrc,\n@@ -563,0 +561,47 @@\n+\n+    @Test\n+    public void testSerializableType(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    \/**\n+                     * A point,\n+                     * @param x the x coord\n+                     * @param y the y coord\n+                     *\/\n+                    public record Point(int x, int y) implements java.io.Serializable { }\"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-quiet\", \"-noindex\", \"--no-platform-links\",\n+                src.resolve(\"Point.java\").toString());\n+        checkExit(Exit.OK);\n+\n+        checkOutput(Output.OUT, false,\n+                \"warning: no comment\");\n+\n+        checkOutput(\"serialized-form.html\", true,\n+                \"\"\"\n+                    <section class=\"serialized-class-details\" id=\"Point\">\n+                    <h3>Record Class&nbsp;<a href=\"Point.html\" title=\"class in Unnamed Package\">Point<\/a><\/h3>\n+                    <div class=\"type-signature\">class Point extends java.lang.Record implements java.io.Serializable<\/div>\n+                    <ul class=\"block-list\">\n+                    <li>\n+                    <section class=\"detail\">\n+                    <h4>Serialized Fields<\/h4>\n+                    <ul class=\"block-list\">\n+                    <li class=\"block-list\">\n+                    <h5>x<\/h5>\n+                    <pre>int x<\/pre>\n+                    <div class=\"block\">The field for the <a href=\".\/Point.html#param-x\"><code>x<\/code><\/a> record component.<\/div>\n+                    <\/li>\n+                    <li class=\"block-list\">\n+                    <h5>y<\/h5>\n+                    <pre>int y<\/pre>\n+                    <div class=\"block\">The field for the <a href=\".\/Point.html#param-y\"><code>y<\/code><\/a> record component.<\/div>\n+                    <\/li>\n+                    <\/ul>\n+                    <\/section>\n+                    <\/li>\n+                    <\/ul>\n+                    <\/section>\"\"\");\n+    }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testRecordTypes\/TestRecordTypes.java","additions":54,"deletions":9,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -5,0 +5,1 @@\n+java.lang.constant\n@@ -9,0 +10,1 @@\n+java.lang.runtime\n@@ -21,1 +23,0 @@\n-java.security.acl\n@@ -38,0 +39,1 @@\n+java.util.random\n@@ -134,0 +136,1 @@\n+javax.naming.ldap.spi\n@@ -141,1 +144,0 @@\n-java.rmi.activation\n@@ -222,0 +224,4 @@\n+module:jdk.incubator.foreign\n+jdk.incubator.foreign\n+module:jdk.incubator.vector\n+jdk.incubator.vector\n@@ -226,2 +232,0 @@\n-com.sun.javadoc\n-com.sun.tools.javadoc\n@@ -244,0 +248,1 @@\n+module:jdk.jpackage\n@@ -263,4 +268,2 @@\n-module:jdk.pack\n-module:jdk.scripting.nashorn\n-jdk.nashorn.api.scripting\n-jdk.nashorn.api.tree\n+module:jdk.nio.mapmode\n+jdk.nio.mapmode\n@@ -281,2 +284,1 @@\n-module:jdk.zipfs\n-\n+module:jdk.zipfs\n\\ No newline at end of file\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testRecordTypes\/jdk17\/element-list","additions":12,"deletions":10,"binary":false,"changes":22,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testRecordTypes\/jdk11\/element-list","status":"renamed"},{"patch":"@@ -227,3 +227,3 @@\n-                        <div class=\"snippet-container\"><a href=\"#\" class=\"snippet-copy\" onclick=\"cop\\\n-                        ySnippet(this)\" aria-label=\"Copy\" data-copied=\"Copied!\"><img src=\"..\/copy.sv\\\n-                        g\" alt=\"Copy\"><\/a>\n+                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n+                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n+                        t=\"Copy\"><\/button>\n@@ -951,3 +951,3 @@\n-                        <div class=\"snippet-container\"><a href=\"#\" class=\"snippet-copy\" onclick=\"cop\\\n-                        ySnippet(this)\" aria-label=\"Copy\" data-copied=\"Copied!\"><img src=\"..\/copy.sv\\\n-                        g\" alt=\"Copy\"><\/a>\n+                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n+                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n+                        t=\"Copy\"><\/button>\n@@ -1047,3 +1047,3 @@\n-                        <div class=\"snippet-container\"><a href=\"#\" class=\"snippet-copy\" onclick=\"cop\\\n-                        ySnippet(this)\" aria-label=\"Copy\" data-copied=\"Copied!\"><img src=\"..\/copy.sv\\\n-                        g\" alt=\"Copy\"><\/a>\n+                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n+                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n+                        t=\"Copy\"><\/button>\n@@ -1608,3 +1608,3 @@\n-                        <div class=\"snippet-container\"><a href=\"#\" class=\"snippet-copy\" onclick=\"cop\\\n-                        ySnippet(this)\" aria-label=\"Copy\" data-copied=\"Copied!\"><img src=\"..\/copy.sv\\\n-                        g\" alt=\"Copy\"><\/a>\n+                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n+                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n+                        t=\"Copy\"><\/button>\n@@ -1725,3 +1725,3 @@\n-                    <div class=\"snippet-container\"><a href=\"#\" class=\"snippet-copy\" onclick=\"copySni\\\n-                    ppet(this)\" aria-label=\"Copy\" data-copied=\"Copied!\"><img src=\"..\/copy.svg\" alt=\"\\\n-                    Copy\"><\/a>\n+                    <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySnippet\\\n+                    (this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" alt=\"Copy\"\\\n+                    ><\/button>\n@@ -1734,3 +1734,3 @@\n-                    <div class=\"snippet-container\"><a href=\"#\" class=\"snippet-copy\" onclick=\"copySni\\\n-                    ppet(this)\" aria-label=\"Copy\" data-copied=\"Copied!\"><img src=\"..\/copy.svg\" alt=\"\\\n-                    Copy\"><\/a>\n+                    <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySnippet\\\n+                    (this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" alt=\"Copy\"\\\n+                    ><\/button>\n@@ -1835,3 +1835,3 @@\n-                        <div class=\"snippet-container\"><a href=\"#\" class=\"snippet-copy\" onclick=\"cop\\\n-                        ySnippet(this)\" aria-label=\"Copy\" data-copied=\"Copied!\"><img src=\"..\/copy.sv\\\n-                        g\" alt=\"Copy\"><\/a>\n+                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n+                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n+                        t=\"Copy\"><\/button>\n@@ -1919,3 +1919,3 @@\n-                        <div class=\"snippet-container\"><a href=\"#\" class=\"snippet-copy\" onclick=\"cop\\\n-                        ySnippet(this)\" aria-label=\"Copy\" data-copied=\"Copied!\"><img src=\"..\/copy.sv\\\n-                        g\" alt=\"Copy\"><\/a>\n+                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n+                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n+                        t=\"Copy\"><\/button>\n@@ -2251,3 +2251,3 @@\n-                        <div class=\"snippet-container\"><a href=\"#\" class=\"snippet-copy\" onclick=\"cop\\\n-                        ySnippet(this)\" aria-label=\"Copy\" data-copied=\"Copied!\"><img src=\"..\/copy.sv\\\n-                        g\" alt=\"Copy\"><\/a>\n+                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n+                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n+                        t=\"Copy\"><\/button>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestSnippetTag.java","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ *           8256208\n@@ -51,0 +52,6 @@\n+        checkOutput(\"index.html\", true,\n+                \"\"\"\n+                    <script type=\"text\/javascript\">window.location.replace('package-summary.html')<\/script>\n+                    <noscript>\n+                    <meta http-equiv=\"Refresh\" content=\"0;package-summary.html\">\n+                    <\/noscript>\"\"\");\n@@ -159,0 +166,21 @@\n+\n+    @Test\n+    public void testMixed() {\n+        javadoc(\"-d\", \"out-mixed\",\n+                \"-sourcepath\", testSrc(\"src1\"),\n+                testSrc(\"src1\/C.java\"),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"index.html\", true,\n+                \"\"\"\n+                    <div class=\"col-first even-row-color all-packages-table all-packages-table-tab1\"\\\n+                    ><a href=\"package-summary.html\">Unnamed Package<\/a><\/div>\n+                    <div class=\"col-last even-row-color all-packages-table all-packages-table-tab1\">\n+                    <div class=\"block\">This is a package comment for the unnamed package.<\/div>\n+                    <\/div>\n+                    <div class=\"col-first odd-row-color all-packages-table all-packages-table-tab1\">\\\n+                    <a href=\"pkg\/package-summary.html\">pkg<\/a><\/div>\n+                    <div class=\"col-last odd-row-color all-packages-table all-packages-table-tab1\">\n+                    <div class=\"block\">This is a package comment for package pkg.<\/div>\"\"\");\n+    }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testUnnamedPackage\/TestUnnamedPackage.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package pkg;\n+\n+\/**\n+ * This is class D in the package pkg.\n+ *\/\n+public class D {}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testUnnamedPackage\/src1\/pkg\/D.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+<html>\n+    <body>\n+        This is a package comment for package pkg.\n+    <\/body>\n+<\/html>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testUnnamedPackage\/src1\/pkg\/package.html","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -26,1 +26,0 @@\n-import java.io.BufferedWriter;\n@@ -42,1 +41,0 @@\n-import java.nio.file.FileVisitResult;\n@@ -44,0 +42,1 @@\n+import java.nio.file.NoSuchFileException;\n@@ -46,2 +45,0 @@\n-import java.nio.file.SimpleFileVisitor;\n-import java.nio.file.attribute.BasicFileAttributes;\n@@ -56,0 +53,1 @@\n+import java.util.Locale;\n@@ -58,0 +56,1 @@\n+import java.util.function.BiFunction;\n@@ -61,0 +60,1 @@\n+import java.util.stream.Collectors;\n@@ -186,0 +186,1 @@\n+     *\n@@ -267,0 +268,1 @@\n+     *\n@@ -276,0 +278,1 @@\n+     *\n@@ -305,1 +308,1 @@\n-     * <pre><code>\n+     * {@snippet :\n@@ -310,1 +313,1 @@\n-     * <\/code><\/pre>\n+     * }\n@@ -404,0 +407,1 @@\n+     *\n@@ -467,2 +471,1 @@\n-     * @param expected the exit code that is required for the test\n-     * to pass.\n+     * @param expected the exit code that is required for the test to pass\n@@ -483,3 +486,4 @@\n-     * @param path a path within the most recent output directory\n-     *  or the name of one of the output buffers, identifying\n-     *  where to look for the search strings.\n+     *\n+     * @param path          a path within the most recent output directory\n+     *                      or the name of one of the output buffers, identifying\n+     *                      where to look for the search strings.\n@@ -487,2 +491,2 @@\n-     *  to be found, or false if the file is not expected to be found\n-     * @param strings the strings to be searched for\n+     *                      to be found, or false if the file is not expected to be found\n+     * @param strings       the strings to be searched for\n@@ -502,2 +506,3 @@\n-     * @param path a path within the most recent output directory, identifying\n-     *  where to look for the search strings.\n+     *\n+     * @param path          a path within the most recent output directory, identifying\n+     *                      where to look for the search strings.\n@@ -505,3 +510,5 @@\n-     *  to be found, or false if all of the strings are expected to be\n-     *  not found\n-     * @param strings the strings to be searched for\n+     *                      to be found, or false if all of the strings are expected to be\n+     *                      not found\n+     * @param strings       the strings to be searched for\n+     *\n+     * @see OutputChecker#check(String...)\n@@ -510,8 +517,4 @@\n-        \/\/ Read contents of file\n-        try {\n-            String fileString = readFile(outputDir, Path.of(path));\n-            checkOutput(outputDir.resolve(path).toString(), fileString, expectedFound, strings);\n-        } catch (Error e) {\n-            checking(\"Read file\");\n-            failed(\"Error reading file: \" + e);\n-        }\n+        new OutputChecker(path)\n+                .setExpectFound(expectedFound)\n+                .setExpectOrdered(false) \/\/ TODO, fix tests (32 failures) and change to true\n+                .check(strings);\n@@ -524,1 +527,2 @@\n-     * @param output the output stream to check\n+     *\n+     * @param output        the output stream to check\n@@ -526,3 +530,5 @@\n-     *  to be found, or false if all of the strings are expected to be\n-     *  not found\n-     * @param strings the strings to be searched for\n+     *                      to be found, or false if all of the strings are expected to be\n+     *                      not found\n+     * @param strings       the strings to be searched for\n+     *\n+     * @see OutputChecker#check(String...)\n@@ -531,20 +537,4 @@\n-        checkOutput(output.toString(), outputMap.get(output), expectedFound, strings);\n-    }\n-\n-    \/\/ NOTE: path may be the name of an Output stream as well as a file path\n-    private void checkOutput(String path, String fileString, boolean expectedFound, String... strings) {\n-        for (String stringToFind : strings) {\n-\/\/            log.logCheckOutput(path, expectedFound, stringToFind);\n-            checking(\"checkOutput\");\n-            \/\/ Find string in file's contents\n-            boolean isFound = findString(fileString, stringToFind);\n-            if (isFound == expectedFound) {\n-                passed(path + \": following text \" + (isFound ? \"found:\" : \"not found:\") + \"\\n\"\n-                        + stringToFind);\n-            } else {\n-                failed(path + \": following text \" + (isFound ? \"found:\" : \"not found:\") + \"\\n\"\n-                        + stringToFind + '\\n' +\n-                        \"found \\n\" +\n-                        fileString);\n-            }\n-        }\n+        new OutputChecker(output)\n+                .setExpectFound(expectedFound)\n+                .setExpectOrdered(false) \/\/ TODO, fix tests (6 failures) and change to true\n+                .check(strings);\n@@ -555,0 +545,1 @@\n+     *\n@@ -556,0 +547,2 @@\n+     *\n+     * @see OutputChecker#checkUnique()\n@@ -562,1 +555,1 @@\n-     * Checks that there are no duplicate lines that either match or don't match a given patter,\n+     * Checks that there are no duplicate lines that either match or don't match a given pattern,\n@@ -564,1 +557,2 @@\n-     * @param output the output stream to check\n+     *\n+     * @param output  the output stream to check\n@@ -566,2 +560,4 @@\n-     * @param select if {@code true}, lines that match the pattern will be checked for uniqueness;\n-     *               if {@code false}, lines that do not match the pattern will be checked\n+     * @param select  if {@code true}, lines that match the pattern will be checked for uniqueness;\n+     *                if {@code false}, lines that do not match the pattern will be checked\n+     *\n+     * @see OutputChecker#checkUnique(Pattern, boolean)\n@@ -570,23 +566,15 @@\n-        checking(\"checkUnique\");\n-        Pattern filter = Pattern.compile(pattern);\n-        Matcher m = filter.matcher(\"\");\n-        Map<String, Integer> linesSofar = new HashMap<>();\n-        int lineNumber = 0;\n-        int duplicates = 0;\n-        for (String line : getOutputLines(output)) {\n-            m.reset(line);\n-            if (m.find() == select) {\n-                Integer prev = linesSofar.putIfAbsent(line, ++lineNumber);\n-                if (prev != null) {\n-                    out.println(\"duplicate line detected on line \" + lineNumber\n-                            + \"; first occurrence on line \" + prev);\n-                    out.println(\"line: \" + line);\n-                    duplicates++;\n-                }\n-            }\n-        }\n-        if (duplicates == 0) {\n-            passed(\"All lines are unique\");\n-        } else {\n-            failed(duplicates + \" duplicate lines found\");\n-        }\n+        new OutputChecker(output).checkUnique(Pattern.compile(pattern), select);\n+    }\n+\n+    \/**\n+     * Ensures that a series of strings appear only once, in the generated output.\n+     * Note: this test does not exhaustively check for all other possible\n+     * duplicates once one is found.\n+     *\n+     * @param path    the file to check\n+     * @param strings the strings\n+     *\n+     * @see OutputChecker#checkUnique(String...)\n+     *\/\n+    public void checkUnique(String path, String... strings) {\n+        new OutputChecker(path).checkUnique(strings);\n@@ -661,1 +649,2 @@\n-     * Gets the content of the one of the output streams written by javadoc.\n+     * Returns the content of one of the output streams written by javadoc.\n+     *\n@@ -670,1 +659,2 @@\n-     * Gets the content of the one of the output streams written by javadoc.\n+     * Returns the content of one of the output streams written by javadoc.\n+     *\n@@ -681,0 +671,1 @@\n+     *\n@@ -682,4 +673,4 @@\n-     *  to be found, or false if all of the files are expected to be\n-     *  not found\n-     * @param paths the files to check, within the most recent output directory.\n-     * *\/\n+     *                      to be found, or false if all of the files are expected to be\n+     *                      not found\n+     * @param paths         the files to check, within the most recent output directory.\n+     *\/\n@@ -692,5 +683,5 @@\n-     * @param expectedFound true if all of the files are expected\n-     *  to be found, or false if all of the files are expected to be\n-     *  not found\n-     * @param paths the files to check, within the most recent output directory.\n-     * *\/\n+     *\n+     * @param expectedFound true if all of the files are expected to be found,\n+     *                      or false if all of the files are expected to be not found\n+     * @param paths         the files to check, within the most recent output directory.\n+     *\/\n@@ -714,2 +705,5 @@\n-     * @param path the file to check\n-     * @param strings  the strings whose order to check\n+     *\n+     * @param path    the file to check\n+     * @param strings the strings whose order to check\n+     *\n+     * @see OutputChecker#check(String...)\n@@ -718,44 +712,3 @@\n-        Path file = outputDir.resolve(path);\n-        String fileString = readOutputFile(path);\n-        int prevIndex = -1;\n-        for (String s : strings) {\n-            s = s.replace(\"\\n\", NL); \/\/ normalize new lines\n-            int currentIndex = fileString.indexOf(s, prevIndex + 1);\n-            checking(\"file: \" + file + \": \" + s + \" at index \" + currentIndex);\n-            if (currentIndex == -1) {\n-                failed(file, s + \" not found.\");\n-                continue;\n-            }\n-            if (currentIndex > prevIndex) {\n-                passed(file, s + \" is in the correct order\");\n-            } else {\n-                failed(file, s + \" is in the wrong order.\");\n-            }\n-            prevIndex = currentIndex;\n-        }\n-    }\n-\n-    \/**\n-     * Ensures that a series of strings appear only once, in the generated output,\n-     * noting that, this test does not exhaustively check for all other possible\n-     * duplicates once one is found.\n-     * @param path the file to check\n-     * @param strings ensure each are unique\n-     *\/\n-    public void checkUnique(String path, String... strings) {\n-        Path file = outputDir.resolve(path);\n-        String fileString = readOutputFile(path);\n-        for (String s : strings) {\n-            int currentIndex = fileString.indexOf(s);\n-            checking(s + \" at index \" + currentIndex);\n-            if (currentIndex == -1) {\n-                failed(file, s + \" not found.\");\n-                continue;\n-            }\n-            int nextindex = fileString.indexOf(s, currentIndex + s.length());\n-            if (nextindex == -1) {\n-                passed(file, s + \" is unique\");\n-            } else {\n-                failed(file, s + \" is not unique, found at \" + nextindex);\n-            }\n-        }\n+        new OutputChecker(path)\n+                .setExpectOrdered(true) \/\/ be explicit\n+                .check(strings);\n@@ -769,1 +722,1 @@\n-     * @param files the set of files to be compared\n+     * @param files    the set of files to be compared\n@@ -833,2 +786,2 @@\n-        } catch (FileNotFoundException e) {\n-            throw new Error(\"File not found: \" + fileName + \": \" + e);\n+        } catch (FileNotFoundException | NoSuchFileException e) {\n+            throw new Error(\"File not found: \" + fileName + \": \" + e, e);\n@@ -836,1 +789,1 @@\n-            throw new Error(\"Error reading file: \" + fileName + \": \" + e);\n+            throw new Error(\"Error reading file: \" + fileName + \": \" + e, e);\n@@ -944,16 +897,0 @@\n-    \/**\n-     * Searches for the string in the given file and return true\n-     * if the string was found.\n-     *\n-     * @param fileString    the contents of the file to search through\n-     * @param stringToFind  the string to search for\n-     * @return              true if the string was found\n-     *\/\n-    private boolean findString(String fileString, String stringToFind) {\n-        \/\/ javadoc (should) always use the platform newline sequence,\n-        \/\/ but in the strings to find it is more convenient to use the Java\n-        \/\/ newline character. So we translate \\n to NL before we search.\n-        stringToFind = stringToFind.replace(\"\\n\", NL);\n-        return fileString.contains(stringToFind);\n-    }\n-\n@@ -978,0 +915,453 @@\n+    \/**\n+     * A flexible checker for checking the content of generated files and output streams.\n+     *\n+     * Configuration can be done with a series of chained method calls.\n+     * Checks can be specified as either literal strings or regular expressions.\n+     *\/\n+    public class OutputChecker {\n+        private final String name;\n+        private final String content;\n+        private boolean allowOverlaps = false;\n+        private boolean expectFound = true;\n+        private boolean expectOrdered = true;\n+        private List<Range> matches = new ArrayList<>();\n+        private Range lastMatch;\n+\n+        private enum SearchKind {\n+            TEXT, PATTERN;\n+            @Override\n+            public String toString() {\n+                return name().toLowerCase(Locale.ROOT);\n+            }\n+        }\n+\n+        \/** A half-open interval {@code [start, end)} to record the position of a match. *\/\n+        record Range(int start, int end) {\n+            static Range of(int start, int end) {\n+                return new Range(start, end);\n+            }\n+            boolean overlaps(Range other) {\n+                \/\/ Intervals do not overlap if one interval is completely before or completely after the other:\n+                \/\/ that is,    other.end <= start || end <= other.start\n+                \/\/ Invert that for when intervals do overlap, and simplify to the following expression:\n+                return other.end > start && end > other.start;\n+            }\n+            String toIntervalString() {\n+                return \"[\" + start + \",\" + end + \")\";\n+            }\n+        }\n+\n+        \/**\n+         * Creates an output checker for a file written by the most recent run of javadoc.\n+         * If the file cannot be found or there is any other error while reading the file,\n+         * an error will be reported and all subsequent {@code check...} methods will be skipped\n+         *\n+         * @param file the file\n+         *\/\n+        public OutputChecker(String file) {\n+            String c = null;\n+            try {\n+                c = readFile(file);\n+            } catch (Error e) {\n+                JavadocTester.this.checking(\"Read file \" + file);\n+                if (e.getCause() instanceof IOException) {\n+                    \/\/ exception probably thrown (with known message) by readFile\n+                    failed(e.getMessage());\n+                } else {\n+                    failed(\"Error reading file: \" + e);\n+                }\n+            }\n+\n+            if (c == null) {\n+                name = null;\n+                content = null;\n+            } else {\n+                name = file;\n+                content = c;\n+            }\n+        }\n+\n+        \/**\n+         * Creates an output checker for an output stream written by the most recent run of javadoc.\n+         *\n+         * @param output the output\n+         *\/\n+        public OutputChecker(Output output) {\n+            name = output.name();\n+            content = getOutput(output);\n+        }\n+\n+        \/**\n+         * Specifies whether matches are expected to be found or not.\n+         * The default is {@code true}.\n+         *\n+         * @param expectFound whether matches are expected to be found\n+         * @return this object\n+         *\/\n+        public OutputChecker setExpectFound(boolean expectFound) {\n+            this.expectFound = expectFound;\n+            return this;\n+        }\n+\n+        \/**\n+         * Specifies whether matches are expected to be found in order or not.\n+         * The default is {@code true}.\n+         *\n+         * @param expectOrdered  whether matches should be ordered\n+         * @return this object\n+         *\/\n+        public OutputChecker setExpectOrdered(boolean expectOrdered) {\n+            this.expectOrdered = expectOrdered;\n+            return this;\n+        }\n+\n+        \/**\n+         * Specifies whether matches are allowed to overlap.\n+         * The default is {@code false}.\n+         *\n+         * @param allowOverlaps whether matches may overlap\n+         * @return this object\n+         *\/\n+        public OutputChecker setAllowOverlaps(boolean allowOverlaps) {\n+            this.allowOverlaps = allowOverlaps;\n+            return this;\n+        }\n+\n+        \/**\n+         * Checks for the presence (or absence) of a series of strings.\n+         * Within the search strings, the newline character {@code \\n}\n+         * will be translated to the platform newline character sequence.\n+         *\n+         * @param strings the strings to be searched for\n+         *\/\n+        public OutputChecker check(String... strings) {\n+            if (name == null) {\n+                out.println(\"Skipping checks for:\" + NL\n+                        + List.of(strings).stream()\n+                        .map(s -> \"    \" + toShortString(s))\n+                        .collect(Collectors.joining(NL)));\n+                return this;\n+            }\n+\n+            for (String stringToFind : strings) {\n+                check(startPos -> findString(stringToFind, startPos), SearchKind.TEXT, stringToFind);\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Checks for the presence (or absence) of a series of regular expressions.\n+         * Unlike {@link #check(String...)}, there is no special handling for\n+         * newline characters. Use {@code \\R} to match the platform newline sequence.\n+         *\n+         * @param patterns the regular expressions to be searched for\n+         *\/\n+        public OutputChecker check(Pattern... patterns) {\n+            if (name == null) {\n+                out.println(\"Skipping checks for:\" + NL\n+                        + List.of(patterns).stream()\n+                        .map(p -> \"    \" + toShortString(p.pattern()))\n+                        .collect(Collectors.joining(NL)));\n+                return this;\n+            }\n+            for (Pattern pattern : patterns) {\n+                check(startPos -> findPattern(pattern, startPos), SearchKind.PATTERN, pattern.pattern());\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Checks for the presence (or absence) of an item.\n+         *\n+         * @param finder a function to find the next occurrence of an item starting at a given position\n+         * @param kind   the kind of the item ({@code \"text\"} or {@code \"pattern:} to include in messages\n+         * @param s      a string for the item, to be included in messages\n+         *\/\n+        private void check(Function<Integer, Range> finder, SearchKind kind, String s) {\n+            checking(\"checkOutput\", kind);\n+            int start = getStart();\n+            Range r = finder.apply(start);\n+            boolean isFound = r != null;\n+            if (isFound == expectFound) {\n+                matches.add(lastMatch = r);\n+                passed(name + \": following \" + kind + \" \" + (isFound ? \"found:\" : \"not found:\") + \"\\n\"\n+                        + s);\n+            } else {\n+                \/\/ item not found in order, so check if the item is found out of order, to determine the best message\n+                if (expectFound && expectOrdered && start > 0) {\n+                    Range r2 = finder.apply(0);\n+                    if (r2 != null) {\n+                        failed(name + \": following \" + kind + \" was found on line \"\n+                                + getLineNumber(r2.start)\n+                                + \", but not in order as expected, on or after line \"\n+                                + getLineNumber(start)\n+                                + \":\\n\"\n+                                + s);\n+                        return;\n+                    }\n+                }\n+                failed(name + \": following \" + kind + \" \"\n+                        + (isFound ? \"found:\" : \"not found:\") + \"\\n\"\n+                        + s + '\\n' + \"found \\n\" + content);\n+            }\n+\n+        }\n+\n+        \/**\n+         * Checks that there are no duplicate lines in the content.\n+         *\/\n+        public OutputChecker checkUnique() {\n+            checkUnique(Pattern.compile(\".*\"), true);\n+            return this;\n+        }\n+\n+        \/**\n+         * Checks that there are no duplicate lines that either match or don't match a given pattern,\n+         * in one of the streams written by javadoc.\n+         *\n+         * @param pattern a pattern to filter the lines to be checked\n+         * @param select  if {@code true}, lines that match the pattern will be checked for uniqueness;\n+         *                if {@code false}, lines that do not match the pattern will be checked\n+         *\/\n+        public OutputChecker checkUnique(Pattern pattern, boolean select ) {\n+            if (name == null) {\n+                out.println(\"Skipping checkUnique\");\n+                return this;\n+            }\n+\n+            checking(\"checkUnique\", SearchKind.PATTERN);\n+            Matcher m = pattern.matcher(\"\");\n+            Map<String, Integer> linesSofar = new HashMap<>();\n+            int lineNumber = 0;\n+            int duplicates = 0;\n+            for (String line : content.split(NL)) {\n+                m.reset(line);\n+                if (m.find() == select) {\n+                    Integer prev = linesSofar.putIfAbsent(line, ++lineNumber);\n+                    if (prev != null) {\n+                        out.println(\"duplicate line detected on line \" + lineNumber\n+                                + \"; first occurrence on line \" + prev);\n+                        out.println(\"line: \" + line);\n+                        duplicates++;\n+                    }\n+                }\n+            }\n+            if (duplicates == 0) {\n+                passed(\"All lines are unique\");\n+            } else {\n+                failed(duplicates + \" duplicate lines found\");\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Checks that each of a series of strings appears only once in the generated output.\n+         * Note: this test does not exhaustively check for all other possible duplicates once one is found.\n+         *\n+         * @param strings the strings\n+         *\/\n+        public OutputChecker checkUnique(String... strings) {\n+            return checkUnique(SearchKind.TEXT, List.of(strings), this::findString);\n+        }\n+\n+        \/**\n+         * Checks that each of a series of pattern matches appears only once in the generated output.\n+         * Note: this test does not exhaustively check for all other possible duplicates once one is found.\n+         *\n+         * @param patterns the patterns\n+         *\/\n+        public OutputChecker checkUnique(Pattern... patterns) {\n+            return checkUnique(SearchKind.PATTERN, List.of(patterns), this::findPattern);\n+        }\n+\n+        private <T> OutputChecker checkUnique(SearchKind kind, List<T> items, BiFunction<T, Integer, Range> finder) {\n+            if (name == null) {\n+                out.println(\"Skipping checkUnique\");\n+                return this;\n+            }\n+\n+            Range latest = null;\n+            for (T item : items) {\n+                int start = getStart();\n+                Range r = finder.apply(item, start);\n+                checking(\"checkUnique at index \" + start, SearchKind.TEXT);\n+                if (r == null) {\n+                    failed(name + \": \" + item + \" not found.\");\n+                    continue;\n+                }\n+                \/\/ only update lastMatch for the initial match of each item\n+                if (lastMatch == null) {\n+                    lastMatch = r;\n+                }\n+                Range next = finder.apply(item, r.end);\n+                if (next == null) {\n+                    passed(name + \": \" + item + \" is unique\");\n+                } else {\n+                    failed(name + \": \" + item + \" is not unique, found at \" + next.start);\n+                }\n+            }\n+            if (latest != null) {\n+                lastMatch = latest;\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Checks that all the output has been matched by preceding checks with this object.\n+         * It does not matter whether the checks were ordered or not.\n+         * The results of the matches are sorted and then checked to be adjacent and to\n+         * cover the entire content.\n+         *\n+         * @apiNote This is probably most useful for checking diagnostic output,\n+         *          in which case care must be taken to allow for platform differences\n+         *          in the output, such as file separators and newline sequences.\n+         *\/\n+        public OutputChecker checkComplete() {\n+            if (name == null) {\n+                out.println(\"Skipping checkComplete\");\n+                return this;\n+            }\n+\n+            JavadocTester.this.checking(\"checking for complete coverage of output\");\n+            List<Range> uncovered = new ArrayList<>();\n+            List<Range> list = new ArrayList<>(matches);\n+            list.sort(Comparator.comparing(Range::start));\n+            int prev = 0;\n+            for (Range r : list) {\n+                if (r.start != prev) {\n+                    uncovered.add(new Range(prev, r.start));\n+                }\n+                prev = r.end;\n+            }\n+            if (prev != content.length()) {\n+                uncovered.add(new Range(prev, content.length()));\n+            }\n+            if (uncovered.isEmpty()) {\n+                passed(\"All output matched\");\n+            } else {\n+                failed(\"The following output was not matched: \"\n+                    + uncovered.stream()\n+                        .map(Range::toIntervalString)\n+                        .collect(Collectors.joining(\", \")));\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Checks that no output is present.\n+         *\/\n+        public OutputChecker checkEmpty() {\n+            if (name == null) {\n+                out.println(\"Skipping checkEmpty\");\n+                return this;\n+            }\n+\n+            JavadocTester.this.checking(\"empty\");\n+            if (content == null || content.isEmpty()) {\n+                passed(name + \" is empty, as expected\");\n+            } else {\n+                failed(name + \" is not empty; contains:\\n\"\n+                        + content);\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Checks that at least of a set of alternatives is found.\n+         *\/\n+        public OutputChecker checkAnyOf(String... strings) {\n+            return checkAnyOf(SearchKind.TEXT, List.of(strings), this::findString);\n+        }\n+\n+        \/**\n+         * Checks that at least of a set of alternatives is found.\n+         *\/\n+        public OutputChecker checkAnyOf(Pattern... patterns) {\n+            return checkAnyOf(SearchKind.PATTERN, List.of(patterns), this::findPattern);\n+        }\n+\n+        \/**\n+         * Checks that at least of a set of alternatives is found.\n+         *\n+         *\/\n+        private <T> OutputChecker checkAnyOf(SearchKind kind, List<T> items, BiFunction<T, Integer, Range> finder) {\n+            if (name == null) {\n+                out.println(\"Skipping checkAnyOf\");\n+                return this;\n+            }\n+\n+            checking(\"checkAnyOf\", kind);\n+            Range earliest = null;\n+            int start = getStart();\n+            int count = 0;\n+            for (T item : items) {\n+                Range r = finder.apply(item, start);\n+                if (r != null) {\n+                    count++;\n+                    if (earliest == null || rangeComparator.compare(earliest, r) > 0) {\n+                        earliest = r;\n+                    }\n+                }\n+            }\n+            if (earliest != null) {\n+                lastMatch = earliest;\n+            }\n+            if (count == 0) {\n+                failed(\"no match found for any \" + kind);\n+            } else {\n+                passed(count + \" matches found; earliest is \" + earliest.toIntervalString());\n+            }\n+            return this;\n+        }\n+\n+        Comparator<Range> rangeComparator = Comparator.comparing(Range::start).thenComparing(Range::end);\n+\n+        private void checking(String name, SearchKind kind) {\n+            JavadocTester.this.checking(name + \" \" + kind.name()\n+                + \" allowOverlaps:\" + allowOverlaps\n+                + \" expectFound:\"   + expectFound\n+                + \" expectOrdered:\" + expectOrdered);\n+        }\n+\n+        private Range findString(String stringToFind, int start) {\n+            \/\/ javadoc (should) always use the platform newline sequence,\n+            \/\/ but in the strings to find it is more convenient to use the Java\n+            \/\/ newline character. So we translate \\n to NL before we search.\n+            stringToFind = stringToFind.replace(\"\\n\", NL);\n+            int i = content.indexOf(stringToFind, start);\n+            return i >= 0 ? Range.of(i, i + stringToFind.length()) : null;\n+        }\n+\n+        private Range findPattern(Pattern p, int start) {\n+            Matcher m = p.matcher(content);\n+            return m.find(start) ? Range.of(m.start(), m.end()) : null;\n+        }\n+        private int getStart() {\n+            if (lastMatch == null || !expectOrdered) {\n+                return 0;\n+            }\n+            return allowOverlaps ? lastMatch.start + 1 : lastMatch.end;\n+        }\n+\n+        private int getLineNumber(int pos) {\n+            Pattern p = Pattern.compile(\"\\\\R\");\n+            Matcher m = p.matcher(content);\n+            int line = 1;\n+            int start = 0;\n+            while (m.find(start) && m.start() < pos) {\n+                line++;\n+                start = m.start() + 1;\n+            }\n+            return line;\n+        }\n+\n+        private String toShortString(String s) {\n+            final int MAX = 64;\n+            s = s.replaceAll(\"\\\\s+\", \" \");\n+            if (s.length() > MAX) {\n+                s = s.substring(0, MAX \/ 2 - 2) + \" ... \" + s.substring(s.length() - MAX \/ 2 - 2);\n+            }\n+            return s;\n+        }\n+    }\n+\n","filename":"test\/langtools\/jdk\/javadoc\/lib\/javadoc\/tester\/JavadocTester.java","additions":544,"deletions":154,"binary":false,"changes":698,"status":"modified"},{"patch":"@@ -354,1 +354,1 @@\n-                if (name != null && !name.isEmpty()) {\n+                if (name != null) {\n@@ -371,1 +371,1 @@\n-                if (name != null && !name.isEmpty() && !id.declared) {\n+                if (name != null && !id.declared) {\n","filename":"test\/langtools\/jdk\/javadoc\/lib\/javadoc\/tester\/LinkChecker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,438 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @bug 8273154\n+ * @summary Provide a JavadocTester method for non-overlapping, unordered output matching\n+ * @library \/tools\/lib\/ ..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @run main TestJavadocTester\n+ *\/\n+\n+import javadoc.tester.JavadocTester;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import toolbox.ToolBox;\n+\n+\/**\n+ * Tests basic mechanisms in the {@code JavadocTester} class.\n+ *\n+ * It is not a direct test of the javadoc tool or the output generated by the\n+ * Standard Doclet, although both are indirectly used as part of this test.\n+ *\n+ * The test works by exercising the {@code JavadocTester} API with a series of\n+ * positive and negative tests.  The {@code passed} and {@code failed} methods\n+ * are overridden to record the messages reported by the underlying instance, so\n+ * that the messages can subsequently be verified. Also, {@code printSummary}\n+ * is overridden to suppress the default action to throw {@code Error} when\n+ * tests have failed.\n+ *\/\n+public class TestJavadocTester extends JavadocTester {\n+    public static void main(String... args) throws Exception {\n+        TestJavadocTester tester = new TestJavadocTester();\n+        tester.setup().runTests();\n+    }\n+\n+    private final List<String> messages = new ArrayList<>();\n+    private int testErrors = 0;\n+\n+    \/**\n+     * Overrides the default implementation of {@code passed} to record the argument.\n+     * {@inheritDoc}\n+     *\n+     * @param message a short description of the outcome\n+     *\/\n+    @Override\n+    public void passed(String message) {\n+        super.passed(message);\n+        messages.add(\"Passed: \" + message);\n+    }\n+\n+    \/**\n+     * Overrides the default implementation of {@code failed} to record the argument.\n+     * {@inheritDoc}\n+     *\n+     * @param message a short description of the outcome\n+     *\/\n+    @Override\n+    public void failed(String message) {\n+        super.failed(message);\n+        messages.add(\"FAILED: \" + message);\n+    }\n+\n+    \/**\n+     * Overrides the default implementation of {@code printSummary} to suppress\n+     * the error thrown as a result of errors reported by {@code JavadocTester}.\n+     * Instead, an error is thrown if any errors are found by the tests in this class.\n+     *\/\n+    @Override\n+    public void printSummary() {\n+        try {\n+            super.printSummary();\n+        } catch (Error e) {\n+            if (e.getClass() != Error.class) {\n+                throw e;\n+            }\n+            report(\"Suppressed: \" + e);\n+        }\n+\n+        if (testErrors > 0) {\n+            report(testErrors + \" errors found\");\n+            throw new Error(testErrors + \" errors found\");\n+        }\n+    }\n+\n+    \/**\n+     * Checks the content of messages reported by the {@code passed} and {@code failed}\n+     * methods in {@code JavadocTester}.  The messages are saved by the local overloads\n+     * of those methods in this class.\n+     *\n+     * Because some of the messages are <em>very<\/em> long, it is enough to pass in\n+     * initial substrings of the expected messages.\n+     *\n+     * Note that messages reported by {@code JavadocTester} use filenames as given\n+     * to the various {@code check...} calls. By convention, these always use {@code \/}\n+     * as the file separator, and not the platform file separator.\n+     *\n+     * @param expect initial substrings of expected messages\n+     *\/\n+    void checkMessages(String... expect) {\n+        for (String e : expect) {\n+            Optional<String> match = messages.stream()\n+                    .filter(m -> m.startsWith(e))\n+                    .findFirst();\n+            if (match.isPresent()) {\n+                report(\"found '\" + e + \"'\");\n+            } else {\n+                report(\"ERROR: no message found for '\" + e + \"'\");\n+                testErrors++;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Reports a message, preceded by {@code >>> }.\n+     *\n+     * It is helpful\/important to distinguish the messages written as a side-effect\n+     * of the underlying tests from the messages used to report the outcome of the\n+     * tests that verify those messages.  Instead of interposing to mark the messages\n+     * written as a side effect of the underlying tests, we leave those messages\n+     * unchanged, and instead, mark the messages reporting whether those messages\n+     * are as expected or not.\n+     *\n+     * @param message the message to be reported.\n+     *\/\n+    private void report(String message) {\n+        message.lines().forEachOrdered(l -> out.println(\">>> \" + l));\n+    }\n+\n+    \/\/-------------------------------------------------\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    TestJavadocTester setup() throws IOException {\n+        Path src = Path.of(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package p;\n+                \/**\n+                 * First sentence abc.\n+                 * Second sentence.\n+                 * abc123\n+                 * def456\n+                 * ghi789\n+                 * abc123\n+                 * def456\n+                 * ghi789\n+                 *\/\n+                public class C {\n+                    private C() { }\n+                    \/** m3 comment. *\/\n+                    public void m3() { }\n+                    \/** m2 comment. *\/\n+                    public void m2() { }\n+                    \/** m1 comment. *\/\n+                    public void m1() { }\n+                }\n+                \"\"\");\n+\n+        javadoc(\"-d\", \"out\",\n+                \"-sourcepath\", src.toString(),\n+                \"-noindex\", \"-nohelp\",\n+                \"p\");\n+        return this;\n+    }\n+\n+    @Test\n+    public void testSimpleStringCheck() {\n+        messages.clear();\n+        new OutputChecker(\"p\/C.html\")\n+                .check(\"Second sentence\",\n+                        \"abc123\",\n+                        \"def456\");\n+        messages.forEach(this::report);\n+        checkMessages(\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    Second sentence\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    abc123\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    def456\"\"\");\n+    }\n+\n+    @Test\n+    public void testSimpleNegativeStringCheck_expected() {\n+        messages.clear();\n+        new OutputChecker(\"p\/C.html\")\n+                .setExpectFound(false)\n+                .check(\"Third sentence.\");\n+        checkMessages(\n+                \"\"\"\n+                    Passed: p\/C.html: following text not found:\n+                    Third sentence\"\"\");\n+    }\n+\n+    @Test\n+    public void testSimpleNegativeStringCheck_unexpected() {\n+        messages.clear();\n+        new OutputChecker(\"p\/C.html\")\n+                .check(\"Third sentence.\");\n+        checkMessages(\n+                \"\"\"\n+                    FAILED: p\/C.html: following text not found:\n+                    Third sentence\"\"\");\n+    }\n+\n+    @Test\n+    public void testSimpleRegexCheck() {\n+        messages.clear();\n+        new OutputChecker(\"p\/C.html\")\n+                .check(Pattern.compile(\"S.cond s.nt.nc.\"),\n+                        Pattern.compile(\"[abc]{3}[123]{3}\"),\n+                        Pattern.compile(\"d.f4.6\"));\n+        checkMessages(\n+                \"\"\"\n+                    Passed: p\/C.html: following pattern found:\n+                    S.cond s.nt.nc.\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following pattern found:\n+                    [abc]{3}[123]{3}\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following pattern found:\n+                    d.f4.6\"\"\");\n+    }\n+\n+    @Test\n+    public void testOrdered() {\n+        messages.clear();\n+        \/\/ methods are listed alphabetically in the Summary table,\n+        \/\/ but in source-code order in the Details section.\n+        new OutputChecker(\"p\/C.html\")\n+                .check(\"<h2>Method Summary<\/h2>\",\n+                        \"<a href=\\\"#m1()\\\" class=\\\"member-name-link\\\">m1<\/a>\",\n+                        \"<a href=\\\"#m2()\\\" class=\\\"member-name-link\\\">m2<\/a>\",\n+                        \"<a href=\\\"#m3()\\\" class=\\\"member-name-link\\\">m3<\/a>\")\n+                .check(\"<h2>Method Details<\/h2>\",\n+                        \"<section class=\\\"detail\\\" id=\\\"m3()\\\">\\n\",\n+                        \"<section class=\\\"detail\\\" id=\\\"m2()\\\">\\n\",\n+                        \"<section class=\\\"detail\\\" id=\\\"m1()\\\">\\n\");\n+\n+        checkMessages(\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    <h2>Method Summary<\/h2>\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    <a href=\"#m1()\" class=\"member-name-link\">m1<\/a>\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    <a href=\"#m2()\" class=\"member-name-link\">m2<\/a>\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    <a href=\"#m3()\" class=\"member-name-link\">m3<\/a>\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    <h2>Method Details<\/h2>\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    <section class=\"detail\" id=\"m3()\">\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    <section class=\"detail\" id=\"m2()\">\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    <section class=\"detail\" id=\"m1()\">\"\"\"\n+        );\n+    }\n+\n+    @Test\n+    public void testUnordered_expected() {\n+        messages.clear();\n+        new OutputChecker(\"p\/C.html\")\n+                .setExpectOrdered(false)\n+                .check(\"Second sentence\",\n+                        \"First sentence\");\n+        checkMessages(\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    Second sentence\"\"\",\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    First sentence\"\"\");\n+    }\n+\n+    @Test\n+    public void testUnordered_unexpected() {\n+        messages.clear();\n+        new OutputChecker(\"p\/C.html\")\n+                .check(\"Second sentence\",\n+                        \"First sentence\");\n+        checkMessages(\n+                \"\"\"\n+                    Passed: p\/C.html: following text found:\n+                    Second sentence\"\"\",\n+                \"\"\"\n+                    FAILED: p\/C.html: following text was found on line\"\"\");\n+    }\n+\n+    @Test\n+    public void testComplete_Ordered() {\n+        messages.clear();\n+        \/\/ In the following calls, the strings are specified in the expected order.\n+        \/\/ File separators are made platform-specific by calling 'fix'.\n+        \/\/ Newlines are handled automatically by the 'check' method.\n+        new OutputChecker(Output.OUT)\n+                .check(\"Loading source files for package p...\\n\",\n+                        \"Constructing Javadoc information...\\n\",\n+                        fix(\"Creating destination directory: \\\"out\/\\\"\\n\"))\n+                .check(Pattern.compile(\"Standard Doclet .*\\\\R\"))\n+                .check(\"Building tree for all the packages and classes...\\n\",\n+                        fix(\"Generating out\/p\/C.html...\\n\"),\n+                        fix(\"Generating out\/p\/package-summary.html...\\n\"),\n+                        fix(\"Generating out\/p\/package-tree.html...\\n\"),\n+                        fix(\"Generating out\/overview-tree.html...\\n\"),\n+                        fix(\"Generating out\/index.html...\\n\"))\n+                .checkComplete();\n+        checkMessages(\"Passed: All output matched\");\n+    }\n+\n+    @Test\n+    public void testComplete_Unordered() {\n+        messages.clear();\n+        \/\/ In the following calls, the strings are deliberately specified out of the expected order.\n+        \/\/ File separators are made platform-specific by calling 'fix'.\n+        \/\/ Newlines are handled automatically by the 'check' method.\n+        new OutputChecker(Output.OUT)\n+                .setExpectOrdered(false)\n+                .check(\"Loading source files for package p...\\n\",\n+                        \"Constructing Javadoc information...\\n\",\n+                        \"Building tree for all the packages and classes...\\n\")\n+                .check(fix(\"Creating destination directory: \\\"out\/\\\"\\n\",\n+                        \"Generating out\/index.html...\\n\",\n+                        \"Generating out\/overview-tree.html...\\n\",\n+                        \"Generating out\/p\/package-tree.html...\\n\",\n+                        \"Generating out\/p\/package-summary.html...\\n\",\n+                        \"Generating out\/p\/C.html...\\n\"))\n+                .check(Pattern.compile(\"Standard Doclet .*\\\\R\"))\n+                .checkComplete();\n+        checkMessages(\"Passed: All output matched\");\n+    }\n+\n+    @Test\n+    public void testEmpty() {\n+        messages.clear();\n+        new OutputChecker(Output.STDERR)\n+                .checkEmpty();\n+        checkMessages(\"Passed: STDERR is empty, as expected\");\n+    }\n+\n+    @Test\n+    public void testBadFile() {\n+        messages.clear();\n+        new OutputChecker(\"does-not-exist.html\")\n+                .check(\"abcdef\",\n+                        \"very long string \".repeat(10))\n+                .check(Pattern.quote(\"abcdef\"),\n+                        Pattern.quote(\"very long string\".repeat(10)));\n+        checkMessages(\"FAILED: File not found: does-not-exist.html\");\n+    }\n+\n+    @Test\n+    public void testAnyOf() {\n+        messages.clear();\n+        new OutputChecker(\"p\/C.html\")\n+                .checkAnyOf(\"m1()\", \"m2()\", \"m3()\")    \/\/ expect all found\n+                .checkAnyOf(\"m1()\", \"m2()\", \"M3()\")    \/\/ expect some found\n+                .checkAnyOf(\"M1()\", \"M2()\", \"M3()\");   \/\/ expect none found\n+        checkMessages(\"Passed: 3 matches found\",\n+                \"Passed: 2 matches found\",\n+                \"FAILED: no match found for any text\");\n+    }\n+\n+    @Test\n+    public void testUnique() {\n+        messages.clear();\n+        new OutputChecker(\"p\/C.html\")\n+                .setExpectOrdered(false)\n+                .checkUnique(\"id=\\\"m1()\\\"\", \"id=\\\"m2()\\\"\", \"id=\\\"m3()\\\"\")   \/\/ expect unique\n+                .checkUnique(\"m1()\", \"m2()\", \"m3()\");                       \/\/ expect not unique\n+        checkMessages(\"Passed: p\/C.html: id=\\\"m1()\\\" is unique\",\n+                \"Passed: p\/C.html: id=\\\"m2()\\\" is unique\",\n+                \"Passed: p\/C.html: id=\\\"m3()\\\" is unique\",\n+                \"FAILED: p\/C.html: m1() is not unique\",\n+                \"FAILED: p\/C.html: m2() is not unique\",\n+                \"FAILED: p\/C.html: m3() is not unique\");\n+    }\n+\n+    \/**\n+     * {@return a string with {@code \/} replaced by the platform file separator}\n+     *\n+     * @param item the string\n+     *\/\n+    private String fix(String item) {\n+        return item.replace(\"\/\", FS);\n+    }\n+\n+    \/**\n+     * {@return an array of strings with {@code \/} replaced by the platform file separator}\n+     *\n+     * @param items the strings\n+     *\/\n+    private String[] fix(String... items) {\n+        return Stream.of(items)\n+                .map(this::fix)\n+                .toArray(String[]::new);\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/testJavadocTester\/TestJavadocTester.java","additions":438,"deletions":0,"binary":false,"changes":438,"status":"added"},{"patch":"@@ -65,0 +65,1 @@\n+            \"--add-script\",\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/CheckManPageOptions.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8149524 8131024 8165211 8080071 8130454 8167343 8129559 8114842 8182268 8223782 8235474 8246774\n+ * @bug 8149524 8131024 8165211 8080071 8130454 8167343 8129559 8114842 8182268 8223782 8235474 8246774 8276149\n@@ -226,0 +226,6 @@\n+        \/\/JDK-8276149:\n+        \"void t(int i) { int v = switch (i) { case 0 -> \",\n+        \"void t(int i) { int v = switch (i) { case 0 -> {\",\n+        \"void t(int i) { int v = switch (i) { case 0 -> a = b;\",\n+        \"void t(int i) { int v = switch (i) { case 0 -> System.err.println(1);\",\n+        \"void t(int i) { int v = switch (i) { case 0 -> throw new IllegalStateException();\",\n","filename":"test\/langtools\/jdk\/jshell\/CompletenessTest.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.HashMap;\n@@ -91,0 +92,1 @@\n+                    .persistence(new HashMap<>())\n","filename":"test\/langtools\/jdk\/jshell\/CustomInputToolBuilder.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import jdk.jshell.JShell;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+\n+\/*\n+ * @test\n+ * @bug 8274734\n+ * @summary Verify multiple SourceCodeAnalysis instances can concurrently provide documentation.\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.jdeps\/com.sun.tools.javap\n+ *          jdk.jshell\/jdk.internal.jshell.tool\n+ * @build Compiler toolbox.ToolBox\n+ * @run testng MultipleDocumentationTest\n+ *\/\n+@Test\n+public class MultipleDocumentationTest {\n+\n+    public void testMultipleDocumentation() {\n+        String input = \"java.lang.String\";\n+\n+        try (var state1 = JShell.builder()\n+                                .out(new PrintStream(new ByteArrayOutputStream()))\n+                                .err(new PrintStream(new ByteArrayOutputStream()))\n+                                .build()) {\n+            var sca1 = state1.sourceCodeAnalysis();\n+            List<String> javadocs1 =\n+                    sca1.documentation(input, input.length(), true)\n+                        .stream()\n+                        .map(d -> d.javadoc())\n+                        .collect(Collectors.toList());\n+\n+            try (var state2 = JShell.builder()\n+                                    .out(new PrintStream(new ByteArrayOutputStream()))\n+                                    .err(new PrintStream(new ByteArrayOutputStream()))\n+                                    .build()) {\n+                var sca2 = state2.sourceCodeAnalysis();\n+                List<String> javadocs2 = sca2.documentation(input, input.length(), true)\n+                                             .stream()\n+                                             .map(d -> d.javadoc())\n+                                             .collect(Collectors.toList());\n+\n+                assertEquals(javadocs2, javadocs1);\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/jdk\/jshell\/MultipleDocumentationTest.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928\n+ * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097\n@@ -55,1 +55,0 @@\n-import com.sun.source.util.TreePathScanner;\n@@ -86,0 +85,1 @@\n+import com.sun.source.tree.DefaultCaseLabelTree;\n@@ -1823,0 +1823,87 @@\n+    @Test \/\/JDK-8275097\n+    void testDefaultTagPosition() throws IOException {\n+        String code = \"\"\"\n+                      package t;\n+                      class Test {\n+                          private void test1(int i) {\n+                              switch (i) {\n+                                  default:\n+                              }\n+                          }\n+                          private void test2(int i) {\n+                              switch (i) {\n+                                  case default:\n+                              }\n+                          }\n+                          private int test3(int i) {\n+                              return switch (i) {\n+                                  default: yield 0;\n+                              }\n+                          }\n+                          private int test4(int i) {\n+                              return switch (i) {\n+                                  case default: yield 0;\n+                              }\n+                          }\n+                          private void test5(int i) {\n+                              switch (i) {\n+                                  default -> {}\n+                              }\n+                          }\n+                          private void test6(int i) {\n+                              switch (i) {\n+                                  case default -> {}\n+                              }\n+                          }\n+                          private int test5(int i) {\n+                              return switch (i) {\n+                                  default -> { yield 0; }\n+                              }\n+                          }\n+                          private int test6(int i) {\n+                              return switch (i) {\n+                                  case default -> { yield 0; }\n+                              }\n+                          }\n+                          private int test7(int i) {\n+                              return switch (i) {\n+                                  default -> 0;\n+                              }\n+                          }\n+                          private int test8(int i) {\n+                              return switch (i) {\n+                                  case default -> 0;\n+                              }\n+                          }\n+                      }\n+                      \"\"\";\n+\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, null, null,\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+        Trees t = Trees.instance(ct);\n+        SourcePositions sp = t.getSourcePositions();\n+        new TreeScanner<Void, Void>() {\n+            @Override\n+            public Void visitDefaultCaseLabel(DefaultCaseLabelTree tree, Void p) {\n+                int start = (int) sp.getStartPosition(cut, tree);\n+                int end   = (int) sp.getEndPosition(cut, tree);\n+                String defaultName = code.substring(start, end);\n+                if (!\"default\".equals(defaultName)) {\n+                    throw new AssertionError(\"Incorrect span: \" + defaultName);\n+                }\n+                return super.visitDefaultCaseLabel(tree, p);\n+            }\n+\n+            @Override\n+            public Void visitCase(CaseTree node, Void p) {\n+                scan(node.getLabels(), p);\n+                if (node.getCaseKind() == CaseTree.CaseKind.RULE)\n+                    scan(node.getBody(), p);\n+                else\n+                    scan(node.getStatements(), p);\n+                return null;\n+            }\n+        }.scan(cut, null);\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":89,"deletions":2,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-SwitchErrors.java:36:20: compiler.err.total.pattern.and.default\n+SwitchErrors.java:36:13: compiler.err.total.pattern.and.default\n@@ -13,2 +13,2 @@\n-SwitchErrors.java:60:20: compiler.err.duplicate.default.label\n-SwitchErrors.java:66:20: compiler.err.duplicate.default.label\n+SwitchErrors.java:60:13: compiler.err.duplicate.default.label\n+SwitchErrors.java:66:13: compiler.err.duplicate.default.label\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.out","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    private static int offsetBaseArchivePathOffset;\/\/ offset of GenericCDSFileMapHeader::_base_archive_path_offset\n+    private static int offsetBaseArchiveNameOffset;\/\/ offset of GenericCDSFileMapHeader::_base_archive_name_offset\n@@ -90,1 +90,1 @@\n-            offsetBaseArchivePathOffset = wb.getCDSOffsetForName(\"GenericCDSFileMapHeader::_base_archive_path_offset\");\n+            offsetBaseArchiveNameOffset = wb.getCDSOffsetForName(\"GenericCDSFileMapHeader::_base_archive_name_offset\");\n@@ -124,1 +124,1 @@\n-    public static int offsetBaseArchivePathOffset() { return offsetBaseArchivePathOffset; }\n+    public static int offsetBaseArchiveNameOffset() { return offsetBaseArchiveNameOffset; }\n@@ -151,2 +151,2 @@\n-    public static int baseArchivePathOffset(File jsaFile) throws Exception {\n-        return (int)readInt(jsaFile, offsetBaseArchivePathOffset, 4);\n+    public static int baseArchiveNameOffset(File jsaFile) throws Exception {\n+        return (int)readInt(jsaFile, offsetBaseArchiveNameOffset, 4);\n@@ -161,2 +161,2 @@\n-        int baseArchivePathOffset = (int)readInt(jsaFile, offsetBaseArchivePathOffset, 4);\n-        return readString(jsaFile, baseArchivePathOffset, size - 1); \/\/ exclude terminating '\\0'\n+        int baseArchiveNameOffset = (int)readInt(jsaFile, offsetBaseArchiveNameOffset, 4);\n+        return readString(jsaFile, baseArchiveNameOffset, size - 1); \/\/ exclude terminating '\\0'\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSArchiveUtils.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n@@ -31,4 +33,3 @@\n-import java.net.InetSocketAddress;\n-import java.net.Socket;\n-import java.net.SocketException;\n-import java.net.UnknownHostException;\n+import java.net.ProtocolFamily;\n+import java.net.StandardProtocolFamily;\n+import java.nio.channels.SocketChannel;\n@@ -52,13 +53,2 @@\n-        try {\n-            InetAddress loopbackIPv4 = InetAddress.getByAddress(\n-                    new byte[] {0x7F, 0x00, 0x00, 0x01});\n-\n-            InetAddress loopbackIPv6 = InetAddress.getByAddress(\n-                    new byte[] {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01});\n-\n-            hasIPv4 = runPrivilegedAction(() -> hasAddress(loopbackIPv4));\n-            hasIPv6 = runPrivilegedAction(() -> hasAddress(loopbackIPv6));\n-        } catch (UnknownHostException e) {\n-            throw new AssertionError(e);\n-        }\n+        hasIPv4 = runPrivilegedAction(() -> isSupported(Inet4Address.class));\n+        hasIPv6 = runPrivilegedAction(() -> isSupported(Inet6Address.class));\n@@ -74,3 +64,4 @@\n-    private static boolean hasAddress(InetAddress address) {\n-        try (Socket socket = new Socket()) {\n-            socket.bind(new InetSocketAddress(address, 0));\n+    private static boolean isSupported(Class<? extends InetAddress> addressType) {\n+        ProtocolFamily family = addressType == Inet4Address.class ?\n+                StandardProtocolFamily.INET : StandardProtocolFamily.INET6;\n+        try (var sc = SocketChannel.open(family)) {\n@@ -78,1 +69,1 @@\n-        } catch (SocketException se) {\n+        } catch (IOException | UnsupportedOperationException ex) {\n@@ -80,2 +71,0 @@\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n","filename":"test\/lib\/jdk\/test\/lib\/net\/IPSupport.java","additions":13,"deletions":24,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2021, Amazon.com Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Threads;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+public class ThreadOnSpinWait {\n+    @Benchmark\n+    @Threads(1)\n+    public void testOnSpinWait() {\n+        Thread.onSpinWait();\n+    }\n+\n+    @Benchmark\n+    @Threads(1)\n+    public void testSleep0() throws InterruptedException {\n+        Thread.sleep(0);\n+    }\n+\n+    @Benchmark\n+    @Threads(1)\n+    public void testEmpty() {\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ThreadOnSpinWait.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2021, Amazon.com Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.math.BigInteger;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BooleanSupplier;\n+\n+\/**\n+ * This microbenchmark models producer-consumer.\n+ *\n+ * The microbenchmark uses two thread: 1 for a producer, 1 for a consumer.\n+ * The microbenchmark uses BigInteger to have latencies of producing\/consuming\n+ * data comparable with synchronization operations.\n+ *\n+ * Thread.onSpinWait is used in a spin loop which is used to avoid heavy locks.\n+ * In the spin loop volatile fields are checked. To reduce overhead accessing them\n+ * they are only checked after a number of iterations.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Benchmark)\n+@Threads(1)\n+public class ThreadOnSpinWaitProducerConsumer {\n+    @Param({\"100\"})\n+    public int maxNum;\n+\n+    @Param({\"125\"})\n+    public int spinNum;\n+\n+    @Param({\"10\"})\n+    public int checkSpinCondAfterIters;\n+\n+    @Param({\"256\"})\n+    public int dataBitLength;\n+\n+    private Thread threadProducer;\n+    private Thread threadConsumer;\n+    private Object monitor;\n+\n+    private BigInteger a;\n+    private BigInteger b;\n+    private Blackhole bh;\n+\n+    private volatile int dataId;\n+    private volatile int seenDataId;\n+\n+    private int producedDataCount;\n+    private int consumedDataCount;\n+\n+    private void produceData() {\n+        if (!isDataSeen()) {\n+            return;\n+        }\n+\n+        b = a.not();\n+        ++dataId;\n+        ++producedDataCount;\n+    }\n+\n+    private void consumeData() {\n+        if (isDataSeen()) {\n+            return;\n+        }\n+        bh.consume(a.equals(b.not()));\n+        seenDataId = dataId;\n+        ++consumedDataCount;\n+    }\n+\n+    private boolean isDataSeen() {\n+        return seenDataId == dataId;\n+    }\n+\n+    private boolean isNewData() {\n+        return seenDataId != dataId;\n+    }\n+\n+    private boolean spinWaitForCondition(int spinNum, BooleanSupplier cond) {\n+        for (int i = 0; i < spinNum; ++i) {\n+            if ((i % checkSpinCondAfterIters) == 0 && cond.getAsBoolean()) {\n+                return true;\n+            }\n+            Thread.onSpinWait();\n+        }\n+        return cond.getAsBoolean();\n+    }\n+\n+    void produce() {\n+        try {\n+            while (dataId < maxNum) {\n+                if (spinWaitForCondition(this.spinNum, this::isDataSeen)) {\n+                    synchronized (monitor) {\n+                        produceData();\n+                        monitor.notify();\n+                    }\n+                } else {\n+                    synchronized (monitor) {\n+                        while (!isDataSeen()) {\n+                            monitor.wait();\n+                        }\n+\n+                        produceData();\n+                        monitor.notify();\n+                    }\n+                }\n+            }\n+        } catch (InterruptedException e) {}\n+    }\n+\n+    void consume() {\n+        try {\n+            for (;;) {\n+                if (spinWaitForCondition(this.spinNum, this::isNewData)) {\n+                    synchronized (monitor) {\n+                         consumeData();\n+                         monitor.notify();\n+                    }\n+                } else {\n+                    synchronized (monitor) {\n+                        while (isDataSeen()) {\n+                            monitor.wait();\n+                        }\n+\n+                        consumeData();\n+                        monitor.notify();\n+                    }\n+                }\n+            }\n+        } catch (InterruptedException e) {}\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void setup01() {\n+        Random rnd = new Random(111);\n+        a = BigInteger.probablePrime(dataBitLength, rnd);\n+        monitor = new Object();\n+    }\n+\n+    @Setup(Level.Invocation)\n+    public void setup02() {\n+        threadProducer = new Thread(this::produce);\n+        threadConsumer = new Thread(this::consume);\n+    }\n+\n+    @Benchmark\n+    public void trial(Blackhole bh) throws Exception {\n+        this.bh = bh;\n+        producedDataCount = 0;\n+        consumedDataCount = 0;\n+        dataId = 0;\n+        seenDataId = 0;\n+        threadProducer.start();\n+        threadConsumer.start();\n+        threadProducer.join();\n+\n+        synchronized (monitor) {\n+            while (!isDataSeen()) {\n+                monitor.wait();\n+            }\n+        }\n+        threadConsumer.interrupt();\n+\n+        if (producedDataCount != maxNum) {\n+            throw new RuntimeException(\"Produced: \" + producedDataCount + \". Expected: \" + maxNum);\n+        }\n+        if (producedDataCount != consumedDataCount) {\n+            throw new RuntimeException(\"produced != consumed: \" + producedDataCount + \" != \" + consumedDataCount);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ThreadOnSpinWaitProducerConsumer.java","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+public class ThreadOnSpinWaitSharedCounter {\n+    @Param({\"1000000\"})\n+    public int maxNum;\n+\n+    @Param({\"4\"})\n+    public int threadCount;\n+\n+    AtomicInteger theCounter;\n+\n+    Thread threads[];\n+\n+    void work() {\n+        for (;;) {\n+            int prev = theCounter.get();\n+            if (prev >= maxNum) {\n+                break;\n+            }\n+            if (theCounter.compareAndExchange(prev, prev + 1) != prev) {\n+                Thread.onSpinWait();\n+            }\n+        }\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void foo() {\n+        theCounter = new AtomicInteger();\n+    }\n+\n+    @Setup(Level.Invocation)\n+    public void setup() {\n+        theCounter.set(0);\n+        threads = new Thread[threadCount];\n+\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Thread(this::work);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void trial() throws Exception {\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i].join();\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ThreadOnSpinWaitSharedCounter.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"}]}