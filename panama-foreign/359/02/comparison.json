{"files":[{"patch":"@@ -33,0 +33,2 @@\n+import java.lang.constant.Constable;\n+import java.lang.constant.DynamicConstantDesc;\n@@ -35,0 +37,1 @@\n+import java.nio.ByteOrder;\n@@ -36,0 +39,1 @@\n+import java.util.Map;\n@@ -37,0 +41,1 @@\n+import java.util.Optional;\n@@ -39,0 +44,1 @@\n+import static java.lang.constant.ConstantDescs.BSM_GET_STATIC_FINAL;\n@@ -148,1 +154,1 @@\n-    ValueLayout C_CHAR = pick(SysV.C_CHAR, Win64.C_CHAR, AArch64.C_CHAR);\n+    CValueLayout C_CHAR = pick(SysV.C_CHAR, Win64.C_CHAR, AArch64.C_CHAR);\n@@ -152,1 +158,1 @@\n-    ValueLayout C_SHORT = pick(SysV.C_SHORT, Win64.C_SHORT, AArch64.C_SHORT);\n+    CValueLayout C_SHORT = pick(SysV.C_SHORT, Win64.C_SHORT, AArch64.C_SHORT);\n@@ -156,1 +162,1 @@\n-    ValueLayout C_INT = pick(SysV.C_INT, Win64.C_INT, AArch64.C_INT);\n+    CValueLayout C_INT = pick(SysV.C_INT, Win64.C_INT, AArch64.C_INT);\n@@ -160,1 +166,1 @@\n-    ValueLayout C_LONG = pick(SysV.C_LONG, Win64.C_LONG, AArch64.C_LONG);\n+    CValueLayout C_LONG = pick(SysV.C_LONG, Win64.C_LONG, AArch64.C_LONG);\n@@ -164,1 +170,1 @@\n-    ValueLayout C_LONGLONG = pick(SysV.C_LONGLONG, Win64.C_LONGLONG, AArch64.C_LONGLONG);\n+    CValueLayout C_LONGLONG = pick(SysV.C_LONGLONG, Win64.C_LONGLONG, AArch64.C_LONGLONG);\n@@ -168,1 +174,1 @@\n-    ValueLayout C_FLOAT = pick(SysV.C_FLOAT, Win64.C_FLOAT, AArch64.C_FLOAT);\n+    CValueLayout C_FLOAT = pick(SysV.C_FLOAT, Win64.C_FLOAT, AArch64.C_FLOAT);\n@@ -172,1 +178,1 @@\n-    ValueLayout C_DOUBLE = pick(SysV.C_DOUBLE, Win64.C_DOUBLE, AArch64.C_DOUBLE);\n+    CValueLayout C_DOUBLE = pick(SysV.C_DOUBLE, Win64.C_DOUBLE, AArch64.C_DOUBLE);\n@@ -176,1 +182,1 @@\n-    ValueLayout C_LONGDOUBLE = pick(SysV.C_LONGDOUBLE, Win64.C_LONGDOUBLE, AArch64.C_LONGDOUBLE);\n+    CValueLayout C_LONGDOUBLE = pick(SysV.C_LONGDOUBLE, Win64.C_LONGDOUBLE, AArch64.C_LONGDOUBLE);\n@@ -180,1 +186,1 @@\n-    ValueLayout C_POINTER = pick(SysV.C_POINTER, Win64.C_POINTER, AArch64.C_POINTER);\n+    CValueLayout C_POINTER = pick(SysV.C_POINTER, Win64.C_POINTER, AArch64.C_POINTER);\n@@ -703,0 +709,193 @@\n+    \/**\n+     * Subclass of ValueLayout that contains information needed when linking\n+     * downcalls or upcalls.\n+     *\/\n+    class CValueLayout extends ValueLayout {\n+        \/**\n+         * The kind of CValueLayout. Each kind corresponds to a particular\n+         * C language builtin type.\n+         *\/\n+        public enum Kind {\n+            \/**\n+             * A kind corresponding to the C {@code char} type\n+             *\/\n+            CHAR(findBSM(\"C_CHAR\"), true),\n+            \/**\n+             * A kind corresponding to the C {@code short} type\n+             *\/\n+            SHORT(findBSM(\"C_SHORT\"), true),\n+            \/**\n+             * A kind corresponding to the C {@code int} type\n+             *\/\n+            INT(findBSM(\"C_INT\"), true),\n+            \/**\n+             * A kind corresponding to the C {@code long} type\n+             *\/\n+            LONG(findBSM(\"C_LONG\"), true),\n+            \/**\n+             * A kind corresponding to the C {@code long long} type\n+             *\/\n+            LONGLONG(findBSM(\"C_LONGLONG\"), true),\n+            \/**\n+             * A kind corresponding to the C {@code float} type\n+             *\/\n+            FLOAT(findBSM(\"C_FLOAT\"), false),\n+            \/**\n+             * A kind corresponding to the C {@code double} type\n+             *\/\n+            DOUBLE(findBSM(\"C_DOUBLE\"), false),\n+            \/**\n+             * A kind corresponding to the C {@code long double} type\n+             *\/\n+            LONGDOUBLE(findBSM(\"C_LONGDOUBLE\"), false),\n+            \/**\n+             * A kind corresponding to the a C pointer type\n+             *\/\n+            POINTER(findBSM(\"C_POINTER\"), false);\n+\n+            private final DynamicConstantDesc<ValueLayout> bsm;\n+            private final boolean isIntegral;\n+\n+            Kind(DynamicConstantDesc<ValueLayout> bsm, boolean isIntegral) {\n+                this.bsm = bsm;\n+                this.isIntegral = isIntegral;\n+            }\n+\n+            private DynamicConstantDesc<ValueLayout> bsm() {\n+                return bsm;\n+            }\n+\n+            \/**\n+             * Is this kind integral?\n+             *\n+             * @return true if this kind is integral\n+             *\/\n+            public boolean isIntergral() {\n+                return isIntegral;\n+            }\n+\n+            \/**\n+             * Is this kind a floating point type?\n+             *\n+             * @return true if this kind is a floating point type\n+             *\/\n+            public boolean isFloat() {\n+                return !isIntergral() && !isPointer();\n+            }\n+\n+            \/**\n+             * Is this kind a pointer kind?\n+             *\n+             * @return true if this kind is a pointer kind\n+             *\/\n+            public boolean isPointer() {\n+                return this == POINTER;\n+            }\n+\n+            private static DynamicConstantDesc<ValueLayout> findBSM(String fieldName) {\n+                return DynamicConstantDesc.ofNamed(\n+                    BSM_GET_STATIC_FINAL,\n+                    fieldName,\n+                    CValueLayout.class.describeConstable().orElseThrow(),\n+                    CLinker.class.describeConstable().orElseThrow()\n+                );\n+            }\n+        }\n+\n+        private final Kind kind;\n+\n+        \/**\n+         * CValueLayout constructor\n+         *\n+         * @param kind the kind of CValueLayout\n+         * @param order the byte order of the layout\n+         * @param bitSize the size, in bits, of the layout\n+         * @param bitAlignment the alignment, in bits, of the layout\n+         * @param attributes the attribute map of this layout\n+         *\/\n+        public CValueLayout(Kind kind, ByteOrder order, long bitSize, long bitAlignment,\n+                            Map<String, Constable> attributes) {\n+            super(order, bitSize, bitAlignment, attributes);\n+            this.kind = kind;\n+        }\n+\n+        \/**\n+         * Accessor for the kind of this layout\n+         *\n+         * @return the kind\n+         *\/\n+        public final Kind kind() {\n+            return kind;\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        public CValueLayout withOrder(ByteOrder order) {\n+            return new CValueLayout(kind, order, bitSize(), alignment, attributes);\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        public CValueLayout withName(String name) {\n+            return (CValueLayout) super.withName(name);\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        public CValueLayout withBitAlignment(long alignmentBits) {\n+            return (CValueLayout) super.withBitAlignment(alignmentBits);\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        public CValueLayout withAttribute(String name, Constable value) {\n+            return (CValueLayout) super.withAttribute(name, value);\n+        }\n+\n+        @Override\n+        CValueLayout dup(long alignment, Map<String, Constable> attributes) {\n+            return new CValueLayout(kind, order(), bitSize(), alignment, attributes);\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        public Optional<DynamicConstantDesc<ValueLayout>> describeConstable() {\n+            return Optional.of(decorateLayoutConstant(kind.bsm()));\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        public boolean equals(Object other) {\n+            if (this == other) {\n+                return true;\n+            }\n+            if (other == null || getClass() != other.getClass()) {\n+                return false;\n+            }\n+            if (!super.equals(other)) {\n+                return false;\n+            }\n+            CValueLayout that = (CValueLayout) other;\n+            return kind == that.kind;\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), kind);\n+        }\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":208,"deletions":9,"binary":false,"changes":217,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-    protected ValueLayout dup(long alignment, Map<String, Constable> attributes) {\n+    ValueLayout dup(long alignment, Map<String, Constable> attributes) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ValueLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,179 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package jdk.internal.foreign;\n-\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.ValueLayout;\n-\n-import java.lang.constant.Constable;\n-import java.lang.constant.DynamicConstantDesc;\n-import java.nio.ByteOrder;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-\n-import static java.lang.constant.ConstantDescs.BSM_GET_STATIC_FINAL;\n-\n-public class CValueLayout extends ValueLayout {\n-\n-    public enum Kind {\n-        CHAR(findBSM(\"C_CHAR\"), true),\n-        SHORT(findBSM(\"C_SHORT\"), true),\n-        INT(findBSM(\"C_INT\"), true),\n-        LONG(findBSM(\"C_LONG\"), true),\n-        LONGLONG(findBSM(\"C_LONGLONG\"), true),\n-        FLOAT(findBSM(\"C_FLOAT\"), false),\n-        DOUBLE(findBSM(\"C_DOUBLE\"), false),\n-        LONGDOUBLE(findBSM(\"C_LONGDOUBLE\"), false),\n-        POINTER(findBSM(\"C_POINTER\"), false);\n-\n-        private final DynamicConstantDesc<ValueLayout> bsm;\n-        private final boolean isIntegral;\n-\n-        Kind(DynamicConstantDesc<ValueLayout> bsm, boolean isIntegral) {\n-            this.bsm = bsm;\n-            this.isIntegral = isIntegral;\n-        }\n-\n-        public DynamicConstantDesc<ValueLayout> bsm() {\n-            return bsm;\n-        }\n-\n-        public boolean isIntergral() {\n-            return isIntegral;\n-        }\n-\n-        public boolean isPointer() {\n-            return this == POINTER;\n-        }\n-\n-        private static DynamicConstantDesc<ValueLayout> findBSM(String fieldName) {\n-            return DynamicConstantDesc.ofNamed(\n-                BSM_GET_STATIC_FINAL,\n-                fieldName,\n-                ValueLayout.class.describeConstable().orElseThrow(),\n-                CLinker.class.describeConstable().orElseThrow()\n-            );\n-        }\n-    }\n-\n-    private final Kind kind;\n-\n-    private CValueLayout(Kind kind, ByteOrder order, long size, long alignment, Map<String, Constable> attributes) {\n-        super(order, size, alignment, attributes);\n-        this.kind = kind;\n-    }\n-\n-    static CValueLayout ofChar(ByteOrder order, long bitSize) {\n-        return new CValueLayout(Kind.CHAR, order, bitSize, bitSize, Map.of());\n-    }\n-\n-    static CValueLayout ofShort(ByteOrder order, long bitSize) {\n-        return new CValueLayout(Kind.SHORT, order, bitSize, bitSize, Map.of());\n-    }\n-\n-    static CValueLayout ofInt(ByteOrder order, long bitSize) {\n-        return new CValueLayout(Kind.INT, order, bitSize, bitSize, Map.of());\n-    }\n-\n-    static CValueLayout ofLong(ByteOrder order, long bitSize) {\n-        return new CValueLayout(Kind.LONG, order, bitSize, bitSize, Map.of());\n-    }\n-\n-    static CValueLayout ofLongLong(ByteOrder order, long bitSize) {\n-        return new CValueLayout(Kind.LONGLONG, order, bitSize, bitSize, Map.of());\n-    }\n-\n-    static CValueLayout ofFloat(ByteOrder order, long bitSize) {\n-        return new CValueLayout(Kind.FLOAT, order, bitSize, bitSize, Map.of());\n-    }\n-\n-    static CValueLayout ofDouble(ByteOrder order, long bitSize) {\n-        return new CValueLayout(Kind.DOUBLE, order, bitSize, bitSize, Map.of());\n-    }\n-\n-    static CValueLayout ofLongDouble(ByteOrder order, long bitSize) {\n-        return new CValueLayout(Kind.LONGDOUBLE, order, bitSize, bitSize, Map.of());\n-    }\n-\n-    static CValueLayout ofPointer(ByteOrder order, long bitSize) {\n-        return new CValueLayout(Kind.POINTER, order, bitSize, bitSize, Map.of());\n-    }\n-\n-    public Kind kind() {\n-        return kind;\n-    }\n-\n-    @Override\n-    public CValueLayout withOrder(ByteOrder order) {\n-        return (CValueLayout) super.withOrder(order);\n-    }\n-\n-    @Override\n-    public CValueLayout withName(String name) {\n-        return (CValueLayout) super.withName(name);\n-    }\n-\n-    @Override\n-    public CValueLayout withBitAlignment(long alignmentBits) {\n-        return (CValueLayout) super.withBitAlignment(alignmentBits);\n-    }\n-\n-    @Override\n-    public CValueLayout withAttribute(String name, Constable value) {\n-        return (CValueLayout) super.withAttribute(name, value);\n-    }\n-\n-    @Override\n-    protected CValueLayout dup(long alignment, Map<String, Constable> attributes) {\n-        return new CValueLayout(kind, order(), bitSize(), alignment, attributes);\n-    }\n-\n-    @Override\n-    public Optional<DynamicConstantDesc<ValueLayout>> describeConstable() {\n-        return Optional.of(decorateLayoutConstant(kind.bsm()));\n-    }\n-\n-    @Override\n-    public boolean equals(Object other) {\n-        if (this == other) {\n-            return true;\n-        }\n-        if (other == null || getClass() != other.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(other)) {\n-            return false;\n-        }\n-        CValueLayout that = (CValueLayout) other;\n-        return kind == that.kind;\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), kind);\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/CValueLayout.java","additions":0,"deletions":179,"binary":false,"changes":179,"status":"deleted"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.CLinker.CValueLayout;\n@@ -31,0 +33,3 @@\n+import java.nio.ByteOrder;\n+import java.util.Map;\n+\n@@ -50,0 +55,43 @@\n+    private static CValueLayout ofChar(ByteOrder order, long bitSize) {\n+        return new CValueLayout(CValueLayout.Kind.CHAR, order, bitSize, bitSize, Map.of());\n+    }\n+\n+    private static CValueLayout ofShort(ByteOrder order, long bitSize) {\n+        return new CValueLayout(CValueLayout.Kind.SHORT, order, bitSize, bitSize, Map.of());\n+    }\n+\n+    private static CValueLayout ofInt(ByteOrder order, long bitSize) {\n+        return new CValueLayout(CValueLayout.Kind.INT, order, bitSize, bitSize, Map.of());\n+    }\n+\n+    private static CValueLayout ofLong(ByteOrder order, long bitSize) {\n+        return new CValueLayout(CValueLayout.Kind.LONG, order, bitSize, bitSize, Map.of());\n+    }\n+\n+    private static CValueLayout ofLongLong(ByteOrder order, long bitSize) {\n+        return new CValueLayout(CValueLayout.Kind.LONGLONG, order, bitSize, bitSize, Map.of());\n+    }\n+\n+    private static CValueLayout ofFloat(ByteOrder order, long bitSize) {\n+        return new CValueLayout(CValueLayout.Kind.FLOAT, order, bitSize, bitSize, Map.of());\n+    }\n+\n+    private static CValueLayout ofDouble(ByteOrder order, long bitSize) {\n+        return new CValueLayout(CValueLayout.Kind.DOUBLE, order, bitSize, bitSize, Map.of());\n+    }\n+\n+    private static CValueLayout ofLongDouble(ByteOrder order, long bitSize) {\n+        return new CValueLayout(CValueLayout.Kind.LONGDOUBLE, order, bitSize, bitSize, Map.of());\n+    }\n+\n+    \/**\n+     * Creates a new CValueLayout with the {@code POINTER} kind\n+     *\n+     * @param order the byte order of the layout\n+     * @param bitSize the size, in bits, of the layout\n+     * @return the newly created CValueLayout\n+     *\/\n+    public static CValueLayout ofPointer(ByteOrder order, long bitSize) {\n+        return new CValueLayout(CValueLayout.Kind.POINTER, order, bitSize, bitSize, Map.of());\n+    }\n+\n@@ -61,1 +109,1 @@\n-        public static final ValueLayout C_CHAR = CValueLayout.ofChar(LITTLE_ENDIAN, 8);\n+        public static final CValueLayout C_CHAR = ofChar(LITTLE_ENDIAN, 8);\n@@ -66,1 +114,1 @@\n-        public static final ValueLayout C_SHORT = CValueLayout.ofShort(LITTLE_ENDIAN, 16);\n+        public static final CValueLayout C_SHORT = ofShort(LITTLE_ENDIAN, 16);\n@@ -71,1 +119,1 @@\n-        public static final ValueLayout C_INT = CValueLayout.ofInt(LITTLE_ENDIAN, 32);\n+        public static final CValueLayout C_INT = ofInt(LITTLE_ENDIAN, 32);\n@@ -76,1 +124,1 @@\n-        public static final ValueLayout C_LONG = CValueLayout.ofLong(LITTLE_ENDIAN, 64);\n+        public static final CValueLayout C_LONG = ofLong(LITTLE_ENDIAN, 64);\n@@ -81,1 +129,1 @@\n-        public static final ValueLayout C_LONGLONG = CValueLayout.ofLongLong(LITTLE_ENDIAN, 64);\n+        public static final CValueLayout C_LONGLONG = ofLongLong(LITTLE_ENDIAN, 64);\n@@ -86,1 +134,1 @@\n-        public static final ValueLayout C_FLOAT = CValueLayout.ofFloat(LITTLE_ENDIAN, 32);\n+        public static final CValueLayout C_FLOAT = ofFloat(LITTLE_ENDIAN, 32);\n@@ -91,1 +139,1 @@\n-        public static final ValueLayout C_DOUBLE = CValueLayout.ofDouble(LITTLE_ENDIAN, 64);\n+        public static final CValueLayout C_DOUBLE = ofDouble(LITTLE_ENDIAN, 64);\n@@ -96,1 +144,1 @@\n-        public static final ValueLayout C_LONGDOUBLE = CValueLayout.ofLongDouble(LITTLE_ENDIAN, 128);\n+        public static final CValueLayout C_LONGDOUBLE = ofLongDouble(LITTLE_ENDIAN, 128);\n@@ -101,1 +149,1 @@\n-        public static final ValueLayout C_POINTER = CValueLayout.ofPointer(LITTLE_ENDIAN, ADDRESS.bitSize());\n+        public static final CValueLayout C_POINTER = ofPointer(LITTLE_ENDIAN, ADDRESS.bitSize());\n@@ -127,1 +175,1 @@\n-        public static final ValueLayout C_CHAR = CValueLayout.ofChar(LITTLE_ENDIAN, 8);\n+        public static final CValueLayout C_CHAR = ofChar(LITTLE_ENDIAN, 8);\n@@ -132,1 +180,1 @@\n-        public static final ValueLayout C_SHORT = CValueLayout.ofShort(LITTLE_ENDIAN, 16);\n+        public static final CValueLayout C_SHORT = ofShort(LITTLE_ENDIAN, 16);\n@@ -137,1 +185,1 @@\n-        public static final ValueLayout C_INT = CValueLayout.ofInt(LITTLE_ENDIAN, 32);\n+        public static final CValueLayout C_INT = ofInt(LITTLE_ENDIAN, 32);\n@@ -141,1 +189,1 @@\n-        public static final ValueLayout C_LONG = CValueLayout.ofLong(LITTLE_ENDIAN, 32);\n+        public static final CValueLayout C_LONG = ofLong(LITTLE_ENDIAN, 32);\n@@ -146,1 +194,1 @@\n-        public static final ValueLayout C_LONGLONG = CValueLayout.ofLongLong(LITTLE_ENDIAN, 64);\n+        public static final CValueLayout C_LONGLONG = ofLongLong(LITTLE_ENDIAN, 64);\n@@ -151,1 +199,1 @@\n-        public static final ValueLayout C_FLOAT = CValueLayout.ofFloat(LITTLE_ENDIAN, 32);\n+        public static final CValueLayout C_FLOAT = ofFloat(LITTLE_ENDIAN, 32);\n@@ -156,1 +204,1 @@\n-        public static final ValueLayout C_DOUBLE = CValueLayout.ofDouble(LITTLE_ENDIAN, 64);\n+        public static final CValueLayout C_DOUBLE = ofDouble(LITTLE_ENDIAN, 64);\n@@ -161,1 +209,1 @@\n-        public static final ValueLayout C_LONGDOUBLE = CValueLayout.ofLongDouble(LITTLE_ENDIAN, 64);\n+        public static final CValueLayout C_LONGDOUBLE = ofLongDouble(LITTLE_ENDIAN, 64);\n@@ -166,1 +214,1 @@\n-        public static final ValueLayout C_POINTER = CValueLayout.ofPointer(LITTLE_ENDIAN, ADDRESS.bitSize());\n+        public static final CValueLayout C_POINTER = ofPointer(LITTLE_ENDIAN, ADDRESS.bitSize());\n@@ -196,1 +244,1 @@\n-        public static final ValueLayout C_CHAR = CValueLayout.ofChar(LITTLE_ENDIAN, 8);\n+        public static final CValueLayout C_CHAR = ofChar(LITTLE_ENDIAN, 8);\n@@ -201,1 +249,1 @@\n-        public static final ValueLayout C_SHORT = CValueLayout.ofShort(LITTLE_ENDIAN, 16);\n+        public static final CValueLayout C_SHORT = ofShort(LITTLE_ENDIAN, 16);\n@@ -206,1 +254,1 @@\n-        public static final ValueLayout C_INT = CValueLayout.ofInt(LITTLE_ENDIAN, 32);\n+        public static final CValueLayout C_INT = ofInt(LITTLE_ENDIAN, 32);\n@@ -211,1 +259,1 @@\n-        public static final ValueLayout C_LONG = CValueLayout.ofLong(LITTLE_ENDIAN, 64);\n+        public static final CValueLayout C_LONG = ofLong(LITTLE_ENDIAN, 64);\n@@ -216,1 +264,1 @@\n-        public static final ValueLayout C_LONGLONG = CValueLayout.ofLongLong(LITTLE_ENDIAN, 64);\n+        public static final CValueLayout C_LONGLONG = ofLongLong(LITTLE_ENDIAN, 64);\n@@ -221,1 +269,1 @@\n-        public static final ValueLayout C_FLOAT = CValueLayout.ofFloat(LITTLE_ENDIAN, 32);\n+        public static final CValueLayout C_FLOAT = ofFloat(LITTLE_ENDIAN, 32);\n@@ -226,1 +274,1 @@\n-        public static final ValueLayout C_DOUBLE = CValueLayout.ofDouble(LITTLE_ENDIAN, 64);\n+        public static final CValueLayout C_DOUBLE = ofDouble(LITTLE_ENDIAN, 64);\n@@ -231,1 +279,1 @@\n-        public static final ValueLayout C_LONGDOUBLE = CValueLayout.ofLongDouble(LITTLE_ENDIAN, 128);\n+        public static final CValueLayout C_LONGDOUBLE = ofLongDouble(LITTLE_ENDIAN, 128);\n@@ -236,1 +284,1 @@\n-        public static final ValueLayout C_POINTER = CValueLayout.ofPointer(LITTLE_ENDIAN, ADDRESS.bitSize());\n+        public static final CValueLayout C_POINTER = ofPointer(LITTLE_ENDIAN, ADDRESS.bitSize());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/PlatformLayouts.java","additions":75,"deletions":27,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -32,1 +33,0 @@\n-import jdk.internal.foreign.CValueLayout;\n@@ -45,1 +45,1 @@\n-        if (!(type instanceof CValueLayout)) {\n+        if (!(type instanceof CLinker.CValueLayout)) {\n@@ -49,1 +49,1 @@\n-        return switch (((CValueLayout) type).kind()) {\n+        return switch (((CLinker.CValueLayout) type).kind()) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/TypeClass.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -31,1 +32,0 @@\n-import jdk.internal.foreign.CValueLayout;\n@@ -110,1 +110,1 @@\n-        if (!(layout instanceof CValueLayout)) {\n+        if (!(layout instanceof CLinker.CValueLayout)) {\n@@ -114,1 +114,1 @@\n-        return switch (((CValueLayout) layout).kind()) {\n+        return switch (((CLinker.CValueLayout) layout).kind()) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/TypeClass.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -30,1 +31,0 @@\n-import jdk.internal.foreign.CValueLayout;\n@@ -43,1 +43,1 @@\n-        if (!(type instanceof CValueLayout)) {\n+        if (!(type instanceof CLinker.CValueLayout)) {\n@@ -56,1 +56,1 @@\n-        return switch (((CValueLayout) type).kind()) {\n+        return switch (((CLinker.CValueLayout) type).kind()) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/TypeClass.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -26,1 +27,0 @@\n-import jdk.internal.foreign.CValueLayout;\n@@ -31,1 +31,1 @@\n-        return ((CValueLayout) layout).kind().isIntergral();\n+        return ((CLinker.CValueLayout) layout).kind().isIntergral();\n@@ -35,1 +35,1 @@\n-        return ((CValueLayout) layout).kind().isPointer();\n+        return ((CLinker.CValueLayout) layout).kind().isPointer();\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}