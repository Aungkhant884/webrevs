{"files":[{"patch":"@@ -360,5 +360,13 @@\n-\n-            return VectorSupport.load(vmClass, e, length,\n-                    msp.unsafeGetBase(), msp.unsafeGetOffset() + offset,\n-                    msp, offset, s,\n-                    defaultImpl);\n+            Object base = msp.unsafeGetBase();\n+            \/\/ Check base to unswitch loop\n+            if (base == null) {\n+                return VectorSupport.load(vmClass, e, length,\n+                        null, msp.unsafeGetOffset() + offset,\n+                        msp, offset, s,\n+                        defaultImpl);\n+            } else {\n+                return VectorSupport.load(vmClass, e, length,\n+                        base, msp.unsafeGetOffset() + offset,\n+                        msp, offset, s,\n+                        defaultImpl);\n+            }\n@@ -406,5 +414,13 @@\n-\n-            return VectorSupport.loadMasked(vmClass, maskClass, e, length,\n-                    msp.unsafeGetBase(), msp.unsafeGetOffset() + offset, m, offsetInRange,\n-                    msp, offset, s,\n-                    defaultImpl);\n+            Object base = msp.unsafeGetBase();\n+            \/\/ Check base to unswitch loop\n+            if (base == null) {\n+                return VectorSupport.loadMasked(vmClass, maskClass, e, length,\n+                        null, msp.unsafeGetOffset() + offset, m, offsetInRange,\n+                        msp, offset, s,\n+                        defaultImpl);\n+            } else {\n+                return VectorSupport.loadMasked(vmClass, maskClass, e, length,\n+                        base, msp.unsafeGetOffset() + offset, m, offsetInRange,\n+                        msp, offset, s,\n+                        defaultImpl);\n+            }\n@@ -451,6 +467,15 @@\n-\n-            VectorSupport.store(vmClass, e, length,\n-                    msp.unsafeGetBase(), msp.unsafeGetOffset() + offset,\n-                    v,\n-                    msp, offset,\n-                    defaultImpl);\n+            Object base = msp.unsafeGetBase();\n+            \/\/ Check base to unswitch loop\n+            if (base == null) {\n+                VectorSupport.store(vmClass, e, length,\n+                        null, msp.unsafeGetOffset() + offset,\n+                        v,\n+                        msp, offset,\n+                        defaultImpl);\n+            } else {\n+                VectorSupport.store(vmClass, e, length,\n+                        base, msp.unsafeGetOffset() + offset,\n+                        v,\n+                        msp, offset,\n+                        defaultImpl);\n+            }\n@@ -497,0 +522,14 @@\n+            Object base = msp.unsafeGetBase();\n+            \/\/ Check base to unswitch loop\n+            if (base == null) {\n+                VectorSupport.storeMasked(vmClass, maskClass, e, length,\n+                        null, msp.unsafeGetOffset() + offset,\n+                        v, m,\n+                        msp, offset,\n+                        defaultImpl);\n+            } else {\n+                VectorSupport.storeMasked(vmClass, maskClass, e, length,\n+                        base, msp.unsafeGetOffset() + offset,\n+                        v, m,\n+                        msp, offset,\n+                        defaultImpl);\n@@ -498,5 +537,1 @@\n-            VectorSupport.storeMasked(vmClass, maskClass, e, length,\n-                    msp.unsafeGetBase(), msp.unsafeGetOffset() + offset,\n-                    v, m,\n-                    msp, offset,\n-                    defaultImpl);\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":56,"deletions":21,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, Rado Smogura. All rights reserved.\n+ *\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\n+    \"--add-modules=jdk.incubator.vector\",\n+    \"--enable-preview\",\n+    \"--enable-native-access\", \"ALL-UNNAMED\"})\n+public class MemorySegmentMaskedVectorAccess {\n+  private static final VectorSpecies<Byte> SPECIES = VectorSpecies.ofLargestShape(byte.class);\n+\n+  @Param(\"1024\")\n+  private int size;\n+\n+  byte[] byteIn;\n+  byte[] byteOut;\n+\n+  MemorySegment nativeIn, nativeOut;\n+  MemorySegment heapIn, heapOut;\n+\n+  MemorySegment nativeInRo, nativeOutRo;\n+  MemorySegment heapInRo, heapOutRo;\n+\n+  @Setup\n+  public void setup() {\n+    nativeIn = MemorySegment.allocateNative(size, MemorySession.openImplicit());\n+    nativeOut = MemorySegment.allocateNative(size, MemorySession.openImplicit());\n+\n+    byteIn = new byte[size];\n+    byteOut = new byte[size];\n+\n+    heapIn = MemorySegment.ofArray(byteIn);\n+    heapOut = MemorySegment.ofArray(byteOut);\n+\n+    nativeInRo = nativeIn.asReadOnly();\n+    nativeOutRo = nativeOut.asReadOnly();\n+\n+    heapInRo = heapIn.asReadOnly();\n+    heapOutRo = heapOut.asReadOnly();\n+  }\n+\n+  @Benchmark\n+  public void directSegments() {\n+    copyMemory(nativeIn, nativeOut);\n+  }\n+\n+  @Benchmark\n+  public void heapSegments() {\n+    copyMemory(heapIn, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedSegments2() {\n+    copyIntoNotInlined(nativeIn, nativeOut);\n+    copyIntoNotInlined(heapIn, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedSegments3() {\n+    copyIntoNotInlined(nativeIn, nativeOut);\n+    copyIntoNotInlined(heapIn, heapOut);\n+\n+    copyIntoNotInlined(nativeInRo, nativeOut);\n+    copyIntoNotInlined(heapInRo, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedSegments4() {\n+    copyIntoNotInlined(nativeIn, heapOut); \/\/ Pollute if unswitch on 2nd param\n+    copyIntoNotInlined(heapIn, heapOut);\n+\n+    copyIntoNotInlined(heapIn, nativeIn); \/\/ Pollute if unswitch on 1st param\n+    copyIntoNotInlined(heapIn, nativeOut);\n+  }\n+\n+\n+  boolean readOnlyException;\n+\n+  @Benchmark\n+  public void pollutedSegments5() {\n+    copyIntoNotInlined(nativeIn, heapOut);\n+    copyIntoNotInlined(heapIn, heapOut);\n+\n+    copyIntoNotInlined(heapIn, nativeIn);\n+    copyIntoNotInlined(heapIn, nativeOut);\n+\n+    if (readOnlyException) {\n+      try {\n+        copyIntoNotInlined(heapIn, nativeOutRo);\n+      } catch (Exception ignored) {}\n+      readOnlyException = !readOnlyException;\n+    }\n+  }\n+\n+  @Benchmark\n+  public void arrayCopy() {\n+    var mask = SPECIES.maskAll(true);\n+\n+    byte[] in = byteIn;\n+    byte[] out = byteOut;\n+\n+    for (int i = 0; i < SPECIES.loopBound(in.length); i += SPECIES.vectorByteSize()) {\n+      final var v = ByteVector.fromArray(SPECIES, in, i, mask);\n+      v.intoArray(out, i, mask);\n+    }\n+  }\n+\n+  @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+  protected void copyIntoNotInlined(MemorySegment in, MemorySegment out) {\n+    copyMemory(in, out);\n+  }\n+\n+  @CompilerControl(CompilerControl.Mode.INLINE)\n+  protected void copyMemory(MemorySegment in, MemorySegment out) {\n+    var mask = SPECIES.maskAll(true);\n+\n+    for (long i = 0; i < SPECIES.loopBound(in.byteSize()); i += SPECIES.vectorByteSize()) {\n+      final var v = ByteVector.fromMemorySegment(SPECIES, in, i, ByteOrder.nativeOrder(), mask);\n+      v.intoMemorySegment(out, i, ByteOrder.nativeOrder(), mask);\n+    }\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MemorySegmentMaskedVectorAccess.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"}]}