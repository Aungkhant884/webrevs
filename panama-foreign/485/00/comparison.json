{"files":[{"patch":"@@ -205,16 +205,0 @@\n-    \/**\n-     * Allocates a native segment which can be passed to other foreign functions (as a function pointer);\n-     * calling such a function pointer from native code will result in the execution of the provided method handle.\n-     * <p>\n-     * The returned segment is associated with a fresh, shared, resource scope,\n-     * which will be automatically closed when the segment (or views derived from it) is no longer in use.\n-     * The scope associated with the returned segment cannot be closed directly e.g. by calling {@link ResourceScope#close()}.\n-     *\n-     * @param target   the target method handle.\n-     * @param function the function descriptor.\n-     * @return the native stub segment.\n-     * @throws IllegalArgumentException if the target's method type and the function descriptor mismatch.\n-     *\/\n-    @NativeAccess\n-    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function);\n-\n@@ -271,37 +255,0 @@\n-    \/**\n-     * Converts a Java string into a null-terminated C string, using the\n-     * platform's default charset, storing the result into a new native memory segment, associated with\n-     * a fresh {@link ResourceScope#ofDefault() default scope}.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement byte array.  The\n-     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n-     * control over the encoding process is required.\n-     *\n-     * @param str the Java string to be converted into a C string.\n-     * @return a new native memory segment containing the converted C string.\n-     *\/\n-    static MemorySegment toCString(String str) {\n-        Objects.requireNonNull(str);\n-        return toCString(str.getBytes());\n-    }\n-\n-    \/**\n-     * Converts a Java string into a null-terminated C string, using the given {@link java.nio.charset.Charset charset},\n-     * storing the result into a new native memory segment, associated with a fresh {@link ResourceScope#ofDefault() default scope}.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement byte array.  The\n-     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n-     * control over the encoding process is required.\n-     *\n-     * @param str the Java string to be converted into a C string.\n-     * @param charset The {@link java.nio.charset.Charset} to be used to compute the contents of the C string.\n-     * @return a new native memory segment containing the converted C string.\n-     *\/\n-    static MemorySegment toCString(String str, Charset charset) {\n-        Objects.requireNonNull(str);\n-        Objects.requireNonNull(charset);\n-        return toCString(str.getBytes(charset));\n-    }\n-\n@@ -475,6 +422,0 @@\n-    private static MemorySegment toCString(byte[] bytes) {\n-        MemorySegment segment = MemorySegment.allocateNative(bytes.length + 1, 1L);\n-        copy(segment, bytes);\n-        return segment;\n-    }\n-\n@@ -594,13 +535,0 @@\n-        \/**\n-         * Reads the next value as a {@code MemorySegment}, and advances this va list's position.\n-         * <p>\n-         * The memory segment returned by this method is associated with a fresh {@link ResourceScope#ofDefault() default scope}.\n-         *\n-         * @param layout the layout of the value\n-         * @return the value read as an {@code MemorySegment}\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}\n-         *\/\n-        MemorySegment vargAsSegment(MemoryLayout layout);\n-\n@@ -660,1 +588,1 @@\n-         * {@link #make(Consumer)} method, closing this va list will also release the native memory that holds its\n+         * {@link #make(Consumer, ResourceScope)} method, closing this va list will also release the native memory that holds its\n@@ -716,20 +644,0 @@\n-        \/**\n-         * Constructs a new {@code VaList} using a builder (see {@link Builder}), associated with a fresh\n-         * a fresh {@link ResourceScope#ofDefault() default scope}.\n-         * <p>\n-         * If this method needs to allocate native memory, such memory will be managed by the same scope which also\n-         * manages the returned valist instance; as such, this memory will be released only when the returned\n-         * valist instance becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n-         * <p>\n-         * Note that when there are no elements added to the created va list,\n-         * this method will return the same as {@link #empty()}.\n-         *\n-         * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements\n-         *                of the underlying C {@code va_list}.\n-         * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.\n-         *\/\n-        static VaList make(Consumer<Builder> actions) {\n-            Objects.requireNonNull(actions);\n-            return SharedUtils.newVaList(actions, MemoryScope.createDefault());\n-        }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":1,"deletions":93,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -91,26 +91,0 @@\n-    \/**\n-     * Returns a shared native memory segment with given size, and whose base address is this address. This method\n-     * can be useful when interacting with custom native memory sources (e.g. custom allocators), where an address to some\n-     * underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n-     * The returned segment is associated with the {@link ResourceScope#globalScope() global} resource scope.\n-     * <p>\n-     * Clients should ensure that the address and bounds refers to a valid region of memory that is accessible for reading and,\n-     * if appropriate, writing; an attempt to access an invalid memory location from Java code will either return an arbitrary value,\n-     * have no visible effect, or cause an unspecified exception to be thrown.\n-     * <p>\n-     * This method is equivalent to the following code:\n-     * <pre>{@code\n-    asSegment(byteSize, null, ResourceScope.globalScope());\n-     * }<\/pre>\n-     * This method is <em>restricted<\/em>. Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param bytesSize the desired size.\n-     * @return a new native memory segment with given base address and size.\n-     * @throws IllegalArgumentException if {@code bytesSize <= 0}.\n-     * @throws UnsupportedOperationException if this address is an heap address.\n-     *\/\n-    @NativeAccess\n-    MemorySegment asSegment(long bytesSize);\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -65,2 +65,2 @@\n- * be allocated using one of the many factory methods provided (see {@link MemorySegment#allocateNative(MemoryLayout)},\n- * {@link MemorySegment#allocateNative(long)} and {@link MemorySegment#allocateNative(long, long)}). Memory segments obtained\n+ * be allocated using one of the many factory methods provided (see {@link MemorySegment#allocateNative(MemoryLayout, ResourceScope)},\n+ * {@link MemorySegment#allocateNative(long, ResourceScope)} and {@link MemorySegment#allocateNative(long, long, ResourceScope)}). Memory segments obtained\n@@ -82,1 +82,1 @@\n- * {@link MemorySegment#mapFile(Path, long, long, FileChannel.MapMode)}. Such memory segments are called <em>mapped memory segments<\/em>;\n+ * {@link MemorySegment#mapFile(Path, long, long, FileChannel.MapMode, ResourceScope)}. Such memory segments are called <em>mapped memory segments<\/em>;\n@@ -289,1 +289,1 @@\n-     * created using the {@link #mapFile(Path, long, long, FileChannel.MapMode)} factory, or a buffer segment\n+     * created using the {@link #mapFile(Path, long, long, FileChannel.MapMode, ResourceScope)} factory, or a buffer segment\n@@ -556,20 +556,0 @@\n-    \/**\n-     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given layout.\n-     * The returned segment is associated with a fresh {@link ResourceScope#ofDefault() default scope}. Resources associated with this\n-     * segment will be automatically released when the returned segment (or any slices and views derived from it) is no longer in use.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    allocateNative(layout.bytesSize(), layout.bytesAlignment());\n-     * }<\/pre><\/blockquote>\n-     * <p>\n-     * The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n-     *\n-     * @param layout the layout of the off-heap memory block backing the native memory segment.\n-     * @return a new native memory segment.\n-     * @throws IllegalArgumentException if the specified layout has illegal size or alignment constraint.\n-     *\/\n-    static MemorySegment allocateNative(MemoryLayout layout) {\n-        return allocateNative(layout, MemoryScope.createDefault());\n-    }\n-\n@@ -599,20 +579,0 @@\n-    \/**\n-     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size (in bytes).\n-     * The returned segment is associated with a fresh {@link ResourceScope#ofDefault() default scope}. Resources associated with this\n-     * segment will be automatically released when the returned segment (or any slices and views derived from it) is no longer in use.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    allocateNative(bytesSize, 1);\n-     * }<\/pre><\/blockquote>\n-     * <p>\n-     * The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n-     *\n-     * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.\n-     * @return a new native memory segment.\n-     * @throws IllegalArgumentException if {@code bytesSize <= 0}.\n-     *\/\n-    static MemorySegment allocateNative(long bytesSize) {\n-        return allocateNative(bytesSize, 1);\n-    }\n-\n@@ -640,18 +600,0 @@\n-    \/**\n-     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size\n-     * and alignment constraints (in bytes). The returned segment is associated with a fresh {@link ResourceScope#ofDefault() default scope}.\n-     * Resources associated with this segment will be automatically released when the returned segment\n-     * (or any slices and views derived from it) is no longer in use.\n-     * <p>\n-     * The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n-     *\n-     * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.\n-     * @param alignmentBytes the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.\n-     * @return a new native memory segment.\n-     * @throws IllegalArgumentException if {@code bytesSize <= 0}, {@code alignmentBytes <= 0}, or if {@code alignmentBytes}\n-     * is not a power of 2.\n-     *\/\n-    static MemorySegment allocateNative(long bytesSize, long alignmentBytes) {\n-        return allocateNative(bytesSize, alignmentBytes, MemoryScope.createDefault());\n-    }\n-\n@@ -687,33 +629,0 @@\n-    \/**\n-     * Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.\n-     * The returned segment is associated with a fresh {@link ResourceScope#ofDefault() default scope}. Resources associated with this\n-     * segment will be automatically released when the returned segment (or any slices and views derived from it) is no longer in use.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    mapFile(path, bytesOffset, bytesSize, mapMode, ResourceScope.ofShared(Cleaner.create()));\n-     * }<\/pre><\/blockquote>\n-     *\n-     * @implNote When obtaining a mapped segment from a newly created file, the initialization state of the contents of the block\n-     * of mapped memory associated with the returned mapped memory segment is unspecified and should not be relied upon.\n-     *\n-     * @param path the path to the file to memory map.\n-     * @param bytesOffset the offset (expressed in bytes) within the file at which the mapped segment is to start.\n-     * @param bytesSize the size (in bytes) of the mapped memory backing the memory segment.\n-     * @param mapMode a file mapping mode, see {@link FileChannel#map(FileChannel.MapMode, long, long)}; the chosen mapping mode\n-     *                might affect the behavior of the returned memory mapped segment (see {@link MappedMemorySegments#force(MemorySegment)}).\n-     * @return a new mapped memory segment.\n-     * @throws IllegalArgumentException if {@code bytesOffset < 0}.\n-     * @throws IllegalArgumentException if {@code bytesSize < 0}.\n-     * @throws UnsupportedOperationException if an unsupported map mode is specified, or if the {@code path} is associated\n-     * with a provider that does not support creating file channels.\n-     * @throws IOException if the specified path does not point to an existing file, or if some other I\/O error occurs.\n-     * @throws  SecurityException If a security manager is installed and it denies an unspecified permission required by the implementation.\n-     * In the case of the default provider, the {@link SecurityManager#checkRead(String)} method is invoked to check\n-     * read access if the file is opened for reading. The {@link SecurityManager#checkWrite(String)} method is invoked to check\n-     * write access if the file is opened for writing.\n-     *\/\n-    static MemorySegment mapFile(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {\n-        return mapFile(path, bytesOffset, bytesSize, mapMode, MemoryScope.createDefault());\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":4,"deletions":95,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -69,0 +69,4 @@\n+ * <p>\n+ * Some resource scopes (see {@link #ofImplicit()}, {@link #globalScope()} are said to be <em>implicit scopes<\/em>.\n+ * An implicit resource scope only features implicit closure, and always throws an {@link UnsupportedOperationException}\n+ * when the {@link #close()} method is called directly.\n@@ -143,0 +147,8 @@\n+    \/**\n+     * Is this resource scope an <em>implicit scope<\/em>?\n+     * @return true if this scope is an an <em>implicit scope<\/em>.\n+     * @see #ofImplicit()\n+     * @see #globalScope()\n+     *\/\n+    boolean isImplicit();\n+\n@@ -160,3 +172,1 @@\n-     * @throws UnsupportedOperationException if the {@code close} operation is not supported by this resource scope. This\n-     * is the case for the resource scope returned by {@link #globalScope()}, or the resource scopes associated to\n-     * memory segments created using certain factories (such as {@link MemorySegment#allocateNative(long)}).\n+     * @throws UnsupportedOperationException if this resource scope is {@link #isImplicit() implicit}.\n@@ -203,1 +213,1 @@\n-        return ofConfined(null, null);\n+        return MemoryScope.createConfined( null);\n@@ -214,12 +224,1 @@\n-        return ofConfined(null, cleaner);\n-    }\n-\n-    \/**\n-     * Create a new confined scope. The resulting scope might be managed by a {@link Cleaner} (where provided).\n-     * An optional attachment can be associated with the resulting scope.\n-     * @param attachment an attachment object which is kept alive by the returned resource scope (can be {@code null}).\n-     * @param cleaner the cleaner to be associated with the returned scope. Can be {@code null}.\n-     * @return a new confined scope, managed by {@code cleaner} (where provided).\n-     *\/\n-    static ResourceScope ofConfined(Object attachment, Cleaner cleaner) {\n-        return MemoryScope.createConfined(attachment, cleaner);\n+        return MemoryScope.createConfined( cleaner);\n@@ -233,1 +232,1 @@\n-        return ofShared(null, null);\n+        return MemoryScope.createShared(null);\n@@ -244,12 +243,1 @@\n-        return ofShared(null, cleaner);\n-    }\n-\n-    \/**\n-     * Create a new shared scope. The resulting scope might be managed by a {@link Cleaner} (where provided).\n-     * An optional attachment can be associated with the resulting scope.\n-     * @param attachment an attachment object which is kept alive by the returned resource scope (can be {@code null}).\n-     * @param cleaner the cleaner to be associated with the returned scope. Can be {@code null}.\n-     * @return a new shared scope, managed by {@code cleaner} (where provided).\n-     *\/\n-    static ResourceScope ofShared(Object attachment, Cleaner cleaner) {\n-        return MemoryScope.createShared(attachment, cleaner);\n+        return MemoryScope.createShared(cleaner);\n@@ -259,1 +247,1 @@\n-     * Create a new <em>default scope<\/em>. The default scope is a shared and non-closeable scope which only features\n+     * Create a new <em>implicit scope<\/em>. The implicit scope is a shared and non-closeable scope which only features\n@@ -261,8 +249,3 @@\n-     * This resource scope is used as a valid default where no resource scope is provided by the user. For instance, this code:\n-     * <blockquote><pre>{@code\n-    MemorySegment.allocateNative(10);\n-     * }<\/pre><\/blockquote>\n-     * is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    MemorySegment.allocateNative(10, ResourceScope.ofDefault());\n-     * }<\/pre><\/blockquote>\n+     * Since implicit scopes can only be closed implicitly by the garbage collector, it is recommended that implicit\n+     * scopes are only used in cases where deallocation performance is not a critical concern, to avoid unnecessary\n+     * memory pressure.\n@@ -270,1 +253,1 @@\n-     * @return a new default scope.\n+     * @return a new implicit scope.\n@@ -272,2 +255,2 @@\n-    static ResourceScope ofDefault() {\n-        return MemoryScope.createDefault();\n+    static ResourceScope ofImplicit() {\n+        return MemoryScope.createImplicitScope();\n@@ -277,1 +260,1 @@\n-     * A non-closeable, shared, global scope which is assumed to be always alive.\n+     * Returns an implicit scope which is assumed to be always alive.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ResourceScope.java","additions":25,"deletions":42,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n- * (e.g. {@link MemorySegment#allocateNative(long, long)}); since {@link SegmentAllocator} is a <em>functional interface<\/em>,\n+ * (e.g. {@link MemorySegment#allocateNative(long, long, ResourceScope)}); since {@link SegmentAllocator} is a <em>functional interface<\/em>,\n@@ -56,1 +56,1 @@\n-   SegmentAllocator allocator = SegmentAllocator.of(scope);\n+   SegmentAllocator allocator = SegmentAllocator.scoped(scope);\n@@ -461,2 +461,1 @@\n-     * Returns the default native allocator which creates segments using the default\n-     * {@link MemorySegment#allocateNative(long, long) native segment factory}. This code is equivalent\n+     * Returns a native allocator which creates segments associated with fresh implicit scopes. This code is equivalent\n@@ -465,1 +464,1 @@\n-    SegmentAllocator defaultAllocator = (size, align) -> MemorySegment.allocateNative(size, align);\n+    SegmentAllocator implicitAllocator = (size, align) -> MemorySegment.allocateNative(size, align, ResourceScope.ofImplicit());\n@@ -467,1 +466,1 @@\n-     * @return the default native allocator.\n+     * @return the implicit native allocator.\n@@ -469,2 +468,2 @@\n-    static SegmentAllocator ofDefault() {\n-        return NativeMemorySegmentImpl.DEFAULT_ALLOCATOR;\n+    static SegmentAllocator implicit() {\n+        return NativeMemorySegmentImpl.IMPLICIT_ALLOCATOR;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n- * native strings and viceversa (see {@link jdk.incubator.foreign.CLinker#toCString(java.lang.String)} and\n+ * native strings and viceversa (see {@link jdk.incubator.foreign.CLinker#toCString(java.lang.String, ResourceScope)} and\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,6 +61,0 @@\n-\n-    @CallerSensitive\n-    public final MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        return upcallStub(target, function, MemoryScope.createDefault());\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractCLinker.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-    public ConfinedScope(Thread owner, Object ref, Cleaner cleaner) {\n-        super(ref, cleaner, new ConfinedResourceList());\n+    public ConfinedScope(Thread owner, Cleaner cleaner) {\n+        super(cleaner, new ConfinedResourceList());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ConfinedScope.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-                MemoryScope s = MemoryScope.createDefault();\n+                MemoryScope s = MemoryScope.createImplicitScope();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LibrariesHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,7 +108,0 @@\n-    @Override\n-    @CallerSensitive\n-    public final MemorySegment asSegment(long bytesSize) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        return asSegment(bytesSize, null, ResourceScope.globalScope());\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-    protected final Object ref;\n@@ -64,0 +63,5 @@\n+    @Override\n+    public boolean isImplicit() {\n+        return false;\n+    }\n+\n@@ -91,2 +95,1 @@\n-    protected MemoryScope(Object ref, Cleaner cleaner, ResourceList resourceList) {\n-        this.ref = ref;\n+    protected MemoryScope(Cleaner cleaner, ResourceList resourceList) {\n@@ -99,2 +102,2 @@\n-    public static MemoryScope createDefault() {\n-        return new NonCloseableSharedScope(null, CleanerFactory.cleaner());\n+    public static MemoryScope createImplicitScope() {\n+        return new NonCloseableSharedScope(CleanerFactory.cleaner());\n@@ -103,2 +106,2 @@\n-    public static MemoryScope createConfined(Thread thread, Object ref, Cleaner cleaner) {\n-        return new ConfinedScope(thread, ref, cleaner);\n+    public static MemoryScope createConfined(Thread thread, Cleaner cleaner) {\n+        return new ConfinedScope(thread, cleaner);\n@@ -110,1 +113,0 @@\n-     * @param ref           an optional reference to an instance that needs to be kept reachable\n@@ -113,2 +115,2 @@\n-    public static MemoryScope createConfined(Object ref, Cleaner cleaner) {\n-        return new ConfinedScope(Thread.currentThread(), ref, cleaner);\n+    public static MemoryScope createConfined(Cleaner cleaner) {\n+        return new ConfinedScope(Thread.currentThread(), cleaner);\n@@ -119,1 +121,0 @@\n-     * @param ref           an optional reference to an instance that needs to be kept reachable\n@@ -122,2 +123,2 @@\n-    public static MemoryScope createShared(Object ref, Cleaner cleaner) {\n-        return new SharedScope(ref, cleaner);\n+    public static MemoryScope createShared(Cleaner cleaner) {\n+        return new SharedScope(cleaner);\n@@ -200,2 +201,2 @@\n-        public NonCloseableSharedScope(Object ref, Cleaner cleaner) {\n-            super(ref, cleaner);\n+        public NonCloseableSharedScope(Cleaner cleaner) {\n+            super(cleaner);\n@@ -213,0 +214,5 @@\n+        @Override\n+        public boolean isImplicit() {\n+            return true;\n+        }\n+\n@@ -224,1 +230,1 @@\n-    public static MemoryScope GLOBAL = new NonCloseableSharedScope( null, null) {\n+    public static MemoryScope GLOBAL = new NonCloseableSharedScope( null) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryScope.java","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -49,1 +50,1 @@\n-    public static final SegmentAllocator DEFAULT_ALLOCATOR = MemorySegment::allocateNative;\n+    public static final SegmentAllocator IMPLICIT_ALLOCATOR = (size, align) -> MemorySegment.allocateNative(size, align, ResourceScope.ofImplicit());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -66,2 +66,2 @@\n-    SharedScope(Object ref, Cleaner cleaner) {\n-        super(ref, cleaner, new SharedResourceList());\n+    SharedScope(Cleaner cleaner) {\n+        super(cleaner, new SharedResourceList());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SharedScope.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -294,2 +294,2 @@\n-         * Dummy binding context. Throws exceptions when attempting to access allocator\/scope, and its\n-         * {@link #close()} is idempotent.\n+         * Dummy binding context. Throws exceptions when attempting to access scope, return a throwing allocator, and has\n+         * an idempotent {@link #close()}.\n@@ -300,1 +300,1 @@\n-                throw new UnsupportedOperationException();\n+                return SharedUtils.THROWING_ALLOCATOR;\n@@ -313,6 +313,0 @@\n-\n-        \/**\n-         * Default binding context. Does not provide a resource scope, but provides a default {@link SegmentAllocator}\n-         * which uses {@link MemorySegment#allocateNative(long, long)}.\n-         *\/\n-        public static Context DEFAULT = ofAllocator(MemorySegment::allocateNative);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -105,4 +105,2 @@\n-    \/\/ workaround for https:\/\/bugs.openjdk.java.net\/browse\/JDK-8239083\n-    private static MemorySegment allocateNative(MemoryLayout layout) {\n-        return MemorySegment.allocateNative(layout);\n-    }\n+    \/\/ this allocator should be used when no allocation is expected\n+    public final static SegmentAllocator THROWING_ALLOCATOR = (size, align) -> { throw new IllegalStateException(\"Cannot get here\"); };\n@@ -568,5 +566,0 @@\n-        @Override\n-        public MemorySegment vargAsSegment(MemoryLayout layout) {\n-            throw uoe();\n-        }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import jdk.internal.vm.annotation.NativeAccess;\n@@ -87,2 +86,2 @@\n-            \/\/ not returning segment, just insert default allocator\n-            handle = MethodHandles.insertArguments(handle, 1, Binding.Context.DEFAULT.allocator());\n+            \/\/ not returning segment, just insert a throwing allocator\n+            handle = MethodHandles.insertArguments(handle, 1, SharedUtils.THROWING_ALLOCATOR);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Linker.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import static jdk.internal.foreign.abi.SharedUtils.THROWING_ALLOCATOR;\n@@ -231,5 +232,0 @@\n-    @Override\n-    public MemorySegment vargAsSegment(MemoryLayout layout) {\n-        return (MemorySegment) read(MemorySegment.class, layout);\n-    }\n-\n@@ -248,1 +244,1 @@\n-        return read(carrier, layout, MemorySegment::allocateNative);\n+        return read(carrier, layout, THROWING_ALLOCATOR);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64VaList.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import static jdk.internal.foreign.abi.SharedUtils.THROWING_ALLOCATOR;\n@@ -209,5 +210,0 @@\n-    @Override\n-    public MemorySegment vargAsSegment(MemoryLayout layout) {\n-        return (MemorySegment) read(MemorySegment.class, layout);\n-    }\n-\n@@ -226,1 +222,1 @@\n-        return read(carrier, layout, MemorySegment::allocateNative);\n+        return read(carrier, layout, THROWING_ALLOCATOR);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import jdk.internal.vm.annotation.NativeAccess;\n@@ -98,2 +97,2 @@\n-            \/\/ not returning segment, just insert default allocator\n-            handle = MethodHandles.insertArguments(handle, 1, Binding.Context.DEFAULT.allocator());\n+            \/\/ not returning segment, just insert a throwing allocator\n+            handle = MethodHandles.insertArguments(handle, 1, SharedUtils.THROWING_ALLOCATOR);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -97,5 +97,0 @@\n-    @Override\n-    public MemorySegment vargAsSegment(MemoryLayout layout) {\n-        return (MemorySegment) read(MemorySegment.class, layout);\n-    }\n-\n@@ -114,1 +109,1 @@\n-        return read(carrier, layout, MemorySegment::allocateNative);\n+        return read(carrier, layout, SharedUtils.THROWING_ALLOCATOR);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.internal.vm.annotation.NativeAccess;\n@@ -99,2 +98,2 @@\n-            \/\/ not returning segment, just insert default allocator\n-            handle = MethodHandles.insertArguments(handle, 1, Binding.Context.DEFAULT.allocator());\n+            \/\/ not returning segment, just insert a throwing allocator\n+            handle = MethodHandles.insertArguments(handle, 1, SharedUtils.THROWING_ALLOCATOR);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -363,1 +364,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(layout);\n+            MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.ofImplicit());\n@@ -367,1 +368,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(1);\n+            MemorySegment segment = MemorySegment.allocateNative(1, ResourceScope.ofImplicit());\n@@ -371,1 +372,1 @@\n-                        assertEquals((MemoryAddress)o, segment.address());\n+                        assertEquals(o, segment.address());\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -260,1 +260,1 @@\n-                this.base = addr.asSegment(SIZE);\n+                this.base = addr.asSegment(SIZE, ResourceScope.globalScope());\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -99,1 +100,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.ofImplicit());\n@@ -118,1 +119,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.ofImplicit());\n@@ -139,1 +140,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.ofImplicit());\n@@ -207,1 +208,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.ofImplicit());\n@@ -250,1 +251,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.ofImplicit());\n@@ -288,1 +289,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.ofImplicit());\n@@ -327,1 +328,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.ofImplicit());\n@@ -370,1 +371,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.ofImplicit());\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.ofImplicit());\n@@ -115,1 +115,1 @@\n-        MemorySegment segment = MemoryAddress.NULL.asSegment(seq.byteSize());\n+        MemorySegment segment = MemoryAddress.NULL.asSegment(seq.byteSize(), ResourceScope.globalScope());\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -271,1 +271,1 @@\n-        MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 8, FileChannel.MapMode.READ_WRITE);\n+        MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 8, FileChannel.MapMode.READ_WRITE, ResourceScope.ofImplicit());\n@@ -458,1 +458,1 @@\n-        MemorySegment segment = MemoryAddress.NULL.asSegment(Integer.MAX_VALUE + 10L);\n+        MemorySegment segment = MemoryAddress.NULL.asSegment(Integer.MAX_VALUE + 10L, ResourceScope.globalScope());\n@@ -467,1 +467,1 @@\n-        MemorySegment.mapFile(f.toPath(), 0L, -1, FileChannel.MapMode.READ_WRITE);\n+        MemorySegment.mapFile(f.toPath(), 0L, -1, FileChannel.MapMode.READ_WRITE, ResourceScope.ofImplicit());\n@@ -475,1 +475,1 @@\n-        MemorySegment.mapFile(f.toPath(), -1, 1, FileChannel.MapMode.READ_WRITE);\n+        MemorySegment.mapFile(f.toPath(), -1, 1, FileChannel.MapMode.READ_WRITE, ResourceScope.ofImplicit());\n@@ -534,1 +534,1 @@\n-        MemorySegment.mapFile(path, 0L, 0L, FileChannel.MapMode.READ_WRITE);\n+        MemorySegment.mapFile(path, 0L, 0L, FileChannel.MapMode.READ_WRITE, ResourceScope.ofImplicit());\n@@ -699,1 +699,1 @@\n-                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16) },\n+                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, ResourceScope.ofImplicit()) },\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-        Object res = doCall(addr, SegmentAllocator.ofDefault(), mt, descriptor, args);\n+        Object res = doCall(addr, SegmentAllocator.implicit(), mt, descriptor, args);\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import jdk.incubator.foreign.ResourceScope;\n+\n@@ -41,1 +43,1 @@\n-        return addr.asSegment(numElements * layout.byteSize());\n+        return addr.asSegment(numElements * layout.byteSize(), ResourceScope.globalScope());\n","filename":"test\/jdk\/java\/foreign\/TestFree.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -67,1 +68,1 @@\n-            NATIVE(MemorySegment::allocateNative),\n+            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.ofImplicit())),\n","filename":"test\/jdk\/java\/foreign\/TestMemoryCopy.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-        NATIVE(MemorySegment::allocateNative),\n+        NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.ofImplicit())),\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-            segment.address().asSegment(0);\n+            segment.address().asSegment(0, ResourceScope.globalScope());\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,5 +109,1 @@\n-            \"jdk.incubator.foreign.FunctionDescriptor\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"jdk.incubator.foreign.ResourceScope\/ofConfined(java.lang.Object,java.lang.ref.Cleaner)\/0\/0\",\n-            \"jdk.incubator.foreign.ResourceScope\/ofConfined(java.lang.Object,java.lang.ref.Cleaner)\/1\/0\",\n-            \"jdk.incubator.foreign.ResourceScope\/ofShared(java.lang.Object,java.lang.ref.Cleaner)\/0\/0\",\n-            \"jdk.incubator.foreign.ResourceScope\/ofShared(java.lang.Object,java.lang.ref.Cleaner)\/1\/0\"\n+            \"jdk.incubator.foreign.FunctionDescriptor\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\"\n@@ -166,1 +162,1 @@\n-        addDefaultMapping(SegmentAllocator.class, MemorySegment::allocateNative);\n+        addDefaultMapping(SegmentAllocator.class, SegmentAllocator.implicit());\n@@ -179,1 +175,1 @@\n-            });\n+            }, ResourceScope.ofImplicit());\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -84,1 +85,1 @@\n-            NATIVE(MemorySegment::allocateNative),\n+            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.ofImplicit())),\n","filename":"test\/jdk\/java\/foreign\/TestRebase.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,1 +55,3 @@\n-        ResourceScope scope = ResourceScope.ofConfined(null, cleaner);\n+        ResourceScope scope = cleaner != null ?\n+                ResourceScope.ofConfined(cleaner) :\n+                ResourceScope.ofConfined();\n@@ -78,1 +80,3 @@\n-        ResourceScope scope = ResourceScope.ofShared(null, cleaner);\n+        ResourceScope scope = cleaner != null ?\n+                ResourceScope.ofShared(cleaner) :\n+                ResourceScope.ofShared();\n@@ -102,1 +106,3 @@\n-        ResourceScope scope = ResourceScope.ofShared(null, cleaner);\n+        ResourceScope scope = cleaner != null ?\n+                ResourceScope.ofShared(cleaner) :\n+                ResourceScope.ofShared();\n@@ -150,1 +156,3 @@\n-        ResourceScope scope = ResourceScope.ofConfined(null, cleaner);\n+        ResourceScope scope = cleaner != null ?\n+                ResourceScope.ofConfined(cleaner) :\n+                ResourceScope.ofConfined();\n@@ -174,1 +182,3 @@\n-        ResourceScope scope = ResourceScope.ofShared(null, cleaner);\n+        ResourceScope scope = cleaner != null ?\n+                ResourceScope.ofShared(cleaner) :\n+                ResourceScope.ofShared();\n","filename":"test\/jdk\/java\/foreign\/TestResourceScope.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -58,2 +59,2 @@\n-        Method method = MemoryAddress.class.getDeclaredMethod(\"asSegment\", long.class);\n-        method.invoke(MemoryAddress.NULL, 4000L);\n+        Method method = MemoryAddress.class.getDeclaredMethod(\"asSegment\", long.class, ResourceScope.class);\n+        method.invoke(MemoryAddress.NULL, 4000L, ResourceScope.globalScope());\n@@ -65,2 +66,2 @@\n-            MethodType.methodType(MemorySegment.class, long.class));\n-        var seg = (MemorySegment)mh.invokeExact(MemoryAddress.NULL, 4000L);\n+            MethodType.methodType(MemorySegment.class, long.class, ResourceScope.class));\n+        var seg = (MemorySegment)mh.invokeExact(MemoryAddress.NULL, 4000L, ResourceScope.globalScope());\n@@ -71,1 +72,1 @@\n-        MemoryAddress.NULL.asSegment(4000L);\n+        MemoryAddress.NULL.asSegment(4000L, ResourceScope.globalScope());\n","filename":"test\/jdk\/java\/foreign\/TestRestricted.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-            ScopedOperation.ofVaList(list -> list.vargAsSegment(MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT)), \"VaList::vargAsSegment\/1\");\n+            ScopedOperation.ofVaList(list -> list.vargAsSegment(MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT), ResourceScope.ofImplicit()), \"VaList::vargAsSegment\/1\");\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-        MemorySegment.allocateNative(size, align);\n+        MemorySegment.allocateNative(size, align, ResourceScope.ofImplicit());\n@@ -63,1 +63,1 @@\n-        MemorySegment.allocateNative(layout);\n+        MemorySegment.allocateNative(layout, ResourceScope.ofImplicit());\n@@ -69,1 +69,1 @@\n-        MemorySegment.allocateNative(Long.MAX_VALUE);\n+        MemorySegment.allocateNative(Long.MAX_VALUE, ResourceScope.ofImplicit());\n@@ -74,1 +74,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(1024 * 1024 * 8 * 2); \/\/ 2M\n+        MemorySegment segment = MemorySegment.allocateNative(1024 * 1024 * 8 * 2, ResourceScope.ofImplicit()); \/\/ 2M\n@@ -119,1 +119,1 @@\n-        try {\n+        if (!segment.scope().isImplicit()) {\n@@ -121,2 +121,0 @@\n-        } catch (UnsupportedOperationException ex) {\n-            \/\/ whoops - scope is not closeable\n@@ -136,3 +134,3 @@\n-                () -> MemorySegment.allocateNative(4),\n-                () -> MemorySegment.allocateNative(4, 8),\n-                () -> MemorySegment.allocateNative(MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder())),\n+                () -> MemorySegment.allocateNative(4, ResourceScope.ofImplicit()),\n+                () -> MemorySegment.allocateNative(4, 8, ResourceScope.ofImplicit()),\n+                () -> MemorySegment.allocateNative(MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder()), ResourceScope.ofImplicit()),\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.ofImplicit());\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-        dummyStub = abi.upcallStub(DUMMY, FunctionDescriptor.ofVoid());\n+        dummyStub = abi.upcallStub(DUMMY, FunctionDescriptor.ofVoid(), ResourceScope.ofImplicit());\n@@ -111,2 +111,2 @@\n-        MethodHandle mh = abi.downcallHandle(addr, SegmentAllocator.ofDefault(), mtype, function(ret, paramTypes, fields));\n-        Object[] args = makeArgs(ResourceScope.ofDefault(), ret, paramTypes, fields, returnChecks, argChecks);\n+        MethodHandle mh = abi.downcallHandle(addr, SegmentAllocator.implicit(), mtype, function(ret, paramTypes, fields));\n+        Object[] args = makeArgs(ResourceScope.ofImplicit(), ret, paramTypes, fields, returnChecks, argChecks);\n@@ -200,1 +200,1 @@\n-                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize());\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), ResourceScope.ofImplicit());\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize());\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), ResourceScope.ofImplicit());\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(1, 2);\n+        MemorySegment segment = MemorySegment.allocateNative(1, 2, ResourceScope.ofImplicit());\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-                    MemorySegment struct = list.vargAsSegment(pointLayout);\n+                    MemorySegment struct = list.vargAsSegment(pointLayout, ResourceScope.ofImplicit());\n@@ -276,1 +276,1 @@\n-                    MemorySegment struct = list.vargAsSegment(BigPoint_LAYOUT);\n+                    MemorySegment struct = list.vargAsSegment(BigPoint_LAYOUT, ResourceScope.ofImplicit());\n@@ -328,1 +328,1 @@\n-                    MemorySegment struct = list.vargAsSegment(FloatPoint_LAYOUT);\n+                    MemorySegment struct = list.vargAsSegment(FloatPoint_LAYOUT, ResourceScope.ofImplicit());\n@@ -385,1 +385,1 @@\n-                    MemorySegment struct = list.vargAsSegment(HugePoint_LAYOUT);\n+                    MemorySegment struct = list.vargAsSegment(HugePoint_LAYOUT, ResourceScope.ofImplicit());\n@@ -660,1 +660,1 @@\n-                    MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT);\n+                    MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT, ResourceScope.ofImplicit());\n@@ -666,1 +666,1 @@\n-                    MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT);\n+                    MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT, ResourceScope.ofImplicit());\n@@ -674,1 +674,1 @@\n-                    struct = copy.vargAsSegment(BigPoint_LAYOUT);\n+                    struct = copy.vargAsSegment(BigPoint_LAYOUT, ResourceScope.ofImplicit());\n@@ -679,1 +679,1 @@\n-                    MemorySegment struct = vaList.vargAsSegment(Point_LAYOUT);\n+                    MemorySegment struct = vaList.vargAsSegment(Point_LAYOUT, ResourceScope.ofImplicit());\n@@ -684,1 +684,1 @@\n-                    MemorySegment struct = vaList.vargAsSegment(HugePoint_LAYOUT);\n+                    MemorySegment struct = vaList.vargAsSegment(HugePoint_LAYOUT, ResourceScope.ofImplicit());\n@@ -690,1 +690,1 @@\n-                    MemorySegment struct = vaList.vargAsSegment(FloatPoint_LAYOUT);\n+                    MemorySegment struct = vaList.vargAsSegment(FloatPoint_LAYOUT, ResourceScope.ofImplicit());\n@@ -696,1 +696,1 @@\n-                    MemorySegment ms = intPtr.asSegment(C_INT.byteSize());\n+                    MemorySegment ms = intPtr.asSegment(C_INT.byteSize(), ResourceScope.globalScope());\n@@ -735,1 +735,1 @@\n-                    MemorySegment point = vaList.vargAsSegment(Point_LAYOUT);\n+                    MemorySegment point = vaList.vargAsSegment(Point_LAYOUT, ResourceScope.ofImplicit());\n@@ -740,1 +740,1 @@\n-                    MemorySegment bigPoint = vaList.vargAsSegment(BigPoint_LAYOUT);\n+                    MemorySegment bigPoint = vaList.vargAsSegment(BigPoint_LAYOUT, ResourceScope.ofImplicit());\n@@ -748,1 +748,1 @@\n-                    MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT);\n+                    MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT, ResourceScope.ofImplicit());\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"}]}