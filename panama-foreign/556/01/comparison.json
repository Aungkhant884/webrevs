{"files":[{"patch":"@@ -28,1 +28,15 @@\n-      echo \"usage: $0 [-h|--help] [-v|--verbose] [-o|--output <path>] [modules]+\"\n+      echo \"Usage: $0 [-h|--help] [-q|--quiet] [-a|--absolute-paths] [-o|--output <path>] [modules...]\"\n+      echo \"    -h | --help\"\n+      echo \"    -q | --quiet\n+        No stdout output\"\n+      echo \"    -a | --absolute-paths\n+        Use absolute paths to this jdk, so that generated .idea\n+        project files can be moved independently of jdk sources\"\n+      echo \"    -o | --output <path>\n+        Where .idea directory with project files will be generated\n+        (e.g. using '-o .' will place project files in '.\/.idea')\n+        Default: $TOPLEVEL_DIR\"\n+      echo \"    [modules...]\n+        Generate project modules for specific java modules\n+        (e.g. 'java.base java.desktop')\n+        Default: all existing modules (java.* and jdk.*)\"\n@@ -36,0 +50,1 @@\n+cd .. ; TOPLEVEL_DIR=`pwd`\n@@ -38,3 +53,3 @@\n-IDEA_OUTPUT=$TOP\/.idea\n-CUSTOM_IDEA_OUTPUT=false\n-VERBOSE=\"false\"\n+IDEA_OUTPUT=$TOPLEVEL_DIR\/.idea\n+VERBOSE=true\n+ABSOLUTE_PATHS=false\n@@ -48,2 +63,6 @@\n-    -v | --vebose )\n-      VERBOSE=\"true\"\n+    -q | --quiet )\n+      VERBOSE=false\n+      ;;\n+\n+    -a | --absolute-paths )\n+      ABSOLUTE_PATHS=true\n@@ -54,1 +73,0 @@\n-      CUSTOM_IDEA_OUTPUT=true\n@@ -71,0 +89,1 @@\n+cd ..; IDEA_OUTPUT_PARENT=`pwd`\n@@ -72,7 +91,1 @@\n-if [ \"x$TOPLEVEL_DIR\" = \"x\" ] ; then\n-    cd $SCRIPT_DIR\/..\n-    TOPLEVEL_DIR=`pwd`\n-    cd $IDEA_OUTPUT\n-fi\n-\n-MAKE_DIR=\"$SCRIPT_DIR\/..\/make\"\n+MAKE_DIR=\"$TOPLEVEL_DIR\/make\"\n@@ -91,3 +104,2 @@\n-if [ \"$VERBOSE\" = \"true\" ] ; then\n-  echo \"output dir: $IDEA_OUTPUT\"\n-  echo \"idea template dir: $IDEA_TEMPLATE\"\n+if [ \"$VERBOSE\" = true ] ; then\n+  echo \"Will generate IDEA project files in \\\"$IDEA_OUTPUT\\\" for project \\\"$TOPLEVEL_DIR\\\"\"\n@@ -96,1 +108,2 @@\n-cd $TOP ; make -f \"$IDEA_MAKE\/idea.gmk\" -I $MAKE_DIR\/.. idea MAKEOVERRIDES= OUT=$IDEA_OUTPUT\/env.cfg MODULES=\"$*\" || exit 1\n+cd $TOP ; make -f \"$IDEA_MAKE\/idea.gmk\" -I \"$TOPLEVEL_DIR\" idea \\\n+    MAKEOVERRIDES= IDEA_OUTPUT_PARENT=\"$IDEA_OUTPUT_PARENT\" OUT=\"$IDEA_OUTPUT\/env.cfg\" MODULES=\"$*\" || exit 1\n@@ -101,1 +114,1 @@\n-# Expect MODULES, MODULE_NAMES, BOOT_JDK & SPEC to be set\n+# Expect MODULES, MODULE_NAMES, RELATIVE_PROJECT_DIR, RELATIVE_BUILD_DIR to be set\n@@ -110,2 +123,2 @@\n-if [ \"x$BOOT_JDK\" = \"x\" ] ; then\n-  echo \"FATAL: BOOT_JDK is empty\" >&2; exit 1\n+if [ \"x$RELATIVE_PROJECT_DIR\" = \"x\" ] ; then\n+  echo \"FATAL: RELATIVE_PROJECT_DIR is empty\" >&2; exit 1\n@@ -114,2 +127,2 @@\n-if [ \"x$SPEC\" = \"x\" ] ; then\n-  echo \"FATAL: SPEC is empty\" >&2; exit 1\n+if [ \"x$RELATIVE_BUILD_DIR\" = \"x\" ] ; then\n+  echo \"FATAL: RELATIVE_BUILD_DIR is empty\" >&2; exit 1\n@@ -126,0 +139,23 @@\n+if [ \"$ABSOLUTE_PATHS\" = true ] ; then\n+  if [ \"x$PATHTOOL\" != \"x\" ]; then\n+    PROJECT_DIR=\"`$PATHTOOL -am $TOPLEVEL_DIR`\"\n+  else\n+    PROJECT_DIR=\"$TOPLEVEL_DIR\"\n+  fi\n+  MODULE_DIR=\"$PROJECT_DIR\"\n+  cd \"$TOPLEVEL_DIR\" && cd \"$RELATIVE_BUILD_DIR\" && BUILD_DIR=\"`pwd`\"\n+else\n+  if [ \"$RELATIVE_PROJECT_DIR\" = \".\" ] ; then\n+    PROJECT_DIR=\"\"\n+  else\n+    PROJECT_DIR=\"\/$RELATIVE_PROJECT_DIR\"\n+  fi\n+  MODULE_DIR=\"\\$MODULE_DIR\\$$PROJECT_DIR\"\n+  PROJECT_DIR=\"\\$PROJECT_DIR\\$$PROJECT_DIR\"\n+  BUILD_DIR=\"\\$PROJECT_DIR\\$\/$RELATIVE_BUILD_DIR\"\n+fi\n+if [ \"$VERBOSE\" = true ] ; then\n+  echo \"Project root: $PROJECT_DIR\"\n+  echo \"Generating IDEA project files...\"\n+fi\n+\n@@ -149,0 +185,2 @@\n+add_replacement \"###PROJECT_DIR###\" \"$PROJECT_DIR\"\n+add_replacement \"###MODULE_DIR###\" \"$MODULE_DIR\"\n@@ -151,4 +189,1 @@\n-SPEC_DIR=`dirname $SPEC`\n-RELATIVE_SPEC_DIR=\"`realpath --relative-to=\\\"$TOPLEVEL_DIR\\\" \\\"$SPEC_DIR\\\"`\"\n-add_replacement \"###BUILD_DIR###\" \"$RELATIVE_SPEC_DIR\"\n-add_replacement \"###IMAGES_DIR###\" \"$RELATIVE_SPEC_DIR\/images\/jdk\"\n+add_replacement \"###BUILD_DIR###\" \"$BUILD_DIR\"\n@@ -156,5 +191,1 @@\n-  if [ \"$CUSTOM_IDEA_OUTPUT\" = true ]; then\n-    add_replacement \"###BASH_RUNNER_PREFIX###\" \"`$PATHTOOL -am $IDEA_OUTPUT\/.idea\/bash.bat`\"\n-  else\n-    add_replacement \"###BASH_RUNNER_PREFIX###\" \".idea\\\\\\\\bash.bat\"\n-  fi\n+  add_replacement \"###BASH_RUNNER_PREFIX###\" \"\\$PROJECT_DIR\\$\/.idea\/bash.bat\"\n@@ -187,0 +218,3 @@\n+if [ \"$VERBOSE\" = true ] ; then\n+    echo \"Generating project modules:\"\n+  fi\n@@ -190,5 +224,0 @@\n-if [ \"x$PATHTOOL\" != \"x\" ]; then\n-  TOPDIR_FOR_RELATIVITY_CHECKS=\"`echo \\\"$TOPLEVEL_DIR\\\" | tr '[:upper:]' '[:lower:]'`\"\n-else\n-  TOPDIR_FOR_RELATIVITY_CHECKS=\"$TOPLEVEL_DIR\"\n-fi\n@@ -198,2 +227,2 @@\n-  if [ \"$VERBOSE\" = \"true\" ] ; then\n-    echo \"generating project module: $module\"\n+  if [ \"$VERBOSE\" = true ] ; then\n+    echo \"    $module\"\n@@ -201,1 +230,1 @@\n-  add_replacement \"###MODULE_DIR###\" \"src\/$module\"\n+  add_replacement \"###MODULE_CONTENT###\" \"src\/$module\"\n@@ -205,4 +234,0 @@\n-    if [ \"x$PATHTOOL\" != \"x\" ]; then\n-      dir=\"`echo \\\"$dir\\\" | tr '[:upper:]' '[:lower:]'`\"\n-    fi\n-    dir=\"`realpath --relative-to=\\\"$TOPDIR_FOR_RELATIVITY_CHECKS\\\" \\\"$dir\\\"`\"\n@@ -210,2 +235,1 @@\n-      \"$SPEC_DIR\"*) ;;\n-      *) SOURCE_DIRS=\"$SOURCE_DIRS<sourceFolder url=\\\"file:\/\/\\$MODULE_DIR\\$\/$dir\\\" isTestSource=\\\"false\\\" \/> \"\n+      \"src\/\"*) SOURCE_DIRS=\"$SOURCE_DIRS<sourceFolder url=\\\"file:\/\/$MODULE_DIR\/$dir\\\" isTestSource=\\\"false\\\" \/> \"\n@@ -217,1 +241,3 @@\n-    DEPENDENCIES=\"$DEPENDENCIES<orderEntry type=\\\"module\\\" module-name=\\\"$dep\\\" \/> \"\n+    case $MODULE_NAMES in # Exclude skipped modules from dependencies\n+      *\"$dep\"*) DEPENDENCIES=\"$DEPENDENCIES<orderEntry type=\\\"module\\\" module-name=\\\"$dep\\\" \/> \"\n+    esac\n","filename":"bin\/idea.sh","additions":73,"deletions":47,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -52,1 +52,2 @@\n-    FILES := $(TOPDIR)\/src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java, \\\n+    FILES := $(TOPDIR)\/src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java \\\n+        $(TOPDIR)\/src\/java.base\/share\/classes\/jdk\/internal\/javac\/NoPreview.java, \\\n","filename":"make\/CompileInterimLangtools.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -335,0 +335,6 @@\n+  # Add summary pages for new\/deprecated APIs in recent releases\n+  $1_OPTIONS += --since $(call CommaList, \\\n+      $(filter-out $(VERSION_DOCS_API_SINCE), \\\n+          $(call sequence, $(VERSION_DOCS_API_SINCE), $(VERSION_FEATURE))))\n+  $1_OPTIONS += --since-label \"New API since JDK $(VERSION_DOCS_API_SINCE)\"\n+\n","filename":"make\/Docs.gmk","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -95,2 +95,0 @@\n-# interim-langtools is needed by hotspot only when $(INCLUDE_GRAAL) is true\n-GRAAL_INTERIM_LANGTOOLS_true = interim-langtools\n@@ -99,1 +97,0 @@\n-    DEPS := $(GRAAL_INTERIM_LANGTOOLS_$(INCLUDE_GRAAL)), \\\n","filename":"make\/Main.gmk","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -770,1 +770,1 @@\n-  $1_JTREG_BASIC_OPTIONS += -automatic -ignore:quiet -Djavatest.security.noSecurityManager=true\n+  $1_JTREG_BASIC_OPTIONS += -automatic -ignore:quiet\n","filename":"make\/RunTests.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -536,0 +536,1 @@\n+  VERSION_DOCS_API_SINCE=\"$DEFAULT_VERSION_DOCS_API_SINCE\"\n@@ -560,0 +561,1 @@\n+  AC_SUBST(VERSION_DOCS_API_SINCE)\n","filename":"make\/autoconf\/jdk-version.m4","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -233,0 +233,3 @@\n+# Version for API docs \"new-since\" feature\n+VERSION_DOCS_API_SINCE := @VERSION_DOCS_API_SINCE@\n+\n","filename":"make\/autoconf\/spec.gmk.in","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+# On Windows paths are treated as case-insensitive\n@@ -99,6 +100,12 @@\n-    $(patsubst x%,%,$(subst $(SPACE),\/,$(strip \\\n-        $(call FindCommonPathPrefixHelper, \\\n-            $(subst \/,$(SPACE),x$(strip $1)), $(subst \/,$(SPACE),x$(strip $2))) \\\n-    )))\n-\n-FindCommonPathPrefixHelper = \\\n+    $(call DecodeSpace,$(patsubst x%,%,$(subst $(SPACE),\/,$(strip \\\n+        $(call FindCommonPathPrefixHelper1, \\\n+            $(subst \/,$(SPACE),x$(call EncodeSpace,$(strip $1))), \\\n+            $(subst \/,$(SPACE),x$(call EncodeSpace,$(strip $2)))) \\\n+    ))))\n+\n+FindCommonPathPrefixHelper1 = \\\n+    $(if $(filter $(OPENJDK_TARGET_OS), windows), \\\n+        $(call FindCommonPathPrefixHelper2,$(call uppercase,$1),$(call uppercase,$2),$1), \\\n+        $(call FindCommonPathPrefixHelper2,$1,$2,$1))\n+\n+FindCommonPathPrefixHelper2 = \\\n@@ -106,3 +113,7 @@\n-      $(firstword $1) \\\n-      $(call FindCommonPathPrefixHelper, \\\n-          $(wordlist 2, $(words $1), $1), $(wordlist 2, $(words $2), $2) \\\n+      $(if $(call equals, $(firstword $1),),, \\\n+        $(firstword $3) \\\n+        $(call FindCommonPathPrefixHelper2, \\\n+            $(wordlist 2, $(words $1), $1), \\\n+            $(wordlist 2, $(words $2), $2), \\\n+            $(wordlist 2, $(words $3), $3) \\\n+        ) \\\n@@ -112,8 +123,0 @@\n-# Convert a partial path into as many directory levels of ..\/, removing\n-# leading and following \/.\n-# Ex: foo\/bar\/baz\/ -> ..\/..\/..\n-#     foo\/bar -> ..\/..\n-#     \/foo -> ..\n-DirToDotDot = \\\n-    $(subst $(SPACE),\/,$(foreach d, $(subst \/,$(SPACE),$1),..))\n-\n@@ -124,5 +127,20 @@\n-    $(eval $1_prefix := $(call FindCommonPathPrefix, $1, $2)) \\\n-    $(eval $1_dotdots := $(call DirToDotDot, $(patsubst $($(strip $1)_prefix)%, %, $2))) \\\n-    $(eval $1_dotdots := $(if $($(strip $1)_dotdots),$($(strip $1)_dotdots),.)) \\\n-    $(eval $1_suffix := $(patsubst $($(strip $1)_prefix)\/%, %, $1)) \\\n-    $($(strip $1)_dotdots)\/$($(strip $1)_suffix)\n+    $(call DecodeSpace,$(strip $(call RelativePathHelper,$(call EncodeSpace \\\n+        ,$(strip $1)),$(call EncodeSpace \\\n+        ,$(strip $2)),$(call EncodeSpace \\\n+        ,$(call FindCommonPathPrefix,$1,$2)))))\n+\n+RelativePathHelper = \\\n+    $(eval $3_prefix_length := $(words $(subst \/,$(SPACE),$3))) \\\n+    $(eval $1_words := $(subst \/,$(SPACE),$1)) \\\n+    $(eval $2_words := $(subst \/,$(SPACE),$2)) \\\n+    $(if $(call equals,$($3_prefix_length),0),, \\\n+        $(eval $1_words := $(wordlist 2,$(words $($1_words)),$(wordlist \\\n+            $($3_prefix_length),$(words $($1_words)),$($1_words)))) \\\n+        $(eval $2_words := $(wordlist 2,$(words $($2_words)),$(wordlist \\\n+            $($3_prefix_length),$(words $($2_words)),$($2_words)))) \\\n+    ) \\\n+    $(eval $1_suffix := $(subst $(SPACE),\/,$($1_words))) \\\n+    $(eval $2_dotdots := $(subst $(SPACE),\/,$(foreach d,$($2_words),..))) \\\n+    $(if $($1_suffix), \\\n+        $(if $($2_dotdots), $($2_dotdots)\/$($1_suffix), $($1_suffix)), \\\n+        $(if $($2_dotdots), $($2_dotdots), .))\n","filename":"make\/common\/Utils.gmk","additions":40,"deletions":22,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-DEFAULT_VERSION_FEATURE=17\n+DEFAULT_VERSION_FEATURE=18\n@@ -36,2 +36,2 @@\n-DEFAULT_VERSION_DATE=2021-09-14\n-DEFAULT_VERSION_CLASSFILE_MAJOR=61  # \"`$EXPR $DEFAULT_VERSION_FEATURE + 44`\"\n+DEFAULT_VERSION_DATE=2022-03-15\n+DEFAULT_VERSION_CLASSFILE_MAJOR=62  # \"`$EXPR $DEFAULT_VERSION_FEATURE + 44`\"\n@@ -39,2 +39,3 @@\n-DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"16 17\"\n-DEFAULT_JDK_SOURCE_TARGET_VERSION=17\n+DEFAULT_VERSION_DOCS_API_SINCE=11\n+DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"16 17 18\"\n+DEFAULT_JDK_SOURCE_TARGET_VERSION=18\n","filename":"make\/conf\/version-numbers.conf","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,891 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name java.base\n+header exports java\/io,java\/lang,java\/lang\/annotation,java\/lang\/constant,java\/lang\/invoke,java\/lang\/module,java\/lang\/ref,java\/lang\/reflect,java\/lang\/runtime,java\/math,java\/net,java\/net\/spi,java\/nio,java\/nio\/channels,java\/nio\/channels\/spi,java\/nio\/charset,java\/nio\/charset\/spi,java\/nio\/file,java\/nio\/file\/attribute,java\/nio\/file\/spi,java\/security,java\/security\/cert,java\/security\/interfaces,java\/security\/spec,java\/text,java\/text\/spi,java\/time,java\/time\/chrono,java\/time\/format,java\/time\/temporal,java\/time\/zone,java\/util,java\/util\/concurrent,java\/util\/concurrent\/atomic,java\/util\/concurrent\/locks,java\/util\/function,java\/util\/jar,java\/util\/random,java\/util\/regex,java\/util\/spi,java\/util\/stream,java\/util\/zip,javax\/crypto,javax\/crypto\/interfaces,javax\/crypto\/spec,javax\/net,javax\/net\/ssl,javax\/security\/auth,javax\/security\/auth\/callback,javax\/security\/auth\/login,javax\/security\/auth\/spi,javax\/security\/auth\/x500,javax\/security\/cert uses java\/lang\/System$LoggerFinder,java\/net\/ContentHandlerFactory,java\/net\/spi\/URLStreamHandlerProvider,java\/nio\/channels\/spi\/AsynchronousChannelProvider,java\/nio\/channels\/spi\/SelectorProvider,java\/nio\/charset\/spi\/CharsetProvider,java\/nio\/file\/spi\/FileSystemProvider,java\/nio\/file\/spi\/FileTypeDetector,java\/security\/Provider,java\/text\/spi\/BreakIteratorProvider,java\/text\/spi\/CollatorProvider,java\/text\/spi\/DateFormatProvider,java\/text\/spi\/DateFormatSymbolsProvider,java\/text\/spi\/DecimalFormatSymbolsProvider,java\/text\/spi\/NumberFormatProvider,java\/time\/chrono\/AbstractChronology,java\/time\/chrono\/Chronology,java\/time\/zone\/ZoneRulesProvider,java\/util\/random\/RandomGenerator,java\/util\/spi\/CalendarDataProvider,java\/util\/spi\/CalendarNameProvider,java\/util\/spi\/CurrencyNameProvider,java\/util\/spi\/LocaleNameProvider,java\/util\/spi\/ResourceBundleControlProvider,java\/util\/spi\/ResourceBundleProvider,java\/util\/spi\/TimeZoneNameProvider,java\/util\/spi\/ToolProvider,javax\/security\/auth\/spi\/LoginModule,jdk\/internal\/logger\/DefaultLoggerFinder,sun\/text\/spi\/JavaTimeDateTimePatternProvider,sun\/util\/locale\/provider\/LocaleDataMetaInfo,sun\/util\/resources\/LocaleData$CommonResourceBundleProvider,sun\/util\/resources\/LocaleData$SupplementaryResourceBundleProvider,sun\/util\/spi\/CalendarProvider provides interface\\u0020;java\/nio\/file\/spi\/FileSystemProvider\\u0020;impls\\u0020;jdk\/internal\/jrtfs\/JrtFileSystemProvider,interface\\u0020;java\/util\/random\/RandomGenerator\\u0020;impls\\u0020;java\/security\/SecureRandom\\u005C;u002C;java\/util\/Random\\u005C;u002C;java\/util\/SplittableRandom target linux-amd64 flags 8000\n+\n+class name java\/io\/CharArrayReader\n+method name read descriptor (Ljava\/nio\/CharBuffer;)I thrownTypes java\/io\/IOException flags 1\n+\n+class name java\/io\/Console\n+method name charset descriptor ()Ljava\/nio\/charset\/Charset; flags 1\n+\n+class name java\/io\/FileInputStream\n+method name readAllBytes descriptor ()[B thrownTypes java\/io\/IOException flags 1\n+method name readNBytes descriptor (I)[B thrownTypes java\/io\/IOException flags 1\n+\n+class name java\/io\/InputStreamReader\n+method name read descriptor (Ljava\/nio\/CharBuffer;)I thrownTypes java\/io\/IOException flags 1\n+\n+class name java\/io\/PrintStream\n+header extends java\/io\/FilterOutputStream implements java\/lang\/Appendable,java\/io\/Closeable flags 21\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/io\/WriteAbortedException\n+-field name detail descriptor Ljava\/lang\/Exception;\n+field name detail descriptor Ljava\/lang\/Exception; flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+\n+class name java\/lang\/AbstractStringBuilder\n+header extends java\/lang\/Object implements java\/lang\/Appendable,java\/lang\/CharSequence flags 420\n+innerclass innerClass java\/util\/Spliterator$OfInt outerClass java\/util\/Spliterator innerClassName OfInt flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/Class\n+-method name isSealed descriptor ()Z\n+-method name getPermittedSubclasses descriptor ()[Ljava\/lang\/Class;\n+method name getPermittedSubclasses descriptor ()[Ljava\/lang\/Class; flags 1 signature ()[Ljava\/lang\/Class<*>; runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name isSealed descriptor ()Z flags 1\n+\n+class name java\/lang\/Compiler\n+header extends java\/lang\/Object flags 31 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/lang\/Deprecated\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;eLjava\/lang\/annotation\/ElementType;FIELD;eLjava\/lang\/annotation\/ElementType;LOCAL_VARIABLE;eLjava\/lang\/annotation\/ElementType;METHOD;eLjava\/lang\/annotation\/ElementType;PACKAGE;eLjava\/lang\/annotation\/ElementType;MODULE;eLjava\/lang\/annotation\/ElementType;PARAMETER;eLjava\/lang\/annotation\/ElementType;TYPE;})\n+\n+class name java\/lang\/IllegalCallerException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/LayerInstantiationException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/NamedPackage\n+header extends java\/lang\/Object flags 20\n+\n+class name java\/lang\/SecurityManager\n+header extends java\/lang\/Object flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Opens outerClass java\/lang\/module\/ModuleDescriptor innerClassName Opens flags 19\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Exports outerClass java\/lang\/module\/ModuleDescriptor innerClassName Exports flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name checkMulticast descriptor (Ljava\/net\/InetAddress;B)V\n+method name checkMulticast descriptor (Ljava\/net\/InetAddress;B)V flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"1.4\")\n+\n+class name java\/lang\/StrictMath\n+-method name toRadians descriptor (D)D\n+-method name toDegrees descriptor (D)D\n+method name toRadians descriptor (D)D flags 9\n+method name toDegrees descriptor (D)D flags 9\n+\n+class name java\/lang\/SuppressWarnings\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;TYPE;eLjava\/lang\/annotation\/ElementType;FIELD;eLjava\/lang\/annotation\/ElementType;METHOD;eLjava\/lang\/annotation\/ElementType;PARAMETER;eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;eLjava\/lang\/annotation\/ElementType;LOCAL_VARIABLE;eLjava\/lang\/annotation\/ElementType;MODULE;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;SOURCE;)\n+\n+class name java\/lang\/System\n+-method name setSecurityManager descriptor (Ljava\/lang\/SecurityManager;)V\n+-method name getSecurityManager descriptor ()Ljava\/lang\/SecurityManager;\n+method name setSecurityManager descriptor (Ljava\/lang\/SecurityManager;)V flags 9 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+method name getSecurityManager descriptor ()Ljava\/lang\/SecurityManager; flags 9 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/lang\/Thread\n+-method name checkAccess descriptor ()V\n+method name checkAccess descriptor ()V flags 11 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/lang\/ThreadGroup\n+-method name checkAccess descriptor ()V\n+method name checkAccess descriptor ()V flags 11 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/lang\/constant\/ClassDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc,java\/lang\/invoke\/TypeDescriptor$OfField sealed true flags 601 signature Ljava\/lang\/Object;Ljava\/lang\/constant\/ConstantDesc;Ljava\/lang\/invoke\/TypeDescriptor$OfField<Ljava\/lang\/constant\/ClassDesc;>;\n+innerclass innerClass java\/lang\/invoke\/TypeDescriptor$OfField outerClass java\/lang\/invoke\/TypeDescriptor innerClassName OfField flags 609\n+\n+class name java\/lang\/constant\/ConstantDesc\n+header extends java\/lang\/Object sealed true flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/constant\/DirectMethodHandleDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/MethodHandleDesc nestMembers java\/lang\/constant\/DirectMethodHandleDesc$Kind sealed true flags 601\n+innerclass innerClass java\/lang\/constant\/DirectMethodHandleDesc$Kind outerClass java\/lang\/constant\/DirectMethodHandleDesc innerClassName Kind flags 4019\n+\n+class name java\/lang\/constant\/DynamicConstantDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc flags 421 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/lang\/constant\/ConstantDesc;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+innerclass innerClass java\/lang\/Enum$EnumDesc outerClass java\/lang\/Enum innerClassName EnumDesc flags 19\n+innerclass innerClass java\/lang\/invoke\/VarHandle$VarHandleDesc outerClass java\/lang\/invoke\/VarHandle innerClassName VarHandleDesc flags 19\n+\n+class name java\/lang\/constant\/MethodHandleDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc sealed true flags 601\n+innerclass innerClass java\/lang\/constant\/DirectMethodHandleDesc$Kind outerClass java\/lang\/constant\/DirectMethodHandleDesc innerClassName Kind flags 4019\n+\n+class name java\/lang\/constant\/MethodTypeDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc,java\/lang\/invoke\/TypeDescriptor$OfMethod sealed true flags 601 signature Ljava\/lang\/Object;Ljava\/lang\/constant\/ConstantDesc;Ljava\/lang\/invoke\/TypeDescriptor$OfMethod<Ljava\/lang\/constant\/ClassDesc;Ljava\/lang\/constant\/MethodTypeDesc;>;\n+innerclass innerClass java\/lang\/invoke\/TypeDescriptor$OfMethod outerClass java\/lang\/invoke\/TypeDescriptor innerClassName OfMethod flags 609\n+innerclass innerClass java\/lang\/invoke\/TypeDescriptor$OfField outerClass java\/lang\/invoke\/TypeDescriptor innerClassName OfField flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/invoke\/CallSite\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/invoke\/LambdaMetafactory\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/invoke\/MethodHandles\n+method name tableSwitch descriptor (Ljava\/lang\/invoke\/MethodHandle;[Ljava\/lang\/invoke\/MethodHandle;)Ljava\/lang\/invoke\/MethodHandle; flags 89\n+\n+class name java\/lang\/invoke\/StringConcatException\n+header extends java\/lang\/Exception flags 21\n+\n+class name java\/lang\/module\/Configuration\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/module\/FindException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/module\/InvalidModuleDescriptorException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/module\/ModuleReader\n+header extends java\/lang\/Object implements java\/io\/Closeable flags 601\n+\n+class name java\/lang\/module\/ModuleReference\n+header extends java\/lang\/Object flags 421\n+\n+class name java\/lang\/module\/ResolutionException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/module\/ResolvedModule\n+header extends java\/lang\/Object flags 31\n+\n+class name java\/lang\/reflect\/AccessibleObject\n+header extends java\/lang\/Object implements java\/lang\/reflect\/AnnotatedElement flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I1)\n+-method name <init> descriptor ()V\n+method name <init> descriptor ()V flags 4 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+\n+class name java\/lang\/reflect\/AnnotatedElement\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/reflect\/Executable\n+header extends java\/lang\/reflect\/AccessibleObject implements java\/lang\/reflect\/Member,java\/lang\/reflect\/GenericDeclaration sealed true flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/reflect\/InaccessibleObjectException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/net\/DatagramSocket\n+-method name setDatagramSocketImplFactory descriptor (Ljava\/net\/DatagramSocketImplFactory;)V\n+method name setDatagramSocketImplFactory descriptor (Ljava\/net\/DatagramSocketImplFactory;)V thrownTypes java\/io\/IOException flags 29 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+method name joinGroup descriptor (Ljava\/net\/SocketAddress;Ljava\/net\/NetworkInterface;)V thrownTypes java\/io\/IOException flags 1\n+method name leaveGroup descriptor (Ljava\/net\/SocketAddress;Ljava\/net\/NetworkInterface;)V thrownTypes java\/io\/IOException flags 1\n+\n+class name java\/net\/ServerSocket\n+-method name setSocketFactory descriptor (Ljava\/net\/SocketImplFactory;)V\n+method name setSocketFactory descriptor (Ljava\/net\/SocketImplFactory;)V thrownTypes java\/io\/IOException flags 29 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+\n+class name java\/net\/Socket\n+-method name setSocketImplFactory descriptor (Ljava\/net\/SocketImplFactory;)V\n+method name setSocketImplFactory descriptor (Ljava\/net\/SocketImplFactory;)V thrownTypes java\/io\/IOException flags 29 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+\n+class name java\/net\/URLDecoder\n+-method name <init> descriptor ()V\n+\n+class name java\/net\/URLStreamHandler\n+-method name getHostAddress descriptor (Ljava\/net\/URL;)Ljava\/net\/InetAddress;\n+method name getHostAddress descriptor (Ljava\/net\/URL;)Ljava\/net\/InetAddress; flags 4\n+\n+class name java\/net\/spi\/URLStreamHandlerProvider\n+header extends java\/lang\/Object implements java\/net\/URLStreamHandlerFactory flags 421\n+\n+class name java\/nio\/CharBuffer\n+header extends java\/nio\/Buffer implements java\/lang\/Comparable,java\/lang\/Appendable,java\/lang\/CharSequence,java\/lang\/Readable flags 421 signature Ljava\/nio\/Buffer;Ljava\/lang\/Comparable<Ljava\/nio\/CharBuffer;>;Ljava\/lang\/Appendable;Ljava\/lang\/CharSequence;Ljava\/lang\/Readable;\n+innerclass innerClass java\/util\/Spliterator$OfInt outerClass java\/util\/Spliterator innerClassName OfInt flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/nio\/MappedByteBuffer\n+method name slice descriptor ()Ljava\/nio\/MappedByteBuffer; flags 401\n+method name slice descriptor (II)Ljava\/nio\/MappedByteBuffer; flags 401\n+method name duplicate descriptor ()Ljava\/nio\/MappedByteBuffer; flags 401\n+method name compact descriptor ()Ljava\/nio\/MappedByteBuffer; flags 401\n+method name compact descriptor ()Ljava\/nio\/ByteBuffer; flags 1041\n+method name duplicate descriptor ()Ljava\/nio\/ByteBuffer; flags 1041\n+method name slice descriptor (II)Ljava\/nio\/ByteBuffer; flags 1041\n+method name slice descriptor ()Ljava\/nio\/ByteBuffer; flags 1041\n+method name duplicate descriptor ()Ljava\/nio\/Buffer; flags 1041\n+method name slice descriptor (II)Ljava\/nio\/Buffer; flags 1041\n+method name slice descriptor ()Ljava\/nio\/Buffer; flags 1041\n+\n+class name java\/security\/AccessControlContext\n+header extends java\/lang\/Object flags 31 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/security\/AccessControlException\n+header extends java\/lang\/SecurityException flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/security\/AccessController\n+header extends java\/lang\/Object flags 31 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/security\/Certificate\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"1.2\")\n+\n+class name java\/security\/DomainCombiner\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/security\/Identity\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 421 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"1.2\")\n+\n+class name java\/security\/Policy\n+header extends java\/lang\/Object nestMembers java\/security\/Policy$Parameters flags 421 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+innerclass innerClass java\/security\/Policy$Parameters outerClass java\/security\/Policy innerClassName Parameters flags 609\n+\n+class name java\/security\/Policy$Parameters\n+header extends java\/lang\/Object nestHost java\/security\/Policy flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+innerclass innerClass java\/security\/Policy$Parameters outerClass java\/security\/Policy innerClassName Parameters flags 609\n+\n+class name java\/security\/PolicySpi\n+header extends java\/lang\/Object flags 421 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/security\/SecureRandom\n+header extends java\/util\/Random flags 21 runtimeAnnotations @Ljdk\/internal\/util\/random\/RandomSupport$RandomGeneratorProperties;(name=\"SecureRandom\",isStochastic=Ztrue)\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name java\/security\/SecureRandomParameters\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/security\/SignedObject\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name java\/security\/cert\/CertificateRevokedException\n+header extends java\/security\/cert\/CertificateException flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/security\/cert\/URICertStoreParameters\n+header extends java\/lang\/Object implements java\/security\/cert\/CertStoreParameters flags 31\n+\n+class name java\/security\/interfaces\/RSAKey\n+-method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/security\/spec\/MGF1ParameterSpec\n+-field name SHA512_224 descriptor Ljava\/security\/spec\/MGF1ParameterSpec;\n+-field name SHA512_256 descriptor Ljava\/security\/spec\/MGF1ParameterSpec;\n+field name SHA512_224 descriptor Ljava\/security\/spec\/MGF1ParameterSpec; flags 19\n+field name SHA512_256 descriptor Ljava\/security\/spec\/MGF1ParameterSpec; flags 19\n+\n+class name java\/security\/spec\/PSSParameterSpec\n+-field name TRAILER_FIELD_BC descriptor I\n+field name TRAILER_FIELD_BC descriptor I constantValue 1 flags 19\n+-method name toString descriptor ()Ljava\/lang\/String;\n+method name toString descriptor ()Ljava\/lang\/String; flags 1\n+\n+class name java\/security\/spec\/RSAKeyGenParameterSpec\n+-method name <init> descriptor (ILjava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+-method name getKeyParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name <init> descriptor (ILjava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+method name getKeyParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/security\/spec\/RSAMultiPrimePrivateCrtKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;[Ljava\/security\/spec\/RSAOtherPrimeInfo;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;[Ljava\/security\/spec\/RSAOtherPrimeInfo;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+\n+class name java\/security\/spec\/RSAPrivateCrtKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+\n+class name java\/security\/spec\/RSAPrivateKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+-method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/security\/spec\/RSAPublicKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+-method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/text\/DateFormatSymbols\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/text\/RuleBasedCollator\n+header extends java\/text\/Collator flags 21\n+innerclass innerClass java\/text\/Normalizer$Form outerClass java\/text\/Normalizer innerClassName Form flags 4019\n+\n+class name java\/time\/chrono\/ChronoLocalDate\n+header extends java\/lang\/Object implements java\/time\/temporal\/Temporal,java\/time\/temporal\/TemporalAdjuster,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Ljava\/time\/temporal\/Temporal;Ljava\/time\/temporal\/TemporalAdjuster;Ljava\/lang\/Comparable<Ljava\/time\/chrono\/ChronoLocalDate;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/time\/chrono\/ChronoLocalDateTime\n+header extends java\/lang\/Object implements java\/time\/temporal\/Temporal,java\/time\/temporal\/TemporalAdjuster,java\/lang\/Comparable flags 601 signature <D::Ljava\/time\/chrono\/ChronoLocalDate;>Ljava\/lang\/Object;Ljava\/time\/temporal\/Temporal;Ljava\/time\/temporal\/TemporalAdjuster;Ljava\/lang\/Comparable<Ljava\/time\/chrono\/ChronoLocalDateTime<*>;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/time\/format\/DecimalStyle\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/time\/temporal\/TemporalAdjusters\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/Comparator\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/DoubleSummaryStatistics\n+header extends java\/lang\/Object implements java\/util\/function\/DoubleConsumer flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/GregorianCalendar\n+header extends java\/util\/Calendar flags 21\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/util\/HashSet\n+header extends java\/util\/AbstractSet implements java\/util\/Set,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/util\/AbstractSet<TE;>;Ljava\/util\/Set<TE;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/util\/HexFormat\n+header extends java\/lang\/Object flags 31\n+method name of descriptor ()Ljava\/util\/HexFormat; flags 9\n+method name ofDelimiter descriptor (Ljava\/lang\/String;)Ljava\/util\/HexFormat; flags 9\n+method name withDelimiter descriptor (Ljava\/lang\/String;)Ljava\/util\/HexFormat; flags 1\n+method name withPrefix descriptor (Ljava\/lang\/String;)Ljava\/util\/HexFormat; flags 1\n+method name withSuffix descriptor (Ljava\/lang\/String;)Ljava\/util\/HexFormat; flags 1\n+method name withUpperCase descriptor ()Ljava\/util\/HexFormat; flags 1\n+method name withLowerCase descriptor ()Ljava\/util\/HexFormat; flags 1\n+method name delimiter descriptor ()Ljava\/lang\/String; flags 1\n+method name prefix descriptor ()Ljava\/lang\/String; flags 1\n+method name suffix descriptor ()Ljava\/lang\/String; flags 1\n+method name isUpperCase descriptor ()Z flags 1\n+method name formatHex descriptor ([B)Ljava\/lang\/String; flags 1\n+method name formatHex descriptor ([BII)Ljava\/lang\/String; flags 1\n+method name formatHex descriptor (Ljava\/lang\/Appendable;[B)Ljava\/lang\/Appendable; flags 1 signature <A::Ljava\/lang\/Appendable;>(TA;[B)TA;\n+method name formatHex descriptor (Ljava\/lang\/Appendable;[BII)Ljava\/lang\/Appendable; flags 1 signature <A::Ljava\/lang\/Appendable;>(TA;[BII)TA;\n+method name parseHex descriptor (Ljava\/lang\/CharSequence;)[B flags 1\n+method name parseHex descriptor (Ljava\/lang\/CharSequence;II)[B flags 1\n+method name parseHex descriptor ([CII)[B flags 1\n+method name toLowHexDigit descriptor (I)C flags 1\n+method name toHighHexDigit descriptor (I)C flags 1\n+method name toHexDigits descriptor (Ljava\/lang\/Appendable;B)Ljava\/lang\/Appendable; flags 1 signature <A::Ljava\/lang\/Appendable;>(TA;B)TA;\n+method name toHexDigits descriptor (B)Ljava\/lang\/String; flags 1\n+method name toHexDigits descriptor (C)Ljava\/lang\/String; flags 1\n+method name toHexDigits descriptor (S)Ljava\/lang\/String; flags 1\n+method name toHexDigits descriptor (I)Ljava\/lang\/String; flags 1\n+method name toHexDigits descriptor (J)Ljava\/lang\/String; flags 1\n+method name toHexDigits descriptor (JI)Ljava\/lang\/String; flags 1\n+method name isHexDigit descriptor (I)Z flags 9\n+method name fromHexDigit descriptor (I)I flags 9\n+method name fromHexDigits descriptor (Ljava\/lang\/CharSequence;)I flags 9\n+method name fromHexDigits descriptor (Ljava\/lang\/CharSequence;II)I flags 9\n+method name fromHexDigitsToLong descriptor (Ljava\/lang\/CharSequence;)J flags 9\n+method name fromHexDigitsToLong descriptor (Ljava\/lang\/CharSequence;II)J flags 9\n+method name equals descriptor (Ljava\/lang\/Object;)Z flags 1\n+method name hashCode descriptor ()I flags 1\n+method name toString descriptor ()Ljava\/lang\/String; flags 1\n+\n+class name java\/util\/Locale$IsoCountryCode\n+header extends java\/lang\/Enum nestHost java\/util\/Locale sealed true flags 4421 signature Ljava\/lang\/Enum<Ljava\/util\/Locale$IsoCountryCode;>;\n+innerclass innerClass java\/util\/Locale$IsoCountryCode outerClass java\/util\/Locale innerClassName IsoCountryCode flags 4409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/Observable\n+header extends java\/lang\/Object flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+\n+class name java\/util\/Observer\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+\n+class name java\/util\/Random\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator,java\/io\/Serializable flags 21 runtimeAnnotations @Ljdk\/internal\/util\/random\/RandomSupport$RandomGeneratorProperties;(name=\"Random\",i=I48,j=I0,k=I0,equidistribution=I0)\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name java\/util\/SplittableRandom\n+header extends jdk\/internal\/util\/random\/RandomSupport$AbstractSplittableGenerator flags 31 runtimeAnnotations @Ljdk\/internal\/util\/random\/RandomSupport$RandomGeneratorProperties;(name=\"SplittableRandom\",i=I64,j=I0,k=I0,equidistribution=I1)\n+innerclass innerClass jdk\/internal\/util\/random\/RandomSupport$AbstractSplittableGenerator outerClass jdk\/internal\/util\/random\/RandomSupport innerClassName AbstractSplittableGenerator flags 409\n+innerclass innerClass java\/util\/random\/RandomGenerator$SplittableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName SplittableGenerator flags 609\n+-method name nextInt descriptor (I)I\n+-method name nextInt descriptor (II)I\n+-method name nextLong descriptor (J)J\n+-method name nextLong descriptor (JJ)J\n+-method name nextDouble descriptor ()D\n+-method name nextDouble descriptor (D)D\n+-method name nextDouble descriptor (DD)D\n+-method name nextBoolean descriptor ()Z\n+method name split descriptor (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/SplittableRandom; flags 1\n+method name splits descriptor ()Ljava\/util\/stream\/Stream; flags 1 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name splits descriptor (J)Ljava\/util\/stream\/Stream; flags 1 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name splits descriptor (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream; flags 1 signature (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name splits descriptor (JLjava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream; flags 1 signature (JLjava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name split descriptor ()Ljava\/util\/random\/RandomGenerator$SplittableGenerator; flags 1041\n+method name split descriptor (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/random\/RandomGenerator$SplittableGenerator; flags 1041\n+\n+class name java\/util\/TimeZone\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/util\/Timer\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/ref\/Cleaner$Cleanable outerClass java\/lang\/ref\/Cleaner innerClassName Cleanable flags 609\n+\n+class name java\/util\/TreeSet\n+header extends java\/util\/AbstractSet implements java\/util\/NavigableSet,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/util\/AbstractSet<TE;>;Ljava\/util\/NavigableSet<TE;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/util\/concurrent\/ConcurrentMap\n+header extends java\/lang\/Object implements java\/util\/Map flags 601 signature <K:Ljava\/lang\/Object;V:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/util\/Map<TK;TV;>;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/ConcurrentSkipListSet\n+header extends java\/util\/AbstractSet implements java\/util\/NavigableSet,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/util\/AbstractSet<TE;>;Ljava\/util\/NavigableSet<TE;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/CountedCompleter\n+header extends java\/util\/concurrent\/ForkJoinTask flags 421 signature <T:Ljava\/lang\/Object;>Ljava\/util\/concurrent\/ForkJoinTask<TT;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/Executors\n+-method name privilegedThreadFactory descriptor ()Ljava\/util\/concurrent\/ThreadFactory;\n+-method name privilegedCallable descriptor (Ljava\/util\/concurrent\/Callable;)Ljava\/util\/concurrent\/Callable;\n+-method name privilegedCallableUsingCurrentClassLoader descriptor (Ljava\/util\/concurrent\/Callable;)Ljava\/util\/concurrent\/Callable;\n+method name privilegedThreadFactory descriptor ()Ljava\/util\/concurrent\/ThreadFactory; flags 9 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+method name privilegedCallable descriptor (Ljava\/util\/concurrent\/Callable;)Ljava\/util\/concurrent\/Callable; flags 9 deprecated true signature <T:Ljava\/lang\/Object;>(Ljava\/util\/concurrent\/Callable<TT;>;)Ljava\/util\/concurrent\/Callable<TT;>; runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+method name privilegedCallableUsingCurrentClassLoader descriptor (Ljava\/util\/concurrent\/Callable;)Ljava\/util\/concurrent\/Callable; flags 9 deprecated true signature <T:Ljava\/lang\/Object;>(Ljava\/util\/concurrent\/Callable<TT;>;)Ljava\/util\/concurrent\/Callable<TT;>; runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/util\/concurrent\/ForkJoinPool\n+header extends java\/util\/concurrent\/AbstractExecutorService nestMembers java\/util\/concurrent\/ForkJoinPool$ManagedBlocker,java\/util\/concurrent\/ForkJoinPool$ForkJoinWorkerThreadFactory flags 21\n+innerclass innerClass java\/util\/concurrent\/ForkJoinPool$ForkJoinWorkerThreadFactory outerClass java\/util\/concurrent\/ForkJoinPool innerClassName ForkJoinWorkerThreadFactory flags 609\n+innerclass innerClass java\/util\/concurrent\/ForkJoinPool$ManagedBlocker outerClass java\/util\/concurrent\/ForkJoinPool innerClassName ManagedBlocker flags 609\n+innerclass innerClass java\/lang\/Thread$UncaughtExceptionHandler outerClass java\/lang\/Thread innerClassName UncaughtExceptionHandler flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name invokeAll descriptor (Ljava\/util\/Collection;JLjava\/util\/concurrent\/TimeUnit;)Ljava\/util\/List; thrownTypes java\/lang\/InterruptedException flags 1 signature <T:Ljava\/lang\/Object;>(Ljava\/util\/Collection<+Ljava\/util\/concurrent\/Callable<TT;>;>;JLjava\/util\/concurrent\/TimeUnit;)Ljava\/util\/List<Ljava\/util\/concurrent\/Future<TT;>;>;\n+method name invokeAny descriptor (Ljava\/util\/Collection;)Ljava\/lang\/Object; thrownTypes java\/lang\/InterruptedException,java\/util\/concurrent\/ExecutionException flags 1 signature <T:Ljava\/lang\/Object;>(Ljava\/util\/Collection<+Ljava\/util\/concurrent\/Callable<TT;>;>;)TT;\n+method name invokeAny descriptor (Ljava\/util\/Collection;JLjava\/util\/concurrent\/TimeUnit;)Ljava\/lang\/Object; thrownTypes java\/lang\/InterruptedException,java\/util\/concurrent\/ExecutionException,java\/util\/concurrent\/TimeoutException flags 1 signature <T:Ljava\/lang\/Object;>(Ljava\/util\/Collection<+Ljava\/util\/concurrent\/Callable<TT;>;>;JLjava\/util\/concurrent\/TimeUnit;)TT;\n+\n+class name java\/util\/concurrent\/ForkJoinWorkerThread\n+header extends java\/lang\/Thread flags 21\n+innerclass innerClass java\/lang\/Thread$UncaughtExceptionHandler outerClass java\/lang\/Thread innerClassName UncaughtExceptionHandler flags 609\n+\n+class name java\/util\/concurrent\/LinkedTransferQueue\n+header extends java\/util\/AbstractQueue implements java\/util\/concurrent\/TransferQueue,java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/util\/AbstractQueue<TE;>;Ljava\/util\/concurrent\/TransferQueue<TE;>;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/concurrent\/ForkJoinPool$ManagedBlocker outerClass java\/util\/concurrent\/ForkJoinPool innerClassName ManagedBlocker flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/ThreadLocalRandom\n+header extends java\/util\/Random flags 21 runtimeAnnotations @Ljdk\/internal\/util\/random\/RandomSupport$RandomGeneratorProperties;(name=\"ThreadLocalRandom\",i=I64,j=I0,k=I0,equidistribution=I1)\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+-method name nextGaussian descriptor ()D\n+method name nextFloat descriptor (F)F flags 1\n+method name nextFloat descriptor (FF)F flags 1\n+\n+class name java\/util\/concurrent\/atomic\/AtomicBoolean\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/atomic\/AtomicReference\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 signature <V:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/io\/Serializable;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/atomic\/AtomicReferenceArray\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/io\/Serializable;\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/locks\/StampedLock\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I1)\n+-method name tryWriteLock descriptor ()J\n+-method name writeLockInterruptibly descriptor ()J\n+-method name tryReadLock descriptor ()J\n+-method name tryReadLock descriptor (JLjava\/util\/concurrent\/TimeUnit;)J\n+-method name readLockInterruptibly descriptor ()J\n+-method name unlock descriptor (J)V\n+method name tryWriteLock descriptor ()J flags 1\n+method name writeLockInterruptibly descriptor ()J thrownTypes java\/lang\/InterruptedException flags 1\n+method name tryReadLock descriptor ()J flags 1\n+method name tryReadLock descriptor (JLjava\/util\/concurrent\/TimeUnit;)J thrownTypes java\/lang\/InterruptedException flags 1\n+method name readLockInterruptibly descriptor ()J thrownTypes java\/lang\/InterruptedException flags 1\n+method name unlock descriptor (J)V flags 1\n+\n+class name java\/util\/function\/BiConsumer\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;U:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/BiFunction\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;U:Ljava\/lang\/Object;R:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/BiPredicate\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;U:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/BinaryOperator\n+header extends java\/lang\/Object implements java\/util\/function\/BiFunction flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/util\/function\/BiFunction<TT;TT;TT;>; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/Consumer\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/DoubleConsumer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/DoublePredicate\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/DoubleUnaryOperator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/Function\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;R:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/IntConsumer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/IntPredicate\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/IntUnaryOperator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/LongConsumer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/LongPredicate\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/LongUnaryOperator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/Predicate\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/UnaryOperator\n+header extends java\/lang\/Object implements java\/util\/function\/Function flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/util\/function\/Function<TT;TT;>; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/random\/RandomGenerator\n+header extends java\/lang\/Object nestMembers java\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator,java\/util\/random\/RandomGenerator$LeapableGenerator,java\/util\/random\/RandomGenerator$JumpableGenerator,java\/util\/random\/RandomGenerator$SplittableGenerator,java\/util\/random\/RandomGenerator$StreamableGenerator flags 601\n+innerclass innerClass java\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName ArbitrarilyJumpableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$LeapableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName LeapableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$JumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName JumpableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$SplittableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName SplittableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$StreamableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName StreamableGenerator flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGenerator; flags 9\n+method name getDefault descriptor ()Ljava\/util\/random\/RandomGenerator; flags 9\n+method name isDeprecated descriptor ()Z flags 1\n+method name doubles descriptor ()Ljava\/util\/stream\/DoubleStream; flags 1\n+method name doubles descriptor (DD)Ljava\/util\/stream\/DoubleStream; flags 1\n+method name doubles descriptor (J)Ljava\/util\/stream\/DoubleStream; flags 1\n+method name doubles descriptor (JDD)Ljava\/util\/stream\/DoubleStream; flags 1\n+method name ints descriptor ()Ljava\/util\/stream\/IntStream; flags 1\n+method name ints descriptor (II)Ljava\/util\/stream\/IntStream; flags 1\n+method name ints descriptor (J)Ljava\/util\/stream\/IntStream; flags 1\n+method name ints descriptor (JII)Ljava\/util\/stream\/IntStream; flags 1\n+method name longs descriptor ()Ljava\/util\/stream\/LongStream; flags 1\n+method name longs descriptor (JJ)Ljava\/util\/stream\/LongStream; flags 1\n+method name longs descriptor (J)Ljava\/util\/stream\/LongStream; flags 1\n+method name longs descriptor (JJJ)Ljava\/util\/stream\/LongStream; flags 1\n+method name nextBoolean descriptor ()Z flags 1\n+method name nextBytes descriptor ([B)V flags 1\n+method name nextFloat descriptor ()F flags 1\n+method name nextFloat descriptor (F)F flags 1\n+method name nextFloat descriptor (FF)F flags 1\n+method name nextDouble descriptor ()D flags 1\n+method name nextDouble descriptor (D)D flags 1\n+method name nextDouble descriptor (DD)D flags 1\n+method name nextInt descriptor ()I flags 1\n+method name nextInt descriptor (I)I flags 1\n+method name nextInt descriptor (II)I flags 1\n+method name nextLong descriptor ()J flags 401\n+method name nextLong descriptor (J)J flags 1\n+method name nextLong descriptor (JJ)J flags 1\n+method name nextGaussian descriptor ()D flags 1\n+method name nextGaussian descriptor (DD)D flags 1\n+method name nextExponential descriptor ()D flags 1\n+\n+class name java\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator$LeapableGenerator nestHost java\/util\/random\/RandomGenerator flags 601\n+innerclass innerClass java\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName ArbitrarilyJumpableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$LeapableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName LeapableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$JumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName JumpableGenerator flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator; flags 9\n+method name copy descriptor ()Ljava\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator; flags 401\n+method name jumpPowerOfTwo descriptor (I)V flags 401\n+method name jump descriptor (D)V flags 401\n+method name jump descriptor ()V flags 1\n+method name jumps descriptor (D)Ljava\/util\/stream\/Stream; flags 1 signature (D)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator;>;\n+method name jumps descriptor (JD)Ljava\/util\/stream\/Stream; flags 1 signature (JD)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator;>;\n+method name leap descriptor ()V flags 1\n+method name copyAndJump descriptor (D)Ljava\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator; flags 1\n+method name copy descriptor ()Ljava\/util\/random\/RandomGenerator$LeapableGenerator; flags 1041\n+method name copy descriptor ()Ljava\/util\/random\/RandomGenerator$JumpableGenerator; flags 1041\n+\n+class name java\/util\/random\/RandomGenerator$JumpableGenerator\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator$StreamableGenerator nestHost java\/util\/random\/RandomGenerator flags 601\n+innerclass innerClass java\/util\/random\/RandomGenerator$JumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName JumpableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$StreamableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName StreamableGenerator flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGenerator$JumpableGenerator; flags 9\n+method name copy descriptor ()Ljava\/util\/random\/RandomGenerator$JumpableGenerator; flags 401\n+method name jump descriptor ()V flags 401\n+method name jumpDistance descriptor ()D flags 401\n+method name jumps descriptor ()Ljava\/util\/stream\/Stream; flags 1 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+method name jumps descriptor (J)Ljava\/util\/stream\/Stream; flags 1 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+method name rngs descriptor ()Ljava\/util\/stream\/Stream; flags 1 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+method name rngs descriptor (J)Ljava\/util\/stream\/Stream; flags 1 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+method name copyAndJump descriptor ()Ljava\/util\/random\/RandomGenerator; flags 1\n+\n+class name java\/util\/random\/RandomGenerator$LeapableGenerator\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator$JumpableGenerator nestHost java\/util\/random\/RandomGenerator flags 601\n+innerclass innerClass java\/util\/random\/RandomGenerator$LeapableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName LeapableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$JumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName JumpableGenerator flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGenerator$LeapableGenerator; flags 9\n+method name copy descriptor ()Ljava\/util\/random\/RandomGenerator$LeapableGenerator; flags 401\n+method name leap descriptor ()V flags 401\n+method name leapDistance descriptor ()D flags 401\n+method name leaps descriptor ()Ljava\/util\/stream\/Stream; flags 1 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$JumpableGenerator;>;\n+method name leaps descriptor (J)Ljava\/util\/stream\/Stream; flags 1 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$JumpableGenerator;>;\n+method name copyAndLeap descriptor ()Ljava\/util\/random\/RandomGenerator$JumpableGenerator; flags 1\n+method name copy descriptor ()Ljava\/util\/random\/RandomGenerator$JumpableGenerator; flags 1041\n+\n+class name java\/util\/random\/RandomGenerator$SplittableGenerator\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator$StreamableGenerator nestHost java\/util\/random\/RandomGenerator flags 601\n+innerclass innerClass java\/util\/random\/RandomGenerator$SplittableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName SplittableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$StreamableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName StreamableGenerator flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGenerator$SplittableGenerator; flags 9\n+method name split descriptor ()Ljava\/util\/random\/RandomGenerator$SplittableGenerator; flags 401\n+method name split descriptor (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/random\/RandomGenerator$SplittableGenerator; flags 401\n+method name splits descriptor ()Ljava\/util\/stream\/Stream; flags 1 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name splits descriptor (J)Ljava\/util\/stream\/Stream; flags 401 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name splits descriptor (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream; flags 401 signature (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name splits descriptor (JLjava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream; flags 401 signature (JLjava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name rngs descriptor ()Ljava\/util\/stream\/Stream; flags 1 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+method name rngs descriptor (J)Ljava\/util\/stream\/Stream; flags 1 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+\n+class name java\/util\/random\/RandomGenerator$StreamableGenerator\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator nestHost java\/util\/random\/RandomGenerator flags 601\n+innerclass innerClass java\/util\/random\/RandomGenerator$StreamableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName StreamableGenerator flags 609\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGenerator$StreamableGenerator; flags 9\n+method name rngs descriptor ()Ljava\/util\/stream\/Stream; flags 401 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+method name rngs descriptor (J)Ljava\/util\/stream\/Stream; flags 1 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+\n+class name java\/util\/random\/RandomGeneratorFactory\n+header extends java\/lang\/Object flags 31 signature <T::Ljava\/util\/random\/RandomGenerator;>Ljava\/lang\/Object;\n+innerclass innerClass java\/util\/ServiceLoader$Provider outerClass java\/util\/ServiceLoader innerClassName Provider flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName ArbitrarilyJumpableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$JumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName JumpableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$LeapableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName LeapableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$SplittableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName SplittableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$StreamableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName StreamableGenerator flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGeneratorFactory; flags 9 signature <T::Ljava\/util\/random\/RandomGenerator;>(Ljava\/lang\/String;)Ljava\/util\/random\/RandomGeneratorFactory<TT;>;\n+method name getDefault descriptor ()Ljava\/util\/random\/RandomGeneratorFactory; flags 9 signature ()Ljava\/util\/random\/RandomGeneratorFactory<Ljava\/util\/random\/RandomGenerator;>;\n+method name all descriptor ()Ljava\/util\/stream\/Stream; flags 9 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGeneratorFactory<Ljava\/util\/random\/RandomGenerator;>;>;\n+method name name descriptor ()Ljava\/lang\/String; flags 1\n+method name group descriptor ()Ljava\/lang\/String; flags 1\n+method name stateBits descriptor ()I flags 1\n+method name equidistribution descriptor ()I flags 1\n+method name period descriptor ()Ljava\/math\/BigInteger; flags 1\n+method name isStatistical descriptor ()Z flags 1\n+method name isStochastic descriptor ()Z flags 1\n+method name isHardware descriptor ()Z flags 1\n+method name isArbitrarilyJumpable descriptor ()Z flags 1\n+method name isJumpable descriptor ()Z flags 1\n+method name isLeapable descriptor ()Z flags 1\n+method name isSplittable descriptor ()Z flags 1\n+method name isStreamable descriptor ()Z flags 1\n+method name isDeprecated descriptor ()Z flags 1\n+method name create descriptor ()Ljava\/util\/random\/RandomGenerator; flags 1 signature ()TT;\n+method name create descriptor (J)Ljava\/util\/random\/RandomGenerator; flags 1 signature (J)TT;\n+method name create descriptor ([B)Ljava\/util\/random\/RandomGenerator; flags 1 signature ([B)TT;\n+\n+class name java\/util\/spi\/AbstractResourceBundleProvider\n+header extends java\/lang\/Object implements java\/util\/spi\/ResourceBundleProvider flags 421\n+innerclass innerClass java\/util\/ResourceBundle$Control outerClass java\/util\/ResourceBundle innerClassName Control flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/spi\/CurrencyNameProvider\n+header extends java\/util\/spi\/LocaleServiceProvider flags 421\n+innerclass innerClass java\/util\/ResourceBundle$Control outerClass java\/util\/ResourceBundle innerClassName Control flags 9\n+\n+class name java\/util\/spi\/ResourceBundleProvider\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/util\/spi\/ToolProvider\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/zip\/CRC32C\n+header extends java\/lang\/Object implements java\/util\/zip\/Checksum flags 31\n+\n+class name javax\/crypto\/AEADBadTagException\n+header extends javax\/crypto\/BadPaddingException flags 21\n+\n+class name javax\/crypto\/BadPaddingException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/CipherInputStream\n+header extends java\/io\/FilterInputStream flags 21\n+\n+class name javax\/crypto\/CipherOutputStream\n+header extends java\/io\/FilterOutputStream flags 21\n+\n+class name javax\/crypto\/CipherSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/EncryptedPrivateKeyInfo\n+header extends java\/lang\/Object flags 21\n+\n+class name javax\/crypto\/ExemptionMechanism\n+header extends java\/lang\/Object flags 21\n+\n+class name javax\/crypto\/ExemptionMechanismException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/ExemptionMechanismSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/IllegalBlockSizeException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/KeyAgreement\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/KeyAgreementSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/KeyGenerator\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/KeyGeneratorSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/Mac\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/MacSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/NoSuchPaddingException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/NullCipher\n+header extends javax\/crypto\/Cipher flags 21\n+\n+class name javax\/crypto\/SealedObject\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/crypto\/SecretKey\n+header extends java\/lang\/Object implements java\/security\/Key,javax\/security\/auth\/Destroyable flags 601\n+\n+class name javax\/crypto\/SecretKeyFactory\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/SecretKeyFactorySpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/ShortBufferException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/interfaces\/DHKey\n+header extends java\/lang\/Object flags 601\n+\n+class name javax\/crypto\/interfaces\/DHPrivateKey\n+header extends java\/lang\/Object implements javax\/crypto\/interfaces\/DHKey,java\/security\/PrivateKey flags 601\n+\n+class name javax\/crypto\/interfaces\/DHPublicKey\n+header extends java\/lang\/Object implements javax\/crypto\/interfaces\/DHKey,java\/security\/PublicKey flags 601\n+\n+class name javax\/crypto\/interfaces\/PBEKey\n+header extends java\/lang\/Object implements javax\/crypto\/SecretKey flags 601\n+\n+class name javax\/crypto\/spec\/DESKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/DESedeKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/DHGenParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/DHParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/DHPrivateKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/DHPublicKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/GCMParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/IvParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/OAEPParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+innerclass innerClass javax\/crypto\/spec\/PSource$PSpecified outerClass javax\/crypto\/spec\/PSource innerClassName PSpecified flags 19\n+\n+class name javax\/crypto\/spec\/PBEKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/PBEParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/RC2ParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/RC5ParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/SecretKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec,javax\/crypto\/SecretKey flags 21\n+\n+class name javax\/security\/auth\/Subject\n+-method name getSubject descriptor (Ljava\/security\/AccessControlContext;)Ljavax\/security\/auth\/Subject;\n+-method name doAsPrivileged descriptor (Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedAction;Ljava\/security\/AccessControlContext;)Ljava\/lang\/Object;\n+-method name doAsPrivileged descriptor (Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedExceptionAction;Ljava\/security\/AccessControlContext;)Ljava\/lang\/Object;\n+method name getSubject descriptor (Ljava\/security\/AccessControlContext;)Ljavax\/security\/auth\/Subject; flags 9 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+method name doAsPrivileged descriptor (Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedAction;Ljava\/security\/AccessControlContext;)Ljava\/lang\/Object; flags 9 deprecated true signature <T:Ljava\/lang\/Object;>(Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedAction<TT;>;Ljava\/security\/AccessControlContext;)TT; runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+method name doAsPrivileged descriptor (Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedExceptionAction;Ljava\/security\/AccessControlContext;)Ljava\/lang\/Object; thrownTypes java\/security\/PrivilegedActionException flags 9 deprecated true signature <T:Ljava\/lang\/Object;>(Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedExceptionAction<TT;>;Ljava\/security\/AccessControlContext;)TT; runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name javax\/security\/auth\/SubjectDomainCombiner\n+header extends java\/lang\/Object implements java\/security\/DomainCombiner flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n","filename":"make\/data\/symbols\/java.base-H.sym.txt","additions":891,"deletions":0,"binary":false,"changes":891,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/annotation\/processing\/AbstractProcessor\n+header extends java\/lang\/Object implements javax\/annotation\/processing\/Processor flags 421\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/annotation\/processing\/Generated\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;SOURCE;)@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;PACKAGE;eLjava\/lang\/annotation\/ElementType;TYPE;eLjava\/lang\/annotation\/ElementType;METHOD;eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;eLjava\/lang\/annotation\/ElementType;FIELD;eLjava\/lang\/annotation\/ElementType;LOCAL_VARIABLE;eLjava\/lang\/annotation\/ElementType;PARAMETER;})\n+\n+class name javax\/lang\/model\/SourceVersion\n+field name RELEASE_17 descriptor Ljavax\/lang\/model\/SourceVersion; flags 4019\n+\n+class name javax\/lang\/model\/element\/Modifier\n+header extends java\/lang\/Enum sealed true flags 4021 signature Ljava\/lang\/Enum<Ljavax\/lang\/model\/element\/Modifier;>;\n+-field name SEALED descriptor Ljavax\/lang\/model\/element\/Modifier;\n+-field name NON_SEALED descriptor Ljavax\/lang\/model\/element\/Modifier;\n+field name SEALED descriptor Ljavax\/lang\/model\/element\/Modifier; flags 4019\n+field name NON_SEALED descriptor Ljavax\/lang\/model\/element\/Modifier; flags 4019\n+\n+class name javax\/lang\/model\/element\/TypeElement\n+-method name getPermittedSubclasses descriptor ()Ljava\/util\/List;\n+method name getPermittedSubclasses descriptor ()Ljava\/util\/List; flags 1 signature ()Ljava\/util\/List<+Ljavax\/lang\/model\/type\/TypeMirror;>;\n+\n+class name javax\/lang\/model\/element\/UnknownAnnotationValueException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/element\/UnknownDirectiveException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass javax\/lang\/model\/element\/ModuleElement$Directive outerClass javax\/lang\/model\/element\/ModuleElement innerClassName Directive flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/element\/UnknownElementException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/type\/MirroredTypeException\n+header extends javax\/lang\/model\/type\/MirroredTypesException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/type\/MirroredTypesException\n+header extends java\/lang\/RuntimeException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/type\/UnknownTypeException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/util\/AbstractAnnotationValueVisitor14\n+header extends javax\/lang\/model\/util\/AbstractAnnotationValueVisitor9 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractAnnotationValueVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/AbstractElementVisitor14\n+header extends javax\/lang\/model\/util\/AbstractElementVisitor9 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractElementVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor14\n+header extends javax\/lang\/model\/util\/AbstractTypeVisitor9 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractTypeVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor6\n+header extends java\/lang\/Object implements javax\/lang\/model\/type\/TypeVisitor flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljavax\/lang\/model\/type\/TypeVisitor<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_6;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor7\n+header extends javax\/lang\/model\/util\/AbstractTypeVisitor6 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractTypeVisitor6<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_7;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor8\n+header extends javax\/lang\/model\/util\/AbstractTypeVisitor7 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractTypeVisitor7<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_8;)\n+\n+class name javax\/lang\/model\/util\/ElementKindVisitor14\n+header extends javax\/lang\/model\/util\/ElementKindVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/ElementKindVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/ElementScanner14\n+header extends javax\/lang\/model\/util\/ElementScanner9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/ElementScanner9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/Elements\n+method name isAutomaticModule descriptor (Ljavax\/lang\/model\/element\/ModuleElement;)Z flags 1\n+\n+class name javax\/lang\/model\/util\/SimpleAnnotationValueVisitor14\n+header extends javax\/lang\/model\/util\/SimpleAnnotationValueVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/SimpleAnnotationValueVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/SimpleElementVisitor14\n+header extends javax\/lang\/model\/util\/SimpleElementVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/SimpleElementVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/SimpleTypeVisitor14\n+header extends javax\/lang\/model\/util\/SimpleTypeVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/SimpleTypeVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/TypeKindVisitor14\n+header extends javax\/lang\/model\/util\/TypeKindVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/TypeKindVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/tools\/SimpleJavaFileObject\n+header extends java\/lang\/Object implements javax\/tools\/JavaFileObject flags 21\n+innerclass innerClass javax\/tools\/JavaFileObject$Kind outerClass javax\/tools\/JavaFileObject innerClassName Kind flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/tools\/ToolProvider\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.compiler-H.sym.txt","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/awt\/datatransfer\/Clipboard\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/datatransfer\/DataFlavor\n+header extends java\/lang\/Object implements java\/io\/Externalizable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-field name selectionHtmlFlavor descriptor Ljava\/awt\/datatransfer\/DataFlavor;\n+-field name fragmentHtmlFlavor descriptor Ljava\/awt\/datatransfer\/DataFlavor;\n+-field name allHtmlFlavor descriptor Ljava\/awt\/datatransfer\/DataFlavor;\n+field name selectionHtmlFlavor descriptor Ljava\/awt\/datatransfer\/DataFlavor; flags 19\n+field name fragmentHtmlFlavor descriptor Ljava\/awt\/datatransfer\/DataFlavor; flags 19\n+field name allHtmlFlavor descriptor Ljava\/awt\/datatransfer\/DataFlavor; flags 19\n+\n","filename":"make\/data\/symbols\/java.datatransfer-H.sym.txt","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,902 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/applet\/Applet\n+header extends java\/awt\/Panel nestMembers java\/applet\/Applet$AccessibleApplet flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+innerclass innerClass java\/applet\/Applet$AccessibleApplet outerClass java\/applet\/Applet innerClassName AccessibleApplet flags 4\n+\n+class name java\/applet\/AppletContext\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/applet\/AppletStub\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/applet\/AudioClip\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/awt\/AWTKeyStroke\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/AttributeValue\n+header extends java\/lang\/Object flags 420\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/BorderLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager2,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/CheckboxGroup\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Color\n+header extends java\/lang\/Object implements java\/awt\/Paint,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/ContainerOrderFocusTraversalPolicy\n+header extends java\/awt\/FocusTraversalPolicy implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Dimension\n+header extends java\/awt\/geom\/Dimension2D implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/DisplayMode\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Event\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/FlowLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/FontMetrics\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Graphics\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/GridBagLayoutInfo\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/awt\/Component$BaselineResizeBehavior outerClass java\/awt\/Component innerClassName BaselineResizeBehavior flags 4019\n+\n+class name java\/awt\/GridLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/HeadlessException\n+header extends java\/lang\/UnsupportedOperationException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Insets\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/MenuShortcut\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Point\n+header extends java\/awt\/geom\/Point2D implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Rectangle\n+header extends java\/awt\/geom\/Rectangle2D implements java\/awt\/Shape,java\/io\/Serializable flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/SystemColor\n+header extends java\/awt\/Color implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/TexturePaint\n+header extends java\/lang\/Object implements java\/awt\/Paint flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/awt\/color\/ColorSpace\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/color\/ICC_ColorSpace\n+header extends java\/awt\/color\/ColorSpace flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I4)\n+\n+class name java\/awt\/desktop\/AboutEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AboutHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/AppEvent\n+header extends java\/util\/EventObject flags 21\n+\n+class name java\/awt\/desktop\/AppForegroundEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AppForegroundListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/AppHiddenEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AppHiddenListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/AppReopenedEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AppReopenedListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/FilesEvent\n+header extends java\/awt\/desktop\/AppEvent flags 21\n+\n+class name java\/awt\/desktop\/OpenFilesEvent\n+header extends java\/awt\/desktop\/FilesEvent flags 31\n+\n+class name java\/awt\/desktop\/OpenFilesHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/OpenURIEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/OpenURIHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/PreferencesEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/PreferencesHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/PrintFilesEvent\n+header extends java\/awt\/desktop\/FilesEvent flags 31\n+\n+class name java\/awt\/desktop\/PrintFilesHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/QuitEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/QuitHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/QuitResponse\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/QuitStrategy\n+header extends java\/lang\/Enum flags 4031 signature Ljava\/lang\/Enum<Ljava\/awt\/desktop\/QuitStrategy;>;\n+\n+class name java\/awt\/desktop\/ScreenSleepEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/ScreenSleepListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/SystemEventListener\n+header extends java\/lang\/Object implements java\/util\/EventListener flags 601\n+\n+class name java\/awt\/desktop\/SystemSleepEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/SystemSleepListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/UserSessionListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/dnd\/DragGestureEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name java\/awt\/dnd\/DragGestureRecognizer\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name java\/awt\/dnd\/DragSource\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/dnd\/DropTargetDragEvent\n+header extends java\/awt\/dnd\/DropTargetEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/dnd\/DropTargetDropEvent\n+header extends java\/awt\/dnd\/DropTargetEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ActionEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/AdjustmentEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ComponentEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ContainerEvent\n+header extends java\/awt\/event\/ComponentEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/HierarchyEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/InputMethodEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ItemEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/MouseWheelEvent\n+header extends java\/awt\/event\/MouseEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/PaintEvent\n+header extends java\/awt\/event\/ComponentEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/WindowEvent\n+header extends java\/awt\/event\/ComponentEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/font\/FontRenderContext\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/awt\/RenderingHints$Key outerClass java\/awt\/RenderingHints innerClassName Key flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/font\/GraphicAttribute\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+\n+class name java\/awt\/font\/ImageGraphicAttribute\n+header extends java\/awt\/font\/GraphicAttribute flags 31\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+\n+class name java\/awt\/font\/NumericShaper$Range\n+header extends java\/lang\/Enum nestHost java\/awt\/font\/NumericShaper sealed true flags 4021 signature Ljava\/lang\/Enum<Ljava\/awt\/font\/NumericShaper$Range;>;\n+innerclass innerClass java\/awt\/font\/NumericShaper$Range outerClass java\/awt\/font\/NumericShaper innerClassName Range flags 4009\n+\n+class name java\/awt\/font\/ShapeGraphicAttribute\n+header extends java\/awt\/font\/GraphicAttribute flags 31\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+\n+class name java\/awt\/font\/TextHitInfo\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/font\/TextMeasurer\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 31\n+innerclass innerClass java\/text\/AttributedCharacterIterator$Attribute outerClass java\/text\/AttributedCharacterIterator innerClassName Attribute flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/geom\/AffineTransform\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Double outerClass java\/awt\/geom\/Point2D innerClassName Double flags 9\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/awt\/geom\/Path2D$Double outerClass java\/awt\/geom\/Path2D innerClassName Double flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/geom\/Area\n+header extends java\/lang\/Object implements java\/awt\/Shape,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/awt\/geom\/RectangularShape\n+header extends java\/lang\/Object implements java\/awt\/Shape,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/awt\/image\/AbstractMultiResolutionImage\n+header extends java\/awt\/Image implements java\/awt\/image\/MultiResolutionImage flags 421\n+\n+class name java\/awt\/image\/BandCombineOp\n+header extends java\/lang\/Object implements java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/BandedSampleModel\n+header extends java\/awt\/image\/ComponentSampleModel flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/BaseMultiResolutionImage\n+header extends java\/awt\/image\/AbstractMultiResolutionImage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/BufferedImageFilter\n+header extends java\/awt\/image\/ImageFilter implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ByteLookupTable\n+header extends java\/awt\/image\/LookupTable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ColorConvertOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+\n+class name java\/awt\/image\/ComponentColorModel\n+header extends java\/awt\/image\/ColorModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ComponentSampleModel\n+header extends java\/awt\/image\/SampleModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ConvolveOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+\n+class name java\/awt\/image\/DataBufferUShort\n+header extends java\/awt\/image\/DataBuffer flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/DirectColorModel\n+header extends java\/awt\/image\/PackedColorModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ImageFilter\n+header extends java\/lang\/Object implements java\/awt\/image\/ImageConsumer,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/IndexColorModel\n+header extends java\/awt\/image\/ColorModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/Kernel\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/LookupOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/MultiPixelPackedSampleModel\n+header extends java\/awt\/image\/SampleModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/MultiResolutionImage\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/image\/PackedColorModel\n+header extends java\/awt\/image\/ColorModel flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/Raster\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ReplicateScaleFilter\n+header extends java\/awt\/image\/ImageFilter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/RescaleOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/SampleModel\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ShortLookupTable\n+header extends java\/awt\/image\/LookupTable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/SinglePixelPackedSampleModel\n+header extends java\/awt\/image\/SampleModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/print\/Paper\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/beans\/AppletInitializer\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/beans\/BeanProperty\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;METHOD;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name java\/beans\/Beans\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name instantiate descriptor (Ljava\/lang\/ClassLoader;Ljava\/lang\/String;Ljava\/beans\/beancontext\/BeanContext;Ljava\/beans\/AppletInitializer;)Ljava\/lang\/Object;\n+method name instantiate descriptor (Ljava\/lang\/ClassLoader;Ljava\/lang\/String;Ljava\/beans\/beancontext\/BeanContext;Ljava\/beans\/AppletInitializer;)Ljava\/lang\/Object; thrownTypes java\/io\/IOException,java\/lang\/ClassNotFoundException flags 9 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/beans\/DefaultPersistenceDelegate\n+header extends java\/beans\/PersistenceDelegate flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/Encoder\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/EventSetDescriptor\n+header extends java\/beans\/FeatureDescriptor flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/Expression\n+header extends java\/beans\/Statement flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/FeatureDescriptor\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/beans\/IndexedPropertyDescriptor\n+header extends java\/beans\/PropertyDescriptor flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/JavaBean\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;TYPE;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name java\/beans\/PropertyDescriptor\n+header extends java\/beans\/FeatureDescriptor flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/SimpleBeanInfo\n+header extends java\/lang\/Object implements java\/beans\/BeanInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/accessibility\/AccessibilityProvider\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/accessibility\/AccessibleBundle\n+header extends java\/lang\/Object flags 421 classAnnotations @Ljdk\/Profile+Annotation;(value=I4)\n+\n+class name javax\/accessibility\/AccessibleRelationSet\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/accessibility\/AccessibleStateSet\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/metadata\/IIOMetadata\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/jpeg\/JPEGHuffmanTable\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/jpeg\/JPEGQTable\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFDirectory\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFField\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFImageReadParam\n+header extends javax\/imageio\/ImageReadParam flags 31\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFTag\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFTagSet\n+header extends java\/lang\/Object flags 21\n+\n+class name javax\/imageio\/spi\/ImageReaderWriterSpi\n+header extends javax\/imageio\/spi\/IIOServiceProvider flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/DateTimeSyntax\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/EnumSyntax\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/IntegerSyntax\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/standard\/MediaPrintableArea\n+header extends java\/lang\/Object implements javax\/print\/attribute\/DocAttribute,javax\/print\/attribute\/PrintRequestAttribute,javax\/print\/attribute\/PrintJobAttribute flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/event\/PrintEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/MetaMessage\n+header extends javax\/sound\/midi\/MidiMessage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/MidiMessage\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/Sequence\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/ShortMessage\n+header extends javax\/sound\/midi\/MidiMessage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/SysexMessage\n+header extends javax\/sound\/midi\/MidiMessage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/sampled\/ReverbType\n+header extends java\/lang\/Object flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I4)\n+\n+class name javax\/sound\/sampled\/spi\/FormatConversionProvider\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/sound\/sampled\/AudioFormat$Encoding outerClass javax\/sound\/sampled\/AudioFormat innerClassName Encoding flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/BoxLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager2,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/DebugGraphics\n+header extends java\/awt\/Graphics flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/DefaultBoundedRangeModel\n+header extends java\/lang\/Object implements javax\/swing\/BoundedRangeModel,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/DefaultListSelectionModel\n+header extends java\/lang\/Object implements javax\/swing\/ListSelectionModel,java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/GrayFilter\n+header extends java\/awt\/image\/RGBImageFilter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/JApplet\n+header extends java\/applet\/Applet implements javax\/accessibility\/Accessible,javax\/swing\/RootPaneContainer,javax\/swing\/TransferHandler$HasGetTransferHandler nestMembers javax\/swing\/JApplet$AccessibleJApplet flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")@Ljava\/beans\/JavaBean;(defaultProperty=\"JMenuBar\",description=\"Swing's\\u005C;u0020;Applet\\u005C;u0020;subclass.\")@Ljavax\/swing\/SwingContainer;(delegate=\"getContentPane\")\n+innerclass innerClass javax\/swing\/JApplet$AccessibleJApplet outerClass javax\/swing\/JApplet innerClassName AccessibleJApplet flags 4\n+innerclass innerClass javax\/swing\/TransferHandler$HasGetTransferHandler outerClass javax\/swing\/TransferHandler innerClassName HasGetTransferHandler flags 608\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/JList$AccessibleJList$AccessibleJListChild\n+-method name getAccessibleAction descriptor ()Ljavax\/accessibility\/AccessibleAction;\n+method name getAccessibleAction descriptor ()Ljavax\/accessibility\/AccessibleAction; flags 1\n+\n+class name javax\/swing\/JSlider$AccessibleJSlider\n+header extends javax\/swing\/JComponent$AccessibleJComponent implements javax\/accessibility\/AccessibleValue,javax\/swing\/event\/ChangeListener,javax\/accessibility\/AccessibleAction nestHost javax\/swing\/JSlider flags 21\n+innerclass innerClass javax\/swing\/JSlider$AccessibleJSlider outerClass javax\/swing\/JSlider innerClassName AccessibleJSlider flags 4\n+innerclass innerClass javax\/swing\/JComponent$AccessibleJComponent outerClass javax\/swing\/JComponent innerClassName AccessibleJComponent flags 401\n+method name getAccessibleAction descriptor ()Ljavax\/accessibility\/AccessibleAction; flags 1\n+method name getAccessibleActionCount descriptor ()I flags 1\n+method name getAccessibleActionDescription descriptor (I)Ljava\/lang\/String; flags 1\n+method name doAccessibleAction descriptor (I)Z flags 1\n+\n+class name javax\/swing\/JTextPane\n+header extends javax\/swing\/JEditorPane flags 21 runtimeAnnotations @Ljava\/beans\/JavaBean;(description=\"A\\u005C;u0020;text\\u005C;u0020;component\\u005C;u0020;that\\u005C;u0020;can\\u005C;u0020;be\\u005C;u0020;marked\\u005C;u0020;up\\u005C;u0020;with\\u005C;u0020;attributes\\u005C;u0020;that\\u005C;u0020;are\\u005C;u0020;graphically\\u005C;u0020;represented.\")@Ljavax\/swing\/SwingContainer;\n+\n+class name javax\/swing\/LookAndFeel\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/swing\/text\/JTextComponent$KeyBinding outerClass javax\/swing\/text\/JTextComponent innerClassName KeyBinding flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/MenuSelectionManager\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/RepaintManager\n+-method name addDirtyRegion descriptor (Ljava\/applet\/Applet;IIII)V\n+method name addDirtyRegion descriptor (Ljava\/applet\/Applet;IIII)V flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name javax\/swing\/SizeRequirements\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/SortingFocusTraversalPolicy\n+header extends javax\/swing\/InternalFrameFocusTraversalPolicy flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/SwingContainer\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;TYPE;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name javax\/swing\/UIClientPropertyKey\n+header extends java\/lang\/Object flags 601\n+\n+class name javax\/swing\/border\/LineBorder\n+header extends javax\/swing\/border\/AbstractBorder flags 21\n+innerclass innerClass java\/awt\/geom\/RoundRectangle2D$Float outerClass java\/awt\/geom\/RoundRectangle2D innerClassName Float flags 9\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+innerclass innerClass java\/awt\/geom\/Path2D$Float outerClass java\/awt\/geom\/Path2D innerClassName Float flags 9\n+\n+class name javax\/swing\/event\/EventListenerList\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/event\/ListDataEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/event\/ListSelectionEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/event\/TreeModelEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/filechooser\/FileNameExtensionFilter\n+header extends javax\/swing\/filechooser\/FileFilter flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/filechooser\/FileSystemView\n+method name getSystemIcon descriptor (Ljava\/io\/File;II)Ljavax\/swing\/Icon; flags 1\n+\n+class name javax\/swing\/plaf\/basic\/BasicArrowButton\n+header extends javax\/swing\/JButton implements javax\/swing\/SwingConstants flags 21\n+innerclass innerClass java\/awt\/geom\/Path2D$Double outerClass java\/awt\/geom\/Path2D innerClassName Double flags 9\n+\n+class name javax\/swing\/plaf\/basic\/BasicButtonUI\n+header extends javax\/swing\/plaf\/ButtonUI flags 21\n+innerclass innerClass java\/awt\/Component$BaselineResizeBehavior outerClass java\/awt\/Component innerClassName BaselineResizeBehavior flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/basic\/BasicDirectoryModel\n+-method name intervalAdded descriptor (Ljavax\/swing\/event\/ListDataEvent;)V\n+-method name intervalRemoved descriptor (Ljavax\/swing\/event\/ListDataEvent;)V\n+-method name lt descriptor (Ljava\/io\/File;Ljava\/io\/File;)Z\n+method name intervalAdded descriptor (Ljavax\/swing\/event\/ListDataEvent;)V flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+method name intervalRemoved descriptor (Ljavax\/swing\/event\/ListDataEvent;)V flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+method name lt descriptor (Ljava\/io\/File;Ljava\/io\/File;)Z flags 4 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+\n+class name javax\/swing\/plaf\/basic\/BasicMenuItemUI$MouseInputHandler\n+header extends java\/lang\/Object implements javax\/swing\/event\/MouseInputListener nestHost javax\/swing\/plaf\/basic\/BasicMenuItemUI flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicMenuItemUI$MouseInputHandler outerClass javax\/swing\/plaf\/basic\/BasicMenuItemUI innerClassName MouseInputHandler flags 4\n+\n+class name javax\/swing\/plaf\/basic\/BasicPasswordFieldUI\n+header extends javax\/swing\/plaf\/basic\/BasicTextFieldUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/basic\/BasicScrollPaneUI$HSBChangeListener\n+header extends java\/lang\/Object implements javax\/swing\/event\/ChangeListener nestHost javax\/swing\/plaf\/basic\/BasicScrollPaneUI flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI$HSBChangeListener outerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI innerClassName HSBChangeListener flags 1\n+\n+class name javax\/swing\/plaf\/basic\/BasicScrollPaneUI$PropertyChangeHandler\n+header extends java\/lang\/Object implements java\/beans\/PropertyChangeListener nestHost javax\/swing\/plaf\/basic\/BasicScrollPaneUI flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI$PropertyChangeHandler outerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI innerClassName PropertyChangeHandler flags 1\n+\n+class name javax\/swing\/plaf\/basic\/BasicScrollPaneUI$VSBChangeListener\n+header extends java\/lang\/Object implements javax\/swing\/event\/ChangeListener nestHost javax\/swing\/plaf\/basic\/BasicScrollPaneUI flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI$VSBChangeListener outerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI innerClassName VSBChangeListener flags 1\n+\n+class name javax\/swing\/plaf\/basic\/BasicScrollPaneUI$ViewportChangeHandler\n+header extends java\/lang\/Object implements javax\/swing\/event\/ChangeListener nestHost javax\/swing\/plaf\/basic\/BasicScrollPaneUI flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI$ViewportChangeHandler outerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI innerClassName ViewportChangeHandler flags 1\n+\n+class name javax\/swing\/plaf\/basic\/BasicToolBarSeparatorUI\n+header extends javax\/swing\/plaf\/basic\/BasicSeparatorUI flags 21\n+innerclass innerClass javax\/swing\/JToolBar$Separator outerClass javax\/swing\/JToolBar innerClassName Separator flags 9\n+\n+class name javax\/swing\/plaf\/basic\/BasicToolBarUI\n+-method name createFloatingFrame descriptor (Ljavax\/swing\/JToolBar;)Ljavax\/swing\/JFrame;\n+method name createFloatingFrame descriptor (Ljavax\/swing\/JToolBar;)Ljavax\/swing\/JFrame; flags 4 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+\n+class name javax\/swing\/plaf\/metal\/MetalButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalCheckBoxUI\n+header extends javax\/swing\/plaf\/metal\/MetalRadioButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalRadioButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicRadioButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalToggleButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicToggleButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalToolTipUI\n+header extends javax\/swing\/plaf\/basic\/BasicToolTipUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/multi\/MultiLookAndFeel\n+header extends javax\/swing\/LookAndFeel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicButtonUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthIcon\n+header extends java\/lang\/Object implements javax\/swing\/Icon flags 601\n+\n+class name javax\/swing\/plaf\/synth\/SynthMenuItemUI\n+header extends javax\/swing\/plaf\/basic\/BasicMenuItemUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthMenuUI\n+header extends javax\/swing\/plaf\/basic\/BasicMenuUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthSeparatorUI\n+header extends javax\/swing\/plaf\/SeparatorUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass javax\/swing\/JToolBar$Separator outerClass javax\/swing\/JToolBar innerClassName Separator flags 9\n+\n+class name javax\/swing\/plaf\/synth\/SynthStyle\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/swing\/UIDefaults$LazyInputMap outerClass javax\/swing\/UIDefaults innerClassName LazyInputMap flags 9\n+innerclass innerClass javax\/swing\/UIDefaults$LazyValue outerClass javax\/swing\/UIDefaults innerClassName LazyValue flags 609\n+\n+class name javax\/swing\/table\/AbstractTableModel\n+header extends java\/lang\/Object implements javax\/swing\/table\/TableModel,java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/AbstractWriter\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/BoxView\n+header extends javax\/swing\/text\/CompositeView flags 21\n+innerclass innerClass javax\/swing\/event\/DocumentEvent$ElementChange outerClass javax\/swing\/event\/DocumentEvent innerClassName ElementChange flags 609\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/CompositeView\n+header extends javax\/swing\/text\/View flags 421\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/DateFormatter\n+header extends javax\/swing\/text\/InternationalFormatter flags 21\n+innerclass innerClass java\/text\/DateFormat$Field outerClass java\/text\/DateFormat innerClassName Field flags 9\n+\n+class name javax\/swing\/text\/IconView\n+header extends javax\/swing\/text\/View flags 21\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/LayoutQueue\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/NumberFormatter\n+header extends javax\/swing\/text\/InternationalFormatter flags 21\n+innerclass innerClass java\/text\/NumberFormat$Field outerClass java\/text\/NumberFormat innerClassName Field flags 9\n+innerclass innerClass javax\/swing\/text\/DocumentFilter$FilterBypass outerClass javax\/swing\/text\/DocumentFilter innerClassName FilterBypass flags 409\n+innerclass innerClass java\/text\/AttributedCharacterIterator$Attribute outerClass java\/text\/AttributedCharacterIterator innerClassName Attribute flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/Segment\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/text\/CharacterIterator,java\/lang\/CharSequence flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/TabSet\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/TabStop\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/View\n+header extends java\/lang\/Object implements javax\/swing\/SwingConstants flags 421\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass javax\/swing\/event\/DocumentEvent$ElementChange outerClass javax\/swing\/event\/DocumentEvent innerClassName ElementChange flags 609\n+innerclass innerClass javax\/swing\/event\/DocumentEvent$EventType outerClass javax\/swing\/event\/DocumentEvent innerClassName EventType flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/InlineView\n+header extends javax\/swing\/text\/LabelView flags 21\n+innerclass innerClass javax\/swing\/text\/html\/CSS$Attribute outerClass javax\/swing\/text\/html\/CSS innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/ListView\n+header extends javax\/swing\/text\/html\/BlockView flags 21\n+innerclass innerClass javax\/swing\/text\/html\/StyleSheet$ListPainter outerClass javax\/swing\/text\/html\/StyleSheet innerClassName ListPainter flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/MinimalHTMLWriter\n+header extends javax\/swing\/text\/AbstractWriter flags 21\n+innerclass innerClass javax\/swing\/text\/StyleConstants$ParagraphConstants outerClass javax\/swing\/text\/StyleConstants innerClassName ParagraphConstants flags 9\n+innerclass innerClass javax\/swing\/text\/StyleConstants$CharacterConstants outerClass javax\/swing\/text\/StyleConstants innerClassName CharacterConstants flags 9\n+innerclass innerClass javax\/swing\/text\/StyleConstants$FontConstants outerClass javax\/swing\/text\/StyleConstants innerClassName FontConstants flags 9\n+innerclass innerClass javax\/swing\/text\/StyleConstants$ColorConstants outerClass javax\/swing\/text\/StyleConstants innerClassName ColorConstants flags 9\n+innerclass innerClass javax\/swing\/text\/AbstractDocument$BranchElement outerClass javax\/swing\/text\/AbstractDocument innerClassName BranchElement flags 1\n+innerclass innerClass javax\/swing\/text\/StyleContext$NamedStyle outerClass javax\/swing\/text\/StyleContext innerClassName NamedStyle flags 1\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/ObjectView\n+header extends javax\/swing\/text\/ComponentView flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/Option\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/ParagraphView\n+header extends javax\/swing\/text\/ParagraphView flags 21\n+innerclass innerClass javax\/swing\/text\/html\/StyleSheet$BoxPainter outerClass javax\/swing\/text\/html\/StyleSheet innerClassName BoxPainter flags 9\n+innerclass innerClass javax\/swing\/text\/html\/CSS$Attribute outerClass javax\/swing\/text\/html\/CSS innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/ContentModel\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/DocumentParser\n+header extends javax\/swing\/text\/html\/parser\/Parser flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTMLEditorKit$ParserCallback outerClass javax\/swing\/text\/html\/HTMLEditorKit innerClassName ParserCallback flags 9\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Tag outerClass javax\/swing\/text\/html\/HTML innerClassName Tag flags 9\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/Parser\n+header extends java\/lang\/Object implements javax\/swing\/text\/html\/parser\/DTDConstants flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/TagElement\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Tag outerClass javax\/swing\/text\/html\/HTML innerClassName Tag flags 9\n+innerclass innerClass javax\/swing\/text\/html\/HTML$UnknownTag outerClass javax\/swing\/text\/html\/HTML innerClassName UnknownTag flags 9\n+\n+class name javax\/swing\/tree\/DefaultTreeModel\n+header extends java\/lang\/Object implements java\/io\/Serializable,javax\/swing\/tree\/TreeModel flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name javax\/swing\/tree\/DefaultTreeSelectionModel\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable,javax\/swing\/tree\/TreeSelectionModel flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/tree\/TreePath\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/undo\/AbstractUndoableEdit\n+header extends java\/lang\/Object implements javax\/swing\/undo\/UndoableEdit,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/undo\/CompoundEdit\n+header extends javax\/swing\/undo\/AbstractUndoableEdit flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/undo\/UndoableEditSupport\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.desktop-H.sym.txt","additions":902,"deletions":0,"binary":false,"changes":902,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/lang\/instrument\/UnmodifiableModuleException\n+header extends java\/lang\/RuntimeException flags 21\n+\n","filename":"make\/data\/symbols\/java.instrument-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/util\/logging\/ErrorManager\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/LogManager\n+-method name checkAccess descriptor ()V\n+method name checkAccess descriptor ()V thrownTypes java\/lang\/SecurityException flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/util\/logging\/LoggingMXBean\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+\n+class name java\/util\/logging\/LoggingPermission\n+header extends java\/security\/BasicPermission flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/MemoryHandler\n+header extends java\/util\/logging\/Handler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/SimpleFormatter\n+header extends java\/util\/logging\/Formatter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/SocketHandler\n+header extends java\/util\/logging\/StreamHandler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/XMLFormatter\n+header extends java\/util\/logging\/Formatter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.logging-H.sym.txt","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,265 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/lang\/management\/LockInfo\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/ManagementPermission\n+header extends java\/security\/BasicPermission flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/MemoryUsage\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/MonitorInfo\n+header extends java\/lang\/management\/LockInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/RuntimeMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/PlatformManagedObject flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/Attribute\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/AttributeList\n+header extends java\/util\/ArrayList flags 21 signature Ljava\/util\/ArrayList<Ljava\/lang\/Object;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/BadAttributeValueExpException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/BadBinaryOpValueExpException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/BadStringOperationException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/ConstructorParameters\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name javax\/management\/ImmutableDescriptor\n+header extends java\/lang\/Object implements javax\/management\/Descriptor flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanAttributeInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanConstructorInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanNotificationInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanOperationInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanParameterInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanPermission\n+header extends java\/security\/Permission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerDelegate\n+header extends java\/lang\/Object implements javax\/management\/MBeanServerDelegateMBean,javax\/management\/NotificationEmitter flags 21\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerFactory\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerInvocationHandler\n+header extends java\/lang\/Object implements java\/lang\/reflect\/InvocationHandler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerNotification\n+header extends javax\/management\/Notification flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerPermission\n+header extends java\/security\/BasicPermission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanTrustPermission\n+header extends java\/security\/BasicPermission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/Notification\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/ObjectInstance\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/Query\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/StandardEmitterMBean\n+header extends javax\/management\/StandardMBean implements javax\/management\/NotificationEmitter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/StringValueExp\n+header extends java\/lang\/Object implements javax\/management\/ValueExp flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/loading\/DefaultLoaderRepository\n+header extends java\/lang\/Object flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+\n+class name javax\/management\/loading\/MLetContent\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/modelmbean\/InvalidTargetObjectTypeException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/modelmbean\/XMLParseException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/ArrayType\n+header extends javax\/management\/openmbean\/OpenType flags 21 signature <T:Ljava\/lang\/Object;>Ljavax\/management\/openmbean\/OpenType<TT;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/CompositeDataInvocationHandler\n+header extends java\/lang\/Object implements java\/lang\/reflect\/InvocationHandler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/CompositeDataSupport\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/CompositeData,java\/io\/Serializable flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/CompositeType\n+header extends javax\/management\/openmbean\/OpenType flags 21 signature Ljavax\/management\/openmbean\/OpenType<Ljavax\/management\/openmbean\/CompositeData;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/OpenMBeanAttributeInfoSupport\n+header extends javax\/management\/MBeanAttributeInfo implements javax\/management\/openmbean\/OpenMBeanAttributeInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/OpenMBeanOperationInfoSupport\n+header extends javax\/management\/MBeanOperationInfo implements javax\/management\/openmbean\/OpenMBeanOperationInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/SimpleType\n+header extends javax\/management\/openmbean\/OpenType flags 31 signature <T:Ljava\/lang\/Object;>Ljavax\/management\/openmbean\/OpenType<TT;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/TabularDataSupport\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/TabularData,java\/util\/Map,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature Ljava\/lang\/Object;Ljavax\/management\/openmbean\/TabularData;Ljava\/util\/Map<Ljava\/lang\/Object;Ljava\/lang\/Object;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/TabularType\n+header extends javax\/management\/openmbean\/OpenType flags 21 signature Ljavax\/management\/openmbean\/OpenType<Ljavax\/management\/openmbean\/TabularData;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/relation\/RelationNotification\n+header extends javax\/management\/Notification flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/management\/relation\/RelationSupport\n+header extends java\/lang\/Object implements javax\/management\/relation\/RelationSupportMBean,javax\/management\/MBeanRegistration flags 21\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+\n+class name javax\/management\/relation\/Role\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/relation\/RoleInfo\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/relation\/RoleResult\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/management\/relation\/RoleUnresolved\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/JMXConnectorServerFactory\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/util\/ServiceLoader$Provider outerClass java\/util\/ServiceLoader innerClassName Provider flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/JMXPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/JMXServiceURL\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/NotificationResult\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/TargetedNotification\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.management-H.sym.txt","additions":265,"deletions":0,"binary":false,"changes":265,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/management\/remote\/rmi\/RMIConnectorServer\n+header extends javax\/management\/remote\/JMXConnectorServer flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/rmi\/RMIIIOPServerImpl\n+header extends javax\/management\/remote\/rmi\/RMIServerImpl flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;\n+\n+class name javax\/management\/remote\/rmi\/RMIServerImpl\n+header extends java\/lang\/Object implements java\/io\/Closeable,javax\/management\/remote\/rmi\/RMIServer flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.management.rmi-H.sym.txt","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/naming\/BinaryRefAddr\n+header extends javax\/naming\/RefAddr flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/Binding\n+header extends javax\/naming\/NameClassPair flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/CompositeName\n+header extends java\/lang\/Object implements javax\/naming\/Name flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/CompoundName\n+header extends java\/lang\/Object implements javax\/naming\/Name flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/Context\n+-field name APPLET descriptor Ljava\/lang\/String;\n+field name APPLET descriptor Ljava\/lang\/String; constantValue java.naming.applet flags 19 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name javax\/naming\/LinkException\n+header extends javax\/naming\/NamingException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/NameClassPair\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/NamingException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/RefAddr\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/Reference\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/directory\/AttributeModificationException\n+header extends javax\/naming\/NamingException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/directory\/ModificationItem\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/directory\/SearchResult\n+header extends javax\/naming\/Binding flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.naming-H.sym.txt","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name java.rmi\n+header exports java\/rmi,java\/rmi\/dgc,java\/rmi\/registry,java\/rmi\/server,javax\/rmi\/ssl requires name\\u0020;java.base\\u0020;flags\\u0020;8000,name\\u0020;java.logging\\u0020;flags\\u0020;0 uses java\/rmi\/server\/RMIClassLoaderSpi target linux-amd64 flags 8000\n+\n+class name java\/rmi\/RMISecurityManager\n+header extends java\/lang\/SecurityManager flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"1.8\")\n+\n+class name java\/rmi\/RemoteException\n+header extends java\/io\/IOException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+-class name java\/rmi\/activation\/Activatable\n+\n+-class name java\/rmi\/activation\/ActivateFailedException\n+\n+-class name java\/rmi\/activation\/ActivationDesc\n+\n+-class name java\/rmi\/activation\/ActivationException\n+\n+-class name java\/rmi\/activation\/ActivationGroup\n+\n+-class name java\/rmi\/activation\/ActivationGroupDesc\n+\n+-class name java\/rmi\/activation\/ActivationGroupDesc$CommandEnvironment\n+\n+-class name java\/rmi\/activation\/ActivationGroupID\n+\n+-class name java\/rmi\/activation\/ActivationGroup_Stub\n+\n+-class name java\/rmi\/activation\/ActivationID\n+\n+-class name java\/rmi\/activation\/ActivationInstantiator\n+\n+-class name java\/rmi\/activation\/ActivationMonitor\n+\n+-class name java\/rmi\/activation\/ActivationSystem\n+\n+-class name java\/rmi\/activation\/Activator\n+\n+-class name java\/rmi\/activation\/UnknownGroupException\n+\n+-class name java\/rmi\/activation\/UnknownObjectException\n+\n+class name java\/rmi\/dgc\/VMID\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/rmi\/server\/ObjID\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/rmi\/server\/RemoteObject\n+header extends java\/lang\/Object implements java\/rmi\/Remote,java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/rmi\/server\/ServerCloneException\n+header extends java\/lang\/CloneNotSupportedException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/rmi\/server\/UID\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.rmi-H.sym.txt","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/script\/ScriptException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.scripting-H.sym.txt","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/security\/auth\/kerberos\/DelegationPermission\n+header extends java\/security\/BasicPermission implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/EncryptionKey\n+header extends java\/lang\/Object implements javax\/crypto\/SecretKey flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/KerberosCredMessage\n+header extends java\/lang\/Object implements javax\/security\/auth\/Destroyable flags 31\n+innerclass innerClass java\/util\/Base64$Encoder outerClass java\/util\/Base64 innerClassName Encoder flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/KerberosKey\n+header extends java\/lang\/Object implements javax\/crypto\/SecretKey flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/KerberosPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/KerberosTicket\n+header extends java\/lang\/Object implements javax\/security\/auth\/Destroyable,javax\/security\/auth\/Refreshable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/KeyTab\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/ServicePermission\n+header extends java\/security\/Permission implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name org\/ietf\/jgss\/GSSException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name org\/ietf\/jgss\/Oid\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.security.jgss-H.sym.txt","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/security\/sasl\/SaslException\n+header extends java\/io\/IOException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.security.sasl-H.sym.txt","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/smartcardio\/ATR\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/smartcardio\/Card\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/smartcardio\/CardChannel\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/smartcardio\/CardException\n+header extends java\/lang\/Exception flags 21\n+\n+class name javax\/smartcardio\/CardNotPresentException\n+header extends javax\/smartcardio\/CardException flags 21\n+\n+class name javax\/smartcardio\/CardPermission\n+header extends java\/security\/Permission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/smartcardio\/CardTerminal\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/smartcardio\/CommandAPDU\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/smartcardio\/ResponseAPDU\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/smartcardio\/TerminalFactorySpi\n+header extends java\/lang\/Object flags 421\n+\n","filename":"make\/data\/symbols\/java.smartcardio-H.sym.txt","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/sql\/BatchUpdateException\n+header extends java\/sql\/SQLException flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name java\/sql\/ConnectionBuilder\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/sql\/JDBCType\n+header extends java\/lang\/Enum implements java\/sql\/SQLType flags 4031 signature Ljava\/lang\/Enum<Ljava\/sql\/JDBCType;>;Ljava\/sql\/SQLType;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/sql\/SQLWarning\n+header extends java\/sql\/SQLException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/sql\/ShardingKey\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/sql\/ShardingKeyBuilder\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/sql\/Statement\n+header extends java\/lang\/Object implements java\/sql\/Wrapper,java\/lang\/AutoCloseable flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/PooledConnectionBuilder\n+header extends java\/lang\/Object flags 601\n+\n+class name javax\/sql\/XAConnectionBuilder\n+header extends java\/lang\/Object flags 601\n+\n","filename":"make\/data\/symbols\/java.sql-H.sym.txt","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/sql\/rowset\/BaseRowSet\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SerialArray\n+header extends java\/lang\/Object implements java\/sql\/Array,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/sql\/rowset\/serial\/SerialBlob\n+header extends java\/lang\/Object implements java\/sql\/Blob,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/sql\/rowset\/serial\/SerialClob\n+header extends java\/lang\/Object implements java\/sql\/Clob,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SerialDatalink\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SerialJavaObject\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/sql\/rowset\/serial\/SerialRef\n+header extends java\/lang\/Object implements java\/sql\/Ref,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SerialStruct\n+header extends java\/lang\/Object implements java\/sql\/Struct,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.sql.rowset-H.sym.txt","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/xml\/catalog\/Catalog\n+header extends java\/lang\/Object flags 601\n+\n+class name javax\/xml\/catalog\/CatalogException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name javax\/xml\/catalog\/CatalogManager\n+header extends java\/lang\/Object flags 31\n+\n+class name javax\/xml\/catalog\/CatalogResolver\n+header extends java\/lang\/Object implements org\/xml\/sax\/EntityResolver,javax\/xml\/stream\/XMLResolver,javax\/xml\/transform\/URIResolver,org\/w3c\/dom\/ls\/LSResourceResolver flags 601\n+\n+class name javax\/xml\/datatype\/DatatypeFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/xml\/datatype\/DatatypeConstants$Field outerClass javax\/xml\/datatype\/DatatypeConstants innerClassName Field flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/datatype\/Duration\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/xml\/datatype\/DatatypeConstants$Field outerClass javax\/xml\/datatype\/DatatypeConstants innerClassName Field flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/namespace\/QName\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/parsers\/DocumentBuilder\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/parsers\/DocumentBuilderFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/parsers\/SAXParser\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/parsers\/SAXParserFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/stream\/XMLEventReader\n+header extends java\/lang\/Object implements java\/util\/Iterator flags 601 signature Ljava\/lang\/Object;Ljava\/util\/Iterator<Ljava\/lang\/Object;>;\n+\n+class name javax\/xml\/stream\/XMLInputFactory\n+-method name newFactory descriptor ()Ljavax\/xml\/stream\/XMLInputFactory;\n+method name newFactory descriptor ()Ljavax\/xml\/stream\/XMLInputFactory; thrownTypes javax\/xml\/stream\/FactoryConfigurationError flags 9\n+\n+class name javax\/xml\/stream\/XMLStreamException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/transform\/Transformer\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/transform\/TransformerException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/validation\/SchemaFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/xpath\/XPath\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass javax\/xml\/xpath\/XPathEvaluationResult$XPathResultType outerClass javax\/xml\/xpath\/XPathEvaluationResult innerClassName XPathResultType flags 4019\n+\n+class name javax\/xml\/xpath\/XPathException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name javax\/xml\/xpath\/XPathExpression\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass javax\/xml\/xpath\/XPathEvaluationResult$XPathResultType outerClass javax\/xml\/xpath\/XPathEvaluationResult innerClassName XPathResultType flags 4019\n+\n+class name javax\/xml\/xpath\/XPathFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/xpath\/XPathNodes\n+header extends java\/lang\/Object implements java\/lang\/Iterable flags 601 signature Ljava\/lang\/Object;Ljava\/lang\/Iterable<Lorg\/w3c\/dom\/Node;>;\n+\n+class name org\/w3c\/dom\/ElementTraversal\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/xml\/sax\/AttributeList\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/DocumentHandler\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/HandlerBase\n+header extends java\/lang\/Object implements org\/xml\/sax\/EntityResolver,org\/xml\/sax\/DTDHandler,org\/xml\/sax\/DocumentHandler,org\/xml\/sax\/ErrorHandler flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/Parser\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/ext\/Attributes2Impl\n+header extends org\/xml\/sax\/helpers\/AttributesImpl implements org\/xml\/sax\/ext\/Attributes2 flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name org\/xml\/sax\/helpers\/AttributeListImpl\n+header extends java\/lang\/Object implements org\/xml\/sax\/AttributeList flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/helpers\/AttributesImpl\n+header extends java\/lang\/Object implements org\/xml\/sax\/Attributes flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name org\/xml\/sax\/helpers\/ParserFactory\n+header extends java\/lang\/Object flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/helpers\/XMLFilterImpl\n+header extends java\/lang\/Object implements org\/xml\/sax\/XMLFilter,org\/xml\/sax\/EntityResolver,org\/xml\/sax\/DTDHandler,org\/xml\/sax\/ContentHandler,org\/xml\/sax\/ErrorHandler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name org\/xml\/sax\/helpers\/XMLReaderFactory\n+header extends java\/lang\/Object flags 31 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.xml-H.sym.txt","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/xml\/crypto\/NodeSetData\n+header extends java\/lang\/Object implements javax\/xml\/crypto\/Data,java\/lang\/Iterable flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljavax\/xml\/crypto\/Data;Ljava\/lang\/Iterable<TT;>;\n+\n+class name javax\/xml\/crypto\/dom\/DOMCryptoContext\n+header extends java\/lang\/Object implements javax\/xml\/crypto\/XMLCryptoContext flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/crypto\/dsig\/SignatureMethod\n+field name RSA_PSS descriptor Ljava\/lang\/String; constantValue http:\/\/www.w3.org\/2007\/05\/xmldsig-more#rsa-pss flags 19\n+\n+class name javax\/xml\/crypto\/dsig\/XMLSignatureFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/crypto\/dsig\/keyinfo\/KeyInfoFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/crypto\/dsig\/spec\/RSAPSSParameterSpec\n+header extends java\/lang\/Object implements javax\/xml\/crypto\/dsig\/spec\/SignatureMethodParameterSpec flags 31\n+method name <init> descriptor (Ljava\/security\/spec\/PSSParameterSpec;)V flags 1\n+method name getPSSParameterSpec descriptor ()Ljava\/security\/spec\/PSSParameterSpec; flags 1\n+\n","filename":"make\/data\/symbols\/java.xml.crypto-H.sym.txt","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/java\/accessibility\/util\/AccessibilityListenerList\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/java\/accessibility\/util\/EventID\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/java\/accessibility\/util\/GUIInitializedListener\n+header extends java\/lang\/Object implements java\/util\/EventListener flags 601\n+\n+class name com\/sun\/java\/accessibility\/util\/TopLevelWindowListener\n+header extends java\/lang\/Object implements java\/util\/EventListener flags 601\n+\n+class name com\/sun\/java\/accessibility\/util\/Translator\n+header extends javax\/accessibility\/AccessibleContext implements javax\/accessibility\/Accessible,javax\/accessibility\/AccessibleComponent flags 21\n+\n","filename":"make\/data\/symbols\/jdk.accessibility-H.sym.txt","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/tools\/attach\/AgentInitializationException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/tools\/attach\/AgentLoadException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/tools\/attach\/AttachNotSupportedException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/tools\/attach\/AttachOperationFailedException\n+header extends java\/io\/IOException flags 21\n+\n+class name com\/sun\/tools\/attach\/AttachPermission\n+header extends java\/security\/BasicPermission flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/tools\/attach\/VirtualMachine\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/tools\/attach\/VirtualMachineDescriptor\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/tools\/attach\/spi\/AttachProvider\n+header extends java\/lang\/Object flags 421\n+\n","filename":"make\/data\/symbols\/jdk.attach-H.sym.txt","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,367 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/source\/doctree\/AuthorTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/BlockTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/CommentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DeprecatedTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DocCommentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DocRootTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DocTreeVisitor\n+header extends java\/lang\/Object flags 601 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+\n+class name com\/sun\/source\/doctree\/DocTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/EndElementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/EntityTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ErroneousTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/TextTree flags 601\n+\n+class name com\/sun\/source\/doctree\/HiddenTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/IdentifierTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/IndexTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/InheritDocTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/InlineTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/LinkTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/LiteralTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ParamTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ProvidesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ReferenceTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SeeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SerialDataTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SerialFieldTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SerialTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SinceTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/StartElementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SummaryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/TextTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ThrowsTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/UnknownBlockTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/UnknownInlineTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/UsesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ValueTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/VersionTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/tree\/AnnotatedTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/AnnotationTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ArrayAccessTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ArrayTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/AssertTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/AssignmentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/BinaryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/BlockTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/BreakTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/CatchTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ClassTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+-method name getPermitsClause descriptor ()Ljava\/util\/List;\n+method name getPermitsClause descriptor ()Ljava\/util\/List; flags 1 signature ()Ljava\/util\/List<+Lcom\/sun\/source\/tree\/Tree;>;\n+\n+class name com\/sun\/source\/tree\/CompilationUnitTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+method name getModule descriptor ()Lcom\/sun\/source\/tree\/ModuleTree; flags 1\n+\n+class name com\/sun\/source\/tree\/CompoundAssignmentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ConditionalExpressionTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ContinueTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/DirectiveTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/DoWhileLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/EmptyStatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/EnhancedForLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ErroneousTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ExportsTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/ExpressionStatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ExpressionTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ForLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/IdentifierTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/IfTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ImportTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/InstanceOfTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/IntersectionTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/LabeledStatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/LineMap\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/tree\/LiteralTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/MemberSelectTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/MethodInvocationTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/MethodTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ModifiersTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/NewArrayTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/NewClassTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/OpensTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/PackageTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ParameterizedTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ParenthesizedTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/PrimitiveTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ProvidesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/RequiresTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/ReturnTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/Scope\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/tree\/StatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/SwitchTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/SynchronizedTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ThrowTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/TreeVisitor\n+header extends java\/lang\/Object flags 601 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+\n+class name com\/sun\/source\/tree\/TryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/TypeCastTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/TypeParameterTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/UnaryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/UnionTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/UsesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/VariableTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/WhileLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/WildcardTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/util\/DocSourcePositions\n+header extends java\/lang\/Object implements com\/sun\/source\/util\/SourcePositions flags 601\n+\n+class name com\/sun\/source\/util\/DocTreeFactory\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass com\/sun\/source\/doctree\/AttributeTree$ValueKind outerClass com\/sun\/source\/doctree\/AttributeTree innerClassName ValueKind flags 4019\n+\n+class name com\/sun\/source\/util\/DocTreePathScanner\n+header extends com\/sun\/source\/util\/DocTreeScanner flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Lcom\/sun\/source\/util\/DocTreeScanner<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/DocTreeScanner\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTreeVisitor flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/source\/doctree\/DocTreeVisitor<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/DocTrees\n+header extends com\/sun\/source\/util\/Trees flags 421\n+innerclass innerClass javax\/tools\/JavaCompiler$CompilationTask outerClass javax\/tools\/JavaCompiler innerClassName CompilationTask flags 609\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+\n+class name com\/sun\/source\/util\/JavacTask\n+header extends java\/lang\/Object implements javax\/tools\/JavaCompiler$CompilationTask flags 421\n+innerclass innerClass javax\/tools\/JavaCompiler$CompilationTask outerClass javax\/tools\/JavaCompiler innerClassName CompilationTask flags 609\n+\n+class name com\/sun\/source\/util\/Plugin\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/util\/SimpleDocTreeVisitor\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTreeVisitor flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/source\/doctree\/DocTreeVisitor<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/SimpleTreeVisitor\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/TreeVisitor flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/source\/tree\/TreeVisitor<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/SourcePositions\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/util\/TaskListener\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/util\/TreePathScanner\n+header extends com\/sun\/source\/util\/TreeScanner flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Lcom\/sun\/source\/util\/TreeScanner<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/Trees\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/tools\/JavaCompiler$CompilationTask outerClass javax\/tools\/JavaCompiler innerClassName CompilationTask flags 609\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+\n+class name com\/sun\/tools\/javac\/Main\n+header extends java\/lang\/Object flags 21\n+\n","filename":"make\/data\/symbols\/jdk.compiler-H.sym.txt","additions":367,"deletions":0,"binary":false,"changes":367,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/dynalink\/CallSiteDescriptor\n+header extends jdk\/dynalink\/SecureLookupSupplier flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/DynamicLinker\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/StackWalker$StackFrame outerClass java\/lang\/StackWalker innerClassName StackFrame flags 609\n+innerclass innerClass java\/lang\/StackWalker$Option outerClass java\/lang\/StackWalker innerClassName Option flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/NamedOperation\n+header extends java\/lang\/Object implements jdk\/dynalink\/Operation flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/Namespace\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/dynalink\/NamespaceOperation\n+header extends java\/lang\/Object implements jdk\/dynalink\/Operation flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/NoSuchDynamicMethodException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name jdk\/dynalink\/Operation\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/dynalink\/RelinkableCallSite\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/dynalink\/SecureLookupSupplier\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/StandardNamespace\n+header extends java\/lang\/Enum implements jdk\/dynalink\/Namespace flags 4031 signature Ljava\/lang\/Enum<Ljdk\/dynalink\/StandardNamespace;>;Ljdk\/dynalink\/Namespace;\n+\n+class name jdk\/dynalink\/StandardOperation\n+header extends java\/lang\/Enum implements jdk\/dynalink\/Operation flags 4031 signature Ljava\/lang\/Enum<Ljdk\/dynalink\/StandardOperation;>;Ljdk\/dynalink\/Operation;\n+\n+class name jdk\/dynalink\/beans\/MissingMemberHandlerFactory\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+\n+class name jdk\/dynalink\/linker\/GuardedInvocation\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/linker\/GuardedInvocationTransformer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+\n+class name jdk\/dynalink\/linker\/GuardingDynamicLinker\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/dynalink\/linker\/GuardingDynamicLinkerExporter\n+header extends java\/lang\/Object implements java\/util\/function\/Supplier flags 421 signature Ljava\/lang\/Object;Ljava\/util\/function\/Supplier<Ljava\/util\/List<Ljdk\/dynalink\/linker\/GuardingDynamicLinker;>;>;\n+\n+class name jdk\/dynalink\/linker\/GuardingTypeConverterFactory\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/linker\/LinkRequest\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/dynalink\/linker\/LinkerServices\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass jdk\/dynalink\/linker\/ConversionComparator$Comparison outerClass jdk\/dynalink\/linker\/ConversionComparator innerClassName Comparison flags 4019\n+\n+class name jdk\/dynalink\/linker\/MethodHandleTransformer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+\n+class name jdk\/dynalink\/linker\/MethodTypeConversionStrategy\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+\n+class name jdk\/dynalink\/linker\/TypeBasedGuardingDynamicLinker\n+header extends java\/lang\/Object implements jdk\/dynalink\/linker\/GuardingDynamicLinker flags 601\n+\n+class name jdk\/dynalink\/linker\/support\/CompositeGuardingDynamicLinker\n+header extends java\/lang\/Object implements jdk\/dynalink\/linker\/GuardingDynamicLinker flags 21\n+\n+class name jdk\/dynalink\/linker\/support\/DefaultInternalObjectFilter\n+header extends java\/lang\/Object implements jdk\/dynalink\/linker\/MethodHandleTransformer flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/linker\/support\/Guards\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/linker\/support\/Lookup\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/linker\/support\/SimpleLinkRequest\n+header extends java\/lang\/Object implements jdk\/dynalink\/linker\/LinkRequest flags 21\n+\n+class name jdk\/dynalink\/linker\/support\/TypeUtilities\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name jdk\/dynalink\/support\/AbstractRelinkableCallSite\n+header extends java\/lang\/invoke\/MutableCallSite implements jdk\/dynalink\/RelinkableCallSite flags 421\n+\n+class name jdk\/dynalink\/support\/ChainedCallSite\n+header extends jdk\/dynalink\/support\/AbstractRelinkableCallSite flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/support\/SimpleRelinkableCallSite\n+header extends jdk\/dynalink\/support\/AbstractRelinkableCallSite flags 21\n+\n","filename":"make\/data\/symbols\/jdk.dynalink-H.sym.txt","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/net\/httpserver\/Filter\n+method name beforeHandler descriptor (Ljava\/lang\/String;Ljava\/util\/function\/Consumer;)Lcom\/sun\/net\/httpserver\/Filter; flags 9 signature (Ljava\/lang\/String;Ljava\/util\/function\/Consumer<Lcom\/sun\/net\/httpserver\/HttpExchange;>;)Lcom\/sun\/net\/httpserver\/Filter;\n+method name afterHandler descriptor (Ljava\/lang\/String;Ljava\/util\/function\/Consumer;)Lcom\/sun\/net\/httpserver\/Filter; flags 9 signature (Ljava\/lang\/String;Ljava\/util\/function\/Consumer<Lcom\/sun\/net\/httpserver\/HttpExchange;>;)Lcom\/sun\/net\/httpserver\/Filter;\n+\n+class name com\/sun\/net\/httpserver\/Headers\n+header extends java\/lang\/Object implements java\/util\/Map flags 21 signature Ljava\/lang\/Object;Ljava\/util\/Map<Ljava\/lang\/String;Ljava\/util\/List<Ljava\/lang\/String;>;>;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name com\/sun\/net\/httpserver\/HttpContext\n+header extends java\/lang\/Object flags 421\n+\n+class name com\/sun\/net\/httpserver\/HttpHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/net\/httpserver\/HttpPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/net\/httpserver\/HttpServer\n+header extends java\/lang\/Object flags 421\n+\n+class name com\/sun\/net\/httpserver\/HttpsConfigurator\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/net\/httpserver\/HttpsExchange\n+header extends com\/sun\/net\/httpserver\/HttpExchange flags 421\n+\n+class name com\/sun\/net\/httpserver\/HttpsParameters\n+header extends java\/lang\/Object flags 421\n+\n+class name com\/sun\/net\/httpserver\/HttpsServer\n+header extends com\/sun\/net\/httpserver\/HttpServer flags 421\n+\n+class name com\/sun\/net\/httpserver\/spi\/HttpServerProvider\n+header extends java\/lang\/Object flags 421\n+\n","filename":"make\/data\/symbols\/jdk.httpserver-H.sym.txt","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,232 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/incubator\/foreign\/CLinker\n+header extends java\/lang\/Object nestMembers jdk\/incubator\/foreign\/CLinker$TypeKind,jdk\/incubator\/foreign\/CLinker$VaList,jdk\/incubator\/foreign\/CLinker$VaList$Builder sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$TypeKind outerClass jdk\/incubator\/foreign\/CLinker innerClassName TypeKind flags 4019\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$VaList outerClass jdk\/incubator\/foreign\/CLinker innerClassName VaList flags 609\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$VaList$Builder outerClass jdk\/incubator\/foreign\/CLinker$VaList innerClassName Builder flags 609\n+-method name getInstance descriptor ()Ljdk\/incubator\/foreign\/CLinker;\n+-method name upcallStub descriptor (Ljava\/lang\/invoke\/MethodHandle;Ljdk\/incubator\/foreign\/FunctionDescriptor;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name toCString descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name toCString descriptor (Ljava\/lang\/String;Ljava\/nio\/charset\/Charset;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name toCString descriptor (Ljava\/lang\/String;Ljdk\/incubator\/foreign\/NativeScope;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name toCString descriptor (Ljava\/lang\/String;Ljava\/nio\/charset\/Charset;Ljdk\/incubator\/foreign\/NativeScope;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name toJavaStringRestricted descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)Ljava\/lang\/String;\n+-method name toJavaStringRestricted descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;Ljava\/nio\/charset\/Charset;)Ljava\/lang\/String;\n+-method name allocateMemoryRestricted descriptor (J)Ljdk\/incubator\/foreign\/MemoryAddress;\n+-method name freeMemoryRestricted descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)V\n+method name getInstance descriptor ()Ljdk\/incubator\/foreign\/CLinker; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name downcallHandle descriptor (Ljdk\/incubator\/foreign\/Addressable;Ljdk\/incubator\/foreign\/SegmentAllocator;Ljava\/lang\/invoke\/MethodType;Ljdk\/incubator\/foreign\/FunctionDescriptor;)Ljava\/lang\/invoke\/MethodHandle; flags 401\n+method name downcallHandle descriptor (Ljava\/lang\/invoke\/MethodType;Ljdk\/incubator\/foreign\/FunctionDescriptor;)Ljava\/lang\/invoke\/MethodHandle; flags 401\n+method name upcallStub descriptor (Ljava\/lang\/invoke\/MethodHandle;Ljdk\/incubator\/foreign\/FunctionDescriptor;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemoryAddress; flags 401\n+method name toCString descriptor (Ljava\/lang\/String;Ljdk\/incubator\/foreign\/SegmentAllocator;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name toCString descriptor (Ljava\/lang\/String;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name toCString descriptor (Ljava\/lang\/String;Ljava\/nio\/charset\/Charset;Ljdk\/incubator\/foreign\/SegmentAllocator;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name toCString descriptor (Ljava\/lang\/String;Ljava\/nio\/charset\/Charset;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name toJavaString descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)Ljava\/lang\/String; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name toJavaString descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;Ljava\/nio\/charset\/Charset;)Ljava\/lang\/String; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name allocateMemory descriptor (J)Ljdk\/incubator\/foreign\/MemoryAddress; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name freeMemory descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)V flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+\n+class name jdk\/incubator\/foreign\/CLinker$VaList\n+header extends java\/lang\/Object implements jdk\/incubator\/foreign\/Addressable nestHost jdk\/incubator\/foreign\/CLinker sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$VaList outerClass jdk\/incubator\/foreign\/CLinker innerClassName VaList flags 609\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$VaList$Builder outerClass jdk\/incubator\/foreign\/CLinker$VaList innerClassName Builder flags 609\n+-method name vargAsSegment descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name vargAsSegment descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;Ljdk\/incubator\/foreign\/NativeScope;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name isAlive descriptor ()Z\n+-method name close descriptor ()V\n+-method name copy descriptor (Ljdk\/incubator\/foreign\/NativeScope;)Ljdk\/incubator\/foreign\/CLinker$VaList;\n+-method name ofAddressRestricted descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/CLinker$VaList;\n+-method name make descriptor (Ljava\/util\/function\/Consumer;)Ljdk\/incubator\/foreign\/CLinker$VaList;\n+-method name make descriptor (Ljava\/util\/function\/Consumer;Ljdk\/incubator\/foreign\/NativeScope;)Ljdk\/incubator\/foreign\/CLinker$VaList;\n+method name vargAsSegment descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;Ljdk\/incubator\/foreign\/SegmentAllocator;)Ljdk\/incubator\/foreign\/MemorySegment; flags 401\n+method name vargAsSegment descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 401\n+method name scope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 401\n+method name ofAddress descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/CLinker$VaList; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name ofAddress descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/CLinker$VaList; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name make descriptor (Ljava\/util\/function\/Consumer;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/CLinker$VaList; flags 9 signature (Ljava\/util\/function\/Consumer<Ljdk\/incubator\/foreign\/CLinker$VaList$Builder;>;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/CLinker$VaList;\n+\n+class name jdk\/incubator\/foreign\/CLinker$VaList$Builder\n+header extends java\/lang\/Object nestHost jdk\/incubator\/foreign\/CLinker sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$VaList outerClass jdk\/incubator\/foreign\/CLinker innerClassName VaList flags 609\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$VaList$Builder outerClass jdk\/incubator\/foreign\/CLinker$VaList innerClassName Builder flags 609\n+\n+class name jdk\/incubator\/foreign\/GroupLayout\n+header extends jdk\/incubator\/foreign\/AbstractLayout implements jdk\/incubator\/foreign\/MemoryLayout flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/incubator\/foreign\/LibraryLookup\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name lookup descriptor (Ljava\/lang\/String;)Ljava\/util\/Optional;\n+-method name ofDefault descriptor ()Ljdk\/incubator\/foreign\/LibraryLookup;\n+-method name ofPath descriptor (Ljava\/nio\/file\/Path;)Ljdk\/incubator\/foreign\/LibraryLookup;\n+-method name ofLibrary descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/LibraryLookup;\n+method name lookup descriptor (Ljava\/lang\/String;)Ljava\/util\/Optional; flags 401 signature (Ljava\/lang\/String;)Ljava\/util\/Optional<Ljdk\/incubator\/foreign\/MemoryAddress;>;\n+method name lookup descriptor (Ljava\/lang\/String;Ljdk\/incubator\/foreign\/MemoryLayout;)Ljava\/util\/Optional; flags 401 signature (Ljava\/lang\/String;Ljdk\/incubator\/foreign\/MemoryLayout;)Ljava\/util\/Optional<Ljdk\/incubator\/foreign\/MemorySegment;>;\n+method name ofDefault descriptor ()Ljdk\/incubator\/foreign\/LibraryLookup; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name ofPath descriptor (Ljava\/nio\/file\/Path;)Ljdk\/incubator\/foreign\/LibraryLookup; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name ofLibrary descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/LibraryLookup; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+\n+-class name jdk\/incubator\/foreign\/LibraryLookup$Symbol\n+\n+-class name jdk\/incubator\/foreign\/MappedMemorySegments\n+\n+class name jdk\/incubator\/foreign\/MemoryAddress\n+header extends java\/lang\/Object implements jdk\/incubator\/foreign\/Addressable sealed true flags 601\n+-method name asSegmentRestricted descriptor (J)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name asSegmentRestricted descriptor (JLjava\/lang\/Runnable;Ljava\/lang\/Object;)Ljdk\/incubator\/foreign\/MemorySegment;\n+method name scope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 401\n+method name asSegment descriptor (JLjdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name asSegment descriptor (JLjava\/lang\/Runnable;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name isNative descriptor ()Z flags 401\n+\n+class name jdk\/incubator\/foreign\/MemoryLayout\n+header extends java\/lang\/Object implements java\/lang\/constant\/Constable nestMembers jdk\/incubator\/foreign\/MemoryLayout$PathElement sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/MemoryLayout$PathElement outerClass jdk\/incubator\/foreign\/MemoryLayout innerClassName PathElement flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name ofPaddingBits descriptor (J)Ljdk\/incubator\/foreign\/MemoryLayout;\n+-method name ofValueBits descriptor (JLjava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout;\n+-method name ofSequence descriptor (JLjdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/SequenceLayout;\n+-method name ofSequence descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/SequenceLayout;\n+-method name ofStruct descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/GroupLayout;\n+-method name ofUnion descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/GroupLayout;\n+method name sliceHandle descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout$PathElement;)Ljava\/lang\/invoke\/MethodHandle; flags 81\n+method name paddingLayout descriptor (J)Ljdk\/incubator\/foreign\/MemoryLayout; flags 9\n+method name valueLayout descriptor (JLjava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout; flags 9\n+method name sequenceLayout descriptor (JLjdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/SequenceLayout; flags 9\n+method name sequenceLayout descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/SequenceLayout; flags 9\n+method name structLayout descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/GroupLayout; flags 89\n+method name unionLayout descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/GroupLayout; flags 89\n+\n+class name jdk\/incubator\/foreign\/MemoryLayout$PathElement\n+header extends java\/lang\/Object nestHost jdk\/incubator\/foreign\/MemoryLayout sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/MemoryLayout$PathElement outerClass jdk\/incubator\/foreign\/MemoryLayout innerClassName PathElement flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/incubator\/foreign\/MemorySegment\n+header extends java\/lang\/Object implements jdk\/incubator\/foreign\/Addressable sealed true flags 601\n+innerclass innerClass java\/nio\/channels\/FileChannel$MapMode outerClass java\/nio\/channels\/FileChannel innerClassName MapMode flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-field name READ descriptor I\n+-field name WRITE descriptor I\n+-field name CLOSE descriptor I\n+-field name HANDOFF descriptor I\n+-field name ALL_ACCESS descriptor I\n+-field name SHARE descriptor I\n+-method name ownerThread descriptor ()Ljava\/lang\/Thread;\n+method name asReadOnly descriptor ()Ljdk\/incubator\/foreign\/MemorySegment; flags 401\n+-method name isAlive descriptor ()Z\n+method name isReadOnly descriptor ()Z flags 401\n+-method name close descriptor ()V\n+-method name allocateNative descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name allocateNative descriptor (J)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name allocateNative descriptor (JJ)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name withAccessModes descriptor (I)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name hasAccessModes descriptor (I)Z\n+-method name accessModes descriptor ()I\n+-method name spliterator descriptor (Ljdk\/incubator\/foreign\/SequenceLayout;)Ljava\/util\/Spliterator;\n+-method name handoff descriptor (Ljava\/lang\/Thread;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name handoff descriptor (Ljdk\/incubator\/foreign\/NativeScope;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name share descriptor ()Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name registerCleaner descriptor (Ljava\/lang\/ref\/Cleaner;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name mapFile descriptor (Ljava\/nio\/file\/Path;JJLjava\/nio\/channels\/FileChannel$MapMode;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name ofNativeRestricted descriptor ()Ljdk\/incubator\/foreign\/MemorySegment;\n+method name spliterator descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljava\/util\/Spliterator; flags 401 signature (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljava\/util\/Spliterator<Ljdk\/incubator\/foreign\/MemorySegment;>;\n+method name elements descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljava\/util\/stream\/Stream; flags 401 signature (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljava\/util\/stream\/Stream<Ljdk\/incubator\/foreign\/MemorySegment;>;\n+method name scope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 401\n+method name isNative descriptor ()Z flags 401\n+method name isLoaded descriptor ()Z flags 401\n+method name load descriptor ()V flags 401\n+method name unload descriptor ()V flags 401\n+method name force descriptor ()V flags 401\n+method name allocateNative descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name allocateNative descriptor (JLjdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name allocateNative descriptor (JJLjdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name mapFile descriptor (Ljava\/nio\/file\/Path;JJLjava\/nio\/channels\/FileChannel$MapMode;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; thrownTypes java\/io\/IOException flags 9\n+method name globalNativeSegment descriptor ()Ljdk\/incubator\/foreign\/MemorySegment; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+\n+-class name jdk\/incubator\/foreign\/NativeScope\n+\n+class name jdk\/incubator\/foreign\/ResourceScope\n+header extends java\/lang\/Object implements java\/lang\/AutoCloseable nestMembers jdk\/incubator\/foreign\/ResourceScope$Handle sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/ResourceScope$Handle outerClass jdk\/incubator\/foreign\/ResourceScope innerClassName Handle flags 609\n+method name isAlive descriptor ()Z flags 401\n+method name ownerThread descriptor ()Ljava\/lang\/Thread; flags 401\n+method name isImplicit descriptor ()Z flags 401\n+method name close descriptor ()V flags 401\n+method name addCloseAction descriptor (Ljava\/lang\/Runnable;)V flags 401\n+method name acquire descriptor ()Ljdk\/incubator\/foreign\/ResourceScope$Handle; flags 401\n+method name release descriptor (Ljdk\/incubator\/foreign\/ResourceScope$Handle;)V flags 401\n+method name newConfinedScope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 9\n+method name newConfinedScope descriptor (Ljava\/lang\/ref\/Cleaner;)Ljdk\/incubator\/foreign\/ResourceScope; flags 9\n+method name newSharedScope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 9\n+method name newSharedScope descriptor (Ljava\/lang\/ref\/Cleaner;)Ljdk\/incubator\/foreign\/ResourceScope; flags 9\n+method name newImplicitScope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 9\n+method name globalScope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 9\n+\n+class name jdk\/incubator\/foreign\/ResourceScope$Handle\n+header extends java\/lang\/Object nestHost jdk\/incubator\/foreign\/ResourceScope sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/ResourceScope$Handle outerClass jdk\/incubator\/foreign\/ResourceScope innerClassName Handle flags 609\n+method name scope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 401\n+\n+class name jdk\/incubator\/foreign\/SegmentAllocator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass jdk\/incubator\/foreign\/MemoryLayout$PathElement outerClass jdk\/incubator\/foreign\/MemoryLayout innerClassName PathElement flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;B)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;C)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;S)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;I)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;F)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;J)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;D)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;Ljdk\/incubator\/foreign\/Addressable;)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[B)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[S)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[C)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[I)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[F)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[J)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[D)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[Ljdk\/incubator\/foreign\/Addressable;)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;J)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (J)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (JJ)Ljdk\/incubator\/foreign\/MemorySegment; flags 401\n+method name arenaAllocator descriptor (JLjdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/SegmentAllocator; flags 9\n+method name arenaAllocator descriptor (Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/SegmentAllocator; flags 9\n+method name ofSegment descriptor (Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/SegmentAllocator; flags 9\n+method name ofScope descriptor (Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/SegmentAllocator; flags 9\n+\n+class name jdk\/incubator\/foreign\/SequenceLayout\n+header extends jdk\/incubator\/foreign\/AbstractLayout implements jdk\/incubator\/foreign\/MemoryLayout flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/jdk.incubator.foreign-H.sym.txt","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/security\/jarsigner\/JarSignerException\n+header extends java\/lang\/RuntimeException flags 21\n+\n","filename":"make\/data\/symbols\/jdk.jartool-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/javadoc\/doclet\/Reporter\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+\n+class name jdk\/javadoc\/doclet\/StandardDoclet\n+header extends java\/lang\/Object implements jdk\/javadoc\/doclet\/Doclet flags 21\n+innerclass innerClass jdk\/javadoc\/doclet\/Doclet$Option outerClass jdk\/javadoc\/doclet\/Doclet innerClassName Option flags 609\n+\n","filename":"make\/data\/symbols\/jdk.javadoc-H.sym.txt","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/tools\/jconsole\/JConsolePlugin\n+header extends java\/lang\/Object flags 421\n+\n","filename":"make\/data\/symbols\/jdk.jconsole-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,395 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/jdi\/AbsentInformationException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/Accessible\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/ArrayReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ArrayType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ReferenceType flags 601\n+\n+class name com\/sun\/jdi\/BooleanType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/BooleanValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue flags 601\n+\n+class name com\/sun\/jdi\/Bootstrap\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/jdi\/ByteType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/ByteValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/ByteValue;>;\n+\n+class name com\/sun\/jdi\/CharType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/CharValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/CharValue;>;\n+\n+class name com\/sun\/jdi\/ClassLoaderReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ClassNotLoadedException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/ClassNotPreparedException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/ClassObjectReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ClassType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ReferenceType flags 601\n+\n+class name com\/sun\/jdi\/DoubleType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/DoubleValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/DoubleValue;>;\n+\n+class name com\/sun\/jdi\/Field\n+header extends java\/lang\/Object implements com\/sun\/jdi\/TypeComponent,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/TypeComponent;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/Field;>;\n+\n+class name com\/sun\/jdi\/FloatType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/FloatValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/FloatValue;>;\n+\n+class name com\/sun\/jdi\/IncompatibleThreadStateException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/InconsistentDebugInfoException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/IntegerType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/IntegerValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/IntegerValue;>;\n+\n+class name com\/sun\/jdi\/InterfaceType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ReferenceType flags 601\n+\n+class name com\/sun\/jdi\/InternalException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/InvalidCodeIndexException\n+header extends java\/lang\/RuntimeException flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;\n+\n+class name com\/sun\/jdi\/InvalidLineNumberException\n+header extends java\/lang\/RuntimeException flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;\n+\n+class name com\/sun\/jdi\/InvalidModuleException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/InvalidStackFrameException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/InvalidTypeException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/InvocationException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/JDIPermission\n+header extends java\/security\/BasicPermission flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/jdi\/LocalVariable\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/Mirror;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/LocalVariable;>;\n+\n+class name com\/sun\/jdi\/Locatable\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/Location\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/Mirror;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/Location;>;\n+\n+class name com\/sun\/jdi\/LongType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/LongValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/LongValue;>;\n+\n+class name com\/sun\/jdi\/Method\n+header extends java\/lang\/Object implements com\/sun\/jdi\/TypeComponent,com\/sun\/jdi\/Locatable,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/TypeComponent;Lcom\/sun\/jdi\/Locatable;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/Method;>;\n+\n+class name com\/sun\/jdi\/Mirror\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/ModuleReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/MonitorInfo\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/NativeMethodException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/ObjectCollectedException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/ObjectReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Value flags 601\n+\n+class name com\/sun\/jdi\/PathSearchingVirtualMachine\n+header extends java\/lang\/Object implements com\/sun\/jdi\/VirtualMachine flags 601\n+\n+class name com\/sun\/jdi\/PrimitiveType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Type flags 601\n+\n+class name com\/sun\/jdi\/PrimitiveValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Value flags 601\n+\n+class name com\/sun\/jdi\/ReferenceType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Type,java\/lang\/Comparable,com\/sun\/jdi\/Accessible flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/Type;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/ReferenceType;>;Lcom\/sun\/jdi\/Accessible;\n+\n+class name com\/sun\/jdi\/ShortType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/ShortValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/ShortValue;>;\n+\n+class name com\/sun\/jdi\/StackFrame\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,com\/sun\/jdi\/Locatable flags 601\n+\n+class name com\/sun\/jdi\/StringReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ThreadGroupReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ThreadReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/Type\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/TypeComponent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,com\/sun\/jdi\/Accessible flags 601\n+\n+class name com\/sun\/jdi\/VMCannotBeModifiedException\n+header extends java\/lang\/UnsupportedOperationException flags 21\n+\n+class name com\/sun\/jdi\/VMDisconnectedException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/VMMismatchException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/VMOutOfMemoryException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/Value\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/VirtualMachine\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/VirtualMachineManager\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/VoidType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Type flags 601\n+\n+class name com\/sun\/jdi\/VoidValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Value flags 601\n+\n+class name com\/sun\/jdi\/connect\/AttachingConnector\n+header extends java\/lang\/Object implements com\/sun\/jdi\/connect\/Connector flags 601\n+innerclass innerClass com\/sun\/jdi\/connect\/Connector$Argument outerClass com\/sun\/jdi\/connect\/Connector innerClassName Argument flags 609\n+\n+class name com\/sun\/jdi\/connect\/IllegalConnectorArgumentsException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/connect\/LaunchingConnector\n+header extends java\/lang\/Object implements com\/sun\/jdi\/connect\/Connector flags 601\n+innerclass innerClass com\/sun\/jdi\/connect\/Connector$Argument outerClass com\/sun\/jdi\/connect\/Connector innerClassName Argument flags 609\n+\n+class name com\/sun\/jdi\/connect\/ListeningConnector\n+header extends java\/lang\/Object implements com\/sun\/jdi\/connect\/Connector flags 601\n+innerclass innerClass com\/sun\/jdi\/connect\/Connector$Argument outerClass com\/sun\/jdi\/connect\/Connector innerClassName Argument flags 609\n+\n+class name com\/sun\/jdi\/connect\/Transport\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/connect\/TransportTimeoutException\n+header extends java\/io\/IOException flags 21\n+\n+class name com\/sun\/jdi\/connect\/VMStartException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/connect\/spi\/ClosedConnectionException\n+header extends java\/io\/IOException flags 21\n+\n+class name com\/sun\/jdi\/connect\/spi\/Connection\n+header extends java\/lang\/Object flags 421\n+\n+class name com\/sun\/jdi\/event\/AccessWatchpointEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/WatchpointEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/BreakpointEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/ClassPrepareEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/ClassUnloadEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/Event\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/event\/EventIterator\n+header extends java\/lang\/Object implements java\/util\/Iterator flags 601 signature Ljava\/lang\/Object;Ljava\/util\/Iterator<Lcom\/sun\/jdi\/event\/Event;>;\n+\n+class name com\/sun\/jdi\/event\/EventQueue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/event\/EventSet\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,java\/util\/Set flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/Mirror;Ljava\/util\/Set<Lcom\/sun\/jdi\/event\/Event;>;\n+\n+class name com\/sun\/jdi\/event\/ExceptionEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/LocatableEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event,com\/sun\/jdi\/Locatable flags 601\n+\n+class name com\/sun\/jdi\/event\/MethodEntryEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MethodExitEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/ModificationWatchpointEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/WatchpointEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MonitorContendedEnterEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MonitorContendedEnteredEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MonitorWaitEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MonitorWaitedEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/StepEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/ThreadDeathEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/ThreadStartEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/VMDeathEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/VMDisconnectEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/VMStartEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/WatchpointEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/request\/AccessWatchpointRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/WatchpointRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/BreakpointRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest,com\/sun\/jdi\/Locatable flags 601\n+\n+class name com\/sun\/jdi\/request\/ClassPrepareRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/ClassUnloadRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/DuplicateRequestException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/request\/EventRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/request\/EventRequestManager\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/request\/ExceptionRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/InvalidRequestStateException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/request\/MethodEntryRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MethodExitRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/ModificationWatchpointRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/WatchpointRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MonitorContendedEnterRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MonitorContendedEnteredRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MonitorWaitRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MonitorWaitedRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/StepRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/ThreadDeathRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/ThreadStartRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/VMDeathRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/WatchpointRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n","filename":"make\/data\/symbols\/jdk.jdi-H.sym.txt","additions":395,"deletions":0,"binary":false,"changes":395,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/jshell\/DeclarationSnippet\n+header extends jdk\/jshell\/PersistentSnippet flags 421\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/Diag\n+header extends java\/lang\/Object flags 421\n+\n+class name jdk\/jshell\/EvalException\n+header extends jdk\/jshell\/JShellException flags 21\n+\n+class name jdk\/jshell\/ExpressionSnippet\n+header extends jdk\/jshell\/Snippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/ImportSnippet\n+header extends jdk\/jshell\/PersistentSnippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/JShellException\n+header extends java\/lang\/Exception flags 21\n+\n+class name jdk\/jshell\/MethodSnippet\n+header extends jdk\/jshell\/DeclarationSnippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/PersistentSnippet\n+header extends jdk\/jshell\/Snippet flags 421\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/Snippet$SubKind\n+-field name RECORD_SUBKIND descriptor Ljdk\/jshell\/Snippet$SubKind;\n+field name RECORD_SUBKIND descriptor Ljdk\/jshell\/Snippet$SubKind; flags 4019\n+\n+class name jdk\/jshell\/SnippetEvent\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$Status outerClass jdk\/jshell\/Snippet innerClassName Status flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/StatementSnippet\n+header extends jdk\/jshell\/Snippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/TypeDeclSnippet\n+header extends jdk\/jshell\/DeclarationSnippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/execution\/FailOverExecutionControlProvider\n+header extends java\/lang\/Object implements jdk\/jshell\/spi\/ExecutionControlProvider flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/execution\/JdiDefaultExecutionControl\n+header extends jdk\/jshell\/execution\/JdiExecutionControl flags 21\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$InternalException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName InternalException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$EngineTerminationException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName EngineTerminationException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$RunException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName RunException flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/execution\/JdiExecutionControlProvider\n+header extends java\/lang\/Object implements jdk\/jshell\/spi\/ExecutionControlProvider flags 21\n+\n+class name jdk\/jshell\/execution\/LoaderDelegate\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ClassBytecodes outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ClassBytecodes flags 19\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ClassInstallException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ClassInstallException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$NotImplementedException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName NotImplementedException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$EngineTerminationException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName EngineTerminationException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$InternalException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName InternalException flags 9\n+\n+class name jdk\/jshell\/execution\/LocalExecutionControlProvider\n+header extends java\/lang\/Object implements jdk\/jshell\/spi\/ExecutionControlProvider flags 21\n+\n+class name jdk\/jshell\/spi\/ExecutionControlProvider\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/jshell\/spi\/ExecutionEnv\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/jshell\/spi\/SPIResolutionException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name jdk\/jshell\/tool\/JavaShellToolBuilder\n+header extends java\/lang\/Object flags 601\n+method name interactiveTerminal descriptor (Z)Ljdk\/jshell\/tool\/JavaShellToolBuilder; flags 1\n+\n","filename":"make\/data\/symbols\/jdk.jshell-H.sym.txt","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name netscape\/javascript\/JSException\n+header extends java\/lang\/RuntimeException flags 21\n+\n","filename":"make\/data\/symbols\/jdk.jsobject-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/management\/GarbageCollectionNotificationInfo\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/CompositeDataView flags 21\n+\n+class name com\/sun\/management\/GarbageCollectorMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/GarbageCollectorMXBean flags 601\n+\n+class name com\/sun\/management\/GcInfo\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/CompositeData,javax\/management\/openmbean\/CompositeDataView flags 21\n+\n+class name com\/sun\/management\/HotSpotDiagnosticMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/PlatformManagedObject flags 601\n+\n+class name com\/sun\/management\/OperatingSystemMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/OperatingSystemMXBean flags 601\n+\n+class name com\/sun\/management\/ThreadMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/ThreadMXBean flags 601\n+\n+class name com\/sun\/management\/UnixOperatingSystemMXBean\n+header extends java\/lang\/Object implements com\/sun\/management\/OperatingSystemMXBean flags 601\n+\n","filename":"make\/data\/symbols\/jdk.management-H.sym.txt","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/net\/NetworkPermission\n+header extends java\/security\/BasicPermission flags 31\n+\n","filename":"make\/data\/symbols\/jdk.net-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/nio\/sctp\/AbstractNotificationHandler\n+header extends java\/lang\/Object implements com\/sun\/nio\/sctp\/NotificationHandler flags 21 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/nio\/sctp\/NotificationHandler<TT;>;\n+\n+class name com\/sun\/nio\/sctp\/Association\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/nio\/sctp\/HandlerResult\n+header extends java\/lang\/Enum flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/nio\/sctp\/HandlerResult;>;\n+\n+class name com\/sun\/nio\/sctp\/IllegalReceiveException\n+header extends java\/lang\/IllegalStateException flags 21\n+\n+class name com\/sun\/nio\/sctp\/IllegalUnbindException\n+header extends java\/lang\/IllegalStateException flags 21\n+\n+class name com\/sun\/nio\/sctp\/InvalidStreamException\n+header extends java\/lang\/IllegalArgumentException flags 21\n+\n+class name com\/sun\/nio\/sctp\/MessageInfo\n+header extends java\/lang\/Object flags 421\n+\n+class name com\/sun\/nio\/sctp\/Notification\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/nio\/sctp\/NotificationHandler\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+\n+class name com\/sun\/nio\/sctp\/SctpChannel\n+header extends java\/nio\/channels\/spi\/AbstractSelectableChannel flags 421\n+\n+class name com\/sun\/nio\/sctp\/SctpMultiChannel\n+header extends java\/nio\/channels\/spi\/AbstractSelectableChannel flags 421\n+\n+class name com\/sun\/nio\/sctp\/SctpServerChannel\n+header extends java\/nio\/channels\/spi\/AbstractSelectableChannel flags 421\n+\n+class name com\/sun\/nio\/sctp\/SctpSocketOption\n+header extends java\/lang\/Object implements java\/net\/SocketOption flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/net\/SocketOption<TT;>;\n+\n+class name com\/sun\/nio\/sctp\/SendFailedNotification\n+header extends java\/lang\/Object implements com\/sun\/nio\/sctp\/Notification flags 421\n+\n+class name com\/sun\/nio\/sctp\/ShutdownNotification\n+header extends java\/lang\/Object implements com\/sun\/nio\/sctp\/Notification flags 421\n+\n","filename":"make\/data\/symbols\/jdk.sctp-H.sym.txt","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/security\/auth\/LdapPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 31\n+\n+class name com\/sun\/security\/auth\/NTDomainPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+\n+class name com\/sun\/security\/auth\/NTNumericCredential\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/security\/auth\/NTSid\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+\n+class name com\/sun\/security\/auth\/NTSidDomainPrincipal\n+header extends com\/sun\/security\/auth\/NTSid flags 21\n+\n+class name com\/sun\/security\/auth\/NTSidGroupPrincipal\n+header extends com\/sun\/security\/auth\/NTSid flags 21\n+\n+class name com\/sun\/security\/auth\/NTSidPrimaryGroupPrincipal\n+header extends com\/sun\/security\/auth\/NTSid flags 21\n+\n+class name com\/sun\/security\/auth\/NTSidUserPrincipal\n+header extends com\/sun\/security\/auth\/NTSid flags 21\n+\n+class name com\/sun\/security\/auth\/NTUserPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+\n+class name com\/sun\/security\/auth\/PrincipalComparator\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/security\/auth\/UnixNumericGroupPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+\n+class name com\/sun\/security\/auth\/UnixNumericUserPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+\n+class name com\/sun\/security\/auth\/UnixPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+\n+class name com\/sun\/security\/auth\/UserPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 31\n+\n+class name com\/sun\/security\/auth\/callback\/TextCallbackHandler\n+header extends java\/lang\/Object implements javax\/security\/auth\/callback\/CallbackHandler flags 21\n+\n+class name com\/sun\/security\/auth\/login\/ConfigFile\n+header extends javax\/security\/auth\/login\/Configuration flags 21\n+\n+class name com\/sun\/security\/auth\/module\/JndiLoginModule\n+header extends java\/lang\/Object implements javax\/security\/auth\/spi\/LoginModule flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/auth\/module\/KeyStoreLoginModule\n+header extends java\/lang\/Object implements javax\/security\/auth\/spi\/LoginModule flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/auth\/module\/Krb5LoginModule\n+header extends java\/lang\/Object implements javax\/security\/auth\/spi\/LoginModule flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/auth\/module\/LdapLoginModule\n+header extends java\/lang\/Object implements javax\/security\/auth\/spi\/LoginModule flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/auth\/module\/NTLoginModule\n+header extends java\/lang\/Object implements javax\/security\/auth\/spi\/LoginModule flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/auth\/module\/NTSystem\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/security\/auth\/module\/UnixLoginModule\n+header extends java\/lang\/Object implements javax\/security\/auth\/spi\/LoginModule flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/auth\/module\/UnixSystem\n+header extends java\/lang\/Object flags 21\n+\n","filename":"make\/data\/symbols\/jdk.security.auth-H.sym.txt","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/security\/jgss\/AuthorizationDataEntry\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/jgss\/ExtendedGSSContext\n+header extends java\/lang\/Object implements org\/ietf\/jgss\/GSSContext flags 601\n+\n+class name com\/sun\/security\/jgss\/ExtendedGSSCredential\n+header extends java\/lang\/Object implements org\/ietf\/jgss\/GSSCredential flags 601\n+\n+class name com\/sun\/security\/jgss\/GSSUtil\n+header extends java\/lang\/Object flags 21\n+-method name <init> descriptor ()V\n+\n+class name com\/sun\/security\/jgss\/InquireSecContextPermission\n+header extends java\/security\/BasicPermission flags 31\n+\n+class name com\/sun\/security\/jgss\/InquireType\n+header extends java\/lang\/Enum flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/security\/jgss\/InquireType;>;\n+\n","filename":"make\/data\/symbols\/jdk.security.jgss-H.sym.txt","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/nio\/file\/ExtendedCopyOption\n+header extends java\/lang\/Enum implements java\/nio\/file\/CopyOption flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/nio\/file\/ExtendedCopyOption;>;Ljava\/nio\/file\/CopyOption; classAnnotations @Lsun\/Proprietary+Annotation;\n+\n+class name com\/sun\/nio\/file\/ExtendedOpenOption\n+header extends java\/lang\/Enum implements java\/nio\/file\/OpenOption flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/nio\/file\/ExtendedOpenOption;>;Ljava\/nio\/file\/OpenOption; classAnnotations @Lsun\/Proprietary+Annotation;\n+\n+class name com\/sun\/nio\/file\/ExtendedWatchEventModifier\n+header extends java\/lang\/Enum implements java\/nio\/file\/WatchEvent$Modifier flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/nio\/file\/ExtendedWatchEventModifier;>;Ljava\/nio\/file\/WatchEvent$Modifier; classAnnotations @Lsun\/Proprietary+Annotation;\n+innerclass innerClass java\/nio\/file\/WatchEvent$Modifier outerClass java\/nio\/file\/WatchEvent innerClassName Modifier flags 609\n+\n+class name com\/sun\/nio\/file\/SensitivityWatchEventModifier\n+header extends java\/lang\/Enum implements java\/nio\/file\/WatchEvent$Modifier flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/nio\/file\/SensitivityWatchEventModifier;>;Ljava\/nio\/file\/WatchEvent$Modifier; classAnnotations @Lsun\/Proprietary+Annotation;\n+innerclass innerClass java\/nio\/file\/WatchEvent$Modifier outerClass java\/nio\/file\/WatchEvent innerClassName Modifier flags 609\n+\n+class name sun\/misc\/SignalHandler\n+header extends java\/lang\/Object flags 601 classAnnotations @Lsun\/Proprietary+Annotation;\n+\n+class name sun\/misc\/Unsafe\n+-method name defineAnonymousClass descriptor (Ljava\/lang\/Class;[B[Ljava\/lang\/Object;)Ljava\/lang\/Class;\n+\n+class name sun\/reflect\/ReflectionFactory\n+header extends java\/lang\/Object flags 21 classAnnotations @Lsun\/Proprietary+Annotation;\n+\n","filename":"make\/data\/symbols\/jdk.unsupported-H.sym.txt","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,295 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name org\/w3c\/dom\/css\/CSS2Properties\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSCharsetRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSFontFaceRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSImportRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSMediaRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSPageRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSPrimitiveValue\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSValue flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSRule\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSRuleList\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSStyleDeclaration\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSStyleRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSStyleSheet\n+header extends java\/lang\/Object implements org\/w3c\/dom\/stylesheets\/StyleSheet flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSUnknownRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSValue\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSValueList\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSValue flags 601\n+\n+class name org\/w3c\/dom\/css\/Counter\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/DOMImplementationCSS\n+header extends java\/lang\/Object implements org\/w3c\/dom\/DOMImplementation flags 601\n+\n+class name org\/w3c\/dom\/css\/DocumentCSS\n+header extends java\/lang\/Object implements org\/w3c\/dom\/stylesheets\/DocumentStyle flags 601\n+\n+class name org\/w3c\/dom\/css\/ElementCSSInlineStyle\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/RGBColor\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/Rect\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/ViewCSS\n+header extends java\/lang\/Object implements org\/w3c\/dom\/views\/AbstractView flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLAnchorElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLAppletElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLAreaElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLBRElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLBaseElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLBaseFontElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLBodyElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLButtonElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLCollection\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLDListElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLDOMImplementation\n+header extends java\/lang\/Object implements org\/w3c\/dom\/DOMImplementation flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLDirectoryElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLDivElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLDocument\n+header extends java\/lang\/Object implements org\/w3c\/dom\/Document flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/Element flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLFieldSetElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLFontElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLFormElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLFrameElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLFrameSetElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLHRElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLHeadElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLHeadingElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLHtmlElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLIFrameElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLImageElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLInputElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLIsIndexElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLLIElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLLabelElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLLegendElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLLinkElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLMapElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLMenuElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLMetaElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLModElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLOListElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLObjectElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLOptGroupElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLOptionElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLParagraphElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLParamElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLPreElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLQuoteElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLScriptElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLSelectElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLStyleElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTableCaptionElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTableCellElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTableColElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTableElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTableRowElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTableSectionElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTextAreaElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTitleElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLUListElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/stylesheets\/DocumentStyle\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/stylesheets\/LinkStyle\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/stylesheets\/MediaList\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/stylesheets\/StyleSheet\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/stylesheets\/StyleSheetList\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/xpath\/XPathEvaluator\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/xpath\/XPathException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name org\/w3c\/dom\/xpath\/XPathExpression\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/xpath\/XPathNSResolver\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/xpath\/XPathNamespace\n+header extends java\/lang\/Object implements org\/w3c\/dom\/Node flags 601\n+\n+class name org\/w3c\/dom\/xpath\/XPathResult\n+header extends java\/lang\/Object flags 601\n+\n","filename":"make\/data\/symbols\/jdk.xml.dom-H.sym.txt","additions":295,"deletions":0,"binary":false,"changes":295,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-generate platforms 7:8:9:A:B:C:D:E:F:G\n+generate platforms 7:8:9:A:B:C:D:E:F:G:H\n@@ -43,0 +43,1 @@\n+platform version H base G files java.base-H.sym.txt:java.compiler-H.sym.txt:java.datatransfer-H.sym.txt:java.desktop-H.sym.txt:java.instrument-H.sym.txt:java.logging-H.sym.txt:java.management-H.sym.txt:java.management.rmi-H.sym.txt:java.naming-H.sym.txt:java.rmi-H.sym.txt:java.scripting-H.sym.txt:java.security.jgss-H.sym.txt:java.security.sasl-H.sym.txt:java.smartcardio-H.sym.txt:java.sql-H.sym.txt:java.sql.rowset-H.sym.txt:java.xml-H.sym.txt:java.xml.crypto-H.sym.txt:jdk.accessibility-H.sym.txt:jdk.attach-H.sym.txt:jdk.compiler-H.sym.txt:jdk.dynalink-H.sym.txt:jdk.httpserver-H.sym.txt:jdk.incubator.foreign-H.sym.txt:jdk.jartool-H.sym.txt:jdk.javadoc-H.sym.txt:jdk.jconsole-H.sym.txt:jdk.jdi-H.sym.txt:jdk.jshell-H.sym.txt:jdk.jsobject-H.sym.txt:jdk.management-H.sym.txt:jdk.net-H.sym.txt:jdk.sctp-H.sym.txt:jdk.security.auth-H.sym.txt:jdk.security.jgss-H.sym.txt:jdk.unsupported-H.sym.txt:jdk.xml.dom-H.sym.txt\n","filename":"make\/data\/symbols\/symbols","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-\t$(ECHO) \"SUPPORT=$(SUPPORT_OUTPUTDIR)\" > $(OUT)\n@@ -52,1 +51,1 @@\n-\t          moduleSrcDirs='$(call FindModuleSrcDirs,$(mod))' \\\n+\t          moduleSrcDirs='$(foreach m,$(call FindModuleSrcDirs,$(mod)),$(call RelativePath,$m,$(topdir)))' \\\n@@ -54,1 +53,1 @@\n-\t        #)\\\"\" >> $(OUT)\n+\t        #)\\\"\" > $(OUT)\n@@ -56,2 +55,2 @@\n-\t$(ECHO) \"SEL_MODULES=\\\"$(SEL_MODULES)\\\"\" >> $(OUT)\n-\t$(ECHO) \"BOOT_JDK=\\\"$(BOOT_JDK)\\\"\" >> $(OUT)\n+\t$(ECHO) \"RELATIVE_PROJECT_DIR=\\\"$(call RelativePath,$(topdir),$(IDEA_OUTPUT_PARENT))\\\"\" >> $(OUT)\n+\t$(ECHO) \"RELATIVE_BUILD_DIR=\\\"$(call RelativePath,$(OUTPUTDIR),$(IDEA_OUTPUT_PARENT))\\\"\" >> $(OUT)\n@@ -59,1 +58,0 @@\n-\t$(ECHO) \"SPEC=\\\"$(SPEC)\\\"\" >> $(OUT)\n","filename":"make\/ide\/idea\/jdk\/idea.gmk","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -6,4 +6,4 @@\n-      <directory url=\"file:\/\/$PROJECT_DIR$\/src\" includeSubdirectories=\"true\" \/>\n-      <directory url=\"file:\/\/$PROJECT_DIR$\/build\" includeSubdirectories=\"true\" \/>\n-      <directory url=\"file:\/\/$PROJECT_DIR$\/make\" includeSubdirectories=\"true\" \/>\n-      <directory url=\"file:\/\/$PROJECT_DIR$\/test\" includeSubdirectories=\"false\" \/>\n+      <directory url=\"file:\/\/###PROJECT_DIR###\/src\" includeSubdirectories=\"true\" \/>\n+      <directory url=\"file:\/\/###PROJECT_DIR###\/build\" includeSubdirectories=\"true\" \/>\n+      <directory url=\"file:\/\/###PROJECT_DIR###\/make\" includeSubdirectories=\"true\" \/>\n+      <directory url=\"file:\/\/###PROJECT_DIR###\/test\" includeSubdirectories=\"false\" \/>\n","filename":"make\/ide\/idea\/jdk\/template\/compiler.xml","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -5,3 +5,3 @@\n-    <content url=\"file:\/\/$MODULE_DIR$\">\n-      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/build\" \/>\n-      <excludeFolder url=\"file:\/\/$MODULE_DIR$\/make\" \/>\n+    <content url=\"file:\/\/###MODULE_DIR###\">\n+      <excludeFolder url=\"file:\/\/###MODULE_DIR###\/build\" \/>\n+      <excludeFolder url=\"file:\/\/###MODULE_DIR###\/make\" \/>\n","filename":"make\/ide\/idea\/jdk\/template\/jdk.iml","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -8,2 +8,2 @@\n-    <workDir>$PROJECT_DIR$\/###BUILD_DIR###<\/workDir>\n-    <jre alt=\"true\" value=\"$PROJECT_DIR$\/###IMAGES_DIR###\" \/>\n+    <workDir>###BUILD_DIR###<\/workDir>\n+    <jre alt=\"true\" value=\"###BUILD_DIR###\/images\/jdk\" \/>\n@@ -11,3 +11,0 @@\n-    <ant>\n-      <target file=\"file:\/\/$PROJECT_DIR$\/make\/ide\/idea\/jdk\/build.xml\" name=\"images\" \/>\n-    <\/ant>\n@@ -16,1 +13,1 @@\n-    <output url=\"file:\/\/$PROJECT_DIR$\/###BUILD_DIR###\/idea\" \/>\n+    <output url=\"file:\/\/###BUILD_DIR###\/idea\" \/>\n","filename":"make\/ide\/idea\/jdk\/template\/misc.xml","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-    <content url=\"file:\/\/$MODULE_DIR$\/###MODULE_DIR###\">\n+    <content url=\"file:\/\/###MODULE_DIR###\/###MODULE_CONTENT###\">\n","filename":"make\/ide\/idea\/jdk\/template\/module.iml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-    <content url=\"file:\/\/$MODULE_DIR$\/test\/jdk\"><\/content>\n+    <content url=\"file:\/\/###MODULE_DIR###\/test\/jdk\"><\/content>\n","filename":"make\/ide\/idea\/jdk\/template\/test.iml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-    <mapping directory=\"$PROJECT_DIR$\" vcs=\"###VCS_TYPE###\" \/>\n+    <mapping directory=\"###PROJECT_DIR###\" vcs=\"###VCS_TYPE###\" \/>\n","filename":"make\/ide\/idea\/jdk\/template\/vcs.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-    <ignored path=\"$PROJECT_DIR$\/build\/idea\/out\/\" \/>\n+    <ignored path=\"###PROJECT_DIR###\/build\/idea\/out\/\" \/>\n@@ -18,1 +18,1 @@\n-      <option name=\"SCRIPT_WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" \/>\n+      <option name=\"SCRIPT_WORKING_DIRECTORY\" value=\"###PROJECT_DIR###\" \/>\n@@ -33,1 +33,1 @@\n-      <option name=\"SCRIPT_WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" \/>\n+      <option name=\"SCRIPT_WORKING_DIRECTORY\" value=\"###PROJECT_DIR###\" \/>\n@@ -48,1 +48,1 @@\n-      <option name=\"SCRIPT_WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" \/>\n+      <option name=\"SCRIPT_WORKING_DIRECTORY\" value=\"###PROJECT_DIR###\" \/>\n","filename":"make\/ide\/idea\/jdk\/template\/workspace.xml","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-    \/\/@Override \/\/ uncomment when JDK 15 is the boot JDK\n+    @Override\n@@ -166,1 +166,1 @@\n-                String url = String.format(\"%1$s\/%2$s-%3$s.html#jls-%3$s%4$s\",\n+                String url = String.format(\"%1$s\/%2$s-%3$s.html#%2$s-%3$s%4$s\",\n","filename":"make\/jdk\/src\/classes\/build\/tools\/taglet\/JSpec.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-\t$(CP) $(SCOPED_MEMORY_ACCESS_TEMPLATE) $(SCOPED_MEMORY_ACCESS_DEST)\n+\t$(CAT) $(SCOPED_MEMORY_ACCESS_TEMPLATE) > $(SCOPED_MEMORY_ACCESS_DEST)\n","filename":"make\/modules\/java.base\/gensrc\/GensrcScopedMemoryAccess.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1846,1 +1846,1 @@\n-instruct vcmeq8B(vecD dst, vecD src1, vecD src2, immI cond)\n+instruct vcmpD(vecD dst, vecD src1, vecD src2, immI cond)\n@@ -1848,3 +1848,1 @@\n-  predicate(n->as_Vector()->length() == 8 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::eq &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  predicate(n->as_Vector()->length_in_bytes() == 8);\n@@ -1852,1 +1850,1 @@\n-  format %{ \"cmeq  $dst, T8B, $src1, $src2\\t# vector cmp (8B)\" %}\n+  format %{ \"vcmpD  $dst, $src1, $src2\\t# vector compare \" %}\n@@ -1855,2 +1853,4 @@\n-    __ cmeq(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n+    BasicType bt = vector_element_basic_type(this);\n+    assert(type2aelembytes(bt) != 8, \"not supported\");\n+    __ neon_compare(as_FloatRegister($dst$$reg), bt, as_FloatRegister($src1$$reg),\n+                    as_FloatRegister($src2$$reg), (int)$cond$$constant, \/*isQ*\/ false);\n@@ -1861,1 +1861,1 @@\n-instruct vcmeq16B(vecX dst, vecX src1, vecX src2, immI cond)\n+instruct vcmpX(vecX dst, vecX src1, vecX src2, immI cond)\n@@ -1863,3 +1863,1 @@\n-  predicate(n->as_Vector()->length() == 16 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::eq &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  predicate(n->as_Vector()->length_in_bytes() == 16);\n@@ -1867,1 +1865,1 @@\n-  format %{ \"cmeq  $dst, T16B, $src1, $src2\\t# vector cmp (16B)\" %}\n+  format %{ \"vcmpX  $dst, $src1, $src2\\t# vector compare \" %}\n@@ -1870,892 +1868,3 @@\n-    __ cmeq(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmeq4S(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::eq &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmeq  $dst, T4H, $src1, $src2\\t# vector cmp (4S)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmeq(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vcmeq8S(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 8 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::eq &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmeq  $dst, T8H, $src1, $src2\\t# vector cmp (8S)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmeq(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmeq2I(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::eq &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmeq  $dst, T2S, $src1, $src2\\t# vector cmp (2I)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmeq(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vcmeq4I(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::eq &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmeq  $dst, T4S, $src1, $src2\\t# vector cmp (4I)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmeq(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmeq2L(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::eq &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmeq  $dst, T2D, $src1, $src2\\t# vector cmp (2L)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmeq(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmeq2F(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::eq &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"fcmeq  $dst, T2S, $src1, $src2\\t# vector cmp (2F)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ fcmeq(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vcmeq4F(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::eq &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"fcmeq  $dst, T4S, $src1, $src2\\t# vector cmp (4F)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ fcmeq(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmeq2D(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::eq &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"fcmeq  $dst, T2D, $src1, $src2\\t# vector cmp (2D)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ fcmeq(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmgt8B(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 8 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::gt &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmgt  $dst, T8B, $src1, $src2\\t# vector cmp (8B)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmgt(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vcmgt16B(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 16 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::gt &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmgt  $dst, T16B, $src1, $src2\\t# vector cmp (16B)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmgt(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmgt4S(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::gt &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmgt  $dst, T4H, $src1, $src2\\t# vector cmp (4S)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmgt(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vcmgt8S(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 8 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::gt &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmgt  $dst, T8H, $src1, $src2\\t# vector cmp (8S)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmgt(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmgt2I(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::gt &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmgt  $dst, T2S, $src1, $src2\\t# vector cmp (2I)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmgt(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vcmgt4I(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::gt &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmgt  $dst, T4S, $src1, $src2\\t# vector cmp (4I)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmgt(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmgt2L(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::gt &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmgt  $dst, T2D, $src1, $src2\\t# vector cmp (2L)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmgt(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmgt2F(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::gt &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"fcmgt  $dst, T2S, $src1, $src2\\t# vector cmp (2F)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ fcmgt(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vcmgt4F(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::gt &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"fcmgt  $dst, T4S, $src1, $src2\\t# vector cmp (4F)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ fcmgt(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmgt2D(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::gt &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"fcmgt  $dst, T2D, $src1, $src2\\t# vector cmp (2D)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ fcmgt(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmge8B(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 8 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::ge &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmge  $dst, T8B, $src1, $src2\\t# vector cmp (8B)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmge(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vcmge16B(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 16 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::ge &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmge  $dst, T16B, $src1, $src2\\t# vector cmp (16B)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmge(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmge4S(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::ge &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmge  $dst, T4H, $src1, $src2\\t# vector cmp (4S)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmge(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vcmge8S(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 8 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::ge &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmge  $dst, T8H, $src1, $src2\\t# vector cmp (8S)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmge(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmge2I(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::ge &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmge  $dst, T2S, $src1, $src2\\t# vector cmp (2I)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmge(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vcmge4I(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::ge &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmge  $dst, T4S, $src1, $src2\\t# vector cmp (4I)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmge(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmge2L(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::ge &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmge  $dst, T2D, $src1, $src2\\t# vector cmp (2L)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmge(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmge2F(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::ge &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"fcmge  $dst, T2S, $src1, $src2\\t# vector cmp (2F)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ fcmge(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vcmge4F(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::ge &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"fcmge  $dst, T4S, $src1, $src2\\t# vector cmp (4F)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ fcmge(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmge2D(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::ge &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"fcmge  $dst, T2D, $src1, $src2\\t# vector cmp (2D)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ fcmge(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmne8B(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 8 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::ne &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmeq  $dst, T8B, $src1, $src2\\n\\t# vector cmp (8B)\"\n-            \"not   $dst, T8B, $dst\\t\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmeq(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-    __ notr(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcmne16B(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 16 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::ne &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmeq  $dst, T16B, $src1, $src2\\n\\t# vector cmp (16B)\"\n-            \"not   $dst, T16B, $dst\\t\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmeq(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-    __ notr(as_FloatRegister($dst$$reg), __ T16B, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcmne4S(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::ne &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmeq  $dst, T4H, $src1, $src2\\n\\t# vector cmp (4S)\"\n-            \"not   $dst, T8B, $dst\\t\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmeq(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-    __ notr(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcmne8S(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 8 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::ne &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmeq  $dst, T8H, $src1, $src2\\n\\t# vector cmp (8S)\"\n-            \"not   $dst, T16B, $dst\\t\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmeq(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-    __ notr(as_FloatRegister($dst$$reg), __ T16B, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcmne2I(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::ne &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmeq  $dst, T2S, $src1, $src2\\n\\t# vector cmp (2I)\"\n-            \"not   $dst, T8B, $dst\\t\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmeq(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-    __ notr(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcmne4I(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::ne &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmeq  $dst, T4S, $src1, $src2\\n\\t# vector cmp (4I)\"\n-            \"not   $dst, T16B, $dst\\t\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmeq(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-    __ notr(as_FloatRegister($dst$$reg), __ T16B, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcmne2L(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::ne &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmeq  $dst, T2D, $src1, $src2\\n\\t# vector cmp (2L)\"\n-            \"not   $dst, T16B, $dst\\t\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmeq(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-    __ notr(as_FloatRegister($dst$$reg), __ T16B, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcmne2F(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::ne &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"fcmeq  $dst, T2S, $src1, $src2\\n\\t# vector cmp (2F)\"\n-            \"not   $dst, T8B, $dst\\t\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ fcmeq(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-    __ notr(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcmne4F(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::ne &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"fcmeq  $dst, T4S, $src1, $src2\\n\\t# vector cmp (4F)\"\n-            \"not   $dst, T16B, $dst\\t\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ fcmeq(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-    __ notr(as_FloatRegister($dst$$reg), __ T16B, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcmne2D(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::ne &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"fcmeq  $dst, T2D, $src1, $src2\\n\\t# vector cmp (2D)\"\n-            \"not   $dst, T16B, $dst\\t\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ fcmeq(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-    __ notr(as_FloatRegister($dst$$reg), __ T16B, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcmlt8B(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 8 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::lt &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmgt  $dst, T8B, $src2, $src1\\t# vector cmp (8B)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmgt(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vcmlt16B(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 16 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::lt &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmgt  $dst, T16B, $src2, $src1\\t# vector cmp (16B)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmgt(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmlt4S(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::lt &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmgt  $dst, T4H, $src2, $src1\\t# vector cmp (4S)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmgt(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vcmlt8S(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 8 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::lt &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmgt  $dst, T8H, $src2, $src1\\t# vector cmp (8S)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmgt(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmlt2I(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::lt &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmgt  $dst, T2S, $src2, $src1\\t# vector cmp (2I)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmgt(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vcmlt4I(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::lt &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmgt  $dst, T4S, $src2, $src1\\t# vector cmp (4I)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmgt(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmlt2L(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::lt &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmgt  $dst, T2D, $src2, $src1\\t# vector cmp (2L)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmgt(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmlt2F(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::lt &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"fcmgt  $dst, T2S, $src2, $src1\\t# vector cmp (2F)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ fcmgt(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vcmlt4F(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::lt &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"fcmgt  $dst, T4S, $src2, $src1\\t# vector cmp (4F)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ fcmgt(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmlt2D(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::lt &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"fcmgt  $dst, T2D, $src2, $src1\\t# vector cmp (2D)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ fcmgt(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmle8B(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 8 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::le &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmge  $dst, T8B, $src2, $src1\\t# vector cmp (8B)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmge(as_FloatRegister($dst$$reg), __ T8B,\n-            as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vcmle16B(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 16 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::le &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmge  $dst, T16B, $src2, $src1\\t# vector cmp (16B)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmge(as_FloatRegister($dst$$reg), __ T16B,\n-            as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmle4S(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::le &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmge  $dst, T4H, $src2, $src1\\t# vector cmp (4S)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmge(as_FloatRegister($dst$$reg), __ T4H,\n-            as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vcmle8S(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 8 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::le &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmge  $dst, T8H, $src2, $src1\\t# vector cmp (8S)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmge(as_FloatRegister($dst$$reg), __ T8H,\n-            as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmle2I(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::le &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmge  $dst, T2S, $src2, $src1\\t# vector cmp (2I)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmge(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vcmle4I(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::le &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmge  $dst, T4S, $src2, $src1\\t# vector cmp (4I)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmge(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmle2L(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::le &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"cmge  $dst, T2D, $src2, $src1\\t# vector cmp (2L)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ cmge(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmle2F(vecD dst, vecD src1, vecD src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::le &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"fcmge  $dst, T2S, $src2, $src1\\t# vector cmp (2F)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ fcmge(as_FloatRegister($dst$$reg), __ T2S,\n-            as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vdop64);\n-%}\n-\n-instruct vcmle4F(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 4 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::le &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"fcmge  $dst, T4S, $src2, $src1\\t# vector cmp (4F)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ fcmge(as_FloatRegister($dst$$reg), __ T4S,\n-            as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(vdop128);\n-%}\n-\n-instruct vcmle2D(vecX dst, vecX src1, vecX src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == 2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::le &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"fcmge  $dst, T2D, $src2, $src1\\t# vector cmp (2D)\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ fcmge(as_FloatRegister($dst$$reg), __ T2D,\n-            as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n+    BasicType bt = vector_element_basic_type(this);\n+    __ neon_compare(as_FloatRegister($dst$$reg), bt, as_FloatRegister($src1$$reg),\n+                    as_FloatRegister($src2$$reg), (int)$cond$$constant, \/*isQ*\/ true);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":13,"deletions":904,"binary":false,"changes":917,"status":"modified"},{"patch":"@@ -867,2 +867,2 @@\n-define(`VECTOR_CMP_EQ_GT_GE', `\n-instruct vcm$1$2$3`'(vec$4 dst, vec$4 src1, vec$4 src2, immI cond)\n+\n+instruct vcmpD(vecD dst, vecD src1, vecD src2, immI cond)\n@@ -870,3 +870,1 @@\n-  predicate(n->as_Vector()->length() == $2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::$1 &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($3));\n+  predicate(n->as_Vector()->length_in_bytes() == 8);\n@@ -874,1 +872,1 @@\n-  format %{ \"$6cm$1  $dst, T$2$5, $src1, $src2\\t# vector cmp ($2$3)\" %}\n+  format %{ \"vcmpD  $dst, $src1, $src2\\t# vector compare \" %}\n@@ -877,2 +875,4 @@\n-    __ $6cm$1(as_FloatRegister($dst$$reg), __ T$2$5,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n+    BasicType bt = vector_element_basic_type(this);\n+    assert(type2aelembytes(bt) != 8, \"not supported\");\n+    __ neon_compare(as_FloatRegister($dst$$reg), bt, as_FloatRegister($src1$$reg),\n+                    as_FloatRegister($src2$$reg), (int)$cond$$constant, \/*isQ*\/ false);\n@@ -880,69 +880,6 @@\n-  ins_pipe(vdop$7);\n-%}')dnl\n-dnl                $1   $2 $3 $4 $5 $6 $7\n-VECTOR_CMP_EQ_GT_GE(eq, 8, B, D, B,  , 64)\n-VECTOR_CMP_EQ_GT_GE(eq, 16,B, X, B,  , 128)\n-VECTOR_CMP_EQ_GT_GE(eq, 4, S, D, H,  , 64)\n-VECTOR_CMP_EQ_GT_GE(eq, 8, S, X, H,  , 128)\n-VECTOR_CMP_EQ_GT_GE(eq, 2, I, D, S,  , 64)\n-VECTOR_CMP_EQ_GT_GE(eq, 4, I, X, S,  , 128)\n-VECTOR_CMP_EQ_GT_GE(eq, 2, L, X, D,  , 128)\n-VECTOR_CMP_EQ_GT_GE(eq, 2, F, D, S, f, 64)\n-VECTOR_CMP_EQ_GT_GE(eq, 4, F, X, S, f, 128)\n-VECTOR_CMP_EQ_GT_GE(eq, 2, D, X, D, f, 128)\n-VECTOR_CMP_EQ_GT_GE(gt, 8, B, D, B,  , 64)\n-VECTOR_CMP_EQ_GT_GE(gt, 16,B, X, B,  , 128)\n-VECTOR_CMP_EQ_GT_GE(gt, 4, S, D, H,  , 64)\n-VECTOR_CMP_EQ_GT_GE(gt, 8, S, X, H,  , 128)\n-VECTOR_CMP_EQ_GT_GE(gt, 2, I, D, S,  , 64)\n-VECTOR_CMP_EQ_GT_GE(gt, 4, I, X, S,  , 128)\n-VECTOR_CMP_EQ_GT_GE(gt, 2, L, X, D,  , 128)\n-VECTOR_CMP_EQ_GT_GE(gt, 2, F, D, S, f, 64)\n-VECTOR_CMP_EQ_GT_GE(gt, 4, F, X, S, f, 128)\n-VECTOR_CMP_EQ_GT_GE(gt, 2, D, X, D, f, 128)\n-VECTOR_CMP_EQ_GT_GE(ge, 8, B, D, B,  , 64)\n-VECTOR_CMP_EQ_GT_GE(ge, 16,B, X, B,  , 128)\n-VECTOR_CMP_EQ_GT_GE(ge, 4, S, D, H,  , 64)\n-VECTOR_CMP_EQ_GT_GE(ge, 8, S, X, H,  , 128)\n-VECTOR_CMP_EQ_GT_GE(ge, 2, I, D, S,  , 64)\n-VECTOR_CMP_EQ_GT_GE(ge, 4, I, X, S,  , 128)\n-VECTOR_CMP_EQ_GT_GE(ge, 2, L, X, D,  , 128)\n-VECTOR_CMP_EQ_GT_GE(ge, 2, F, D, S, f, 64)\n-VECTOR_CMP_EQ_GT_GE(ge, 4, F, X, S, f, 128)\n-VECTOR_CMP_EQ_GT_GE(ge, 2, D, X, D, f, 128)\n-dnl\n-define(`VECTOR_CMP_NE', `\n-instruct vcmne$1$2`'(vec$3 dst, vec$3 src1, vec$3 src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == $1 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::ne &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n-  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n-  format %{ \"$5cmeq  $dst, T$1$4, $src1, $src2\\n\\t# vector cmp ($1$2)\"\n-            \"not   $dst, T$6, $dst\\t\" %}\n-  ins_cost(INSN_COST);\n-  ins_encode %{\n-    __ $5cmeq(as_FloatRegister($dst$$reg), __ T$1$4,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-    __ notr(as_FloatRegister($dst$$reg), __ T$6, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl           $1 $2 $3 $4 $5 $6\n-VECTOR_CMP_NE(8, B, D, B,  , 8B)\n-VECTOR_CMP_NE(16,B, X, B,  , 16B)\n-VECTOR_CMP_NE(4, S, D, H,  , 8B)\n-VECTOR_CMP_NE(8, S, X, H,  , 16B)\n-VECTOR_CMP_NE(2, I, D, S,  , 8B)\n-VECTOR_CMP_NE(4, I, X, S,  , 16B)\n-VECTOR_CMP_NE(2, L, X, D,  , 16B)\n-VECTOR_CMP_NE(2, F, D, S, f, 8B)\n-VECTOR_CMP_NE(4, F, X, S, f, 16B)\n-VECTOR_CMP_NE(2, D, X, D, f, 16B)\n-dnl\n-define(`VECTOR_CMP_LT_LE', `\n-instruct vcm$1$2$3`'(vec$4 dst, vec$4 src1, vec$4 src2, immI cond)\n-%{\n-  predicate(n->as_Vector()->length() == $2 &&\n-            n->as_VectorMaskCmp()->get_predicate() == BoolTest::$1 &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($3));\n+  ins_pipe(vdop64);\n+%}\n+\n+instruct vcmpX(vecX dst, vecX src1, vecX src2, immI cond)\n+%{\n+  predicate(n->as_Vector()->length_in_bytes() == 16);\n@@ -950,1 +887,1 @@\n-  format %{ \"$6cm$7  $dst, T$2$5, $src2, $src1\\t# vector cmp ($2$3)\" %}\n+  format %{ \"vcmpX  $dst, $src1, $src2\\t# vector compare \" %}\n@@ -953,2 +890,3 @@\n-    __ $6cm$7(as_FloatRegister($dst$$reg), __ T$2$5,\n-            as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));\n+    BasicType bt = vector_element_basic_type(this);\n+    __ neon_compare(as_FloatRegister($dst$$reg), bt, as_FloatRegister($src1$$reg),\n+                    as_FloatRegister($src2$$reg), (int)$cond$$constant, \/*isQ*\/ true);\n@@ -956,24 +894,2 @@\n-  ins_pipe(vdop$8);\n-%}')dnl\n-dnl              $1  $2 $3 $4 $5 $6 $7  $8\n-VECTOR_CMP_LT_LE(lt, 8, B, D, B,  , gt, 64)\n-VECTOR_CMP_LT_LE(lt, 16,B, X, B,  , gt, 128)\n-VECTOR_CMP_LT_LE(lt, 4, S, D, H,  , gt, 64)\n-VECTOR_CMP_LT_LE(lt, 8, S, X, H,  , gt, 128)\n-VECTOR_CMP_LT_LE(lt, 2, I, D, S,  , gt, 64)\n-VECTOR_CMP_LT_LE(lt, 4, I, X, S,  , gt, 128)\n-VECTOR_CMP_LT_LE(lt, 2, L, X, D,  , gt, 128)\n-VECTOR_CMP_LT_LE(lt, 2, F, D, S, f, gt, 64)\n-VECTOR_CMP_LT_LE(lt, 4, F, X, S, f, gt, 128)\n-VECTOR_CMP_LT_LE(lt, 2, D, X, D, f, gt, 128)\n-VECTOR_CMP_LT_LE(le, 8, B, D, B,  , ge, 64)\n-VECTOR_CMP_LT_LE(le, 16,B, X, B,  , ge, 128)\n-VECTOR_CMP_LT_LE(le, 4, S, D, H,  , ge, 64)\n-VECTOR_CMP_LT_LE(le, 8, S, X, H,  , ge, 128)\n-VECTOR_CMP_LT_LE(le, 2, I, D, S,  , ge, 64)\n-VECTOR_CMP_LT_LE(le, 4, I, X, S,  , ge, 128)\n-VECTOR_CMP_LT_LE(le, 2, L, X, D,  , ge, 128)\n-VECTOR_CMP_LT_LE(le, 2, F, D, S, f, ge, 64)\n-VECTOR_CMP_LT_LE(le, 4, F, X, S, f, ge, 128)\n-VECTOR_CMP_LT_LE(le, 2, D, X, D, f, ge, 128)\n-dnl\n+  ins_pipe(vdop128);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":20,"deletions":104,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,19 @@\n+Assembler::SIMD_Arrangement Assembler::_esize2arrangement_table[9][2] = {\n+  \/\/ esize        isQ:false             isQ:true\n+  \/*   0  *\/      {INVALID_ARRANGEMENT, INVALID_ARRANGEMENT},\n+  \/*   1  *\/      {T8B,                 T16B},\n+  \/*   2  *\/      {T4H,                 T8H},\n+  \/*   3  *\/      {INVALID_ARRANGEMENT, INVALID_ARRANGEMENT},\n+  \/*   4  *\/      {T2S,                 T4S},\n+  \/*   5  *\/      {INVALID_ARRANGEMENT, INVALID_ARRANGEMENT},\n+  \/*   6  *\/      {INVALID_ARRANGEMENT, INVALID_ARRANGEMENT},\n+  \/*   7  *\/      {INVALID_ARRANGEMENT, INVALID_ARRANGEMENT},\n+  \/*   8  *\/      {T1D,                 T2D}\n+  };\n+\n+\n+Assembler::SIMD_Arrangement Assembler::esize2arrangement(int esize, bool isQ) {\n+    guarantee(esize == 1 || esize == 2 || esize == 4 || esize == 8, \"unsupported element size\");\n+    return _esize2arrangement_table[esize][isQ];\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1533,1 +1533,1 @@\n-    T8B, T16B, T4H, T8H, T2S, T4S, T1D, T2D, T1Q\n+    T8B, T16B, T4H, T8H, T2S, T4S, T1D, T2D, T1Q, INVALID_ARRANGEMENT\n@@ -1536,0 +1536,8 @@\n+private:\n+\n+  static SIMD_Arrangement _esize2arrangement_table[9][2];\n+\n+public:\n+\n+  static SIMD_Arrangement esize2arrangement(int esize, bool isQ);\n+\n@@ -2413,0 +2421,1 @@\n+  INSN(cmhs,   1, 0b001111, true);  \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -275,0 +275,3 @@\n+\n+  \/\/ Only generated code frames should be patched, therefore the return address will not be signed.\n+  assert(pauth_ptr_is_raw(*pc_addr), \"cannot be signed\");\n@@ -454,1 +457,3 @@\n-  return frame(sender_sp, unextended_sp, link(), sender_pc());\n+  \/\/ Use the raw version of pc - the interpreter should not have signed it.\n+\n+  return frame(sender_sp, unextended_sp, link(), sender_pc_maybe_signed());\n@@ -517,0 +522,1 @@\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,0 +152,1 @@\n+  inline address  sender_pc_maybe_signed() const;\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"pauth_aarch64.hpp\"\n@@ -48,0 +49,1 @@\n+  assert(pauth_ptr_is_raw(pc), \"cannot be signed\");\n@@ -72,0 +74,1 @@\n+  assert(pauth_ptr_is_raw(pc), \"cannot be signed\");\n@@ -153,2 +156,3 @@\n-inline address* frame::sender_pc_addr()      const { return (address*) addr_at( return_addr_offset); }\n-inline address  frame::sender_pc()           const { return *sender_pc_addr(); }\n+inline address* frame::sender_pc_addr()         const { return (address*) addr_at( return_addr_offset); }\n+inline address  frame::sender_pc_maybe_signed() const { return *sender_pc_addr(); }\n+inline address  frame::sender_pc()              const { return pauth_strip_pointer(sender_pc_maybe_signed()); }\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -5342,0 +5342,43 @@\n+void MacroAssembler::neon_compare(FloatRegister dst, BasicType bt, FloatRegister src1,\n+                                  FloatRegister src2, int cond, bool isQ) {\n+  SIMD_Arrangement size = esize2arrangement(type2aelembytes(bt), isQ);\n+  if (bt == T_FLOAT || bt == T_DOUBLE) {\n+    switch (cond) {\n+      case BoolTest::eq: fcmeq(dst, size, src1, src2); break;\n+      case BoolTest::ne: {\n+        fcmeq(dst, size, src1, src2);\n+        notr(dst, T16B, dst);\n+        break;\n+      }\n+      case BoolTest::ge: fcmge(dst, size, src1, src2); break;\n+      case BoolTest::gt: fcmgt(dst, size, src1, src2); break;\n+      case BoolTest::le: fcmge(dst, size, src2, src1); break;\n+      case BoolTest::lt: fcmgt(dst, size, src2, src1); break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  } else {\n+    switch (cond) {\n+      case BoolTest::eq: cmeq(dst, size, src1, src2); break;\n+      case BoolTest::ne: {\n+        cmeq(dst, size, src1, src2);\n+        notr(dst, T16B, dst);\n+        break;\n+      }\n+      case BoolTest::ge: cmge(dst, size, src1, src2); break;\n+      case BoolTest::gt: cmgt(dst, size, src1, src2); break;\n+      case BoolTest::le: cmge(dst, size, src2, src1); break;\n+      case BoolTest::lt: cmgt(dst, size, src2, src1); break;\n+      case BoolTest::uge: cmhs(dst, size, src1, src2); break;\n+      case BoolTest::ugt: cmhi(dst, size, src1, src2); break;\n+      case BoolTest::ult: cmhi(dst, size, src2, src1); break;\n+      case BoolTest::ule: cmhs(dst, size, src2, src1); break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  }\n+}\n+\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -1060,0 +1060,3 @@\n+\n+  \/\/ SIMD&FP comparison\n+  void neon_compare(FloatRegister dst, BasicType bt, FloatRegister src1, FloatRegister src2, int cond, bool isQ);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -142,2 +142,3 @@\n-  static constexpr bool supports_vector_comparison_unsigned(int vlen, BasicType bt) {\n-    return false;\n+  static const bool supports_vector_comparison_unsigned(int vlen, BasicType bt) {\n+    \/\/ Not supported on SVE yet.\n+    return !UseSVE;\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_AARCH64_PAUTH_AARCH64_INLINE_HPP\n+#define CPU_AARCH64_PAUTH_AARCH64_INLINE_HPP\n+\n+#include OS_CPU_HEADER_INLINE(pauth)\n+\n+inline bool pauth_ptr_is_raw(address ptr) {\n+  \/\/ Confirm none of the high bits are set in the pointer.\n+  return ptr == pauth_strip_pointer(ptr);\n+}\n+\n+#endif \/\/ CPU_AARCH64_PAUTH_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/aarch64\/pauth_aarch64.hpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -980,1 +980,1 @@\n-  bool ret_value = match_rule_supported(opcode);\n+  bool ret_value = match_rule_supported(opcode) && vector_size_supported(bt, vlen);\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2575,0 +2575,7 @@\n+void Assembler::knotql(KRegister dst, KRegister src) {\n+  assert(VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x44, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1483,0 +1483,1 @@\n+  void knotql(KRegister dst, KRegister src);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1926,1 +1926,1 @@\n-  assert(ArrayCopyPartialInlineSize <= 64,\"\");\n+  assert(ArrayOperationPartialInlineSize > 0 && ArrayOperationPartialInlineSize <= 64, \"invalid\");\n@@ -2143,0 +2143,24 @@\n+void C2_MacroAssembler::evpcmp(BasicType typ, KRegister kdmask, KRegister ksmask, XMMRegister src1, XMMRegister src2, int comparison, int vector_len) {\n+  switch(typ) {\n+    case T_BYTE:\n+    case T_BOOLEAN:\n+      evpcmpb(kdmask, ksmask, src1, src2, comparison, \/*signed*\/ true, vector_len);\n+      break;\n+    case T_SHORT:\n+    case T_CHAR:\n+      evpcmpw(kdmask, ksmask, src1, src2, comparison, \/*signed*\/ true, vector_len);\n+      break;\n+    case T_INT:\n+    case T_FLOAT:\n+      evpcmpd(kdmask, ksmask, src1, src2, comparison, \/*signed*\/ true, vector_len);\n+      break;\n+    case T_LONG:\n+    case T_DOUBLE:\n+      evpcmpq(kdmask, ksmask, src1, src2, comparison, \/*signed*\/ true, vector_len);\n+      break;\n+    default:\n+      assert(false,\"Should not reach here.\");\n+      break;\n+  }\n+}\n+\n@@ -2145,0 +2169,1 @@\n+    case T_BOOLEAN:\n@@ -2148,0 +2173,1 @@\n+    case T_CHAR:\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+  void evpcmp(BasicType typ, KRegister kdmask, KRegister ksmask, XMMRegister src1, XMMRegister src2, int comparison, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1422,6 +1422,6 @@\n-      if (FLAG_IS_DEFAULT(ArrayCopyPartialInlineSize) ||\n-          (!FLAG_IS_DEFAULT(ArrayCopyPartialInlineSize) &&\n-           ArrayCopyPartialInlineSize != 0 &&\n-           ArrayCopyPartialInlineSize != 32 &&\n-           ArrayCopyPartialInlineSize != 16 &&\n-           ArrayCopyPartialInlineSize != 64)) {\n+      if (FLAG_IS_DEFAULT(ArrayOperationPartialInlineSize) ||\n+          (!FLAG_IS_DEFAULT(ArrayOperationPartialInlineSize) &&\n+           ArrayOperationPartialInlineSize != 0 &&\n+           ArrayOperationPartialInlineSize != 16 &&\n+           ArrayOperationPartialInlineSize != 32 &&\n+           ArrayOperationPartialInlineSize != 64)) {\n@@ -1436,2 +1436,2 @@\n-        if(!FLAG_IS_DEFAULT(ArrayCopyPartialInlineSize)) {\n-          warning(\"Setting ArrayCopyPartialInlineSize as %d\", inline_size);\n+        if(!FLAG_IS_DEFAULT(ArrayOperationPartialInlineSize)) {\n+          warning(\"Setting ArrayOperationPartialInlineSize as %d\", inline_size);\n@@ -1439,1 +1439,1 @@\n-        ArrayCopyPartialInlineSize = inline_size;\n+        ArrayOperationPartialInlineSize = inline_size;\n@@ -1442,4 +1442,4 @@\n-      if (ArrayCopyPartialInlineSize > MaxVectorSize) {\n-        ArrayCopyPartialInlineSize = MaxVectorSize >= 16 ? MaxVectorSize : 0;\n-        if (ArrayCopyPartialInlineSize) {\n-          warning(\"Setting ArrayCopyPartialInlineSize as MaxVectorSize\" INTX_FORMAT \")\", MaxVectorSize);\n+      if (ArrayOperationPartialInlineSize > MaxVectorSize) {\n+        ArrayOperationPartialInlineSize = MaxVectorSize >= 16 ? MaxVectorSize : 0;\n+        if (ArrayOperationPartialInlineSize) {\n+          warning(\"Setting ArrayOperationPartialInlineSize as MaxVectorSize\" INTX_FORMAT \")\", MaxVectorSize);\n@@ -1447,1 +1447,1 @@\n-          warning(\"Setting ArrayCopyPartialInlineSize as \" INTX_FORMAT, ArrayCopyPartialInlineSize);\n+          warning(\"Setting ArrayOperationPartialInlineSize as \" INTX_FORMAT, ArrayOperationPartialInlineSize);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1581,0 +1581,1 @@\n+    case Op_VectorCmpMasked:\n@@ -1681,0 +1682,1 @@\n+    case Op_VectorCmpMasked:\n@@ -8087,1 +8089,28 @@\n-\/\/ ---------------------------------- Masked Block Copy ------------------------------------\n+\/\/ ---------------------------------- Masked Operations ------------------------------------\n+\n+instruct vmask_cmp_node(rRegI dst, vec src1, vec src2, kReg mask, kReg ktmp1, kReg ktmp2, rFlagsReg cr) %{\n+  match(Set dst (VectorCmpMasked src1 (Binary src2 mask)));\n+  effect(TEMP_DEF dst, TEMP ktmp1, TEMP ktmp2, KILL cr);\n+  format %{ \"vector_mask_cmp $src1, $src2, $mask \\t! vector mask comparison\" %}\n+  ins_encode %{\n+    assert(vector_length_encoding(this, $src1) == vector_length_encoding(this, $src2), \"mismatch\");\n+    assert(vector_element_basic_type(this, $src1) == vector_element_basic_type(this, $src2), \"mismatch\");\n+\n+    Label DONE;\n+    int vlen_enc = vector_length_encoding(this, $src1);\n+    BasicType elem_bt = vector_element_basic_type(this, $src1);\n+\n+    __ knotql($ktmp2$$KRegister, $mask$$KRegister);\n+    __ mov64($dst$$Register, -1L);\n+    __ evpcmp(elem_bt, $ktmp1$$KRegister, $mask$$KRegister, $src1$$XMMRegister, $src2$$XMMRegister, Assembler::eq, vlen_enc);\n+    __ kortestql($ktmp2$$KRegister, $ktmp1$$KRegister);\n+    __ jccb(Assembler::carrySet, DONE);\n+    __ kmovql($dst$$Register, $ktmp1$$KRegister);\n+    __ notq($dst$$Register);\n+    __ tzcntq($dst$$Register, $dst$$Register);\n+    __ bind(DONE);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -555,3 +555,0 @@\n-  log_info(os, thread)(\"Thread is alive (tid: \" UINTX_FORMAT \", pthread id: \" UINTX_FORMAT \").\",\n-    os::current_thread_id(), (uintx) pthread_self());\n-\n@@ -590,0 +587,3 @@\n+  log_info(os, thread)(\"Thread is alive (tid: \" UINTX_FORMAT \", pthread id: \" UINTX_FORMAT \").\",\n+    os::current_thread_id(), (uintx) pthread_self());\n+\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -675,1 +675,2 @@\n-  void *stackmem = alloca(((pid ^ counter++) & 7) * 128);\n+  int random = ((pid ^ counter++) & 7) * 128;\n+  void *stackmem = alloca(random != 0 ? random : 1); \/\/ ensure we allocate > 0\n@@ -687,3 +688,0 @@\n-  log_info(os, thread)(\"Thread is alive (tid: \" UINTX_FORMAT \", pthread id: \" UINTX_FORMAT \").\",\n-    os::current_thread_id(), (uintx) pthread_self());\n-\n@@ -716,0 +714,3 @@\n+  log_info(os, thread)(\"Thread is alive (tid: \" UINTX_FORMAT \", pthread id: \" UINTX_FORMAT \").\",\n+    os::current_thread_id(), (uintx) pthread_self());\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -388,1 +388,0 @@\n-    struct bitmask* bmp = NULL;\n@@ -392,2 +391,1 @@\n-    if (_numa_get_membind != NULL && _numa_max_node != NULL && _numa_bitmask_isbitset != NULL) {\n-      bmp = _numa_get_membind();\n+    if (_numa_membind_bitmask != NULL && _numa_max_node != NULL && _numa_bitmask_isbitset != NULL) {\n@@ -400,1 +398,1 @@\n-      if (_numa_bitmask_isbitset(bmp, node)) {\n+      if (_numa_bitmask_isbitset(_numa_membind_bitmask, node)) {\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2381,1 +2381,1 @@\n-    jint fp_control_word = (* (jint*) StubRoutines::addr_fpu_cntrl_wrd_std());\n+    jint fp_control_word = (* (jint*) StubRoutines::x86::addr_fpu_cntrl_wrd_std());\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_LINUX_AARCH64_PAUTH_BSD_AARCH64_INLINE_HPP\n+#define OS_CPU_LINUX_AARCH64_PAUTH_BSD_AARCH64_INLINE_HPP\n+\n+#ifdef __APPLE__\n+#include <ptrauth.h>\n+#endif\n+\n+\/\/ Only the PAC instructions in the NOP space can be used. This ensures the\n+\/\/ binaries work on systems without PAC. Write these instructions using their\n+\/\/ alternate \"hint\" instructions to ensure older compilers can still be used.\n+\/\/ For Apple, use the provided interface as this may provide additional\n+\/\/ optimization.\n+\n+#define XPACLRI \"hint #0x7;\"\n+\n+inline address pauth_strip_pointer(address ptr) {\n+#ifdef __APPLE__\n+  return ptrauth_strip(ptr, ptrauth_key_asib);\n+#else\n+  register address result __asm__(\"x30\") = ptr;\n+  asm (XPACLRI : \"+r\"(result));\n+  return result;\n+#endif\n+}\n+\n+#undef XPACLRI\n+\n+#endif \/\/ OS_CPU_LINUX_AARCH64_PAUTH_BSD_AARCH64_INLINE_HPP\n+\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/pauth_bsd_aarch64.inline.hpp","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_LINUX_AARCH64_PAUTH_LINUX_AARCH64_INLINE_HPP\n+#define OS_CPU_LINUX_AARCH64_PAUTH_LINUX_AARCH64_INLINE_HPP\n+\n+\/\/ Only the PAC instructions in the NOP space can be used. This ensures the\n+\/\/ binaries work on systems without PAC. Write these instructions using their\n+\/\/ alternate \"hint\" instructions to ensure older compilers can still be used.\n+\n+#define XPACLRI \"hint #0x7;\"\n+\n+inline address pauth_strip_pointer(address ptr) {\n+  register address result __asm__(\"x30\") = ptr;\n+  asm (XPACLRI : \"+r\"(result));\n+  return result;\n+}\n+\n+#undef XPACLRI\n+\n+#endif \/\/ OS_CPU_LINUX_AARCH64_PAUTH_LINUX_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/pauth_linux_aarch64.inline.hpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_LINUX_AARCH64_PAUTH_WINDOWS_AARCH64_INLINE_HPP\n+#define OS_CPU_LINUX_AARCH64_PAUTH_WINDOWS_AARCH64_INLINE_HPP\n+\n+inline address pauth_strip_pointer(address ptr) {\n+  \/\/ No PAC support in windows as of yet.\n+  return ptr;\n+}\n+\n+#endif \/\/ OS_CPU_LINUX_AARCH64_PAUTH_WINDOWS_AARCH64_INLINE_HPP\n+\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/pauth_windows_aarch64.inline.hpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -536,1 +536,1 @@\n-  int fpu_cntrl_word = StubRoutines::fpu_cntrl_wrd_std();\n+  int fpu_cntrl_word = StubRoutines::x86::fpu_cntrl_wrd_std();\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/os_windows_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -792,0 +792,1 @@\n+       !strcmp(_matrule->_rChild->_opType,\"VectorCmpMasked\")||\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3050,1 +3050,3 @@\n-  \/\/ can increment the interpreter_invocation_count.\n+  \/\/ can increment the the counters.\n+  \/\/ In addition, with range check elimination, we may need a valid block\n+  \/\/ that dominates all the rest to insert range predicates.\n@@ -3052,1 +3054,1 @@\n-  if (std_entry->number_of_preds() > 0 || count_invocations() || count_backedges()) {\n+  if (std_entry->number_of_preds() > 0 || count_invocations() || count_backedges() || RangeCheckElimination) {\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -112,0 +112,1 @@\n+    MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"classfile\/classLoader.hpp\"\n@@ -243,0 +244,1 @@\n+  _has_non_jar_in_classpath = ClassLoaderExt::has_non_jar_in_classpath();\n@@ -296,0 +298,1 @@\n+  st->print_cr(\"- has_non_jar_in_classpath:       %d\", _has_non_jar_in_classpath);\n@@ -720,1 +723,1 @@\n-\n+  JavaThread* current = JavaThread::current();\n@@ -722,0 +725,1 @@\n+  bool non_jar_in_cp = header()->has_non_jar_in_classpath();\n@@ -724,3 +728,14 @@\n-    struct stat st;\n-    if (os::stat(path, &st) == 0) {\n-      path_array->append(path);\n+    if (!non_jar_in_cp) {\n+      struct stat st;\n+      if (os::stat(path, &st) == 0) {\n+        path_array->append(path);\n+      }\n+    } else {\n+      const char* canonical_path = ClassLoader::get_canonical_path(path, current);\n+      if (canonical_path != NULL) {\n+        char* error_msg = NULL;\n+        jzfile* zip = ClassLoader::open_zip_file(canonical_path, &error_msg, current);\n+        if (zip != NULL && error_msg == NULL) {\n+          path_array->append(path);\n+        }\n+      }\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -206,0 +206,1 @@\n+  bool _has_non_jar_in_classpath;   \/\/ non-jar file entry exists in classpath\n@@ -275,0 +276,1 @@\n+  bool has_non_jar_in_classpath()          const { return _has_non_jar_in_classpath; }\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -492,0 +492,1 @@\n+  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -140,0 +140,2 @@\n+#define JAVA_18_VERSION                   62\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -739,0 +739,3 @@\n+#if INCLUDE_CDS\n+      ClassLoaderExt::set_has_non_jar_in_classpath();\n+#endif\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -257,1 +257,0 @@\n-  static jzfile* open_zip_file(const char* canonical_path, char** error_msg, JavaThread* thread);\n@@ -260,0 +259,1 @@\n+  static jzfile* open_zip_file(const char* canonical_path, char** error_msg, JavaThread* thread);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -697,6 +697,11 @@\n-  \/\/ Clear all the JNI handles for methods\n-  \/\/ These aren't deallocated and are going to look like a leak, but that's\n-  \/\/ needed because we can't really get rid of jmethodIDs because we don't\n-  \/\/ know when native code is going to stop using them.  The spec says that\n-  \/\/ they're \"invalid\" but existing programs likely rely on their being\n-  \/\/ NULL after class unloading.\n+  \/\/ Method::clear_jmethod_ids only sets the jmethod_ids to NULL without\n+  \/\/ releasing the memory for related JNIMethodBlocks and JNIMethodBlockNodes.\n+  \/\/ This is done intentionally because native code (e.g. JVMTI agent) holding\n+  \/\/ jmethod_ids may access them after the associated classes and class loader\n+  \/\/ are unloaded. The Java Native Interface Specification says \"method ID\n+  \/\/ does not prevent the VM from unloading the class from which the ID has\n+  \/\/ been derived. After the class is unloaded, the method or field ID becomes\n+  \/\/ invalid\". In real world usages, the native code may rely on jmethod_ids\n+  \/\/ being NULL after class unloading. Hence, it is unsafe to free the memory\n+  \/\/ from the VM side without knowing when native code is going to stop using\n+  \/\/ them.\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+bool ClassLoaderExt::_has_non_jar_in_classpath = false;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+  static bool _has_non_jar_in_classpath;\n@@ -110,0 +111,4 @@\n+  static bool has_non_jar_in_classpath() {\n+    return _has_non_jar_in_classpath;\n+  }\n+\n@@ -118,1 +123,4 @@\n-#endif\n+  static void set_has_non_jar_in_classpath() {\n+    _has_non_jar_in_classpath = true;\n+  }\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -959,13 +959,0 @@\n-\/\/ Load a class for boot loader from the shared spaces. This also\n-\/\/ forces the superclass and all interfaces to be loaded.\n-InstanceKlass* SystemDictionary::load_shared_boot_class(Symbol* class_name,\n-                                                        PackageEntry* pkg_entry,\n-                                                        TRAPS) {\n-  assert(UseSharedSpaces, \"Sanity check\");\n-  InstanceKlass* ik = SystemDictionaryShared::find_builtin_class(class_name);\n-  if (ik != NULL && ik->is_shared_boot_class()) {\n-    return load_shared_class(ik, Handle(), Handle(), NULL, pkg_entry, THREAD);\n-  }\n-  return NULL;\n-}\n-\n@@ -1292,1 +1279,5 @@\n-      k = load_shared_boot_class(class_name, pkg_entry, THREAD);\n+      InstanceKlass* ik = SystemDictionaryShared::find_builtin_class(class_name);\n+      if (ik != NULL && ik->is_shared_boot_class() && !ik->shared_loading_failed()) {\n+        SharedClassLoadingMark slm(THREAD, ik);\n+        k = load_shared_class(ik, class_loader, Handle(), NULL,  pkg_entry, CHECK_NULL);\n+      }\n@@ -1304,0 +1295,1 @@\n+      CDS_ONLY(SharedClassLoadingMark slm(THREAD, k);)\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -379,3 +379,0 @@\n-  static InstanceKlass* load_shared_boot_class(Symbol* class_name,\n-                                               PackageEntry* pkg_entry,\n-                                               TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -355,0 +355,2 @@\n+\n+  InstanceKlass* caller_ik() const { return _caller_ik; }\n@@ -430,1 +432,1 @@\n-  assert(DumpTimeTable_lock->owned_by_self(), \"sanity\");\n+  assert_lock_strong(DumpTimeTable_lock);\n@@ -1019,0 +1021,1 @@\n+        SharedClassLoadingMark slm(THREAD, k);\n@@ -1048,5 +1051,4 @@\n-  if (ik != NULL) {\n-    if ((ik->is_shared_app_class() &&\n-         SystemDictionary::is_system_class_loader(class_loader()))  ||\n-        (ik->is_shared_platform_class() &&\n-         SystemDictionary::is_platform_class_loader(class_loader()))) {\n+  if (ik != NULL && !ik->shared_loading_failed()) {\n+    if ((SystemDictionary::is_system_class_loader(class_loader()) && ik->is_shared_app_class())  ||\n+        (SystemDictionary::is_platform_class_loader(class_loader()) && ik->is_shared_platform_class())) {\n+      SharedClassLoadingMark slm(THREAD, ik);\n@@ -1237,0 +1239,5 @@\n+  return find_or_allocate_info_for_locked(k);\n+}\n+\n+DumpTimeSharedClassInfo* SystemDictionaryShared::find_or_allocate_info_for_locked(InstanceKlass* k) {\n+  assert_lock_strong(DumpTimeTable_lock);\n@@ -1470,0 +1477,1 @@\n+  assert_lock_strong(DumpTimeTable_lock);\n@@ -1471,1 +1479,1 @@\n-  DumpTimeSharedClassInfo* p = find_or_allocate_info_for(k);\n+  DumpTimeSharedClassInfo* p = find_or_allocate_info_for_locked(k);\n@@ -1508,1 +1516,2 @@\n-    if (!info.is_excluded()) {\n+    assert_lock_strong(DumpTimeTable_lock);\n+    if (k->is_loader_alive() && !info.is_excluded()) {\n@@ -1521,3 +1530,6 @@\n-    info.metaspace_pointers_do(_it);\n-    key.metaspace_pointers_do(_it);\n-    return true;\n+    assert_lock_strong(DumpTimeTable_lock);\n+    if (key.caller_ik()->is_loader_alive()) {\n+      info.metaspace_pointers_do(_it);\n+      key.metaspace_pointers_do(_it);\n+    }\n+    return true; \/\/ keep on iterating\n@@ -1528,1 +1540,1 @@\n-  assert_locked_or_safepoint(DumpTimeTable_lock);\n+  assert_lock_strong(DumpTimeTable_lock);\n@@ -2157,1 +2169,1 @@\n-  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n+  assert_lock_strong(DumpTimeTable_lock);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":25,"deletions":13,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -115,0 +115,17 @@\n+class SharedClassLoadingMark {\n+ private:\n+  Thread* THREAD;\n+  InstanceKlass* _klass;\n+ public:\n+  SharedClassLoadingMark(Thread* current, InstanceKlass* ik) : THREAD(current), _klass(ik) {}\n+  ~SharedClassLoadingMark() {\n+    assert(THREAD != NULL, \"Current thread is NULL\");\n+    assert(_klass != NULL, \"InstanceKlass is NULL\");\n+    if (HAS_PENDING_EXCEPTION) {\n+      if (_klass->is_shared()) {\n+        _klass->set_shared_loading_failed();\n+      }\n+    }\n+  }\n+};\n+\n@@ -210,0 +227,1 @@\n+  static DumpTimeSharedClassInfo* find_or_allocate_info_for_locked(InstanceKlass* k);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -518,1 +518,1 @@\n-  if (method_code != NULL && method_code->is_in_use()) {\n+  if (method_code != NULL && method_code->is_in_use() && !method_code->is_unloading()) {\n@@ -644,1 +644,1 @@\n-  if (m_code != NULL && m_code->is_in_use()) {\n+  if (m_code != NULL && m_code->is_in_use() && !m_code->is_unloading()) {\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -758,0 +758,11 @@\n+void* Disassembler::dll_load(char* buf, int buflen, int offset, char* ebuf, int ebuflen, outputStream* st) {\n+  int sz = buflen - offset;\n+  int written = jio_snprintf(&buf[offset], sz, \"%s%s\", hsdis_library_name, os::dll_file_extension());\n+  if (written < sz) { \/\/ written successfully, not truncated.\n+    if (Verbose) st->print_cr(\"Trying to load: %s\", buf);\n+    return os::dll_load(buf, ebuf, ebuflen);\n+  } else if (Verbose) {\n+    st->print_cr(\"Try to load hsdis library failed: the length of path is beyond the OS limit\");\n+  }\n+  return NULL;\n+}\n@@ -807,8 +818,1 @@\n-    if (jvm_offset + strlen(hsdis_library_name) + strlen(os::dll_file_extension()) < JVM_MAXPATHLEN) {\n-      strcpy(&buf[jvm_offset], hsdis_library_name);\n-      strcat(&buf[jvm_offset], os::dll_file_extension());\n-      if (Verbose) st->print_cr(\"Trying to load: %s\", buf);\n-      _library = os::dll_load(buf, ebuf, sizeof ebuf);\n-    } else {\n-      if (Verbose) st->print_cr(\"Try to load hsdis library failed: the length of path is beyond the OS limit\");\n-    }\n+    _library = dll_load(buf, sizeof buf, jvm_offset, ebuf, sizeof ebuf, st);\n@@ -817,8 +821,1 @@\n-      if (lib_offset + strlen(hsdis_library_name) + strlen(os::dll_file_extension()) < JVM_MAXPATHLEN) {\n-        strcpy(&buf[lib_offset], hsdis_library_name);\n-        strcat(&buf[lib_offset], os::dll_file_extension());\n-        if (Verbose) st->print_cr(\"Trying to load: %s\", buf);\n-        _library = os::dll_load(buf, ebuf, sizeof ebuf);\n-      } else {\n-        if (Verbose) st->print_cr(\"Try to load hsdis library failed: the length of path is beyond the OS limit\");\n-      }\n+      _library = dll_load(buf, sizeof buf, lib_offset, ebuf, sizeof ebuf, st);\n@@ -832,8 +829,1 @@\n-        if (lib_offset + strlen(hsdis_library_name) + strlen(os::dll_file_extension()) < JVM_MAXPATHLEN) {\n-          strcpy(&buf[lib_offset], hsdis_library_name);\n-          strcat(&buf[lib_offset], os::dll_file_extension());\n-          if (Verbose) st->print_cr(\"Trying to load: %s\", buf);\n-          _library = os::dll_load(buf, ebuf, sizeof ebuf);\n-        } else {\n-          if (Verbose) st->print_cr(\"Try to load hsdis library failed: the length of path is beyond the OS limit\");\n-        }\n+        _library = dll_load(buf, sizeof buf, lib_offset, ebuf, sizeof ebuf, st);\n@@ -844,5 +834,1 @@\n-    \/\/ 4. hsdis-<arch>.so  (using LD_LIBRARY_PATH)\n-    strcpy(&buf[0], hsdis_library_name);\n-    strcat(&buf[0], os::dll_file_extension());\n-    if (Verbose) st->print_cr(\"Trying to load: %s via LD_LIBRARY_PATH or equivalent\", buf);\n-    _library = os::dll_load(buf, ebuf, sizeof ebuf);\n+    _library = dll_load(buf, sizeof buf, 0, ebuf, sizeof ebuf, st);\n","filename":"src\/hotspot\/share\/compiler\/disassembler.cpp","additions":15,"deletions":29,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,1 @@\n+  static void* dll_load(char* buf, int buflen, int offset, char* ebuf, int ebuflen, outputStream* st);\n","filename":"src\/hotspot\/share\/compiler\/disassembler.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -167,6 +167,0 @@\n-  \/\/ Second-level allocation: Should be called while holding a\n-  \/\/ lock. It will try to first allocate lock-free out of the active\n-  \/\/ region or, if it's unable to, it will try to replace the active\n-  \/\/ alloc region with a new one. We require that the caller takes the\n-  \/\/ appropriate lock before calling this so that it is easier to make\n-  \/\/ it conform to its locking protocol.\n@@ -174,4 +168,6 @@\n-  \/\/ Same as attempt_allocation_locked(size_t, bool), but allowing specification\n-  \/\/ of minimum word size of the block in min_word_size, and the maximum word\n-  \/\/ size of the allocation in desired_word_size. The actual size of the block is\n-  \/\/ returned in actual_word_size.\n+  \/\/ Second-level allocation: Should be called while holding a\n+  \/\/ lock. We require that the caller takes the appropriate lock\n+  \/\/ before calling this so that it is easier to make it conform\n+  \/\/ to the locking protocol. The min and desired word size allow\n+  \/\/ specifying a minimum and maximum size of the allocation. The\n+  \/\/ actual size of allocation is returned in actual_word_size.\n@@ -182,0 +178,5 @@\n+  \/\/ Perform an allocation out of a new allocation region, retiring the current one.\n+  inline HeapWord* attempt_allocation_using_new_region(size_t min_word_size,\n+                                                       size_t desired_word_size,\n+                                                       size_t* actual_word_size);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.hpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -102,3 +102,0 @@\n-  \/\/ First we have to redo the allocation, assuming we're holding the\n-  \/\/ appropriate lock, in case another thread changed the region while\n-  \/\/ we were waiting to get the lock.\n@@ -110,0 +107,6 @@\n+  return attempt_allocation_using_new_region(min_word_size, desired_word_size, actual_word_size);\n+}\n+\n+inline HeapWord* G1AllocRegion::attempt_allocation_using_new_region(size_t min_word_size,\n+                                                                    size_t desired_word_size,\n+                                                                    size_t* actual_word_size) {\n@@ -111,1 +114,1 @@\n-  result = new_alloc_region_and_allocate(desired_word_size, false \/* force *\/);\n+  HeapWord* result = new_alloc_region_and_allocate(desired_word_size, false \/* force *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.inline.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+  \/\/ Attempt allocation in the current alloc region.\n@@ -118,0 +119,7 @@\n+\n+  \/\/ Attempt allocation, retiring the current region and allocating a new one. It is\n+  \/\/ assumed that attempt_allocation() has been tried and failed already first.\n+  inline HeapWord* attempt_allocation_using_new_region(size_t word_size);\n+\n+  \/\/ This is to be called when holding an appropriate lock. It first tries in the\n+  \/\/ current allocation region, and then attempts an allocation using a new region.\n@@ -119,0 +127,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+\n@@ -60,0 +61,1 @@\n+\n@@ -63,0 +65,10 @@\n+inline HeapWord* G1Allocator::attempt_allocation_using_new_region(size_t word_size) {\n+  uint node_index = current_node_index();\n+  size_t temp;\n+  HeapWord* result = mutator_alloc_region(node_index)->attempt_allocation_using_new_region(word_size, word_size, &temp);\n+  assert(result != NULL || mutator_alloc_region(node_index)->get() == NULL,\n+         \"Must not have a mutator alloc region if there is no memory, but is \" PTR_FORMAT,\n+         p2i(mutator_alloc_region(node_index)->get()));\n+  return result;\n+}\n+\n@@ -66,0 +78,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.inline.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -397,0 +397,1 @@\n+    bool preventive_collection_required = false;\n@@ -401,1 +402,5 @@\n-      result = _allocator->attempt_allocation_locked(word_size);\n+\n+      \/\/ Now that we have the lock, we first retry the allocation in case another\n+      \/\/ thread changed the region while we were waiting to acquire the lock.\n+      size_t actual_size;\n+      result = _allocator->attempt_allocation(word_size, word_size, &actual_size);\n@@ -406,7 +411,5 @@\n-      \/\/ If the GCLocker is active and we are bound for a GC, try expanding young gen.\n-      \/\/ This is different to when only GCLocker::needs_gc() is set: try to avoid\n-      \/\/ waiting because the GCLocker is active to not wait too long.\n-      if (GCLocker::is_active_and_needs_gc() && policy()->can_expand_young_list()) {\n-        \/\/ No need for an ergo message here, can_expand_young_list() does this when\n-        \/\/ it returns true.\n-        result = _allocator->attempt_allocation_force(word_size);\n+      preventive_collection_required = policy()->preventive_collection_required(1);\n+      if (!preventive_collection_required) {\n+        \/\/ We've already attempted a lock-free allocation above, so we don't want to\n+        \/\/ do it again. Let's jump straight to replacing the active region.\n+        result = _allocator->attempt_allocation_using_new_region(word_size);\n@@ -416,0 +419,12 @@\n+\n+        \/\/ If the GCLocker is active and we are bound for a GC, try expanding young gen.\n+        \/\/ This is different to when only GCLocker::needs_gc() is set: try to avoid\n+        \/\/ waiting because the GCLocker is active to not wait too long.\n+        if (GCLocker::is_active_and_needs_gc() && policy()->can_expand_young_list()) {\n+          \/\/ No need for an ergo message here, can_expand_young_list() does this when\n+          \/\/ it returns true.\n+          result = _allocator->attempt_allocation_force(word_size);\n+          if (result != NULL) {\n+            return result;\n+          }\n+        }\n@@ -417,0 +432,1 @@\n+\n@@ -426,0 +442,2 @@\n+      GCCause::Cause gc_cause = preventive_collection_required ? GCCause::_g1_preventive_collection\n+                                                              : GCCause::_g1_inc_collection_pause;\n@@ -427,2 +445,1 @@\n-      result = do_collection_pause(word_size, gc_count_before, &succeeded,\n-                                   GCCause::_g1_inc_collection_pause);\n+      result = do_collection_pause(word_size, gc_count_before, &succeeded, gc_cause);\n@@ -843,0 +860,1 @@\n+    bool preventive_collection_required = false;\n@@ -849,9 +867,12 @@\n-      \/\/ Given that humongous objects are not allocated in young\n-      \/\/ regions, we'll first try to do the allocation without doing a\n-      \/\/ collection hoping that there's enough space in the heap.\n-      result = humongous_obj_allocate(word_size);\n-      if (result != NULL) {\n-        size_t size_in_regions = humongous_obj_size_in_regions(word_size);\n-        policy()->old_gen_alloc_tracker()->\n-          add_allocated_humongous_bytes_since_last_gc(size_in_regions * HeapRegion::GrainBytes);\n-        return result;\n+      size_t size_in_regions = humongous_obj_size_in_regions(word_size);\n+      preventive_collection_required = policy()->preventive_collection_required((uint)size_in_regions);\n+      if (!preventive_collection_required) {\n+        \/\/ Given that humongous objects are not allocated in young\n+        \/\/ regions, we'll first try to do the allocation without doing a\n+        \/\/ collection hoping that there's enough space in the heap.\n+        result = humongous_obj_allocate(word_size);\n+        if (result != NULL) {\n+          policy()->old_gen_alloc_tracker()->\n+            add_allocated_humongous_bytes_since_last_gc(size_in_regions * HeapRegion::GrainBytes);\n+          return result;\n+        }\n@@ -869,0 +890,2 @@\n+      GCCause::Cause gc_cause = preventive_collection_required ? GCCause::_g1_preventive_collection\n+                                                              : GCCause::_g1_humongous_allocation;\n@@ -870,2 +893,1 @@\n-      result = do_collection_pause(word_size, gc_count_before, &succeeded,\n-                                   GCCause::_g1_humongous_allocation);\n+      result = do_collection_pause(word_size, gc_count_before, &succeeded, gc_cause);\n@@ -1119,0 +1141,12 @@\n+bool G1CollectedHeap::upgrade_to_full_collection() {\n+  GCCauseSetter compaction(this, GCCause::_g1_compaction_pause);\n+  log_info(gc, ergo)(\"Attempting full compaction clearing soft references\");\n+  bool success = do_full_collection(false \/* explicit gc *\/,\n+                                    true  \/* clear_all_soft_refs *\/,\n+                                    false \/* do_maximum_compaction *\/);\n+  \/\/ do_full_collection only fails if blocked by GC locker and that can't\n+  \/\/ be the case here since we only call this when already completed one gc.\n+  assert(success, \"invariant\");\n+  return success;\n+}\n+\n@@ -1136,1 +1170,1 @@\n-                                                            bool clear_all_soft_refs,\n+                                                            bool maximum_compaction,\n@@ -1158,3 +1192,1 @@\n-    \/\/ When clear_all_soft_refs is set we want to do a maximum compaction\n-    \/\/ not leaving any dead wood.\n-    bool do_maximum_compaction = clear_all_soft_refs;\n+    GCCauseSetter compaction(this, GCCause::_g1_compaction_pause);\n@@ -1162,0 +1194,7 @@\n+    \/\/ If maximum_compaction is set we clear all soft references and don't\n+    \/\/ allow any dead wood to be left on the heap.\n+    if (maximum_compaction) {\n+      log_info(gc, ergo)(\"Attempting maximum full compaction clearing soft references\");\n+    } else {\n+      log_info(gc, ergo)(\"Attempting full compaction\");\n+    }\n@@ -1163,2 +1202,2 @@\n-                                       clear_all_soft_refs,\n-                                       do_maximum_compaction);\n+                                       maximum_compaction \/* clear_all_soft_refs *\/ ,\n+                                       maximum_compaction \/* do_maximum_compaction *\/);\n@@ -1178,1 +1217,1 @@\n-                                     false, \/* clear_all_soft_refs *\/\n+                                     false, \/* maximum_collection *\/\n@@ -1189,1 +1228,1 @@\n-                                            true, \/* clear_all_soft_refs *\/\n+                                            true, \/* maximum_collection *\/\n@@ -1200,1 +1239,1 @@\n-                                            false, \/* clear_all_soft_refs *\/\n+                                            false, \/* maximum_collection *\/\n@@ -1441,0 +1480,1 @@\n+  _regions_failed_evacuation(NULL),\n@@ -1733,0 +1773,2 @@\n+  _regions_failed_evacuation = NEW_C_HEAP_ARRAY(volatile bool, max_regions(), mtGC);\n+\n@@ -1803,2 +1845,1 @@\n-                           &_is_alive_closure_cm,                          \/\/ is alive closure\n-                           true);                                          \/\/ allow changes to number of processing threads\n+                           &_is_alive_closure_cm);                         \/\/ is alive closure\n@@ -1813,2 +1854,1 @@\n-                           &_is_alive_closure_stw,               \/\/ is alive closure\n-                           true);                                \/\/ allow changes to number of processing threads\n+                           &_is_alive_closure_stw);              \/\/ is alive closure\n@@ -1881,10 +1921,0 @@\n-bool G1CollectedHeap::should_upgrade_to_full_gc(GCCause::Cause cause) {\n-  if (should_do_concurrent_full_gc(_gc_cause)) {\n-    return false;\n-  } else if (has_regions_left_for_allocation()) {\n-    return false;\n-  } else {\n-    return true;\n-  }\n-}\n-\n@@ -2858,9 +2888,0 @@\n-  if (should_upgrade_to_full_gc(gc_cause())) {\n-    log_info(gc, ergo)(\"Attempting maximally compacting collection\");\n-    bool result = do_full_collection(false \/* explicit gc *\/,\n-                                     true  \/* clear_all_soft_refs *\/,\n-                                     false \/* do_maximum_compaction *\/);\n-    \/\/ do_full_collection only fails if blocked by GC locker, but\n-    \/\/ we've already checked for that above.\n-    assert(result, \"invariant\");\n-  }\n@@ -3396,0 +3417,10 @@\n+      log_debug(gc, humongous)(\"Humongous region %u (object size \" SIZE_FORMAT \" @ \" PTR_FORMAT \") remset \" SIZE_FORMAT \" code roots \" SIZE_FORMAT \" marked %d reclaim candidate %d type array %d\",\n+                               index,\n+                               (size_t)cast_to_oop(hr->bottom())->size() * HeapWordSize,\n+                               p2i(hr->bottom()),\n+                               hr->rem_set()->occupied(),\n+                               hr->rem_set()->strong_code_roots_list_length(),\n+                               _g1h->concurrent_mark()->next_mark_bitmap()->is_marked(hr->bottom()),\n+                               _g1h->is_humongous_reclaim_candidate(index),\n+                               cast_to_oop(hr->bottom())->is_typeArray()\n+                              );\n@@ -3442,0 +3473,2 @@\n+  memset((void*)_regions_failed_evacuation, false, sizeof(bool) * max_regions());\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":86,"deletions":53,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -288,3 +288,0 @@\n-  \/\/ Return true if should upgrade to full gc after an incremental one.\n-  bool should_upgrade_to_full_gc(GCCause::Cause cause);\n-\n@@ -519,0 +516,3 @@\n+  \/\/ Helper to do a full collection that clears soft references.\n+  bool upgrade_to_full_collection();\n+\n@@ -537,1 +537,1 @@\n-                                             bool clear_all_soft_refs,\n+                                             bool maximum_compaction,\n@@ -870,0 +870,2 @@\n+  \/\/ Records for every region on the heap whether evacuation failed for it.\n+  volatile bool* _regions_failed_evacuation;\n@@ -1089,3 +1091,4 @@\n-  \/\/ Returns whether there are any regions left in the heap for allocation.\n-  bool has_regions_left_for_allocation() const {\n-    return !is_maximal_no_gc() || num_free_regions() != 0;\n+  \/\/ Returns true if an incremental GC should be upgrade to a full gc. This\n+  \/\/ is done when there are no free regions and the heap can't be expanded.\n+  bool should_upgrade_to_full_gc() const {\n+    return is_maximal_no_gc() && num_free_regions() == 0;\n@@ -1147,0 +1150,4 @@\n+  \/\/ True iff the given region encountered an evacuation failure in the most-recent\n+  \/\/ collection.\n+  inline bool evacuation_failed(uint region_idx) const;\n+\n@@ -1148,3 +1155,4 @@\n-  \/\/ Notify that the garbage collection encountered an evacuation failure in a\n-  \/\/ region. Should only be called once per region.\n-  inline void notify_region_failed_evacuation();\n+  \/\/ Notify that the garbage collection encountered an evacuation failure in the\n+  \/\/ given region. Returns whether this has been the first occurrence of an evacuation\n+  \/\/ failure in that region.\n+  inline bool notify_region_failed_evacuation(uint const region_idx);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -197,0 +197,6 @@\n+bool G1CollectedHeap::evacuation_failed(uint region_idx) const {\n+  assert(region_idx < max_regions(), \"Invalid region index %u\", region_idx);\n+\n+  return Atomic::load(&_regions_failed_evacuation[region_idx]);\n+}\n+\n@@ -201,2 +207,9 @@\n-void G1CollectedHeap::notify_region_failed_evacuation() {\n-  Atomic::inc(&_num_regions_failed_evacuation, memory_order_relaxed);\n+bool G1CollectedHeap::notify_region_failed_evacuation(uint const region_idx) {\n+  assert(region_idx < max_regions(), \"Invalid region index %u\", region_idx);\n+\n+  volatile bool* region_failed_addr = &_regions_failed_evacuation[region_idx];\n+  bool result = !Atomic::load(region_failed_addr) && !Atomic::cmpxchg(region_failed_addr, false, true, memory_order_relaxed);\n+  if (result) {\n+    Atomic::inc(&_num_regions_failed_evacuation, memory_order_relaxed);\n+  }\n+  return result;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -114,0 +114,4 @@\n+bool G1CollectionSet::has_candidates() {\n+  return _candidates != NULL && !_candidates->is_empty();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -275,0 +275,1 @@\n+  bool has_candidates();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -683,0 +683,5 @@\n+  \/\/ To avoid fragmentation the full collection requesting to clear the bitmap\n+  \/\/ might use fewer workers than available. To ensure the bitmap is cleared\n+  \/\/ as efficiently as possible the number of active workers are temporarily\n+  \/\/ increased to include all currently created workers.\n+  WithUpdatedActiveWorkers update(workers, workers->created_workers());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-    if (hr->evacuation_failed()) {\n+    if (_g1h->evacuation_failed(hr->hrm_index())) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,0 +97,4 @@\n+  \/\/ Finally consider the amount of used regions.\n+  uint used_worker_limit = heap->num_used_regions();\n+  assert(used_worker_limit > 0, \"Should never have zero used regions.\");\n+\n@@ -98,3 +102,4 @@\n-  uint worker_count = MIN2(heap_waste_worker_limit, active_worker_limit);\n-  log_debug(gc, task)(\"Requesting %u active workers for full compaction (waste limited workers: %u, adaptive workers: %u)\",\n-                      worker_count, heap_waste_worker_limit, active_worker_limit);\n+  uint worker_count = MIN3(heap_waste_worker_limit, active_worker_limit, used_worker_limit);\n+  log_debug(gc, task)(\"Requesting %u active workers for full compaction (waste limited workers: %u, \"\n+                      \"adaptive workers: %u, used limited workers: %u)\",\n+                      worker_count, heap_waste_worker_limit, active_worker_limit, used_worker_limit);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -608,2 +608,1 @@\n-    if (r->set_evacuation_failed()) {\n-      _g1h->notify_region_failed_evacuation();\n+    if (_g1h->notify_region_failed_evacuation(r->hrm_index())) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -71,0 +71,2 @@\n+  _predicted_surviving_bytes_from_survivor(0),\n+  _predicted_surviving_bytes_from_old(0),\n@@ -453,0 +455,1 @@\n+  update_survival_estimates_for_next_collection();\n@@ -782,0 +785,1 @@\n+  update_survival_estimates_for_next_collection();\n@@ -1403,0 +1407,80 @@\n+\/\/ Number of regions required to store the given number of bytes, taking\n+\/\/ into account the target amount of wasted space in PLABs.\n+static size_t get_num_regions_adjust_for_plab_waste(size_t byte_count) {\n+  size_t byte_count_adjusted = byte_count * (size_t)(100 + TargetPLABWastePct) \/ 100.0;\n+\n+  \/\/ Round up the region count\n+  return (byte_count_adjusted + HeapRegion::GrainBytes - 1) \/ HeapRegion::GrainBytes;\n+}\n+\n+bool G1Policy::preventive_collection_required(uint alloc_region_count) {\n+  if (!G1AllowPreventiveGC || !Universe::is_fully_initialized()) {\n+    \/\/ Don't attempt any preventive GC's if the feature is disabled,\n+    \/\/ or before initialization is complete.\n+    return false;\n+  }\n+\n+  if (_g1h->young_regions_count() == 0 && !_collection_set->has_candidates()) {\n+    return false;\n+  }\n+\n+  uint eden_count = _g1h->eden_regions_count();\n+  size_t const eden_surv_bytes_pred = _eden_surv_rate_group->accum_surv_rate_pred(eden_count) * HeapRegion::GrainBytes;\n+  size_t const total_young_predicted_surviving_bytes = eden_surv_bytes_pred + _predicted_surviving_bytes_from_survivor;\n+\n+  uint required_regions = (uint)(get_num_regions_adjust_for_plab_waste(total_young_predicted_surviving_bytes) +\n+                                get_num_regions_adjust_for_plab_waste(_predicted_surviving_bytes_from_old));\n+\n+  if (required_regions > _g1h->num_free_regions() - alloc_region_count) {\n+    log_debug(gc, ergo, cset)(\"Preventive GC, insufficient free regions. Predicted need %u. Curr Eden %u (Pred %u). Curr Survivor %u (Pred %u). Curr Old %u (Pred %u) Free %u Alloc %u\",\n+            required_regions,\n+            eden_count,\n+            (uint)get_num_regions_adjust_for_plab_waste(eden_surv_bytes_pred),\n+            _g1h->survivor_regions_count(),\n+            (uint)get_num_regions_adjust_for_plab_waste(_predicted_surviving_bytes_from_survivor),\n+            _g1h->old_regions_count(),\n+            (uint)get_num_regions_adjust_for_plab_waste(_predicted_surviving_bytes_from_old),\n+            _g1h->num_free_regions(),\n+            alloc_region_count);\n+\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+void G1Policy::update_survival_estimates_for_next_collection() {\n+  \/\/ Predict the number of bytes of surviving objects from survivor and old\n+  \/\/ regions and update the associated members.\n+\n+  \/\/ Survivor regions\n+  size_t survivor_bytes = 0;\n+  const GrowableArray<HeapRegion*>* survivor_regions = _g1h->survivor()->regions();\n+  for (GrowableArrayIterator<HeapRegion*> it = survivor_regions->begin();\n+       it != survivor_regions->end();\n+       ++it) {\n+    survivor_bytes += predict_bytes_to_copy(*it);\n+  }\n+\n+  _predicted_surviving_bytes_from_survivor = survivor_bytes;\n+\n+  \/\/ Old regions\n+  if (!_collection_set->has_candidates()) {\n+    _predicted_surviving_bytes_from_old = 0;\n+    return;\n+  }\n+\n+  \/\/ Use the minimum old gen collection set as conservative estimate for the number\n+  \/\/ of regions to take for this calculation.\n+  G1CollectionSetCandidates *candidates = _collection_set->candidates();\n+  uint iterate_count = MIN2(candidates->num_remaining(), calc_min_old_cset_length(candidates));\n+  uint current_index = candidates->cur_idx();\n+  size_t old_bytes = 0;\n+  for (uint i = 0; i < iterate_count; i++) {\n+    HeapRegion *region = candidates->at(current_index + i);\n+    old_bytes += predict_bytes_to_copy(region);\n+  }\n+\n+  _predicted_surviving_bytes_from_old = old_bytes;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -101,0 +101,5 @@\n+  \/\/ These values are predictions of how much we think will survive in each\n+  \/\/ section of the heap.\n+  size_t _predicted_surviving_bytes_from_survivor;\n+  size_t _predicted_surviving_bytes_from_old;\n+\n@@ -348,0 +353,5 @@\n+  \/\/ Returns whether a collection should be done proactively, taking into\n+  \/\/ account the current number of free regions and the expected survival\n+  \/\/ rates in each section of the heap.\n+  bool preventive_collection_required(uint region_count);\n+\n@@ -349,0 +359,5 @@\n+\n+  \/\/ Predict the number of bytes of surviving objects from survivor and old\n+  \/\/ regions and update the associated members.\n+  void update_survival_estimates_for_next_collection();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -97,3 +97,1 @@\n-  } else if (g1h->do_collection_pause_at_safepoint(_target_pause_time_ms)) {\n-    _gc_succeeded = true;\n-  } else {\n+  } else if (!g1h->do_collection_pause_at_safepoint(_target_pause_time_ms)) {\n@@ -105,0 +103,4 @@\n+  } else if (g1h->should_upgrade_to_full_gc()) {\n+    _gc_succeeded = g1h->upgrade_to_full_collection();\n+  } else {\n+    _gc_succeeded = true;\n@@ -122,0 +124,5 @@\n+bool VM_G1CollectForAllocation::should_try_allocation_before_gc() {\n+  \/\/ Don't allocate before a preventive GC.\n+  return _gc_cause != GCCause::_g1_preventive_collection;\n+}\n+\n@@ -125,1 +132,1 @@\n-  if (_word_size > 0) {\n+  if (should_try_allocation_before_gc() && _word_size > 0) {\n@@ -141,4 +148,11 @@\n-  if (_gc_succeeded && (_word_size > 0)) {\n-    \/\/ An allocation had been requested. Do it, eventually trying a stronger\n-    \/\/ kind of GC.\n-    _result = g1h->satisfy_failed_allocation(_word_size, &_gc_succeeded);\n+  if (_gc_succeeded) {\n+    if (_word_size > 0) {\n+      \/\/ An allocation had been requested. Do it, eventually trying a stronger\n+      \/\/ kind of GC.\n+      _result = g1h->satisfy_failed_allocation(_word_size, &_gc_succeeded);\n+    } else if (g1h->should_upgrade_to_full_gc()) {\n+      \/\/ There has been a request to perform a GC to free some space. We have no\n+      \/\/ information on how much memory has been asked for. In case there are\n+      \/\/ absolutely no regions left to allocate into, do a full compaction.\n+      _gc_succeeded = g1h->upgrade_to_full_collection();\n+    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -81,0 +81,3 @@\n+\n+private:\n+  bool should_try_allocation_before_gc();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -94,1 +94,0 @@\n-public:\n@@ -96,0 +95,36 @@\n+  \/\/ Returns whether the given humongous object defined by the start region index\n+  \/\/ is reclaimable.\n+  \/\/\n+  \/\/ At this point in the garbage collection, checking whether the humongous object\n+  \/\/ is still a candidate is sufficient because:\n+  \/\/\n+  \/\/ - if it has not been a candidate at the start of collection, it will never\n+  \/\/ changed to be a candidate during the gc (and live).\n+  \/\/ - any found outstanding (i.e. in the DCQ, or in its remembered set)\n+  \/\/ references will set the candidate state to false.\n+  \/\/ - there can be no references from within humongous starts regions referencing\n+  \/\/ the object because we never allocate other objects into them.\n+  \/\/ (I.e. there can be no intra-region references)\n+  \/\/\n+  \/\/ It is not required to check whether the object has been found dead by marking\n+  \/\/ or not, in fact it would prevent reclamation within a concurrent cycle, as\n+  \/\/ all objects allocated during that time are considered live.\n+  \/\/ SATB marking is even more conservative than the remembered set.\n+  \/\/ So if at this point in the collection we did not find a reference during gc\n+  \/\/ (or it had enough references to not be a candidate, having many remembered\n+  \/\/ set entries), nobody has a reference to it.\n+  \/\/ At the start of collection we flush all refinement logs, and remembered sets\n+  \/\/ are completely up-to-date wrt to references to the humongous object.\n+  \/\/\n+  \/\/ So there is no need to re-check remembered set size of the humongous region.\n+  \/\/\n+  \/\/ Other implementation considerations:\n+  \/\/ - never consider object arrays at this time because they would pose\n+  \/\/ considerable effort for cleaning up the the remembered sets. This is\n+  \/\/ required because stale remembered sets might reference locations that\n+  \/\/ are currently allocated into.\n+  bool is_reclaimable(uint region_idx) const {\n+    return G1CollectedHeap::heap()->is_humongous_reclaim_candidate(region_idx);\n+  }\n+\n+public:\n@@ -107,33 +142,0 @@\n-    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-\n-    oop obj = cast_to_oop(r->bottom());\n-    G1CMBitMap* next_bitmap = g1h->concurrent_mark()->next_mark_bitmap();\n-\n-    \/\/ The following checks whether the humongous object is live are sufficient.\n-    \/\/ The main additional check (in addition to having a reference from the roots\n-    \/\/ or the young gen) is whether the humongous object has a remembered set entry.\n-    \/\/\n-    \/\/ A humongous object cannot be live if there is no remembered set for it\n-    \/\/ because:\n-    \/\/ - there can be no references from within humongous starts regions referencing\n-    \/\/ the object because we never allocate other objects into them.\n-    \/\/ (I.e. there are no intra-region references that may be missed by the\n-    \/\/ remembered set)\n-    \/\/ - as soon there is a remembered set entry to the humongous starts region\n-    \/\/ (i.e. it has \"escaped\" to an old object) this remembered set entry will stay\n-    \/\/ until the end of a concurrent mark.\n-    \/\/\n-    \/\/ It is not required to check whether the object has been found dead by marking\n-    \/\/ or not, in fact it would prevent reclamation within a concurrent cycle, as\n-    \/\/ all objects allocated during that time are considered live.\n-    \/\/ SATB marking is even more conservative than the remembered set.\n-    \/\/ So if at this point in the collection there is no remembered set entry,\n-    \/\/ nobody has a reference to it.\n-    \/\/ At the start of collection we flush all refinement logs, and remembered sets\n-    \/\/ are completely up-to-date wrt to references to the humongous object.\n-    \/\/\n-    \/\/ Other implementation considerations:\n-    \/\/ - never consider object arrays at this time because they would pose\n-    \/\/ considerable effort for cleaning up the the remembered sets. This is\n-    \/\/ required because stale remembered sets might reference locations that\n-    \/\/ are currently allocated into.\n@@ -141,12 +143,1 @@\n-    if (!g1h->is_humongous_reclaim_candidate(region_idx) ||\n-        !r->rem_set()->is_empty()) {\n-      log_debug(gc, humongous)(\"Live humongous region %u object size \" SIZE_FORMAT \" start \" PTR_FORMAT \"  with remset \" SIZE_FORMAT \" code roots \" SIZE_FORMAT \" is marked %d reclaim candidate %d type array %d\",\n-                               region_idx,\n-                               (size_t)obj->size() * HeapWordSize,\n-                               p2i(r->bottom()),\n-                               r->rem_set()->occupied(),\n-                               r->rem_set()->strong_code_roots_list_length(),\n-                               next_bitmap->is_marked(r->bottom()),\n-                               g1h->is_humongous_reclaim_candidate(region_idx),\n-                               obj->is_typeArray()\n-                              );\n+    if (!is_reclaimable(region_idx)) {\n@@ -156,0 +147,1 @@\n+    oop obj = cast_to_oop(r->bottom());\n@@ -160,1 +152,1 @@\n-    log_debug(gc, humongous)(\"Dead humongous region %u object size \" SIZE_FORMAT \" start \" PTR_FORMAT \" with remset \" SIZE_FORMAT \" code roots \" SIZE_FORMAT \" is marked %d reclaim candidate %d type array %d\",\n+    log_debug(gc, humongous)(\"Reclaimed humongous region %u (object size \" SIZE_FORMAT \" @ \" PTR_FORMAT \")\",\n@@ -163,6 +155,1 @@\n-                             p2i(r->bottom()),\n-                             r->rem_set()->occupied(),\n-                             r->rem_set()->strong_code_roots_list_length(),\n-                             next_bitmap->is_marked(r->bottom()),\n-                             g1h->is_humongous_reclaim_candidate(region_idx),\n-                             obj->is_typeArray()\n+                             p2i(r->bottom())\n@@ -171,0 +158,1 @@\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n@@ -280,1 +268,1 @@\n-    \/\/ A region will be freed by free_collection_set if the region is in the\n+    \/\/ A region will be freed by during the FreeCollectionSet phase if the region is in the\n@@ -282,1 +270,1 @@\n-    return _g1h->is_in_cset(hr) && !hr->evacuation_failed();\n+    return _g1h->is_in_cset(hr) && !_g1h->evacuation_failed(hr->hrm_index());\n@@ -394,2 +382,2 @@\n-      size_t used = r->used();\n-      assert(used > 0, \"region %u %s zero used\", r->hrm_index(), r->get_short_type_str());\n+    size_t used = r->used();\n+    assert(used > 0, \"region %u %s zero used\", r->hrm_index(), r->get_short_type_str());\n@@ -446,1 +434,1 @@\n-  void assert_in_cset(HeapRegion* r) {\n+  void assert_tracks_surviving_words(HeapRegion* r) {\n@@ -501,1 +489,0 @@\n-    _g1h->clear_region_attr(r);\n@@ -505,1 +492,1 @@\n-      assert_in_cset(r);\n+      assert_tracks_surviving_words(r);\n@@ -509,1 +496,1 @@\n-    if (r->evacuation_failed()) {\n+    if (_g1h->evacuation_failed(r->hrm_index())) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":48,"deletions":61,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -310,1 +310,6 @@\n-          range(0.0, (double)max_uintx)\n+          range(0.0, (double)max_uintx)                                     \\\n+                                                                            \\\n+  product(bool, G1AllowPreventiveGC, true, DIAGNOSTIC,                       \\\n+          \"Allows collections to be triggered proactively based on the      \\\n+           number of free regions and the expected survival rates in each   \\\n+           section of the heap.\")\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -107,1 +107,0 @@\n-  reset_evacuation_failed();\n@@ -121,2 +120,0 @@\n-  assert(!in_collection_set(),\n-         \"Should not clear heap region %u in the collection set\", hrm_index());\n@@ -137,1 +134,0 @@\n-  Atomic::store(&_evacuation_failed, false);\n@@ -245,1 +241,0 @@\n-  _evacuation_failed(false),\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -213,3 +213,0 @@\n-  \/\/ True iff an attempt to evacuate an object in the region failed.\n-  volatile bool _evacuation_failed;\n-\n@@ -501,9 +498,0 @@\n-  \/\/ Returns the \"evacuation_failed\" property of the region.\n-  inline bool evacuation_failed() const;\n-\n-  \/\/ Sets the \"evacuation_failed\" property of the region, returning true if this\n-  \/\/ has been the first call, false otherwise.\n-  inline bool set_evacuation_failed();\n-\n-  inline void reset_evacuation_failed();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -455,12 +455,0 @@\n-inline bool HeapRegion::evacuation_failed() const {\n-  return Atomic::load(&_evacuation_failed);\n-}\n-\n-inline bool HeapRegion::set_evacuation_failed() {\n-  return !Atomic::load(&_evacuation_failed) && !Atomic::cmpxchg(&_evacuation_failed, false, true, memory_order_relaxed);\n-}\n-\n-inline void HeapRegion::reset_evacuation_failed() {\n-  Atomic::store(&_evacuation_failed, false);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -88,0 +88,4 @@\n+\n+  if (FLAG_IS_DEFAULT(ParallelRefProcEnabled) && ParallelGCThreads > 1) {\n+    \/\/FLAG_SET_DEFAULT(ParallelRefProcEnabled, true);\n+  }\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelArguments.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,7 +93,2 @@\n-      oop o = *p;\n-      oop new_obj;\n-      if (o->is_forwarded()) {\n-        new_obj = o->forwardee();\n-      } else {\n-        new_obj = _pm->copy_to_survivor_space<\/*promote_immediately=*\/false>(o);\n-      }\n+      oop o = RawAccess<IS_NOT_NULL>::oop_load(p);\n+      oop new_obj = _pm->copy_to_survivor_space<\/*promote_immediately=*\/false>(o);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psClosure.inline.hpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2117,1 +2117,4 @@\n-    WeakProcessor::weak_oops_do(is_alive_closure(), &do_nothing_cl);\n+    WeakProcessor::weak_oops_do(&ParallelScavengeHeap::heap()->workers(),\n+                                is_alive_closure(),\n+                                &do_nothing_cl,\n+                                1);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -113,0 +113,3 @@\n+  template<bool promote_immediately>\n+  oop copy_unmarked_to_survivor_space(oop o, markWord m);\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/orderAccess.hpp\"\n@@ -129,0 +130,21 @@\n+\n+template<bool promote_immediately>\n+inline oop PSPromotionManager::copy_to_survivor_space(oop o) {\n+  assert(should_scavenge(&o), \"Sanity\");\n+\n+  \/\/ NOTE! We must be very careful with any methods that access the mark\n+  \/\/ in o. There may be multiple threads racing on it, and it may be forwarded\n+  \/\/ at any time.\n+  markWord m = o->mark();\n+  if (!m.is_marked()) {\n+    return copy_unmarked_to_survivor_space<promote_immediately>(o, m);\n+  } else {\n+    \/\/ Ensure any loads from the forwardee follow all changes that precede\n+    \/\/ the release-cmpxchg that performed the forwarding, possibly in some\n+    \/\/ other thread.\n+    OrderAccess::acquire();\n+    \/\/ Return the already installed forwardee.\n+    return cast_to_oop(m.decode_pointer());\n+  }\n+}\n+\n@@ -135,1 +157,2 @@\n-inline oop PSPromotionManager::copy_to_survivor_space(oop o) {\n+inline oop PSPromotionManager::copy_unmarked_to_survivor_space(oop o,\n+                                                               markWord test_mark) {\n@@ -139,0 +162,2 @@\n+  bool new_obj_is_tenured = false;\n+  size_t new_obj_size = o->size();\n@@ -140,12 +165,2 @@\n-  \/\/ NOTE! We must be very careful with any methods that access the mark\n-  \/\/ in o. There may be multiple threads racing on it, and it may be forwarded\n-  \/\/ at any time. Do not use oop methods for accessing the mark!\n-  markWord test_mark = o->mark();\n-\n-  \/\/ The same test as \"o->is_forwarded()\"\n-  if (!test_mark.is_marked()) {\n-    bool new_obj_is_tenured = false;\n-    size_t new_obj_size = o->size();\n-\n-    \/\/ Find the objects age, MT safe.\n-    uint age = (test_mark.has_displaced_mark_helper() \/* o->has_displaced_mark() *\/) ?\n+  \/\/ Find the objects age, MT safe.\n+  uint age = (test_mark.has_displaced_mark_helper() \/* o->has_displaced_mark() *\/) ?\n@@ -154,10 +169,20 @@\n-    if (!promote_immediately) {\n-      \/\/ Try allocating obj in to-space (unless too old)\n-      if (age < PSScavenge::tenuring_threshold()) {\n-        new_obj = cast_to_oop(_young_lab.allocate(new_obj_size));\n-        if (new_obj == NULL && !_young_gen_is_full) {\n-          \/\/ Do we allocate directly, or flush and refill?\n-          if (new_obj_size > (YoungPLABSize \/ 2)) {\n-            \/\/ Allocate this object directly\n-            new_obj = cast_to_oop(young_space()->cas_allocate(new_obj_size));\n-            promotion_trace_event(new_obj, o, new_obj_size, age, false, NULL);\n+  if (!promote_immediately) {\n+    \/\/ Try allocating obj in to-space (unless too old)\n+    if (age < PSScavenge::tenuring_threshold()) {\n+      new_obj = cast_to_oop(_young_lab.allocate(new_obj_size));\n+      if (new_obj == NULL && !_young_gen_is_full) {\n+        \/\/ Do we allocate directly, or flush and refill?\n+        if (new_obj_size > (YoungPLABSize \/ 2)) {\n+          \/\/ Allocate this object directly\n+          new_obj = cast_to_oop(young_space()->cas_allocate(new_obj_size));\n+          promotion_trace_event(new_obj, o, new_obj_size, age, false, NULL);\n+        } else {\n+          \/\/ Flush and fill\n+          _young_lab.flush();\n+\n+          HeapWord* lab_base = young_space()->cas_allocate(YoungPLABSize);\n+          if (lab_base != NULL) {\n+            _young_lab.initialize(MemRegion(lab_base, YoungPLABSize));\n+            \/\/ Try the young lab allocation again.\n+            new_obj = cast_to_oop(_young_lab.allocate(new_obj_size));\n+            promotion_trace_event(new_obj, o, new_obj_size, age, false, &_young_lab);\n@@ -165,12 +190,1 @@\n-            \/\/ Flush and fill\n-            _young_lab.flush();\n-\n-            HeapWord* lab_base = young_space()->cas_allocate(YoungPLABSize);\n-            if (lab_base != NULL) {\n-              _young_lab.initialize(MemRegion(lab_base, YoungPLABSize));\n-              \/\/ Try the young lab allocation again.\n-              new_obj = cast_to_oop(_young_lab.allocate(new_obj_size));\n-              promotion_trace_event(new_obj, o, new_obj_size, age, false, &_young_lab);\n-            } else {\n-              _young_gen_is_full = true;\n-            }\n+            _young_gen_is_full = true;\n@@ -181,0 +195,1 @@\n+  }\n@@ -182,2 +197,2 @@\n-    \/\/ Otherwise try allocating obj tenured\n-    if (new_obj == NULL) {\n+  \/\/ Otherwise try allocating obj tenured\n+  if (new_obj == NULL) {\n@@ -185,3 +200,3 @@\n-      if (ParallelScavengeHeap::heap()->promotion_should_fail()) {\n-        return oop_promotion_failed(o, test_mark);\n-      }\n+    if (ParallelScavengeHeap::heap()->promotion_should_fail()) {\n+      return oop_promotion_failed(o, test_mark);\n+    }\n@@ -190,13 +205,2 @@\n-      new_obj = cast_to_oop(_old_lab.allocate(new_obj_size));\n-      new_obj_is_tenured = true;\n-\n-      if (new_obj == NULL) {\n-        if (!_old_gen_is_full) {\n-          \/\/ Do we allocate directly, or flush and refill?\n-          if (new_obj_size > (OldPLABSize \/ 2)) {\n-            \/\/ Allocate this object directly\n-            new_obj = cast_to_oop(old_gen()->allocate(new_obj_size));\n-            promotion_trace_event(new_obj, o, new_obj_size, age, true, NULL);\n-          } else {\n-            \/\/ Flush and fill\n-            _old_lab.flush();\n+    new_obj = cast_to_oop(_old_lab.allocate(new_obj_size));\n+    new_obj_is_tenured = true;\n@@ -204,2 +208,13 @@\n-            HeapWord* lab_base = old_gen()->allocate(OldPLABSize);\n-            if(lab_base != NULL) {\n+    if (new_obj == NULL) {\n+      if (!_old_gen_is_full) {\n+        \/\/ Do we allocate directly, or flush and refill?\n+        if (new_obj_size > (OldPLABSize \/ 2)) {\n+          \/\/ Allocate this object directly\n+          new_obj = cast_to_oop(old_gen()->allocate(new_obj_size));\n+          promotion_trace_event(new_obj, o, new_obj_size, age, true, NULL);\n+        } else {\n+          \/\/ Flush and fill\n+          _old_lab.flush();\n+\n+          HeapWord* lab_base = old_gen()->allocate(OldPLABSize);\n+          if(lab_base != NULL) {\n@@ -207,10 +222,4 @@\n-              \/\/ Delay the initialization of the promotion lab (plab).\n-              \/\/ This exposes uninitialized plabs to card table processing.\n-              if (GCWorkerDelayMillis > 0) {\n-                os::naked_sleep(GCWorkerDelayMillis);\n-              }\n-#endif\n-              _old_lab.initialize(MemRegion(lab_base, OldPLABSize));\n-              \/\/ Try the old lab allocation again.\n-              new_obj = cast_to_oop(_old_lab.allocate(new_obj_size));\n-              promotion_trace_event(new_obj, o, new_obj_size, age, true, &_old_lab);\n+            \/\/ Delay the initialization of the promotion lab (plab).\n+            \/\/ This exposes uninitialized plabs to card table processing.\n+            if (GCWorkerDelayMillis > 0) {\n+              os::naked_sleep(GCWorkerDelayMillis);\n@@ -218,0 +227,5 @@\n+#endif\n+            _old_lab.initialize(MemRegion(lab_base, OldPLABSize));\n+            \/\/ Try the old lab allocation again.\n+            new_obj = cast_to_oop(_old_lab.allocate(new_obj_size));\n+            promotion_trace_event(new_obj, o, new_obj_size, age, true, &_old_lab);\n@@ -220,0 +234,1 @@\n+      }\n@@ -221,5 +236,5 @@\n-        \/\/ This is the promotion failed test, and code handling.\n-        \/\/ The code belongs here for two reasons. It is slightly\n-        \/\/ different than the code below, and cannot share the\n-        \/\/ CAS testing code. Keeping the code here also minimizes\n-        \/\/ the impact on the common case fast path code.\n+      \/\/ This is the promotion failed test, and code handling.\n+      \/\/ The code belongs here for two reasons. It is slightly\n+      \/\/ different than the code below, and cannot share the\n+      \/\/ CAS testing code. Keeping the code here also minimizes\n+      \/\/ the impact on the common case fast path code.\n@@ -227,4 +242,3 @@\n-        if (new_obj == NULL) {\n-          _old_gen_is_full = true;\n-          return oop_promotion_failed(o, test_mark);\n-        }\n+      if (new_obj == NULL) {\n+        _old_gen_is_full = true;\n+        return oop_promotion_failed(o, test_mark);\n@@ -233,0 +247,1 @@\n+  }\n@@ -234,1 +249,1 @@\n-    assert(new_obj != NULL, \"allocation should have succeeded\");\n+  assert(new_obj != NULL, \"allocation should have succeeded\");\n@@ -236,2 +251,2 @@\n-    \/\/ Copy obj\n-    Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(o), cast_from_oop<HeapWord*>(new_obj), new_obj_size);\n+  \/\/ Copy obj\n+  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(o), cast_from_oop<HeapWord*>(new_obj), new_obj_size);\n@@ -239,5 +254,6 @@\n-    \/\/ Now we have to CAS in the header.\n-    \/\/ Make copy visible to threads reading the forwardee.\n-    if (o->cas_forward_to(new_obj, test_mark, memory_order_release)) {\n-      \/\/ We won any races, we \"own\" this object.\n-      assert(new_obj == o->forwardee(), \"Sanity\");\n+  \/\/ Now we have to CAS in the header.\n+  \/\/ Make copy visible to threads reading the forwardee.\n+  oop forwardee = o->forward_to_atomic(new_obj, test_mark, memory_order_release);\n+  if (forwardee == NULL) {  \/\/ forwardee is NULL when forwarding is successful\n+    \/\/ We won any races, we \"own\" this object.\n+    assert(new_obj == o->forwardee(), \"Sanity\");\n@@ -245,7 +261,7 @@\n-      \/\/ Increment age if obj still in new generation. Now that\n-      \/\/ we're dealing with a markWord that cannot change, it is\n-      \/\/ okay to use the non mt safe oop methods.\n-      if (!new_obj_is_tenured) {\n-        new_obj->incr_age();\n-        assert(young_space()->contains(new_obj), \"Attempt to push non-promoted obj\");\n-      }\n+    \/\/ Increment age if obj still in new generation. Now that\n+    \/\/ we're dealing with a markWord that cannot change, it is\n+    \/\/ okay to use the non mt safe oop methods.\n+    if (!new_obj_is_tenured) {\n+      new_obj->incr_age();\n+      assert(young_space()->contains(new_obj), \"Attempt to push non-promoted obj\");\n+    }\n@@ -253,26 +269,34 @@\n-      \/\/ Do the size comparison first with new_obj_size, which we\n-      \/\/ already have. Hopefully, only a few objects are larger than\n-      \/\/ _min_array_size_for_chunking, and most of them will be arrays.\n-      \/\/ So, the is->objArray() test would be very infrequent.\n-      if (new_obj_size > _min_array_size_for_chunking &&\n-          new_obj->is_objArray() &&\n-          PSChunkLargeArrays) {\n-        \/\/ we'll chunk it\n-        push_depth(ScannerTask(PartialArrayScanTask(o)));\n-        TASKQUEUE_STATS_ONLY(++_arrays_chunked; ++_array_chunk_pushes);\n-      } else {\n-        \/\/ we'll just push its contents\n-        push_contents(new_obj);\n-      }\n-    }  else {\n-      \/\/ We lost, someone else \"owns\" this object\n-      guarantee(o->is_forwarded(), \"Object must be forwarded if the cas failed.\");\n-\n-      \/\/ Try to deallocate the space.  If it was directly allocated we cannot\n-      \/\/ deallocate it, so we have to test.  If the deallocation fails,\n-      \/\/ overwrite with a filler object.\n-      if (new_obj_is_tenured) {\n-        if (!_old_lab.unallocate_object(cast_from_oop<HeapWord*>(new_obj), new_obj_size)) {\n-          CollectedHeap::fill_with_object(cast_from_oop<HeapWord*>(new_obj), new_obj_size);\n-        }\n-      } else if (!_young_lab.unallocate_object(cast_from_oop<HeapWord*>(new_obj), new_obj_size)) {\n+    log_develop_trace(gc, scavenge)(\"{%s %s \" PTR_FORMAT \" -> \" PTR_FORMAT \" (%d)}\",\n+                                    new_obj_is_tenured ? \"copying\" : \"tenuring\",\n+                                    new_obj->klass()->internal_name(),\n+                                    p2i((void *)o), p2i((void *)new_obj), new_obj->size());\n+\n+    \/\/ Do the size comparison first with new_obj_size, which we\n+    \/\/ already have. Hopefully, only a few objects are larger than\n+    \/\/ _min_array_size_for_chunking, and most of them will be arrays.\n+    \/\/ So, the is->objArray() test would be very infrequent.\n+    if (new_obj_size > _min_array_size_for_chunking &&\n+        new_obj->is_objArray() &&\n+        PSChunkLargeArrays) {\n+      \/\/ we'll chunk it\n+      push_depth(ScannerTask(PartialArrayScanTask(o)));\n+      TASKQUEUE_STATS_ONLY(++_arrays_chunked; ++_array_chunk_pushes);\n+    } else {\n+      \/\/ we'll just push its contents\n+      push_contents(new_obj);\n+    }\n+    return new_obj;\n+  } else {\n+    \/\/ We lost, someone else \"owns\" this object.\n+    \/\/ Ensure loads from the forwardee follow all changes that preceeded the\n+    \/\/ release-cmpxchg that performed the forwarding in another thread.\n+    OrderAccess::acquire();\n+\n+    assert(o->is_forwarded(), \"Object must be forwarded if the cas failed.\");\n+    assert(o->forwardee() == forwardee, \"invariant\");\n+\n+    \/\/ Try to deallocate the space.  If it was directly allocated we cannot\n+    \/\/ deallocate it, so we have to test.  If the deallocation fails,\n+    \/\/ overwrite with a filler object.\n+    if (new_obj_is_tenured) {\n+      if (!_old_lab.unallocate_object(cast_from_oop<HeapWord*>(new_obj), new_obj_size)) {\n@@ -281,4 +305,2 @@\n-\n-      \/\/ don't update this before the unallocation!\n-      \/\/ Using acquire though consume would be accurate for accessing new_obj.\n-      new_obj = o->forwardee_acquire();\n+    } else if (!_young_lab.unallocate_object(cast_from_oop<HeapWord*>(new_obj), new_obj_size)) {\n+      CollectedHeap::fill_with_object(cast_from_oop<HeapWord*>(new_obj), new_obj_size);\n@@ -286,3 +308,1 @@\n-  } else {\n-    assert(o->is_forwarded(), \"Sanity\");\n-    new_obj = o->forwardee_acquire();\n+    return forwardee;\n@@ -290,8 +310,0 @@\n-\n-  \/\/ This code must come after the CAS test, or it will print incorrect\n-  \/\/ information.\n-  log_develop_trace(gc, scavenge)(\"{%s %s \" PTR_FORMAT \" -> \" PTR_FORMAT \" (%d)}\",\n-                                  should_scavenge(&new_obj) ? \"copying\" : \"tenuring\",\n-                                  new_obj->klass()->internal_name(), p2i((void *)o), p2i((void *)new_obj), new_obj->size());\n-\n-  return new_obj;\n@@ -308,12 +320,1 @@\n-  oop new_obj = o->is_forwarded()\n-        ? o->forwardee()\n-        : copy_to_survivor_space<promote_immediately>(o);\n-\n-  \/\/ This code must come after the CAS test, or it will print incorrect\n-  \/\/ information.\n-  if (log_develop_is_enabled(Trace, gc, scavenge) && o->is_forwarded()) {\n-    log_develop_trace(gc, scavenge)(\"{%s %s \" PTR_FORMAT \" -> \" PTR_FORMAT \" (%d)}\",\n-                      \"forwarding\",\n-                      new_obj->klass()->internal_name(), p2i((void *)o), p2i((void *)new_obj), new_obj->size());\n-  }\n-\n+  oop new_obj = copy_to_survivor_space<promote_immediately>(o);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":143,"deletions":142,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -808,2 +808,1 @@\n-                           NULL,                       \/\/ header provides liveness info\n-                           false);\n+                           NULL);                      \/\/ header provides liveness info\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,2 +136,0 @@\n-  static void copy_and_push_safe_barrier_from_klass(PSPromotionManager* pm, oop* p);\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,0 +96,3 @@\n+    case _g1_compaction_pause:\n+      return \"G1 Compaction Pause\";\n+\n@@ -102,0 +105,3 @@\n+    case _g1_preventive_collection:\n+      return \"G1 Preventive Collection\";\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/gcCause.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+    _g1_compaction_pause,\n@@ -76,0 +77,1 @@\n+    _g1_preventive_collection,\n","filename":"src\/hotspot\/share\/gc\/shared\/gcCause.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n@@ -101,2 +100,1 @@\n-                                       BoolObjectClosure* is_alive_non_header,\n-                                       bool      adjust_no_of_processing_threads)  :\n+                                       BoolObjectClosure* is_alive_non_header)  :\n@@ -107,1 +105,0 @@\n-  _adjust_no_of_processing_threads(adjust_no_of_processing_threads),\n@@ -934,2 +931,1 @@\n-    Thread* thr = Thread::current();\n-    id = thr->as_Worker_thread()->id();\n+    id = WorkerThread::current()->id();\n@@ -1323,4 +1319,0 @@\n-  if (!_rp->adjust_no_of_processing_threads() || (ReferencesPerThread == 0)) {\n-    return;\n-  }\n-\n@@ -1328,1 +1320,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -209,1 +209,0 @@\n-  bool        _adjust_no_of_processing_threads; \/\/ allow dynamic adjustment of processing threads\n@@ -371,2 +370,1 @@\n-                     BoolObjectClosure* is_alive_non_header = NULL,\n-                     bool adjust_no_of_processing_threads = false);\n+                     BoolObjectClosure* is_alive_non_header = NULL);\n@@ -441,2 +439,0 @@\n-\n-  bool adjust_no_of_processing_threads() const { return _adjust_no_of_processing_threads; }\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1071,1 +1071,0 @@\n-    PhaseIterGVN* igvn = phase->is_IterGVN();\n@@ -1073,5 +1072,1 @@\n-      if (igvn != NULL) {\n-        n->set_req_X(1, in1, igvn);\n-      } else {\n-        n->set_req(1, in1);\n-      }\n+      n->set_req_X(1, in1, phase);\n@@ -1082,5 +1077,1 @@\n-      if (igvn != NULL) {\n-        n->set_req_X(2, in2, igvn);\n-      } else {\n-        n->set_req(2, in2);\n-      }\n+      n->set_req_X(2, in2, phase);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -57,5 +57,7 @@\n-\n-  if (UseLargePages && (MaxHeapSize \/ os::large_page_size()) < ShenandoahHeapRegion::MIN_NUM_REGIONS) {\n-    warning(\"Large pages size (\" SIZE_FORMAT \"K) is too large to afford page-sized regions, disabling uncommit\",\n-            os::large_page_size() \/ K);\n-    FLAG_SET_DEFAULT(ShenandoahUncommit, false);\n+  if (UseLargePages) {\n+    size_t large_page_size = os::large_page_size();\n+    if ((align_up(MaxHeapSize, large_page_size) \/ large_page_size) < ShenandoahHeapRegion::MIN_NUM_REGIONS) {\n+      warning(\"Large pages size (\" SIZE_FORMAT \"K) is too large to afford page-sized regions, disabling uncommit\",\n+              os::large_page_size() \/ K);\n+      FLAG_SET_DEFAULT(ShenandoahUncommit, false);\n+    }\n@@ -180,1 +182,1 @@\n-  ShenandoahHeapRegion::setup_sizes(MaxHeapSize);\n+  MaxHeapSize = ShenandoahHeapRegion::setup_sizes(MaxHeapSize);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -470,1 +470,1 @@\n-void ShenandoahHeapRegion::setup_sizes(size_t max_heap_size) {\n+size_t ShenandoahHeapRegion::setup_sizes(size_t max_heap_size) {\n@@ -545,4 +545,7 @@\n-  \/\/ Make sure region size is at least one large page, if enabled.\n-  \/\/ The heap sizes would be rounded by heap initialization code by\n-  \/\/ page size, so we need to round up the region size too, to cover\n-  \/\/ the heap exactly.\n+  \/\/ Make sure region size and heap size are page aligned.\n+  \/\/ If large pages are used, we ensure that region size is aligned to large page size if\n+  \/\/ heap size is large enough to accommodate minimal number of regions. Otherwise, we align\n+  \/\/ region size to regular page size.\n+\n+  \/\/ Figure out page size to use, and aligns up heap to page size\n+  int page_size = os::vm_page_size();\n@@ -550,1 +553,10 @@\n-    region_size = MAX2(region_size, os::large_page_size());\n+    size_t large_page_size = os::large_page_size();\n+    max_heap_size = align_up(max_heap_size, large_page_size);\n+    if ((max_heap_size \/ align_up(region_size, large_page_size)) >= MIN_NUM_REGIONS) {\n+      page_size = (int)large_page_size;\n+    } else {\n+      \/\/ Should have been checked during argument initialization\n+      assert(!ShenandoahUncommit, \"Uncommit requires region size aligns to large page size\");\n+    }\n+  } else {\n+    max_heap_size = align_up(max_heap_size, page_size);\n@@ -553,0 +565,3 @@\n+  \/\/ Align region size to page size\n+  region_size = align_up(region_size, page_size);\n+\n@@ -615,0 +630,2 @@\n+\n+  return max_heap_size;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -254,1 +254,2 @@\n-  static void setup_sizes(size_t max_heap_size);\n+  \/\/ Return adjusted max heap size\n+  static size_t setup_sizes(size_t max_heap_size);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+    _ZAddressMetadataMask(&ZAddressMetadataMask),\n+    _ZAddressMetadataFinalizable(&ZAddressMetadataFinalizable),\n","filename":"src\/hotspot\/share\/gc\/z\/vmStructs_z.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+  uintptr_t* _ZAddressMetadataMask;\n+  uintptr_t* _ZAddressMetadataFinalizable;\n@@ -58,0 +60,1 @@\n+typedef ZGranuleMap<ZForwarding*> ZGranuleMapForForwarding;\n@@ -65,0 +68,2 @@\n+  nonstatic_field(ZGlobalsForVMStructs,         _ZAddressMetadataMask, uintptr_t*)                   \\\n+  nonstatic_field(ZGlobalsForVMStructs,         _ZAddressMetadataFinalizable, uintptr_t*)            \\\n@@ -75,0 +80,2 @@\n+  nonstatic_field(ZHeap,                        _forwarding_table,    ZForwardingTable)              \\\n+  nonstatic_field(ZHeap,                        _relocate,            ZRelocate)                     \\\n@@ -88,0 +95,3 @@\n+  nonstatic_field(ZGranuleMapForForwarding,     _map,                 ZForwarding** const)           \\\n+                                                                                                     \\\n+  nonstatic_field(ZForwardingTable,             _map,                 ZGranuleMapForForwarding)      \\\n@@ -92,1 +102,6 @@\n-  nonstatic_field(ZForwarding,                  _entries,             const ZAttachedArrayForForwarding)\n+  nonstatic_field(ZForwarding,                  _virtual,             const ZVirtualMemory)          \\\n+  nonstatic_field(ZForwarding,                  _object_alignment_shift, const size_t)               \\\n+  volatile_nonstatic_field(ZForwarding,         _ref_count,           int)                           \\\n+  nonstatic_field(ZForwarding,                  _entries,             const ZAttachedArrayForForwarding) \\\n+  nonstatic_field(ZForwardingEntry,             _entry,               uint64_t)                      \\\n+  nonstatic_field(ZAttachedArrayForForwarding,  _length,              const size_t)\n@@ -115,0 +130,1 @@\n+  declare_toplevel_type(ZRelocate)                                                                   \\\n@@ -120,0 +136,1 @@\n+  declare_toplevel_type(ZGranuleMapForForwarding)                                                    \\\n","filename":"src\/hotspot\/share\/gc\/z\/vmStructs_z.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,6 @@\n+  \/\/ The heuristics used when UseDynamicNumberOfGCThreads is\n+  \/\/ enabled defaults to using a ZAllocationSpikeTolerance of 1.\n+  if (UseDynamicNumberOfGCThreads && FLAG_IS_DEFAULT(ZAllocationSpikeTolerance)) {\n+    FLAG_SET_DEFAULT(ZAllocationSpikeTolerance, 1);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zArguments.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+  friend class VMStructs;\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zAttachedArray.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-    _director(new ZDirector()),\n@@ -55,0 +54,1 @@\n+    _director(new ZDirector(_driver)),\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-  ZDirector*        _director;\n@@ -49,0 +48,1 @@\n+  ZDirector*        _director;\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"gc\/z\/zCollectedHeap.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"gc\/z\/zDriver.hpp\"\n@@ -33,1 +33,2 @@\n-const double ZDirector::one_in_1000 = 3.290527;\n+constexpr double one_in_1000 = 3.290527;\n+constexpr double sample_interval = 1.0 \/ ZStatAllocRate::sample_hz;\n@@ -35,2 +36,2 @@\n-ZDirector::ZDirector() :\n-    _relocation_headroom(ZHeuristics::relocation_headroom()),\n+ZDirector::ZDirector(ZDriver* driver) :\n+    _driver(driver),\n@@ -42,1 +43,1 @@\n-void ZDirector::sample_allocation_rate() const {\n+static void sample_allocation_rate() {\n@@ -47,1 +48,1 @@\n-  log_debug(gc, alloc)(\"Allocation Rate: %.3fMB\/s, Avg: %.3f(+\/-%.3f)MB\/s\",\n+  log_debug(gc, alloc)(\"Allocation Rate: %.1fMB\/s, Predicted: %.1fMB\/s, Avg: %.1f(+\/-%.1f)MB\/s\",\n@@ -49,0 +50,1 @@\n+                       ZStatAllocRate::predict() \/ M,\n@@ -50,1 +52,1 @@\n-                       ZStatAllocRate::avg_sd() \/ M);\n+                       ZStatAllocRate::sd() \/ M);\n@@ -53,4 +55,5 @@\n-bool ZDirector::rule_timer() const {\n-  if (ZCollectionInterval <= 0) {\n-    \/\/ Rule disabled\n-    return false;\n+static ZDriverRequest rule_allocation_stall() {\n+  \/\/ Perform GC if we've observed at least one allocation stall since\n+  \/\/ the last GC started.\n+  if (!ZHeap::heap()->has_alloc_stalled()) {\n+    return GCCause::_no_gc;\n@@ -59,6 +62,1 @@\n-  \/\/ Perform GC if timer has expired.\n-  const double time_since_last_gc = ZStatCycle::time_since_last();\n-  const double time_until_gc = ZCollectionInterval - time_since_last_gc;\n-\n-  log_debug(gc, director)(\"Rule: Timer, Interval: %.3fs, TimeUntilGC: %.3fs\",\n-                          ZCollectionInterval, time_until_gc);\n+  log_debug(gc, director)(\"Rule: Allocation Stall Observed\");\n@@ -66,1 +64,1 @@\n-  return time_until_gc <= 0;\n+  return GCCause::_z_allocation_stall;\n@@ -69,1 +67,1 @@\n-bool ZDirector::rule_warmup() const {\n+static ZDriverRequest rule_warmup() {\n@@ -72,1 +70,1 @@\n-    return false;\n+    return GCCause::_no_gc;\n@@ -86,1 +84,5 @@\n-  return used >= used_threshold;\n+  if (used < used_threshold) {\n+    return GCCause::_no_gc;\n+  }\n+\n+  return GCCause::_z_warmup;\n@@ -89,2 +91,2 @@\n-bool ZDirector::rule_allocation_rate() const {\n-  if (!ZStatCycle::is_normalized_duration_trustable()) {\n+static ZDriverRequest rule_timer() {\n+  if (ZCollectionInterval <= 0) {\n@@ -92,1 +94,148 @@\n-    return false;\n+    return GCCause::_no_gc;\n+  }\n+\n+  \/\/ Perform GC if timer has expired.\n+  const double time_since_last_gc = ZStatCycle::time_since_last();\n+  const double time_until_gc = ZCollectionInterval - time_since_last_gc;\n+\n+  log_debug(gc, director)(\"Rule: Timer, Interval: %.3fs, TimeUntilGC: %.3fs\",\n+                          ZCollectionInterval, time_until_gc);\n+\n+  if (time_until_gc > 0) {\n+    return GCCause::_no_gc;\n+  }\n+\n+  return GCCause::_z_timer;\n+}\n+\n+static double estimated_gc_workers(double serial_gc_time, double parallelizable_gc_time, double time_until_deadline) {\n+  const double parallelizable_time_until_deadline = MAX2(time_until_deadline - serial_gc_time, 0.001);\n+  return parallelizable_gc_time \/ parallelizable_time_until_deadline;\n+}\n+\n+static uint discrete_gc_workers(double gc_workers) {\n+  return clamp<uint>(ceil(gc_workers), 1, ConcGCThreads);\n+}\n+\n+static double select_gc_workers(double serial_gc_time, double parallelizable_gc_time, double alloc_rate_sd_percent, double time_until_oom) {\n+  \/\/ Use all workers until we're warm\n+  if (!ZStatCycle::is_warm()) {\n+    const double not_warm_gc_workers = ConcGCThreads;\n+    log_debug(gc, director)(\"Select GC Workers (Not Warm), GCWorkers: %.3f\", not_warm_gc_workers);\n+    return not_warm_gc_workers;\n+  }\n+\n+  \/\/ Calculate number of GC workers needed to avoid a long GC cycle and to avoid OOM.\n+  const double avoid_long_gc_workers = estimated_gc_workers(serial_gc_time, parallelizable_gc_time, 10 \/* seconds *\/);\n+  const double avoid_oom_gc_workers = estimated_gc_workers(serial_gc_time, parallelizable_gc_time, time_until_oom);\n+\n+  const double gc_workers = MAX2(avoid_long_gc_workers, avoid_oom_gc_workers);\n+  const uint actual_gc_workers = discrete_gc_workers(gc_workers);\n+  const uint last_gc_workers = ZStatCycle::last_active_workers();\n+\n+  \/\/ More than 15% division from the average is considered unsteady\n+  if (alloc_rate_sd_percent >= 0.15) {\n+    const double half_gc_workers = ConcGCThreads \/ 2.0;\n+    const double unsteady_gc_workers = MAX3<double>(gc_workers, last_gc_workers, half_gc_workers);\n+    log_debug(gc, director)(\"Select GC Workers (Unsteady), \"\n+                            \"AvoidLongGCWorkers: %.3f, AvoidOOMGCWorkers: %.3f, LastGCWorkers: %.3f, HalfGCWorkers: %.3f, GCWorkers: %.3f\",\n+                            avoid_long_gc_workers, avoid_oom_gc_workers, (double)last_gc_workers, half_gc_workers, unsteady_gc_workers);\n+    return unsteady_gc_workers;\n+  }\n+\n+  if (actual_gc_workers < last_gc_workers) {\n+    \/\/ Before decreasing number of GC workers compared to the previous GC cycle, check if the\n+    \/\/ next GC cycle will need to increase it again. If so, use the same number of GC workers\n+    \/\/ that will be needed in the next cycle.\n+    const double gc_duration_delta = (parallelizable_gc_time \/ actual_gc_workers) - (parallelizable_gc_time \/ last_gc_workers);\n+    const double additional_time_for_allocations = ZStatCycle::time_since_last() - gc_duration_delta - sample_interval;\n+    const double next_time_until_oom = time_until_oom + additional_time_for_allocations;\n+    const double next_avoid_oom_gc_workers = estimated_gc_workers(serial_gc_time, parallelizable_gc_time, next_time_until_oom);\n+\n+    \/\/ Add 0.5 to increase friction and avoid lowering too eagerly\n+    const double next_gc_workers = next_avoid_oom_gc_workers + 0.5;\n+    const double try_lowering_gc_workers = clamp<double>(next_gc_workers, actual_gc_workers, last_gc_workers);\n+\n+    log_debug(gc, director)(\"Select GC Workers (Try Lowering), \"\n+                           \"AvoidLongGCWorkers: %.3f, AvoidOOMGCWorkers: %.3f, NextAvoidOOMGCWorkers: %.3f, LastGCWorkers: %.3f, GCWorkers: %.3f\",\n+                            avoid_long_gc_workers, avoid_oom_gc_workers, next_avoid_oom_gc_workers, (double)last_gc_workers, try_lowering_gc_workers);\n+    return try_lowering_gc_workers;\n+  }\n+\n+  log_debug(gc, director)(\"Select GC Workers (Normal), \"\n+                         \"AvoidLongGCWorkers: %.3f, AvoidOOMGCWorkers: %.3f, LastGCWorkers: %.3f, GCWorkers: %.3f\",\n+                         avoid_long_gc_workers, avoid_oom_gc_workers, (double)last_gc_workers, gc_workers);\n+  return gc_workers;\n+}\n+\n+ZDriverRequest rule_allocation_rate_dynamic() {\n+  if (!ZStatCycle::is_time_trustable()) {\n+    \/\/ Rule disabled\n+    return GCCause::_no_gc;\n+  }\n+\n+  \/\/ Calculate amount of free memory available. Note that we take the\n+  \/\/ relocation headroom into account to avoid in-place relocation.\n+  const size_t soft_max_capacity = ZHeap::heap()->soft_max_capacity();\n+  const size_t used = ZHeap::heap()->used();\n+  const size_t free_including_headroom = soft_max_capacity - MIN2(soft_max_capacity, used);\n+  const size_t free = free_including_headroom - MIN2(free_including_headroom, ZHeuristics::relocation_headroom());\n+\n+  \/\/ Calculate time until OOM given the max allocation rate and the amount\n+  \/\/ of free memory. The allocation rate is a moving average and we multiply\n+  \/\/ that with an allocation spike tolerance factor to guard against unforeseen\n+  \/\/ phase changes in the allocate rate. We then add ~3.3 sigma to account for\n+  \/\/ the allocation rate variance, which means the probability is 1 in 1000\n+  \/\/ that a sample is outside of the confidence interval.\n+  const double alloc_rate_predict = ZStatAllocRate::predict();\n+  const double alloc_rate_avg = ZStatAllocRate::avg();\n+  const double alloc_rate_sd = ZStatAllocRate::sd();\n+  const double alloc_rate_sd_percent = alloc_rate_sd \/ (alloc_rate_avg + 1.0);\n+  const double alloc_rate = (MAX2(alloc_rate_predict, alloc_rate_avg) * ZAllocationSpikeTolerance) + (alloc_rate_sd * one_in_1000) + 1.0;\n+  const double time_until_oom = (free \/ alloc_rate) \/ (1.0 + alloc_rate_sd_percent);\n+\n+  \/\/ Calculate max serial\/parallel times of a GC cycle. The times are\n+  \/\/ moving averages, we add ~3.3 sigma to account for the variance.\n+  const double serial_gc_time = ZStatCycle::serial_time().davg() + (ZStatCycle::serial_time().dsd() * one_in_1000);\n+  const double parallelizable_gc_time = ZStatCycle::parallelizable_time().davg() + (ZStatCycle::parallelizable_time().dsd() * one_in_1000);\n+\n+  \/\/ Calculate number of GC workers needed to avoid OOM.\n+  const double gc_workers = select_gc_workers(serial_gc_time, parallelizable_gc_time, alloc_rate_sd_percent, time_until_oom);\n+\n+  \/\/ Convert to a discrete number of GC workers within limits.\n+  const uint actual_gc_workers = discrete_gc_workers(gc_workers);\n+\n+  \/\/ Calculate GC duration given number of GC workers needed.\n+  const double actual_gc_duration = serial_gc_time + (parallelizable_gc_time \/ actual_gc_workers);\n+  const uint last_gc_workers = ZStatCycle::last_active_workers();\n+\n+  \/\/ Calculate time until GC given the time until OOM and GC duration.\n+  \/\/ We also subtract the sample interval, so that we don't overshoot the\n+  \/\/ target time and end up starting the GC too late in the next interval.\n+  const double more_safety_for_fewer_workers = (ConcGCThreads - actual_gc_workers) * sample_interval;\n+  const double time_until_gc = time_until_oom - actual_gc_duration - sample_interval - more_safety_for_fewer_workers;\n+\n+  log_debug(gc, director)(\"Rule: Allocation Rate (Dynamic GC Workers), \"\n+                          \"MaxAllocRate: %.1fMB\/s (+\/-%.1f%%), Free: \" SIZE_FORMAT \"MB, GCCPUTime: %.3f, \"\n+                          \"GCDuration: %.3fs, TimeUntilOOM: %.3fs, TimeUntilGC: %.3fs, GCWorkers: %u -> %u\",\n+                          alloc_rate \/ M,\n+                          alloc_rate_sd_percent * 100,\n+                          free \/ M,\n+                          serial_gc_time + parallelizable_gc_time,\n+                          serial_gc_time + (parallelizable_gc_time \/ actual_gc_workers),\n+                          time_until_oom,\n+                          time_until_gc,\n+                          last_gc_workers,\n+                          actual_gc_workers);\n+\n+  if (actual_gc_workers <= last_gc_workers && time_until_gc > 0) {\n+    return ZDriverRequest(GCCause::_no_gc, actual_gc_workers);\n+  }\n+\n+  return ZDriverRequest(GCCause::_z_allocation_rate, actual_gc_workers);\n+}\n+\n+static ZDriverRequest rule_allocation_rate_static() {\n+  if (!ZStatCycle::is_time_trustable()) {\n+    \/\/ Rule disabled\n+    return GCCause::_no_gc;\n@@ -106,1 +255,1 @@\n-  const size_t free = free_including_headroom - MIN2(free_including_headroom, _relocation_headroom);\n+  const size_t free = free_including_headroom - MIN2(free_including_headroom, ZHeuristics::relocation_headroom());\n@@ -114,1 +263,1 @@\n-  const double max_alloc_rate = (ZStatAllocRate::avg() * ZAllocationSpikeTolerance) + (ZStatAllocRate::avg_sd() * one_in_1000);\n+  const double max_alloc_rate = (ZStatAllocRate::avg() * ZAllocationSpikeTolerance) + (ZStatAllocRate::sd() * one_in_1000);\n@@ -117,4 +266,7 @@\n-  \/\/ Calculate max duration of a GC cycle. The duration of GC is a moving\n-  \/\/ average, we add ~3.3 sigma to account for the GC duration variance.\n-  const AbsSeq& duration_of_gc = ZStatCycle::normalized_duration();\n-  const double max_duration_of_gc = duration_of_gc.davg() + (duration_of_gc.dsd() * one_in_1000);\n+  \/\/ Calculate max serial\/parallel times of a GC cycle. The times are\n+  \/\/ moving averages, we add ~3.3 sigma to account for the variance.\n+  const double serial_gc_time = ZStatCycle::serial_time().davg() + (ZStatCycle::serial_time().dsd() * one_in_1000);\n+  const double parallelizable_gc_time = ZStatCycle::parallelizable_time().davg() + (ZStatCycle::parallelizable_time().dsd() * one_in_1000);\n+\n+  \/\/ Calculate GC duration given number of GC workers needed.\n+  const double gc_duration = serial_gc_time + (parallelizable_gc_time \/ ConcGCThreads);\n@@ -125,2 +277,11 @@\n-  const double sample_interval = 1.0 \/ ZStatAllocRate::sample_hz;\n-  const double time_until_gc = time_until_oom - max_duration_of_gc - sample_interval;\n+  const double time_until_gc = time_until_oom - gc_duration - sample_interval;\n+\n+  log_debug(gc, director)(\"Rule: Allocation Rate (Static GC Workers), MaxAllocRate: %.1fMB\/s, Free: \" SIZE_FORMAT \"MB, GCDuration: %.3fs, TimeUntilGC: %.3fs\",\n+                          max_alloc_rate \/ M, free \/ M, gc_duration, time_until_gc);\n+\n+  if (time_until_gc > 0) {\n+    return GCCause::_no_gc;\n+  }\n+\n+  return GCCause::_z_allocation_rate;\n+}\n@@ -128,2 +289,29 @@\n-  log_debug(gc, director)(\"Rule: Allocation Rate, MaxAllocRate: %.3fMB\/s, Free: \" SIZE_FORMAT \"MB, MaxDurationOfGC: %.3fs, TimeUntilGC: %.3fs\",\n-                          max_alloc_rate \/ M, free \/ M, max_duration_of_gc, time_until_gc);\n+static ZDriverRequest rule_allocation_rate() {\n+  if (UseDynamicNumberOfGCThreads) {\n+    return rule_allocation_rate_dynamic();\n+  } else {\n+    return rule_allocation_rate_static();\n+  }\n+}\n+\n+static ZDriverRequest rule_high_usage() {\n+  \/\/ Perform GC if the amount of free memory is 5% or less. This is a preventive\n+  \/\/ meassure in the case where the application has a very low allocation rate,\n+  \/\/ such that the allocation rate rule doesn't trigger, but the amount of free\n+  \/\/ memory is still slowly but surely heading towards zero. In this situation,\n+  \/\/ we start a GC cycle to avoid a potential allocation stall later.\n+\n+  \/\/ Calculate amount of free memory available. Note that we take the\n+  \/\/ relocation headroom into account to avoid in-place relocation.\n+  const size_t soft_max_capacity = ZHeap::heap()->soft_max_capacity();\n+  const size_t used = ZHeap::heap()->used();\n+  const size_t free_including_headroom = soft_max_capacity - MIN2(soft_max_capacity, used);\n+  const size_t free = free_including_headroom - MIN2(free_including_headroom, ZHeuristics::relocation_headroom());\n+  const double free_percent = percent_of(free, soft_max_capacity);\n+\n+  log_debug(gc, director)(\"Rule: High Usage, Free: \" SIZE_FORMAT \"MB(%.1f%%)\",\n+                          free \/ M, free_percent);\n+\n+  if (free_percent > 5.0) {\n+    return GCCause::_no_gc;\n+  }\n@@ -131,1 +319,1 @@\n-  return time_until_gc <= 0;\n+  return GCCause::_z_high_usage;\n@@ -134,1 +322,1 @@\n-bool ZDirector::rule_proactive() const {\n+static ZDriverRequest rule_proactive() {\n@@ -137,1 +325,1 @@\n-    return false;\n+    return GCCause::_no_gc;\n@@ -160,1 +348,1 @@\n-    return false;\n+    return GCCause::_no_gc;\n@@ -165,3 +353,4 @@\n-  const AbsSeq& duration_of_gc = ZStatCycle::normalized_duration();\n-  const double max_duration_of_gc = duration_of_gc.davg() + (duration_of_gc.dsd() * one_in_1000);\n-  const double acceptable_gc_interval = max_duration_of_gc * ((assumed_throughput_drop_during_gc \/ acceptable_throughput_drop) - 1.0);\n+  const double serial_gc_time = ZStatCycle::serial_time().davg() + (ZStatCycle::serial_time().dsd() * one_in_1000);\n+  const double parallelizable_gc_time = ZStatCycle::parallelizable_time().davg() + (ZStatCycle::parallelizable_time().dsd() * one_in_1000);\n+  const double gc_duration = serial_gc_time + (parallelizable_gc_time \/ ConcGCThreads);\n+  const double acceptable_gc_interval = gc_duration * ((assumed_throughput_drop_during_gc \/ acceptable_throughput_drop) - 1.0);\n@@ -173,28 +362,2 @@\n-  return time_until_gc <= 0;\n-}\n-\n-bool ZDirector::rule_high_usage() const {\n-  \/\/ Perform GC if the amount of free memory is 5% or less. This is a preventive\n-  \/\/ meassure in the case where the application has a very low allocation rate,\n-  \/\/ such that the allocation rate rule doesn't trigger, but the amount of free\n-  \/\/ memory is still slowly but surely heading towards zero. In this situation,\n-  \/\/ we start a GC cycle to avoid a potential allocation stall later.\n-\n-  \/\/ Calculate amount of free memory available. Note that we take the\n-  \/\/ relocation headroom into account to avoid in-place relocation.\n-  const size_t soft_max_capacity = ZHeap::heap()->soft_max_capacity();\n-  const size_t used = ZHeap::heap()->used();\n-  const size_t free_including_headroom = soft_max_capacity - MIN2(soft_max_capacity, used);\n-  const size_t free = free_including_headroom - MIN2(free_including_headroom, _relocation_headroom);\n-  const double free_percent = percent_of(free, soft_max_capacity);\n-\n-  log_debug(gc, director)(\"Rule: High Usage, Free: \" SIZE_FORMAT \"MB(%.1f%%)\",\n-                          free \/ M, free_percent);\n-\n-  return free_percent <= 5.0;\n-}\n-\n-GCCause::Cause ZDirector::make_gc_decision() const {\n-  \/\/ Rule 0: Timer\n-  if (rule_timer()) {\n-    return GCCause::_z_timer;\n+  if (time_until_gc > 0) {\n+    return GCCause::_no_gc;\n@@ -203,14 +366,2 @@\n-  \/\/ Rule 1: Warmup\n-  if (rule_warmup()) {\n-    return GCCause::_z_warmup;\n-  }\n-\n-  \/\/ Rule 2: Allocation rate\n-  if (rule_allocation_rate()) {\n-    return GCCause::_z_allocation_rate;\n-  }\n-\n-  \/\/ Rule 3: Proactive\n-  if (rule_proactive()) {\n-    return GCCause::_z_proactive;\n-  }\n+  return GCCause::_z_proactive;\n+}\n@@ -218,3 +369,18 @@\n-  \/\/ Rule 4: High usage\n-  if (rule_high_usage()) {\n-    return GCCause::_z_high_usage;\n+static ZDriverRequest make_gc_decision() {\n+  \/\/ List of rules\n+  using ZDirectorRule = ZDriverRequest (*)();\n+  const ZDirectorRule rules[] = {\n+    rule_allocation_stall,\n+    rule_warmup,\n+    rule_timer,\n+    rule_allocation_rate,\n+    rule_high_usage,\n+    rule_proactive,\n+  };\n+\n+  \/\/ Execute rules\n+  for (size_t i = 0; i < ARRAY_SIZE(rules); i++) {\n+    const ZDriverRequest request = rules[i]();\n+    if (request.cause() != GCCause::_no_gc) {\n+      return request;\n+    }\n@@ -223,1 +389,0 @@\n-  \/\/ No GC\n@@ -231,3 +396,5 @@\n-    const GCCause::Cause cause = make_gc_decision();\n-    if (cause != GCCause::_no_gc) {\n-      ZCollectedHeap::heap()->collect(cause);\n+    if (!_driver->is_busy()) {\n+      const ZDriverRequest request = make_gc_decision();\n+      if (request.cause() != GCCause::_no_gc) {\n+        _driver->collect(request);\n+      }\n","filename":"src\/hotspot\/share\/gc\/z\/zDirector.cpp","additions":257,"deletions":90,"binary":false,"changes":347,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"gc\/shared\/gcCause.hpp\"\n@@ -31,0 +30,2 @@\n+class ZDriver;\n+\n@@ -33,13 +34,2 @@\n-  static const double one_in_1000;\n-\n-  const size_t _relocation_headroom;\n-  ZMetronome   _metronome;\n-\n-  void sample_allocation_rate() const;\n-\n-  bool rule_timer() const;\n-  bool rule_warmup() const;\n-  bool rule_allocation_rate() const;\n-  bool rule_proactive() const;\n-  bool rule_high_usage() const;\n-  GCCause::Cause make_gc_decision() const;\n+  ZDriver* const _driver;\n+  ZMetronome     _metronome;\n@@ -52,1 +42,1 @@\n-  ZDirector();\n+  ZDirector(ZDriver* driver);\n","filename":"src\/hotspot\/share\/gc\/z\/zDirector.hpp","additions":6,"deletions":16,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,22 @@\n+ZDriverRequest::ZDriverRequest() :\n+    ZDriverRequest(GCCause::_no_gc) {}\n+\n+ZDriverRequest::ZDriverRequest(GCCause::Cause cause) :\n+    ZDriverRequest(cause, ConcGCThreads) {}\n+\n+ZDriverRequest::ZDriverRequest(GCCause::Cause cause, uint nworkers) :\n+    _cause(cause),\n+    _nworkers(nworkers) {}\n+\n+bool ZDriverRequest::operator==(const ZDriverRequest& other) const {\n+  return _cause == other._cause;\n+}\n+\n+GCCause::Cause ZDriverRequest::cause() const {\n+  return _cause;\n+}\n+\n+uint ZDriverRequest::nworkers() const {\n+  return _nworkers;\n+}\n+\n@@ -121,41 +143,0 @@\n-static bool should_clear_soft_references() {\n-  \/\/ Clear if one or more allocations have stalled\n-  const bool stalled = ZHeap::heap()->is_alloc_stalled();\n-  if (stalled) {\n-    \/\/ Clear\n-    return true;\n-  }\n-\n-  \/\/ Clear if implied by the GC cause\n-  const GCCause::Cause cause = ZCollectedHeap::heap()->gc_cause();\n-  if (cause == GCCause::_wb_full_gc ||\n-      cause == GCCause::_metadata_GC_clear_soft_refs) {\n-    \/\/ Clear\n-    return true;\n-  }\n-\n-  \/\/ Don't clear\n-  return false;\n-}\n-\n-static bool should_boost_worker_threads() {\n-  \/\/ Boost worker threads if one or more allocations have stalled\n-  const bool stalled = ZHeap::heap()->is_alloc_stalled();\n-  if (stalled) {\n-    \/\/ Boost\n-    return true;\n-  }\n-\n-  \/\/ Boost worker threads if implied by the GC cause\n-  const GCCause::Cause cause = ZCollectedHeap::heap()->gc_cause();\n-  if (cause == GCCause::_wb_full_gc ||\n-      cause == GCCause::_java_lang_system_gc ||\n-      cause == GCCause::_metadata_GC_clear_soft_refs) {\n-    \/\/ Boost\n-    return true;\n-  }\n-\n-  \/\/ Don't boost\n-  return false;\n-}\n-\n@@ -176,8 +157,0 @@\n-    \/\/ Set up soft reference policy\n-    const bool clear = should_clear_soft_references();\n-    ZHeap::heap()->set_soft_reference_policy(clear);\n-\n-    \/\/ Set up boost mode\n-    const bool boost = should_boost_worker_threads();\n-    ZHeap::heap()->set_boost_worker_threads(boost);\n-\n@@ -244,2 +217,6 @@\n-void ZDriver::collect(GCCause::Cause cause) {\n-  switch (cause) {\n+bool ZDriver::is_busy() const {\n+  return _gc_cycle_port.is_busy();\n+}\n+\n+void ZDriver::collect(const ZDriverRequest& request) {\n+  switch (request.cause()) {\n@@ -256,1 +233,1 @@\n-    _gc_cycle_port.send_sync(cause);\n+    _gc_cycle_port.send_sync(request);\n@@ -267,1 +244,1 @@\n-    _gc_cycle_port.send_async(cause);\n+    _gc_cycle_port.send_async(request);\n@@ -277,1 +254,1 @@\n-    _gc_cycle_port.send_async(cause);\n+    _gc_cycle_port.send_async(request);\n@@ -282,1 +259,1 @@\n-    fatal(\"Unsupported GC cause (%s)\", GCCause::to_string(cause));\n+    fatal(\"Unsupported GC cause (%s)\", GCCause::to_string(request.cause()));\n@@ -372,0 +349,44 @@\n+static bool should_clear_soft_references(const ZDriverRequest& request) {\n+  \/\/ Clear soft references if implied by the GC cause\n+  if (request.cause() == GCCause::_wb_full_gc ||\n+      request.cause() == GCCause::_metadata_GC_clear_soft_refs ||\n+      request.cause() == GCCause::_z_allocation_stall) {\n+    \/\/ Clear\n+    return true;\n+  }\n+\n+  \/\/ Don't clear\n+  return false;\n+}\n+\n+static uint select_active_worker_threads_dynamic(const ZDriverRequest& request) {\n+  \/\/ Use requested number of worker threads\n+  return request.nworkers();\n+}\n+\n+static uint select_active_worker_threads_static(const ZDriverRequest& request) {\n+  const GCCause::Cause cause = request.cause();\n+  const uint nworkers = request.nworkers();\n+\n+  \/\/ Boost number of worker threads if implied by the GC cause\n+  if (cause == GCCause::_wb_full_gc ||\n+      cause == GCCause::_java_lang_system_gc ||\n+      cause == GCCause::_metadata_GC_clear_soft_refs ||\n+      cause == GCCause::_z_allocation_stall) {\n+    \/\/ Boost\n+    const uint boosted_nworkers = MAX2(nworkers, ParallelGCThreads);\n+    return boosted_nworkers;\n+  }\n+\n+  \/\/ Use requested number of worker threads\n+  return nworkers;\n+}\n+\n+static uint select_active_worker_threads(const ZDriverRequest& request) {\n+  if (UseDynamicNumberOfGCThreads) {\n+    return select_active_worker_threads_dynamic(request);\n+  } else {\n+    return select_active_worker_threads_static(request);\n+  }\n+}\n+\n@@ -381,1 +402,1 @@\n-  ZDriverGCScope(GCCause::Cause cause) :\n+  ZDriverGCScope(const ZDriverRequest& request) :\n@@ -383,2 +404,2 @@\n-      _gc_cause(cause),\n-      _gc_cause_setter(ZCollectedHeap::heap(), cause),\n+      _gc_cause(request.cause()),\n+      _gc_cause_setter(ZCollectedHeap::heap(), _gc_cause),\n@@ -389,0 +410,8 @@\n+\n+    \/\/ Set up soft reference policy\n+    const bool clear = should_clear_soft_references(request);\n+    ZHeap::heap()->set_soft_reference_policy(clear);\n+\n+    \/\/ Select number of worker threads to use\n+    const uint nworkers = select_active_worker_threads(request);\n+    ZHeap::heap()->set_active_workers(nworkers);\n@@ -392,4 +421,0 @@\n-    \/\/ Calculate boost factor\n-    const double boost_factor = (double)ZHeap::heap()->nconcurrent_worker_threads() \/\n-                                (double)ZHeap::heap()->nconcurrent_no_boost_worker_threads();\n-\n@@ -397,1 +422,1 @@\n-    ZStatCycle::at_end(_gc_cause, boost_factor);\n+    ZStatCycle::at_end(_gc_cause, ZHeap::heap()->active_workers());\n@@ -420,2 +445,2 @@\n-void ZDriver::gc(GCCause::Cause cause) {\n-  ZDriverGCScope scope(cause);\n+void ZDriver::gc(const ZDriverRequest& request) {\n+  ZDriverGCScope scope(request);\n@@ -461,2 +486,2 @@\n-    const GCCause::Cause cause = _gc_cycle_port.receive();\n-    if (cause == GCCause::_no_gc) {\n+    const ZDriverRequest request = _gc_cycle_port.receive();\n+    if (request.cause() == GCCause::_no_gc) {\n@@ -469,1 +494,1 @@\n-    gc(cause);\n+    gc(request);\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.cpp","additions":94,"deletions":69,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,16 @@\n+class ZDriverRequest {\n+private:\n+  GCCause::Cause _cause;\n+  uint           _nworkers;\n+\n+public:\n+  ZDriverRequest();\n+  ZDriverRequest(GCCause::Cause cause);\n+  ZDriverRequest(GCCause::Cause cause, uint nworkers);\n+\n+  bool operator==(const ZDriverRequest& other) const;\n+\n+  GCCause::Cause cause() const;\n+  uint nworkers() const;\n+};\n+\n@@ -35,1 +51,1 @@\n-  ZMessagePort<GCCause::Cause> _gc_cycle_port;\n+  ZMessagePort<ZDriverRequest> _gc_cycle_port;\n@@ -54,1 +70,1 @@\n-  void gc(GCCause::Cause cause);\n+  void gc(const ZDriverRequest& request);\n@@ -63,1 +79,3 @@\n-  void collect(GCCause::Cause cause);\n+  bool is_busy() const;\n+\n+  void collect(const ZDriverRequest& request);\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.hpp","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+  friend class VMStructs;\n","filename":"src\/hotspot\/share\/gc\/z\/zForwardingEntry.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+  friend class VMStructs;\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zForwardingTable.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -42,1 +43,1 @@\n-#include \"gc\/z\/zWorkers.inline.hpp\"\n+#include \"gc\/z\/zWorkers.hpp\"\n@@ -151,2 +152,2 @@\n-uint ZHeap::nconcurrent_worker_threads() const {\n-  return _workers.nconcurrent();\n+uint ZHeap::active_workers() const {\n+  return _workers.active_workers();\n@@ -155,6 +156,2 @@\n-uint ZHeap::nconcurrent_no_boost_worker_threads() const {\n-  return _workers.nconcurrent_no_boost();\n-}\n-\n-void ZHeap::set_boost_worker_threads(bool boost) {\n-  _workers.set_boost(boost);\n+void ZHeap::set_active_workers(uint nworkers) {\n+  _workers.set_active_workers(nworkers);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -96,3 +96,2 @@\n-  uint nconcurrent_worker_threads() const;\n-  uint nconcurrent_no_boost_worker_threads() const;\n-  void set_boost_worker_threads(bool boost);\n+  uint active_workers() const;\n+  void set_active_workers(uint nworkers);\n@@ -119,1 +118,1 @@\n-  bool is_alloc_stalled() const;\n+  bool has_alloc_stalled() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -121,2 +121,2 @@\n-inline bool ZHeap::is_alloc_stalled() const {\n-  return _page_allocator.is_alloc_stalled();\n+inline bool ZHeap::has_alloc_stalled() const {\n+  return _page_allocator.has_alloc_stalled();\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,2 @@\n-  return (MAX2(ParallelGCThreads, ConcGCThreads) * ZPageSizeSmall) + ZPageSizeMedium;\n+  const uint nworkers = UseDynamicNumberOfGCThreads ? ConcGCThreads : MAX2(ConcGCThreads, ParallelGCThreads);\n+  return (nworkers * ZPageSizeSmall) + ZPageSizeMedium;\n@@ -96,7 +97,7 @@\n-  \/\/ Use 12.5% of the CPUs, rounded up. The number of concurrent threads we\n-  \/\/ would like to use heavily depends on the type of workload we are running.\n-  \/\/ Using too many threads will have a negative impact on the application\n-  \/\/ throughput, while using too few threads will prolong the GC-cycle and\n-  \/\/ we then risk being out-run by the application. Using 12.5% of the active\n-  \/\/ processors appears to be a fairly good balance.\n-  return nworkers(12.5);\n+  \/\/ The number of concurrent threads we would like to use heavily depends\n+  \/\/ on the type of workload we are running. Using too many threads will have\n+  \/\/ a negative impact on the application throughput, while using too few\n+  \/\/ threads will prolong the GC-cycle and we then risk being out-run by the\n+  \/\/ application. When in dynamic mode, use up to 25% of the active processors.\n+  \/\/  When in non-dynamic mode, use 12.5% of the active processors.\n+  return nworkers(UseDynamicNumberOfGCThreads ? 25.0 : 12.5);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeuristics.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -48,1 +49,1 @@\n-#include \"gc\/z\/zWorkers.inline.hpp\"\n+#include \"gc\/z\/zWorkers.hpp\"\n@@ -114,1 +115,1 @@\n-  _nworkers = _workers->nconcurrent();\n+  _nworkers = _workers->active_workers();\n@@ -138,1 +139,1 @@\n-  assert(_nworkers == _workers->nconcurrent(), \"Invalid number of workers\");\n+  assert(_nworkers == _workers->active_workers(), \"Invalid number of workers\");\n@@ -720,1 +721,1 @@\n-    _workers->run_concurrent(&task);\n+    _workers->run(&task);\n@@ -724,1 +725,1 @@\n-  _workers->run_concurrent(&task);\n+  _workers->run(&task);\n@@ -733,1 +734,1 @@\n-  _workers->run_concurrent(&task);\n+  _workers->run(&task);\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,5 +38,5 @@\n-  Monitor        _monitor;\n-  bool           _has_message;\n-  T              _message;\n-  uint64_t       _seqnum;\n-  ZList<Request> _queue;\n+  mutable Monitor _monitor;\n+  bool            _has_message;\n+  T               _message;\n+  uint64_t        _seqnum;\n+  ZList<Request>  _queue;\n@@ -47,2 +47,4 @@\n-  void send_sync(T message);\n-  void send_async(T message);\n+  bool is_busy() const;\n+\n+  void send_sync(const T& message);\n+  void send_async(const T& message);\n","filename":"src\/hotspot\/share\/gc\/z\/zMessagePort.hpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,7 @@\n-inline void ZMessagePort<T>::send_sync(T message) {\n+inline bool ZMessagePort<T>::is_busy() const {\n+  MonitorLocker ml(&_monitor, Monitor::_no_safepoint_check_flag);\n+  return _has_message;\n+}\n+\n+template <typename T>\n+inline void ZMessagePort<T>::send_sync(const T& message) {\n@@ -105,1 +111,1 @@\n-inline void ZMessagePort<T>::send_async(T message) {\n+inline void ZMessagePort<T>::send_async(const T& message) {\n","filename":"src\/hotspot\/share\/gc\/z\/zMessagePort.inline.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -379,1 +379,1 @@\n-      workers->run_concurrent(&task);\n+      workers->run(&task);\n@@ -424,1 +424,1 @@\n-  workers->run_concurrent(&task);\n+  workers->run(&task);\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,0 +148,1 @@\n+    _nstalled(0),\n@@ -227,1 +228,1 @@\n-    workers->run_parallel(&task);\n+    workers->run_all(&task);\n@@ -286,0 +287,1 @@\n+  _nstalled = 0;\n@@ -451,0 +453,3 @@\n+  \/\/ Increment stalled counter\n+  Atomic::inc(&_nstalled);\n+\n@@ -651,1 +656,1 @@\n-  if (!flags.worker_relocation()) {\n+  if (!flags.worker_relocation() && is_init_completed()) {\n@@ -807,3 +812,2 @@\n-bool ZPageAllocator::is_alloc_stalled() const {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"Should be at safepoint\");\n-  return !_stalled.is_empty();\n+bool ZPageAllocator::has_alloc_stalled() const {\n+  return Atomic::load(&_nstalled) != 0;\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,1 @@\n+  volatile uint64_t          _nstalled;\n@@ -130,1 +131,1 @@\n-  bool is_alloc_stalled() const;\n+  bool has_alloc_stalled() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -428,1 +428,1 @@\n-  _workers->run_concurrent(&task);\n+  _workers->run(&task);\n","filename":"src\/hotspot\/share\/gc\/z\/zReferenceProcessor.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -418,1 +418,1 @@\n-  _workers->run_concurrent(&task);\n+  _workers->run(&task);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,1 +118,1 @@\n-  _workers->run_concurrent(&task);\n+  _workers->run(&task);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-             nworkers(),\n+             ParallelGCThreads,\n@@ -66,1 +66,1 @@\n-  log_info_p(gc, init)(\"Runtime Workers: %u parallel\", nworkers());\n+  log_info_p(gc, init)(\"Runtime Workers: %u\", _workers.total_workers());\n@@ -70,2 +70,2 @@\n-  _workers.update_active_workers(nworkers());\n-  if (_workers.active_workers() != nworkers()) {\n+  _workers.update_active_workers(_workers.total_workers());\n+  if (_workers.active_workers() != _workers.total_workers()) {\n@@ -77,1 +77,1 @@\n-  ZRuntimeWorkersInitializeTask task(nworkers());\n+  ZRuntimeWorkersInitializeTask task(_workers.total_workers());\n@@ -81,4 +81,0 @@\n-uint ZRuntimeWorkers::nworkers() const {\n-  return ParallelGCThreads;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zRuntimeWorkers.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,0 @@\n-  uint nworkers() const;\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zRuntimeWorkers.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -833,2 +833,2 @@\n-TruncatedSeq                ZStatAllocRate::_rate(ZStatAllocRate::sample_window_sec * ZStatAllocRate::sample_hz);\n-TruncatedSeq                ZStatAllocRate::_rate_avg(ZStatAllocRate::sample_window_sec * ZStatAllocRate::sample_hz);\n+TruncatedSeq                ZStatAllocRate::_samples(ZStatAllocRate::sample_hz);\n+TruncatedSeq                ZStatAllocRate::_rate(ZStatAllocRate::sample_hz);\n@@ -842,1 +842,1 @@\n-  const uint64_t bytes_per_second = bytes_per_sample._counter * sample_hz;\n+  _samples.add(bytes_per_sample._counter);\n@@ -844,0 +844,1 @@\n+  const uint64_t bytes_per_second = _samples.sum();\n@@ -845,1 +846,0 @@\n-  _rate_avg.add(_rate.avg());\n@@ -850,0 +850,4 @@\n+double ZStatAllocRate::predict() {\n+  return _rate.predict_next();\n+}\n+\n@@ -854,2 +858,2 @@\n-double ZStatAllocRate::avg_sd() {\n-  return _rate_avg.sd();\n+double ZStatAllocRate::sd() {\n+  return _rate.sd();\n@@ -1061,1 +1065,3 @@\n-NumberSeq ZStatCycle::_normalized_duration(0.7 \/* alpha *\/);\n+NumberSeq ZStatCycle::_serial_time(0.7 \/* alpha *\/);\n+NumberSeq ZStatCycle::_parallelizable_time(0.7 \/* alpha *\/);\n+uint      ZStatCycle::_last_active_workers = 0;\n@@ -1067,1 +1073,1 @@\n-void ZStatCycle::at_end(GCCause::Cause cause, double boost_factor) {\n+void ZStatCycle::at_end(GCCause::Cause cause, uint active_workers) {\n@@ -1074,3 +1080,3 @@\n-  \/\/ Calculate normalized cycle duration. The measured duration is\n-  \/\/ normalized using the boost factor to avoid artificial deflation\n-  \/\/ of the duration when boost mode is enabled.\n+  _last_active_workers = active_workers;\n+\n+  \/\/ Calculate serial and parallelizable GC cycle times\n@@ -1078,2 +1084,5 @@\n-  const double normalized_duration = duration * boost_factor;\n-  _normalized_duration.add(normalized_duration);\n+  const double workers_duration = ZStatWorkers::get_and_reset_duration();\n+  const double serial_time = duration - workers_duration;\n+  const double parallelizable_time = workers_duration * active_workers;\n+  _serial_time.add(serial_time);\n+  _parallelizable_time.add(parallelizable_time);\n@@ -1090,3 +1099,3 @@\n-bool ZStatCycle::is_normalized_duration_trustable() {\n-  \/\/ The normalized duration is considered trustable if we have\n-  \/\/ completed at least one warmup cycle\n+bool ZStatCycle::is_time_trustable() {\n+  \/\/ The times are considered trustable if we\n+  \/\/ have completed at least one warmup cycle.\n@@ -1096,2 +1105,10 @@\n-const AbsSeq& ZStatCycle::normalized_duration() {\n-  return _normalized_duration;\n+const AbsSeq& ZStatCycle::serial_time() {\n+  return _serial_time;\n+}\n+\n+const AbsSeq& ZStatCycle::parallelizable_time() {\n+  return _parallelizable_time;\n+}\n+\n+uint ZStatCycle::last_active_workers() {\n+  return _last_active_workers;\n@@ -1110,0 +1127,23 @@\n+\n+\/\/\n+\/\/ Stat workers\n+\/\/\n+Ticks ZStatWorkers::_start_of_last;\n+Tickspan ZStatWorkers::_accumulated_duration;\n+\n+void ZStatWorkers::at_start() {\n+  _start_of_last = Ticks::now();\n+}\n+\n+void ZStatWorkers::at_end() {\n+  const Ticks now = Ticks::now();\n+  const Tickspan duration = now - _start_of_last;\n+  _accumulated_duration += duration;\n+}\n+\n+double ZStatWorkers::get_and_reset_duration() {\n+  const double duration = _accumulated_duration.seconds();\n+  const Ticks now = Ticks::now();\n+  _accumulated_duration = now - now;\n+  return duration;\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.cpp","additions":58,"deletions":18,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -334,2 +334,2 @@\n-  static TruncatedSeq                _rate;     \/\/ B\/s\n-  static TruncatedSeq                _rate_avg; \/\/ B\/s\n+  static TruncatedSeq                _samples;\n+  static TruncatedSeq                _rate;\n@@ -338,2 +338,1 @@\n-  static const uint64_t sample_window_sec = 1; \/\/ seconds\n-  static const uint64_t sample_hz         = 10;\n+  static const uint64_t sample_hz = 10;\n@@ -344,0 +343,1 @@\n+  static double predict();\n@@ -345,1 +345,1 @@\n-  static double avg_sd();\n+  static double sd();\n@@ -377,1 +377,3 @@\n-  static NumberSeq _normalized_duration;\n+  static NumberSeq _serial_time;\n+  static NumberSeq _parallelizable_time;\n+  static uint      _last_active_workers;\n@@ -381,1 +383,1 @@\n-  static void at_end(GCCause::Cause cause, double boost_factor);\n+  static void at_end(GCCause::Cause cause, uint active_workers);\n@@ -386,2 +388,5 @@\n-  static bool is_normalized_duration_trustable();\n-  static const AbsSeq& normalized_duration();\n+  static bool is_time_trustable();\n+  static const AbsSeq& serial_time();\n+  static const AbsSeq& parallelizable_time();\n+\n+  static uint last_active_workers();\n@@ -392,0 +397,15 @@\n+\/\/\n+\/\/ Stat workers\n+\/\/\n+class ZStatWorkers : public AllStatic {\n+private:\n+  static Ticks    _start_of_last;\n+  static Tickspan _accumulated_duration;\n+\n+public:\n+  static void at_start();\n+  static void at_end();\n+\n+  static double get_and_reset_duration();\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.hpp","additions":29,"deletions":9,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-  return MAX2(ParallelGCThreads, ConcGCThreads);\n+  return UseDynamicNumberOfGCThreads ? ConcGCThreads : MAX2(ConcGCThreads, ParallelGCThreads);\n","filename":"src\/hotspot\/share\/gc\/z\/zValue.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-  _workers->run_concurrent(&task);\n+  _workers->run(&task);\n","filename":"src\/hotspot\/share\/gc\/z\/zWeakRootsProcessor.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -27,0 +28,1 @@\n+#include \"gc\/z\/zStat.hpp\"\n@@ -29,1 +31,1 @@\n-#include \"gc\/z\/zWorkers.inline.hpp\"\n+#include \"gc\/z\/zWorkers.hpp\"\n@@ -32,1 +34,1 @@\n-class ZWorkersInitializeTask : public ZTask {\n+class ZWorkersInitializeTask : public AbstractGangTask {\n@@ -40,1 +42,1 @@\n-      ZTask(\"ZWorkersInitializeTask\"),\n+      AbstractGangTask(\"ZWorkersInitializeTask\"),\n@@ -45,1 +47,1 @@\n-  virtual void work() {\n+  virtual void work(uint worker_id) {\n@@ -63,1 +65,0 @@\n-    _boost(false),\n@@ -65,1 +66,1 @@\n-             nworkers(),\n+             UseDynamicNumberOfGCThreads ? ConcGCThreads : MAX2(ConcGCThreads, ParallelGCThreads),\n@@ -69,1 +70,5 @@\n-  log_info_p(gc, init)(\"Workers: %u parallel, %u concurrent\", nparallel(), nconcurrent());\n+  if (UseDynamicNumberOfGCThreads) {\n+    log_info_p(gc, init)(\"GC Workers: %u (dynamic)\", _workers.total_workers());\n+  } else {\n+    log_info_p(gc, init)(\"GC Workers: %u\/%u (static)\", ConcGCThreads, _workers.total_workers());\n+  }\n@@ -73,2 +78,2 @@\n-  _workers.update_active_workers(nworkers());\n-  if (_workers.active_workers() != nworkers()) {\n+  _workers.update_active_workers(_workers.total_workers());\n+  if (_workers.active_workers() != _workers.total_workers()) {\n@@ -79,2 +84,2 @@\n-  ZWorkersInitializeTask task(nworkers());\n-  run(&task, nworkers());\n+  ZWorkersInitializeTask task(_workers.total_workers());\n+  _workers.run_task(&task);\n@@ -83,6 +88,2 @@\n-void ZWorkers::set_boost(bool boost) {\n-  if (boost) {\n-    log_debug(gc)(\"Boosting workers\");\n-  }\n-\n-  _boost = boost;\n+uint ZWorkers::active_workers() const {\n+  return _workers.active_workers();\n@@ -91,2 +92,2 @@\n-void ZWorkers::run(ZTask* task, uint nworkers) {\n-  log_debug(gc, task)(\"Executing Task: %s, Active Workers: %u\", task->name(), nworkers);\n+void ZWorkers::set_active_workers(uint nworkers) {\n+  log_info(gc, task)(\"Using %u workers\", nworkers);\n@@ -94,1 +95,0 @@\n-  _workers.run_task(task->gang_task());\n@@ -97,2 +97,5 @@\n-void ZWorkers::run_parallel(ZTask* task) {\n-  run(task, nparallel());\n+void ZWorkers::run(ZTask* task) {\n+  log_debug(gc, task)(\"Executing Task: %s, Active Workers: %u\", task->name(), active_workers());\n+  ZStatWorkers::at_start();\n+  _workers.run_task(task->gang_task());\n+  ZStatWorkers::at_end();\n@@ -101,2 +104,11 @@\n-void ZWorkers::run_concurrent(ZTask* task) {\n-  run(task, nconcurrent());\n+void ZWorkers::run_all(ZTask* task) {\n+  \/\/ Save number of active workers\n+  const uint prev_active_workers = _workers.active_workers();\n+\n+  \/\/ Execute task using all workers\n+  _workers.update_active_workers(_workers.total_workers());\n+  log_debug(gc, task)(\"Executing Task: %s, Active Workers: %u\", task->name(), active_workers());\n+  _workers.run_task(task->gang_task());\n+\n+  \/\/ Restore number of active workers\n+  _workers.update_active_workers(prev_active_workers);\n","filename":"src\/hotspot\/share\/gc\/z\/zWorkers.cpp","additions":37,"deletions":25,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-  bool     _boost;\n@@ -37,2 +36,0 @@\n-  void run(ZTask* task, uint nworkers);\n-\n@@ -42,7 +39,2 @@\n-  uint nparallel() const;\n-  uint nparallel_no_boost() const;\n-  uint nconcurrent() const;\n-  uint nconcurrent_no_boost() const;\n-  uint nworkers() const;\n-\n-  void set_boost(bool boost);\n+  uint active_workers() const;\n+  void set_active_workers(uint nworkers);\n@@ -50,2 +42,2 @@\n-  void run_parallel(ZTask* task);\n-  void run_concurrent(ZTask* task);\n+  void run(ZTask* task);\n+  void run_all(ZTask* task);\n","filename":"src\/hotspot\/share\/gc\/z\/zWorkers.hpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_GC_Z_ZWORKERS_INLINE_HPP\n-#define SHARE_GC_Z_ZWORKERS_INLINE_HPP\n-\n-#include \"gc\/z\/zWorkers.hpp\"\n-\n-#include \"gc\/shared\/gc_globals.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-inline uint ZWorkers::nparallel() const {\n-  return _boost ? nworkers() : nparallel_no_boost();\n-}\n-\n-inline uint ZWorkers::nparallel_no_boost() const {\n-  return ParallelGCThreads;\n-}\n-\n-inline uint ZWorkers::nconcurrent() const {\n-  return _boost ? nworkers() : nconcurrent_no_boost();\n-}\n-\n-inline uint ZWorkers::nconcurrent_no_boost() const {\n-  return ConcGCThreads;\n-}\n-\n-inline uint ZWorkers::nworkers() const {\n-  return MAX2(ParallelGCThreads, ConcGCThreads);\n-}\n-\n-#endif \/\/ SHARE_GC_Z_ZWORKERS_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/z\/zWorkers.inline.hpp","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -173,5 +173,5 @@\n-                                         jstring invokedName,\n-                                         jobject invokedType,\n-                                         jobject methodType,\n-                                         jobject implMethodMember,\n-                                         jobject instantiatedMethodType,\n+                                         jstring interfaceMethodName,\n+                                         jobject factoryType,\n+                                         jobject interfaceMethodType,\n+                                         jobject implementationMember,\n+                                         jobject dynamicMethodType,\n@@ -182,5 +182,5 @@\n-                                      jstring invokedName,\n-                                      jobject invokedType,\n-                                      jobject methodType,\n-                                      jobject implMethodMember,\n-                                      jobject instantiatedMethodType);\n+                                      jstring interfaceMethodName,\n+                                      jobject factoryType,\n+                                      jobject interfaceMethodType,\n+                                      jobject implementationMember,\n+                                      jobject dynamicMethodType);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -46,3 +46,0 @@\n-#ifdef _WINDOWS\n-#define JFR_FILENAME_EXAMPLE \"C:\\\\Users\\\\user\\\\My Recording.jfr\"\n-#endif\n@@ -50,7 +47,9 @@\n-#ifdef __APPLE__\n-#define JFR_FILENAME_EXAMPLE  \"\/Users\/user\/My Recording.jfr\"\n-#endif\n-\n-#ifndef JFR_FILENAME_EXAMPLE\n-#define JFR_FILENAME_EXAMPLE \"\/home\/user\/My Recording.jfr\"\n-#endif\n+bool register_jfr_dcmds() {\n+  uint32_t full_export = DCmd_Source_Internal | DCmd_Source_AttachAPI | DCmd_Source_MBean;\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrCheckFlightRecordingDCmd>(full_export, true, false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrDumpFlightRecordingDCmd>(full_export, true, false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrStartFlightRecordingDCmd>(full_export, true, false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrStopFlightRecordingDCmd>(full_export, true, false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrConfigureFlightRecorderDCmd>(full_export, true, false));\n+  return true;\n+}\n@@ -119,11 +118,0 @@\n-static bool is_recorder_instance_created(outputStream* output) {\n-  if (!JfrRecorder::is_created()) {\n-    if (output != NULL) {\n-      output->print_cr(\"No available recordings.\\n\");\n-      output->print_cr(\"Use JFR.start to start a recording.\\n\");\n-    }\n-    return false;\n-  }\n-  return true;\n-}\n-\n@@ -189,0 +177,1 @@\n+  ResourceMark rm(THREAD);\n@@ -228,34 +217,4 @@\n-JfrDumpFlightRecordingDCmd::JfrDumpFlightRecordingDCmd(outputStream* output,\n-                                                       bool heap) : DCmdWithParser(output, heap),\n-  _name(\"name\", \"Recording name, e.g. \\\\\\\"My Recording\\\\\\\"\", \"STRING\", false, NULL),\n-  _filename(\"filename\", \"Copy recording data to file, e.g. \\\\\\\"\" JFR_FILENAME_EXAMPLE \"\\\\\\\"\", \"STRING\", false),\n-  _maxage(\"maxage\", \"Maximum duration to dump, in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or 0 for no limit\", \"NANOTIME\", false, \"0\"),\n-  _maxsize(\"maxsize\", \"Maximum amount of bytes to dump, in (M)B or (G)B, e.g. 500M, or 0 for no limit\", \"MEMORY SIZE\", false, \"0\"),\n-  _begin(\"begin\", \"Point in time to dump data from, e.g. 09:00, 21:35:00, 2018-06-03T18:12:56.827Z, 2018-06-03T20:13:46.832, -10m, -3h, or -1d\", \"STRING\", false),\n-  _end(\"end\", \"Point in time to dump data to, e.g. 09:00, 21:35:00, 2018-06-03T18:12:56.827Z, 2018-06-03T20:13:46.832, -10m, -3h, or -1d\", \"STRING\", false),\n-  _path_to_gc_roots(\"path-to-gc-roots\", \"Collect path to GC roots\", \"BOOLEAN\", false, \"false\") {\n-  _dcmdparser.add_dcmd_option(&_name);\n-  _dcmdparser.add_dcmd_option(&_filename);\n-  _dcmdparser.add_dcmd_option(&_maxage);\n-  _dcmdparser.add_dcmd_option(&_maxsize);\n-  _dcmdparser.add_dcmd_option(&_begin);\n-  _dcmdparser.add_dcmd_option(&_end);\n-  _dcmdparser.add_dcmd_option(&_path_to_gc_roots);\n-};\n-\n-int JfrDumpFlightRecordingDCmd::num_arguments() {\n-  ResourceMark rm;\n-  JfrDumpFlightRecordingDCmd* dcmd = new JfrDumpFlightRecordingDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  }\n-  return 0;\n-}\n-\n-void JfrDumpFlightRecordingDCmd::execute(DCmdSource source, TRAPS) {\n-  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n-\n-  if (invalid_state(output(), THREAD) || !is_recorder_instance_created(output())) {\n-    return;\n-  }\n+void JfrDCmd::invoke(JfrJavaArguments& method, TRAPS) const {\n+  JavaValue constructor_result(T_OBJECT);\n+  JfrJavaArguments constructor_args(&constructor_result);\n+  constructor_args.set_klass(javaClass(), CHECK);\n@@ -267,3 +226,0 @@\n-  JavaValue result(T_OBJECT);\n-  JfrJavaArguments constructor_args(&result);\n-  constructor_args.set_klass(\"jdk\/jfr\/internal\/dcmd\/DCmdDump\", CHECK);\n@@ -271,86 +227,0 @@\n-  Handle h_dcmd_instance(THREAD, dcmd);\n-  assert(h_dcmd_instance.not_null(), \"invariant\");\n-\n-  jstring name = NULL;\n-  if (_name.is_set() && _name.value()  != NULL) {\n-    name = JfrJavaSupport::new_string(_name.value(), CHECK);\n-  }\n-\n-  jstring filepath = NULL;\n-  if (_filename.is_set() && _filename.value() != NULL) {\n-    filepath = JfrJavaSupport::new_string(_filename.value(), CHECK);\n-  }\n-\n-  jobject maxage = NULL;\n-  if (_maxage.is_set()) {\n-    maxage = JfrJavaSupport::new_java_lang_Long(_maxage.value()._nanotime, CHECK);\n-  }\n-\n-  jobject maxsize = NULL;\n-  if (_maxsize.is_set()) {\n-    maxsize = JfrJavaSupport::new_java_lang_Long(_maxsize.value()._size, CHECK);\n-  }\n-\n-  jstring begin = NULL;\n-  if (_begin.is_set() && _begin.value() != NULL) {\n-    begin = JfrJavaSupport::new_string(_begin.value(), CHECK);\n-  }\n-\n-  jstring end = NULL;\n-  if (_end.is_set() && _end.value() != NULL) {\n-    end = JfrJavaSupport::new_string(_end.value(), CHECK);\n-  }\n-\n-  jobject path_to_gc_roots = NULL;\n-  if (_path_to_gc_roots.is_set()) {\n-    path_to_gc_roots = JfrJavaSupport::new_java_lang_Boolean(_path_to_gc_roots.value(), CHECK);\n-  }\n-\n-  static const char klass[] = \"jdk\/jfr\/internal\/dcmd\/DCmdDump\";\n-  static const char method[] = \"execute\";\n-  static const char signature[] = \"(Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/Long;Ljava\/lang\/Long;Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/Boolean;)[Ljava\/lang\/String;\";\n-\n-  JfrJavaArguments execute_args(&result, klass, method, signature, CHECK);\n-  execute_args.set_receiver(h_dcmd_instance);\n-\n-  \/\/ arguments\n-  execute_args.push_jobject(name);\n-  execute_args.push_jobject(filepath);\n-  execute_args.push_jobject(maxage);\n-  execute_args.push_jobject(maxsize);\n-  execute_args.push_jobject(begin);\n-  execute_args.push_jobject(end);\n-  execute_args.push_jobject(path_to_gc_roots);\n-\n-  JfrJavaSupport::call_virtual(&execute_args, THREAD);\n-  handle_dcmd_result(output(), result.get_oop(), source, THREAD);\n-}\n-\n-JfrCheckFlightRecordingDCmd::JfrCheckFlightRecordingDCmd(outputStream* output, bool heap) : DCmdWithParser(output, heap),\n-  _name(\"name\",\"Recording name, e.g. \\\\\\\"My Recording\\\\\\\" or omit to see all recordings\",\"STRING\",false, NULL),\n-  _verbose(\"verbose\",\"Print event settings for the recording(s)\",\"BOOLEAN\",\n-           false, \"false\") {\n-  _dcmdparser.add_dcmd_option(&_name);\n-  _dcmdparser.add_dcmd_option(&_verbose);\n-};\n-\n-int JfrCheckFlightRecordingDCmd::num_arguments() {\n-  ResourceMark rm;\n-  JfrCheckFlightRecordingDCmd* dcmd = new JfrCheckFlightRecordingDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  }\n-  return 0;\n-}\n-\n-void JfrCheckFlightRecordingDCmd::execute(DCmdSource source, TRAPS) {\n-  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n-\n-  if (invalid_state(output(), THREAD) || !is_recorder_instance_created(output())) {\n-    return;\n-  }\n-\n-  ResourceMark rm(THREAD);\n-  HandleMark hm(THREAD);\n-  JNIHandleBlockManager jni_handle_management(THREAD);\n@@ -358,4 +228,0 @@\n-  JavaValue result(T_OBJECT);\n-  JfrJavaArguments constructor_args(&result);\n-  constructor_args.set_klass(\"jdk\/jfr\/internal\/dcmd\/DCmdCheck\", CHECK);\n-  const oop dcmd = construct_dcmd_instance(&constructor_args, CHECK);\n@@ -365,23 +231,2 @@\n-  jstring name = NULL;\n-  if (_name.is_set() && _name.value() != NULL) {\n-    name = JfrJavaSupport::new_string(_name.value(), CHECK);\n-  }\n-\n-  jobject verbose = NULL;\n-  if (_verbose.is_set()) {\n-    verbose = JfrJavaSupport::new_java_lang_Boolean(_verbose.value(), CHECK);\n-  }\n-\n-  static const char klass[] = \"jdk\/jfr\/internal\/dcmd\/DCmdCheck\";\n-  static const char method[] = \"execute\";\n-  static const char signature[] = \"(Ljava\/lang\/String;Ljava\/lang\/Boolean;)[Ljava\/lang\/String;\";\n-\n-  JfrJavaArguments execute_args(&result, klass, method, signature, CHECK);\n-  execute_args.set_receiver(h_dcmd_instance);\n-\n-  \/\/ arguments\n-  execute_args.push_jobject(name);\n-  execute_args.push_jobject(verbose);\n-\n-  JfrJavaSupport::call_virtual(&execute_args, THREAD);\n-  handle_dcmd_result(output(), result.get_oop(), source, THREAD);\n+  method.set_receiver(h_dcmd_instance);\n+  JfrJavaSupport::call_virtual(&method, THREAD);\n@@ -390,34 +235,6 @@\n-JfrStartFlightRecordingDCmd::JfrStartFlightRecordingDCmd(outputStream* output,\n-                                                         bool heap) : DCmdWithParser(output, heap),\n-  _name(\"name\", \"Name that can be used to identify recording, e.g. \\\\\\\"My Recording\\\\\\\"\", \"STRING\", false, NULL),\n-  _settings(\"settings\", \"Settings file(s), e.g. profile or default. See JAVA_HOME\/lib\/jfr\", \"STRING SET\", false),\n-  _delay(\"delay\", \"Delay recording start with (s)econds, (m)inutes), (h)ours), or (d)ays, e.g. 5h.\", \"NANOTIME\", false, \"0\"),\n-  _duration(\"duration\", \"Duration of recording in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 300s.\", \"NANOTIME\", false, \"0\"),\n-  _disk(\"disk\", \"Recording should be persisted to disk\", \"BOOLEAN\", false),\n-  _filename(\"filename\", \"Resulting recording filename, e.g. \\\\\\\"\" JFR_FILENAME_EXAMPLE \"\\\\\\\"\", \"STRING\", false),\n-  _maxage(\"maxage\", \"Maximum time to keep recorded data (on disk) in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or 0 for no limit\", \"NANOTIME\", false, \"0\"),\n-  _maxsize(\"maxsize\", \"Maximum amount of bytes to keep (on disk) in (k)B, (M)B or (G)B, e.g. 500M, or 0 for no limit\", \"MEMORY SIZE\", false, \"0\"),\n-  _flush_interval(\"flush-interval\", \"Minimum time before flushing buffers, measured in (s)econds, e.g. 4 s, or 0 for flushing when a recording ends\", \"NANOTIME\", false, \"1s\"),\n-  _dump_on_exit(\"dumponexit\", \"Dump running recording when JVM shuts down\", \"BOOLEAN\", false),\n-  _path_to_gc_roots(\"path-to-gc-roots\", \"Collect path to GC roots\", \"BOOLEAN\", false, \"false\") {\n-  _dcmdparser.add_dcmd_option(&_name);\n-  _dcmdparser.add_dcmd_option(&_settings);\n-  _dcmdparser.add_dcmd_option(&_delay);\n-  _dcmdparser.add_dcmd_option(&_duration);\n-  _dcmdparser.add_dcmd_option(&_disk);\n-  _dcmdparser.add_dcmd_option(&_filename);\n-  _dcmdparser.add_dcmd_option(&_maxage);\n-  _dcmdparser.add_dcmd_option(&_maxsize);\n-  _dcmdparser.add_dcmd_option(&_flush_interval);\n-  _dcmdparser.add_dcmd_option(&_dump_on_exit);\n-  _dcmdparser.add_dcmd_option(&_path_to_gc_roots);\n-};\n-\n-int JfrStartFlightRecordingDCmd::num_arguments() {\n-  ResourceMark rm;\n-  JfrStartFlightRecordingDCmd* dcmd = new JfrStartFlightRecordingDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  }\n-  return 0;\n+void JfrDCmd::parse(CmdLine* line, char delim, TRAPS) {\n+  _args = line->args_addr();\n+  _delimiter = delim;\n+  \/\/ Error checking done in execute.\n+  \/\/ Will not matter from DCmdFactory perspective\n+  \/\/ where parse and execute are called consecutively.\n@@ -426,2 +243,2 @@\n-void JfrStartFlightRecordingDCmd::execute(DCmdSource source, TRAPS) {\n-  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n+void JfrDCmd::execute(DCmdSource source, TRAPS) {\n+  static const char signature[] = \"(Ljava\/lang\/String;Ljava\/lang\/String;C)[Ljava\/lang\/String;\";\n@@ -433,4 +250,0 @@\n-  ResourceMark rm(THREAD);\n-  HandleMark hm(THREAD);\n-  JNIHandleBlockManager jni_handle_management(THREAD);\n-\n@@ -438,102 +251,16 @@\n-  JfrJavaArguments constructor_args(&result);\n-  constructor_args.set_klass(\"jdk\/jfr\/internal\/dcmd\/DCmdStart\", THREAD);\n-  const oop dcmd = construct_dcmd_instance(&constructor_args, CHECK);\n-  Handle h_dcmd_instance(THREAD, dcmd);\n-  assert(h_dcmd_instance.not_null(), \"invariant\");\n-\n-  jstring name = NULL;\n-  if (_name.is_set() && _name.value() != NULL) {\n-    name = JfrJavaSupport::new_string(_name.value(), CHECK);\n-  }\n-\n-  jstring filename = NULL;\n-  if (_filename.is_set() && _filename.value() != NULL) {\n-    filename = JfrJavaSupport::new_string(_filename.value(), CHECK);\n-  }\n-\n-  jobject maxage = NULL;\n-  if (_maxage.is_set()) {\n-    maxage = JfrJavaSupport::new_java_lang_Long(_maxage.value()._nanotime, CHECK);\n-  }\n-\n-  jobject maxsize = NULL;\n-  if (_maxsize.is_set()) {\n-    maxsize = JfrJavaSupport::new_java_lang_Long(_maxsize.value()._size, CHECK);\n-  }\n-\n-  jobject flush_interval = NULL;\n-  if (_flush_interval.is_set()) {\n-    flush_interval = JfrJavaSupport::new_java_lang_Long(_flush_interval.value()._nanotime, CHECK);\n-  }\n-  jobject duration = NULL;\n-  if (_duration.is_set()) {\n-    duration = JfrJavaSupport::new_java_lang_Long(_duration.value()._nanotime, CHECK);\n-  }\n-\n-  jobject delay = NULL;\n-  if (_delay.is_set()) {\n-    delay = JfrJavaSupport::new_java_lang_Long(_delay.value()._nanotime, CHECK);\n-  }\n-\n-  jobject disk = NULL;\n-  if (_disk.is_set()) {\n-    disk = JfrJavaSupport::new_java_lang_Boolean(_disk.value(), CHECK);\n-  }\n-\n-  jobject dump_on_exit = NULL;\n-  if (_dump_on_exit.is_set()) {\n-    dump_on_exit = JfrJavaSupport::new_java_lang_Boolean(_dump_on_exit.value(), CHECK);\n-  }\n-\n-  jobject path_to_gc_roots = NULL;\n-  if (_path_to_gc_roots.is_set()) {\n-    path_to_gc_roots = JfrJavaSupport::new_java_lang_Boolean(_path_to_gc_roots.value(), CHECK);\n-  }\n-\n-  jobjectArray settings = NULL;\n-  if (_settings.is_set()) {\n-    int length = _settings.value()->array()->length();\n-    if (length == 1) {\n-      const char* c_str = _settings.value()->array()->at(0);\n-      if (strcmp(c_str, \"none\") == 0) {\n-        length = 0;\n-      }\n-    }\n-    settings = JfrJavaSupport::new_string_array(length, CHECK);\n-    assert(settings != NULL, \"invariant\");\n-    for (int i = 0; i < length; ++i) {\n-      jobject element = JfrJavaSupport::new_string(_settings.value()->array()->at(i), CHECK);\n-      assert(element != NULL, \"invariant\");\n-      JfrJavaSupport::set_array_element(settings, element, i, CHECK);\n-    }\n-  } else {\n-    settings = JfrJavaSupport::new_string_array(1, CHECK);\n-    assert(settings != NULL, \"invariant\");\n-    jobject element = JfrJavaSupport::new_string(\"default\", CHECK);\n-    assert(element != NULL, \"invariant\");\n-    JfrJavaSupport::set_array_element(settings, element, 0, CHECK);\n-  }\n-\n-  static const char klass[] = \"jdk\/jfr\/internal\/dcmd\/DCmdStart\";\n-  static const char method[] = \"execute\";\n-  static const char signature[] = \"(Ljava\/lang\/String;[Ljava\/lang\/String;Ljava\/lang\/Long;\"\n-    \"Ljava\/lang\/Long;Ljava\/lang\/Boolean;Ljava\/lang\/String;\"\n-    \"Ljava\/lang\/Long;Ljava\/lang\/Long;Ljava\/lang\/Long;Ljava\/lang\/Boolean;Ljava\/lang\/Boolean;)[Ljava\/lang\/String;\";\n-\n-  JfrJavaArguments execute_args(&result, klass, method, signature, CHECK);\n-  execute_args.set_receiver(h_dcmd_instance);\n-\n-  \/\/ arguments\n-  execute_args.push_jobject(name);\n-  execute_args.push_jobject(settings);\n-  execute_args.push_jobject(delay);\n-  execute_args.push_jobject(duration);\n-  execute_args.push_jobject(disk);\n-  execute_args.push_jobject(filename);\n-  execute_args.push_jobject(maxage);\n-  execute_args.push_jobject(maxsize);\n-  execute_args.push_jobject(flush_interval);\n-  execute_args.push_jobject(dump_on_exit);\n-  execute_args.push_jobject(path_to_gc_roots);\n-\n-  JfrJavaSupport::call_virtual(&execute_args, THREAD);\n+  JfrJavaArguments execute(&result, javaClass(), \"execute\", signature, CHECK);\n+  jstring argument = JfrJavaSupport::new_string(_args, CHECK);\n+  jstring s = NULL;\n+  if (source == DCmd_Source_Internal) {\n+    s = JfrJavaSupport::new_string(\"internal\", CHECK);\n+  }\n+  if (source == DCmd_Source_MBean) {\n+    s = JfrJavaSupport::new_string(\"mbean\", CHECK);\n+  }\n+  if (source == DCmd_Source_AttachAPI) {\n+    s = JfrJavaSupport::new_string(\"attach\", CHECK);\n+  }\n+  execute.push_jobject(s);\n+  execute.push_jobject(argument);\n+  execute.push_int(_delimiter);\n+  invoke(execute, THREAD);\n@@ -543,29 +270,3 @@\n-JfrStopFlightRecordingDCmd::JfrStopFlightRecordingDCmd(outputStream* output,\n-                                                       bool heap) : DCmdWithParser(output, heap),\n-  _name(\"name\", \"Recording text,.e.g \\\\\\\"My Recording\\\\\\\"\", \"STRING\", true, NULL),\n-  _filename(\"filename\", \"Copy recording data to file, e.g. \\\\\\\"\" JFR_FILENAME_EXAMPLE \"\\\\\\\"\", \"STRING\", false, NULL) {\n-  _dcmdparser.add_dcmd_option(&_name);\n-  _dcmdparser.add_dcmd_option(&_filename);\n-};\n-\n-int JfrStopFlightRecordingDCmd::num_arguments() {\n-  ResourceMark rm;\n-  JfrStopFlightRecordingDCmd* dcmd = new JfrStopFlightRecordingDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  }\n-  return 0;\n-}\n-\n-void JfrStopFlightRecordingDCmd::execute(DCmdSource source, TRAPS) {\n-  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n-\n-  if (invalid_state(output(), THREAD) || !is_recorder_instance_created(output())) {\n-    return;\n-  }\n-\n-  ResourceMark rm(THREAD);\n-  HandleMark hm(THREAD);\n-  JNIHandleBlockManager jni_handle_management(THREAD);\n-\n+void JfrDCmd::print_help(const char* name) const {\n+  static const char signature[] = \"()[Ljava\/lang\/String;\";\n+  JavaThread* thread = JavaThread::current();\n@@ -573,5 +274,4 @@\n-  JfrJavaArguments constructor_args(&result);\n-  constructor_args.set_klass(\"jdk\/jfr\/internal\/dcmd\/DCmdStop\", CHECK);\n-  const oop dcmd = construct_dcmd_instance(&constructor_args, CHECK);\n-  Handle h_dcmd_instance(THREAD, dcmd);\n-  assert(h_dcmd_instance.not_null(), \"invariant\");\n+  JfrJavaArguments print_help(&result, javaClass(), \"printHelp\", signature, thread);\n+  invoke(print_help, thread);\n+  handle_dcmd_result(output(), result.get_oop(), DCmd_Source_MBean, thread);\n+}\n@@ -579,4 +279,3 @@\n-  jstring name = NULL;\n-  if (_name.is_set() && _name.value()  != NULL) {\n-    name = JfrJavaSupport::new_string(_name.value(), CHECK);\n-  }\n+GrowableArray<DCmdArgumentInfo*>* JfrDCmd::argument_info_array() const {\n+  return new GrowableArray<DCmdArgumentInfo*>();\n+}\n@@ -584,3 +283,5 @@\n-  jstring filepath = NULL;\n-  if (_filename.is_set() && _filename.value() != NULL) {\n-    filepath = JfrJavaSupport::new_string(_filename.value(), CHECK);\n+GrowableArray<const char*>* JfrDCmd::argument_name_array() const {\n+  GrowableArray<DCmdArgumentInfo*>* argument_infos = argument_info_array();\n+  GrowableArray<const char*>* array = new GrowableArray<const char*>(argument_infos->length());\n+  for (int i = 0; i < argument_infos->length(); i++) {\n+    array->append(argument_infos->at(i)->name());\n@@ -588,14 +289,1 @@\n-\n-  static const char klass[] = \"jdk\/jfr\/internal\/dcmd\/DCmdStop\";\n-  static const char method[] = \"execute\";\n-  static const char signature[] = \"(Ljava\/lang\/String;Ljava\/lang\/String;)[Ljava\/lang\/String;\";\n-\n-  JfrJavaArguments execute_args(&result, klass, method, signature, CHECK);\n-  execute_args.set_receiver(h_dcmd_instance);\n-\n-  \/\/ arguments\n-  execute_args.push_jobject(name);\n-  execute_args.push_jobject(filepath);\n-\n-  JfrJavaSupport::call_virtual(&execute_args, THREAD);\n-  handle_dcmd_result(output(), result.get_oop(), source, THREAD);\n+  return array;\n@@ -627,0 +315,58 @@\n+void JfrConfigureFlightRecorderDCmd::print_help(const char* name) const {\n+  outputStream* out = output();\n+              \/\/ 0123456789001234567890012345678900123456789001234567890012345678900123456789001234567890\n+  out->print_cr(\"Options:\");\n+  out->print_cr(\"\");\n+  out->print_cr(\"  globalbuffercount  (Optional) Number of global buffers. This option is a legacy\");\n+  out->print_cr(\"                     option: change the memorysize parameter to alter the number of\");\n+  out->print_cr(\"                     global buffers. This value cannot be changed once JFR has been\");\n+  out->print_cr(\"                     initalized. (STRING, default determined by the value for\");\n+  out->print_cr(\"                     memorysize)\");\n+  out->print_cr(\"\");\n+  out->print_cr(\"  globalbuffersize   (Optional) Size of the global buffers, in bytes. This option is a\");\n+  out->print_cr(\"                     legacy option: change the memorysize parameter to alter the size\");\n+  out->print_cr(\"                     of the global buffers. This value cannot be changed once JFR has\");\n+  out->print_cr(\"                     been initalized. (STRING, default determined by the value for\");\n+  out->print_cr(\"                     memorysize)\");\n+  out->print_cr(\"\");\n+  out->print_cr(\"   maxchunksize      (Optional) Maximum size of an individual data chunk in bytes if\");\n+  out->print_cr(\"                     one of the following suffixes is not used: 'm' or 'M' for\");\n+  out->print_cr(\"                     megabytes OR 'g' or 'G' for gigabytes. This value cannot be\");\n+  out->print_cr(\"                     changed once JFR has been initialized. (STRING, 12M)\");\n+  out->print_cr(\"\");\n+  out->print_cr(\"   memorysize        (Optional) Overall memory size, in bytes if one of the following\");\n+  out->print_cr(\"                     suffixes is not used: 'm' or 'M' for megabytes OR 'g' or 'G' for\");\n+  out->print_cr(\"                     gigabytes. This value cannot be changed once JFR has been\");\n+  out->print_cr(\"                     initialized. (STRING, 10M)\");\n+  out->print_cr(\"\");\n+  out->print_cr(\"  repositorypath     (Optional) Path to the location where recordings are stored until\");\n+  out->print_cr(\"                     they are written to a permanent file. (STRING, The default\");\n+  out->print_cr(\"                     location is the temporary directory for the operating system. On\");\n+  out->print_cr(\"                     Linux operating systems, the temporary directory is \/tmp. On\");\n+  out->print_cr(\"                     Windows, the temporary directory is specified by the TMP\");\n+  out->print_cr(\"                     environment variable.)\");\n+  out->print_cr(\"\");\n+  out->print_cr(\"  stackdepth         (Optional) Stack depth for stack traces. Setting this value\");\n+  out->print_cr(\"                     greater than the default of 64 may cause a performance\");\n+  out->print_cr(\"                     degradation. This value cannot be changed once JFR has been\");\n+  out->print_cr(\"                     initialized. (LONG, 64)\");\n+  out->print_cr(\"\");\n+  out->print_cr(\"  thread_buffer_size (Optional) Local buffer size for each thread in bytes if one of\");\n+  out->print_cr(\"                     the following suffixes is not used: 'k' or 'K' for kilobytes or\");\n+  out->print_cr(\"                     'm' or 'M' for megabytes. Overriding this parameter could reduce\");\n+  out->print_cr(\"                     performance and is not recommended. This value cannot be changed\");\n+  out->print_cr(\"                     once JFR has been initialized. (STRING, 8k)\");\n+  out->print_cr(\"\");\n+  out->print_cr(\"  samplethreads      (Optional) Flag for activating thread sampling. (BOOLEAN, true)\");\n+  out->print_cr(\"\");\n+  out->print_cr(\"Options must be specified using the <key> or <key>=<value> syntax.\");\n+  out->print_cr(\"\");\n+  out->print_cr(\"Example usage:\");\n+  out->print_cr(\"\");\n+  out->print_cr(\" $ jcmd <pid> JFR.configure\");\n+  out->print_cr(\" $ jcmd <pid> JFR.configure repositorypath=\/temporary\");\n+  out->print_cr(\" $ jcmd <pid> JFR.configure stackdepth=256\");\n+  out->print_cr(\" $ jcmd <pid> JFR.configure memorysize=100M\");\n+  out->print_cr(\"\");\n+}\n+\n@@ -724,10 +470,0 @@\n-\n-bool register_jfr_dcmds() {\n-  uint32_t full_export = DCmd_Source_Internal | DCmd_Source_AttachAPI | DCmd_Source_MBean;\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrCheckFlightRecordingDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrDumpFlightRecordingDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrStartFlightRecordingDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrStopFlightRecordingDCmd>(full_export, true, false));\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<JfrConfigureFlightRecorderDCmd>(full_export, true, false));\n-  return true;\n-}\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.cpp","additions":114,"deletions":378,"binary":false,"changes":492,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+class JfrJavaArguments;\n@@ -30,1 +31,12 @@\n-class JfrDumpFlightRecordingDCmd : public DCmdWithParser {\n+class JfrDCmd : public DCmd {\n+ private:\n+  const char* _args;\n+  char _delimiter;\n+ public:\n+  JfrDCmd(outputStream* output, bool heap) : DCmd(output,heap), _args(NULL), _delimiter('\\0')  {}\n+\n+  virtual void execute(DCmdSource source, TRAPS);\n+  virtual void print_help(const char* name) const;\n+  virtual GrowableArray<const char*>* argument_name_array() const;\n+  virtual GrowableArray<DCmdArgumentInfo*>* argument_info_array() const;\n+  virtual void parse(CmdLine* line, char delim, TRAPS);\n@@ -32,7 +44,3 @@\n-  DCmdArgument<char*> _name;\n-  DCmdArgument<char*> _filename;\n-  DCmdArgument<NanoTimeArgument> _maxage;\n-  DCmdArgument<MemorySizeArgument> _maxsize;\n-  DCmdArgument<char*> _begin;\n-  DCmdArgument<char*> _end;\n-  DCmdArgument<bool>  _path_to_gc_roots;\n+  virtual const char* javaClass() const = 0;\n+  void invoke(JfrJavaArguments& method, TRAPS) const;\n+};\n@@ -40,0 +48,1 @@\n+class JfrStartFlightRecordingDCmd : public JfrDCmd {\n@@ -41,1 +50,2 @@\n-  JfrDumpFlightRecordingDCmd(outputStream* output, bool heap);\n+  JfrStartFlightRecordingDCmd(outputStream* output, bool heap) : JfrDCmd(output, heap) {}\n+\n@@ -43,1 +53,1 @@\n-    return \"JFR.dump\";\n+    return \"JFR.start\";\n@@ -46,1 +56,1 @@\n-    return \"Copies contents of a JFR recording to file. Either the name or the recording id must be specified.\";\n+    return \"Starts a new JFR recording\";\n@@ -49,1 +59,1 @@\n-    return \"Low\";\n+    return \"Medium: Depending on the settings for a recording, the impact can range from low to high.\";\n@@ -55,2 +65,3 @@\n-  static int num_arguments();\n-  virtual void execute(DCmdSource source, TRAPS);\n+  virtual const char* javaClass() const {\n+    return \"jdk\/jfr\/internal\/dcmd\/DCmdStart\";\n+  }\n@@ -59,5 +70,1 @@\n-class JfrCheckFlightRecordingDCmd : public DCmdWithParser {\n- protected:\n-  DCmdArgument<char*> _name;\n-  DCmdArgument<bool>  _verbose;\n-\n+class JfrDumpFlightRecordingDCmd : public JfrDCmd {\n@@ -65,1 +72,2 @@\n-  JfrCheckFlightRecordingDCmd(outputStream* output, bool heap);\n+  JfrDumpFlightRecordingDCmd(outputStream* output, bool heap) : JfrDCmd(output, heap) {}\n+\n@@ -67,1 +75,1 @@\n-    return \"JFR.check\";\n+    return \"JFR.dump\";\n@@ -70,1 +78,1 @@\n-    return \"Checks running JFR recording(s)\";\n+    return \"Copies contents of a JFR recording to file. Either the name or the recording id must be specified.\";\n@@ -79,2 +87,3 @@\n-  static int num_arguments();\n-  virtual void execute(DCmdSource source, TRAPS);\n+  virtual const char* javaClass() const {\n+    return \"jdk\/jfr\/internal\/dcmd\/DCmdDump\";\n+  }\n@@ -83,14 +92,1 @@\n-class JfrStartFlightRecordingDCmd : public DCmdWithParser {\n- protected:\n-  DCmdArgument<char*> _name;\n-  DCmdArgument<StringArrayArgument*> _settings;\n-  DCmdArgument<NanoTimeArgument> _delay;\n-  DCmdArgument<NanoTimeArgument> _duration;\n-  DCmdArgument<bool> _disk;\n-  DCmdArgument<char*> _filename;\n-  DCmdArgument<NanoTimeArgument> _maxage;\n-  DCmdArgument<MemorySizeArgument> _maxsize;\n-  DCmdArgument<NanoTimeArgument> _flush_interval;\n-  DCmdArgument<bool> _dump_on_exit;\n-  DCmdArgument<bool> _path_to_gc_roots;\n-\n+class JfrCheckFlightRecordingDCmd : public JfrDCmd {\n@@ -98,1 +94,2 @@\n-  JfrStartFlightRecordingDCmd(outputStream* output, bool heap);\n+  JfrCheckFlightRecordingDCmd(outputStream* output, bool heap) : JfrDCmd(output, heap) {}\n+\n@@ -100,1 +97,1 @@\n-    return \"JFR.start\";\n+    return \"JFR.check\";\n@@ -103,1 +100,1 @@\n-    return \"Starts a new JFR recording\";\n+    return \"Checks running JFR recording(s)\";\n@@ -106,1 +103,1 @@\n-    return \"Medium: Depending on the settings for a recording, the impact can range from low to high.\";\n+    return \"Low\";\n@@ -112,2 +109,3 @@\n-  static int num_arguments();\n-  virtual void execute(DCmdSource source, TRAPS);\n+  virtual const char* javaClass() const {\n+    return \"jdk\/jfr\/internal\/dcmd\/DCmdCheck\";\n+  }\n@@ -116,5 +114,1 @@\n-class JfrStopFlightRecordingDCmd : public DCmdWithParser {\n- protected:\n-  DCmdArgument<char*> _name;\n-  DCmdArgument<char*> _filename;\n-\n+class JfrStopFlightRecordingDCmd : public JfrDCmd {\n@@ -122,1 +116,2 @@\n-  JfrStopFlightRecordingDCmd(outputStream* output, bool heap);\n+  JfrStopFlightRecordingDCmd(outputStream* output, bool heap) : JfrDCmd(output, heap) {}\n+\n@@ -136,2 +131,3 @@\n-  static int num_arguments();\n-  virtual void execute(DCmdSource source, TRAPS);\n+  virtual const char* javaClass() const {\n+    return \"jdk\/jfr\/internal\/dcmd\/DCmdStop\";\n+  }\n@@ -140,2 +136,0 @@\n-class JfrRuntimeOptions;\n-\n@@ -176,0 +170,1 @@\n+  virtual void print_help(const char* name) const;\n@@ -178,0 +173,1 @@\n+\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.hpp","additions":50,"deletions":54,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -490,2 +490,6 @@\n-\/\/ caller needs ResourceMark\n-const char* JfrJavaSupport::c_str(oop string, JavaThread* t) {\n+static char* allocate_string(bool c_heap, int length, JavaThread* jt) {\n+  return c_heap ? NEW_C_HEAP_ARRAY(char, length, mtTracing) :\n+                  NEW_RESOURCE_ARRAY_IN_THREAD(jt, char, length);\n+}\n+\n+const char* JfrJavaSupport::c_str(oop string, JavaThread* t, bool c_heap \/* false *\/) {\n@@ -493,1 +497,1 @@\n-  char* resource_copy = NULL;\n+  char* str = NULL;\n@@ -497,3 +501,3 @@\n-    resource_copy = NEW_RESOURCE_ARRAY_IN_THREAD(t, char, (length + 1));\n-    if (resource_copy == NULL) {\n-      JfrJavaSupport::throw_out_of_memory_error(\"Unable to allocate thread local native memory\", t);\n+    str = allocate_string(c_heap, length + 1, t);\n+    if (str == NULL) {\n+      JfrJavaSupport::throw_out_of_memory_error(\"Unable to allocate native memory\", t);\n@@ -502,2 +506,1 @@\n-    assert(resource_copy != NULL, \"invariant\");\n-    java_lang_String::as_utf8_string(string, value, resource_copy, length + 1);\n+    java_lang_String::as_utf8_string(string, value, str, length + 1);\n@@ -505,1 +508,1 @@\n-  return resource_copy;\n+  return str;\n@@ -508,2 +511,1 @@\n-\/\/ caller needs ResourceMark\n-const char* JfrJavaSupport::c_str(jstring string, JavaThread* t) {\n+const char* JfrJavaSupport::c_str(jstring string, JavaThread* t, bool c_heap \/* false *\/) {\n@@ -511,1 +513,1 @@\n-  return string != NULL ? c_str(resolve_non_null(string), t) : NULL;\n+  return string != NULL ? c_str(resolve_non_null(string), t, c_heap) : NULL;\n@@ -762,0 +764,20 @@\n+static const Klass* get_handler_field_descriptor(const Handle& h_mirror, fieldDescriptor* descriptor, TRAPS) {\n+  assert(h_mirror.not_null(), \"invariant\");\n+  assert(descriptor != NULL, \"invariant\");\n+  Klass* const k = java_lang_Class::as_Klass(h_mirror());\n+  assert(k->is_instance_klass(), \"invariant\");\n+  InstanceKlass* const ik = InstanceKlass::cast(k);\n+  if (ik->is_not_initialized()) {\n+    ik->initialize(CHECK_NULL);\n+  }\n+  assert(ik->is_being_initialized() || ik->is_initialized(), \"invariant\");\n+  const Klass* const typed_field_holder = ik->find_field(vmSymbols::eventHandler_name(),\n+                                                         vmSymbols::jdk_jfr_internal_handlers_EventHandler_signature(),\n+                                                         true,\n+                                                         descriptor);\n+  return typed_field_holder != NULL ? typed_field_holder : ik->find_field(vmSymbols::eventHandler_name(),\n+                                                                          vmSymbols::object_signature(), \/\/ untyped\n+                                                                          true,\n+                                                                          descriptor);\n+}\n+\n@@ -764,3 +786,0 @@\n-  const oop klass_oop = JNIHandles::resolve(clazz);\n-  assert(klass_oop != NULL, \"invariant\");\n-  Klass* klass = java_lang_Class::as_Klass(klass_oop);\n@@ -768,22 +787,7 @@\n-  Handle h_klass_oop(Handle(THREAD, klass->java_mirror()));\n-  InstanceKlass* const instance_klass = static_cast<InstanceKlass*>(klass);\n-  klass->initialize(CHECK_NULL);\n-\n-  fieldDescriptor event_handler_field;\n-  Klass* f = instance_klass->find_field(\n-    vmSymbols::eventHandler_name(),\n-    vmSymbols::jdk_jfr_internal_handlers_EventHandler_signature(),\n-    true, &event_handler_field);\n-  if (f != NULL) {\n-    oop ret = h_klass_oop->obj_field(event_handler_field.offset());\n-    return ret != NULL ? JfrJavaSupport::local_jni_handle(ret, THREAD) : NULL;\n-  }\n-\n-  fieldDescriptor object_field;\n-  Klass* g = instance_klass->find_field(\n-    vmSymbols::eventHandler_name(),\n-    vmSymbols::object_signature(),\n-    true, &object_field);\n-  if (g != NULL) {\n-    oop ret = h_klass_oop->obj_field(object_field.offset());\n-    return ret != NULL ? JfrJavaSupport::local_jni_handle(ret, THREAD) : NULL;\n+  const Handle h_mirror(Handle(THREAD, JNIHandles::resolve(clazz)));\n+  assert(h_mirror.not_null(), \"invariant\");\n+  fieldDescriptor handler_field_descriptor;\n+  const Klass* const field_holder = get_handler_field_descriptor(h_mirror, &handler_field_descriptor, THREAD);\n+  if (field_holder == NULL) {\n+    \/\/ The only reason should be that klass initialization failed.\n+    return NULL;\n@@ -791,2 +795,3 @@\n-  assert(f == NULL && g == NULL, \"no handler field for class\");\n-  return NULL;\n+  assert(java_lang_Class::as_Klass(h_mirror()) == field_holder, \"invariant\");\n+  oop handler_oop = h_mirror->obj_field(handler_field_descriptor.offset());\n+  return handler_oop != NULL ? JfrJavaSupport::local_jni_handle(handler_oop, THREAD) : NULL;\n@@ -797,5 +802,0 @@\n-  const oop klass_oop = JNIHandles::resolve(clazz);\n-  assert(klass_oop != NULL, \"invariant\");\n-  const oop handler_oop = JNIHandles::resolve(handler);\n-  assert(handler_oop != NULL, \"invariant\");\n-  Klass* klass = java_lang_Class::as_Klass(klass_oop);\n@@ -803,22 +803,7 @@\n-  Handle h_klass_oop(Handle(THREAD, klass->java_mirror()));\n-  InstanceKlass* const instance_klass = static_cast<InstanceKlass*>(klass);\n-  klass->initialize(CHECK_false);\n-\n-  fieldDescriptor event_handler_field;\n-  Klass* f = instance_klass->find_field(\n-    vmSymbols::eventHandler_name(),\n-    vmSymbols::jdk_jfr_internal_handlers_EventHandler_signature(),\n-    true, &event_handler_field);\n-  if (f != NULL) {\n-    h_klass_oop->obj_field_put(event_handler_field.offset(), handler_oop);\n-    return true;\n-  }\n-\n-  fieldDescriptor object_handler_field;\n-  Klass* g = instance_klass->find_field(\n-    vmSymbols::eventHandler_name(),\n-    vmSymbols::object_signature(),\n-    true, &object_handler_field);\n-  if (g != NULL) {\n-    h_klass_oop->obj_field_put(object_handler_field.offset(), handler_oop);\n-    return true;\n+  const Handle h_mirror(Handle(THREAD, JNIHandles::resolve(clazz)));\n+  assert(h_mirror.not_null(), \"invariant\");\n+  fieldDescriptor handler_field_descriptor;\n+  const Klass* const field_holder = get_handler_field_descriptor(h_mirror, &handler_field_descriptor, THREAD);\n+  if (field_holder == NULL) {\n+    \/\/ The only reason should be that klass initialization failed.\n+    return false;\n@@ -826,2 +811,5 @@\n-  assert(f == NULL && g == NULL, \"no handler field for class\");\n-  return false;\n+  assert(java_lang_Class::as_Klass(h_mirror()) == field_holder, \"invariant\");\n+  const oop handler_oop = JNIHandles::resolve(handler);\n+  assert(handler_oop != NULL, \"invariant\");\n+  h_mirror->obj_field_put(handler_field_descriptor.offset(), handler_oop);\n+  return true;\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":56,"deletions":68,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -78,3 +78,2 @@\n-  \/\/ caller needs ResourceMark\n-  static const char* c_str(jstring string, JavaThread* jt);\n-  static const char* c_str(oop string, JavaThread* t);\n+  static const char* c_str(jstring string, JavaThread* jt, bool c_heap = false);\n+  static const char* c_str(oop string, JavaThread* jt, bool c_heap = false);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -281,0 +281,4 @@\n+  <Event name=\"SystemGC\" category=\"Java Virtual Machine, GC, Collector\" label=\"System GC\" stackTrace=\"true\" startTime=\"true\" thread=\"true\">\n+    <Field type=\"boolean\" name=\"invokedConcurrent\" label=\"Invoked Concurrent\" \/>\n+  <\/Event>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,2 @@\n-  JFR_LOG_TAG(jfr, dcmd)\n+  JFR_LOG_TAG(jfr, dcmd) \\\n+  JFR_LOG_TAG(jfr, start)\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrLogTagSets.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -277,1 +277,1 @@\n-  write((uintptr_t)JfrTime::is_ft_enabled() ? time.ft_value() : time.value());\n+  write(JfrTime::is_ft_enabled() ? time.ft_value() : time.value());\n@@ -282,1 +282,1 @@\n-  write((uintptr_t)JfrTime::is_ft_enabled() ? time.ft_value() : time.value());\n+  write(JfrTime::is_ft_enabled() ? time.ft_value() : time.value());\n@@ -287,1 +287,1 @@\n-  write((uintptr_t)time.value());\n+  write(time.value());\n@@ -292,1 +292,1 @@\n-  write((uintptr_t)time.value());\n+  write(time.value());\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrWriterHost.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -92,1 +92,3 @@\n-     code_too_large\n+     nmethod_reclaimed, \/\/ code cache sweeper reclaimed nmethod in between its creation and being marked \"in_use\"\n+     code_too_large,\n+     first_permanent_bailout = code_too_large\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -483,0 +483,1 @@\n+    nmethodLocker& nmethod_handle,\n@@ -540,2 +541,1 @@\n-    nmethod* nm = NULL;\n-    result = runtime()->register_method(jvmci_env(), method, nm, entry_bci, &_offsets, _orig_pc_offset, &buffer,\n+    result = runtime()->register_method(jvmci_env(), method, nmethod_handle, entry_bci, &_offsets, _orig_pc_offset, &buffer,\n@@ -546,6 +546,9 @@\n-    cb = nm->as_codeblob_or_null();\n-    if (nm != NULL && compile_state == NULL) {\n-      \/\/ This compile didn't come through the CompileBroker so perform the printing here\n-      DirectiveSet* directive = DirectivesStack::getMatchingDirective(method, compiler);\n-      nm->maybe_print_nmethod(directive);\n-      DirectivesStack::release(directive);\n+    if (result == JVMCI::ok) {\n+      nmethod* nm = nmethod_handle.code()->as_nmethod_or_null();\n+      cb = nm;\n+      if (compile_state == NULL) {\n+        \/\/ This compile didn't come through the CompileBroker so perform the printing here\n+        DirectiveSet* directive = DirectivesStack::getMatchingDirective(method, compiler);\n+        nm->maybe_print_nmethod(directive);\n+        DirectivesStack::release(directive);\n+      }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -190,0 +190,1 @@\n+                                   nmethodLocker& nmethod_handle,\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -884,0 +884,1 @@\n+  nmethodLocker nmethod_handle;\n@@ -889,0 +890,1 @@\n+      nmethod_handle,\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1644,1 +1644,1 @@\n-                                nmethod*& nm,\n+                                nmethodLocker& code_handle,\n@@ -1665,1 +1665,1 @@\n-  nm = NULL;\n+  nmethod* nm = NULL;\n@@ -1750,0 +1750,1 @@\n+        result = JVMCI::cache_full;\n@@ -1787,0 +1788,2 @@\n+            } else {\n+              result = JVMCI::nmethod_reclaimed;\n@@ -1799,0 +1802,2 @@\n+            } else {\n+              result = JVMCI::nmethod_reclaimed;\n@@ -1803,0 +1808,4 @@\n+          MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+          if (!nm->make_in_use()) {\n+            result = JVMCI::nmethod_reclaimed;\n+          }\n@@ -1805,1 +1814,3 @@\n-      result = nm != NULL ? JVMCI::ok :JVMCI::cache_full;\n+    }\n+    if (result == JVMCI::ok) {\n+      code_handle.set_code(nm);\n@@ -1816,2 +1827,2 @@\n-  \/\/ JVMTI -- compiled method notification (must be done outside lock)\n-  if (nm != NULL) {\n+  if (result == JVMCI::ok) {\n+    \/\/ JVMTI -- compiled method notification (must be done outside lock)\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -293,1 +293,1 @@\n-                       nmethod*&                 nm,\n+                       nmethodLocker&            code_handle,\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -593,4 +593,7 @@\n-  declare_preprocessor_constant(\"JVMCI::ok\",                   JVMCI::ok)                      \\\n-  declare_preprocessor_constant(\"JVMCI::dependencies_failed\",  JVMCI::dependencies_failed)     \\\n-  declare_preprocessor_constant(\"JVMCI::cache_full\",           JVMCI::cache_full)              \\\n-  declare_preprocessor_constant(\"JVMCI::code_too_large\",       JVMCI::code_too_large)          \\\n+  declare_preprocessor_constant(\"JVMCI::ok\",                      JVMCI::ok)                      \\\n+  declare_preprocessor_constant(\"JVMCI::dependencies_failed\",     JVMCI::dependencies_failed)     \\\n+  declare_preprocessor_constant(\"JVMCI::cache_full\",              JVMCI::cache_full)              \\\n+  declare_preprocessor_constant(\"JVMCI::code_too_large\",          JVMCI::code_too_large)          \\\n+  declare_preprocessor_constant(\"JVMCI::nmethod_reclaimed\",       JVMCI::nmethod_reclaimed)       \\\n+  declare_preprocessor_constant(\"JVMCI::first_permanent_bailout\", JVMCI::first_permanent_bailout) \\\n+                                                                          \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-  DEBUG_ONLY(const LogDecorators& _decorators;)\n+  DEBUG_ONLY(const LogDecorators _decorators;)\n","filename":"src\/hotspot\/share\/logging\/logDecorations.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -288,0 +288,13 @@\n+class RotationLocker : public StackObj {\n+  Semaphore& _sem;\n+\n+ public:\n+  RotationLocker(Semaphore& sem) : _sem(sem) {\n+    sem.wait();\n+  }\n+\n+  ~RotationLocker() {\n+    _sem.signal();\n+  }\n+};\n+\n@@ -289,1 +302,6 @@\n-  _rotation_semaphore.wait();\n+  RotationLocker lock(_rotation_semaphore);\n+  if (_stream == NULL) {\n+    \/\/ An error has occurred with this output, avoid writing to it.\n+    return 0;\n+  }\n+\n@@ -298,1 +316,0 @@\n-  _rotation_semaphore.signal();\n@@ -330,1 +347,1 @@\n-  _rotation_semaphore.wait();\n+  RotationLocker lock(_rotation_semaphore);\n@@ -339,1 +356,0 @@\n-  _rotation_semaphore.signal();\n@@ -366,1 +382,2 @@\n-  _rotation_semaphore.wait();\n+\n+  RotationLocker lock(_rotation_semaphore);\n@@ -368,1 +385,0 @@\n-  _rotation_semaphore.signal();\n@@ -372,1 +388,0 @@\n-\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -266,0 +266,15 @@\n+  \/\/ There are functions that all subtypes of MetaspaceObj are expected\n+  \/\/ to implement, so that templates which are defined for this class hierarchy\n+  \/\/ can work uniformly. Within the sub-hierarchy of Metadata, these are virtuals.\n+  \/\/ Elsewhere in the hierarchy of MetaspaceObj, type(), size(), and\/or on_stack()\n+  \/\/ can be static if constant.\n+  \/\/\n+  \/\/ The following functions are required by MetaspaceClosure:\n+  \/\/   void metaspace_pointers_do(MetaspaceClosure* it) { <walk my refs> }\n+  \/\/   int size() const { return align_up(sizeof(<This>), wordSize) \/ wordSize; }\n+  \/\/   MetaspaceObj::Type type() const { return <This>Type; }\n+  \/\/\n+  \/\/ The following functions are required by MetadataFactory::free_metadata():\n+  \/\/   bool on_stack() { return false; }\n+  \/\/   void deallocate_contents(ClassLoaderData* loader_data);\n+\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -745,0 +745,3 @@\n+    if (!FLAG_IS_DEFAULT(CompressedClassSpaceBaseAddress)) {\n+      log_warning(metaspace)(\"CDS active - ignoring CompressedClassSpaceBaseAddress.\");\n+    }\n@@ -760,1 +763,1 @@\n-    \/\/ case (b)\n+    \/\/ case (b) (No CDS)\n@@ -762,10 +765,0 @@\n-\n-    \/\/ If UseCompressedOops=1 and the java heap has been placed in coops-friendly\n-    \/\/  territory, i.e. its base is under 32G, then we attempt to place ccs\n-    \/\/  right above the java heap.\n-    \/\/ Otherwise the lower 32G are still free. We try to place ccs at the lowest\n-    \/\/ allowed mapping address.\n-    address base = (UseCompressedOops && (uint64_t)CompressedOops::base() < OopEncodingHeapMax) ?\n-                   CompressedOops::end() : (address)HeapBaseMinAddress;\n-    base = align_up(base, Metaspace::reserve_alignment());\n-\n@@ -773,4 +766,40 @@\n-    if (base != NULL) {\n-      if (CompressedKlassPointers::is_valid_base(base)) {\n-        rs = ReservedSpace(size, Metaspace::reserve_alignment(),\n-                           os::vm_page_size(), (char*)base);\n+    address base = NULL;\n+\n+    \/\/ If CompressedClassSpaceBaseAddress is set, we attempt to force-map class space to\n+    \/\/ the given address. This is a debug-only feature aiding tests. Due to the ASLR lottery\n+    \/\/ this may fail, in which case the VM will exit after printing an appropiate message.\n+    \/\/ Tests using this switch should cope with that.\n+    if (CompressedClassSpaceBaseAddress != 0) {\n+      base = (address)CompressedClassSpaceBaseAddress;\n+      if (!is_aligned(base, Metaspace::reserve_alignment())) {\n+        vm_exit_during_initialization(\n+            err_msg(\"CompressedClassSpaceBaseAddress=\" PTR_FORMAT \" invalid \"\n+                    \"(must be aligned to \" SIZE_FORMAT_HEX \").\",\n+                    CompressedClassSpaceBaseAddress, Metaspace::reserve_alignment()));\n+      }\n+      rs = ReservedSpace(size, Metaspace::reserve_alignment(),\n+                         os::vm_page_size() \/* large *\/, (char*)base);\n+      if (rs.is_reserved()) {\n+        log_info(metaspace)(\"Sucessfully forced class space address to \" PTR_FORMAT, p2i(base));\n+      } else {\n+        vm_exit_during_initialization(\n+            err_msg(\"CompressedClassSpaceBaseAddress=\" PTR_FORMAT \" given, but reserving class space failed.\",\n+                CompressedClassSpaceBaseAddress));\n+      }\n+    }\n+\n+    if (!rs.is_reserved()) {\n+      \/\/ If UseCompressedOops=1 and the java heap has been placed in coops-friendly\n+      \/\/  territory, i.e. its base is under 32G, then we attempt to place ccs\n+      \/\/  right above the java heap.\n+      \/\/ Otherwise the lower 32G are still free. We try to place ccs at the lowest\n+      \/\/ allowed mapping address.\n+      base = (UseCompressedOops && (uint64_t)CompressedOops::base() < OopEncodingHeapMax) ?\n+              CompressedOops::end() : (address)HeapBaseMinAddress;\n+      base = align_up(base, Metaspace::reserve_alignment());\n+\n+      if (base != NULL) {\n+        if (CompressedKlassPointers::is_valid_base(base)) {\n+          rs = ReservedSpace(size, Metaspace::reserve_alignment(),\n+                             os::vm_page_size(), (char*)base);\n+        }\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":44,"deletions":15,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-  size_t cap() const                          { return _cap; }\n","filename":"src\/hotspot\/share\/memory\/metaspace\/commitLimiter.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2499,0 +2499,1 @@\n+  assert(!shared_loading_failed(), \"Must not try to load failed class again\");\n@@ -3309,2 +3310,0 @@\n-#ifndef PRODUCT\n-\n@@ -3460,2 +3459,0 @@\n-#endif \/\/PRODUCT\n-\n@@ -3468,2 +3465,0 @@\n-#ifndef PRODUCT\n-\n@@ -3527,0 +3522,2 @@\n+#ifndef PRODUCT\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-#ifndef PRODUCT\n@@ -89,1 +88,0 @@\n-#endif  \/\/ !PRODUCT\n@@ -212,4 +210,3 @@\n-  int             _static_field_size;    \/\/ number words used by static fields (oop and non-oop) in this klass\n-\n-  int             _nonstatic_oop_map_size;\/\/ size in words of nonstatic oop map blocks\n-  int             _itable_len;           \/\/ length of Java itable (in words)\n+  int             _static_field_size;       \/\/ number words used by static fields (oop and non-oop) in this klass\n+  int             _nonstatic_oop_map_size;  \/\/ size in words of nonstatic oop map blocks\n+  int             _itable_len;              \/\/ length of Java itable (in words)\n@@ -220,1 +217,3 @@\n-  u2              _this_class_index;              \/\/ constant pool entry\n+  u2              _this_class_index;        \/\/ constant pool entry\n+  u2              _static_oop_field_count;  \/\/ number of static oop fields in this klass\n+  u2              _java_fields_count;       \/\/ The number of declared Java fields\n@@ -222,4 +221,1 @@\n-  u2              _static_oop_field_count;\/\/ number of static oop fields in this klass\n-  u2              _java_fields_count;    \/\/ The number of declared Java fields\n-\n-  volatile u2     _idnum_allocated_count;         \/\/ JNI\/JVMTI: increments with the addition of methods, old ids don't change\n+  volatile u2     _idnum_allocated_count;   \/\/ JNI\/JVMTI: increments with the addition of methods, old ids don't change\n@@ -229,1 +225,1 @@\n-  bool            _is_marked_dependent;  \/\/ used for marking during flushing and deoptimization\n+  bool            _is_marked_dependent;     \/\/ used for marking during flushing and deoptimization\n@@ -234,1 +230,1 @@\n-  u1              _init_state;                    \/\/ state of class\n+  u1              _init_state;              \/\/ state of class\n@@ -255,1 +251,1 @@\n-    _unused                                   = 1 << 8,  \/\/\n+    _misc_shared_loading_failed               = 1 << 8,  \/\/ class has been loaded from shared archive\n@@ -360,0 +356,12 @@\n+  bool shared_loading_failed() const {\n+    return (_misc_flags & _misc_shared_loading_failed) != 0;\n+  }\n+\n+  void set_shared_loading_failed() {\n+    _misc_flags |= _misc_shared_loading_failed;\n+  }\n+\n+  void clear_shared_loading_failed() {\n+    _misc_flags &= ~_misc_shared_loading_failed;\n+  }\n+\n@@ -1243,1 +1251,0 @@\n-#ifndef PRODUCT\n@@ -1245,1 +1252,0 @@\n-#endif\n@@ -1250,1 +1256,0 @@\n-#ifndef PRODUCT\n@@ -1253,0 +1258,1 @@\n+#ifndef PRODUCT\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":23,"deletions":17,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -260,1 +260,0 @@\n-  inline oop forwardee_acquire() const;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -308,7 +308,0 @@\n-\/\/ Note that the forwardee is not the same thing as the displaced_mark.\n-\/\/ The forwardee is used when copying during scavenge and mark-sweep.\n-\/\/ It does need to clear the low two locking- and GC-related bits.\n-oop oopDesc::forwardee_acquire() const {\n-  return cast_to_oop(Atomic::load_acquire(&_mark).decode_pointer());\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -741,1 +741,1 @@\n-  int lane_count = ArrayCopyPartialInlineSize\/type2aelembytes(type);\n+  int lane_count = ArrayOperationPartialInlineSize\/type2aelembytes(type);\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,3 +85,4 @@\n-  product(intx, ArrayCopyPartialInlineSize, -1, DIAGNOSTIC,                 \\\n-          \"Partial inline size used for array copy acceleration.\")          \\\n-          range(-1, 64)                                                     \\\n+  product(intx, ArrayOperationPartialInlineSize, 0, DIAGNOSTIC,             \\\n+          \"Partial inline size used for small array operations\"             \\\n+          \"(e.g. copy,cmp) acceleration.\")                                  \\\n+          range(0, 64)                                                      \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -109,0 +109,15 @@\n+  case Op_CastFF: {\n+    Node* cast = new CastFFNode(n, t, carry_dependency);\n+    cast->set_req(0, c);\n+    return cast;\n+  }\n+  case Op_CastDD: {\n+    Node* cast = new CastDDNode(n, t, carry_dependency);\n+    cast->set_req(0, c);\n+    return cast;\n+  }\n+  case Op_CastVV: {\n+    Node* cast = new CastVVNode(n, t, carry_dependency);\n+    cast->set_req(0, c);\n+    return cast;\n+  }\n@@ -560,0 +575,18 @@\n+\n+Node* ConstraintCastNode::make_cast_for_type(Node* c, Node* in, const Type* type) {\n+  Node* cast= NULL;\n+  if (type->isa_int()) {\n+    cast = make_cast(Op_CastII, c, in, type, true);\n+  } else if (type->isa_long()) {\n+    cast = make_cast(Op_CastLL, c, in, type, true);\n+  } else if (type->isa_float()) {\n+    cast = make_cast(Op_CastFF, c, in, type, true);\n+  } else if (type->isa_double()) {\n+    cast = make_cast(Op_CastDD, c, in, type, true);\n+  } else if (type->isa_vect()) {\n+    cast = make_cast(Op_CastVV, c, in, type, true);\n+  } else if (type->isa_ptr()) {\n+    cast = make_cast(Op_CastPP, c, in, type, true);\n+  }\n+  return cast;\n+}\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+\n+  static Node* make_cast_for_type(Node* c, Node* in, const Type* type);\n@@ -81,0 +83,5 @@\n+  CastIINode(Node* ctrl, Node* n, const Type* t, bool carry_dependency = false, bool range_check_dependency = false)\n+    : ConstraintCastNode(n, t, carry_dependency), _range_check_dependency(range_check_dependency) {\n+    init_class_id(Class_CastII);\n+    init_req(0, ctrl);\n+  }\n@@ -106,0 +113,5 @@\n+  CastLLNode(Node* ctrl, Node* n, const Type* t, bool carry_dependency = false)\n+    : ConstraintCastNode(n, t, carry_dependency) {\n+    init_class_id(Class_CastLL);\n+    init_req(0, ctrl);\n+  }\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1972,1 +1972,0 @@\n-      assert(phi_type->isa_int() || phi_type->isa_ptr() || phi_type->isa_long(), \"bad phi type\");\n@@ -1976,5 +1975,1 @@\n-      if (phi_type->isa_int()) {\n-        cast = ConstraintCastNode::make_cast(Op_CastII, r, uin, phi_type, true);\n-      } else if (phi_type->isa_long()) {\n-        cast = ConstraintCastNode::make_cast(Op_CastLL, r, uin, phi_type, true);\n-      } else {\n+      if (phi_type->isa_ptr()) {\n@@ -2011,0 +2006,2 @@\n+      } else {\n+        cast = ConstraintCastNode::make_cast_for_type(r, uin, phi_type);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -420,0 +420,1 @@\n+macro(VectorCmpMasked)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3413,0 +3413,1 @@\n+  case Op_VectorCmpMasked:\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5239,1 +5239,1 @@\n-  assert(UseVectorizedMismatchIntrinsic, \"not implementated on this platform\");\n+  assert(UseVectorizedMismatchIntrinsic, \"not implemented on this platform\");\n@@ -5241,6 +5241,0 @@\n-  address stubAddr = StubRoutines::vectorizedMismatch();\n-  if (stubAddr == NULL) {\n-    return false; \/\/ Intrinsic's stub is not implemented on this platform\n-  }\n-  const char* stubName = \"vectorizedMismatch\";\n-  int size_l = callee()->signature()->size();\n@@ -5248,0 +5242,6 @@\n+  Node* obja    = argument(0); \/\/ Object\n+  Node* aoffset = argument(1); \/\/ long\n+  Node* objb    = argument(3); \/\/ Object\n+  Node* boffset = argument(4); \/\/ long\n+  Node* length  = argument(6); \/\/ int\n+  Node* scale   = argument(7); \/\/ int\n@@ -5249,15 +5249,6 @@\n-  Node* obja = argument(0);\n-  Node* aoffset = argument(1);\n-  Node* objb = argument(3);\n-  Node* boffset = argument(4);\n-  Node* length = argument(6);\n-  Node* scale = argument(7);\n-\n-  const Type* a_type = obja->Value(&_gvn);\n-  const Type* b_type = objb->Value(&_gvn);\n-  const TypeAryPtr* top_a = a_type->isa_aryptr();\n-  const TypeAryPtr* top_b = b_type->isa_aryptr();\n-  if (top_a == NULL || top_a->klass() == NULL ||\n-    top_b == NULL || top_b->klass() == NULL) {\n-    \/\/ failed array check\n-    return false;\n+  const TypeAryPtr* obja_t = _gvn.type(obja)->isa_aryptr();\n+  const TypeAryPtr* objb_t = _gvn.type(objb)->isa_aryptr();\n+  if (obja_t == NULL || obja_t->klass() == NULL ||\n+      objb_t == NULL || objb_t->klass() == NULL ||\n+      scale == top()) {\n+    return false; \/\/ failed input validation\n@@ -5266,3 +5257,0 @@\n-  Node* call;\n-  jvms()->set_should_reexecute(true);\n-\n@@ -5272,4 +5260,106 @@\n-  call = make_runtime_call(RC_LEAF,\n-    OptoRuntime::vectorizedMismatch_Type(),\n-    stubAddr, stubName, TypePtr::BOTTOM,\n-    obja_adr, objb_adr, length, scale);\n+  \/\/ Partial inlining handling for inputs smaller than ArrayOperationPartialInlineSize bytes in size.\n+  \/\/\n+  \/\/    inline_limit = ArrayOperationPartialInlineSize \/ element_size;\n+  \/\/    if (length <= inline_limit) {\n+  \/\/      inline_path:\n+  \/\/        vmask   = VectorMaskGen length\n+  \/\/        vload1  = LoadVectorMasked obja, vmask\n+  \/\/        vload2  = LoadVectorMasked objb, vmask\n+  \/\/        result1 = VectorCmpMasked vload1, vload2, vmask\n+  \/\/    } else {\n+  \/\/      call_stub_path:\n+  \/\/        result2 = call vectorizedMismatch_stub(obja, objb, length, scale)\n+  \/\/    }\n+  \/\/    exit_block:\n+  \/\/      return Phi(result1, result2);\n+  \/\/\n+  enum { inline_path = 1,  \/\/ input is small enough to process it all at once\n+         stub_path   = 2,  \/\/ input is too large; call into the VM\n+         PATH_LIMIT  = 3\n+  };\n+\n+  Node* exit_block = new RegionNode(PATH_LIMIT);\n+  Node* result_phi = new PhiNode(exit_block, TypeInt::INT);\n+  Node* memory_phi = new PhiNode(exit_block, Type::MEMORY, TypePtr::BOTTOM);\n+\n+  Node* call_stub_path = control();\n+\n+  BasicType elem_bt = T_ILLEGAL;\n+\n+  const TypeInt* scale_t = _gvn.type(scale)->is_int();\n+  if (scale_t->is_con()) {\n+    switch (scale_t->get_con()) {\n+      case 0: elem_bt = T_BYTE;  break;\n+      case 1: elem_bt = T_SHORT; break;\n+      case 2: elem_bt = T_INT;   break;\n+      case 3: elem_bt = T_LONG;  break;\n+\n+      default: elem_bt = T_ILLEGAL; break; \/\/ not supported\n+    }\n+  }\n+\n+  int inline_limit = 0;\n+  bool do_partial_inline = false;\n+\n+  if (elem_bt != T_ILLEGAL && ArrayOperationPartialInlineSize > 0) {\n+    inline_limit = ArrayOperationPartialInlineSize \/ type2aelembytes(elem_bt);\n+    do_partial_inline = inline_limit >= 16;\n+  }\n+\n+  if (do_partial_inline) {\n+    assert(elem_bt != T_ILLEGAL, \"sanity\");\n+\n+    const TypeVect* vt = TypeVect::make(elem_bt, inline_limit);\n+\n+    if (Matcher::match_rule_supported_vector(Op_VectorMaskGen,    inline_limit, elem_bt) &&\n+        Matcher::match_rule_supported_vector(Op_LoadVectorMasked, inline_limit, elem_bt) &&\n+        Matcher::match_rule_supported_vector(Op_VectorCmpMasked,  inline_limit, elem_bt)) {\n+\n+      Node* cmp_length = _gvn.transform(new CmpINode(length, intcon(inline_limit)));\n+      Node* bol_gt     = _gvn.transform(new BoolNode(cmp_length, BoolTest::gt));\n+\n+      call_stub_path = generate_guard(bol_gt, NULL, PROB_MIN);\n+\n+      if (!stopped()) {\n+        Node* casted_length = _gvn.transform(new CastIINode(control(), length, TypeInt::make(0, inline_limit, Type::WidenMin)));\n+\n+        const TypePtr* obja_adr_t = _gvn.type(obja_adr)->isa_ptr();\n+        const TypePtr* objb_adr_t = _gvn.type(objb_adr)->isa_ptr();\n+        Node* obja_adr_mem = memory(C->get_alias_index(obja_adr_t));\n+        Node* objb_adr_mem = memory(C->get_alias_index(objb_adr_t));\n+\n+        Node* vmask      = _gvn.transform(new VectorMaskGenNode(ConvI2X(casted_length), TypeVect::VECTMASK, elem_bt));\n+        Node* vload_obja = _gvn.transform(new LoadVectorMaskedNode(control(), obja_adr_mem, obja_adr, obja_adr_t, vt, vmask));\n+        Node* vload_objb = _gvn.transform(new LoadVectorMaskedNode(control(), objb_adr_mem, objb_adr, objb_adr_t, vt, vmask));\n+        Node* result     = _gvn.transform(new VectorCmpMaskedNode(vload_obja, vload_objb, vmask, TypeInt::INT));\n+\n+        exit_block->init_req(inline_path, control());\n+        memory_phi->init_req(inline_path, map()->memory());\n+        result_phi->init_req(inline_path, result);\n+\n+        C->set_max_vector_size(MAX2((uint)ArrayOperationPartialInlineSize, C->max_vector_size()));\n+        clear_upper_avx();\n+      }\n+    }\n+  }\n+\n+  if (call_stub_path != NULL) {\n+    set_control(call_stub_path);\n+\n+    Node* call = make_runtime_call(RC_LEAF,\n+                                   OptoRuntime::vectorizedMismatch_Type(),\n+                                   StubRoutines::vectorizedMismatch(), \"vectorizedMismatch\", TypePtr::BOTTOM,\n+                                   obja_adr, objb_adr, length, scale);\n+\n+    exit_block->init_req(stub_path, control());\n+    memory_phi->init_req(stub_path, map()->memory());\n+    result_phi->init_req(stub_path, _gvn.transform(new ProjNode(call, TypeFunc::Parms)));\n+  }\n+\n+  exit_block = _gvn.transform(exit_block);\n+  memory_phi = _gvn.transform(memory_phi);\n+  result_phi = _gvn.transform(result_phi);\n+\n+  set_control(exit_block);\n+  set_all_memory(memory_phi);\n+  set_result(result_phi);\n@@ -5277,2 +5367,0 @@\n-  Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n-  set_result(result);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":119,"deletions":31,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -1774,28 +1774,0 @@\n-    if (inner_out->outcnt() != 1) {\n-      ResourceMark rm;\n-      Unique_Node_List wq;\n-\n-      for (DUIterator_Fast imax, i = inner_out->fast_outs(imax); i < imax; i++) {\n-        Node* u = inner_out->fast_out(i);\n-        if (u == sfpt) {\n-          continue;\n-        }\n-        wq.clear();\n-        wq.push(u);\n-        bool found_sfpt = false;\n-        for (uint next = 0; next < wq.size() && !found_sfpt; next++) {\n-          Node* n = wq.at(next);\n-          for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax && !found_sfpt; i++) {\n-            Node* u = n->fast_out(i);\n-            if (u == sfpt) {\n-              found_sfpt = true;\n-            }\n-            if (!u->is_CFG()) {\n-              wq.push(u);\n-            }\n-          }\n-        }\n-        assert(found_sfpt, \"no node in loop that's not input to safepoint\");\n-      }\n-    }\n-\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1514,13 +1514,1 @@\n-                if (in_t->isa_int()) {\n-                  cast = new CastIINode(in, in_t, true);\n-                } else if (in_t->isa_long()) {\n-                  cast = new CastLLNode(in, in_t, true);\n-                } else if (in_t->isa_ptr()) {\n-                  cast = new CastPPNode(in, in_t, true);\n-                } else if (in_t->isa_float()) {\n-                  cast = new CastFFNode(in, in_t, true);\n-                } else if (in_t->isa_double()) {\n-                  cast = new CastDDNode(in, in_t, true);\n-                } else if (in_t->isa_vect()) {\n-                  cast = new CastVVNode(in, in_t, true);\n-                }\n+                cast = ConstraintCastNode::make_cast_for_type(x_ctrl, in, in_t);\n@@ -1529,1 +1517,0 @@\n-                cast->set_req(0, x_ctrl);\n@@ -1993,1 +1980,1 @@\n-      Node* c = phase->get_ctrl(u);\n+      Node* c = u->in(0) != NULL ? u->in(0) : phase->get_ctrl(u);\n@@ -2116,0 +2103,6 @@\n+\n+    Node* inner_out = sfpt->in(0);\n+    if (inner_out->outcnt() > 1) {\n+      clone_outer_loop_helper(inner_out, loop, outer_loop, old_new, wq, this, true);\n+    }\n+\n@@ -2121,0 +2114,3 @@\n+      if (n->in(0) != NULL) {\n+        _igvn.replace_input_of(n, 0, new_ctrl);\n+      }\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"opto\/castnode.hpp\"\n@@ -177,2 +178,2 @@\n-\/\/ length(in bytes) less than ArrayCopyPartialInlineSize.\n-\/\/  if (length <= ArrayCopyPartialInlineSize) {\n+\/\/ length(in bytes) less than ArrayOperationPartialInlineSize.\n+\/\/  if (length <= ArrayOperationPartialInlineSize) {\n@@ -219,1 +220,1 @@\n-  if ( const_len > ArrayCopyPartialInlineSize ||\n+  if ( const_len > ArrayOperationPartialInlineSize ||\n@@ -226,0 +227,3 @@\n+  int inline_limit = ArrayOperationPartialInlineSize \/ type2aelembytes(type);\n+  Node* casted_length = new CastLLNode(*ctrl, length, TypeLong::make(0, inline_limit, Type::WidenMin));\n+  transform_later(casted_length);\n@@ -229,1 +233,1 @@\n-  Node* cmp_le = new CmpULNode(copy_bytes, longcon(ArrayCopyPartialInlineSize));\n+  Node* cmp_le = new CmpULNode(copy_bytes, longcon(ArrayOperationPartialInlineSize));\n@@ -236,1 +240,1 @@\n-  Node* mask_gen =  new VectorMaskGenNode(length, TypeVect::VECTMASK, Type::get_const_basic_type(type));\n+  Node* mask_gen =  new VectorMaskGenNode(casted_length, TypeVect::VECTMASK, type);\n@@ -1190,1 +1194,1 @@\n-  if (ArrayCopyPartialInlineSize > 0 && is_subword_type(basic_elem_type) &&\n+  if (ArrayOperationPartialInlineSize > 0 && is_subword_type(basic_elem_type) &&\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2230,0 +2230,1 @@\n+    case Op_VectorCmpMasked:\n@@ -2323,0 +2324,6 @@\n+    case Op_VectorCmpMasked: {\n+      Node* pair1 = new BinaryNode(n->in(2), n->in(3));\n+      n->set_req(2, pair1);\n+      n->del_req(3);\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -505,2 +505,0 @@\n-  void do_irem();\n-\n@@ -547,1 +545,0 @@\n-  Node*   jump_if_join(Node* iffalse, Node* iftrue);\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -221,11 +221,0 @@\n-\/\/ return Region node\n-Node* Parse::jump_if_join(Node* iffalse, Node* iftrue) {\n-  Node *region  = new RegionNode(3); \/\/ 2 results\n-  record_for_igvn(region);\n-  region->init_req(1, iffalse);\n-  region->init_req(2, iftrue );\n-  _gvn.set_type(region, Type::CONTROL);\n-  region = _gvn.transform(region);\n-  set_control (region);\n-  return region;\n-}\n@@ -1161,44 +1150,0 @@\n-void Parse::do_irem() {\n-  \/\/ Must keep both values on the expression-stack during null-check\n-  zero_check_int(peek());\n-  \/\/ Compile-time detect of null-exception?\n-  if (stopped())  return;\n-\n-  Node* b = pop();\n-  Node* a = pop();\n-\n-  const Type *t = _gvn.type(b);\n-  if (t != Type::TOP) {\n-    const TypeInt *ti = t->is_int();\n-    if (ti->is_con()) {\n-      int divisor = ti->get_con();\n-      \/\/ check for positive power of 2\n-      if (divisor > 0 &&\n-          (divisor & ~(divisor-1)) == divisor) {\n-        \/\/ yes !\n-        Node *mask = _gvn.intcon((divisor - 1));\n-        \/\/ Sigh, must handle negative dividends\n-        Node *zero = _gvn.intcon(0);\n-        IfNode *ifff = jump_if_fork_int(a, zero, BoolTest::lt, PROB_FAIR, COUNT_UNKNOWN);\n-        Node *iff = _gvn.transform( new IfFalseNode(ifff) );\n-        Node *ift = _gvn.transform( new IfTrueNode (ifff) );\n-        Node *reg = jump_if_join(ift, iff);\n-        Node *phi = PhiNode::make(reg, NULL, TypeInt::INT);\n-        \/\/ Negative path; negate\/and\/negate\n-        Node *neg = _gvn.transform( new SubINode(zero, a) );\n-        Node *andn= _gvn.transform( new AndINode(neg, mask) );\n-        Node *negn= _gvn.transform( new SubINode(zero, andn) );\n-        phi->init_req(1, negn);\n-        \/\/ Fast positive case\n-        Node *andx = _gvn.transform( new AndINode(a, mask) );\n-        phi->init_req(2, andx);\n-        \/\/ Push the merge\n-        push( _gvn.transform(phi) );\n-        return;\n-      }\n-    }\n-  }\n-  \/\/ Default case\n-  push( _gvn.transform( new ModINode(control(),a,b) ) );\n-}\n-\n@@ -2199,1 +2144,7 @@\n-    do_irem();\n+    \/\/ Must keep both values on the expression-stack during null-check\n+    zero_check_int(peek());\n+    \/\/ Compile-time detect of null-exception?\n+    if (stopped())  return;\n+    b = pop();\n+    a = pop();\n+    push(_gvn.transform(new ModINode(control(), a, b)));\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":7,"deletions":56,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -409,1 +409,0 @@\n-    BasicType elem_bt;\n@@ -414,3 +413,0 @@\n-      if (vec_unbox->is_shuffle_to_vector() == true) {\n-        elem_bt = bt;\n-      }\n@@ -462,7 +458,3 @@\n-    } else if (is_vector_shuffle(from_kls)) {\n-      if (vec_unbox->is_shuffle_to_vector() == false) {\n-        assert(vec_unbox->bottom_type()->is_vect()->element_basic_type() == masktype, \"expect shuffle type consistency\");\n-        vec_val_load = gvn.transform(new VectorLoadShuffleNode(vec_val_load, TypeVect::make(masktype, num_elem)));\n-      } else {\n-        vec_val_load = gvn.transform(VectorCastNode::make(Op_VectorCastB2X, vec_val_load, elem_bt, num_elem));\n-      }\n+    } else if (is_vector_shuffle(from_kls) && !vec_unbox->is_shuffle_to_vector()) {\n+      assert(vec_unbox->bottom_type()->is_vect()->element_basic_type() == masktype, \"expect shuffle type consistency\");\n+      vec_val_load = gvn.transform(new VectorLoadShuffleNode(vec_val_load, TypeVect::make(masktype, num_elem)));\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -581,1 +581,5 @@\n-  Node* shuffle_vec = unbox_vector(shuffle, shuffle_box_type, elem_bt, num_elem, true);\n+  \/\/ shuffle is a byte array\n+  Node* shuffle_vec = unbox_vector(shuffle, shuffle_box_type, T_BYTE, num_elem, true);\n+\n+  \/\/ cast byte to target element type\n+  shuffle_vec = gvn().transform(VectorCastNode::make(cast_vopc, shuffle_vec, elem_bt, num_elem));\n@@ -1591,1 +1595,1 @@\n-  if (is_vector_shuffle(vbox_klass_from) || is_vector_shuffle(vbox_klass_to)) {\n+  if (is_vector_shuffle(vbox_klass_from)) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -724,11 +724,13 @@\n-  Node* mask_len = in(3)->in(1);\n-  const TypeLong* ty = phase->type(mask_len)->isa_long();\n-  if (ty && ty->is_con()) {\n-    BasicType mask_bt = ((VectorMaskGenNode*)in(3))->get_elem_type()->array_element_basic_type();\n-    uint load_sz      = type2aelembytes(mask_bt) * ty->get_con();\n-    if ( load_sz == 32 || load_sz == 64) {\n-      assert(load_sz == 32 || MaxVectorSize > 32, \"Unexpected load size\");\n-      Node* ctr = in(MemNode::Control);\n-      Node* mem = in(MemNode::Memory);\n-      Node* adr = in(MemNode::Address);\n-      return phase->transform(new LoadVectorNode(ctr, mem, adr, adr_type(), vect_type()));\n+  if (!in(3)->is_top() && in(3)->Opcode() == Op_VectorMaskGen) {\n+    Node* mask_len = in(3)->in(1);\n+    const TypeLong* ty = phase->type(mask_len)->isa_long();\n+    if (ty && ty->is_con()) {\n+      BasicType mask_bt = ((VectorMaskGenNode*)in(3))->get_elem_type();\n+      uint load_sz      = type2aelembytes(mask_bt) * ty->get_con();\n+      if ( load_sz == 32 || load_sz == 64) {\n+        assert(load_sz == 32 || MaxVectorSize > 32, \"Unexpected load size\");\n+        Node* ctr = in(MemNode::Control);\n+        Node* mem = in(MemNode::Memory);\n+        Node* adr = in(MemNode::Address);\n+        return phase->transform(new LoadVectorNode(ctr, mem, adr, adr_type(), vect_type()));\n+      }\n@@ -741,12 +743,14 @@\n-  Node* mask_len = in(4)->in(1);\n-  const TypeLong* ty = phase->type(mask_len)->isa_long();\n-  if (ty && ty->is_con()) {\n-    BasicType mask_bt = ((VectorMaskGenNode*)in(4))->get_elem_type()->array_element_basic_type();\n-    uint load_sz      = type2aelembytes(mask_bt) * ty->get_con();\n-    if ( load_sz == 32 || load_sz == 64) {\n-      assert(load_sz == 32 || MaxVectorSize > 32, \"Unexpected store size\");\n-      Node* ctr = in(MemNode::Control);\n-      Node* mem = in(MemNode::Memory);\n-      Node* adr = in(MemNode::Address);\n-      Node* val = in(MemNode::ValueIn);\n-      return phase->transform(new StoreVectorNode(ctr, mem, adr, adr_type(), val));\n+  if (!in(4)->is_top() && in(4)->Opcode() == Op_VectorMaskGen) {\n+    Node* mask_len = in(4)->in(1);\n+    const TypeLong* ty = phase->type(mask_len)->isa_long();\n+    if (ty && ty->is_con()) {\n+      BasicType mask_bt = ((VectorMaskGenNode*)in(4))->get_elem_type();\n+      uint load_sz      = type2aelembytes(mask_bt) * ty->get_con();\n+      if ( load_sz == 32 || load_sz == 64) {\n+        assert(load_sz == 32 || MaxVectorSize > 32, \"Unexpected store size\");\n+        Node* ctr = in(MemNode::Control);\n+        Node* mem = in(MemNode::Memory);\n+        Node* adr = in(MemNode::Address);\n+        Node* val = in(MemNode::ValueIn);\n+        return phase->transform(new StoreVectorNode(ctr, mem, adr, adr_type(), val));\n+      }\n@@ -1246,4 +1250,1 @@\n-          if (is_shuffle_to_vector()) {\n-            \/\/ VectorUnbox (VectorBox vshuffle) ==> VectorCastB2X vshuffle\n-            return new VectorCastB2XNode(value, out_vt);\n-          } else {\n+          if (!is_shuffle_to_vector()) {\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":28,"deletions":27,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -803,0 +803,2 @@\n+\/\/------------------------------StoreVectorMaskedNode--------------------------------\n+\/\/ Store Vector to memory under the influence of a predicate register(mask).\n@@ -821,0 +823,2 @@\n+\/\/------------------------------LoadVectorMaskedNode--------------------------------\n+\/\/ Load Vector from memory under the influence of a predicate register(mask).\n@@ -839,0 +843,15 @@\n+\n+\/\/------------------------------VectorCmpMaskedNode--------------------------------\n+\/\/ Vector Comparison under the influence of a predicate register(mask).\n+class VectorCmpMaskedNode : public TypeNode {\n+  public:\n+   VectorCmpMaskedNode(Node* src1, Node* src2, Node* mask, const Type* ty): TypeNode(ty, 4)  {\n+     init_req(1, src1);\n+     init_req(2, src2);\n+     init_req(3, mask);\n+   }\n+\n+  virtual int Opcode() const;\n+};\n+\n+\n@@ -841,1 +860,1 @@\n-  VectorMaskGenNode(Node* length, const Type* ty, const Type* ety): TypeNode(ty, 2), _elemType(ety) {\n+  VectorMaskGenNode(Node* length, const Type* ty, BasicType ety): TypeNode(ty, 2), _elemType(ety) {\n@@ -846,1 +865,1 @@\n-  const Type* get_elem_type()  { return _elemType;}\n+  BasicType get_elem_type()  { return _elemType;}\n@@ -853,1 +872,1 @@\n-   const Type* _elemType;\n+   BasicType _elemType;\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -446,0 +446,2 @@\n+    EventSystemGC event;\n+    event.set_invokedConcurrent(ExplicitGCInvokesConcurrent);\n@@ -447,0 +449,1 @@\n+    event.commit();\n@@ -3523,5 +3526,5 @@\n-                                              jstring invokedName,\n-                                              jobject invokedType,\n-                                              jobject methodType,\n-                                              jobject implMethodMember,\n-                                              jobject instantiatedMethodType,\n+                                              jstring interfaceMethodName,\n+                                              jobject factoryType,\n+                                              jobject interfaceMethodType,\n+                                              jobject implementationMember,\n+                                              jobject dynamicMethodType,\n@@ -3547,3 +3550,3 @@\n-  Symbol* invoked_name = NULL;\n-  if (invokedName != NULL) {\n-    invoked_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(invokedName));\n+  Symbol* interface_method_name = NULL;\n+  if (interfaceMethodName != NULL) {\n+    interface_method_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(interfaceMethodName));\n@@ -3551,2 +3554,2 @@\n-  Handle invoked_type_oop(THREAD, JNIHandles::resolve_non_null(invokedType));\n-  Symbol* invoked_type = java_lang_invoke_MethodType::as_signature(invoked_type_oop(), true);\n+  Handle factory_type_oop(THREAD, JNIHandles::resolve_non_null(factoryType));\n+  Symbol* factory_type = java_lang_invoke_MethodType::as_signature(factory_type_oop(), true);\n@@ -3554,2 +3557,2 @@\n-  Handle method_type_oop(THREAD, JNIHandles::resolve_non_null(methodType));\n-  Symbol* method_type = java_lang_invoke_MethodType::as_signature(method_type_oop(), true);\n+  Handle interface_method_type_oop(THREAD, JNIHandles::resolve_non_null(interfaceMethodType));\n+  Symbol* interface_method_type = java_lang_invoke_MethodType::as_signature(interface_method_type_oop(), true);\n@@ -3557,3 +3560,3 @@\n-  Handle impl_method_member_oop(THREAD, JNIHandles::resolve_non_null(implMethodMember));\n-  assert(java_lang_invoke_MemberName::is_method(impl_method_member_oop()), \"must be\");\n-  Method* m = java_lang_invoke_MemberName::vmtarget(impl_method_member_oop());\n+  Handle implementation_member_oop(THREAD, JNIHandles::resolve_non_null(implementationMember));\n+  assert(java_lang_invoke_MemberName::is_method(implementation_member_oop()), \"must be\");\n+  Method* m = java_lang_invoke_MemberName::vmtarget(implementation_member_oop());\n@@ -3561,2 +3564,2 @@\n-  Handle instantiated_method_type_oop(THREAD, JNIHandles::resolve_non_null(instantiatedMethodType));\n-  Symbol* instantiated_method_type = java_lang_invoke_MethodType::as_signature(instantiated_method_type_oop(), true);\n+  Handle dynamic_method_type_oop(THREAD, JNIHandles::resolve_non_null(dynamicMethodType));\n+  Symbol* dynamic_method_type = java_lang_invoke_MethodType::as_signature(dynamic_method_type_oop(), true);\n@@ -3564,2 +3567,2 @@\n-  SystemDictionaryShared::add_lambda_proxy_class(caller_ik, lambda_ik, invoked_name, invoked_type,\n-                                                 method_type, m, instantiated_method_type, THREAD);\n+  SystemDictionaryShared::add_lambda_proxy_class(caller_ik, lambda_ik, interface_method_name, factory_type,\n+                                                 interface_method_type, m, dynamic_method_type, THREAD);\n@@ -3571,5 +3574,5 @@\n-                                                        jstring invokedName,\n-                                                        jobject invokedType,\n-                                                        jobject methodType,\n-                                                        jobject implMethodMember,\n-                                                        jobject instantiatedMethodType))\n+                                                        jstring interfaceMethodName,\n+                                                        jobject factoryType,\n+                                                        jobject interfaceMethodType,\n+                                                        jobject implementationMember,\n+                                                        jobject dynamicMethodType))\n@@ -3578,2 +3581,2 @@\n-  if (invokedName == NULL || invokedType == NULL || methodType == NULL ||\n-      implMethodMember == NULL || instantiatedMethodType == NULL) {\n+  if (interfaceMethodName == NULL || factoryType == NULL || interfaceMethodType == NULL ||\n+      implementationMember == NULL || dynamicMethodType == NULL) {\n@@ -3590,3 +3593,3 @@\n-  Symbol* invoked_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(invokedName));\n-  Handle invoked_type_oop(THREAD, JNIHandles::resolve_non_null(invokedType));\n-  Symbol* invoked_type = java_lang_invoke_MethodType::as_signature(invoked_type_oop(), true);\n+  Symbol* interface_method_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(interfaceMethodName));\n+  Handle factory_type_oop(THREAD, JNIHandles::resolve_non_null(factoryType));\n+  Symbol* factory_type = java_lang_invoke_MethodType::as_signature(factory_type_oop(), true);\n@@ -3594,2 +3597,2 @@\n-  Handle method_type_oop(THREAD, JNIHandles::resolve_non_null(methodType));\n-  Symbol* method_type = java_lang_invoke_MethodType::as_signature(method_type_oop(), true);\n+  Handle interface_method_type_oop(THREAD, JNIHandles::resolve_non_null(interfaceMethodType));\n+  Symbol* interface_method_type = java_lang_invoke_MethodType::as_signature(interface_method_type_oop(), true);\n@@ -3597,3 +3600,3 @@\n-  Handle impl_method_member_oop(THREAD, JNIHandles::resolve_non_null(implMethodMember));\n-  assert(java_lang_invoke_MemberName::is_method(impl_method_member_oop()), \"must be\");\n-  Method* m = java_lang_invoke_MemberName::vmtarget(impl_method_member_oop());\n+  Handle implementation_member_oop(THREAD, JNIHandles::resolve_non_null(implementationMember));\n+  assert(java_lang_invoke_MemberName::is_method(implementation_member_oop()), \"must be\");\n+  Method* m = java_lang_invoke_MemberName::vmtarget(implementation_member_oop());\n@@ -3601,2 +3604,2 @@\n-  Handle instantiated_method_type_oop(THREAD, JNIHandles::resolve_non_null(instantiatedMethodType));\n-  Symbol* instantiated_method_type = java_lang_invoke_MethodType::as_signature(instantiated_method_type_oop(), true);\n+  Handle dynamic_method_type_oop(THREAD, JNIHandles::resolve_non_null(dynamicMethodType));\n+  Symbol* dynamic_method_type = java_lang_invoke_MethodType::as_signature(dynamic_method_type_oop(), true);\n@@ -3604,2 +3607,2 @@\n-  InstanceKlass* lambda_ik = SystemDictionaryShared::get_shared_lambda_proxy_class(caller_ik, invoked_name, invoked_type,\n-                                                                                   method_type, m, instantiated_method_type);\n+  InstanceKlass* lambda_ik = SystemDictionaryShared::get_shared_lambda_proxy_class(caller_ik, interface_method_name, factory_type,\n+                                                                                   interface_method_type, m, dynamic_method_type);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":41,"deletions":38,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -4966,1 +4966,3 @@\n-        <jvmti\/> version 1.0 and have been superseded by more\n+        <jvmti\/> version 1.0. They are deprecated and will be changed \n+        to return an error in a future release. They were superseded in\n+        <jvmti\/> version 1.2 (Java SE 6) by more \n@@ -15037,0 +15039,3 @@\n+  <change date=\"8 June 2021\" version=\"17.0.0\">\n+      Minor update to deprecate Heap functions 1.0.\n+  <\/change>\n","filename":"src\/hotspot\/share\/prims\/jvmti.xml","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2292,0 +2292,2 @@\n+  \/\/ The collector and\/or state might be NULL if JvmtiDynamicCodeEventCollector\n+  \/\/ has been initialized while JVMTI_EVENT_DYNAMIC_CODE_GENERATED was disabled.\n@@ -2293,6 +2295,6 @@\n-  \/\/ state can only be NULL if the current thread is exiting which\n-  \/\/ should not happen since we're trying to post an event\n-  guarantee(state != NULL, \"attempt to register stub via an exiting thread\");\n-  JvmtiDynamicCodeEventCollector* collector = state->get_dynamic_code_event_collector();\n-  guarantee(collector != NULL, \"attempt to register stub without event collector\");\n-  collector->register_stub(name, code_begin, code_end);\n+  if (state != NULL) {\n+    JvmtiDynamicCodeEventCollector *collector = state->get_dynamic_code_event_collector();\n+    if (collector != NULL) {\n+      collector->register_stub(name, code_begin, code_end);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -132,0 +132,2 @@\n+#endif \/* PRODUCT *\/\n+\n@@ -232,1 +234,0 @@\n-#endif \/* PRODUCT *\/\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,2 +116,2 @@\n-  void print_on(outputStream* st) const         PRODUCT_RETURN;\n-  void print_on_for(outputStream* st, oop obj)  PRODUCT_RETURN;\n+  void print_on(outputStream* st) const;\n+  void print_on_for(outputStream* st, oop obj);\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1469,0 +1469,4 @@\n+  develop(size_t, CompressedClassSpaceBaseAddress, 0,                       \\\n+          \"Force the class space to be allocated at this address or \"       \\\n+          \"fails VM initialization (requires -Xshare=off.\")                 \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -330,1 +330,3 @@\n-  Atomic::dec(&_pending_threads, memory_order_release);\n+  Atomic::dec(&_pending_threads);\n+  \/\/ Trailing fence, used to make sure removal of the operation strictly\n+  \/\/ happened after we completed the operation.\n@@ -422,8 +424,0 @@\n-  class MatchOp {\n-    HandshakeOperation* _op;\n-   public:\n-    MatchOp(HandshakeOperation* op) : _op(op) {}\n-    bool operator()(HandshakeOperation* op) {\n-      return op == _op;\n-    }\n-  };\n@@ -434,1 +428,1 @@\n-HandshakeOperation* HandshakeState::pop_for_self() {\n+HandshakeOperation* HandshakeState::get_op_for_self() {\n@@ -437,1 +431,1 @@\n-  return _queue.pop();\n+  return _queue.peek();\n@@ -450,1 +444,1 @@\n-HandshakeOperation* HandshakeState::pop() {\n+HandshakeOperation* HandshakeState::get_op() {\n@@ -453,1 +447,8 @@\n-  return _queue.pop(non_self_queue_filter);\n+  return _queue.peek(non_self_queue_filter);\n+};\n+\n+void HandshakeState::remove_op(HandshakeOperation* op) {\n+  assert(_lock.owned_by_self(), \"Lock must be held\");\n+  MatchOp mo(op);\n+  HandshakeOperation* ret = _queue.pop(mo);\n+  assert(ret == op, \"Popped op must match requested op\");\n@@ -472,1 +473,1 @@\n-  while (should_process()) {\n+  while (has_operation()) {\n@@ -474,1 +475,1 @@\n-    HandshakeOperation* op = pop_for_self();\n+    HandshakeOperation* op = get_op_for_self();\n@@ -484,1 +485,2 @@\n-        op->do_handshake(_handshakee);\n+        op->do_handshake(_handshakee); \/\/ acquire, op removed after\n+        remove_op(op);\n@@ -489,1 +491,2 @@\n-        op->do_handshake(_handshakee);\n+        op->do_handshake(_handshakee); \/\/ acquire, op removed after\n+        remove_op(op);\n@@ -534,0 +537,1 @@\n+    OrderAccess::loadload(); \/\/ Matches the implicit storestore in add_operation()\n@@ -568,2 +572,1 @@\n-  HandshakeState::ProcessResult pr_ret = HandshakeState::_processed;\n-  int executed = 0;\n+  HandshakeOperation* op = get_op();\n@@ -571,12 +574,3 @@\n-  do {\n-    HandshakeOperation* op = pop();\n-    if (op != NULL) {\n-      assert(SafepointMechanism::local_poll_armed(_handshakee), \"Must be\");\n-      assert(op->_target == NULL || _handshakee == op->_target, \"Wrong thread\");\n-      log_trace(handshake)(\"Processing handshake \" INTPTR_FORMAT \" by %s(%s)\", p2i(op),\n-                           op == match_op ? \"handshaker\" : \"cooperative\",\n-                           current_thread->is_VM_thread() ? \"VM Thread\" : \"JavaThread\");\n-\n-      if (op == match_op) {\n-        pr_ret = HandshakeState::_succeeded;\n-      }\n+  assert(op != NULL, \"Must have an op\");\n+  assert(SafepointMechanism::local_poll_armed(_handshakee), \"Must be\");\n+  assert(op->_target == NULL || _handshakee == op->_target, \"Wrong thread\");\n@@ -584,1 +578,3 @@\n-      op->prepare(_handshakee, current_thread);\n+  log_trace(handshake)(\"Processing handshake \" INTPTR_FORMAT \" by %s(%s)\", p2i(op),\n+                       op == match_op ? \"handshaker\" : \"cooperative\",\n+                       current_thread->is_VM_thread() ? \"VM Thread\" : \"JavaThread\");\n@@ -586,3 +582,1 @@\n-      _active_handshaker = current_thread;\n-      op->do_handshake(_handshakee);\n-      _active_handshaker = NULL;\n+  op->prepare(_handshakee, current_thread);\n@@ -590,3 +584,4 @@\n-      executed++;\n-    }\n-  } while (have_non_self_executable_operation());\n+  set_active_handshaker(current_thread);\n+  op->do_handshake(_handshakee); \/\/ acquire, op removed after\n+  set_active_handshaker(NULL);\n+  remove_op(op);\n@@ -596,1 +591,1 @@\n-  log_trace(handshake)(\"%s(\" INTPTR_FORMAT \") executed %d ops for JavaThread: \" INTPTR_FORMAT \" %s target op: \" INTPTR_FORMAT,\n+  log_trace(handshake)(\"%s(\" INTPTR_FORMAT \") executed an op for JavaThread: \" INTPTR_FORMAT \" %s target op: \" INTPTR_FORMAT,\n@@ -598,3 +593,4 @@\n-                       p2i(current_thread), executed, p2i(_handshakee),\n-                       pr_ret == HandshakeState::_succeeded ? \"including\" : \"excluding\", p2i(match_op));\n-  return pr_ret;\n+                       p2i(current_thread), p2i(_handshakee),\n+                       op == match_op ? \"including\" : \"excluding\", p2i(match_op));\n+\n+  return op == match_op ? HandshakeState::_succeeded : HandshakeState::_processed;\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":38,"deletions":42,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/orderAccess.hpp\"\n@@ -88,1 +89,1 @@\n-  Thread* _active_handshaker;\n+  Thread* volatile _active_handshaker;\n@@ -102,2 +103,14 @@\n-  HandshakeOperation* pop_for_self();\n-  HandshakeOperation* pop();\n+  HandshakeOperation* get_op_for_self();\n+  HandshakeOperation* get_op();\n+  void remove_op(HandshakeOperation* op);\n+\n+  void set_active_handshaker(Thread* thread) { Atomic::store(&_active_handshaker, thread); }\n+\n+  class MatchOp {\n+    HandshakeOperation* _op;\n+   public:\n+    MatchOp(HandshakeOperation* op) : _op(op) {}\n+    bool operator()(HandshakeOperation* op) {\n+      return op == _op;\n+    }\n+  };\n@@ -116,22 +129,0 @@\n-  \/\/ Both _queue and _lock must be checked. If a thread has seen this _handshakee\n-  \/\/ as safe it will execute all possible handshake operations in a loop while\n-  \/\/ holding _lock. We use lock free addition to the queue, which means it is\n-  \/\/ possible for the queue to be seen as empty by _handshakee but as non-empty\n-  \/\/ by the thread executing in the loop. To avoid the _handshakee continuing\n-  \/\/ while handshake operations are being executed, the _handshakee\n-  \/\/ must take slow path, process_by_self(), if _lock is held.\n-  bool should_process() {\n-    \/\/ The holder of the _lock can add an asynchronous handshake to queue.\n-    \/\/ To make sure it is seen by the handshakee, the handshakee must first\n-    \/\/ check the _lock, and if held go to slow path.\n-    \/\/ Since the handshakee is unsafe if _lock gets locked after this check\n-    \/\/ we know other threads cannot process any handshakes.\n-    \/\/ Now we can check the queue to see if there is anything we should processs.\n-    if (_lock.is_locked()) {\n-      return true;\n-    }\n-    \/\/ Lock check must be done before queue check, force ordering.\n-    OrderAccess::loadload();\n-    return !_queue.is_empty();\n-  }\n-\n@@ -150,1 +141,1 @@\n-  Thread* active_handshaker() const { return _active_handshaker; }\n+  Thread* active_handshaker() const { return Atomic::load(&_active_handshaker); }\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":17,"deletions":26,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -106,0 +106,9 @@\n+  static WorkerThread* current() {\n+    return WorkerThread::cast(Thread::current());\n+  }\n+\n+  static WorkerThread* cast(Thread* t) {\n+    assert(t->is_Worker_thread(), \"incorrect cast to WorkerThread\");\n+    return static_cast<WorkerThread*>(t);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-    need_rechecking = thread->handshake_state()->should_process() && thread->handshake_state()->process_by_self();\n+    need_rechecking = thread->handshake_state()->has_operation() && thread->handshake_state()->process_by_self();\n@@ -116,0 +116,1 @@\n+  assert(thread == Thread::current(), \"Must be\");\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -359,1 +359,0 @@\n-  inline const WorkerThread* as_Worker_thread() const;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,5 +69,0 @@\n-inline const WorkerThread* Thread::as_Worker_thread() const {\n-  assert(is_Worker_thread(), \"incorrect cast to const WorkerThread\");\n-  return static_cast<const WorkerThread*>(this);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-  \/\/ Same as pop(MATCH_FUNC& match_func) but matches everything, thus returning\n+  \/\/ Same as peek(MATCH_FUNC& match_func) but matches everything, thus returning\n@@ -72,2 +72,2 @@\n-  E pop() {\n-    return pop(match_all);\n+  E peek() {\n+    return peek(match_all);\n@@ -84,0 +84,3 @@\n+\n+  template <typename MATCH_FUNC>\n+  E peek(MATCH_FUNC& match_func);\n","filename":"src\/hotspot\/share\/utilities\/filterQueue.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,0 +115,25 @@\n+\/\/ MT-Unsafe, external serialization needed.\n+template <class E>\n+template <typename MATCH_FUNC>\n+E FilterQueue<E>::peek(MATCH_FUNC& match_func) {\n+  Node*  first       = load_first();\n+  Node*  cur         = first;\n+  Node*  match       = NULL;\n+\n+  if (cur == NULL) {\n+    return (E)NULL;\n+  }\n+  do {\n+    if (match_func(cur->_data)) {\n+      match = cur;\n+    }\n+    cur = cur->_next;\n+  } while (cur != NULL);\n+\n+  if (match == NULL) {\n+    return (E)NULL;\n+  }\n+\n+  return (E)match->_data;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/filterQueue.inline.hpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -141,15 +141,0 @@\n-    public static final class AES128_GCM_NoPadding extends OidImpl {\n-        public AES128_GCM_NoPadding() {\n-            super(16, \"GCM\", \"NOPADDING\");\n-        }\n-    }\n-    public static final class AES192_GCM_NoPadding extends OidImpl {\n-        public AES192_GCM_NoPadding() {\n-            super(24, \"GCM\", \"NOPADDING\");\n-        }\n-    }\n-    public static final class AES256_GCM_NoPadding extends OidImpl {\n-        public AES256_GCM_NoPadding() {\n-            super(32, \"GCM\", \"NOPADDING\");\n-        }\n-    }\n@@ -188,4 +173,0 @@\n-    \/*\n-     * needed to enforce ISE thrown when updateAAD is called after update for GCM mode.\n-     *\/\n-    private boolean updateCalled;\n@@ -325,1 +306,0 @@\n-        updateCalled = false;\n@@ -358,1 +338,0 @@\n-        updateCalled = false;\n@@ -367,1 +346,0 @@\n-        updateCalled = false;\n@@ -392,1 +370,0 @@\n-        updateCalled = true;\n@@ -422,1 +399,0 @@\n-        updateCalled = true;\n@@ -461,1 +437,0 @@\n-        updateCalled = false;\n@@ -507,1 +482,0 @@\n-        updateCalled = false;\n@@ -580,80 +554,0 @@\n-    \/**\n-     * Continues a multi-part update of the Additional Authentication\n-     * Data (AAD), using a subset of the provided buffer.\n-     * <p>\n-     * Calls to this method provide AAD to the cipher when operating in\n-     * modes such as AEAD (GCM\/CCM).  If this cipher is operating in\n-     * either GCM or CCM mode, all AAD must be supplied before beginning\n-     * operations on the ciphertext (via the {@code update} and {@code\n-     * doFinal} methods).\n-     *\n-     * @param src the buffer containing the AAD\n-     * @param offset the offset in {@code src} where the AAD input starts\n-     * @param len the number of AAD bytes\n-     *\n-     * @throws IllegalStateException if this cipher is in a wrong state\n-     * (e.g., has not been initialized), does not accept AAD, or if\n-     * operating in either GCM or CCM mode and one of the {@code update}\n-     * methods has already been called for the active\n-     * encryption\/decryption operation\n-     * @throws UnsupportedOperationException if this method\n-     * has not been overridden by an implementation\n-     *\n-     * @since 1.8\n-     *\/\n-    @Override\n-    protected void engineUpdateAAD(byte[] src, int offset, int len) {\n-        if (core.getMode() == CipherCore.GCM_MODE && updateCalled) {\n-            throw new IllegalStateException(\"AAD must be supplied before encryption\/decryption starts\");\n-        }\n-        core.updateAAD(src, offset, len);\n-    }\n-\n-    \/**\n-     * Continues a multi-part update of the Additional Authentication\n-     * Data (AAD).\n-     * <p>\n-     * Calls to this method provide AAD to the cipher when operating in\n-     * modes such as AEAD (GCM\/CCM).  If this cipher is operating in\n-     * either GCM or CCM mode, all AAD must be supplied before beginning\n-     * operations on the ciphertext (via the {@code update} and {@code\n-     * doFinal} methods).\n-     * <p>\n-     * All {@code src.remaining()} bytes starting at\n-     * {@code src.position()} are processed.\n-     * Upon return, the input buffer's position will be equal\n-     * to its limit; its limit will not have changed.\n-     *\n-     * @param src the buffer containing the AAD\n-     *\n-     * @throws IllegalStateException if this cipher is in a wrong state\n-     * (e.g., has not been initialized), does not accept AAD, or if\n-     * operating in either GCM or CCM mode and one of the {@code update}\n-     * methods has already been called for the active\n-     * encryption\/decryption operation\n-     * @throws UnsupportedOperationException if this method\n-     * has not been overridden by an implementation\n-     *\n-     * @since 1.8\n-     *\/\n-    @Override\n-    protected void engineUpdateAAD(ByteBuffer src) {\n-        if (core.getMode() == CipherCore.GCM_MODE && updateCalled) {\n-            throw new IllegalStateException(\"AAD must be supplied before encryption\/decryption starts\");\n-        }\n-        if (src != null) {\n-            int aadLen = src.limit() - src.position();\n-            if (aadLen > 0) {\n-                if (src.hasArray()) {\n-                    int aadOfs = Math.addExact(src.arrayOffset(), src.position());\n-                    core.updateAAD(src.array(), aadOfs, aadLen);\n-                    src.position(src.limit());\n-                } else {\n-                    byte[] aad = new byte[aadLen];\n-                    src.get(aad);\n-                    core.updateAAD(aad, 0, aadLen);\n-                }\n-            }\n-        }\n-    }\n-\n@@ -675,5 +569,1 @@\n-        if (core.getMode() == CipherCore.GCM_MODE && !input.hasArray()) {\n-            return core.gcmDoFinal(input, output);\n-        } else {\n-            return super.engineDoFinal(input, output);\n-        }\n+        return super.engineDoFinal(input, output);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESCipher.java","additions":1,"deletions":111,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.nio.ByteBuffer;\n@@ -86,1 +85,0 @@\n-     * 2) GCM mode + decryption - due to its trailing tag bytes\n@@ -128,18 +126,0 @@\n-    static final int GCM_MODE = 7;\n-\n-    \/*\n-     * variables used for performing the GCM (key+iv) uniqueness check.\n-     * To use GCM mode safely, the cipher object must be re-initialized\n-     * with a different combination of key + iv values for each\n-     * encryption operation. However, checking all past key + iv values\n-     * isn't feasible. Thus, we only do a per-instance check of the\n-     * key + iv values used in previous encryption.\n-     * For decryption operations, no checking is necessary.\n-     * NOTE: this key+iv check have to be done inside CipherCore class\n-     * since CipherCore class buffers potential tag bytes in GCM mode\n-     * and may not call GaloisCounterMode when there isn't sufficient\n-     * input to process.\n-     *\/\n-    private boolean requireReinit = false;\n-    private byte[] lastEncKey = null;\n-    private byte[] lastEncIv = null;\n@@ -200,9 +180,0 @@\n-        }  else if (modeUpperCase.equals(\"GCM\")) {\n-            \/\/ can only be used for block ciphers w\/ 128-bit block size\n-            if (blockSize != 16) {\n-                throw new NoSuchAlgorithmException\n-                    (\"GCM mode can only be used for AES cipher\");\n-            }\n-            cipherMode = GCM_MODE;\n-            cipher = new GaloisCounterMode(rawImpl);\n-            padding = null;\n@@ -227,9 +198,0 @@\n-    \/**\n-     * Returns the mode of this cipher.\n-     *\n-     * @return the parsed cipher mode\n-     *\/\n-    int getMode() {\n-        return cipherMode;\n-    }\n-\n@@ -282,2 +244,1 @@\n-            ((cipherMode == CTR_MODE) || (cipherMode == CTS_MODE)\n-             || (cipherMode == GCM_MODE))) {\n+            ((cipherMode == CTR_MODE) || (cipherMode == CTS_MODE))) {\n@@ -290,3 +251,0 @@\n-            case GCM_MODE:\n-                modeStr = \"GCM\";\n-                break;\n@@ -313,1 +271,1 @@\n-     * previous <code>update<\/code> call, padding, and AEAD tagging.\n+     * previous <code>update<\/code> call, and padding.\n@@ -329,1 +287,1 @@\n-        int totalLen = Math.addExact(buffered, cipher.getBufferedLength());\n+        int totalLen = buffered;\n@@ -331,23 +289,4 @@\n-        switch (cipherMode) {\n-        case GCM_MODE:\n-            if (isDoFinal) {\n-                int tagLen = ((GaloisCounterMode) cipher).getTagLen();\n-                if (!decrypting) {\n-                    totalLen = Math.addExact(totalLen, tagLen);\n-                } else {\n-                    totalLen -= tagLen;\n-                }\n-            }\n-            if (totalLen < 0) {\n-                totalLen = 0;\n-            }\n-            break;\n-        default:\n-            if (padding != null && !decrypting) {\n-                if (unitBytes != blockSize) {\n-                    if (totalLen < diffBlocksize) {\n-                        totalLen = diffBlocksize;\n-                    } else {\n-                        int residue = (totalLen - diffBlocksize) % blockSize;\n-                        totalLen = Math.addExact(totalLen, (blockSize - residue));\n-                    }\n+        if (padding != null && !decrypting) {\n+            if (unitBytes != blockSize) {\n+                if (totalLen < diffBlocksize) {\n+                    totalLen = diffBlocksize;\n@@ -355,1 +294,2 @@\n-                    totalLen = Math.addExact(totalLen, padding.padLength(totalLen));\n+                    int residue = (totalLen - diffBlocksize) % blockSize;\n+                    totalLen = Math.addExact(totalLen, (blockSize - residue));\n@@ -357,0 +297,2 @@\n+            } else {\n+                totalLen = Math.addExact(totalLen, padding.padLength(totalLen));\n@@ -358,1 +300,0 @@\n-            break;\n@@ -401,6 +342,1 @@\n-            \/\/ generate spec using default value\n-            if (cipherMode == GCM_MODE) {\n-                iv = new byte[GaloisCounterMode.DEFAULT_IV_LEN];\n-            } else {\n-                iv = new byte[blockSize];\n-            }\n+            iv = new byte[blockSize];\n@@ -409,4 +345,4 @@\n-        if (cipherMode == GCM_MODE) {\n-            algName = \"GCM\";\n-            spec = new GCMParameterSpec\n-                (((GaloisCounterMode) cipher).getTagLen()*8, iv);\n+        if (algName.equals(\"RC2\")) {\n+            RC2Crypt rawImpl = (RC2Crypt) cipher.getEmbeddedCipher();\n+            spec = new RC2ParameterSpec\n+                (rawImpl.getEffectiveKeyBits(), iv);\n@@ -414,7 +350,1 @@\n-           if (algName.equals(\"RC2\")) {\n-               RC2Crypt rawImpl = (RC2Crypt) cipher.getEmbeddedCipher();\n-               spec = new RC2ParameterSpec\n-                   (rawImpl.getEffectiveKeyBits(), iv);\n-           } else {\n-               spec = new IvParameterSpec(iv);\n-           }\n+            spec = new IvParameterSpec(iv);\n@@ -507,41 +437,5 @@\n-        try {\n-            int tagLen = -1;\n-            byte[] ivBytes = null;\n-            if (params != null) {\n-                if (cipherMode == GCM_MODE) {\n-                    if (params instanceof GCMParameterSpec) {\n-                        tagLen = ((GCMParameterSpec) params).getTLen();\n-                        if (tagLen < 96 || tagLen > 128 || ((tagLen & 0x07) != 0)) {\n-                            throw new InvalidAlgorithmParameterException\n-                                    (\"Unsupported TLen value; must be one of \" +\n-                                            \"{128, 120, 112, 104, 96}\");\n-                        }\n-                        tagLen = tagLen >> 3;\n-                        ivBytes = ((GCMParameterSpec) params).getIV();\n-                    } else {\n-                        throw new InvalidAlgorithmParameterException\n-                                (\"Unsupported parameter: \" + params);\n-                    }\n-                } else {\n-                    if (params instanceof IvParameterSpec) {\n-                        ivBytes = ((IvParameterSpec) params).getIV();\n-                        if ((ivBytes == null) || (ivBytes.length != blockSize)) {\n-                            throw new InvalidAlgorithmParameterException\n-                                    (\"Wrong IV length: must be \" + blockSize +\n-                                            \" bytes long\");\n-                        }\n-                    } else if (params instanceof RC2ParameterSpec) {\n-                        ivBytes = ((RC2ParameterSpec) params).getIV();\n-                        if ((ivBytes != null) && (ivBytes.length != blockSize)) {\n-                            throw new InvalidAlgorithmParameterException\n-                                    (\"Wrong IV length: must be \" + blockSize +\n-                                            \" bytes long\");\n-                        }\n-                    } else {\n-                        throw new InvalidAlgorithmParameterException\n-                                (\"Unsupported parameter: \" + params);\n-                    }\n-                }\n-            }\n-            if (cipherMode == ECB_MODE) {\n-                if (ivBytes != null) {\n+        byte[] ivBytes = null;\n+        if (params != null) {\n+            if (params instanceof IvParameterSpec) {\n+                ivBytes = ((IvParameterSpec) params).getIV();\n+                if ((ivBytes == null) || (ivBytes.length != blockSize)) {\n@@ -549,1 +443,2 @@\n-                            (\"ECB mode cannot use IV\");\n+                        (\"Wrong IV length: must be \" + blockSize +\n+                            \" bytes long\");\n@@ -551,4 +446,6 @@\n-            } else if (ivBytes == null) {\n-                if (decrypting) {\n-                    throw new InvalidAlgorithmParameterException(\"Parameters \"\n-                            + \"missing\");\n+            } else if (params instanceof RC2ParameterSpec) {\n+                ivBytes = ((RC2ParameterSpec) params).getIV();\n+                if ((ivBytes != null) && (ivBytes.length != blockSize)) {\n+                    throw new InvalidAlgorithmParameterException\n+                        (\"Wrong IV length: must be \" + blockSize +\n+                            \" bytes long\");\n@@ -556,0 +453,15 @@\n+            } else {\n+                throw new InvalidAlgorithmParameterException\n+                    (\"Unsupported parameter: \" + params);\n+            }\n+        }\n+        if (cipherMode == ECB_MODE) {\n+            if (ivBytes != null) {\n+                throw new InvalidAlgorithmParameterException\n+                    (\"ECB mode cannot use IV\");\n+            }\n+        } else if (ivBytes == null) {\n+            if (decrypting) {\n+                throw new InvalidAlgorithmParameterException(\"Parameters \"\n+                    + \"missing\");\n+            }\n@@ -557,9 +469,2 @@\n-                if (random == null) {\n-                    random = SunJCE.getRandom();\n-                }\n-                if (cipherMode == GCM_MODE) {\n-                    ivBytes = new byte[GaloisCounterMode.DEFAULT_IV_LEN];\n-                } else {\n-                    ivBytes = new byte[blockSize];\n-                }\n-                random.nextBytes(ivBytes);\n+            if (random == null) {\n+                random = SunJCE.getRandom();\n@@ -568,2 +473,3 @@\n-            buffered = 0;\n-            diffBlocksize = blockSize;\n+            ivBytes = new byte[blockSize];\n+            random.nextBytes(ivBytes);\n+        }\n@@ -571,1 +477,2 @@\n-            String algorithm = key.getAlgorithm();\n+        buffered = 0;\n+        diffBlocksize = blockSize;\n@@ -573,34 +480,2 @@\n-            \/\/ GCM mode needs additional handling\n-            if (cipherMode == GCM_MODE) {\n-                if (tagLen == -1) {\n-                    tagLen = GaloisCounterMode.DEFAULT_TAG_LEN;\n-                }\n-                if (decrypting) {\n-                    minBytes = tagLen;\n-                } else {\n-                    \/\/ check key+iv for encryption in GCM mode\n-                    requireReinit =\n-                            Arrays.equals(ivBytes, lastEncIv) &&\n-                                    MessageDigest.isEqual(keyBytes, lastEncKey);\n-                    if (requireReinit) {\n-                        throw new InvalidAlgorithmParameterException\n-                                (\"Cannot reuse iv for GCM encryption\");\n-                    }\n-                    lastEncIv = ivBytes;\n-                    if (lastEncKey != null) {\n-                        Arrays.fill(lastEncKey, (byte) 0);\n-                    }\n-                    lastEncKey = keyBytes;\n-                }\n-                ((GaloisCounterMode) cipher).init\n-                        (decrypting, algorithm, keyBytes, ivBytes, tagLen);\n-            } else {\n-                cipher.init(decrypting, algorithm, keyBytes, ivBytes);\n-            }\n-            \/\/ skip checking key+iv from now on until after doFinal()\n-            requireReinit = false;\n-        } finally {\n-            if (lastEncKey != keyBytes) {\n-                Arrays.fill(keyBytes, (byte) 0);\n-            }\n-        }\n+        String algorithm = key.getAlgorithm();\n+        cipher.init(decrypting, algorithm, keyBytes, ivBytes);\n@@ -616,10 +491,5 @@\n-                if (cipherMode == GCM_MODE) {\n-                    paramType = \"GCM\";\n-                    spec = params.getParameterSpec(GCMParameterSpec.class);\n-                } else {\n-                    \/\/ NOTE: RC2 parameters are always handled through\n-                    \/\/ init(..., AlgorithmParameterSpec,...) method, so\n-                    \/\/ we can assume IvParameterSpec type here.\n-                    paramType = \"IV\";\n-                    spec = params.getParameterSpec(IvParameterSpec.class);\n-                }\n+                \/\/ NOTE: RC2 parameters are always handled through\n+                \/\/ init(..., AlgorithmParameterSpec,...) method, so\n+                \/\/ we can assume IvParameterSpec type here.\n+                paramType = \"IV\";\n+                spec = params.getParameterSpec(IvParameterSpec.class);\n@@ -674,1 +544,0 @@\n-        checkReinit();\n@@ -722,1 +591,0 @@\n-        checkReinit();\n@@ -857,1 +725,0 @@\n-            checkReinit();\n@@ -871,1 +738,1 @@\n-                    \/\/ Zero out internal (ouput) array\n+                    \/\/ Zero out internal (output) array\n@@ -924,1 +791,0 @@\n-        checkReinit();\n@@ -946,6 +812,4 @@\n-            if (getMode() != GCM_MODE || outputCapacity < estOutSize) {\n-                \/\/ create temporary output buffer if the estimated size is larger\n-                \/\/ than the user-provided buffer.\n-                internalOutput = new byte[estOutSize];\n-                offset = 0;\n-            }\n+            \/\/ create temporary output buffer if the estimated size is larger\n+            \/\/ than the user-provided buffer.\n+            internalOutput = new byte[estOutSize];\n+            offset = 0;\n@@ -953,1 +817,0 @@\n-        byte[] outBuffer = (internalOutput != null) ? internalOutput : output;\n@@ -955,0 +818,1 @@\n+        byte[] outBuffer = (internalOutput != null) ? internalOutput : output;\n@@ -964,3 +828,2 @@\n-                                               + (outputCapacity)\n-                                               + \" bytes given, \" + outLen\n-                                               + \" bytes needed\");\n+                    + (outputCapacity) + \" bytes given, \" + outLen\n+                    + \" bytes needed\");\n@@ -970,1 +833,2 @@\n-                System.arraycopy(internalOutput, 0, output, outputOffset, outLen);\n+                System.arraycopy(internalOutput, 0, output, outputOffset,\n+                    outLen);\n@@ -1004,1 +868,1 @@\n-        int totalLen = Math.addExact(len, cipher.getBufferedLength());\n+        int totalLen = len;\n@@ -1062,4 +926,4 @@\n-                                 byte[] output, int outOfs, int finalBufLen,\n-                                 byte[] input)\n-            throws ShortBufferException, BadPaddingException,\n-            IllegalBlockSizeException {\n+        byte[] output, int outOfs, int finalBufLen, byte[] input)\n+        throws ShortBufferException, BadPaddingException,\n+        IllegalBlockSizeException {\n+\n@@ -1069,1 +933,1 @@\n-                    outOfs, finalBufLen);\n+                outOfs, finalBufLen);\n@@ -1075,7 +939,3 @@\n-            if (!decrypting) {\n-                \/\/ reset after doFinal() for GCM encryption\n-                requireReinit = (cipherMode == GCM_MODE);\n-                if (finalBuf != input) {\n-                    \/\/ done with internal finalBuf array. Copied to output\n-                    Arrays.fill(finalBuf, (byte) 0x00);\n-                }\n+            if (!decrypting && finalBuf != input) {\n+                \/\/ done with internal finalBuf array. Copied to output\n+                Arrays.fill(finalBuf, (byte) 0x00);\n@@ -1086,0 +946,1 @@\n+\n@@ -1101,7 +962,0 @@\n-    private void checkReinit() {\n-        if (requireReinit) {\n-            throw new IllegalStateException\n-                (\"Must use either different key or iv for GCM encryption\");\n-        }\n-    }\n-\n@@ -1110,2 +964,1 @@\n-        throws IllegalBlockSizeException, AEADBadTagException,\n-        ShortBufferException {\n+        throws IllegalBlockSizeException, ShortBufferException {\n@@ -1113,1 +966,1 @@\n-        if ((cipherMode != GCM_MODE) && (in == null || len == 0)) {\n+        if (in == null || len == 0) {\n@@ -1117,1 +970,0 @@\n-            (cipherMode != GCM_MODE) &&\n@@ -1129,1 +981,1 @@\n-        int outLen = 0;\n+        int outLen;\n@@ -1220,55 +1072,0 @@\n-\n-    \/**\n-     * Continues a multi-part update of the Additional Authentication\n-     * Data (AAD), using a subset of the provided buffer.\n-     * <p>\n-     * Calls to this method provide AAD to the cipher when operating in\n-     * modes such as AEAD (GCM\/CCM).  If this cipher is operating in\n-     * either GCM or CCM mode, all AAD must be supplied before beginning\n-     * operations on the ciphertext (via the {@code update} and {@code\n-     * doFinal} methods).\n-     *\n-     * @param src the buffer containing the AAD\n-     * @param offset the offset in {@code src} where the AAD input starts\n-     * @param len the number of AAD bytes\n-     *\n-     * @throws IllegalStateException if this cipher is in a wrong state\n-     * (e.g., has not been initialized), does not accept AAD, or if\n-     * operating in either GCM or CCM mode and one of the {@code update}\n-     * methods has already been called for the active\n-     * encryption\/decryption operation\n-     * @throws UnsupportedOperationException if this method\n-     * has not been overridden by an implementation\n-     *\n-     * @since 1.8\n-     *\/\n-    void updateAAD(byte[] src, int offset, int len) {\n-        checkReinit();\n-        cipher.updateAAD(src, offset, len);\n-    }\n-\n-    \/\/ This must only be used with GCM.\n-    \/\/ If some data has been buffered from an update call, operate on the buffer\n-    \/\/ then run doFinal.\n-    int gcmDoFinal(ByteBuffer src, ByteBuffer dst) throws ShortBufferException,\n-        IllegalBlockSizeException, BadPaddingException {\n-        int estOutSize = getOutputSizeByOperation(src.remaining(), true);\n-        if (estOutSize > dst.remaining()) {\n-            throw new ShortBufferException(\"output buffer too small\");\n-        }\n-\n-        int len;\n-        if (decrypting) {\n-            if (buffered > 0) {\n-                cipher.decrypt(buffer, 0, buffered, new byte[0], 0);\n-            }\n-            len = cipher.decryptFinal(src, dst);\n-        } else {\n-            if (buffered > 0) {\n-                ((GaloisCounterMode)cipher).encrypt(buffer, 0, buffered);\n-            }\n-            len = cipher.encryptFinal(src, dst);\n-        }\n-        endDoFinal();\n-        return len;\n-    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/CipherCore.java","additions":82,"deletions":285,"binary":false,"changes":367,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.nio.ByteBuffer;\n@@ -203,2 +202,1 @@\n-         throws IllegalBlockSizeException, AEADBadTagException,\n-         ShortBufferException {\n+         throws IllegalBlockSizeException, ShortBufferException {\n@@ -207,62 +205,0 @@\n-\n-    \/**\n-     * Continues a multi-part update of the Additional Authentication\n-     * Data (AAD), using a subset of the provided buffer. If this\n-     * cipher is operating in either GCM or CCM mode, all AAD must be\n-     * supplied before beginning operations on the ciphertext (via the\n-     * {@code update} and {@code doFinal} methods).\n-     * <p>\n-     * NOTE: Given most modes do not accept AAD, default impl for this\n-     * method throws IllegalStateException.\n-     *\n-     * @param src the buffer containing the AAD\n-     * @param offset the offset in {@code src} where the AAD input starts\n-     * @param len the number of AAD bytes\n-     *\n-     * @throws IllegalStateException if this cipher is in a wrong state\n-     * (e.g., has not been initialized), does not accept AAD, or if\n-     * operating in either GCM or CCM mode and one of the {@code update}\n-     * methods has already been called for the active\n-     * encryption\/decryption operation\n-     * @throws UnsupportedOperationException if this method\n-     * has not been overridden by an implementation\n-     *\n-     * @since 1.8\n-     *\/\n-    void updateAAD(byte[] src, int offset, int len) {\n-        throw new IllegalStateException(\"No AAD accepted\");\n-    }\n-\n-    \/**\n-     * @return the number of bytes that are buffered internally inside\n-     * this FeedbackCipher instance.\n-     * @since 1.8\n-     *\/\n-    int getBufferedLength() {\n-        \/\/ Currently only AEAD cipher impl, e.g. GCM, buffers data\n-        \/\/ internally during decryption mode\n-        return 0;\n-    }\n-\n-    \/*\n-     * ByteBuffer methods should not be accessed as CipherCore and AESCipher\n-     * copy the data to byte arrays.  These methods are to satisfy the compiler.\n-     *\/\n-    int encrypt(ByteBuffer src, ByteBuffer dst) {\n-        throw new UnsupportedOperationException(\"ByteBuffer not supported\");\n-    };\n-\n-    int decrypt(ByteBuffer src, ByteBuffer dst) {\n-        throw new UnsupportedOperationException(\"ByteBuffer not supported\");\n-    };\n-\n-    int encryptFinal(ByteBuffer src, ByteBuffer dst)\n-        throws IllegalBlockSizeException, ShortBufferException {\n-        throw new UnsupportedOperationException(\"ByteBuffer not supported\");\n-    };\n-\n-    int decryptFinal(ByteBuffer src, ByteBuffer dst)\n-        throws IllegalBlockSizeException, AEADBadTagException,\n-        ShortBufferException {\n-        throw new UnsupportedOperationException(\"ByteBuffer not supported\");\n-    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/FeedbackCipher.java","additions":2,"deletions":66,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import java.nio.ByteBuffer;\n+\n+\/**\n+ * This interface allows GHASH.java and GCTR.java to easily operate to\n+ * better operate with GaloisCounterMode.java\n+ *\/\n+\n+public interface GCM {\n+    int update(byte[] in, int inOfs, int inLen, byte[] out, int outOfs);\n+    int update(byte[] in, int inOfs, int inLen, ByteBuffer dst);\n+    int update(ByteBuffer src, ByteBuffer dst);\n+    int doFinal(byte[] in, int inOfs, int inLen, byte[] out, int outOfs);\n+    int doFinal(ByteBuffer src, ByteBuffer dst);\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GCM.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -34,2 +34,1 @@\n-import javax.crypto.IllegalBlockSizeException;\n-import static com.sun.crypto.provider.AESConstants.AES_BLOCK_SIZE;\n+import java.util.Arrays;\n@@ -55,1 +54,1 @@\n-final class GCTR extends CounterMode {\n+final class GCTR extends CounterMode implements GCM {\n@@ -59,0 +58,1 @@\n+    private byte[] block;\n@@ -62,1 +62,1 @@\n-        if (initialCounterBlk.length != AES_BLOCK_SIZE) {\n+        if (initialCounterBlk.length != blockSize) {\n@@ -64,2 +64,2 @@\n-                initialCounterBlk.length + \") not equal to AES_BLOCK_SIZE (\" +\n-                AES_BLOCK_SIZE + \")\");\n+                initialCounterBlk.length + \") not equal to blockSize (\" +\n+                blockSize + \")\");\n@@ -86,2 +86,18 @@\n-    \/\/ input must be multiples of 128-bit blocks when calling update\n-    int update(byte[] in, int inOfs, int inLen, byte[] out, int outOfs) {\n+    private void checkBlock() {\n+        if (block == null) {\n+            block = new byte[blockSize];\n+        } else {\n+            Arrays.fill(block, (byte)0);\n+        }\n+    }\n+\n+    \/**\n+     * Using the given inLen, this operates only on blockSize data, leaving\n+     * the remainder in 'in'.\n+     * The return value will be (inLen - (inLen % blockSize))\n+     *\/\n+    public int update(byte[] in, int inOfs, int inLen, byte[] out, int outOfs) {\n+        if (inLen == 0) {\n+            return 0;\n+        }\n+\n@@ -91,1 +107,1 @@\n-        if (inLen < 0 || inLen % AES_BLOCK_SIZE != 0) {\n+        if (inLen < 0) {\n@@ -94,1 +110,1 @@\n-        if (out.length - outOfs < inLen) {\n+        if (out.length - outOfs < (inLen - (inLen % blockSize))) {\n@@ -98,0 +114,1 @@\n+        inLen -= inLen % blockSize;\n@@ -99,1 +116,1 @@\n-        int numOfCompleteBlocks = inLen \/ AES_BLOCK_SIZE;\n+        int numOfCompleteBlocks = inLen \/ blockSize;\n@@ -103,1 +120,1 @@\n-            byte[] encryptedCntr = new byte[AES_BLOCK_SIZE];\n+            checkBlock();\n@@ -105,3 +122,3 @@\n-                embeddedCipher.encryptBlock(counter, 0, encryptedCntr, 0);\n-                for (int n = 0; n < AES_BLOCK_SIZE; n++) {\n-                    int index = (i * AES_BLOCK_SIZE + n);\n+                embeddedCipher.encryptBlock(counter, 0, block, 0);\n+                for (int n = 0; n < blockSize; n++) {\n+                    int index = (i * blockSize + n);\n@@ -109,1 +126,1 @@\n-                        (byte) ((in[inOfs + index] ^ encryptedCntr[n]));\n+                        (byte) ((in[inOfs + index] ^ block[n]));\n@@ -119,2 +136,14 @@\n-    \/\/ input must be multiples of AES blocks, 128-bit, when calling update\n-    int update(byte[] in, int inOfs, int inLen, ByteBuffer dst) {\n+    \/**\n+     * Operate on only blocksize data leaving the remainder in 'in' .\n+     *\/\n+    public int update(byte[] in, int inOfs, int inLen, ByteBuffer dst) {\n+        \/\/ If the bytebuffer is backed by arrays, use that instead of\n+        \/\/ allocating and copying for direct bytebuffers\n+        if (!dst.isDirect()) {\n+            int len = update(in, inOfs, inLen,  dst.array(),\n+                dst.arrayOffset() + dst.position());\n+            dst.position(dst.position() + len);\n+            return len;\n+        }\n+\n+        \/\/ Direct ByteBuffer operation\n@@ -124,1 +153,1 @@\n-        if (inLen < 0 || inLen % AES_BLOCK_SIZE != 0) {\n+        if (inLen < 0) {\n@@ -131,1 +160,1 @@\n-        int numOfCompleteBlocks = inLen \/ AES_BLOCK_SIZE;\n+        int numOfCompleteBlocks = inLen \/ blockSize;\n@@ -135,1 +164,1 @@\n-            byte[] encryptedCntr = new byte[AES_BLOCK_SIZE];\n+            checkBlock();\n@@ -137,4 +166,4 @@\n-                embeddedCipher.encryptBlock(counter, 0, encryptedCntr, 0);\n-                for (int n = 0; n < AES_BLOCK_SIZE; n++) {\n-                    int index = (i * AES_BLOCK_SIZE + n);\n-                    dst.put((byte) ((in[inOfs + index] ^ encryptedCntr[n])));\n+                embeddedCipher.encryptBlock(counter, 0, block, 0);\n+                for (int n = 0; n < blockSize; n++) {\n+                    int index = (i * blockSize + n);\n+                    dst.put((byte) ((in[inOfs + index] ^ block[n])));\n@@ -146,1 +175,1 @@\n-            int len = inLen - inLen % AES_BLOCK_SIZE;\n+            int len = inLen - inLen % blockSize;\n@@ -165,3 +194,18 @@\n-    \/\/ input operates on multiples of AES blocks, 128-bit, when calling update.\n-    \/\/ The remainder is left in the src buffer.\n-    int update(ByteBuffer src, ByteBuffer dst) {\n+    \/**\n+     * Operate on only blocksize data leaving the remainder in the src buffer.\n+     *\/\n+    public int update(ByteBuffer src, ByteBuffer dst) {\n+        int len;\n+\n+        \/\/ If the bytebuffer is backed by arrays, use that instead of\n+        \/\/ allocating and copying for direct bytebuffers\n+        if (src.hasArray() && dst.hasArray()) {\n+            len = update(src.array(), src.arrayOffset() + src.position(),\n+                src.remaining() - (src.remaining() % blockSize),\n+                dst.array(), dst.arrayOffset() + dst.position());\n+            src.position(src.position() + len);\n+            dst.position(dst.position() + len);\n+            return len;\n+        }\n+\n+        \/\/ Direct bytebuffer operation\n@@ -169,1 +213,1 @@\n-        int numOfCompleteBlocks = src.remaining() \/ AES_BLOCK_SIZE;\n+        int numOfCompleteBlocks = src.remaining() \/ blockSize;\n@@ -173,1 +217,1 @@\n-            byte[] encryptedCntr = new byte[AES_BLOCK_SIZE];\n+            checkBlock();\n@@ -175,3 +219,3 @@\n-                embeddedCipher.encryptBlock(counter, 0, encryptedCntr, 0);\n-                for (int n = 0; n < AES_BLOCK_SIZE; n++) {\n-                    dst.put((byte) (src.get() ^ encryptedCntr[n]));\n+                embeddedCipher.encryptBlock(counter, 0, block, 0);\n+                for (int n = 0; n < blockSize; n++) {\n+                    dst.put((byte) (src.get() ^ block[n]));\n@@ -181,1 +225,1 @@\n-            return numOfCompleteBlocks * AES_BLOCK_SIZE;\n+            return numOfCompleteBlocks * blockSize;\n@@ -184,1 +228,1 @@\n-        int len = src.remaining() - (src.remaining() % AES_BLOCK_SIZE);\n+        len = src.remaining() - (src.remaining() % blockSize);\n@@ -199,21 +243,22 @@\n-    \/\/ input can be arbitrary size when calling doFinal\n-    int doFinal(byte[] in, int inOfs, int inLen, byte[] out,\n-        int outOfs) throws IllegalBlockSizeException {\n-        try {\n-            if (inLen < 0) {\n-                throw new IllegalBlockSizeException(\"Negative input size!\");\n-            } else if (inLen > 0) {\n-                int lastBlockSize = inLen % AES_BLOCK_SIZE;\n-                int completeBlkLen = inLen - lastBlockSize;\n-                \/\/ process the complete blocks first\n-                update(in, inOfs, completeBlkLen, out, outOfs);\n-                if (lastBlockSize != 0) {\n-                    \/\/ do the last partial block\n-                    byte[] encryptedCntr = new byte[AES_BLOCK_SIZE];\n-                    embeddedCipher.encryptBlock(counter, 0, encryptedCntr, 0);\n-                    for (int n = 0; n < lastBlockSize; n++) {\n-                        out[outOfs + completeBlkLen + n] =\n-                            (byte) ((in[inOfs + completeBlkLen + n] ^\n-                                encryptedCntr[n]));\n-                    }\n-                }\n+    \/**\n+     * doFinal operation by using update() for any full block operations needed,\n+     * then operating on the final bytes in the input buffer.\n+     *\n+     * This method will not write any block padding to the output buffer\n+     *\/\n+    public int doFinal(byte[] in, int inOfs, int inLen, byte[] out,\n+        int outOfs) {\n+        if (inLen == 0) {\n+            return 0;\n+        }\n+        int lastBlockSize = inLen % blockSize;\n+        int completeBlkLen = inLen - lastBlockSize;\n+        \/\/ process the complete blocks first\n+        update(in, inOfs, completeBlkLen, out, outOfs);\n+        if (lastBlockSize != 0) {\n+            \/\/ do the last partial block\n+            checkBlock();\n+            embeddedCipher.encryptBlock(counter, 0, block, 0);\n+            for (int n = 0; n < lastBlockSize; n++) {\n+                out[outOfs + completeBlkLen + n] =\n+                    (byte) ((in[inOfs + completeBlkLen + n] ^ block[n]));\n@@ -221,2 +266,0 @@\n-        } finally {\n-            reset();\n@@ -227,2 +270,19 @@\n-    \/\/ src can be arbitrary size when calling doFinal\n-    int doFinal(ByteBuffer src, ByteBuffer dst) {\n+    \/**\n+     * doFinal operation by using update() for any full block operations needed,\n+     * then operating on the final bytes in the input buffer.\n+     *\n+     * If src and dst are array-backed bytebuffers, call doFinal(byte[]...) for\n+     * less memory usage.\n+     *\/\n+    public int doFinal(ByteBuffer src, ByteBuffer dst) {\n+        \/\/ If the bytebuffer is backed by arrays, use that instead of\n+        \/\/ allocating and copying for direct bytebuffers\n+        if (src.hasArray() && dst.hasArray()) {\n+            int len = doFinal(src.array(), src.arrayOffset() + src.position(),\n+                src.remaining(), dst.array(),\n+                dst.arrayOffset() + dst.position());\n+            src.position(src.position() + len);\n+            dst.position(dst.position() + len);\n+            return len;\n+        }\n+\n@@ -230,10 +290,8 @@\n-        int lastBlockSize = len % AES_BLOCK_SIZE;\n-        try {\n-            update(src, dst);\n-            if (lastBlockSize != 0) {\n-                \/\/ do the last partial block\n-                byte[] encryptedCntr = new byte[AES_BLOCK_SIZE];\n-                embeddedCipher.encryptBlock(counter, 0, encryptedCntr, 0);\n-                for (int n = 0; n < lastBlockSize; n++) {\n-                    dst.put((byte) (src.get() ^ encryptedCntr[n]));\n-                }\n+        int lastBlockSize = len % blockSize;\n+        update(src, dst);\n+        if (lastBlockSize != 0) {\n+            checkBlock();\n+            \/\/ do the last partial block\n+            embeddedCipher.encryptBlock(counter, 0, block, 0);\n+            for (int n = 0; n < lastBlockSize; n++) {\n+                dst.put((byte) (src.get() ^ block[n]));\n@@ -241,2 +299,0 @@\n-        } finally {\n-            reset();\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GCTR.java","additions":129,"deletions":73,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -2,2 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2015 Red Hat, Inc.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +27,1 @@\n+ * Copyright (c) 2015 Red Hat, Inc.\n@@ -32,0 +32,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n@@ -33,0 +35,1 @@\n+import java.nio.ByteOrder;\n@@ -47,1 +50,0 @@\n-final class GHASH {\n@@ -49,16 +51,1 @@\n-    private static long getLong(byte[] buffer, int offset) {\n-        long result = 0;\n-        int end = offset + 8;\n-        for (int i = offset; i < end; ++i) {\n-            result = (result << 8) + (buffer[i] & 0xFF);\n-        }\n-        return result;\n-    }\n-\n-    private static void putLong(byte[] buffer, int offset, long value) {\n-        int end = offset + 8;\n-        for (int i = end - 1; i >= offset; --i) {\n-            buffer[i] = (byte) value;\n-            value >>= 8;\n-        }\n-    }\n+final class GHASH implements Cloneable, GCM {\n@@ -68,0 +55,8 @@\n+    \/\/ Handle for converting byte[] <-> long\n+    private static final VarHandle asLongView =\n+        MethodHandles.byteArrayViewVarHandle(long[].class,\n+            ByteOrder.BIG_ENDIAN);\n+\n+    \/\/ Maximum buffer size rotating ByteBuffer->byte[] intrinsic copy\n+    private static final int MAX_LEN = 1024;\n+\n@@ -130,1 +125,2 @@\n-    \/\/ hashtable subkeyHtbl; holds 2*9 powers of subkeyH computed using carry-less multiplication\n+    \/\/ hashtable subkeyHtbl holds 2*9 powers of subkeyH computed using\n+    \/\/ carry-less multiplication\n@@ -136,3 +132,0 @@\n-    \/\/ variables for save\/restore calls\n-    private long stateSave0, stateSave1;\n-\n@@ -154,12 +147,2 @@\n-        subkeyHtbl[0] = getLong(subkeyH, 0);\n-        subkeyHtbl[1] = getLong(subkeyH, 8);\n-    }\n-\n-    \/**\n-     * Resets the GHASH object to its original state, i.e. blank w\/\n-     * the same subkey H. Used after digest() is called and to re-use\n-     * this object for different data w\/ the same H.\n-     *\/\n-    void reset() {\n-        state[0] = 0;\n-        state[1] = 0;\n+        subkeyHtbl[0] = (long)asLongView.get(subkeyH, 0);\n+        subkeyHtbl[1] = (long)asLongView.get(subkeyH, 8);\n@@ -168,6 +151,4 @@\n-    \/**\n-     * Save the current snapshot of this GHASH object.\n-     *\/\n-    void save() {\n-        stateSave0 = state[0];\n-        stateSave1 = state[1];\n+    \/\/ Cloning constructor\n+    private GHASH(GHASH g) {\n+        state = g.state.clone();\n+        subkeyHtbl = g.subkeyHtbl.clone();\n@@ -176,6 +157,3 @@\n-    \/**\n-     * Restores this object using the saved snapshot.\n-     *\/\n-    void restore() {\n-        state[0] = stateSave0;\n-        state[1] = stateSave1;\n+    @Override\n+    public GHASH clone() {\n+        return new GHASH(this);\n@@ -184,3 +162,4 @@\n-    private static void processBlock(byte[] data, int ofs, long[] st, long[] subH) {\n-        st[0] ^= getLong(data, ofs);\n-        st[1] ^= getLong(data, ofs + 8);\n+    private static void processBlock(byte[] data, int ofs, long[] st,\n+        long[] subH) {\n+        st[0] ^= (long)asLongView.get(data, ofs);\n+        st[1] ^= (long)asLongView.get(data, ofs + 8);\n@@ -190,2 +169,2 @@\n-    void update(byte[] in) {\n-        update(in, 0, in.length);\n+    int update(byte[] in) {\n+        return update(in, 0, in.length);\n@@ -194,1 +173,1 @@\n-    void update(byte[] in, int inOfs, int inLen) {\n+    int update(byte[] in, int inOfs, int inLen) {\n@@ -196,1 +175,1 @@\n-            return;\n+            return 0;\n@@ -198,2 +177,4 @@\n-        ghashRangeCheck(in, inOfs, inLen, state, subkeyHtbl);\n-        processBlocks(in, inOfs, inLen\/AES_BLOCK_SIZE, state, subkeyHtbl);\n+        int len = inLen - (inLen % AES_BLOCK_SIZE);\n+        ghashRangeCheck(in, inOfs, len, state, subkeyHtbl);\n+        processBlocks(in, inOfs, len \/ AES_BLOCK_SIZE, state, subkeyHtbl);\n+        return len;\n@@ -202,3 +183,0 @@\n-    \/\/ Maximum buffer size rotating ByteBuffer->byte[] intrinsic copy\n-    private static final int MAX_LEN = 1024;\n-\n@@ -206,1 +184,1 @@\n-    int update(ByteBuffer src, int inLen) {\n+    int update(ByteBuffer ct, int inLen) {\n@@ -212,1 +190,16 @@\n-        int processed = inLen;\n+        \/\/ If ct is a direct bytebuffer, send it directly to the intrinsic\n+        if (ct.isDirect()) {\n+            int processed = inLen;\n+            processBlocksDirect(ct, inLen);\n+            return processed;\n+        } else if (!ct.isReadOnly()) {\n+            \/\/ If a non-read only heap bytebuffer, use the array update method\n+            int processed = update(ct.array(),\n+                ct.arrayOffset() + ct.position(),\n+                inLen);\n+            ct.position(ct.position() + processed);\n+            return processed;\n+        }\n+\n+        \/\/ Read only heap bytebuffers have to be copied and operated on\n+        int to_process = inLen;\n@@ -214,2 +207,2 @@\n-        while (processed > MAX_LEN ) {\n-            src.get(in, 0, MAX_LEN);\n+        while (to_process > MAX_LEN ) {\n+            ct.get(in, 0, MAX_LEN);\n@@ -217,1 +210,1 @@\n-            processed -= MAX_LEN;\n+            to_process -= MAX_LEN;\n@@ -219,2 +212,2 @@\n-        src.get(in, 0, processed);\n-        update(in, 0, processed);\n+        ct.get(in, 0, to_process);\n+        update(in, 0, to_process);\n@@ -224,2 +217,7 @@\n-    void doLastBlock(ByteBuffer src, int inLen) {\n-        int processed = update(src, inLen);\n+    int doFinal(ByteBuffer src, int inLen) {\n+        int processed = 0;\n+\n+        if (inLen >= AES_BLOCK_SIZE) {\n+            processed = update(src, inLen);\n+        }\n+\n@@ -227,1 +225,1 @@\n-            return;\n+            return processed;\n@@ -232,0 +230,13 @@\n+        return inLen;\n+    }\n+\n+    int doFinal(byte[] in, int inOfs, int inLen) {\n+        int remainder = inLen % AES_BLOCK_SIZE;\n+        inOfs += update(in, inOfs, inLen - remainder);\n+        if (remainder > 0) {\n+            byte[] block = new byte[AES_BLOCK_SIZE];\n+            System.arraycopy(in, inOfs, block, 0,\n+                remainder);\n+            update(block, 0, AES_BLOCK_SIZE);\n+        }\n+        return inLen;\n@@ -234,1 +245,2 @@\n-    private static void ghashRangeCheck(byte[] in, int inOfs, int inLen, long[] st, long[] subH) {\n+    private static void ghashRangeCheck(byte[] in, int inOfs, int inLen,\n+        long[] st, long[] subH) {\n@@ -266,1 +278,2 @@\n-    private static void processBlocks(byte[] data, int inOfs, int blocks, long[] st, long[] subH) {\n+    private static void processBlocks(byte[] data, int inOfs, int blocks,\n+        long[] st, long[] subH) {\n@@ -275,0 +288,17 @@\n+    \/\/ ProcessBlock for Direct ByteBuffers\n+    private void processBlocksDirect(ByteBuffer ct, int inLen) {\n+        byte[] data = new byte[Math.min(MAX_LEN, inLen)];\n+        while (inLen > MAX_LEN) {\n+            ct.get(data, 0, MAX_LEN);\n+            processBlocks(data, 0, MAX_LEN \/ AES_BLOCK_SIZE, state,\n+                subkeyHtbl);\n+            inLen -= MAX_LEN;\n+        }\n+        if (inLen >= AES_BLOCK_SIZE) {\n+            int len = inLen - (inLen % AES_BLOCK_SIZE);\n+            ct.get(data, 0, len);\n+            processBlocks(data, 0, len \/ AES_BLOCK_SIZE, state,\n+                subkeyHtbl);\n+        }\n+    }\n+\n@@ -277,3 +307,5 @@\n-        putLong(result, 0, state[0]);\n-        putLong(result, 8, state[1]);\n-        reset();\n+        asLongView.set(result, 0, state[0]);\n+        asLongView.set(result, 8, state[1]);\n+        \/\/ Reset state\n+        state[0] = 0;\n+        state[1] = 0;\n@@ -282,0 +314,31 @@\n+\n+\n+    \/**\n+     * None of the out or dst values are necessary, they are to satisfy the\n+     * GCM interface requirement\n+     *\/\n+    @Override\n+    public int update(byte[] in, int inOfs, int inLen, byte[] out, int outOfs) {\n+        return update(in, inOfs, inLen);\n+    }\n+\n+    @Override\n+    public int update(byte[] in, int inOfs, int inLen, ByteBuffer dst) {\n+        return update(in, inOfs, inLen);\n+    }\n+\n+    @Override\n+    public int update(ByteBuffer src, ByteBuffer dst) {\n+        return update(src, src.remaining());\n+    }\n+\n+    @Override\n+    public int doFinal(byte[] in, int inOfs, int inLen, byte[] out,\n+        int outOfs) {\n+        return doFinal(in, inOfs, inLen);\n+    }\n+\n+    @Override\n+    public int doFinal(ByteBuffer src, ByteBuffer dst) {\n+        return doFinal(src, src.remaining());\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GHASH.java","additions":137,"deletions":74,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.security.jca.JCAUtil;\n@@ -32,0 +33,3 @@\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.CipherSpi;\n@@ -33,0 +37,1 @@\n+import javax.crypto.NoSuchPaddingException;\n@@ -34,0 +39,1 @@\n+import javax.crypto.spec.GCMParameterSpec;\n@@ -36,0 +42,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n@@ -37,0 +45,2 @@\n+import java.nio.ByteOrder;\n+import java.security.AlgorithmParameters;\n@@ -39,0 +49,3 @@\n+import java.security.Key;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n@@ -40,3 +53,4 @@\n-\n-import static com.sun.crypto.provider.AESConstants.AES_BLOCK_SIZE;\n-\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Arrays;\n@@ -57,3 +71,1 @@\n-final class GaloisCounterMode extends FeedbackCipher {\n-\n-    static int DEFAULT_TAG_LEN = AES_BLOCK_SIZE;\n+abstract class GaloisCounterMode extends CipherSpi {\n@@ -61,1 +73,1 @@\n-\n+    static int DEFAULT_TAG_LEN = 16; \/\/ in bytes\n@@ -71,1 +83,0 @@\n-\n@@ -75,3 +86,3 @@\n-    \/\/ buffer for AAD data; if null, meaning update has been called\n-    private ByteArrayOutputStream aadBuffer = new ByteArrayOutputStream();\n-    private int sizeOfAAD = 0;\n+    static final byte[] EMPTY_BUF = new byte[0];\n+\n+    private boolean initialized = false;\n@@ -79,2 +90,4 @@\n-    \/\/ buffer data for crypto operation\n-    private ByteArrayOutputStream ibuffer = null;\n+    SymmetricCipher blockCipher;\n+    \/\/ Engine instance for encryption or decryption\n+    private GCMEngine engine;\n+    private boolean encryption = true;\n@@ -82,2 +95,10 @@\n-    \/\/ Original dst buffer if there was an overlap situation\n-    private ByteBuffer originalDst = null;\n+    \/\/ Default value is 128bits, this is in bytes.\n+    int tagLenBytes = DEFAULT_TAG_LEN;\n+    \/\/ Key size if the value is passed, in bytes.\n+    int keySize;\n+    \/\/ Prevent reuse of iv or key\n+    boolean reInit = false;\n+    byte[] lastKey = EMPTY_BUF;\n+    byte[] lastIv = EMPTY_BUF;\n+    byte[] iv = null;\n+    SecureRandom random = null;\n@@ -85,2 +106,26 @@\n-    \/\/ in bytes; need to convert to bits (default value 128) when needed\n-    private int tagLenBytes = DEFAULT_TAG_LEN;\n+    \/**\n+     *\n+     * @param keySize length of key.\n+     * @param embeddedCipher Cipher object, such as AESCrypt.\n+     *\/\n+    GaloisCounterMode(int keySize, SymmetricCipher embeddedCipher) {\n+        blockCipher = embeddedCipher;\n+        this.keySize = keySize;\n+    }\n+\n+    \/**\n+     * Initializes the cipher in the specified mode with the given key\n+     * and iv.\n+     *\/\n+    void init(int opmode, Key key, GCMParameterSpec spec)\n+        throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        encryption = (opmode == Cipher.ENCRYPT_MODE) ||\n+            (opmode == Cipher.WRAP_MODE);\n+\n+        int tagLen = spec.getTLen();\n+        if (tagLen < 96 || tagLen > 128 || ((tagLen & 0x07) != 0)) {\n+            throw new InvalidAlgorithmParameterException\n+                (\"Unsupported TLen value.  Must be one of \" +\n+                    \"{128, 120, 112, 104, 96}\");\n+        }\n+        tagLenBytes = tagLen >> 3;\n@@ -88,4 +133,12 @@\n-    \/\/ these following 2 fields can only be initialized after init() is\n-    \/\/ called, e.g. after cipher key k is set, and STAY UNCHANGED\n-    private byte[] subkeyH = null;\n-    private byte[] preCounterBlock = null;\n+        \/\/ Check the Key object is valid and the right size\n+        if (key == null) {\n+            throw new InvalidKeyException(\"The key must not be null\");\n+        }\n+        byte[] keyValue = key.getEncoded();\n+        if (keyValue == null) {\n+            throw new InvalidKeyException(\"Key encoding must not be null\");\n+        } else if (keySize != -1 && keyValue.length != keySize) {\n+            Arrays.fill(keyValue, (byte) 0);\n+            throw new InvalidKeyException(\"The key must be \" +\n+                keySize + \" bytes\");\n+        }\n@@ -93,2 +146,8 @@\n-    private GCTR gctrPAndC = null;\n-    private GHASH ghashAllToS = null;\n+        \/\/ Check for reuse\n+        if (encryption) {\n+            if (MessageDigest.isEqual(keyValue, lastKey) &&\n+                MessageDigest.isEqual(iv, lastIv)) {\n+                Arrays.fill(keyValue, (byte) 0);\n+                throw new InvalidAlgorithmParameterException(\n+                    \"Cannot reuse iv for GCM encryption\");\n+            }\n@@ -96,2 +155,7 @@\n-    \/\/ length of total data, i.e. len(C)\n-    private int processed = 0;\n+            \/\/ Both values are already clones\n+            if (lastKey != null) {\n+                Arrays.fill(lastKey, (byte) 0);\n+            }\n+            lastKey = keyValue;\n+            lastIv = iv;\n+        }\n@@ -99,5 +163,1 @@\n-    \/\/ additional variables for save\/restore calls\n-    private byte[] aadBufferSave = null;\n-    private int sizeOfAADSave = 0;\n-    private byte[] ibufferSave = null;\n-    private int processedSave = 0;\n+        reInit = false;\n@@ -105,3 +165,298 @@\n-    \/\/ value must be 16-byte long; used by GCTR and GHASH as well\n-    static void increment32(byte[] value) {\n-        if (value.length != AES_BLOCK_SIZE) {\n+        \/\/ always encrypt mode for embedded cipher\n+        blockCipher.init(false, key.getAlgorithm(), keyValue);\n+    }\n+\n+    @Override\n+    protected void engineSetMode(String mode) throws NoSuchAlgorithmException {\n+        if (!mode.equalsIgnoreCase(\"GCM\")) {\n+            throw new NoSuchAlgorithmException(\"Mode must be GCM\");\n+        }\n+    }\n+\n+    @Override\n+    protected void engineSetPadding(String padding)\n+        throws NoSuchPaddingException {\n+        if (!padding.equalsIgnoreCase(\"NoPadding\")) {\n+            throw new NoSuchPaddingException(\"Padding must be NoPadding\");\n+        }\n+    }\n+\n+    @Override\n+    protected int engineGetBlockSize() {\n+        return blockCipher.getBlockSize();\n+    }\n+\n+    @Override\n+    protected int engineGetOutputSize(int inputLen) {\n+        checkInit();\n+        return engine.getOutputSize(inputLen, true);\n+    }\n+\n+    @Override\n+    protected int engineGetKeySize(Key key) throws InvalidKeyException {\n+        byte[] encoded = key.getEncoded();\n+        Arrays.fill(encoded, (byte)0);\n+        if (!AESCrypt.isKeySizeValid(encoded.length)) {\n+            throw new InvalidKeyException(\"Invalid key length: \" +\n+                                          encoded.length + \" bytes\");\n+        }\n+        return Math.multiplyExact(encoded.length, 8);\n+    }\n+\n+    @Override\n+    protected byte[] engineGetIV() {\n+        if (iv == null) {\n+            return null;\n+        }\n+        return iv.clone();\n+    }\n+\n+    \/**\n+     * Create a random 16-byte iv.\n+     *\n+     * @param rand a {@code SecureRandom} object.  If {@code null} is\n+     * provided a new {@code SecureRandom} object will be instantiated.\n+     *\n+     * @return a 16-byte array containing the random nonce.\n+     *\/\n+    private static byte[] createIv(SecureRandom rand) {\n+        byte[] iv = new byte[DEFAULT_IV_LEN];\n+        if (rand == null) {\n+            rand = JCAUtil.getDefSecureRandom();\n+        }\n+        rand.nextBytes(iv);\n+        return iv;\n+    }\n+\n+    @Override\n+    protected AlgorithmParameters engineGetParameters() {\n+        GCMParameterSpec spec;\n+        spec = new GCMParameterSpec(tagLenBytes * 8,\n+            iv == null ? createIv(random) : iv.clone());\n+        try {\n+            AlgorithmParameters params =\n+                AlgorithmParameters.getInstance(\"GCM\",\n+                    SunJCE.getInstance());\n+            params.init(spec);\n+            return params;\n+        } catch (NoSuchAlgorithmException | InvalidParameterSpecException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    protected void engineInit(int opmode, Key key, SecureRandom random)\n+        throws InvalidKeyException {\n+\n+        engine = null;\n+        if (opmode == Cipher.DECRYPT_MODE || opmode == Cipher.UNWRAP_MODE) {\n+            throw new InvalidKeyException(\"No GCMParameterSpec specified\");\n+        }\n+        try {\n+            engineInit(opmode, key, (AlgorithmParameterSpec) null, random);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            \/\/ never happen\n+        }\n+    }\n+\n+    @Override\n+    protected void engineInit(int opmode, Key key,\n+        AlgorithmParameterSpec params, SecureRandom random)\n+        throws InvalidKeyException, InvalidAlgorithmParameterException {\n+\n+        GCMParameterSpec spec;\n+        this.random = random;\n+        engine = null;\n+        if (params == null) {\n+            iv = createIv(random);\n+            spec = new GCMParameterSpec(DEFAULT_TAG_LEN * 8, iv);\n+        } else {\n+            if (!(params instanceof GCMParameterSpec)) {\n+                throw new InvalidAlgorithmParameterException(\n+                    \"AlgorithmParameterSpec not of GCMParameterSpec\");\n+            }\n+            spec = (GCMParameterSpec)params;\n+            iv = spec.getIV();\n+            if (iv == null) {\n+                throw new InvalidAlgorithmParameterException(\"IV is null\");\n+            }\n+            if (iv.length == 0) {\n+                throw new InvalidAlgorithmParameterException(\"IV is empty\");\n+            }\n+        }\n+        init(opmode, key, spec);\n+        initialized = true;\n+    }\n+\n+    @Override\n+    protected void engineInit(int opmode, Key key, AlgorithmParameters params,\n+        SecureRandom random) throws InvalidKeyException,\n+        InvalidAlgorithmParameterException {\n+        GCMParameterSpec spec = null;\n+        engine = null;\n+        if (params != null) {\n+            try {\n+                spec = params.getParameterSpec(GCMParameterSpec.class);\n+            } catch (InvalidParameterSpecException e) {\n+                throw new InvalidAlgorithmParameterException(e);\n+            }\n+        }\n+        engineInit(opmode, key, spec, random);\n+    }\n+\n+    void checkInit() {\n+        if (!initialized) {\n+            throw new IllegalStateException(\"Operation not initialized.\");\n+        }\n+\n+        if (engine == null) {\n+            if (encryption) {\n+                engine = new GCMEncrypt(blockCipher);\n+            } else {\n+                engine = new GCMDecrypt(blockCipher);\n+            }\n+        }\n+    }\n+\n+    void checkReInit() {\n+        if (reInit) {\n+            throw new IllegalStateException(\n+                \"Must use either different key or \" + \" iv for GCM encryption\");\n+        }\n+    }\n+\n+    @Override\n+    protected byte[] engineUpdate(byte[] input, int inputOffset, int inputLen) {\n+        checkInit();\n+        ArrayUtil.nullAndBoundsCheck(input, inputOffset, inputLen);\n+        return engine.doUpdate(input, inputOffset, inputLen);\n+    }\n+\n+    @Override\n+    protected int engineUpdate(byte[] input, int inputOffset, int inputLen,\n+        byte[] output, int outputOffset) throws ShortBufferException {\n+        checkInit();\n+        ArrayUtil.nullAndBoundsCheck(input, inputOffset, inputLen);\n+        ArrayUtil.nullAndBoundsCheck(output, outputOffset,\n+                output.length - outputOffset);\n+        int len = engine.getOutputSize(inputLen, false);\n+        if (len > output.length - outputOffset) {\n+            throw new ShortBufferException(\"Output buffer too small, must be \" +\n+                \"at least \" + len + \" bytes long\");\n+        }\n+        return engine.doUpdate(input, inputOffset, inputLen, output,\n+            outputOffset);\n+    }\n+\n+    @Override\n+    protected int engineUpdate(ByteBuffer src, ByteBuffer dst)\n+        throws ShortBufferException {\n+        checkInit();\n+        int len = engine.getOutputSize(src.remaining(), false);\n+        if (len > dst.remaining()) {\n+            throw new ShortBufferException(\n+                \"Output buffer must be at least \" + len + \" bytes long\");\n+        }\n+        return engine.doUpdate(src, dst);\n+    }\n+\n+    @Override\n+    protected void engineUpdateAAD(byte[] src, int offset, int len) {\n+        checkInit();\n+        engine.updateAAD(src, offset, len);\n+    }\n+\n+    @Override\n+    protected void engineUpdateAAD(ByteBuffer src) {\n+        checkInit();\n+        if (src.hasArray()) {\n+            int pos = src.position();\n+            int len = src.remaining();\n+            engine.updateAAD(src.array(), src.arrayOffset() + pos, len);\n+            src.position(pos + len);\n+        } else {\n+            byte[] aad = new byte[src.remaining()];\n+            src.get(aad);\n+            engine.updateAAD(aad, 0, aad.length);\n+        }\n+    }\n+\n+    @Override\n+    protected byte[] engineDoFinal(byte[] input, int inputOffset,\n+        int inputLen) throws IllegalBlockSizeException, BadPaddingException {\n+        if (input == null) {\n+            input = EMPTY_BUF;\n+        }\n+        try {\n+            ArrayUtil.nullAndBoundsCheck(input, inputOffset, inputLen);\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new IllegalBlockSizeException(\"input array invalid\");\n+        }\n+\n+        checkInit();\n+        byte[] output = new byte[engine.getOutputSize(inputLen, true)];\n+\n+        try {\n+            engine.doFinal(input, inputOffset, inputLen, output, 0);\n+        } catch (ShortBufferException e) {\n+            throw new ProviderException(e);\n+        } finally {\n+            \/\/ Release crypto engine\n+            engine = null;\n+        }\n+        return output;\n+    }\n+\n+    @Override\n+    protected int engineDoFinal(byte[] input, int inputOffset, int inputLen,\n+        byte[] output, int outputOffset) throws ShortBufferException,\n+        IllegalBlockSizeException, BadPaddingException {\n+\n+        if (input == null) {\n+            input = EMPTY_BUF;\n+        }\n+        try {\n+            ArrayUtil.nullAndBoundsCheck(input, inputOffset, inputLen);\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            \/\/ Release crypto engine\n+            engine = null;\n+            throw new IllegalBlockSizeException(\"input array invalid\");\n+        }\n+        checkInit();\n+        int len = engine.doFinal(input, inputOffset, inputLen, output,\n+            outputOffset);\n+\n+        \/\/ Release crypto engine\n+        engine = null;\n+\n+        return len;\n+    }\n+\n+    @Override\n+    protected int engineDoFinal(ByteBuffer src, ByteBuffer dst)\n+        throws ShortBufferException, IllegalBlockSizeException,\n+        BadPaddingException {\n+        checkInit();\n+\n+        int len = engine.doFinal(src, dst);\n+\n+        \/\/ Release crypto engine\n+        engine = null;\n+\n+        return len;\n+    }\n+\n+    @Override\n+    protected byte[] engineWrap(Key key) throws IllegalBlockSizeException,\n+        InvalidKeyException {\n+        byte[] encodedKey = null;\n+\n+        checkInit();\n+        try {\n+            encodedKey = key.getEncoded();\n+            if ((encodedKey == null) || (encodedKey.length == 0)) {\n+                throw new InvalidKeyException(\n+                    \"Cannot get an encoding of the key to be wrapped\");\n+            }\n+            return engineDoFinal(encodedKey, 0, encodedKey.length);\n+        } catch (BadPaddingException e) {\n@@ -109,1 +464,32 @@\n-            throw new ProviderException(\"Illegal counter block length\");\n+        } finally {\n+            \/\/ Release crypto engine\n+            engine = null;\n+            if (encodedKey != null) {\n+                Arrays.fill(encodedKey, (byte) 0);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    protected Key engineUnwrap(byte[] wrappedKey, String wrappedKeyAlgorithm,\n+        int wrappedKeyType) throws InvalidKeyException,\n+        NoSuchAlgorithmException {\n+        checkInit();\n+\n+        byte[] encodedKey;\n+        try {\n+            encodedKey = engineDoFinal(wrappedKey, 0,\n+                wrappedKey.length);\n+        } catch (BadPaddingException ePadding) {\n+            throw new InvalidKeyException(\n+                \"The wrapped key is not padded correctly\");\n+        } catch (IllegalBlockSizeException eBlockSize) {\n+            throw new InvalidKeyException(\n+                \"The wrapped key does not have the correct length\");\n+        }\n+        try {\n+            return ConstructKeys.constructKey(encodedKey, wrappedKeyAlgorithm,\n+                wrappedKeyType);\n+        } finally {\n+            Arrays.fill(encodedKey, (byte)0);\n@@ -111,0 +497,4 @@\n+    }\n+\n+    \/\/ value must be 16-byte long; used by GCTR and GHASH as well\n+    static void increment32(byte[] value) {\n@@ -118,0 +508,4 @@\n+    private static final VarHandle wrapToByteArray =\n+        MethodHandles.byteArrayViewVarHandle(long[].class,\n+            ByteOrder.BIG_ENDIAN);\n+\n@@ -119,10 +513,2 @@\n-        long ivLen = ((long)ivLenInBytes) << 3;\n-        byte[] out = new byte[AES_BLOCK_SIZE];\n-        out[8] = (byte)(ivLen >>> 56);\n-        out[9] = (byte)(ivLen >>> 48);\n-        out[10] = (byte)(ivLen >>> 40);\n-        out[11] = (byte)(ivLen >>> 32);\n-        out[12] = (byte)(ivLen >>> 24);\n-        out[13] = (byte)(ivLen >>> 16);\n-        out[14] = (byte)(ivLen >>> 8);\n-        out[15] = (byte)ivLen;\n+        byte[] out = new byte[16];\n+        wrapToByteArray.set(out, 8, ((long)ivLenInBytes  & 0xFFFFFFFFL) << 3);\n@@ -133,19 +519,3 @@\n-        long aLen = ((long)aLenInBytes) << 3;\n-        long cLen = ((long)cLenInBytes) << 3;\n-        byte[] out = new byte[AES_BLOCK_SIZE];\n-        out[0] = (byte)(aLen >>> 56);\n-        out[1] = (byte)(aLen >>> 48);\n-        out[2] = (byte)(aLen >>> 40);\n-        out[3] = (byte)(aLen >>> 32);\n-        out[4] = (byte)(aLen >>> 24);\n-        out[5] = (byte)(aLen >>> 16);\n-        out[6] = (byte)(aLen >>> 8);\n-        out[7] = (byte)aLen;\n-        out[8] = (byte)(cLen >>> 56);\n-        out[9] = (byte)(cLen >>> 48);\n-        out[10] = (byte)(cLen >>> 40);\n-        out[11] = (byte)(cLen >>> 32);\n-        out[12] = (byte)(cLen >>> 24);\n-        out[13] = (byte)(cLen >>> 16);\n-        out[14] = (byte)(cLen >>> 8);\n-        out[15] = (byte)cLen;\n+        byte[] out = new byte[16];\n+        wrapToByteArray.set(out, 0, ((long)aLenInBytes & 0xFFFFFFFFL) << 3);\n+        wrapToByteArray.set(out, 8, ((long)cLenInBytes & 0xFFFFFFFFL) << 3);\n@@ -155,2 +525,3 @@\n-    private static byte[] expandToOneBlock(byte[] in, int inOfs, int len) {\n-        if (len > AES_BLOCK_SIZE) {\n+    private static byte[] expandToOneBlock(byte[] in, int inOfs, int len,\n+        int blockSize) {\n+        if (len > blockSize) {\n@@ -159,1 +530,1 @@\n-        if (len == AES_BLOCK_SIZE && inOfs == 0) {\n+        if (len == blockSize && inOfs == 0) {\n@@ -162,1 +533,1 @@\n-            byte[] paddedIn = new byte[AES_BLOCK_SIZE];\n+            byte[] paddedIn = new byte[blockSize];\n@@ -168,1 +539,1 @@\n-    private static byte[] getJ0(byte[] iv, byte[] subkeyH) {\n+    private static byte[] getJ0(byte[] iv, byte[] subkeyH, int blockSize) {\n@@ -171,2 +542,2 @@\n-            j0 = expandToOneBlock(iv, 0, iv.length);\n-            j0[AES_BLOCK_SIZE - 1] = 1;\n+            j0 = expandToOneBlock(iv, 0, iv.length, blockSize);\n+            j0[blockSize - 1] = 1;\n@@ -175,1 +546,1 @@\n-            int lastLen = iv.length % AES_BLOCK_SIZE;\n+            int lastLen = iv.length % blockSize;\n@@ -179,1 +550,2 @@\n-                    expandToOneBlock(iv, iv.length - lastLen, lastLen);\n+                    expandToOneBlock(iv, iv.length - lastLen, lastLen,\n+                        blockSize);\n@@ -184,2 +556,1 @@\n-            byte[] lengthBlock = getLengthBlock(iv.length);\n-            g.update(lengthBlock);\n+            g.update(getLengthBlock(iv.length));\n@@ -201,1 +572,1 @@\n-        if (processed > max) {\n+        if (engine.processed > max) {\n@@ -207,5 +578,0 @@\n-    GaloisCounterMode(SymmetricCipher embeddedCipher) {\n-        super(embeddedCipher);\n-        aadBuffer = new ByteArrayOutputStream();\n-    }\n-\n@@ -213,3 +579,1 @@\n-     * Gets the name of the feedback mechanism\n-     *\n-     * @return the name of the feedback mechanism\n+     * Abstract class for GCMEncrypt and GCMDecrypt internal context objects\n@@ -217,21 +581,34 @@\n-    String getFeedback() {\n-        return \"GCM\";\n-    }\n-\n-    \/**\n-     * Resets the cipher object to its original state.\n-     * This is used when doFinal is called in the Cipher class, so that the\n-     * cipher can be reused (with its original key and iv).\n-     *\/\n-    void reset() {\n-        if (aadBuffer == null) {\n-            aadBuffer = new ByteArrayOutputStream();\n-        } else {\n-            aadBuffer.reset();\n-        }\n-        if (gctrPAndC != null) gctrPAndC.reset();\n-        if (ghashAllToS != null) ghashAllToS.reset();\n-        processed = 0;\n-        sizeOfAAD = 0;\n-        if (ibuffer != null) {\n-            ibuffer.reset();\n+    abstract class GCMEngine {\n+        byte[] preCounterBlock;\n+        GCTR gctrPAndC;\n+        GHASH ghashAllToS;\n+\n+        \/\/ Block size of the algorithm\n+        final int blockSize;\n+\n+        \/\/ length of total data, i.e. len(C)\n+        int processed = 0;\n+\n+        \/\/ buffer for AAD data; if null, meaning update has been called\n+        ByteArrayOutputStream aadBuffer = null;\n+        int sizeOfAAD = 0;\n+        boolean aadProcessed = false;\n+\n+        \/\/ buffer data for crypto operation\n+        ByteArrayOutputStream ibuffer = null;\n+\n+        \/\/ Original dst buffer if there was an overlap situation\n+        ByteBuffer originalDst = null;\n+        byte[] originalOut = null;\n+        int originalOutOfs = 0;\n+\n+\n+        GCMEngine(SymmetricCipher blockCipher) {\n+            blockSize = blockCipher.getBlockSize();\n+            byte[] subkeyH = new byte[blockSize];\n+            blockCipher.encryptBlock(subkeyH, 0, subkeyH,0);\n+            preCounterBlock = getJ0(iv, subkeyH, blockSize);\n+            byte[] j0Plus1 = preCounterBlock.clone();\n+            increment32(j0Plus1);\n+            gctrPAndC = new GCTR(blockCipher, j0Plus1);\n+            ghashAllToS = new GHASH(subkeyH);\n@@ -239,1 +616,0 @@\n-    }\n@@ -241,13 +617,30 @@\n-    \/**\n-     * Save the current content of this cipher.\n-     *\/\n-    void save() {\n-        processedSave = processed;\n-        sizeOfAADSave = sizeOfAAD;\n-        aadBufferSave =\n-            ((aadBuffer == null || aadBuffer.size() == 0)?\n-             null : aadBuffer.toByteArray());\n-        if (gctrPAndC != null) gctrPAndC.save();\n-        if (ghashAllToS != null) ghashAllToS.save();\n-        if (ibuffer != null) {\n-            ibufferSave = ibuffer.toByteArray();\n+        \/**\n+         * Get output buffer size\n+         * @param inLen Contains the length of the input data and buffered data.\n+         * @param isFinal true if this is a doFinal operation\n+         * @return If it's an update operation, inLen must blockSize\n+         *         divisible.  If it's a final operation, output will\n+         *         include the tag.\n+         *\/\n+        abstract int getOutputSize(int inLen, boolean isFinal);\n+\n+        \/\/ Update operations\n+        abstract byte[] doUpdate(byte[] in, int inOff, int inLen);\n+        abstract int doUpdate(byte[] in, int inOff, int inLen, byte[] out,\n+            int outOff) throws ShortBufferException;\n+        abstract int doUpdate(ByteBuffer src, ByteBuffer dst)\n+            throws ShortBufferException;\n+\n+        \/\/ Final operations\n+        abstract int doFinal(byte[] in, int inOff, int inLen, byte[] out,\n+            int outOff) throws IllegalBlockSizeException, AEADBadTagException,\n+            ShortBufferException;\n+        abstract int doFinal(ByteBuffer src, ByteBuffer dst)\n+            throws IllegalBlockSizeException, AEADBadTagException,\n+            ShortBufferException;\n+\n+        \/\/ Initialize internal data buffer, if not already.\n+        void initBuffer(int len) {\n+            if (ibuffer == null) {\n+                ibuffer = new ByteArrayOutputStream(len);\n+            }\n@@ -255,1 +648,0 @@\n-    }\n@@ -257,11 +649,3 @@\n-    \/**\n-     * Restores the content of this cipher to the previous saved one.\n-     *\/\n-    void restore() {\n-        processed = processedSave;\n-        sizeOfAAD = sizeOfAADSave;\n-        if (aadBuffer != null) {\n-            aadBuffer.reset();\n-            if (aadBufferSave != null) {\n-                aadBuffer.write(aadBufferSave, 0, aadBufferSave.length);\n-            }\n+        \/\/ Helper method for getting ibuffer size\n+        int getBufferedLength() {\n+            return (ibuffer == null ? 0 : ibuffer.size());\n@@ -269,5 +653,13 @@\n-        if (gctrPAndC != null) gctrPAndC.restore();\n-        if (ghashAllToS != null) ghashAllToS.restore();\n-        if (ibuffer != null) {\n-            ibuffer.reset();\n-            ibuffer.write(ibufferSave, 0, ibufferSave.length);\n+\n+        \/**\n+         * The method takes two buffers to create one block of data.  The\n+         * difference with the other mergeBlock is this will calculate\n+         * the bufLen from the existing 'buffer' length & offset\n+         *\n+         * This is only called when buffer length is less than a blockSize\n+         * @return number of bytes used from 'in'\n+         *\/\n+        int mergeBlock(byte[] buffer, int bufOfs, byte[] in, int inOfs,\n+            int inLen, byte[] block) {\n+            return mergeBlock(buffer, bufOfs, buffer.length - bufOfs, in,\n+                inOfs, inLen, block);\n@@ -275,1 +667,0 @@\n-    }\n@@ -277,16 +668,12 @@\n-    \/**\n-     * Initializes the cipher in the specified mode with the given key\n-     * and iv.\n-     *\n-     * @param decrypting flag indicating encryption or decryption\n-     * @param algorithm the algorithm name\n-     * @param key the key\n-     * @param iv the iv\n-     * @exception InvalidKeyException if the given key is inappropriate for\n-     * initializing this cipher\n-     *\/\n-    @Override\n-    void init(boolean decrypting, String algorithm, byte[] key, byte[] iv)\n-            throws InvalidKeyException, InvalidAlgorithmParameterException {\n-        init(decrypting, algorithm, key, iv, DEFAULT_TAG_LEN);\n-    }\n+        \/**\n+         * The method takes two buffers to create one block of data\n+         *\n+         * This is only called when buffer length is less than a blockSize\n+         * @return number of bytes used from 'in'\n+         *\/\n+        int mergeBlock(byte[] buffer, int bufOfs, int bufLen, byte[] in,\n+            int inOfs, int inLen, byte[] block) {\n+            if (bufLen > blockSize) {\n+                throw new RuntimeException(\"mergeBlock called on an ibuffer \" +\n+                    \"too big:  \" + bufLen + \" bytes\");\n+            }\n@@ -294,24 +681,4 @@\n-    \/**\n-     * Initializes the cipher in the specified mode with the given key\n-     * and iv.\n-     *\n-     * @param decrypting flag indicating encryption or decryption\n-     * @param algorithm the algorithm name\n-     * @param keyValue the key\n-     * @param ivValue the iv\n-     * @param tagLenBytes the length of tag in bytes\n-     *\n-     * @exception InvalidKeyException if the given key is inappropriate for\n-     * initializing this cipher\n-     *\/\n-    void init(boolean decrypting, String algorithm, byte[] keyValue,\n-              byte[] ivValue, int tagLenBytes)\n-              throws InvalidKeyException, InvalidAlgorithmParameterException {\n-        if (keyValue == null) {\n-            throw new InvalidKeyException(\"Internal error\");\n-        }\n-        if (ivValue == null) {\n-            throw new InvalidAlgorithmParameterException(\"Internal error\");\n-        }\n-        if (ivValue.length == 0) {\n-            throw new InvalidAlgorithmParameterException(\"IV is empty\");\n+            System.arraycopy(buffer, bufOfs, block, 0, bufLen);\n+            int inUsed = Math.min(block.length - bufLen, inLen);\n+            System.arraycopy(in, inOfs, block, bufLen, inUsed);\n+            return inUsed;\n@@ -320,25 +687,21 @@\n-        \/\/ always encrypt mode for embedded cipher\n-        this.embeddedCipher.init(false, algorithm, keyValue);\n-        this.subkeyH = new byte[AES_BLOCK_SIZE];\n-        this.embeddedCipher.encryptBlock(new byte[AES_BLOCK_SIZE], 0,\n-                this.subkeyH, 0);\n-\n-        this.iv = ivValue.clone();\n-        preCounterBlock = getJ0(iv, subkeyH);\n-        byte[] j0Plus1 = preCounterBlock.clone();\n-        increment32(j0Plus1);\n-        gctrPAndC = new GCTR(embeddedCipher, j0Plus1);\n-        ghashAllToS = new GHASH(subkeyH);\n-\n-        this.tagLenBytes = tagLenBytes;\n-        if (aadBuffer == null) {\n-            aadBuffer = new ByteArrayOutputStream();\n-        } else {\n-            aadBuffer.reset();\n-        }\n-        processed = 0;\n-        sizeOfAAD = 0;\n-        if (decrypting) {\n-            ibuffer = new ByteArrayOutputStream();\n-        }\n-    }\n+        \/**\n+         * Continues a multi-part update of the Additional Authentication\n+         * Data (AAD), using a subset of the provided buffer.  All AAD must be\n+         * supplied before beginning operations on the ciphertext (via the\n+         * {@code update} and {@code doFinal} methods).\n+         *\n+         * @param src the buffer containing the AAD\n+         * @param offset the offset in {@code src} where the AAD input starts\n+         * @param len the number of AAD bytes\n+         *\n+         * @throws IllegalStateException if this cipher is in a wrong state\n+         * (e.g., has not been initialized) or does not accept AAD, and one of\n+         * the {@code update} methods has already been called for the active\n+         * encryption\/decryption operation\n+         * @throws UnsupportedOperationException if this method\n+         * has not been overridden by an implementation\n+         *\/\n+        void updateAAD(byte[] src, int offset, int len) {\n+            if (encryption) {\n+                checkReInit();\n+            }\n@@ -346,26 +709,9 @@\n-    \/**\n-     * Continues a multi-part update of the Additional Authentication\n-     * Data (AAD), using a subset of the provided buffer. If this\n-     * cipher is operating in either GCM or CCM mode, all AAD must be\n-     * supplied before beginning operations on the ciphertext (via the\n-     * {@code update} and {@code doFinal} methods).\n-     * <p>\n-     * NOTE: Given most modes do not accept AAD, default impl for this\n-     * method throws IllegalStateException.\n-     *\n-     * @param src the buffer containing the AAD\n-     * @param offset the offset in {@code src} where the AAD input starts\n-     * @param len the number of AAD bytes\n-     *\n-     * @throws IllegalStateException if this cipher is in a wrong state\n-     * (e.g., has not been initialized), does not accept AAD, or if\n-     * operating in either GCM or CCM mode and one of the {@code update}\n-     * methods has already been called for the active\n-     * encryption\/decryption operation\n-     * @throws UnsupportedOperationException if this method\n-     * has not been overridden by an implementation\n-     *\n-     * @since 1.8\n-     *\/\n-    void updateAAD(byte[] src, int offset, int len) {\n-        if (aadBuffer != null) {\n+            if (aadBuffer == null) {\n+                if (sizeOfAAD == 0 && !aadProcessed) {\n+                    aadBuffer = new ByteArrayOutputStream(len);\n+                } else {\n+                    \/\/ update has already been called\n+                    throw new IllegalStateException\n+                        (\"Update has been called; no more AAD data\");\n+                }\n+            }\n@@ -373,4 +719,0 @@\n-        } else {\n-            \/\/ update has already been called\n-            throw new IllegalStateException\n-                (\"Update has been called; no more AAD data\");\n@@ -378,8 +720,0 @@\n-    }\n-\n-    \/\/ Feed the AAD data to GHASH, pad if necessary\n-    void processAAD() {\n-        if (aadBuffer != null) {\n-            if (aadBuffer.size() > 0) {\n-                byte[] aad = aadBuffer.toByteArray();\n-                sizeOfAAD = aad.length;\n@@ -387,8 +721,16 @@\n-                int lastLen = aad.length % AES_BLOCK_SIZE;\n-                if (lastLen != 0) {\n-                    ghashAllToS.update(aad, 0, aad.length - lastLen);\n-                    byte[] padded = expandToOneBlock(aad, aad.length - lastLen,\n-                                                     lastLen);\n-                    ghashAllToS.update(padded);\n-                } else {\n-                    ghashAllToS.update(aad);\n+        \/\/ Feed the AAD data to GHASH, pad if necessary\n+        void processAAD() {\n+            if (aadBuffer != null) {\n+                if (aadBuffer.size() > 0) {\n+                    byte[] aad = aadBuffer.toByteArray();\n+                    sizeOfAAD = aad.length;\n+\n+                    int lastLen = aad.length % blockSize;\n+                    if (lastLen != 0) {\n+                        ghashAllToS.update(aad, 0, aad.length - lastLen);\n+                        byte[] padded = expandToOneBlock(aad,\n+                            aad.length - lastLen, lastLen, blockSize);\n+                        ghashAllToS.update(padded);\n+                    } else {\n+                        ghashAllToS.update(aad);\n+                    }\n@@ -396,0 +738,1 @@\n+                aadBuffer = null;\n@@ -397,1 +740,1 @@\n-            aadBuffer = null;\n+            aadProcessed = true;\n@@ -399,1 +742,0 @@\n-    }\n@@ -401,6 +743,14 @@\n-    \/\/ Utility to process the last block; used by encryptFinal and decryptFinal\n-    void doLastBlock(byte[] in, int inOfs, int len, byte[] out, int outOfs,\n-                     boolean isEncrypt) throws IllegalBlockSizeException {\n-        byte[] ct;\n-        int ctOfs;\n-        int ilen = len;  \/\/ internal length\n+        \/**\n+         * Process en\/decryption all the way to the last block.  It takes both\n+         * For input it takes the ibuffer which is wrapped in 'buffer' and 'src'\n+         * from doFinal.\n+         *\/\n+        int doLastBlock(GCM op, ByteBuffer buffer, ByteBuffer src, ByteBuffer dst) {\n+            int resultLen = 0;\n+\n+            int bLen = (buffer != null ? buffer.remaining() : 0);\n+            if (bLen > 0) {\n+                \/\/ en\/decrypt on how much buffer there is in AES_BLOCK_SIZE\n+                if (bLen >= blockSize) {\n+                    resultLen += op.update(buffer, dst);\n+                }\n@@ -408,7 +758,6 @@\n-        if (isEncrypt) {\n-            ct = out;\n-            ctOfs = outOfs;\n-        } else {\n-            ct = in;\n-            ctOfs = inOfs;\n-        }\n+                \/\/ Process the remainder in the buffer\n+                if (bLen - resultLen > 0) {\n+                    \/\/ Copy the buffer remainder into an extra block\n+                    byte[] block = new byte[blockSize];\n+                    int over = buffer.remaining();\n+                    buffer.get(block, 0, over);\n@@ -416,58 +765,8 @@\n-        \/\/ Divide up larger data sizes to trigger CTR & GHASH intrinsic quicker\n-        if (len > TRIGGERLEN) {\n-            int i = 0;\n-            int tlen;  \/\/ incremental lengths\n-            final int plen = AES_BLOCK_SIZE * 6;\n-            \/\/ arbitrary formula to aid intrinsic without reaching buffer end\n-            final int count = len \/ 1024;\n-\n-            while (count > i) {\n-                tlen = gctrPAndC.update(in, inOfs, plen, out, outOfs);\n-                ghashAllToS.update(ct, ctOfs, tlen);\n-                inOfs += tlen;\n-                outOfs += tlen;\n-                ctOfs += tlen;\n-                i++;\n-            }\n-            ilen -= count * plen;\n-            processed += count * plen;\n-        }\n-\n-        gctrPAndC.doFinal(in, inOfs, ilen, out, outOfs);\n-        processed += ilen;\n-\n-        int lastLen = ilen % AES_BLOCK_SIZE;\n-        if (lastLen != 0) {\n-            ghashAllToS.update(ct, ctOfs, ilen - lastLen);\n-            ghashAllToS.update(\n-                    expandToOneBlock(ct, (ctOfs + ilen - lastLen), lastLen));\n-        } else {\n-            ghashAllToS.update(ct, ctOfs, ilen);\n-        }\n-    }\n-\n-    \/\/ Process en\/decryption all the way to the last block.  It takes both\n-    \/\/ For input it takes the ibuffer which is wrapped in 'buffer' and 'src'\n-    \/\/ from doFinal.\n-    void doLastBlock(ByteBuffer buffer, ByteBuffer src, ByteBuffer dst)\n-        throws IllegalBlockSizeException {\n-\n-        if (buffer != null && buffer.remaining() > 0) {\n-            \/\/ en\/decrypt on how much buffer there is in AES_BLOCK_SIZE\n-            processed += gctrPAndC.update(buffer, dst);\n-\n-            \/\/ Process the remainder in the buffer\n-            if (buffer.remaining() > 0) {\n-                \/\/ Copy the remainder of the buffer into the extra block\n-                byte[] block = new byte[AES_BLOCK_SIZE];\n-                int over = buffer.remaining();\n-                int len = over;  \/\/ how much is processed by in the extra block\n-                buffer.get(block, 0, over);\n-\n-                \/\/ if src is empty, update the final block and wait for later\n-                \/\/ to finalize operation\n-                if (src.remaining() > 0) {\n-                    \/\/ Fill out block with what is in data\n-                    if (src.remaining() > AES_BLOCK_SIZE - over) {\n-                        src.get(block, over, AES_BLOCK_SIZE - over);\n-                        len += AES_BLOCK_SIZE - over;\n+                    \/\/ If src has data, complete the block;\n+                    int slen = Math.min(src.remaining(), blockSize - over);\n+                    if (slen > 0) {\n+                        src.get(block, over, slen);\n+                    }\n+                    int len = slen + over;\n+                    if (len == blockSize) {\n+                        resultLen += op.update(block, 0, blockSize, dst);\n@@ -475,5 +774,7 @@\n-                        \/\/ If the remaining in buffer + data does not fill a\n-                        \/\/ block, complete the ghash operation\n-                        int l = src.remaining();\n-                        src.get(block, over, l);\n-                        len += l;\n+                        resultLen += op.doFinal(block, 0, len, block,\n+                                0);\n+                        if (dst != null) {\n+                            dst.put(block, 0, len);\n+                        }\n+                        processed += resultLen;\n+                        return resultLen;\n@@ -482,2 +783,0 @@\n-                gctrPAndC.update(block, 0, AES_BLOCK_SIZE, dst);\n-                processed += len;\n@@ -485,0 +784,10 @@\n+\n+            \/\/ en\/decrypt whatever remains in src.\n+            \/\/ If src has been consumed, this will be a no-op\n+            if (src.remaining() > TRIGGERLEN) {\n+                resultLen += throttleData(op, src, dst);\n+            }\n+\n+            resultLen += op.doFinal(src, dst);\n+            processed += resultLen;\n+            return resultLen;\n@@ -487,4 +796,0 @@\n-        \/\/ en\/decrypt whatever remains in src.\n-        \/\/ If src has been consumed, this will be a no-op\n-        processed += gctrPAndC.doFinal(src, dst);\n-    }\n@@ -492,10 +797,40 @@\n-     \/*\n-     * This method is for CipherCore to insert the remainder of its buffer\n-     * into the ibuffer before a doFinal(ByteBuffer, ByteBuffer) operation\n-     *\/\n-    int encrypt(byte[] in, int inOfs, int len) {\n-        if (len > 0) {\n-            \/\/ store internally until encryptFinal\n-            ArrayUtil.nullAndBoundsCheck(in, inOfs, len);\n-            if (ibuffer == null) {\n-                ibuffer = new ByteArrayOutputStream();\n+        \/**\n+         * This segments large data into smaller chunks so hotspot will start\n+         * using GCTR and GHASH intrinsics sooner.  This is a problem for app\n+         * and perf tests that only use large input sizes.\n+         *\/\n+        int throttleData(GCM op, byte[] in, int inOfs, int inLen,\n+            byte[] out, int outOfs) {\n+\n+            int segments = (inLen \/ 6);\n+            segments -= segments % blockSize;\n+            int len = 0;\n+            int i = 0;\n+            do {\n+                len += op.update(in, inOfs + len, segments, out,outOfs + len);\n+            } while (++i < 5);\n+\n+            len += op.update(in, inOfs + len, inLen - len, out, outOfs + len);\n+            return len;\n+        }\n+\n+\n+        \/**\n+         * This segments large data into smaller chunks so hotspot will start\n+         * using GCTR and GHASH intrinsics sooner.  This is a problem for app\n+         * and perf tests that only use large input sizes.\n+         *\/\n+        int throttleData(GCM op, ByteBuffer src, ByteBuffer dst) {\n+            int inLen = src.limit();\n+            int segments = (src.remaining() \/ 6);\n+            segments -= segments % blockSize;\n+            int i = 0, resultLen = 0;\n+            do {\n+                src.limit(src.position() + segments);\n+                resultLen += op.update(src, dst);\n+            } while (++i < 5);\n+\n+            src.limit(inLen);\n+            \/\/ If there is still at least a blockSize left\n+            if (src.remaining() > blockSize) {\n+                resultLen += op.update(src, dst);\n@@ -503,1 +838,2 @@\n-            ibuffer.write(in, inOfs, len);\n+\n+            return resultLen;\n@@ -505,2 +841,0 @@\n-        return len;\n-    }\n@@ -508,64 +842,63 @@\n-    \/**\n-     * Performs encryption operation.\n-     *\n-     * <p>The input plain text <code>in<\/code>, starting at <code>inOfs<\/code>\n-     * and ending at <code>(inOfs + len - 1)<\/code>, is encrypted. The result\n-     * is stored in <code>out<\/code>, starting at <code>outOfs<\/code>.\n-     *\n-     * @param in the buffer with the input data to be encrypted\n-     * @param inOfs the offset in <code>in<\/code>\n-     * @param inLen the length of the input data\n-     * @param out the buffer for the result\n-     * @param outOfs the offset in <code>out<\/code>\n-     * @return the number of bytes placed into the <code>out<\/code> buffer\n-     *\/\n-    int encrypt(byte[] in, int inOfs, int inLen, byte[] out, int outOfs) {\n-        checkDataLength(inLen, getBufferedLength());\n-        ArrayUtil.nullAndBoundsCheck(in, inOfs, inLen);\n-        ArrayUtil.nullAndBoundsCheck(out, outOfs, inLen);\n-\n-        processAAD();\n-        \/\/ 'inLen' stores the length to use with buffer 'in'.\n-        \/\/ 'len' stores the length returned by the method.\n-        int len = inLen;\n-\n-        \/\/ if there is enough data in the ibuffer and 'in', encrypt it.\n-        if (ibuffer != null && ibuffer.size() > 0) {\n-            byte[] buffer = ibuffer.toByteArray();\n-            \/\/ number of bytes not filling a block\n-            int remainder = ibuffer.size() % blockSize;\n-            \/\/ number of bytes along block boundary\n-            int blen = ibuffer.size() - remainder;\n-\n-            \/\/ If there is enough bytes in ibuffer for a block or more,\n-            \/\/ encrypt that first.\n-            if (blen > 0) {\n-                encryptBlocks(buffer, 0, blen, out, outOfs);\n-                outOfs += blen;\n-            }\n-\n-            \/\/ blen is now the offset for 'buffer'\n-\n-            \/\/ Construct and encrypt a block if there is enough 'buffer' and\n-            \/\/ 'in' to make one\n-            if ((inLen + remainder) >= blockSize) {\n-                byte[] block = new byte[blockSize];\n-\n-                System.arraycopy(buffer, blen, block, 0, remainder);\n-                int inLenUsed = blockSize - remainder;\n-                System.arraycopy(in, inOfs, block, remainder, inLenUsed);\n-\n-                encryptBlocks(block, 0, blockSize, out, outOfs);\n-                inOfs += inLenUsed;\n-                inLen -= inLenUsed;\n-                len += (blockSize - inLenUsed);\n-                outOfs += blockSize;\n-                ibuffer.reset();\n-                \/\/ Code below will write the remainder from 'in' to ibuffer\n-            } else if (remainder > 0) {\n-                \/\/ If a block or more was encrypted from 'buffer' only, but the\n-                \/\/ rest of 'buffer' with 'in' could not construct a block, then\n-                \/\/ put the rest of 'buffer' back into ibuffer.\n-                ibuffer.reset();\n-                ibuffer.write(buffer, blen, remainder);\n-                \/\/ Code below will write the remainder from 'in' to ibuffer\n+        \/**\n+         * Check for overlap. If the src and dst buffers are using shared data\n+         * and if dst will overwrite src data before src can be processed.\n+         * If so, make a copy to put the dst data in.\n+         *\/\n+        ByteBuffer overlapDetection(ByteBuffer src, ByteBuffer dst) {\n+            if (src.isDirect() && dst.isDirect()) {\n+                DirectBuffer dsrc = (DirectBuffer) src;\n+                DirectBuffer ddst = (DirectBuffer) dst;\n+\n+                \/\/ Get the current memory address for the given ByteBuffers\n+                long srcaddr = dsrc.address();\n+                long dstaddr = ddst.address();\n+\n+                \/\/ Find the lowest attachment that is the base memory address\n+                \/\/ of the shared memory for the src object\n+                while (dsrc.attachment() != null) {\n+                    srcaddr = ((DirectBuffer) dsrc.attachment()).address();\n+                    dsrc = (DirectBuffer) dsrc.attachment();\n+                }\n+\n+                \/\/ Find the lowest attachment that is the base memory address\n+                \/\/ of the shared memory for the dst object\n+                while (ddst.attachment() != null) {\n+                    dstaddr = ((DirectBuffer) ddst.attachment()).address();\n+                    ddst = (DirectBuffer) ddst.attachment();\n+                }\n+\n+                \/\/ If the base addresses are not the same, there is no overlap\n+                if (srcaddr != dstaddr) {\n+                    return dst;\n+                }\n+                \/\/ At this point we know these objects share the same memory.\n+                \/\/ This checks the starting position of the src and dst address\n+                \/\/ for overlap.\n+                \/\/ It uses the base address minus the passed object's address to\n+                \/\/ get the offset from the base address, then add the position()\n+                \/\/ from the passed object.  That gives up the true offset from\n+                \/\/ the base address.  As long as the src side is >= the dst\n+                \/\/ side, we are not in overlap.\n+                if (((DirectBuffer) src).address() - srcaddr + src.position() >=\n+                    ((DirectBuffer) dst).address() - dstaddr + dst.position()) {\n+                    return dst;\n+                }\n+\n+            } else if (!src.isDirect() && !dst.isDirect()) {\n+                \/\/ if src is read only, then we need a copy\n+                if (!src.isReadOnly()) {\n+                    \/\/ If using the heap, check underlying byte[] address.\n+                    if (!src.array().equals(dst.array()) ) {\n+                        return dst;\n+                    }\n+\n+                    \/\/ Position plus arrayOffset() will give us the true offset\n+                    \/\/ from the underlying byte[] address.\n+                    if (src.position() + src.arrayOffset() >=\n+                        dst.position() + dst.arrayOffset()) {\n+                        return dst;\n+                    }\n+                }\n+            } else {\n+                \/\/ buffer types are not the same and can be used as-is\n+                return dst;\n@@ -573,3 +906,11 @@\n-            \/\/ If blen == 0 and there was not enough to construct a block\n-            \/\/ from 'buffer' and 'in', then let the below code append 'in' to\n-            \/\/ the ibuffer.\n+\n+            \/\/ Create a copy\n+            ByteBuffer tmp = dst.duplicate();\n+            \/\/ We can use a heap buffer for internal use, save on alloc cost\n+            ByteBuffer bb = ByteBuffer.allocate(dst.remaining());\n+            tmp.limit(dst.limit());\n+            tmp.position(dst.position());\n+            bb.put(tmp);\n+            bb.flip();\n+            originalDst = dst;\n+            return bb;\n@@ -578,5 +919,10 @@\n-        \/\/ Write any remaining bytes outside the blockSize into ibuffer.\n-        int remainder = inLen % blockSize;\n-        if (remainder > 0) {\n-            if (ibuffer == null) {\n-                ibuffer = new ByteArrayOutputStream(inLen % blockSize);\n+        \/**\n+         * Overlap detection for data using byte array.\n+         * If an intermediate array is needed, the original out array length is\n+         * allocated because for code simplicity.\n+         *\/\n+        byte[] overlapDetection(byte[] in, int inOfs, byte[] out, int outOfs) {\n+            if (in == out && inOfs < outOfs) {\n+                originalOut = out;\n+                originalOutOfs = outOfs;\n+                return new byte[out.length];\n@@ -584,4 +930,1 @@\n-            len -= remainder;\n-            inLen -= remainder;\n-            \/\/ remainder offset is based on original buffer length\n-            ibuffer.write(in, inOfs + inLen, remainder);\n+            return out;\n@@ -590,3 +933,12 @@\n-        \/\/ Encrypt the remaining blocks inside of 'in'\n-        if (inLen > 0) {\n-            encryptBlocks(in, inOfs, inLen, out, outOfs);\n+        \/**\n+         * If originalDst is not null, 'dst' is an internal buffer and it's\n+         * data will be copied to the original dst buffer\n+         *\/\n+        void restoreDst(ByteBuffer dst) {\n+            if (originalDst == null) {\n+                return;\n+            }\n+\n+            dst.flip();\n+            originalDst.put(dst);\n+            originalDst = null;\n@@ -595,2 +947,8 @@\n-        return len;\n-    }\n+        \/**\n+         * If originalOut is not null, the 'out' is an internal buffer and it's\n+         * data will be copied into original out byte[];\n+         *\/\n+        void restoreOut(byte[] out, int len) {\n+            if (originalOut == null) {\n+                return;\n+            }\n@@ -598,4 +956,4 @@\n-    void encryptBlocks(byte[] in, int inOfs, int len, byte[] out, int outOfs) {\n-        gctrPAndC.update(in, inOfs, len, out, outOfs);\n-        processed += len;\n-        ghashAllToS.update(out, outOfs, len);\n+            System.arraycopy(out, originalOutOfs, originalOut, originalOutOfs,\n+                len);\n+            originalOut = null;\n+        }\n@@ -605,8 +963,1 @@\n-     * Performs encryption operation for the last time.\n-     *\n-     * @param in the input buffer with the data to be encrypted\n-     * @param inOfs the offset in <code>in<\/code>\n-     * @param len the length of the input data\n-     * @param out the buffer for the encryption result\n-     * @param outOfs the offset in <code>out<\/code>\n-     * @return the number of bytes placed into the <code>out<\/code> buffer\n+     * Encryption Engine object\n@@ -614,3 +965,2 @@\n-    int encryptFinal(byte[] in, int inOfs, int len, byte[] out, int outOfs)\n-        throws IllegalBlockSizeException, ShortBufferException {\n-        checkDataLength(len, getBufferedLength(), tagLenBytes);\n+    class GCMEncrypt extends GCMEngine {\n+        GCTRGHASH gctrghash;\n@@ -618,5 +968,3 @@\n-        try {\n-            ArrayUtil.nullAndBoundsCheck(out, outOfs,\n-                (len + tagLenBytes));\n-        } catch (ArrayIndexOutOfBoundsException aiobe) {\n-            throw new ShortBufferException(\"Output buffer too small\");\n+        GCMEncrypt(SymmetricCipher blockCipher) {\n+            super(blockCipher);\n+            gctrghash = new GCTRGHASH(gctrPAndC, ghashAllToS);\n@@ -625,5 +973,9 @@\n-        processAAD();\n-        if (len > 0) {\n-            ArrayUtil.nullAndBoundsCheck(in, inOfs, len);\n-\n-            doLastBlock(in, inOfs, len, out, outOfs, true);\n+        @Override\n+        public int getOutputSize(int inLen, boolean isFinal) {\n+            int len = getBufferedLength();\n+            if (isFinal) {\n+                return len + inLen + tagLenBytes;\n+            } else {\n+                len += inLen;\n+                return len - (len % blockCipher.getBlockSize());\n+            }\n@@ -632,5 +984,12 @@\n-        byte[] block = getLengthBlock(sizeOfAAD, processed);\n-        ghashAllToS.update(block);\n-        block = ghashAllToS.digest();\n-        GCTR gctrForSToTag = new GCTR(embeddedCipher, this.preCounterBlock);\n-        gctrForSToTag.doFinal(block, 0, tagLenBytes, block, 0);\n+        @Override\n+        byte[] doUpdate(byte[] in, int inOff, int inLen) {\n+            checkReInit();\n+            byte[] output = new byte[getOutputSize(inLen, false)];\n+            try {\n+                doUpdate(in, inOff, inLen, output, 0);\n+            } catch (ShortBufferException e) {\n+                \/\/ This should never happen because we just allocated output\n+                throw new ProviderException(\"output buffer creation failed\", e);\n+            }\n+            return output;\n+        }\n@@ -638,3 +997,41 @@\n-        System.arraycopy(block, 0, out, (outOfs + len), tagLenBytes);\n-        return (len + tagLenBytes);\n-    }\n+        \/**\n+         * Encrypt update operation.  This uses both the ibuffer and 'in' to\n+         * encrypt as many blocksize data as possible.  Any remaining data is\n+         * put into the ibuffer.\n+         *\/\n+        @Override\n+        public int doUpdate(byte[] in, int inOfs, int inLen, byte[] out,\n+            int outOfs) throws ShortBufferException {\n+\n+            checkReInit();\n+\n+            \/\/ 'inLen' stores the length to use with buffer 'in'.\n+            \/\/ 'len' stores the length returned by the method.\n+            int len = 0;\n+            int bLen = getBufferedLength();\n+            checkDataLength(inLen, bLen);\n+\n+            processAAD();\n+            out = overlapDetection(in, inOfs, out, outOfs);\n+\n+            \/\/ if there is enough data in the ibuffer and 'in', encrypt it.\n+            if (bLen > 0) {\n+                byte[] buffer = ibuffer.toByteArray();\n+                \/\/ number of bytes not filling a block\n+                int remainder = blockSize - bLen;\n+\n+                \/\/ Construct and encrypt a block if there is enough 'buffer' and\n+                \/\/ 'in' to make one\n+                if ((inLen + bLen) >= blockSize) {\n+                    byte[] block = new byte[blockSize];\n+\n+                    System.arraycopy(buffer, 0, block, 0, bLen);\n+                    System.arraycopy(in, inOfs, block, bLen, remainder);\n+\n+                    len = gctrghash.update(block, 0, blockSize, out, outOfs);\n+                    inOfs += remainder;\n+                    inLen -= remainder;\n+                    outOfs += blockSize;\n+                    ibuffer.reset();\n+                }\n+            }\n@@ -642,5 +1039,4 @@\n-    int encryptFinal(ByteBuffer src, ByteBuffer dst)\n-        throws IllegalBlockSizeException, ShortBufferException {\n-        dst = overlapDetection(src, dst);\n-        int len = src.remaining();\n-        len += getBufferedLength();\n+            \/\/ Encrypt the remaining blocks inside of 'in'\n+            if (inLen >= blockSize) {\n+                len += gctrghash.update(in, inOfs, inLen, out, outOfs);\n+            }\n@@ -648,6 +1044,8 @@\n-        \/\/ 'len' includes ibuffer data\n-        checkDataLength(len, tagLenBytes);\n-        dst.mark();\n-        if (dst.remaining() < len + tagLenBytes) {\n-            throw new ShortBufferException(\"Output buffer too small\");\n-        }\n+            \/\/ Write any remaining bytes less than a blockSize into ibuffer.\n+            int remainder = inLen % blockSize;\n+            if (remainder > 0) {\n+                initBuffer(remainder);\n+                inLen -= remainder;\n+                \/\/ remainder offset is based on original buffer length\n+                ibuffer.write(in, inOfs + inLen, remainder);\n+            }\n@@ -655,6 +1053,3 @@\n-        processAAD();\n-        if (len > 0) {\n-            doLastBlock((ibuffer == null || ibuffer.size() == 0) ?\n-                    null : ByteBuffer.wrap(ibuffer.toByteArray()), src, dst);\n-            dst.reset();\n-            ghashAllToS.doLastBlock(dst, len);\n+            restoreOut(out, len);\n+            processed += len;\n+            return len;\n@@ -663,7 +1058,33 @@\n-        byte[] block = getLengthBlock(sizeOfAAD, processed);\n-        ghashAllToS.update(block);\n-        block = ghashAllToS.digest();\n-        GCTR gctrForSToTag = new GCTR(embeddedCipher, this.preCounterBlock);\n-        gctrForSToTag.doFinal(block, 0, tagLenBytes, block, 0);\n-        dst.put(block, 0, tagLenBytes);\n-        restoreDst(dst);\n+        \/**\n+         * Encrypt update operation.  This uses both the ibuffer and 'src' to\n+         * encrypt as many blocksize data as possible.  Any remaining data is\n+         * put into the ibuffer.\n+         *\/\n+        @Override\n+        public int doUpdate(ByteBuffer src, ByteBuffer dst)\n+            throws ShortBufferException {\n+            checkReInit();\n+            int bLen = getBufferedLength();\n+            checkDataLength(src.remaining(), bLen);\n+\n+            \/\/ 'len' stores the length returned by the method.\n+            int len = 0;\n+\n+            processAAD();\n+\n+            dst = overlapDetection(src, dst);\n+            \/\/ if there is enough data in the ibuffer and 'in', encrypt it.\n+            if (bLen > 0) {\n+                \/\/ number of bytes not filling a block\n+                int remainder = blockSize - bLen;\n+                \/\/ Check if there is enough 'src' and 'buffer' to fill a block\n+                if (src.remaining() >= remainder) {\n+                    byte[] block = new byte[blockSize];\n+                    ByteBuffer buffer = ByteBuffer.wrap(ibuffer.toByteArray());\n+                    buffer.get(block, 0, bLen);\n+                    src.get(block, bLen, remainder);\n+                    len += cryptBlocks(\n+                            ByteBuffer.wrap(block, 0, blockSize), dst);\n+                    ibuffer.reset();\n+                }\n+            }\n@@ -671,2 +1092,4 @@\n-        return (len + tagLenBytes);\n-    }\n+            \/\/ encrypt any blocksized data in 'src'\n+            if (src.remaining() >= blockSize) {\n+                len += cryptBlocks(src, dst);\n+            }\n@@ -674,19 +1097,12 @@\n-    \/**\n-     * Performs decryption operation.\n-     *\n-     * <p>The input cipher text <code>in<\/code>, starting at\n-     * <code>inOfs<\/code> and ending at <code>(inOfs + len - 1)<\/code>,\n-     * is decrypted. The result is stored in <code>out<\/code>, starting at\n-     * <code>outOfs<\/code>.\n-     *\n-     * @param in the buffer with the input data to be decrypted\n-     * @param inOfs the offset in <code>in<\/code>\n-     * @param len the length of the input data\n-     * @param out the buffer for the result\n-     * @param outOfs the offset in <code>out<\/code>\n-     * @exception ProviderException if <code>len<\/code> is not\n-     * a multiple of the block size\n-     * @return the number of bytes placed into the <code>out<\/code> buffer\n-     *\/\n-    int decrypt(byte[] in, int inOfs, int len, byte[] out, int outOfs) {\n-        processAAD();\n+            \/\/ Write the remaining bytes into the 'ibuffer'\n+            if (src.remaining() > 0) {\n+                initBuffer(src.remaining());\n+                byte[] b = new byte[src.remaining()];\n+                src.get(b);\n+                \/\/ remainder offset is based on original buffer length\n+                try {\n+                    ibuffer.write(b);\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n@@ -694,6 +1110,2 @@\n-        if (len > 0) {\n-            \/\/ store internally until decryptFinal is called because\n-            \/\/ spec mentioned that only return recovered data after tag\n-            \/\/ is successfully verified\n-            ArrayUtil.nullAndBoundsCheck(in, inOfs, len);\n-            ibuffer.write(in, inOfs, len);\n+            restoreDst(dst);\n+            return len;\n@@ -701,2 +1113,0 @@\n-        return 0;\n-    }\n@@ -704,4 +1114,7 @@\n-    int decrypt(ByteBuffer src, ByteBuffer dst) {\n-        if (src.remaining() > 0) {\n-            byte[] b = new byte[src.remaining()];\n-            src.get(b);\n+        \/**\n+         * Return final encrypted data with auth tag using byte[]\n+         *\/\n+        @Override\n+        public int doFinal(byte[] in, int inOfs, int inLen, byte[] out,\n+            int outOfs) throws IllegalBlockSizeException, ShortBufferException {\n+            checkReInit();\n@@ -709,3 +1122,4 @@\n-                ibuffer.write(b);\n-            } catch (IOException e) {\n-                throw new ProviderException(\"Unable to add remaining input to the buffer\", e);\n+                ArrayUtil.nullAndBoundsCheck(out, outOfs, getOutputSize(inLen,\n+                    true));\n+            } catch (ArrayIndexOutOfBoundsException aiobe) {\n+                throw new ShortBufferException(\"Output buffer invalid\");\n@@ -713,3 +1127,0 @@\n-        }\n-        return 0;\n-    }\n@@ -717,23 +1128,44 @@\n-    \/**\n-     * Performs decryption operation for the last time.\n-     *\n-     * <p>NOTE: For cipher feedback modes which does not perform\n-     * special handling for the last few blocks, this is essentially\n-     * the same as <code>encrypt(...)<\/code>. Given most modes do\n-     * not do special handling, the default impl for this method is\n-     * to simply call <code>decrypt(...)<\/code>.\n-     *\n-     * @param in the input buffer with the data to be decrypted\n-     * @param inOfs the offset in <code>cipher<\/code>\n-     * @param len the length of the input data\n-     * @param out the buffer for the decryption result\n-     * @param outOfs the offset in <code>plain<\/code>\n-     * @return the number of bytes placed into the <code>out<\/code> buffer\n-     *\/\n-    int decryptFinal(byte[] in, int inOfs, int len,\n-                     byte[] out, int outOfs)\n-        throws IllegalBlockSizeException, AEADBadTagException,\n-        ShortBufferException {\n-        if (len < tagLenBytes) {\n-            throw new AEADBadTagException(\"Input too short - need tag\");\n-        }\n+            int bLen = getBufferedLength();\n+            checkDataLength(inLen, bLen, tagLenBytes);\n+            processAAD();\n+            out = overlapDetection(in, inOfs, out, outOfs);\n+\n+            int resultLen = 0;\n+            byte[] block;\n+\n+            \/\/ process what is in the ibuffer\n+            if (bLen > 0) {\n+                byte[] buffer = ibuffer.toByteArray();\n+\n+                \/\/ Make a block if the remaining ibuffer and 'in' can make one.\n+                if (bLen + inLen >= blockSize) {\n+                    int r, bufOfs = 0;\n+                    block = new byte[blockSize];\n+                    r = mergeBlock(buffer, bufOfs, in, inOfs, inLen, block);\n+                    inOfs += r;\n+                    inLen -= r;\n+                    r = gctrghash.update(block, 0, blockSize, out,\n+                        outOfs);\n+                    outOfs += r;\n+                    resultLen += r;\n+                    processed += r;\n+                } else {\n+                    \/\/ Need to consume all the ibuffer here to prepare for doFinal()\n+                    block = new byte[bLen + inLen];\n+                    System.arraycopy(buffer, 0, block, 0, bLen);\n+                    System.arraycopy(in, inOfs, block, bLen, inLen);\n+                    inLen += bLen;\n+                    in = block;\n+                    inOfs = 0;\n+                }\n+            }\n+\n+            \/\/ process what is left in the input buffer\n+            if (inLen > TRIGGERLEN) {\n+                int r = throttleData(gctrghash, in, inOfs, inLen, out, outOfs);\n+                inOfs += r;\n+                inLen -= r;\n+                outOfs += r;\n+                resultLen += r;\n+                processed += r;\n+            }\n@@ -741,3 +1173,3 @@\n-        \/\/ do this check here can also catch the potential integer overflow\n-        \/\/ scenario for the subsequent output buffer capacity check.\n-        checkDataLength(getBufferedLength(), (len - tagLenBytes));\n+            processed += gctrghash.doFinal(in, inOfs, inLen, out, outOfs);\n+            outOfs += inLen;\n+            resultLen += inLen;\n@@ -745,6 +1177,5 @@\n-        try {\n-            ArrayUtil.nullAndBoundsCheck(out, outOfs,\n-                (getBufferedLength() + len) - tagLenBytes);\n-        } catch (ArrayIndexOutOfBoundsException aiobe) {\n-            throw new ShortBufferException(\"Output buffer too small\");\n-        }\n+            block = getLengthBlock(sizeOfAAD, processed);\n+            ghashAllToS.update(block);\n+            block = ghashAllToS.digest();\n+            new GCTR(blockCipher, preCounterBlock).doFinal(block, 0,\n+                tagLenBytes, block, 0);\n@@ -752,1 +1183,4 @@\n-        processAAD();\n+            \/\/ copy the tag to the end of the buffer\n+            System.arraycopy(block, 0, out, outOfs, tagLenBytes);\n+            int len = resultLen + tagLenBytes;\n+            restoreOut(out, len);\n@@ -754,1 +1188,3 @@\n-        ArrayUtil.nullAndBoundsCheck(in, inOfs, len);\n+            reInit = true;\n+            return len;\n+        }\n@@ -756,4 +1192,16 @@\n-        \/\/ get the trailing tag bytes from 'in'\n-        byte[] tag = new byte[tagLenBytes];\n-        System.arraycopy(in, inOfs + len - tagLenBytes, tag, 0, tagLenBytes);\n-        len -= tagLenBytes;\n+        \/**\n+         * Return final encrypted data with auth tag using bytebuffers\n+         *\/\n+        @Override\n+        public int doFinal(ByteBuffer src, ByteBuffer dst) throws\n+            IllegalBlockSizeException, ShortBufferException {\n+            checkReInit();\n+            dst = overlapDetection(src, dst);\n+            int len = src.remaining() + getBufferedLength();\n+\n+            \/\/ 'len' includes ibuffer data\n+            checkDataLength(len, tagLenBytes);\n+            if (dst.remaining() < len + tagLenBytes) {\n+                throw new ShortBufferException(\"Output buffer too small, must\" +\n+                    \"be at least \" + (len + tagLenBytes) + \" bytes long\");\n+            }\n@@ -761,3 +1209,1 @@\n-        \/\/ If decryption is in-place or there is buffered \"ibuffer\" data, copy\n-        \/\/ the \"in\" byte array into the ibuffer before proceeding.\n-        if (in == out || getBufferedLength() > 0) {\n+            processAAD();\n@@ -765,1 +1211,3 @@\n-                ibuffer.write(in, inOfs, len);\n+                processed += doLastBlock(gctrghash,\n+                    (ibuffer == null || ibuffer.size() == 0) ? null :\n+                        ByteBuffer.wrap(ibuffer.toByteArray()), src, dst);\n@@ -768,10 +1216,4 @@\n-            \/\/ refresh 'in' to all buffered-up bytes\n-            in = ibuffer.toByteArray();\n-            inOfs = 0;\n-            len = in.length;\n-            ibuffer.reset();\n-        }\n-\n-        if (len > 0) {\n-            doLastBlock(in, inOfs, len, out, outOfs, false);\n-        }\n+            \/\/ release buffer if needed\n+            if (ibuffer != null) {\n+                ibuffer.reset();\n+            }\n@@ -779,5 +1221,7 @@\n-        byte[] block = getLengthBlock(sizeOfAAD, processed);\n-        ghashAllToS.update(block);\n-        block = ghashAllToS.digest();\n-        GCTR gctrForSToTag = new GCTR(embeddedCipher, this.preCounterBlock);\n-        gctrForSToTag.doFinal(block, 0, tagLenBytes, block, 0);\n+            byte[] block = getLengthBlock(sizeOfAAD, processed);\n+            ghashAllToS.update(block);\n+            block = ghashAllToS.digest();\n+            new GCTR(blockCipher, preCounterBlock).doFinal(block, 0,\n+                tagLenBytes, block, 0);\n+            dst.put(block, 0, tagLenBytes);\n+            restoreDst(dst);\n@@ -785,4 +1229,2 @@\n-        \/\/ check entire authentication tag for time-consistency\n-        int mismatch = 0;\n-        for (int i = 0; i < tagLenBytes; i++) {\n-            mismatch |= tag[i] ^ block[i];\n+            reInit = true;\n+            return (len + tagLenBytes);\n@@ -791,2 +1233,10 @@\n-        if (mismatch != 0) {\n-            throw new AEADBadTagException(\"Tag mismatch!\");\n+        \/\/ Handler method for encrypting blocks\n+        int cryptBlocks(ByteBuffer src, ByteBuffer dst) {\n+            int len;\n+            if (src.remaining() > TRIGGERLEN) {\n+                len = throttleData(gctrghash, src, dst);\n+            } else {\n+                len = gctrghash.update(src, dst);\n+            }\n+            processed += len;\n+            return len;\n@@ -794,2 +1244,0 @@\n-\n-        return len;\n@@ -798,10 +1246,12 @@\n-    \/\/ Note: In-place operations do not need an intermediary copy because\n-    \/\/ the GHASH check was performed before the decryption.\n-    int decryptFinal(ByteBuffer src, ByteBuffer dst)\n-        throws IllegalBlockSizeException, AEADBadTagException,\n-        ShortBufferException {\n-\n-        dst = overlapDetection(src, dst);\n-        \/\/ Length of the input\n-        ByteBuffer tag;\n-        ByteBuffer ct = src.duplicate();\n+    \/**\n+     * Decryption Engine object\n+     *\/\n+    class GCMDecrypt extends GCMEngine {\n+        \/\/ byte array of tag\n+        byte[] tag;\n+        \/\/ offset for byte[] operations\n+        int tagOfs = 0;\n+\n+        GCMDecrypt(SymmetricCipher blockCipher) {\n+            super(blockCipher);\n+        }\n@@ -809,3 +1259,7 @@\n-        ByteBuffer buffer = ((ibuffer == null || ibuffer.size() == 0) ? null :\n-            ByteBuffer.wrap(ibuffer.toByteArray()));\n-        int len;\n+        @Override\n+        public int getOutputSize(int inLen, boolean isFinal) {\n+            if (!isFinal) {\n+                return 0;\n+            }\n+            return Math.max(inLen + getBufferedLength() - tagLenBytes, 0);\n+        }\n@@ -813,7 +1267,20 @@\n-        if (ct.remaining() >= tagLenBytes) {\n-            tag = src.duplicate();\n-            tag.position(ct.limit() - tagLenBytes);\n-            ct.limit(ct.limit() - tagLenBytes);\n-            len = ct.remaining();\n-            if (buffer != null) {\n-                len += buffer.remaining();\n+        \/**\n+         * Find the tag in a given input buffer\n+         *\n+         * If tagOfs > 0, the tag is inside 'in' along with some encrypted data\n+         * If tagOfs = 0, 'in' contains only the tag\n+         * If tagOfs < 0, that tag is split between ibuffer and 'in'\n+         * If tagOfs = -tagLenBytes, the tag is in the ibuffer, 'in' is empty.\n+         *\/\n+        void findTag(byte[] in, int inOfs, int inLen) {\n+            tag = new byte[tagLenBytes];\n+            if (inLen >= tagLenBytes) {\n+                tagOfs = inLen - tagLenBytes;\n+                System.arraycopy(in, inOfs + tagOfs, tag, 0,\n+                    tagLenBytes);\n+            } else {\n+                \/\/ tagOfs will be negative\n+                byte[] buffer = ibuffer.toByteArray();\n+                tagOfs = mergeBlock(buffer,\n+                    buffer.length - (tagLenBytes - inLen), in, inOfs, inLen,\n+                    tag) - tagLenBytes;\n@@ -821,17 +1288,0 @@\n-        } else if (buffer != null && ct.remaining() < tagLenBytes) {\n-            \/\/ It's unlikely the tag will be between the buffer and data\n-            tag = ByteBuffer.allocate(tagLenBytes);\n-            int limit = buffer.remaining() - (tagLenBytes - ct.remaining());\n-            buffer.mark();\n-            buffer.position(limit);\n-            \/\/ Read from \"new\" limit to buffer's end\n-            tag.put(buffer);\n-            \/\/ reset buffer to data only\n-            buffer.reset();\n-            buffer.limit(limit);\n-            tag.put(ct);\n-            tag.flip();\n-            \/\/ Limit is how much of the ibuffer has been chopped off.\n-            len = buffer.remaining();\n-        } else {\n-            throw new AEADBadTagException(\"Input too short - need tag\");\n@@ -840,2 +1290,10 @@\n-        \/\/ 'len' contains the length in ibuffer and src\n-        checkDataLength(len);\n+        \/\/ Put the input data into the ibuffer\n+        @Override\n+        byte[] doUpdate(byte[] in, int inOff, int inLen) {\n+            try {\n+                doUpdate(in, inOff, inLen, null, 0);\n+            } catch (ShortBufferException e) {\n+                \/\/ update decryption has no output\n+            }\n+            return new byte[0];\n+        }\n@@ -843,2 +1301,14 @@\n-        if (len > dst.remaining()) {\n-            throw new ShortBufferException(\"Output buffer too small\");\n+        \/\/ Put the input data into the ibuffer\n+        @Override\n+        public int doUpdate(byte[] in, int inOfs, int inLen, byte[] out,\n+            int outOfs) throws ShortBufferException {\n+\n+            processAAD();\n+            if (inLen > 0) {\n+                \/\/ store internally until decryptFinal is called because\n+                \/\/ spec mentioned that only return recovered data after tag\n+                \/\/ is successfully verified\n+                initBuffer(inLen);\n+                ibuffer.write(in, inOfs, inLen);\n+            }\n+            return 0;\n@@ -847,4 +1317,0 @@\n-        processAAD();\n-        \/\/ Set the mark for a later reset. Either it will be zero, or the tag\n-        \/\/ buffer creation above will have consume some or all of it.\n-        ct.mark();\n@@ -852,11 +1318,4 @@\n-        \/\/ If there is data stored in the buffer\n-        if (buffer != null && buffer.remaining() > 0) {\n-            ghashAllToS.update(buffer, buffer.remaining());\n-            \/\/ Process the overage\n-            if (buffer.remaining() > 0) {\n-                \/\/ Fill out block between two buffers\n-                if (ct.remaining() > 0) {\n-                    int over = buffer.remaining();\n-                    byte[] block = new byte[AES_BLOCK_SIZE];\n-                    \/\/ Copy the remainder of the buffer into the extra block\n-                    buffer.get(block, 0, over);\n+        \/\/ Put the src data into the ibuffer\n+        @Override\n+        public int doUpdate(ByteBuffer src, ByteBuffer dst)\n+            throws ShortBufferException {\n@@ -864,11 +1323,8 @@\n-                    \/\/ Fill out block with what is in data\n-                    if (ct.remaining() > AES_BLOCK_SIZE - over) {\n-                        ct.get(block, over, AES_BLOCK_SIZE - over);\n-                        ghashAllToS.update(block, 0, AES_BLOCK_SIZE);\n-                    } else {\n-                        \/\/ If the remaining in buffer + data does not fill a\n-                        \/\/ block, complete the ghash operation\n-                        int l = ct.remaining();\n-                        ct.get(block, over, l);\n-                        ghashAllToS.doLastBlock(ByteBuffer.wrap(block), over + l);\n-                    }\n+            processAAD();\n+            if (src.remaining() > 0) {\n+                \/\/ If there is an array, use that to avoid the extra copy to\n+                \/\/ take the src data out of the bytebuffer.\n+                if (src.hasArray()) {\n+                    doUpdate(src.array(), src.arrayOffset() + src.position(),\n+                        src.remaining(), null, 0);\n+                    src.position(src.limit());\n@@ -876,3 +1332,9 @@\n-                    \/\/ data is empty, so complete the ghash op with the\n-                    \/\/ remaining buffer\n-                    ghashAllToS.doLastBlock(buffer, buffer.remaining());\n+                    byte[] b = new byte[src.remaining()];\n+                    src.get(b);\n+                    initBuffer(b.length);\n+                    try {\n+                        ibuffer.write(b);\n+                    } catch (IOException e) {\n+                        throw new ProviderException(\n+                            \"Unable to add remaining input to the buffer\", e);\n+                    }\n@@ -881,2 +1343,1 @@\n-            \/\/ Prepare buffer for decryption\n-            buffer.flip();\n+            return 0;\n@@ -885,5 +1346,16 @@\n-        if (ct.remaining() > 0) {\n-            ghashAllToS.doLastBlock(ct, ct.remaining());\n-        }\n-        \/\/ Prepare buffer for decryption if available\n-        ct.reset();\n+        \/**\n+         * Use any data from ibuffer and 'in' to first verify the auth tag. If\n+         * the tag is valid, decrypt the data.\n+         *\/\n+        @Override\n+        public int doFinal(byte[] in, int inOfs, int inLen, byte[] out,\n+            int outOfs) throws IllegalBlockSizeException, AEADBadTagException,\n+            ShortBufferException {\n+            GHASH save = null;\n+\n+            int len = inLen + getBufferedLength();\n+            try {\n+                ArrayUtil.nullAndBoundsCheck(out, outOfs, len - tagLenBytes);\n+            } catch (ArrayIndexOutOfBoundsException aiobe) {\n+                throw new ShortBufferException(\"Output buffer invalid\");\n+            }\n@@ -891,5 +1363,3 @@\n-        byte[] block = getLengthBlock(sizeOfAAD, len);\n-        ghashAllToS.update(block);\n-        block = ghashAllToS.digest();\n-        GCTR gctrForSToTag = new GCTR(embeddedCipher, this.preCounterBlock);\n-        gctrForSToTag.doFinal(block, 0, tagLenBytes, block, 0);\n+            if (len < tagLenBytes) {\n+                throw new AEADBadTagException(\"Input too short - need tag\");\n+            }\n@@ -897,5 +1367,3 @@\n-        \/\/ check entire authentication tag for time-consistency\n-        int mismatch = 0;\n-        for (int i = 0; i < tagLenBytes; i++) {\n-            mismatch |= tag.get() ^ block[i];\n-        }\n+            if (len - tagLenBytes > out.length - outOfs) {\n+                save = ghashAllToS.clone();\n+            }\n@@ -903,3 +1371,16 @@\n-        if (mismatch != 0) {\n-            throw new AEADBadTagException(\"Tag mismatch!\");\n-        }\n+            checkDataLength(len - tagLenBytes);\n+            processAAD();\n+\n+            findTag(in, inOfs, inLen);\n+            byte[] block = getLengthBlock(sizeOfAAD,\n+                decryptBlocks(ghashAllToS, in, inOfs, inLen, null, 0));\n+            ghashAllToS.update(block);\n+            block = ghashAllToS.digest();\n+            new GCTR(blockCipher, preCounterBlock).doFinal(block, 0,\n+                tagLenBytes, block, 0);\n+\n+            \/\/ check entire authentication tag for time-consistency\n+            int mismatch = 0;\n+            for (int i = 0; i < tagLenBytes; i++) {\n+                mismatch |= tag[i] ^ block[i];\n+            }\n@@ -907,7 +1388,3 @@\n-        \/\/ Decrypt the all the input data and put it into dst\n-        doLastBlock(buffer, ct, dst);\n-        restoreDst(dst);\n-        src.position(src.limit());\n-        \/\/ 'processed' from the gctr decryption operation, not ghash\n-        return processed;\n-    }\n+            if (mismatch != 0) {\n+                throw new AEADBadTagException(\"Tag mismatch!\");\n+            }\n@@ -915,4 +1392,5 @@\n-    \/\/ return tag length in bytes\n-    int getTagLen() {\n-        return this.tagLenBytes;\n-    }\n+            if (save != null) {\n+                ghashAllToS = save;\n+                throw new ShortBufferException(\"Output buffer too small, must\" +\n+                    \"be at least \" + (len - tagLenBytes) + \" bytes long\");\n+            }\n@@ -920,5 +1398,4 @@\n-    int getBufferedLength() {\n-        if (ibuffer == null) {\n-            return 0;\n-        } else {\n-            return ibuffer.size();\n+            out = overlapDetection(in, inOfs, out, outOfs);\n+            len = decryptBlocks(gctrPAndC, in, inOfs, inLen, out, outOfs);\n+            restoreOut(out, len);\n+            return len;\n@@ -926,1 +1403,0 @@\n-    }\n@@ -928,9 +1404,22 @@\n-    \/**\n-     * Check for overlap. If the src and dst buffers are using shared data and\n-     * if dst will overwrite src data before src can be processed.  If so, make\n-     * a copy to put the dst data in.\n-     *\/\n-    ByteBuffer overlapDetection(ByteBuffer src, ByteBuffer dst) {\n-        if (src.isDirect() && dst.isDirect()) {\n-            DirectBuffer dsrc = (DirectBuffer) src;\n-            DirectBuffer ddst = (DirectBuffer) dst;\n+        \/**\n+         * Use any data from ibuffer and 'src' to first verify the auth tag. If\n+         * the tag is valid, decrypt the data.\n+         *\/\n+        @Override\n+        public int doFinal(ByteBuffer src, ByteBuffer dst)\n+            throws IllegalBlockSizeException, AEADBadTagException,\n+            ShortBufferException {\n+            GHASH save = null;\n+\n+            ByteBuffer tag;\n+            ByteBuffer ct = src.duplicate();\n+            ByteBuffer buffer = null;\n+\n+            \/\/ The 'len' the total amount of ciphertext\n+            int len = ct.remaining() - tagLenBytes;\n+\n+            \/\/ Check if ibuffer has data\n+            if (getBufferedLength() != 0) {\n+                buffer = ByteBuffer.wrap(ibuffer.toByteArray());\n+                len += buffer.remaining();\n+            }\n@@ -938,3 +1427,1 @@\n-            \/\/ Get the current memory address for the given ByteBuffers\n-            long srcaddr = dsrc.address();\n-            long dstaddr = ddst.address();\n+            checkDataLength(len);\n@@ -942,5 +1429,5 @@\n-            \/\/ Find the lowest attachment that is the base memory address of the\n-            \/\/ shared memory for the src object\n-            while (dsrc.attachment() != null) {\n-                srcaddr = ((DirectBuffer) dsrc.attachment()).address();\n-                dsrc = (DirectBuffer) dsrc.attachment();\n+            \/\/ Save GHASH context to allow the tag to be checked even though\n+            \/\/ the dst buffer is too short.  Context will be restored so the\n+            \/\/ method can be called again with the proper sized dst buffer.\n+            if (len > dst.remaining()) {\n+                save = ghashAllToS.clone();\n@@ -949,5 +1436,21 @@\n-            \/\/ Find the lowest attachment that is the base memory address of the\n-            \/\/ shared memory for the dst object\n-            while (ddst.attachment() != null) {\n-                dstaddr = ((DirectBuffer) ddst.attachment()).address();\n-                ddst = (DirectBuffer) ddst.attachment();\n+            \/\/ Create buffer 'tag' that contains only the auth tag\n+            if (ct.remaining() >= tagLenBytes) {\n+                tag = src.duplicate();\n+                tag.position(ct.limit() - tagLenBytes);\n+                ct.limit(ct.limit() - tagLenBytes);\n+            } else if (buffer != null) {\n+                \/\/ It's unlikely the tag will be between the buffer and data\n+                tag = ByteBuffer.allocate(tagLenBytes);\n+                int limit = buffer.remaining() - (tagLenBytes - ct.remaining());\n+                buffer.mark();\n+                buffer.position(limit);\n+                \/\/ Read from \"new\" limit to buffer's end\n+                tag.put(buffer);\n+                \/\/ reset buffer to data only\n+                buffer.reset();\n+                \/\/ Set the limit to where the ciphertext ends\n+                buffer.limit(limit);\n+                tag.put(ct);\n+                tag.flip();\n+            } else {\n+                throw new AEADBadTagException(\"Input too short - need tag\");\n@@ -956,3 +1459,18 @@\n-            \/\/ If the base addresses are not the same, there is no overlap\n-            if (srcaddr != dstaddr) {\n-                return dst;\n+            \/\/ Set the mark for a later reset. Either it will be zero, or the\n+            \/\/ tag buffer creation above will have consume some or all of it.\n+            ct.mark();\n+\n+            processAAD();\n+            \/\/ Perform GHASH check on data\n+            doLastBlock(ghashAllToS, buffer, ct, null);\n+\n+            byte[] block = getLengthBlock(sizeOfAAD, len);\n+            ghashAllToS.update(block);\n+            block = ghashAllToS.digest();\n+            new GCTR(blockCipher, preCounterBlock).doFinal(block, 0,\n+                tagLenBytes, block, 0);\n+\n+            \/\/ check entire authentication tag for time-consistency\n+            int mismatch = 0;\n+            for (int i = 0; i < tagLenBytes; i++) {\n+                mismatch |= tag.get() ^ block[i];\n@@ -960,11 +1478,3 @@\n-            \/\/ At this point we know these objects share the same memory.\n-            \/\/ This checks the starting position of the src and dst address for\n-            \/\/ overlap.\n-            \/\/ It uses the base address minus the passed object's address to get\n-            \/\/ the offset from the base address, then add the position() from\n-            \/\/ the passed object.  That gives up the true offset from the base\n-            \/\/ address.  As long as the src side is >= the dst side, we are not\n-            \/\/ in overlap.\n-            if (((DirectBuffer) src).address() - srcaddr + src.position() >=\n-                ((DirectBuffer) dst).address() - dstaddr + dst.position()) {\n-                return dst;\n+\n+            if (mismatch != 0) {\n+                throw new AEADBadTagException(\"Tag mismatch!\");\n@@ -973,5 +1483,57 @@\n-        } else if (!src.isDirect() && !dst.isDirect()) {\n-            if (!src.isReadOnly()) {\n-                \/\/ If using the heap, check underlying byte[] address.\n-                if (src.array() != dst.array()) {\n-                    return dst;\n+            if (save != null) {\n+                ghashAllToS = save;\n+                throw new ShortBufferException(\"Output buffer too small, must\" +\n+                    \" be at least \" + len + \" bytes long\");\n+            }\n+\n+            \/\/ Prepare for decryption\n+            if (buffer != null) {\n+                buffer.flip();\n+            }\n+            ct.reset();\n+            processed = 0;\n+            \/\/ Check for overlap in the bytebuffers\n+            dst = overlapDetection(src, dst);\n+\n+            \/\/ Decrypt the all the input data and put it into dst\n+            doLastBlock(gctrPAndC, buffer, ct, dst);\n+            restoreDst(dst);\n+            src.position(src.limit());\n+            if (ibuffer != null) {\n+                ibuffer.reset();\n+            }\n+            return processed;\n+        }\n+\n+        \/**\n+         * This method organizes the data from the ibuffer and 'in' to\n+         * blocksize operations for GHASH and GCTR decryption operations.\n+         * When this method is used, all the data is either in the ibuffer\n+         * or in 'in'.\n+         *\/\n+        int decryptBlocks(GCM op, byte[] in, int inOfs, int inLen,\n+            byte[] out, int outOfs) {\n+            byte[] buffer;\n+            byte[] block;\n+            int len = 0;\n+\n+            \/\/ Calculate the encrypted data length inside the ibuffer\n+            \/\/ considering the tag location\n+            int bLen = getBufferedLength();\n+\n+            \/\/ Change the inLen based of the tag location.\n+            if (tagOfs < 0) {\n+                inLen = 0;\n+                bLen += tagOfs;\n+            } else {\n+                inLen -= tagLenBytes;\n+            }\n+\n+            if (bLen > 0) {\n+                buffer = ibuffer.toByteArray();\n+\n+                if (bLen >= blockSize) {\n+                    len += op.update(buffer, 0, bLen, out, outOfs);\n+                    outOfs += len; \/\/ noop for ghash\n+                    \/\/ Use len as it becomes the ibuffer offset, if\n+                    \/\/ needed, in the next op\n@@ -980,5 +1542,21 @@\n-                \/\/ Position plus arrayOffset() will give us the true offset from\n-                \/\/ the underlying byte[] address.\n-                if (src.position() + src.arrayOffset() >=\n-                    dst.position() + dst.arrayOffset()) {\n-                    return dst;\n+                \/\/ merge the remaining ibuffer with the 'in'\n+                int bufRemainder = bLen - len;\n+                if (bufRemainder > 0) {\n+                    block = new byte[blockSize];\n+                    int inUsed = mergeBlock(buffer, len, bufRemainder, in,\n+                        inOfs, inLen, block);\n+                    \/\/ update the input parameters for what was taken out of 'in'\n+                    inOfs += inUsed;\n+                    inLen -= inUsed;\n+                    \/\/ If is more than block between the merged data and 'in',\n+                    \/\/ update(), otherwise setup for final\n+                    if (inLen > 0) {\n+                        int resultLen = op.update(block, 0, blockSize,\n+                            out, outOfs);\n+                        outOfs += resultLen; \/\/ noop for ghash\n+                        len += resultLen;\n+                    } else {\n+                        in = block;\n+                        inOfs = 0;\n+                        inLen = inUsed + bufRemainder;\n+                    }\n@@ -987,3 +1565,10 @@\n-        } else {\n-            \/\/ buffer types aren't the same\n-            return dst;\n+\n+            \/\/ Finish off the operation\n+            if (inLen > TRIGGERLEN) {\n+                int l = throttleData(op, in, inOfs, inLen, out, outOfs);\n+                inOfs += l;\n+                inLen -= l;\n+                outOfs += l; \/\/ noop for ghash\n+                len += l;\n+            }\n+            return len + op.doFinal(in, inOfs, inLen, out, outOfs);\n@@ -991,0 +1576,1 @@\n+    }\n@@ -992,10 +1578,22 @@\n-        \/\/ Create a copy\n-        ByteBuffer tmp = dst.duplicate();\n-        \/\/ We can use a heap buffer for internal use, save on alloc cost\n-        ByteBuffer bb = ByteBuffer.allocate(dst.remaining());\n-        tmp.limit(dst.limit());\n-        tmp.position(dst.position());\n-        bb.put(tmp);\n-        bb.flip();\n-        originalDst = dst;\n-        return bb;\n+    public static final class AESGCM extends GaloisCounterMode {\n+        public AESGCM() {\n+            super(-1, new AESCrypt());\n+        }\n+    }\n+\n+    public static final class AES128 extends GaloisCounterMode {\n+        public AES128() {\n+            super(16, new AESCrypt());\n+        }\n+    }\n+\n+    public static final class AES192 extends GaloisCounterMode {\n+        public AES192() {\n+            super(24, new AESCrypt());\n+        }\n+    }\n+\n+    public static final class AES256 extends GaloisCounterMode {\n+        public AES256() {\n+            super(32, new AESCrypt());\n+        }\n@@ -1005,2 +1603,2 @@\n-     * If originalDst exists, dst is an internal dst buffer, then copy the data\n-     * into the original dst buffer\n+     * This class is for encryption when both GCTR and GHASH\n+     * can operation in parallel.\n@@ -1008,3 +1606,7 @@\n-    void restoreDst(ByteBuffer dst) {\n-        if (originalDst == null) {\n-            return;\n+    static final class GCTRGHASH implements GCM {\n+        GCTR gctr;\n+        GHASH ghash;\n+\n+        GCTRGHASH(GCTR c, GHASH g) {\n+            gctr = c;\n+            ghash = g;\n@@ -1013,3 +1615,41 @@\n-        dst.flip();\n-        originalDst.put(dst);\n-        originalDst = null;\n+        @Override\n+        public int update(byte[] in, int inOfs, int inLen, byte[] out,\n+            int outOfs) {\n+            int len = gctr.update(in, inOfs, inLen, out, outOfs);\n+            ghash.update(out, outOfs, len);\n+            return len;\n+        }\n+\n+        @Override\n+        public int update(byte[] in, int inOfs, int inLen, ByteBuffer dst) {\n+            dst.mark();\n+            int len = gctr.update(in, inOfs, inLen, dst);\n+            dst.reset();\n+            ghash.update(dst, len);\n+            return len;\n+        }\n+\n+        @Override\n+        public int update(ByteBuffer src, ByteBuffer dst) {\n+            dst.mark();\n+            int len = gctr.update(src, dst);\n+            dst.reset();\n+            ghash.update(dst, len);\n+            return len;\n+        }\n+\n+        @Override\n+        public int doFinal(byte[] in, int inOfs, int inLen, byte[] out, int outOfs) {\n+            int len = gctr.doFinal(in, inOfs, inLen, out, outOfs);\n+            ghash.doFinal(out, outOfs, len);\n+            return len;\n+        }\n+\n+        @Override\n+        public int doFinal(ByteBuffer src, ByteBuffer dst) {\n+            dst.mark();\n+            int l = gctr.doFinal(src, dst);\n+            dst.reset();\n+            ghash.doFinal(dst, l);\n+            return l;\n+        }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":1400,"deletions":760,"binary":false,"changes":2160,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-            \"|GCM|CFB72|CFB80|CFB88|CFB96|CFB104|CFB112|CFB120|CFB128\" +\n+            \"|CFB72|CFB80|CFB88|CFB96|CFB104|CFB112|CFB120|CFB128\" +\n@@ -217,3 +217,0 @@\n-        psA(\"Cipher\", \"AES_128\/GCM\/NoPadding\",\n-                \"com.sun.crypto.provider.AESCipher$AES128_GCM_NoPadding\",\n-                attrs);\n@@ -242,3 +239,0 @@\n-        psA(\"Cipher\", \"AES_192\/GCM\/NoPadding\",\n-                \"com.sun.crypto.provider.AESCipher$AES192_GCM_NoPadding\",\n-                attrs);\n@@ -267,3 +261,0 @@\n-        psA(\"Cipher\", \"AES_256\/GCM\/NoPadding\",\n-                \"com.sun.crypto.provider.AESCipher$AES256_GCM_NoPadding\",\n-                attrs);\n@@ -280,0 +271,17 @@\n+        attrs.clear();\n+        attrs.put(\"SupportedModes\", \"GCM\");\n+        attrs.put(\"SupportedKeyFormats\", \"RAW\");\n+\n+        ps(\"Cipher\", \"AES\/GCM\/NoPadding\",\n+                \"com.sun.crypto.provider.GaloisCounterMode$AESGCM\", null,\n+                attrs);\n+        psA(\"Cipher\", \"AES_128\/GCM\/NoPadding\",\n+                \"com.sun.crypto.provider.GaloisCounterMode$AES128\",\n+                attrs);\n+        psA(\"Cipher\", \"AES_192\/GCM\/NoPadding\",\n+                \"com.sun.crypto.provider.GaloisCounterMode$AES192\",\n+                attrs);\n+        psA(\"Cipher\", \"AES_256\/GCM\/NoPadding\",\n+                \"com.sun.crypto.provider.GaloisCounterMode$AES256\",\n+                attrs);\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.util.StaticProperty;\n+import sun.security.action.GetBooleanAction;\n+\n+import java.lang.reflect.InvocationTargetException;\n@@ -35,0 +40,2 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BinaryOperator;\n@@ -36,0 +43,1 @@\n+import java.util.function.Predicate;\n@@ -37,2 +45,3 @@\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.util.StaticProperty;\n+import static java.io.ObjectInputFilter.Status.*;\n+import static java.lang.System.Logger.Level.TRACE;\n+import static java.lang.System.Logger.Level.DEBUG;\n@@ -51,2 +60,81 @@\n- * If set on an {@link ObjectInputStream}, the {@link #checkInput checkInput(FilterInfo)}\n- * method is called to validate classes, the length of each array,\n+ * <p>To protect against deserialization vulnerabilities, application developers\n+ * need a clear description of the objects that can be deserialized\n+ * by each component or library. For each context and use case, developers should\n+ * construct and apply an appropriate filter.\n+ *\n+ * <h2>Deserialization Filtering Factory and Filters<\/h2>\n+ * The parts of deserialization filtering are the filters, composite filters, and filter factory.\n+ * Each filter performs checks on classes and resource limits to determine the status as\n+ * rejected, allowed, or undecided.\n+ * Filters can be composed of other filters and merge or combine their results.\n+ * The filter factory is responsible for establishing and updating the filter\n+ * for each {@link ObjectInputStream}.\n+ *\n+ * <p>For simple cases, a static JVM-wide filter can be set for the entire application,\n+ * without setting a filter factory.\n+ * The JVM-wide filter can be set either with a system property on the command line or by\n+ * calling {@linkplain Config#setSerialFilter(ObjectInputFilter) Config.setSerialFilter}.\n+ * No custom filter factory needs to be specified, defaulting to the builtin filter factory.\n+ * The builtin filter factory provides the {@linkplain Config#getSerialFilter static JVM-wide filter}\n+ * for each {@linkplain ObjectInputStream ObjectInputStream}.\n+ *\n+ * <p>For example, a filter that allows example classes, allows classes in the\n+ * {@code java.base} module, and rejects all other classes can be set:\n+ *\n+ * <pre>{@code As a command line property:\n+ *     % java -Djdk.serialFilter=\"example.*;java.base\/*;!*\" ...}<\/pre>\n+ *\n+ * <pre>{@code Or programmatically:\n+ *     var filter = ObjectInputFilter.Config.createFilter(\"example.*;java.base\/*;!*\")\n+ *     ObjectInputFilter.Config.setSerialFilter(filter);}<\/pre>\n+ *\n+ * <p>In an application with multiple execution contexts, the application can provide a\n+ * {@linkplain Config#setSerialFilterFactory(BinaryOperator) filter factory} to\n+ * protect individual contexts by providing a custom filter for each. When the stream\n+ * is constructed, the filter factory is called to identify the execution context from the available\n+ * information, including the current thread-local state, hierarchy of callers, library, module,\n+ * and class loader. At that point, the filter factory policy for creating or selecting filters\n+ * can choose a specific filter or composition of filters based on the context.\n+ * The JVM-wide deserialization filter factory ensures that a context-specific deserialization\n+ * filter can be set on every {@link ObjectInputStream} and every object read from the\n+ * stream can be checked.\n+ *\n+ * <h2>Invoking the Filter Factory<\/h2>\n+ * <p>The JVM-wide filter factory is a function invoked when each {@link ObjectInputStream} is\n+ * {@linkplain ObjectInputStream#ObjectInputStream() constructed} and when the\n+ * {@linkplain ObjectInputStream#setObjectInputFilter(ObjectInputFilter) stream-specific filter is set}.\n+ * The parameters are the current filter and a requested filter and it\n+ * returns the filter to be used for the stream. When invoked from the\n+ * {@linkplain ObjectInputStream#ObjectInputStream(InputStream) ObjectInputStream constructors},\n+ * the first parameter is {@code null} and the second parameter is the\n+ * {@linkplain ObjectInputFilter.Config#getSerialFilter() static JVM-wide filter}.\n+ * When invoked from {@link ObjectInputStream#setObjectInputFilter ObjectInputStream.setObjectInputFilter},\n+ * the first parameter is the filter currently set on the stream (which was set in the constructor),\n+ * and the second parameter is the filter given to {@code ObjectInputStream.setObjectInputFilter}.\n+ * The current and new filter may each be {@code null} and the factory may return {@code null}.\n+ * Note that the filter factory implementation can also use any contextual information\n+ * at its disposal, for example, extracted from the application thread context, or its call stack,\n+ * to compose and combine a new filter. It is not restricted to only use its two parameters.\n+ *\n+ * <p>The active deserialization filter factory is either:\n+ * <ul>\n+ * <li>The application specific filter factory set via {@link Config#setSerialFilterFactory(BinaryOperator)}\n+ *     or the system property {@code jdk.serialFilterFactory} or\n+ *     the security property {@code jdk.serialFilterFactory}.\n+ * <li>Otherwise, a builtin deserialization filter factory\n+ *     provides the {@linkplain Config#getSerialFilter static JVM-wide filter} when invoked from the\n+ *     {@linkplain ObjectInputStream#ObjectInputStream(InputStream) ObjectInputStream constructors}\n+ *     and replaces the static filter when invoked from\n+ *     {@link ObjectInputStream#setObjectInputFilter(ObjectInputFilter)}.\n+ *     See {@linkplain Config#getSerialFilterFactory() getSerialFilterFactory}.\n+ * <\/ul>\n+ *\n+ * <h2>Filters<\/h2>\n+ * Filters can be created from a {@linkplain Config#createFilter(String) pattern string},\n+ * or based on a {@linkplain Predicate predicate of a class} to\n+ * {@linkplain #allowFilter(Predicate, Status) allow} or\n+ * {@linkplain #rejectFilter(Predicate, Status) reject} classes.\n+ *\n+ * <p>The filter's {@link #checkInput checkInput(FilterInfo)} method is invoked\n+ * zero or more times while {@linkplain ObjectInputStream#readObject() reading objects}.\n+ * The method is called to validate classes, the length of each array,\n@@ -55,0 +143,7 @@\n+ *\n+ * <p>Composite filters combine or check the results of other filters.\n+ * The {@link #merge(ObjectInputFilter, ObjectInputFilter) merge(filter, anotherFilter)}\n+ * filter combines the status value of two filters.\n+ * The {@link #rejectUndecidedClass(ObjectInputFilter) rejectUndecidedClass(filter)}\n+ * checks the result of a filter for classes when the status is {@code UNDECIDED}.\n+ * In many cases any class not {@code ALLOWED} by the filter should be {@code REJECTED}.\n@@ -56,9 +151,3 @@\n- * A filter can be set via {@link ObjectInputStream#setObjectInputFilter setObjectInputFilter}\n- * for an individual ObjectInputStream.\n- * A filter can be set via {@link Config#setSerialFilter(ObjectInputFilter) Config.setSerialFilter}\n- * to affect every {@code ObjectInputStream} that does not otherwise set a filter.\n- * <p>\n- * A filter determines whether the arguments are {@link Status#ALLOWED ALLOWED}\n- * or {@link Status#REJECTED REJECTED} and should return the appropriate status.\n- * If the filter cannot determine the status it should return\n- * {@link Status#UNDECIDED UNDECIDED}.\n+ * A deserialization filter determines whether the arguments are allowed or rejected and\n+ * should return the appropriate status: {@link Status#ALLOWED ALLOWED} or {@link Status#REJECTED REJECTED}.\n+ * If the filter cannot determine the status it should return {@link Status#UNDECIDED UNDECIDED}.\n@@ -66,1 +155,1 @@\n- * A filter designed for a particular use may be passed a class that is outside\n+ * A filter designed for a particular use may be passed a class outside\n@@ -68,1 +157,1 @@\n- * then it can reject a candidate class that matches and report UNDECIDED for others.\n+ * then it can reject a candidate class that matches and report {@code UNDECIDED} for others.\n@@ -72,1 +161,1 @@\n- * This allows a filter to specific about the choice it is reporting and\n+ * This allows a filter to be specific about the choice it is reporting and\n@@ -75,3 +164,30 @@\n- * <p>\n- * Typically, a custom filter should check if a system-wide filter\n- * is configured and defer to it if so. For example,\n+ * <h2>Filter Model Examples<\/h2>\n+ * For simple applications, a single predefined filter listing allowed or rejected\n+ * classes may be sufficient to manage the risk of deserializing unexpected classes.\n+ * <p>For an application composed from multiple modules or libraries, the structure\n+ * of the application can be used to identify the classes to be allowed or rejected\n+ * by each {@link ObjectInputStream} in each context of the application.\n+ * The deserialization filter factory is invoked when each stream is constructed and\n+ * can examine the thread or program to determine a context-specific filter to be applied.\n+ * Some possible examples:\n+ * <ul>\n+ *     <li>Thread-local state can hold the filter to be applied or composed\n+ *         with a stream-specific filter.\n+ *         Filters could be pushed and popped from a virtual stack of filters\n+ *         maintained by the application or libraries.\n+ *     <li>The filter factory can identify the caller of the deserialization method\n+ *         and use module or library context to select a filter or compose an appropriate\n+ *         context-specific filter.\n+ *         A mechanism could identify a callee with restricted or unrestricted\n+ *         access to serialized classes and choose a filter accordingly.\n+ * <\/ul>\n+ *\n+ * <h2>Example to filter every deserialization in a thread<\/h2>\n+ *\n+ * This class shows how an application provided filter factory can combine filters\n+ * to check every deserialization operation that takes place in a thread.\n+ * It defines a thread-local variable to hold the thread-specific filter, and constructs a filter factory\n+ * that composes that filter with the static JVM-wide filter and the stream-specific filter.\n+ * The {@code doWithSerialFilter} method does the setup of the thread-specific filter\n+ * and invokes the application provided {@link Runnable Runnable}.\n+ *\n@@ -79,7 +195,36 @@\n- * ObjectInputFilter.Status checkInput(FilterInfo info) {\n- *     ObjectInputFilter serialFilter = ObjectInputFilter.Config.getSerialFilter();\n- *     if (serialFilter != null) {\n- *         ObjectInputFilter.Status status = serialFilter.checkInput(info);\n- *         if (status != ObjectInputFilter.Status.UNDECIDED) {\n- *             \/\/ The system-wide filter overrides this filter\n- *             return status;\n+ * public static final class FilterInThread implements BinaryOperator<ObjectInputFilter> {\n+ *\n+ *     private final ThreadLocal<ObjectInputFilter> filterThreadLocal = new ThreadLocal<>();\n+ *\n+ *     \/\/ Construct a FilterInThread deserialization filter factory.\n+ *     public FilterInThread() {}\n+ *\n+ *     \/\/ Returns a composite filter of the static JVM-wide filter, a thread-specific filter,\n+ *     \/\/ and the stream-specific filter.\n+ *     public ObjectInputFilter apply(ObjectInputFilter curr, ObjectInputFilter next) {\n+ *         if (curr == null) {\n+ *             \/\/ Called from the OIS constructor or perhaps OIS.setObjectInputFilter with no current filter\n+ *             var filter = filterThreadLocal.get();\n+ *             if (filter != null) {\n+ *                 \/\/ Prepend a filter to reject all UNDECIDED results\n+ *                 filter = ObjectInputFilter.rejectUndecidedClass(filter);\n+ *             }\n+ *             if (next != null) {\n+ *                 \/\/ Prepend the next filter to the thread filter, if any\n+ *                 \/\/ Initially this is the static JVM-wide filter passed from the OIS constructor\n+ *                 \/\/ Append the filter to reject all UNDECIDED results\n+ *                 filter = ObjectInputFilter.merge(next, filter);\n+ *                 filter = ObjectInputFilter.rejectUndecidedClass(filter);\n+ *             }\n+ *             return filter;\n+ *         } else {\n+ *             \/\/ Called from OIS.setObjectInputFilter with a current filter and a stream-specific filter.\n+ *             \/\/ The curr filter already incorporates the thread filter and static JVM-wide filter\n+ *             \/\/ and rejection of undecided classes\n+ *             \/\/ If there is a stream-specific filter prepend it and a filter to recheck for undecided\n+ *             if (next != null) {\n+ *                 next = ObjectInputFilter.merge(next, curr);\n+ *                 next = ObjectInputFilter.rejectUndecidedClass(next);\n+ *                 return next;\n+ *             }\n+ *             return curr;\n@@ -88,3 +233,10 @@\n- *     if (info.serialClass() != null &&\n- *         Remote.class.isAssignableFrom(info.serialClass())) {\n- *         return Status.REJECTED;      \/\/ Do not allow Remote objects\n+ *\n+ *     \/\/ Applies the filter to the thread and invokes the runnable.\n+ *     public void doWithSerialFilter(ObjectInputFilter filter, Runnable runnable) {\n+ *         var prevFilter = filterThreadLocal.get();\n+ *         try {\n+ *             filterThreadLocal.set(filter);\n+ *             runnable.run();\n+ *         } finally {\n+ *             filterThreadLocal.set(prevFilter);\n+ *         }\n@@ -92,1 +244,0 @@\n- *     return Status.UNDECIDED;\n@@ -94,1 +245,17 @@\n- *}<\/pre>\n+ * }<\/pre>\n+ * <h3>Using the Filter Factory<\/h3>\n+ * To use {@code FilterInThread} utility create an instance and configure it as the\n+ * JVM-wide filter factory.  The {@code doWithSerialFilter} method is invoked with a\n+ * filter allowing the example application and core classes:\n+ * <pre>{@code\n+ *        \/\/ Create a FilterInThread filter factory and set\n+ *        var filterInThread = new FilterInThread();\n+ *        ObjectInputFilter.Config.setSerialFilterFactory(filterInThread);\n+ *\n+ *        \/\/ Create a filter to allow example.* classes and reject all others\n+ *        var filter = ObjectInputFilter.Config.createFilter(\"example.*;java.base\/*;!*\");\n+ *        filterInThread.doWithSerialFilter(filter, () -> {\n+ *              byte[] bytes = ...;\n+ *              var o = deserializeObject(bytes);\n+ *        });\n+ * }<\/pre>\n@@ -113,0 +280,8 @@\n+     * <p>If {@code filterInfo.serialClass()} is {@code non-null}, there is a class to be checked.\n+     * If {@code serialClass()} is {@code null}, there is no class and the info contains\n+     * only metrics related to the depth of the graph being deserialized, the number of\n+     * references, and the size of the stream read.\n+     *\n+     * @apiNote Each filter implementing {@code checkInput} should return one of the values of {@link Status}.\n+     * Returning {@code null} may result in a {@link NullPointerException} or other unpredictable behavior.\n+     *\n@@ -121,0 +296,134 @@\n+    \/**\n+     * Returns a filter that returns {@code Status.ALLOWED} if the predicate\n+     * on the class is {@code true}.\n+     * The filter returns {@code ALLOWED} or the {@code otherStatus} based on the predicate\n+     * of the {@code non-null} class and {@code UNDECIDED} if the class is {@code null}.\n+     *\n+     * <p>When the filter's {@link ObjectInputFilter#checkInput checkInput(info)} method is invoked,\n+     * the predicate is applied to the {@link FilterInfo#serialClass() info.serialClass()},\n+     * the return Status is:\n+     * <ul>\n+     *     <li>{@link Status#UNDECIDED UNDECIDED}, if the {@code serialClass} is {@code null},<\/li>\n+     *     <li>{@link Status#ALLOWED ALLOWED}, if the predicate on the class returns {@code true},<\/li>\n+     *     <li>Otherwise, return {@code otherStatus}.<\/li>\n+     * <\/ul>\n+     * <p>\n+     * Example, to create a filter that will allow any class loaded from the platform classloader.\n+     * <pre><code>\n+     *     ObjectInputFilter f = allowFilter(cl -> cl.getClassLoader() == ClassLoader.getPlatformClassLoader()\n+     *                                          || cl.getClassLoader() == null, Status.UNDECIDED);\n+     * <\/code><\/pre>\n+     *\n+     * @param predicate a predicate to test a non-null Class\n+     * @param otherStatus a Status to use if the predicate is {@code false}\n+     * @return a filter that returns {@code ALLOWED} if the predicate\n+     *          on the class is {@code true}\n+     * @since 17\n+     *\/\n+    static ObjectInputFilter allowFilter(Predicate<Class<?>> predicate, Status otherStatus) {\n+        Objects.requireNonNull(predicate, \"predicate\");\n+        Objects.requireNonNull(otherStatus, \"otherStatus\");\n+        return new Config.PredicateFilter(predicate, ALLOWED, otherStatus);\n+    }\n+\n+    \/**\n+     * Returns a filter that returns {@code Status.REJECTED} if the predicate\n+     * on the class is {@code true}.\n+     * The filter returns {@code REJECTED} or the {@code otherStatus} based on the predicate\n+     * of the {@code non-null} class and {@code UNDECIDED} if the class is {@code null}.\n+     *\n+     * When the filter's {@link ObjectInputFilter#checkInput checkInput(info)} method is invoked,\n+     * the predicate is applied to the {@link FilterInfo#serialClass() serialClass()},\n+     * the return Status is:\n+     * <ul>\n+     *     <li>{@link Status#UNDECIDED UNDECIDED}, if the {@code serialClass} is {@code null},<\/li>\n+     *     <li>{@link Status#REJECTED REJECTED}, if the predicate on the class returns {@code true},<\/li>\n+     *     <li>Otherwise, return {@code otherStatus}.<\/li>\n+     * <\/ul>\n+     * <p>\n+     * Example, to create a filter that will reject any class loaded from the application classloader.\n+     * <pre><code>\n+     *     ObjectInputFilter f = rejectFilter(cl ->\n+     *          cl.getClassLoader() == ClassLoader.ClassLoader.getSystemClassLoader(), Status.UNDECIDED);\n+     * <\/code><\/pre>\n+     *\n+     * @param predicate a predicate to test a non-null Class\n+     * @param otherStatus a Status to use if the predicate is {@code false}\n+     * @return returns a filter that returns {@code REJECTED} if the predicate\n+     *          on the class is {@code true}\n+     * @since 17\n+     *\/\n+    static ObjectInputFilter rejectFilter(Predicate<Class<?>> predicate, Status otherStatus) {\n+        Objects.requireNonNull(predicate, \"predicate\");\n+        Objects.requireNonNull(otherStatus, \"otherStatus\");\n+        return new Config.PredicateFilter(predicate, REJECTED, otherStatus);\n+    }\n+\n+    \/**\n+     * Returns a filter that merges the status of a filter and another filter.\n+     * If {@code another} filter is {@code null}, the {@code filter} is returned.\n+     * Otherwise, a {@code filter} is returned to merge the pair of {@code non-null} filters.\n+     *\n+     * The filter returned implements the {@link ObjectInputFilter#checkInput(FilterInfo)} method\n+     * as follows:\n+     * <ul>\n+     *     <li>Invoke {@code filter} on the {@code FilterInfo} to get its {@code status};\n+     *     <li>Return {@code REJECTED} if the {@code status} is {@code REJECTED};\n+     *     <li>Invoke {@code anotherFilter} to get the {@code otherStatus};\n+     *     <li>Return {@code REJECTED} if the {@code otherStatus} is {@code REJECTED};\n+     *     <li>Return {@code ALLOWED}, if either {@code status} or {@code otherStatus}\n+     *          is {@code ALLOWED}, <\/li>\n+     *     <li>Otherwise, return {@code UNDECIDED}<\/li>\n+     * <\/ul>\n+     *\n+     * @param filter a filter\n+     * @param anotherFilter a filter to be merged with the filter, may be {@code null}\n+     * @return an {@link ObjectInputFilter} that merges the status of the filter and another filter\n+     * @since 17\n+     *\/\n+    static ObjectInputFilter merge(ObjectInputFilter filter, ObjectInputFilter anotherFilter) {\n+        Objects.requireNonNull(filter, \"filter\");\n+        return (anotherFilter == null) ? filter : new Config.MergeFilter(filter, anotherFilter);\n+    }\n+\n+    \/**\n+     * Returns a filter that invokes a given filter and maps {@code UNDECIDED} to {@code REJECTED}\n+     * for classes, with some special cases, and otherwise returns the status.\n+     * If the class is not a primitive class and not an array, the status returned is {@code REJECTED}.\n+     * If the class is a primitive class or an array class additional checks are performed;\n+     * see the list below for details.\n+     *\n+     * <p>Object deserialization accepts a class if the filter returns {@code UNDECIDED}.\n+     * Adding a filter to reject undecided results for classes that have not been\n+     * either allowed or rejected can prevent classes from slipping through the filter.\n+     *\n+     * @implSpec\n+     * The filter returned implements the {@link ObjectInputFilter#checkInput(FilterInfo)} method\n+     * as follows:\n+     * <ul>\n+     *     <li>Invoke the filter on the {@code FilterInfo} to get its {@code status};\n+     *     <li>Return the {@code status} if the status is {@code REJECTED} or {@code ALLOWED};\n+     *     <li>Return {@code UNDECIDED} if the {@code filterInfo.getSerialClass() serialClass}\n+     *          is {@code null};\n+     *     <li>Return {@code REJECTED} if the class is not an {@linkplain Class#isArray() array};\n+     *     <li>Determine the base component type if the {@code serialClass} is\n+     *          an {@linkplain Class#isArray() array};\n+     *     <li>Return {@code UNDECIDED} if the base component type is\n+     *          a {@linkplain Class#isPrimitive() primitive class};\n+     *     <li>Invoke the filter on the {@code base component type} to get its\n+     *          {@code component status};<\/li>\n+     *     <li>Return {@code ALLOWED} if the component status is {@code ALLOWED};\n+     *     <li>Otherwise, return {@code REJECTED}.<\/li>\n+     * <\/ul>\n+     *\n+     * @param filter a filter\n+     * @return an {@link ObjectInputFilter} that maps an {@link Status#UNDECIDED}\n+     *      status to {@link Status#REJECTED} for classes, otherwise returns the\n+     *      filter status\n+     * @since 17\n+     *\/\n+    static ObjectInputFilter rejectUndecidedClass(ObjectInputFilter filter) {\n+        Objects.requireNonNull(filter, \"filter\");\n+        return new Config.RejectUndecidedFilter(filter);\n+    }\n+\n@@ -200,10 +509,11 @@\n-     * A utility class to set and get the system-wide filter or create a filter\n-     * from a pattern string. If a system-wide filter is set, it will be\n-     * used for each {@link ObjectInputStream} that does not set its own filter.\n-     * <p>\n-     * When setting the filter, it should be stateless and idempotent,\n-     * reporting the same result when passed the same arguments.\n-     * <p>\n-     * The filter is configured during the initialization of the {@code ObjectInputFilter.Config}\n-     * class. For example, by calling {@link #getSerialFilter() Config.getSerialFilter}.\n-     * If the Java virtual machine is started with the system property\n+     * A utility class to set and get the JVM-wide deserialization filter factory,\n+     * the static JVM-wide filter, or to create a filter from a pattern string.\n+     * The static filter factory and the static filter apply to the whole Java runtime,\n+     * or \"JVM-wide\", there is only one of each. For a complete description of\n+     * the function and use refer to {@link ObjectInputFilter}.\n+     *\n+     * <p>The JVM-wide deserialization filter factory and the static JVM-wide filter\n+     * can be configured from system properties during the initialization of the\n+     * {@code ObjectInputFilter.Config} class.\n+     *\n+     * <p>If the Java virtual machine is started with the system property\n@@ -217,1 +527,1 @@\n-     * The syntax for each property is the same as for the\n+     * The syntax for the property value is the same as for the\n@@ -220,0 +530,31 @@\n+     * <p> If only `jdk.serialFilter` is set and not `jdk.serialFilterFactory` the builtin\n+     * filter factory, compatible with previous versions, is set and can not be replaced,\n+     * see below to override the builtin filter factory.\n+     * <p>\n+     * If the Java virtual machine is started with the system property\n+     * {@systemProperty jdk.serialFilterFactory} or the {@link java.security.Security} property\n+     * of the same name, its value names the class to configure the JVM-wide deserialization\n+     * filter factory or the special value `OVERRIDE`.\n+     * If the system property is not defined, and the {@link java.security.Security} property\n+     * {@code jdk.serialFilterFactory} is defined then it is used to configure the filter factory.\n+     *\n+     * If the value is `OVERRIDE`, the filter factory can be set by the application before\n+     * the first deserialization using {@link Config#setSerialFilterFactory(BinaryOperator)};\n+     * If it remains unset, the filter factory is a builtin filter factory compatible\n+     * with previous versions.\n+     *\n+     * <p>If not `OVERRIDE`, the class must be public, must have a public zero-argument constructor, implement the\n+     * {@link BinaryOperator {@literal BinaryOperator<ObjectInputFilter>}} interface, provide its implementation and\n+     * be accessible via the {@linkplain ClassLoader#getSystemClassLoader() application class loader}.\n+     * If the filter factory constructor is not invoked successfully, an {@link ExceptionInInitializerError}\n+     * is thrown and subsequent use of the filter factory for deserialization fails with\n+     * {@link IllegalStateException}.\n+     * The filter factory configured using the system or security property during initialization\n+     * can NOT be replaced with {@link #setSerialFilterFactory(BinaryOperator) Config.setSerialFilterFactory}.\n+     * This ensures that a filter factory set on the command line is not overridden accidentally\n+     * or intentionally by the application.\n+     *\n+     * <p>Setting the {@code jdk.serialFilterFactory} with {@link System#setProperty(String, String)\n+     * System.setProperty} <em>does not set the filter factory<\/em>.\n+     * The syntax for the system property value and security property value is the\n+     * fully qualified class name of the deserialization filter factory.\n@@ -224,2 +565,4 @@\n-        \/* No instances. *\/\n-        private Config() {}\n+        \/**\n+         * Lock object for filter and filter factory.\n+         *\/\n+        private final static Object serialFilterLock = new Object();\n@@ -228,1 +571,2 @@\n-         * Lock object for system-wide filter.\n+         * The property name for the filter.\n+         * Used as a system property and a java.security.Security property.\n@@ -230,1 +574,1 @@\n-        private static final Object serialFilterLock = new Object();\n+        private static final String SERIAL_FILTER_PROPNAME = \"jdk.serialFilter\";\n@@ -233,1 +577,2 @@\n-         * Debug: Logger\n+         * The property name for the filter factory.\n+         * Used as a system property and a java.security.Security property.\n@@ -235,1 +580,1 @@\n-        private static final System.Logger configLog;\n+        private static final String SERIAL_FILTER_FACTORY_PROPNAME = \"jdk.serialFilterFactory\";\n@@ -238,1 +583,1 @@\n-         * Logger for debugging.\n+         * The property name to enable tracing of filters.\n@@ -240,5 +585,1 @@\n-        static void filterLog(System.Logger.Level level, String msg, Object... args) {\n-            if (configLog != null) {\n-                configLog.log(level, msg, args);\n-            }\n-        }\n+        private static final String SERIAL_FILTER_TRACE_PROPNAME = \"jdk.serialFilterTrace\";\n@@ -247,2 +588,1 @@\n-         * The name for the system-wide deserialization filter.\n-         * Used as a system property and a java.security.Security property.\n+         * Current static filter.\n@@ -250,1 +590,16 @@\n-        private static final String SERIAL_FILTER_PROPNAME = \"jdk.serialFilter\";\n+        private static volatile ObjectInputFilter serialFilter;\n+\n+        \/**\n+         * Current serial filter factory.\n+         * @see Config#setSerialFilterFactory(BinaryOperator)\n+         *\/\n+        private static volatile BinaryOperator<ObjectInputFilter> serialFilterFactory;\n+\n+        \/**\n+         * Boolean to indicate that the filter factory can not be set or replaced.\n+         * - an ObjectInputStream has already been created using the current filter factory\n+         * - has been set on the command line\n+         * - jdk.serialFilter is set and jdk.serialFilterFactory is unset, the builtin can not be replaced\n+         * @see Config#setSerialFilterFactory(BinaryOperator)\n+         *\/\n+        private static final AtomicBoolean filterFactoryNoReplace = new AtomicBoolean();\n@@ -253,3 +608,1 @@\n-         * The system-wide filter; may be null.\n-         * Lookup the filter in java.security.Security or\n-         * the system property.\n+         * Debug: Logger\n@@ -257,1 +610,6 @@\n-        private static final ObjectInputFilter configuredFilter;\n+        private static final System.Logger configLog;\n+\n+        \/**\n+         * True when tracing of filters is enabled.\n+         *\/\n+        private static final boolean traceFilters;\n@@ -260,21 +618,26 @@\n-            configuredFilter = AccessController\n-                    .doPrivileged((PrivilegedAction<ObjectInputFilter>) () -> {\n-                        String props = StaticProperty.jdkSerialFilter();\n-                        if (props == null) {\n-                            props = Security.getProperty(SERIAL_FILTER_PROPNAME);\n-                        }\n-                        if (props != null) {\n-                            System.Logger log =\n-                                    System.getLogger(\"java.io.serialization\");\n-                            log.log(System.Logger.Level.INFO,\n-                                    \"Creating serialization filter from {0}\", props);\n-                            try {\n-                                return createFilter(props);\n-                            } catch (RuntimeException re) {\n-                                log.log(System.Logger.Level.ERROR,\n-                                        \"Error configuring filter: {0}\", re);\n-                            }\n-                        }\n-                        return null;\n-                    });\n-            configLog = (configuredFilter != null) ? System.getLogger(\"java.io.serialization\") : null;\n+            \/*\n+             * Initialize the configuration containing the filter factory, static filter, and logger.\n+             * <ul>\n+             * <li>The property 'jdk.serialFilter\" is read, either as a system property or a security property,\n+             *     and if set, defines the configured static JVM-wide filter and is logged.\n+             * <li>The property jdk.serialFilterFactory is read, either as a system property or a security property,\n+             *     and if set, defines the initial filter factory and is logged.\n+             * <li>The property jdk.serialFilterTrace, is read, and if set enables tracing of filters.\n+             * <li>If either property is defined or tracing is enabled, the logger is created.\n+             * <\/ul>\n+             *\/\n+\n+            \/\/ Get the values of the system properties, if they are defined\n+            String factoryClassName = StaticProperty.jdkSerialFilterFactory();\n+            if (factoryClassName == null) {\n+                \/\/ Fallback to security property\n+                factoryClassName = AccessController.doPrivileged((PrivilegedAction<String>) () ->\n+                        Security.getProperty(SERIAL_FILTER_FACTORY_PROPNAME));\n+            }\n+\n+            String filterString = StaticProperty.jdkSerialFilter();\n+            if (filterString == null) {\n+                \/\/ Fallback to security property\n+                filterString = AccessController.doPrivileged((PrivilegedAction<String>) () ->\n+                        Security.getProperty(SERIAL_FILTER_PROPNAME));\n+            }\n@@ -282,0 +645,63 @@\n+            traceFilters = GetBooleanAction.privilegedGetProperty(SERIAL_FILTER_TRACE_PROPNAME);\n+\n+            \/\/ Initialize the logger if either filter factory or filter property is set\n+            configLog = (filterString != null || factoryClassName != null || traceFilters)\n+                    ? System.getLogger(\"java.io.serialization\") : null;\n+\n+            \/\/ Initialize the static filter if the jdk.serialFilter is present\n+            ObjectInputFilter filter = null;\n+            if (filterString != null) {\n+                configLog.log(DEBUG,\n+                        \"Creating deserialization filter from {0}\", filterString);\n+                try {\n+                    filter = createFilter(filterString);\n+                } catch (RuntimeException re) {\n+                    configLog.log(System.Logger.Level.ERROR,\n+                            \"Error configuring filter: {0}\", re);\n+                }\n+            }\n+            serialFilter = filter;\n+\n+            \/\/ Initialize the filter factory if the jdk.serialFilterFactory is defined\n+            \/\/ otherwise use the builtin filter factory.\n+            if (factoryClassName == null || \"OVERRIDE\".equals(factoryClassName)) {\n+                serialFilterFactory = new BuiltinFilterFactory();\n+                if (serialFilter != null && factoryClassName == null) {\n+                    \/\/ Ensure backward compatibility, unless factory is explicitly allowed to override\n+                    \/\/ Do not allow factory to be overridden by Config.setSerialFilterFactory\n+                    filterFactoryNoReplace.set(true);\n+                }\n+\n+            } else {\n+                configLog.log(DEBUG,\n+                        \"Creating deserialization filter factory for {0}\", factoryClassName);\n+                try {\n+                    \/\/ Load using the system class loader, the named class may be an application class.\n+                    \/\/ The static initialization of the class or constructor may create a race\n+                    \/\/ if either calls Config.setSerialFilterFactory; the command line configured\n+                    \/\/ Class should not be overridden.\n+                    Class<?> factoryClass = Class.forName(factoryClassName, true,\n+                            ClassLoader.getSystemClassLoader());\n+                    @SuppressWarnings(\"unchecked\")\n+                    BinaryOperator<ObjectInputFilter> f =\n+                            (BinaryOperator<ObjectInputFilter>)\n+                            factoryClass.getConstructor().newInstance(new Object[0]);\n+                    if (serialFilterFactory != null) {\n+                        \/\/ Init cycle if Config.setSerialFilterFactory called from class initialization\n+                        configLog.log(System.Logger.Level.ERROR,\n+                                \"FilterFactory provided on the command line can not be overridden\");\n+                        \/\/ Do not continue if configuration not initialized\n+                        throw new ExceptionInInitializerError(\n+                                \"FilterFactory provided on the command line can not be overridden\");\n+                    }\n+                    serialFilterFactory = f;\n+                    filterFactoryNoReplace.set(true);\n+                } catch (RuntimeException | ClassNotFoundException | NoSuchMethodException |\n+                        IllegalAccessException | InstantiationException | InvocationTargetException ex) {\n+                    configLog.log(System.Logger.Level.ERROR,\n+                            \"Error configuring filter factory\", ex);\n+                    \/\/ Do not continue if configuration not initialized\n+                    throw new ExceptionInInitializerError(\n+                            \"FilterFactory configuration: jdk.serialFilterFactory: \" + ex.getMessage());\n+                }\n+            }\n@@ -287,1 +713,1 @@\n-         * Current configured filter.\n+         * Config has no instances.\n@@ -289,1 +715,2 @@\n-        private static volatile ObjectInputFilter serialFilter = configuredFilter;\n+        private Config() {\n+        }\n@@ -292,1 +719,10 @@\n-         * Returns the system-wide serialization filter or {@code null} if not configured.\n+         * Logger for filter actions.\n+         *\/\n+        private static void traceFilter(String msg, Object... args) {\n+            if (traceFilters && configLog != null) {\n+                configLog.log(TRACE, msg, args);\n+            }\n+        }\n+\n+        \/**\n+         * Returns the static JVM-wide deserialization filter or {@code null} if not configured.\n@@ -294,1 +730,1 @@\n-         * @return the system-wide serialization filter or {@code null} if not configured\n+         * @return the static JVM-wide deserialization filter or {@code null} if not configured\n@@ -301,1 +737,1 @@\n-         * Set the system-wide filter if it has not already been configured or set.\n+         * Set the static JVM-wide filter if it has not already been configured or set.\n@@ -303,1 +739,1 @@\n-         * @param filter the serialization filter to set as the system-wide filter; not null\n+         * @param filter the deserialization filter to set as the JVM-wide filter; not null\n@@ -306,1 +742,1 @@\n-         * @throws IllegalStateException if the filter has already been set {@code non-null}\n+         * @throws IllegalStateException if the filter has already been set\n@@ -322,0 +758,94 @@\n+        \/**\n+         * Returns the JVM-wide deserialization filter factory.\n+         * If the filter factory has been {@linkplain #setSerialFilterFactory(BinaryOperator) set} it is returned,\n+         * otherwise, a builtin deserialization filter factory is returned.\n+         * The filter factory provides a filter for every ObjectInputStream when invoked from\n+         * {@linkplain ObjectInputStream#ObjectInputStream(InputStream) ObjectInputStream constructors}\n+         * and when a stream-specific filter is set with\n+         * {@link ObjectInputStream#setObjectInputFilter(ObjectInputFilter) setObjectInputFilter}.\n+         *\n+         * @implSpec\n+         * The builtin deserialization filter factory provides the\n+         * {@linkplain #getSerialFilter static JVM-wide filter} when invoked from\n+         * {@linkplain ObjectInputStream#ObjectInputStream(InputStream) ObjectInputStream constructors}.\n+         * When invoked {@link ObjectInputStream#setObjectInputFilter(ObjectInputFilter)\n+         * to set the stream-specific filter} the requested filter replaces the static JVM-wide filter,\n+         * unless it has already been set.\n+         * The builtin deserialization filter factory implements the behavior of earlier versions of\n+         * setting the initial filter in the {@link ObjectInputStream} constructor and\n+         * {@link ObjectInputStream#setObjectInputFilter}.\n+         *\n+         * @return the JVM-wide deserialization filter factory; non-null\n+         * @throws IllegalStateException if the filter factory initialization is incomplete\n+         * @since 17\n+         *\/\n+        public static BinaryOperator<ObjectInputFilter> getSerialFilterFactory() {\n+            if (serialFilterFactory == null)\n+                throw new IllegalStateException(\"Serial filter factory initialization incomplete\");\n+            return serialFilterFactory;\n+        }\n+\n+        \/**\n+         * Returns the serial filter factory singleton and prevents it from changing\n+         * thereafter.\n+         * This package private method is *only* called by {@link ObjectInputStream#ObjectInputStream()}\n+         * and  {@link ObjectInputStream#ObjectInputStream(InputStream)}.\n+         * {@link ObjectInputFilter.Config#setSerialFilterFactory(BinaryOperator)} enforces\n+         * the requirement that the filter factory can not be changed after an ObjectInputStream\n+         * is created.\n+         *\n+         * @return the serial filter factory\n+         * @throws IllegalStateException if the filter factory initialization is incomplete\n+         *\/\n+        \/* package-private *\/\n+        static BinaryOperator<ObjectInputFilter> getSerialFilterFactorySingleton() {\n+            filterFactoryNoReplace.set(true);\n+            return getSerialFilterFactory();\n+        }\n+\n+        \/**\n+         * Set the {@linkplain #getSerialFilterFactory() JVM-wide deserialization filter factory}.\n+         * The filter factory can be configured exactly once with one of:\n+         * setting the {@code jdk.serialFilterFactory} property on the command line,\n+         * setting the {@code jdk.serialFilterFactory} property in the {@link java.security.Security}\n+         * file, or using this {@code setSerialFilterFactory} method.\n+         * The filter factory can be set only before any {@link ObjectInputStream} has been\n+         * created to avoid any inconsistency in which filter factory is being used.\n+         *\n+         * <p>The JVM-wide filter factory is invoked when an ObjectInputStream\n+         * {@linkplain ObjectInputStream#ObjectInputStream() is constructed} and when the\n+         * {@linkplain ObjectInputStream#setObjectInputFilter(ObjectInputFilter) stream-specific filter is set}.\n+         * The parameters are the current filter and a requested filter and it\n+         * returns the filter to be used for the stream.\n+         * If the current filter is {@code non-null}, the filter factory must return a\n+         * {@code non-null} filter; this is to prevent unintentional disabling of filtering\n+         * after it has been enabled.\n+         * The factory determines the filter to be used for {@code ObjectInputStream} streams based\n+         * on its inputs, any other filters, context, or state that is available.\n+         * The factory may throw runtime exceptions to signal incorrect use or invalid parameters.\n+         * See the {@linkplain ObjectInputFilter filter models} for examples of composition and delegation.\n+         *\n+         * @param filterFactory the deserialization filter factory to set as the\n+         *         JVM-wide filter factory; not null\n+         * @throws IllegalStateException if the builtin deserialization filter factory\n+         *         has already been replaced or any instance of {@link ObjectInputStream}\n+         *         has been created.\n+         * @throws SecurityException if there is security manager and the\n+         *       {@code SerializablePermission(\"serialFilter\")} is not granted\n+         * @since 17\n+         *\/\n+        public static void setSerialFilterFactory(BinaryOperator<ObjectInputFilter> filterFactory) {\n+            Objects.requireNonNull(filterFactory, \"filterFactory\");\n+            SecurityManager sm = System.getSecurityManager();\n+            if (sm != null) {\n+                sm.checkPermission(ObjectStreamConstants.SERIAL_FILTER_PERMISSION);\n+            }\n+            if (serialFilterFactory == null)\n+                throw new IllegalStateException(\"Serial filter factory initialization incomplete\");\n+            if (filterFactoryNoReplace.getAndSet(true)) {\n+                throw new IllegalStateException(\"Cannot replace filter factory: \" +\n+                        serialFilterFactory.getClass().getName());\n+            }\n+            serialFilterFactory = filterFactory;\n+        }\n+\n@@ -405,1 +935,1 @@\n-         * the system-wide serialization filter. If configured, it will be\n+         * the JVM-wide deserialization filter. If configured, it will be\n@@ -409,1 +939,1 @@\n-        static final class Global implements ObjectInputFilter {\n+        final static class Global implements ObjectInputFilter {\n@@ -636,0 +1166,1 @@\n+                            traceFilter(\"Pattern array class: {0}, filter: {1}\", clazz, this);\n@@ -646,1 +1177,2 @@\n-                        return Status.UNDECIDED;\n+                        traceFilter(\"Pattern UNDECIDED, primitive class: {0}, filter: {1}\", clazz, this);\n+                        return UNDECIDED;\n@@ -654,1 +1186,3 @@\n-                        return status.orElse(Status.UNDECIDED);\n+                        Status s = status.orElse(Status.UNDECIDED);\n+                        traceFilter(\"Pattern {0}, class: {1}, filter: {2}\", s, cl, this);\n+                        return s;\n@@ -657,1 +1191,2 @@\n-                return Status.UNDECIDED;\n+                \/\/ There are no classes to check and none of the limits have been exceeded.\n+                return UNDECIDED;\n@@ -681,0 +1216,228 @@\n+\n+        \/**\n+         * An ObjectInputFilter to evaluate a predicate mapping a class to a boolean.\n+         * @see ObjectInputFilter#allowFilter(Predicate, Status)\n+         * @see ObjectInputFilter#rejectFilter(Predicate, Status)\n+         *\/\n+        private static class PredicateFilter implements ObjectInputFilter {\n+            private final Predicate<Class<?>> predicate;\n+            private final Status ifTrueStatus;\n+            private final Status ifFalseStatus;\n+\n+            PredicateFilter(Predicate<Class<?>> predicate, Status ifTrueStatus, Status ifFalseStatus) {\n+                this.predicate = predicate;\n+                this.ifTrueStatus = ifTrueStatus;\n+                this.ifFalseStatus = ifFalseStatus;\n+            }\n+\n+            \/**\n+             * Returns a filter that returns {@code ifTrueStatus} or the {@code ifFalseStatus}\n+             * based on the predicate of the {@code non-null} class and {@code UNDECIDED}\n+             * if the class is {@code null}.\n+             *\n+             * @param info the FilterInfo\n+             * @return a filter that returns {@code ifTrueStatus} or the {@code ifFalseStatus}\n+             *          based on the predicate of the {@code non-null} class and {@code UNDECIDED}\n+             *          if the class is {@code null}\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                Class<?> clazz = info.serialClass();\n+                Status status = (clazz == null) ? UNDECIDED\n+                        : (predicate.test(clazz)) ? ifTrueStatus : ifFalseStatus;\n+                traceFilter(\"PredicateFilter {0}, filter: {1}\", status, this);\n+                return status;\n+            }\n+\n+            \/**\n+             * Return a String describing the filter, its predicate, and true and false status values.\n+             * @return a String describing the filter, its predicate, and true and false status values.\n+             *\/\n+            public String toString() {\n+                return \"predicate(\" + predicate + \", ifTrue: \" + ifTrueStatus + \", ifFalse:\" + ifFalseStatus+ \")\";\n+            }\n+        }\n+\n+        \/**\n+         * An ObjectInputFilter that merges the status of two filters.\n+         * @see ObjectInputFilter#merge(ObjectInputFilter, ObjectInputFilter)\n+         *\/\n+        private static class MergeFilter implements ObjectInputFilter {\n+            private final ObjectInputFilter first;\n+            private final ObjectInputFilter second;\n+\n+            MergeFilter(ObjectInputFilter first, ObjectInputFilter second) {\n+                this.first = first;\n+                this.second = second;\n+            }\n+\n+            \/**\n+             * Returns REJECTED if either of the filters returns REJECTED,\n+             * otherwise, ALLOWED if either of the filters returns ALLOWED,\n+             * otherwise, returns {@code UNDECIDED}.\n+             *\n+             * @param info the FilterInfo\n+             * @return REJECTED if either of the filters returns REJECTED,\n+             *          otherwise, ALLOWED if either of the filters returns ALLOWED,\n+             *          otherwise, returns {@code UNDECIDED}.\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+               Status firstStatus = Objects.requireNonNull(first.checkInput(info), \"status\");\n+                if (REJECTED.equals(firstStatus)) {\n+                    traceFilter(\"MergeFilter REJECT first: {0}, filter: {1}\",\n+                            firstStatus, this);\n+                    return REJECTED;\n+                }\n+                Status secondStatus = Objects.requireNonNull(second.checkInput(info), \"other status\");\n+                if (REJECTED.equals(secondStatus)) {\n+                    traceFilter(\"MergeFilter REJECT {0}, {1}, filter: {2}\",\n+                            firstStatus, secondStatus, this);\n+                    return REJECTED;\n+                }\n+                if (ALLOWED.equals(firstStatus) || ALLOWED.equals(secondStatus)) {\n+                    traceFilter(\"MergeFilter ALLOW either: {0}, {1}, filter: {2}\",\n+                            firstStatus, secondStatus, this);\n+                    return ALLOWED;\n+                }\n+                traceFilter(\"MergeFilter UNDECIDED {0}, {1}, filter: {2}\",\n+                        firstStatus, secondStatus, this);\n+                return UNDECIDED;\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return \"merge(\" + first + \", \" + second + \")\";\n+            }\n+        }\n+\n+        \/**\n+         * A filter that maps the status {@code UNDECIDED} to {@code REJECTED} when checking a class.\n+         * @see ObjectInputFilter#rejectUndecidedClass(ObjectInputFilter)\n+         *\/\n+        private static class RejectUndecidedFilter implements ObjectInputFilter {\n+            private final ObjectInputFilter filter;\n+\n+            private RejectUndecidedFilter(ObjectInputFilter filter) {\n+                this.filter = Objects.requireNonNull(filter, \"filter\");\n+            }\n+\n+            \/**\n+             * Apply the filter and return the status if not UNDECIDED and checking a class.\n+             * For array classes, re-check the final component type against the filter.\n+             * Make an exception for Primitive classes that are implicitly allowed by the pattern based filter.\n+             * @param info the FilterInfo\n+             * @return the status of applying the filter and checking the class\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                Status status = Objects.requireNonNull(filter.checkInput(info), \"status\");\n+                Class<?> clazz = info.serialClass();\n+                if (clazz == null || !UNDECIDED.equals(status))\n+                    return status;\n+                status = REJECTED;\n+                \/\/ Find the base component type\n+                while (clazz.isArray()) {\n+                    clazz = clazz.getComponentType();\n+                }\n+                if (clazz.isPrimitive()) {\n+                    status = UNDECIDED;\n+                } else {\n+                    \/\/ for non-primitive types;  re-filter the base component type\n+                    FilterInfo clazzInfo = new SerialInfo(info, clazz);\n+                    Status clazzStatus = filter.checkInput(clazzInfo);\n+                    traceFilter(\"RejectUndecidedFilter Array Component type {0} class: {1}, filter: {2}\",\n+                            clazzStatus, clazz, this);\n+                    status = (ALLOWED.equals(clazzStatus)) ? ALLOWED : REJECTED;\n+                }\n+                traceFilter(\"RejectUndecidedFilter {0} class: {1}, filter: {2}\",\n+                        status, info.serialClass(), this);\n+                return status;\n+            }\n+\n+            public String toString() {\n+                return \"rejectUndecidedClass(\" + filter + \")\";\n+            }\n+\n+            \/**\n+             * FilterInfo instance with a specific class and delegating to an existing FilterInfo.\n+             * Nested in the rejectUndecided class.\n+             *\/\n+            static class SerialInfo implements ObjectInputFilter.FilterInfo {\n+                private final FilterInfo base;\n+                private final Class<?> clazz;\n+\n+                SerialInfo(FilterInfo base, Class<?> clazz) {\n+                    this.base = base;\n+                    this.clazz = clazz;\n+                }\n+\n+                @Override\n+                public Class<?> serialClass() {\n+                    return clazz;\n+                }\n+\n+                @Override\n+                public long arrayLength() {\n+                    return base.arrayLength();\n+                }\n+\n+                @Override\n+                public long depth() {\n+                    return base.depth();\n+                }\n+\n+                @Override\n+                public long references() {\n+                    return base.references();\n+                }\n+\n+                @Override\n+                public long streamBytes() {\n+                    return base.streamBytes();\n+                }\n+            }\n+\n+        }\n+\n+        \/**\n+         * Builtin Deserialization filter factory.\n+         * The builtin deserialization filter factory implements the behavior of earlier versions of\n+         * setting the static serial filter in the {@link ObjectInputStream} constructor and\n+         * {@link ObjectInputStream#setObjectInputFilter} in cooperation with {@code ObjectInputStream}.\n+         * Checking that the stream-specific filter can only be set once and throwing\n+         * {@link IllegalStateException} is handled by\n+         * {@link ObjectInputStream#setObjectInputFilter(ObjectInputFilter)}.\n+         *\n+         * @see Config#getSerialFilterFactory()\n+         *\/\n+        private static final class BuiltinFilterFactory implements BinaryOperator<ObjectInputFilter> {\n+            \/**\n+             * Returns the {@code ObjectInputFilter} to be used for an ObjectInputStream.\n+             *\n+             * <p>When invoked from the\n+             * {@linkplain ObjectInputStream#ObjectInputStream(InputStream) ObjectInputStream constructors},\n+             * the first parameter is {@code null} and the second parameter is the\n+             * {@linkplain ObjectInputFilter.Config#getSerialFilter() static JVM-wide filter};\n+             * the value returned is {@code newFilter}, the static JVM-wide filter.\n+             * <p>\n+             * When invoked from\n+             * {@link ObjectInputStream#setObjectInputFilter(ObjectInputFilter) setObjectInputFilter}\n+             * to set the stream-specific filter, the value is {@code newFilter} to replace the\n+             * previous filter.\n+             *\n+             * @param oldFilter the current filter, may be null\n+             * @param newFilter a new filter, may be null\n+             * @return an ObjectInputFilter, the new Filter, may be null\n+             *\/\n+            @Override\n+            public ObjectInputFilter apply(ObjectInputFilter oldFilter, ObjectInputFilter newFilter) {\n+                traceFilter(\"Builtin factory: {0} -> new: {1}\", oldFilter, newFilter);\n+                return newFilter;\n+            }\n+\n+            \/**\n+             * Returns the class name of this builtin deserialization filter factory.\n+             * @return returns the class name of this builtin deserialization filter factory\n+             *\/\n+            public String toString() {\n+                return this.getClass().getName();\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputFilter.java","additions":857,"deletions":94,"binary":false,"changes":951,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.io.ObjectInputFilter.Config;\n@@ -69,0 +70,17 @@\n+ * <p>The key to disabling deserialization attacks is to prevent instances of\n+ * arbitrary classes from being deserialized, thereby preventing the direct or\n+ * indirect execution of their methods.\n+ * {@link ObjectInputFilter} describes how to use filters and\n+ * {@link ObjectInputFilter.Config} describes how to configure the filter and filter factory.\n+ * Each stream has an optional deserialization filter\n+ * to check the classes and resource limits during deserialization.\n+ * The JVM-wide filter factory ensures that a filter can be set on every {@link ObjectInputStream}\n+ * and every object read from the stream can be checked.\n+ * The {@linkplain #ObjectInputStream() ObjectInputStream constructors} invoke the filter factory\n+ * to select the initial filter which may be updated or replaced by {@link #setObjectInputFilter}.\n+ * <p>\n+ * If an ObjectInputStream has a filter, the {@link ObjectInputFilter} can check that\n+ * the classes, array lengths, number of references in the stream, depth, and\n+ * number of bytes consumed from the input stream are allowed and\n+ * if not, can terminate deserialization.\n+ *\n@@ -191,10 +209,0 @@\n- * <p>The contents of the stream can be filtered during deserialization.\n- * If a {@linkplain #setObjectInputFilter(ObjectInputFilter) filter is set}\n- * on an ObjectInputStream, the {@link ObjectInputFilter} can check that\n- * the classes, array lengths, number of references in the stream, depth, and\n- * number of bytes consumed from the input stream are allowed and\n- * if not, can terminate deserialization.\n- * A {@linkplain ObjectInputFilter.Config#setSerialFilter(ObjectInputFilter) system-wide filter}\n- * can be configured that is applied to each {@code ObjectInputStream} unless replaced\n- * using {@link #setObjectInputFilter(ObjectInputFilter) setObjectInputFilter}.\n- *\n@@ -350,0 +358,5 @@\n+    \/**\n+     * True if the stream-specific filter has been set; initially false.\n+     *\/\n+    private boolean streamFilterSet;\n+\n@@ -356,2 +369,3 @@\n-     * <p>The serialization filter is initialized to the value of\n-     * {@linkplain ObjectInputFilter.Config#getSerialFilter() the system-wide filter}.\n+     * <p>The constructor initializes the deserialization filter to the filter returned\n+     * by invoking the {@link Config#getSerialFilterFactory()} with {@code null} for the current filter\n+     * and the {@linkplain Config#getSerialFilter() static JVM-wide filter} for the requested filter.\n@@ -380,1 +394,2 @@\n-        serialFilter = ObjectInputFilter.Config.getSerialFilter();\n+        streamFilterSet = false;\n+        serialFilter = Config.getSerialFilterFactorySingleton().apply(null, Config.getSerialFilter());\n@@ -391,2 +406,3 @@\n-     * <p>The serialization filter is initialized to the value of\n-     * {@linkplain ObjectInputFilter.Config#getSerialFilter() the system-wide filter}.\n+     * <p>The constructor initializes the deserialization filter to the filter returned\n+     * by invoking the {@link Config#getSerialFilterFactory()} with {@code null} for the current filter\n+     * and the {@linkplain Config#getSerialFilter() static JVM-wide filter} for the requested filter.\n@@ -415,1 +431,2 @@\n-        serialFilter = ObjectInputFilter.Config.getSerialFilter();\n+        streamFilterSet = false;\n+        serialFilter = Config.getSerialFilterFactorySingleton().apply(null, Config.getSerialFilter());\n@@ -434,1 +451,1 @@\n-     * <p>The serialization filter, when not {@code null}, is invoked for\n+     * <p>The deserialization filter, when not {@code null}, is invoked for\n@@ -446,1 +463,1 @@\n-     *          serialization.\n+     *          deserialization.\n@@ -567,1 +584,1 @@\n-     * <p>The serialization filter, when not {@code null}, is invoked for\n+     * <p>The deserialization filter, when not {@code null}, is invoked for\n@@ -875,1 +892,1 @@\n-     * field or array element abort the serialization by raising an exception\n+     * field or array element abort the deserialization by raising an exception\n@@ -1226,5 +1243,5 @@\n-     * Returns the serialization filter for this stream.\n-     * The serialization filter is the most recent filter set in\n-     * {@link #setObjectInputFilter setObjectInputFilter} or\n-     * the initial system-wide filter from\n-     * {@link ObjectInputFilter.Config#getSerialFilter() ObjectInputFilter.Config.getSerialFilter}.\n+     * Returns the deserialization filter for this stream.\n+     * The filter is the result of invoking the\n+     * {@link Config#getSerialFilterFactory() JVM-wide filter factory}\n+     * either by the {@linkplain #ObjectInputStream() constructor} or the most recent invocation of\n+     * {@link #setObjectInputFilter setObjectInputFilter}.\n@@ -1232,1 +1249,1 @@\n-     * @return the serialization filter for the stream; may be null\n+     * @return the deserialization filter for the stream; may be null\n@@ -1240,2 +1257,17 @@\n-     * Set the serialization filter for the stream.\n-     * The filter's {@link ObjectInputFilter#checkInput checkInput} method is called\n+     * Set the deserialization filter for the stream.\n+     *\n+     * The deserialization filter is set to the filter returned by invoking the\n+     * {@linkplain Config#getSerialFilterFactory() JVM-wide filter factory}\n+     * with the {@linkplain #getObjectInputFilter() current filter} and the {@code filter} parameter.\n+     * The current filter was set in the\n+     * {@linkplain #ObjectInputStream() ObjectInputStream constructors} by invoking the\n+     * {@linkplain Config#getSerialFilterFactory() JVM-wide filter factory} and may be {@code null}.\n+     * {@linkplain #setObjectInputFilter(ObjectInputFilter)} This method} can be called\n+     * once and only once before reading any objects from the stream;\n+     * for example, by calling {@link #readObject} or {@link #readUnshared}.\n+     *\n+     * <p>It is not permitted to replace a {@code non-null} filter with a {@code null} filter.\n+     * If the {@linkplain #getObjectInputFilter() current filter} is {@code non-null},\n+     * the value returned from the filter factory must be {@code non-null}.\n+     *\n+     * <p>The filter's {@link ObjectInputFilter#checkInput checkInput} method is called\n@@ -1250,2 +1282,2 @@\n-     * The filter is invoked only when reading objects from the stream and for\n-     * not primitives.\n+     * The filter is invoked only when reading objects from the stream and not for\n+     * primitives.\n@@ -1258,7 +1290,0 @@\n-     * <p>\n-     * The serialization filter is initialized to the value of\n-     * {@link ObjectInputFilter.Config#getSerialFilter() ObjectInputFilter.Config.getSerialFilter}\n-     * when the {@code  ObjectInputStream} is constructed and can be set\n-     * to a custom filter only once.\n-     * The filter must be set before reading any objects from the stream;\n-     * for example, by calling {@link #readObject} or {@link #readUnshared}.\n@@ -1306,3 +1331,4 @@\n-     * @throws IllegalStateException if the {@linkplain #getObjectInputFilter() current filter}\n-     *       is not {@code null} and is not the system-wide filter, or\n-     *       if an object has been read\n+     * @throws IllegalStateException if an object has been read,\n+     *       if the filter factory returns {@code null} when the\n+     *       {@linkplain #getObjectInputFilter() current filter} is non-null, or\n+     *       if the filter has already been set.\n@@ -1317,5 +1343,0 @@\n-        \/\/ Allow replacement of the system-wide filter if not already set\n-        if (serialFilter != null &&\n-                serialFilter != ObjectInputFilter.Config.getSerialFilter()) {\n-            throw new IllegalStateException(\"filter can not be set more than once\");\n-        }\n@@ -1326,1 +1347,11 @@\n-        this.serialFilter = filter;\n+        if (streamFilterSet) {\n+            throw new IllegalStateException(\"filter can not be set more than once\");\n+        }\n+        streamFilterSet = true;\n+        \/\/ Delegate to serialFilterFactory to compute stream filter\n+        ObjectInputFilter next = Config.getSerialFilterFactory()\n+                .apply(serialFilter, filter);\n+        if (serialFilter != null && next == null) {\n+            throw new IllegalStateException(\"filter can not be replaced with null filter\");\n+        }\n+        serialFilter = next;\n@@ -1330,1 +1361,1 @@\n-     * Invokes the serialization filter if non-null.\n+     * Invokes the deserialization filter if non-null.\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":78,"deletions":47,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -75,17 +75,9 @@\n-            switch(ch >>> 16) {  \/\/plane 00-16\n-            case(0):\n-                return CharacterData00.instance;\n-            case(1):\n-                return CharacterData01.instance;\n-            case(2):\n-                return CharacterData02.instance;\n-            case(3):\n-                return CharacterData03.instance;\n-            case(14):\n-                return CharacterData0E.instance;\n-            case(15):   \/\/ Private Use\n-            case(16):   \/\/ Private Use\n-                return CharacterDataPrivateUse.instance;\n-            default:\n-                return CharacterDataUndefined.instance;\n-            }\n+            return switch (ch >>> 16) {  \/\/plane 00-16\n+                case 0 -> CharacterData00.instance;\n+                case 1 -> CharacterData01.instance;\n+                case 2 -> CharacterData02.instance;\n+                case 3 -> CharacterData03.instance;\n+                case 14 -> CharacterData0E.instance;\n+                case 15, 16 -> CharacterDataPrivateUse.instance; \/\/ Both cases Private Use\n+                default -> CharacterDataUndefined.instance;\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/CharacterData.java","additions":9,"deletions":17,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -173,19 +173,8 @@\n-        switch (condition) {\n-        case FINAL_CASED:\n-            return isFinalCased(src, index, locale);\n-\n-        case AFTER_SOFT_DOTTED:\n-            return isAfterSoftDotted(src, index);\n-\n-        case MORE_ABOVE:\n-            return isMoreAbove(src, index);\n-\n-        case AFTER_I:\n-            return isAfterI(src, index);\n-\n-        case NOT_BEFORE_DOT:\n-            return !isBeforeDot(src, index);\n-\n-        default:\n-            return true;\n-        }\n+        return switch (condition) {\n+            case FINAL_CASED       -> isFinalCased(src, index, locale);\n+            case AFTER_SOFT_DOTTED -> isAfterSoftDotted(src, index);\n+            case MORE_ABOVE        -> isMoreAbove(src, index);\n+            case AFTER_I           -> isAfterI(src, index);\n+            case NOT_BEFORE_DOT    -> !isBeforeDot(src, index);\n+            default -> true;\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ConditionalSpecialCasing.java","additions":8,"deletions":19,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -216,32 +216,21 @@\n-            switch (radix) {\n-            case 2:\n-                return toBinaryString(i);\n-\n-            case 4:\n-                return toUnsignedString0(i, 2);\n-\n-            case 8:\n-                return toOctalString(i);\n-\n-            case 10:\n-                \/*\n-                 * We can get the effect of an unsigned division by 10\n-                 * on a long value by first shifting right, yielding a\n-                 * positive value, and then dividing by 5.  This\n-                 * allows the last digit and preceding digits to be\n-                 * isolated more quickly than by an initial conversion\n-                 * to BigInteger.\n-                 *\/\n-                long quot = (i >>> 1) \/ 5;\n-                long rem = i - quot * 10;\n-                return toString(quot) + rem;\n-\n-            case 16:\n-                return toHexString(i);\n-\n-            case 32:\n-                return toUnsignedString0(i, 5);\n-\n-            default:\n-                return toUnsignedBigInteger(i).toString(radix);\n-            }\n+            return switch (radix) {\n+                case 2  -> toBinaryString(i);\n+                case 4  -> toUnsignedString0(i, 2);\n+                case 8  -> toOctalString(i);\n+                case 10 -> {\n+                    \/*\n+                     * We can get the effect of an unsigned division by 10\n+                     * on a long value by first shifting right, yielding a\n+                     * positive value, and then dividing by 5.  This\n+                     * allows the last digit and preceding digits to be\n+                     * isolated more quickly than by an initial conversion\n+                     * to BigInteger.\n+                     *\/\n+                    long quot = (i >>> 1) \/ 5;\n+                    long rem = i - quot * 10;\n+                    yield toString(quot) + rem;\n+                }\n+                case 16 -> toHexString(i);\n+                case 32 -> toUnsignedString0(i, 5);\n+                default -> toUnsignedBigInteger(i).toString(radix);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":21,"deletions":32,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -1929,21 +1929,17 @@\n-        switch(exp) {\n-        case Double.MAX_EXPONENT + 1:       \/\/ NaN or infinity\n-            return Math.abs(d);\n-\n-        case Double.MIN_EXPONENT - 1:       \/\/ zero or subnormal\n-            return Double.MIN_VALUE;\n-\n-        default:\n-            assert exp <= Double.MAX_EXPONENT && exp >= Double.MIN_EXPONENT;\n-\n-            \/\/ ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))\n-            exp = exp - (DoubleConsts.SIGNIFICAND_WIDTH-1);\n-            if (exp >= Double.MIN_EXPONENT) {\n-                return powerOfTwoD(exp);\n-            }\n-            else {\n-                \/\/ return a subnormal result; left shift integer\n-                \/\/ representation of Double.MIN_VALUE appropriate\n-                \/\/ number of positions\n-                return Double.longBitsToDouble(1L <<\n-                (exp - (Double.MIN_EXPONENT - (DoubleConsts.SIGNIFICAND_WIDTH-1)) ));\n+        return switch(exp) {\n+            case Double.MAX_EXPONENT + 1 -> Math.abs(d);      \/\/ NaN or infinity\n+            case Double.MIN_EXPONENT - 1 -> Double.MIN_VALUE; \/\/ zero or subnormal\n+            default -> {\n+                assert exp <= Double.MAX_EXPONENT && exp >= Double.MIN_EXPONENT;\n+\n+                \/\/ ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))\n+                exp = exp - (DoubleConsts.SIGNIFICAND_WIDTH - 1);\n+                if (exp >= Double.MIN_EXPONENT) {\n+                    yield powerOfTwoD(exp);\n+                } else {\n+                    \/\/ return a subnormal result; left shift integer\n+                    \/\/ representation of Double.MIN_VALUE appropriate\n+                    \/\/ number of positions\n+                    yield Double.longBitsToDouble(1L <<\n+                            (exp - (Double.MIN_EXPONENT - (DoubleConsts.SIGNIFICAND_WIDTH - 1))));\n+                }\n@@ -1951,1 +1947,1 @@\n-        }\n+        };\n@@ -1980,3 +1976,5 @@\n-        switch(exp) {\n-        case Float.MAX_EXPONENT+1:        \/\/ NaN or infinity\n-            return Math.abs(f);\n+        return switch(exp) {\n+            case Float.MAX_EXPONENT + 1 -> Math.abs(f);     \/\/ NaN or infinity\n+            case Float.MIN_EXPONENT - 1 -> Float.MIN_VALUE; \/\/ zero or subnormal\n+            default -> {\n+                assert exp <= Float.MAX_EXPONENT && exp >= Float.MIN_EXPONENT;\n@@ -1984,16 +1982,11 @@\n-        case Float.MIN_EXPONENT-1:        \/\/ zero or subnormal\n-            return Float.MIN_VALUE;\n-\n-        default:\n-            assert exp <= Float.MAX_EXPONENT && exp >= Float.MIN_EXPONENT;\n-\n-            \/\/ ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))\n-            exp = exp - (FloatConsts.SIGNIFICAND_WIDTH-1);\n-            if (exp >= Float.MIN_EXPONENT) {\n-                return powerOfTwoF(exp);\n-            } else {\n-                \/\/ return a subnormal result; left shift integer\n-                \/\/ representation of FloatConsts.MIN_VALUE appropriate\n-                \/\/ number of positions\n-                return Float.intBitsToFloat(1 <<\n-                (exp - (Float.MIN_EXPONENT - (FloatConsts.SIGNIFICAND_WIDTH-1)) ));\n+                \/\/ ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))\n+                exp = exp - (FloatConsts.SIGNIFICAND_WIDTH - 1);\n+                if (exp >= Float.MIN_EXPONENT) {\n+                    yield powerOfTwoF(exp);\n+                } else {\n+                    \/\/ return a subnormal result; left shift integer\n+                    \/\/ representation of FloatConsts.MIN_VALUE appropriate\n+                    \/\/ number of positions\n+                    yield Float.intBitsToFloat(1 <<\n+                            (exp - (Float.MIN_EXPONENT - (FloatConsts.SIGNIFICAND_WIDTH - 1))));\n+                }\n@@ -2001,1 +1994,1 @@\n-        }\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":35,"deletions":42,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.util.StaticProperty;\n+\n@@ -30,0 +32,3 @@\n+import java.nio.charset.Charset;\n+import java.nio.charset.UnsupportedCharsetException;\n+import java.util.Objects;\n@@ -60,0 +65,4 @@\n+ * The I\/O streams of characters and lines can be written and read using the methods\n+ * {@link #outputWriter()}, {@link #outputWriter(Charset)}},\n+ * {@link #inputReader()}, {@link #inputReader(Charset)},\n+ * {@link #errorReader()}, and {@link #errorReader(Charset)}.\n@@ -93,0 +102,10 @@\n+\n+    \/\/ Readers and Writers created for this process; so repeated calls return the same object\n+    \/\/ All updates must be done while synchronized on this Process.\n+    private BufferedWriter outputWriter;\n+    private Charset outputCharset;\n+    private BufferedReader inputReader;\n+    private Charset inputCharset;\n+    private BufferedReader errorReader;\n+    private Charset errorCharset;\n+\n@@ -109,1 +128,7 @@\n-     * <p>Implementation note: It is a good idea for the returned\n+     * @apiNote\n+     * When writing to both {@link #getOutputStream()} and either {@link #outputWriter()}\n+     * or {@link #outputWriter(Charset)}, {@link BufferedWriter#flush BufferedWriter.flush}\n+     * should be called before writes to the {@code OutputStream}.\n+     *\n+     * @implNote\n+     * Implementation note: It is a good idea for the returned\n@@ -135,1 +160,6 @@\n-     * <p>Implementation note: It is a good idea for the returned\n+     * @apiNote\n+     * Use {@link #getInputStream} and {@link #inputReader} with extreme care.\n+     * The {@code BufferedReader} may have buffered input from the input stream.\n+     *\n+     * @implNote\n+     * Implementation note: It is a good idea for the returned\n@@ -156,1 +186,6 @@\n-     * <p>Implementation note: It is a good idea for the returned\n+     * @apiNote\n+     * Use {@link #getInputStream} and {@link #inputReader} with extreme care.\n+     * The {@code BufferedReader} may have buffered input from the input stream.\n+     *\n+     * @implNote\n+     * Implementation note: It is a good idea for the returned\n@@ -164,0 +199,216 @@\n+    \/**\n+     * Returns a {@link BufferedReader BufferedReader} connected to the standard\n+     * output of the process. The {@link Charset} for the native encoding is used\n+     * to read characters, lines, or stream lines from standard output.\n+     *\n+     * <p>This method delegates to {@link #inputReader(Charset)} using the\n+     * {@link Charset} named by the {@code native.encoding} system property.\n+     * If the {@code native.encoding} is not a valid charset name or not supported\n+     * the {@link Charset#defaultCharset()} is used.\n+     *\n+     * @return a {@link BufferedReader BufferedReader} using the\n+     *          {@code native.encoding} if supported, otherwise, the\n+     *          {@link Charset#defaultCharset()}\n+     * @since 17\n+     *\/\n+    public final BufferedReader inputReader() {\n+        return inputReader(CharsetHolder.nativeCharset());\n+    }\n+\n+    \/**\n+     * Returns a {@link BufferedReader BufferedReader} connected to the\n+     * standard output of this process using a Charset.\n+     * The {@code BufferedReader} can be used to read characters, lines,\n+     * or stream lines of the standard output.\n+     *\n+     * <p>Characters are read by an InputStreamReader that reads and decodes bytes\n+     * from this process {@link #getInputStream()}. Bytes are decoded to characters\n+     * using the {@code charset}; malformed-input and unmappable-character\n+     * sequences are replaced with the charset's default replacement.\n+     * The {@code BufferedReader} reads and buffers characters from the InputStreamReader.\n+     *\n+     * <p>The first call to this method creates the {@link BufferedReader BufferedReader},\n+     * if called again with the same {@code charset} the same {@code BufferedReader} is returned.\n+     * It is an error to call this method again with a different {@code charset}.\n+     *\n+     * <p>If the standard output of the process has been redirected using\n+     * {@link ProcessBuilder#redirectOutput(Redirect) ProcessBuilder.redirectOutput}\n+     * then the {@code InputStreamReader} will be reading from a\n+     * <a href=\"ProcessBuilder.html#redirect-output\">null input stream<\/a>.\n+     *\n+     * <p>Otherwise, if the standard error of the process has been redirected using\n+     * {@link ProcessBuilder#redirectErrorStream(boolean)\n+     * ProcessBuilder.redirectErrorStream} then the input reader returned by\n+     * this method will receive the merged standard output and the standard error\n+     * of the process.\n+     *\n+     * @apiNote\n+     * Using both {@link #getInputStream} and {@link #inputReader(Charset)} has\n+     * unpredictable behavior since the buffered reader reads ahead from the\n+     * input stream.\n+     *\n+     * <p>When the process has terminated, and the standard input has not been redirected,\n+     * reading of the bytes available from the underlying stream is on a best effort basis and\n+     * may be unpredictable.\n+     *\n+     * @param charset the {@code Charset} used to decode bytes to characters\n+     * @return a {@code BufferedReader} for the standard output of the process using the {@code charset}\n+     * @throws NullPointerException if the {@code charset} is {@code null}\n+     * @throws IllegalStateException if called more than once with different charset arguments\n+     * @since 17\n+     *\/\n+    public final BufferedReader inputReader(Charset charset) {\n+        Objects.requireNonNull(charset, \"charset\");\n+        synchronized (this) {\n+            if (inputReader == null) {\n+                inputCharset = charset;\n+                inputReader = new BufferedReader(new InputStreamReader(getInputStream(), charset));\n+            } else {\n+                if (!inputCharset.equals(charset))\n+                    throw new IllegalStateException(\"BufferedReader was created with charset: \" + inputCharset);\n+            }\n+            return inputReader;\n+        }\n+    }\n+\n+    \/**\n+     * Returns a {@link BufferedReader BufferedReader} connected to the standard\n+     * error of the process. The {@link Charset} for the native encoding is used\n+     * to read characters, lines, or stream lines from standard error.\n+     *\n+     * <p>This method delegates to {@link #errorReader(Charset)} using the\n+     * {@link Charset} named by the {@code native.encoding} system property.\n+     * If the {@code native.encoding} is not a valid charset name or not supported\n+     * the {@link Charset#defaultCharset()} is used.\n+     *\n+     * @return a {@link BufferedReader BufferedReader} using the\n+     *          {@code native.encoding} if supported, otherwise, the\n+     *          {@link Charset#defaultCharset()}\n+     * @since 17\n+     *\/\n+    public final BufferedReader errorReader() {\n+        return errorReader(CharsetHolder.nativeCharset());\n+    }\n+\n+    \/**\n+     * Returns a {@link BufferedReader BufferedReader} connected to the\n+     * standard error of this process using a Charset.\n+     * The {@code BufferedReader} can be used to read characters, lines,\n+     * or stream lines of the standard error.\n+     *\n+     * <p>Characters are read by an InputStreamReader that reads and decodes bytes\n+     * from this process {@link #getErrorStream()}. Bytes are decoded to characters\n+     * using the {@code charset}; malformed-input and unmappable-character\n+     * sequences are replaced with the charset's default replacement.\n+     * The {@code BufferedReader} reads and buffers characters from the InputStreamReader.\n+     *\n+     * <p>The first call to this method creates the {@link BufferedReader BufferedReader},\n+     * if called again with the same {@code charset} the same {@code BufferedReader} is returned.\n+     * It is an error to call this method again with a different {@code charset}.\n+     *\n+     * <p>If the standard error of the process has been redirected using\n+     * {@link ProcessBuilder#redirectError(Redirect) ProcessBuilder.redirectError} or\n+     * {@link ProcessBuilder#redirectErrorStream(boolean) ProcessBuilder.redirectErrorStream}\n+     * then the {@code InputStreamReader} will be reading from a\n+     * <a href=\"ProcessBuilder.html#redirect-output\">null input stream<\/a>.\n+     *\n+     * @apiNote\n+     * Using both {@link #getErrorStream} and {@link #errorReader(Charset)} has\n+     * unpredictable behavior since the buffered reader reads ahead from the\n+     * error stream.\n+     *\n+     * <p>When the process has terminated, and the standard error has not been redirected,\n+     * reading of the bytes available from the underlying stream is on a best effort basis and\n+     * may be unpredictable.\n+     *\n+     * @param charset the {@code Charset} used to decode bytes to characters\n+     * @return a {@code BufferedReader} for the standard error of the process using the {@code charset}\n+     * @throws NullPointerException if the {@code charset} is {@code null}\n+     * @throws IllegalStateException if called more than once with different charset arguments\n+     * @since 17\n+     *\/\n+    public final BufferedReader errorReader(Charset charset) {\n+        Objects.requireNonNull(charset, \"charset\");\n+        synchronized (this) {\n+            if (errorReader == null) {\n+                errorCharset = charset;\n+                errorReader = new BufferedReader(new InputStreamReader(getErrorStream(), charset));\n+            } else {\n+                if (!errorCharset.equals(charset))\n+                    throw new IllegalStateException(\"BufferedReader was created with charset: \" + errorCharset);\n+            }\n+            return errorReader;\n+        }\n+    }\n+\n+    \/**\n+     * Returns a {@code BufferedWriter} connected to the normal input of the process\n+     * using the native encoding.\n+     * Writes text to a character-output stream, buffering characters so as to provide\n+     * for the efficient writing of single characters, arrays, and strings.\n+     *\n+     * <p>This method delegates to {@link #outputWriter(Charset)} using the\n+     * {@link Charset} named by the {@code native.encoding} system property.\n+     * If the {@code native.encoding} is not a valid charset name or not supported\n+     * the {@link Charset#defaultCharset()} is used.\n+     *\n+     * @return a {@code BufferedWriter} to the standard input of the process using the charset\n+     *          for the {@code native.encoding} system property\n+     * @since 17\n+     *\/\n+    public final BufferedWriter outputWriter() {\n+        return outputWriter(CharsetHolder.nativeCharset());\n+    }\n+\n+    \/**\n+     * Returns a {@code BufferedWriter} connected to the normal input of the process\n+     * using a Charset.\n+     * Writes text to a character-output stream, buffering characters so as to provide\n+     * for the efficient writing of single characters, arrays, and strings.\n+     *\n+     * <p>Characters written by the writer are encoded to bytes using {@link OutputStreamWriter}\n+     * and the {@link Charset} are written to the standard input of the process represented\n+     * by this {@code Process}.\n+     * Malformed-input and unmappable-character sequences are replaced with the charset's\n+     * default replacement.\n+     *\n+     * <p>The first call to this method creates the {@link BufferedWriter BufferedWriter},\n+     * if called again with the same {@code charset} the same {@code BufferedWriter} is returned.\n+     * It is an error to call this method again with a different {@code charset}.\n+     *\n+     * <p>If the standard input of the process has been redirected using\n+     * {@link ProcessBuilder#redirectInput(Redirect)\n+     * ProcessBuilder.redirectInput} then the {@code OutputStreamWriter} writes to a\n+     * <a href=\"ProcessBuilder.html#redirect-input\">null output stream<\/a>.\n+     *\n+     * @apiNote\n+     * A {@linkplain BufferedWriter} writes characters, arrays of characters, and strings.\n+     * Wrapping the {@link BufferedWriter} with a {@link PrintWriter} provides\n+     * efficient buffering and formatting of primitives and objects as well as support\n+     * for auto-flush on line endings.\n+     * Call the {@link BufferedWriter#flush()} method to flush buffered output to the process.\n+     * <p>\n+     * When writing to both {@link #getOutputStream()} and either {@link #outputWriter()}\n+     * or {@link #outputWriter(Charset)}, {@linkplain BufferedWriter#flush BufferedWriter.flush}\n+     * should be called before writes to the {@code OutputStream}.\n+     *\n+     * @param charset the {@code Charset} to encode characters to bytes\n+     * @return a {@code BufferedWriter} to the standard input of the process using the {@code charset}\n+     * @throws NullPointerException if the {@code charset} is {@code null}\n+     * @throws IllegalStateException if called more than once with different charset arguments\n+     * @since 17\n+     *\/\n+    public final BufferedWriter outputWriter(Charset charset) {\n+        Objects.requireNonNull(charset, \"charset\");\n+        synchronized (this) {\n+            if (outputWriter == null) {\n+                outputCharset = charset;\n+                outputWriter = new BufferedWriter(new OutputStreamWriter(getOutputStream(), charset));\n+            } else {\n+                if (!outputCharset.equals(charset))\n+                    throw new IllegalStateException(\"BufferedWriter was created with charset: \" + outputCharset);\n+            }\n+            return outputWriter;\n+        }\n+    }\n+\n@@ -264,1 +515,1 @@\n-     * {@link ProcessBuilder#start} and {@link Runtime#exec} forcibly terminate\n+     * {@link ProcessBuilder#start()} and {@link Runtime#exec} forcibly terminate\n@@ -295,1 +546,1 @@\n-     * {@link ProcessBuilder#start} and {@link Runtime#exec} return\n+     * {@link ProcessBuilder#start()} and {@link Runtime#exec} return\n@@ -374,1 +625,1 @@\n-     * Processes returned from {@link ProcessBuilder#start} override the\n+     * Processes returned from {@link ProcessBuilder#start()} override the\n@@ -466,1 +717,1 @@\n-     * {@code Process} objects returned by {@link ProcessBuilder#start} and\n+     * {@code Process} objects returned by {@link ProcessBuilder#start()} and\n@@ -592,0 +843,23 @@\n+\n+    \/**\n+     * A nested class to delay looking up the Charset for the native encoding.\n+     *\/\n+    private static class CharsetHolder {\n+        private final static Charset nativeCharset;\n+        static {\n+            Charset cs;\n+            try {\n+                cs = Charset.forName(StaticProperty.nativeEncoding());\n+            } catch (UnsupportedCharsetException uce) {\n+                cs = Charset.defaultCharset();\n+            }\n+            nativeCharset = cs;\n+        }\n+\n+        \/**\n+         * Charset for the native encoding or {@link Charset#defaultCharset().\n+         *\/\n+        static Charset nativeCharset() {\n+            return nativeCharset;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Process.java","additions":282,"deletions":8,"binary":false,"changes":290,"status":"modified"},{"patch":"@@ -75,5 +75,5 @@\n-            case CONSTRUCTOR: validateConstructor(type); break;\n-            case GETTER: validateFieldType(type, false, true); break;\n-            case SETTER: validateFieldType(type, true, true); break;\n-            case STATIC_GETTER: validateFieldType(type, false, false); break;\n-            case STATIC_SETTER: validateFieldType(type, true, false); break;\n+            case CONSTRUCTOR   -> validateConstructor(type);\n+            case GETTER        -> validateFieldType(type, false, true);\n+            case SETTER        -> validateFieldType(type, true, true);\n+            case STATIC_GETTER -> validateFieldType(type, false, false);\n+            case STATIC_SETTER -> validateFieldType(type, true, false);\n@@ -137,21 +137,14 @@\n-        switch (kind) {\n-            case VIRTUAL:\n-            case SPECIAL:\n-            case INTERFACE_VIRTUAL:\n-            case INTERFACE_SPECIAL:\n-                return invocationType.dropParameterTypes(0, 1).descriptorString();\n-            case STATIC:\n-            case INTERFACE_STATIC:\n-                return invocationType.descriptorString();\n-            case CONSTRUCTOR:\n-                return invocationType.changeReturnType(CD_void).descriptorString();\n-            case GETTER:\n-            case STATIC_GETTER:\n-                return invocationType.returnType().descriptorString();\n-            case SETTER:\n-                return invocationType.parameterType(1).descriptorString();\n-            case STATIC_SETTER:\n-                return invocationType.parameterType(0).descriptorString();\n-            default:\n-                throw new IllegalStateException(kind.toString());\n-        }\n+        return switch (kind) {\n+            case VIRTUAL,\n+                 SPECIAL,\n+                 INTERFACE_VIRTUAL,\n+                 INTERFACE_SPECIAL        -> invocationType.dropParameterTypes(0, 1).descriptorString();\n+            case STATIC,\n+                 INTERFACE_STATIC         -> invocationType.descriptorString();\n+            case CONSTRUCTOR              -> invocationType.changeReturnType(CD_void).descriptorString();\n+            case GETTER,\n+                 STATIC_GETTER            -> invocationType.returnType().descriptorString();\n+            case SETTER                   -> invocationType.parameterType(1).descriptorString();\n+            case STATIC_SETTER            -> invocationType.parameterType(0).descriptorString();\n+            default -> throw new IllegalStateException(kind.toString());\n+        };\n@@ -164,24 +157,14 @@\n-        switch (kind) {\n-            case STATIC:\n-            case INTERFACE_STATIC:\n-                return lookup.findStatic(resolvedOwner, name, invocationType);\n-            case INTERFACE_VIRTUAL:\n-            case VIRTUAL:\n-                return lookup.findVirtual(resolvedOwner, name, invocationType.dropParameterTypes(0, 1));\n-            case SPECIAL:\n-            case INTERFACE_SPECIAL:\n-                return lookup.findSpecial(resolvedOwner, name, invocationType.dropParameterTypes(0, 1),\n-                                          lookup.lookupClass());\n-            case CONSTRUCTOR:\n-                return lookup.findConstructor(resolvedOwner, invocationType.changeReturnType(void.class));\n-            case GETTER:\n-                return lookup.findGetter(resolvedOwner, name, invocationType.returnType());\n-            case STATIC_GETTER:\n-                return lookup.findStaticGetter(resolvedOwner, name, invocationType.returnType());\n-            case SETTER:\n-                return lookup.findSetter(resolvedOwner, name, invocationType.parameterType(1));\n-            case STATIC_SETTER:\n-                return lookup.findStaticSetter(resolvedOwner, name, invocationType.parameterType(0));\n-            default:\n-                throw new IllegalStateException(kind.name());\n-        }\n+        return switch (kind) {\n+            case STATIC,\n+                 INTERFACE_STATIC           -> lookup.findStatic(resolvedOwner, name, invocationType);\n+            case VIRTUAL,\n+                 INTERFACE_VIRTUAL          -> lookup.findVirtual(resolvedOwner, name, invocationType.dropParameterTypes(0, 1));\n+            case SPECIAL,\n+                 INTERFACE_SPECIAL          -> lookup.findSpecial(resolvedOwner, name, invocationType.dropParameterTypes(0, 1), lookup.lookupClass());\n+            case CONSTRUCTOR                -> lookup.findConstructor(resolvedOwner, invocationType.changeReturnType(void.class));\n+            case GETTER                     -> lookup.findGetter(resolvedOwner, name, invocationType.returnType());\n+            case STATIC_GETTER              -> lookup.findStaticGetter(resolvedOwner, name, invocationType.returnType());\n+            case SETTER                     -> lookup.findSetter(resolvedOwner, name, invocationType.parameterType(1));\n+            case STATIC_SETTER              -> lookup.findStaticSetter(resolvedOwner, name, invocationType.parameterType(0));\n+            default -> throw new IllegalStateException(kind.name());\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DirectMethodHandleDescImpl.java","additions":33,"deletions":50,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -159,9 +159,7 @@\n-        MethodTypeDesc mtr;\n-        switch (kind) {\n-            case GETTER: mtr = MethodTypeDesc.of(fieldType, owner); break;\n-            case SETTER: mtr = MethodTypeDesc.of(CD_void, owner, fieldType); break;\n-            case STATIC_GETTER: mtr = MethodTypeDesc.of(fieldType); break;\n-            case STATIC_SETTER: mtr = MethodTypeDesc.of(CD_void, fieldType); break;\n-            default:\n-                throw new IllegalArgumentException(kind.toString());\n-        }\n+        MethodTypeDesc mtr = switch (kind) {\n+            case GETTER        -> MethodTypeDesc.of(fieldType, owner);\n+            case SETTER        -> MethodTypeDesc.of(CD_void, owner, fieldType);\n+            case STATIC_GETTER -> MethodTypeDesc.of(fieldType);\n+            case STATIC_SETTER -> MethodTypeDesc.of(CD_void, fieldType);\n+            default -> throw new IllegalArgumentException(kind.toString());\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodHandleDesc.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,6 +56,6 @@\n-    final MethodType invokedType;             \/\/ The type of the invoked method \"(CC)II\"\n-    final Class<?> samBase;                   \/\/ The type of the returned instance \"interface JJ\"\n-    final String samMethodName;               \/\/ Name of the SAM method \"foo\"\n-    final MethodType samMethodType;           \/\/ Type of the SAM method \"(Object)Object\"\n-    final MethodHandle implMethod;            \/\/ Raw method handle for the implementation method\n-    final MethodType implMethodType;          \/\/ Type of the implMethod MethodHandle \"(CC,int)String\"\n+    final MethodType factoryType;             \/\/ The type of the invoked method \"(CC)II\"\n+    final Class<?> interfaceClass;            \/\/ The type of the returned instance \"interface JJ\"\n+    final String interfaceMethodName;         \/\/ Name of the method to implement \"foo\"\n+    final MethodType interfaceMethodType;     \/\/ Type of the method to implement \"(Object)Object\"\n+    final MethodHandle implementation;        \/\/ Raw method handle for the implementation method\n+    final MethodType implMethodType;          \/\/ Type of the implementation MethodHandle \"(CC,int)String\"\n@@ -66,1 +66,1 @@\n-    final MethodType instantiatedMethodType;  \/\/ Instantiated erased functional interface method type \"(Integer)Object\"\n+    final MethodType dynamicMethodType;       \/\/ Dynamically checked method type \"(Integer)Object\"\n@@ -68,2 +68,2 @@\n-    final Class<?>[] markerInterfaces;        \/\/ Additional marker interfaces to be implemented\n-    final MethodType[] additionalBridges;     \/\/ Signatures of additional methods to bridge\n+    final Class<?>[] altInterfaces;           \/\/ Additional interfaces to be implemented\n+    final MethodType[] altMethods;            \/\/ Signatures of additional methods to bridge\n@@ -77,1 +77,1 @@\n-     * @param invokedType Stacked automatically by VM; the signature of the\n+     * @param factoryType Stacked automatically by VM; the signature of the\n@@ -84,15 +84,15 @@\n-     * @param samMethodName Name of the method in the functional interface to\n-     *                      which the lambda or method reference is being\n-     *                      converted, represented as a String.\n-     * @param samMethodType Type of the method in the functional interface to\n-     *                      which the lambda or method reference is being\n-     *                      converted, represented as a MethodType.\n-     * @param implMethod The implementation method which should be called\n-     *                   (with suitable adaptation of argument types, return\n-     *                   types, and adjustment for captured arguments) when\n-     *                   methods of the resulting functional interface instance\n-     *                   are invoked.\n-     * @param instantiatedMethodType The signature of the primary functional\n-     *                               interface method after type variables are\n-     *                               substituted with their instantiation from\n-     *                               the capture site\n+     * @param interfaceMethodName Name of the method in the functional interface to\n+     *                            which the lambda or method reference is being\n+     *                            converted, represented as a String.\n+     * @param interfaceMethodType Type of the method in the functional interface to\n+     *                            which the lambda or method reference is being\n+     *                            converted, represented as a MethodType.\n+     * @param implementation The implementation method which should be called\n+     *                       (with suitable adaptation of argument types, return\n+     *                       types, and adjustment for captured arguments) when\n+     *                       methods of the resulting functional interface instance\n+     *                       are invoked.\n+     * @param dynamicMethodType The signature of the primary functional\n+     *                          interface method after type variables are\n+     *                          substituted with their instantiation from\n+     *                          the capture site\n@@ -102,4 +102,4 @@\n-     * @param markerInterfaces Additional interfaces which the lambda object\n-     *                       should implement.\n-     * @param additionalBridges Method types for additional signatures to be\n-     *                          bridged to the implementation method\n+     * @param altInterfaces Additional interfaces which the lambda object\n+     *                      should implement.\n+     * @param altMethods Method types for additional signatures to be\n+     *                   implemented by invoking the implementation method\n@@ -107,1 +107,4 @@\n-     * invariants are violated\n+     *         invariants are violated\n+     * @throws SecurityException If a security manager is present, and it\n+     *         <a href=\"MethodHandles.Lookup.html#secmgr\">denies access<\/a>\n+     *         from {@code caller} to the package of {@code implementation}.\n@@ -110,8 +113,8 @@\n-                                       MethodType invokedType,\n-                                       String samMethodName,\n-                                       MethodType samMethodType,\n-                                       MethodHandle implMethod,\n-                                       MethodType instantiatedMethodType,\n-                                       boolean isSerializable,\n-                                       Class<?>[] markerInterfaces,\n-                                       MethodType[] additionalBridges)\n+                                        MethodType factoryType,\n+                                        String interfaceMethodName,\n+                                        MethodType interfaceMethodType,\n+                                        MethodHandle implementation,\n+                                        MethodType dynamicMethodType,\n+                                        boolean isSerializable,\n+                                        Class<?>[] altInterfaces,\n+                                        MethodType[] altMethods)\n@@ -119,1 +122,1 @@\n-        if ((caller.lookupModes() & MethodHandles.Lookup.PRIVATE) == 0) {\n+        if (!caller.hasFullPrivilegeAccess()) {\n@@ -126,1 +129,1 @@\n-        this.invokedType = invokedType;\n+        this.factoryType = factoryType;\n@@ -128,1 +131,1 @@\n-        this.samBase = invokedType.returnType();\n+        this.interfaceClass = factoryType.returnType();\n@@ -130,2 +133,2 @@\n-        this.samMethodName = samMethodName;\n-        this.samMethodType  = samMethodType;\n+        this.interfaceMethodName = interfaceMethodName;\n+        this.interfaceMethodType  = interfaceMethodType;\n@@ -133,3 +136,7 @@\n-        this.implMethod = implMethod;\n-        this.implMethodType = implMethod.type();\n-        this.implInfo = caller.revealDirect(implMethod);\n+        this.implementation = implementation;\n+        this.implMethodType = implementation.type();\n+        try {\n+            this.implInfo = caller.revealDirect(implementation); \/\/ may throw SecurityException\n+        } catch (IllegalArgumentException e) {\n+            throw new LambdaConversionException(implementation + \" is not direct or cannot be cracked\");\n+        }\n@@ -150,8 +157,4 @@\n-                \/\/ Classes compiled prior to dynamic nestmate support invokes a private instance\n-                \/\/ method with REF_invokeSpecial.\n-                \/\/\n-                \/\/ invokespecial should only be used to invoke private nestmate constructors.\n-                \/\/ The lambda proxy class will be defined as a nestmate of targetClass.\n-                \/\/ If the method to be invoked is an instance method of targetClass, then\n-                \/\/ convert to use invokevirtual or invokeinterface.\n-                if (targetClass == implClass && !implInfo.getName().equals(\"<init>\")) {\n+                \/\/ Classes compiled prior to dynamic nestmate support invoke a private instance\n+                \/\/ method with REF_invokeSpecial. Newer classes use REF_invokeVirtual or\n+                \/\/ REF_invokeInterface, and we can use that instruction in the lambda class.\n+                if (targetClass == implClass) {\n@@ -174,1 +177,1 @@\n-        this.instantiatedMethodType = instantiatedMethodType;\n+        this.dynamicMethodType = dynamicMethodType;\n@@ -176,2 +179,2 @@\n-        this.markerInterfaces = markerInterfaces;\n-        this.additionalBridges = additionalBridges;\n+        this.altInterfaces = altInterfaces;\n+        this.altMethods = altMethods;\n@@ -179,7 +182,7 @@\n-        if (samMethodName.isEmpty() ||\n-                samMethodName.indexOf('.') >= 0 ||\n-                samMethodName.indexOf(';') >= 0 ||\n-                samMethodName.indexOf('[') >= 0 ||\n-                samMethodName.indexOf('\/') >= 0 ||\n-                samMethodName.indexOf('<') >= 0 ||\n-                samMethodName.indexOf('>') >= 0) {\n+        if (interfaceMethodName.isEmpty() ||\n+                interfaceMethodName.indexOf('.') >= 0 ||\n+                interfaceMethodName.indexOf(';') >= 0 ||\n+                interfaceMethodName.indexOf('[') >= 0 ||\n+                interfaceMethodName.indexOf('\/') >= 0 ||\n+                interfaceMethodName.indexOf('<') >= 0 ||\n+                interfaceMethodName.indexOf('>') >= 0) {\n@@ -188,1 +191,1 @@\n-                    samMethodName));\n+                    interfaceMethodName));\n@@ -191,1 +194,1 @@\n-        if (!samBase.isInterface()) {\n+        if (!interfaceClass.isInterface()) {\n@@ -193,2 +196,2 @@\n-                    \"Functional interface %s is not an interface\",\n-                    samBase.getName()));\n+                    \"%s is not an interface\",\n+                    interfaceClass.getName()));\n@@ -197,1 +200,1 @@\n-        for (Class<?> c : markerInterfaces) {\n+        for (Class<?> c : altInterfaces) {\n@@ -200,1 +203,1 @@\n-                        \"Marker interface %s is not an interface\",\n+                        \"%s is not an interface\",\n@@ -223,3 +226,3 @@\n-        final int capturedArity = invokedType.parameterCount();\n-        final int samArity = samMethodType.parameterCount();\n-        final int instantiatedArity = instantiatedMethodType.parameterCount();\n+        final int capturedArity = factoryType.parameterCount();\n+        final int samArity = interfaceMethodType.parameterCount();\n+        final int dynamicArity = dynamicMethodType.parameterCount();\n@@ -232,1 +235,1 @@\n-        if (instantiatedArity != samArity) {\n+        if (dynamicArity != samArity) {\n@@ -234,1 +237,1 @@\n-                    String.format(\"Incorrect number of parameters for %s method %s; %d instantiated parameters, %d functional interface method parameters\",\n+                    String.format(\"Incorrect number of parameters for %s method %s; %d dynamic parameters, %d functional interface method parameters\",\n@@ -236,1 +239,1 @@\n-                                  instantiatedArity, samArity));\n+                                  dynamicArity, samArity));\n@@ -238,1 +241,1 @@\n-        for (MethodType bridgeMT : additionalBridges) {\n+        for (MethodType bridgeMT : altMethods) {\n@@ -242,1 +245,1 @@\n-                                      bridgeMT, samMethodType));\n+                                      bridgeMT, interfaceMethodType));\n@@ -257,1 +260,1 @@\n-                receiverClass = instantiatedMethodType.parameterType(0);\n+                receiverClass = dynamicMethodType.parameterType(0);\n@@ -262,1 +265,1 @@\n-                receiverClass = invokedType.parameterType(0);\n+                receiverClass = factoryType.parameterType(0);\n@@ -280,1 +283,1 @@\n-            Class<?> capturedParamType = invokedType.parameterType(i);\n+            Class<?> capturedParamType = factoryType.parameterType(i);\n@@ -290,2 +293,2 @@\n-            Class<?> instantiatedParamType = instantiatedMethodType.parameterType(i - capturedArity);\n-            if (!isAdaptableTo(instantiatedParamType, implParamType, true)) {\n+            Class<?> dynamicParamType = dynamicMethodType.parameterType(i - capturedArity);\n+            if (!isAdaptableTo(dynamicParamType, implParamType, true)) {\n@@ -294,1 +297,1 @@\n-                                      i, instantiatedParamType, implParamType));\n+                                      i, dynamicParamType, implParamType));\n@@ -299,1 +302,1 @@\n-        Class<?> expectedType = instantiatedMethodType.returnType();\n+        Class<?> expectedType = dynamicMethodType.returnType();\n@@ -308,2 +311,2 @@\n-        checkDescriptor(samMethodType);\n-        for (MethodType bridgeMT : additionalBridges) {\n+        checkDescriptor(interfaceMethodType);\n+        for (MethodType bridgeMT : altMethods) {\n@@ -314,1 +317,1 @@\n-    \/** Validate that the given descriptor's types are compatible with {@code instantiatedMethodType} **\/\n+    \/** Validate that the given descriptor's types are compatible with {@code dynamicMethodType} **\/\n@@ -316,2 +319,2 @@\n-        for (int i = 0; i < instantiatedMethodType.parameterCount(); i++) {\n-            Class<?> instantiatedParamType = instantiatedMethodType.parameterType(i);\n+        for (int i = 0; i < dynamicMethodType.parameterCount(); i++) {\n+            Class<?> dynamicParamType = dynamicMethodType.parameterType(i);\n@@ -319,3 +322,3 @@\n-            if (!descriptorParamType.isAssignableFrom(instantiatedParamType)) {\n-                String msg = String.format(\"Type mismatch for instantiated parameter %d: %s is not a subtype of %s\",\n-                                           i, instantiatedParamType, descriptorParamType);\n+            if (!descriptorParamType.isAssignableFrom(dynamicParamType)) {\n+                String msg = String.format(\"Type mismatch for dynamic parameter %d: %s is not a subtype of %s\",\n+                                           i, dynamicParamType, descriptorParamType);\n@@ -326,1 +329,1 @@\n-        Class<?> instantiatedReturnType = instantiatedMethodType.returnType();\n+        Class<?> dynamicReturnType = dynamicMethodType.returnType();\n@@ -328,1 +331,1 @@\n-        if (!isAdaptableToAsReturnStrict(instantiatedReturnType, descriptorReturnType)) {\n+        if (!isAdaptableToAsReturnStrict(dynamicReturnType, descriptorReturnType)) {\n@@ -330,1 +333,1 @@\n-                                       instantiatedReturnType, descriptorReturnType);\n+                                       dynamicReturnType, descriptorReturnType);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":100,"deletions":97,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -67,13 +67,8 @@\n-            switch (xtype) {\n-            case L_TYPE:\n-                return bindSingle(type, form, x);  \/\/ Use known fast path.\n-            case I_TYPE:\n-                return (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(I_TYPE_NUM).factory().invokeBasic(type, form, ValueConversions.widenSubword(x));\n-            case J_TYPE:\n-                return (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(J_TYPE_NUM).factory().invokeBasic(type, form, (long) x);\n-            case F_TYPE:\n-                return (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(F_TYPE_NUM).factory().invokeBasic(type, form, (float) x);\n-            case D_TYPE:\n-                return (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(D_TYPE_NUM).factory().invokeBasic(type, form, (double) x);\n-            default : throw newInternalError(\"unexpected xtype: \" + xtype);\n-            }\n+            return switch (xtype) {\n+                case L_TYPE -> bindSingle(type, form, x);  \/\/ Use known fast path.\n+                case I_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(I_TYPE_NUM).factory().invokeBasic(type, form, ValueConversions.widenSubword(x));\n+                case J_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(J_TYPE_NUM).factory().invokeBasic(type, form, (long) x);\n+                case F_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(F_TYPE_NUM).factory().invokeBasic(type, form, (float) x);\n+                case D_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(D_TYPE_NUM).factory().invokeBasic(type, form, (double) x);\n+                default -> throw newInternalError(\"unexpected xtype: \" + xtype);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BoundMethodHandle.java","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -856,8 +856,8 @@\n-            switch (t) {\n-            case 'L': return ALOAD;\n-            case 'I': return ILOAD;\n-            case 'J': return LLOAD;\n-            case 'F': return FLOAD;\n-            case 'D': return DLOAD;\n-            default : throw newInternalError(\"unrecognized type \" + t);\n-            }\n+            return switch (t) {\n+                case 'L' -> ALOAD;\n+                case 'I' -> ILOAD;\n+                case 'J' -> LLOAD;\n+                case 'F' -> FLOAD;\n+                case 'D' -> DLOAD;\n+                default -> throw newInternalError(\"unrecognized type \" + t);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -166,5 +166,5 @@\n-        switch(whichCache) {\n-            case MethodTypeForm.LF_REBIND:   return BOUND_REINVOKER;\n-            case MethodTypeForm.LF_DELEGATE: return DELEGATE;\n-            default:                         return REINVOKER;\n-        }\n+        return switch (whichCache) {\n+            case MethodTypeForm.LF_REBIND   -> BOUND_REINVOKER;\n+            case MethodTypeForm.LF_DELEGATE -> DELEGATE;\n+            default -> REINVOKER;\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DelegatingMethodHandle.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-            switch (refKind) {\n-                case REF_invokeSpecial: {\n+            return switch (refKind) {\n+                case REF_invokeSpecial -> {\n@@ -98,1 +98,1 @@\n-                    return new Special(mtype, lform, member, true, callerClass);\n+                    yield new Special(mtype, lform, member, true, callerClass);\n@@ -100,1 +100,1 @@\n-                case REF_invokeInterface: {\n+                case REF_invokeInterface -> {\n@@ -105,1 +105,1 @@\n-                    return new Interface(mtype, lform, member, true, refc);\n+                    yield new Interface(mtype, lform, member, true, refc);\n@@ -107,1 +107,1 @@\n-                default: {\n+                default -> {\n@@ -109,1 +109,1 @@\n-                    return new DirectMethodHandle(mtype, lform, member, true);\n+                    yield new DirectMethodHandle(mtype, lform, member, true);\n@@ -111,1 +111,1 @@\n-            }\n+            };\n@@ -197,1 +197,0 @@\n-        int which;\n@@ -203,8 +202,8 @@\n-        switch (m.getReferenceKind()) {\n-        case REF_invokeVirtual:    which = LF_INVVIRTUAL;    break;\n-        case REF_invokeStatic:     which = LF_INVSTATIC;     break;\n-        case REF_invokeSpecial:    which = LF_INVSPECIAL;    break;\n-        case REF_invokeInterface:  which = LF_INVINTERFACE;  break;\n-        case REF_newInvokeSpecial: which = LF_NEWINVSPECIAL; break;\n-        default:  throw new InternalError(m.toString());\n-        }\n+        int which = switch (m.getReferenceKind()) {\n+            case REF_invokeVirtual    -> LF_INVVIRTUAL;\n+            case REF_invokeStatic     -> LF_INVSTATIC;\n+            case REF_invokeSpecial    -> LF_INVSPECIAL;\n+            case REF_invokeInterface  -> LF_INVINTERFACE;\n+            case REF_newInvokeSpecial -> LF_NEWINVSPECIAL;\n+            default -> throw new InternalError(m.toString());\n+        };\n@@ -667,8 +666,7 @@\n-        byte formOp;\n-        switch (m.getReferenceKind()) {\n-        case REF_getField:      formOp = AF_GETFIELD;    break;\n-        case REF_putField:      formOp = AF_PUTFIELD;    break;\n-        case REF_getStatic:     formOp = AF_GETSTATIC;   break;\n-        case REF_putStatic:     formOp = AF_PUTSTATIC;   break;\n-        default:  throw new InternalError(m.toString());\n-        }\n+        byte formOp = switch (m.getReferenceKind()) {\n+            case REF_getField  -> AF_GETFIELD;\n+            case REF_putField  -> AF_PUTFIELD;\n+            case REF_getStatic -> AF_GETSTATIC;\n+            case REF_putStatic -> AF_PUTSTATIC;\n+            default -> throw new InternalError(m.toString());\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":23,"deletions":25,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-     * @param invokedType Stacked automatically by VM; the signature of the\n+     * @param factoryType Stacked automatically by VM; the signature of the\n@@ -138,14 +138,14 @@\n-     * @param samMethodName Name of the method in the functional interface to\n-     *                      which the lambda or method reference is being\n-     *                      converted, represented as a String.\n-     * @param samMethodType Type of the method in the functional interface to\n-     *                      which the lambda or method reference is being\n-     *                      converted, represented as a MethodType.\n-     * @param implMethod The implementation method which should be called (with\n-     *                   suitable adaptation of argument types, return types,\n-     *                   and adjustment for captured arguments) when methods of\n-     *                   the resulting functional interface instance are invoked.\n-     * @param instantiatedMethodType The signature of the primary functional\n-     *                               interface method after type variables are\n-     *                               substituted with their instantiation from\n-     *                               the capture site\n+     * @param interfaceMethodName Name of the method in the functional interface to\n+     *                   which the lambda or method reference is being\n+     *                   converted, represented as a String.\n+     * @param interfaceMethodType Type of the method in the functional interface to\n+     *                            which the lambda or method reference is being\n+     *                            converted, represented as a MethodType.\n+     * @param implementation The implementation method which should be called (with\n+     *                       suitable adaptation of argument types, return types,\n+     *                       and adjustment for captured arguments) when methods of\n+     *                       the resulting functional interface instance are invoked.\n+     * @param dynamicMethodType The signature of the primary functional\n+     *                          interface method after type variables are\n+     *                          substituted with their instantiation from\n+     *                          the capture site\n@@ -155,4 +155,4 @@\n-     * @param markerInterfaces Additional interfaces which the lambda object\n-     *                       should implement.\n-     * @param additionalBridges Method types for additional signatures to be\n-     *                          bridged to the implementation method\n+     * @param altInterfaces Additional interfaces which the lambda object\n+     *                      should implement.\n+     * @param altMethods Method types for additional signatures to be\n+     *                   implemented by invoking the implementation method\n@@ -160,1 +160,4 @@\n-     * invariants are violated\n+     *         invariants are violated\n+     * @throws SecurityException If a security manager is present, and it\n+     *         <a href=\"MethodHandles.Lookup.html#secmgr\">denies access<\/a>\n+     *         from {@code caller} to the package of {@code implementation}.\n@@ -163,5 +166,5 @@\n-                                       MethodType invokedType,\n-                                       String samMethodName,\n-                                       MethodType samMethodType,\n-                                       MethodHandle implMethod,\n-                                       MethodType instantiatedMethodType,\n+                                       MethodType factoryType,\n+                                       String interfaceMethodName,\n+                                       MethodType interfaceMethodType,\n+                                       MethodHandle implementation,\n+                                       MethodType dynamicMethodType,\n@@ -169,2 +172,2 @@\n-                                       Class<?>[] markerInterfaces,\n-                                       MethodType[] additionalBridges)\n+                                       Class<?>[] altInterfaces,\n+                                       MethodType[] altMethods)\n@@ -172,3 +175,3 @@\n-        super(caller, invokedType, samMethodName, samMethodType,\n-              implMethod, instantiatedMethodType,\n-              isSerializable, markerInterfaces, additionalBridges);\n+        super(caller, factoryType, interfaceMethodName, interfaceMethodType,\n+              implementation, dynamicMethodType,\n+              isSerializable, altInterfaces, altMethods);\n@@ -178,1 +181,1 @@\n-        constructorType = invokedType.changeReturnType(Void.TYPE);\n+        constructorType = factoryType.changeReturnType(Void.TYPE);\n@@ -180,2 +183,9 @@\n-        useImplMethodHandle = !Modifier.isPublic(implInfo.getModifiers()) &&\n-                              !VerifyAccess.isSamePackage(implClass, implInfo.getDeclaringClass());\n+        \/\/ If the target class invokes a protected method inherited from a\n+        \/\/ superclass in a different package, or does 'invokespecial', the\n+        \/\/ lambda class has no access to the resolved method. Instead, we need\n+        \/\/ to pass the live implementation method handle to the proxy class\n+        \/\/ to invoke directly. (javac prefers to avoid this situation by\n+        \/\/ generating bridges in the target class)\n+        useImplMethodHandle = (Modifier.isProtected(implInfo.getModifiers()) &&\n+                               !VerifyAccess.isSamePackage(implClass, implInfo.getDeclaringClass())) ||\n+                               implKind == H_INVOKESPECIAL;\n@@ -183,1 +193,1 @@\n-        int parameterCount = invokedType.parameterCount();\n+        int parameterCount = factoryType.parameterCount();\n@@ -189,1 +199,1 @@\n-                argDescs[i] = BytecodeDescriptor.unparse(invokedType.parameterType(i));\n+                argDescs[i] = BytecodeDescriptor.unparse(factoryType.parameterType(i));\n@@ -219,1 +229,1 @@\n-        if (invokedType.parameterCount() == 0) {\n+        if (factoryType.parameterCount() == 0) {\n@@ -225,1 +235,1 @@\n-                            invokedType.returnType()));\n+                            factoryType.returnType()));\n@@ -252,1 +262,1 @@\n-                    return new ConstantCallSite(MethodHandles.constant(samBase, inst));\n+                    return new ConstantCallSite(MethodHandles.constant(interfaceClass, inst));\n@@ -259,2 +269,2 @@\n-                MethodHandle mh = caller.findConstructor(innerClass, invokedType.changeReturnType(void.class));\n-                return new ConstantCallSite(mh.asType(invokedType));\n+                MethodHandle mh = caller.findConstructor(innerClass, constructorType);\n+                return new ConstantCallSite(mh.asType(factoryType));\n@@ -281,5 +291,5 @@\n-                                                 samMethodName,\n-                                                 invokedType,\n-                                                 samMethodType,\n-                                                 implMethod,\n-                                                 instantiatedMethodType,\n+                                                 interfaceMethodName,\n+                                                 factoryType,\n+                                                 interfaceMethodType,\n+                                                 implementation,\n+                                                 dynamicMethodType,\n@@ -287,2 +297,2 @@\n-                                                 markerInterfaces,\n-                                                 additionalBridges,\n+                                                 altInterfaces,\n+                                                 altMethods,\n@@ -295,5 +305,5 @@\n-                                                               samMethodName,\n-                                                               invokedType,\n-                                                               samMethodType,\n-                                                               implMethod,\n-                                                               instantiatedMethodType,\n+                                                               interfaceMethodName,\n+                                                               factoryType,\n+                                                               interfaceMethodType,\n+                                                               implementation,\n+                                                               dynamicMethodType,\n@@ -301,2 +311,2 @@\n-                                                               markerInterfaces,\n-                                                               additionalBridges);\n+                                                               altInterfaces,\n+                                                               altMethods);\n@@ -312,7 +322,0 @@\n-     * @implNote The class that is generated does not include signature\n-     * information for exceptions that may be present on the SAM method.\n-     * This is to reduce classfile size, and is harmless as checked exceptions\n-     * are erased anyway, no one will ever compile against this classfile,\n-     * and we make no guarantees about the reflective properties of lambda\n-     * objects.\n-     *\n@@ -325,5 +328,5 @@\n-        String[] interfaces;\n-        String samIntf = samBase.getName().replace('.', '\/');\n-        boolean accidentallySerializable = !isSerializable && Serializable.class.isAssignableFrom(samBase);\n-        if (markerInterfaces.length == 0) {\n-            interfaces = new String[]{samIntf};\n+        String[] interfaceNames;\n+        String interfaceName = interfaceClass.getName().replace('.', '\/');\n+        boolean accidentallySerializable = !isSerializable && Serializable.class.isAssignableFrom(interfaceClass);\n+        if (altInterfaces.length == 0) {\n+            interfaceNames = new String[]{interfaceName};\n@@ -332,5 +335,5 @@\n-            Set<String> itfs = new LinkedHashSet<>(markerInterfaces.length + 1);\n-            itfs.add(samIntf);\n-            for (Class<?> markerInterface : markerInterfaces) {\n-                itfs.add(markerInterface.getName().replace('.', '\/'));\n-                accidentallySerializable |= !isSerializable && Serializable.class.isAssignableFrom(markerInterface);\n+            Set<String> itfs = new LinkedHashSet<>(altInterfaces.length + 1);\n+            itfs.add(interfaceName);\n+            for (Class<?> i : altInterfaces) {\n+                itfs.add(i.getName().replace('.', '\/'));\n+                accidentallySerializable |= !isSerializable && Serializable.class.isAssignableFrom(i);\n@@ -338,1 +341,1 @@\n-            interfaces = itfs.toArray(new String[itfs.size()]);\n+            interfaceNames = itfs.toArray(new String[itfs.size()]);\n@@ -343,1 +346,1 @@\n-                 JAVA_LANG_OBJECT, interfaces);\n+                 JAVA_LANG_OBJECT, interfaceNames);\n@@ -356,1 +359,1 @@\n-        if (invokedType.parameterCount() == 0 && disableEagerInitialization) {\n+        if (factoryType.parameterCount() == 0 && disableEagerInitialization) {\n@@ -361,8 +364,8 @@\n-        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, samMethodName,\n-                                          samMethodType.toMethodDescriptorString(), null, null);\n-        new ForwardingMethodGenerator(mv).generate(samMethodType);\n-\n-        \/\/ Forward the bridges\n-        if (additionalBridges != null) {\n-            for (MethodType mt : additionalBridges) {\n-                mv = cw.visitMethod(ACC_PUBLIC|ACC_BRIDGE, samMethodName,\n+        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, interfaceMethodName,\n+                                          interfaceMethodType.toMethodDescriptorString(), null, null);\n+        new ForwardingMethodGenerator(mv).generate(interfaceMethodType);\n+\n+        \/\/ Forward the altMethods\n+        if (altMethods != null) {\n+            for (MethodType mt : altMethods) {\n+                mv = cw.visitMethod(ACC_PUBLIC, interfaceMethodName,\n@@ -401,8 +404,1 @@\n-                \/\/ If the target class invokes a method reference this::m which is\n-                \/\/ resolved to a protected method inherited from a superclass in a different\n-                \/\/ package, the target class does not have a bridge and this method reference\n-                \/\/ has been changed from public to protected after the target class was compiled.\n-                \/\/ This lambda proxy class has no access to the resolved method.\n-                \/\/ So this workaround by passing the live implMethod method handle\n-                \/\/ to the proxy class to invoke directly.\n-                lookup = caller.defineHiddenClassWithClassData(classBytes, implMethod, !disableEagerInitialization,\n+                lookup = caller.defineHiddenClassWithClassData(classBytes, implementation, !disableEagerInitialization,\n@@ -425,1 +421,1 @@\n-        String lambdaTypeDescriptor = invokedType.returnType().descriptorString();\n+        String lambdaTypeDescriptor = factoryType.returnType().descriptorString();\n@@ -438,1 +434,1 @@\n-        assert invokedType.parameterCount() == 0;\n+        assert factoryType.parameterCount() == 0;\n@@ -458,1 +454,1 @@\n-        int parameterCount = invokedType.parameterCount();\n+        int parameterCount = factoryType.parameterCount();\n@@ -461,1 +457,1 @@\n-            Class<?> argType = invokedType.parameterType(i);\n+            Class<?> argType = factoryType.parameterType(i);\n@@ -486,3 +482,3 @@\n-        mv.visitLdcInsn(invokedType.returnType().getName().replace('.', '\/'));\n-        mv.visitLdcInsn(samMethodName);\n-        mv.visitLdcInsn(samMethodType.toMethodDescriptorString());\n+        mv.visitLdcInsn(factoryType.returnType().getName().replace('.', '\/'));\n+        mv.visitLdcInsn(interfaceMethodName);\n+        mv.visitLdcInsn(interfaceMethodType.toMethodDescriptorString());\n@@ -493,1 +489,1 @@\n-        mv.visitLdcInsn(instantiatedMethodType.toMethodDescriptorString());\n+        mv.visitLdcInsn(dynamicMethodType.toMethodDescriptorString());\n@@ -595,1 +591,1 @@\n-            int captureArity = invokedType.parameterCount();\n+            int captureArity = factoryType.parameterCount();\n@@ -600,1 +596,1 @@\n-                convertType(argType, implMethodType.parameterType(captureArity + i), instantiatedMethodType.parameterType(i));\n+                convertType(argType, implMethodType.parameterType(captureArity + i), dynamicMethodType.parameterType(i));\n@@ -605,14 +601,8 @@\n-            switch (implKind) {\n-                case MethodHandleInfo.REF_invokeStatic:\n-                    return INVOKESTATIC;\n-                case MethodHandleInfo.REF_newInvokeSpecial:\n-                    return INVOKESPECIAL;\n-                 case MethodHandleInfo.REF_invokeVirtual:\n-                    return INVOKEVIRTUAL;\n-                case MethodHandleInfo.REF_invokeInterface:\n-                    return INVOKEINTERFACE;\n-                case MethodHandleInfo.REF_invokeSpecial:\n-                    return INVOKESPECIAL;\n-                default:\n-                    throw new InternalError(\"Unexpected invocation kind: \" + implKind);\n-            }\n+            return switch (implKind) {\n+                case MethodHandleInfo.REF_invokeStatic     -> INVOKESTATIC;\n+                case MethodHandleInfo.REF_newInvokeSpecial -> INVOKESPECIAL;\n+                case MethodHandleInfo.REF_invokeVirtual    -> INVOKEVIRTUAL;\n+                case MethodHandleInfo.REF_invokeInterface  -> INVOKEINTERFACE;\n+                case MethodHandleInfo.REF_invokeSpecial    -> INVOKESPECIAL;\n+                default -> throw new InternalError(\"Unexpected invocation kind: \" + implKind);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":104,"deletions":114,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -495,9 +495,8 @@\n-        switch (type) {\n-            case I_TYPE: return Opcodes.ILOAD;\n-            case J_TYPE: return Opcodes.LLOAD;\n-            case F_TYPE: return Opcodes.FLOAD;\n-            case D_TYPE: return Opcodes.DLOAD;\n-            case L_TYPE: return Opcodes.ALOAD;\n-            default:\n-                throw new InternalError(\"unknown type: \" + type);\n-        }\n+        return switch (type) {\n+            case I_TYPE -> Opcodes.ILOAD;\n+            case J_TYPE -> Opcodes.LLOAD;\n+            case F_TYPE -> Opcodes.FLOAD;\n+            case D_TYPE -> Opcodes.DLOAD;\n+            case L_TYPE -> Opcodes.ALOAD;\n+            default -> throw new InternalError(\"unknown type: \" + type);\n+        };\n@@ -515,9 +514,8 @@\n-        switch (type) {\n-            case I_TYPE: return Opcodes.ISTORE;\n-            case J_TYPE: return Opcodes.LSTORE;\n-            case F_TYPE: return Opcodes.FSTORE;\n-            case D_TYPE: return Opcodes.DSTORE;\n-            case L_TYPE: return Opcodes.ASTORE;\n-            default:\n-                throw new InternalError(\"unknown type: \" + type);\n-        }\n+        return switch (type) {\n+            case I_TYPE -> Opcodes.ISTORE;\n+            case J_TYPE -> Opcodes.LSTORE;\n+            case F_TYPE -> Opcodes.FSTORE;\n+            case D_TYPE -> Opcodes.DSTORE;\n+            case L_TYPE -> Opcodes.ASTORE;\n+            default -> throw new InternalError(\"unknown type: \" + type);\n+        };\n@@ -530,12 +528,12 @@\n-        switch (elementType) {\n-            case BOOLEAN: return Opcodes.T_BOOLEAN;\n-            case BYTE:    return Opcodes.T_BYTE;\n-            case CHAR:    return Opcodes.T_CHAR;\n-            case SHORT:   return Opcodes.T_SHORT;\n-            case INT:     return Opcodes.T_INT;\n-            case LONG:    return Opcodes.T_LONG;\n-            case FLOAT:   return Opcodes.T_FLOAT;\n-            case DOUBLE:  return Opcodes.T_DOUBLE;\n-            case OBJECT:  return 0; \/\/ in place of Opcodes.T_OBJECT\n-            default:      throw new InternalError();\n-        }\n+        return (byte) switch (elementType) {\n+            case BOOLEAN -> Opcodes.T_BOOLEAN;\n+            case BYTE    -> Opcodes.T_BYTE;\n+            case CHAR    -> Opcodes.T_CHAR;\n+            case SHORT   -> Opcodes.T_SHORT;\n+            case INT     -> Opcodes.T_INT;\n+            case LONG    -> Opcodes.T_LONG;\n+            case FLOAT   -> Opcodes.T_FLOAT;\n+            case DOUBLE  -> Opcodes.T_DOUBLE;\n+            case OBJECT  -> 0; \/\/ in place of Opcodes.T_OBJECT\n+            default -> throw new InternalError();\n+        };\n@@ -546,13 +544,12 @@\n-        int xas;\n-        switch (tcode) {\n-            case Opcodes.T_BOOLEAN: xas = Opcodes.BASTORE; break;\n-            case Opcodes.T_BYTE:    xas = Opcodes.BASTORE; break;\n-            case Opcodes.T_CHAR:    xas = Opcodes.CASTORE; break;\n-            case Opcodes.T_SHORT:   xas = Opcodes.SASTORE; break;\n-            case Opcodes.T_INT:     xas = Opcodes.IASTORE; break;\n-            case Opcodes.T_LONG:    xas = Opcodes.LASTORE; break;\n-            case Opcodes.T_FLOAT:   xas = Opcodes.FASTORE; break;\n-            case Opcodes.T_DOUBLE:  xas = Opcodes.DASTORE; break;\n-            case 0:                 xas = Opcodes.AASTORE; break;\n-            default:      throw new InternalError();\n-        }\n+        int xas = switch (tcode) {\n+            case Opcodes.T_BOOLEAN -> Opcodes.BASTORE;\n+            case Opcodes.T_BYTE    -> Opcodes.BASTORE;\n+            case Opcodes.T_CHAR    -> Opcodes.CASTORE;\n+            case Opcodes.T_SHORT   -> Opcodes.SASTORE;\n+            case Opcodes.T_INT     -> Opcodes.IASTORE;\n+            case Opcodes.T_LONG    -> Opcodes.LASTORE;\n+            case Opcodes.T_FLOAT   -> Opcodes.FASTORE;\n+            case Opcodes.T_DOUBLE  -> Opcodes.DASTORE;\n+            case 0                 -> Opcodes.AASTORE;\n+            default -> throw new InternalError();\n+        };\n@@ -1386,11 +1383,5 @@\n-        switch (type) {\n-            case I_TYPE:\n-            case F_TYPE:\n-            case L_TYPE:\n-                return Opcodes.POP;\n-            case J_TYPE:\n-            case D_TYPE:\n-                return Opcodes.POP2;\n-            default:\n-                throw new InternalError(\"unknown type: \" + type);\n-        }\n+        return switch (type) {\n+            case I_TYPE, F_TYPE, L_TYPE -> Opcodes.POP;\n+            case J_TYPE, D_TYPE         -> Opcodes.POP2;\n+            default -> throw new InternalError(\"unknown type: \" + type);\n+        };\n@@ -1666,8 +1657,8 @@\n-        switch (type) {\n-            case I_TYPE: mv.visitInsn(Opcodes.ICONST_0); break;\n-            case J_TYPE: mv.visitInsn(Opcodes.LCONST_0); break;\n-            case F_TYPE: mv.visitInsn(Opcodes.FCONST_0); break;\n-            case D_TYPE: mv.visitInsn(Opcodes.DCONST_0); break;\n-            case L_TYPE: mv.visitInsn(Opcodes.ACONST_NULL); break;\n-            default: throw new InternalError(\"unknown type: \" + type);\n-        }\n+        mv.visitInsn(switch (type) {\n+            case I_TYPE -> Opcodes.ICONST_0;\n+            case J_TYPE -> Opcodes.LCONST_0;\n+            case F_TYPE -> Opcodes.FCONST_0;\n+            case D_TYPE -> Opcodes.DCONST_0;\n+            case L_TYPE -> Opcodes.ACONST_NULL;\n+            default -> throw new InternalError(\"unknown type: \" + type);\n+        });\n@@ -1781,5 +1772,6 @@\n-                case LONG:\n-                    switch (to) {\n-                    case FLOAT:   mv.visitInsn(Opcodes.L2F);  break;\n-                    case DOUBLE:  mv.visitInsn(Opcodes.L2D);  break;\n-                    default:      error = true;               break;\n+                    case LONG -> {\n+                        switch (to) {\n+                            case FLOAT  -> mv.visitInsn(Opcodes.L2F);\n+                            case DOUBLE -> mv.visitInsn(Opcodes.L2D);\n+                            default -> error = true;\n+                        }\n@@ -1787,6 +1779,6 @@\n-                    break;\n-                case FLOAT:\n-                    switch (to) {\n-                    case LONG :   mv.visitInsn(Opcodes.F2L);  break;\n-                    case DOUBLE:  mv.visitInsn(Opcodes.F2D);  break;\n-                    default:      error = true;               break;\n+                    case FLOAT -> {\n+                        switch (to) {\n+                            case LONG   -> mv.visitInsn(Opcodes.F2L);\n+                            case DOUBLE -> mv.visitInsn(Opcodes.F2D);\n+                            default -> error = true;\n+                        }\n@@ -1794,6 +1786,6 @@\n-                    break;\n-                case DOUBLE:\n-                    switch (to) {\n-                    case LONG :   mv.visitInsn(Opcodes.D2L);  break;\n-                    case FLOAT:   mv.visitInsn(Opcodes.D2F);  break;\n-                    default:      error = true;               break;\n+                    case DOUBLE -> {\n+                        switch (to) {\n+                            case LONG  -> mv.visitInsn(Opcodes.D2L);\n+                            case FLOAT -> mv.visitInsn(Opcodes.D2F);\n+                            default -> error = true;\n+                        }\n@@ -1801,4 +1793,1 @@\n-                    break;\n-                default:\n-                    error = true;\n-                    break;\n+                    default -> error = true;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":72,"deletions":83,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -257,6 +257,5 @@\n-        int which;\n-        switch (name) {\n-            case \"invokeExact\":  which = MethodTypeForm.LF_EX_LINKER; break;\n-            case \"invoke\":       which = MethodTypeForm.LF_GEN_LINKER; break;\n-            default:             throw new InternalError(\"not invoker: \"+name);\n-        }\n+        int which = switch (name) {\n+            case \"invokeExact\" -> MethodTypeForm.LF_EX_LINKER;\n+            case \"invoke\"      -> MethodTypeForm.LF_GEN_LINKER;\n+            default -> throw new InternalError(\"not invoker: \" + name);\n+        };\n@@ -663,18 +662,10 @@\n-            switch (func) {\n-                case NF_checkExactType:\n-                    return getNamedFunction(\"checkExactType\", MethodType.methodType(void.class, MethodHandle.class, MethodType.class));\n-                case NF_checkGenericType:\n-                    return getNamedFunction(\"checkGenericType\", MethodType.methodType(MethodHandle.class, MethodHandle.class, MethodType.class));\n-                case NF_getCallSiteTarget:\n-                    return getNamedFunction(\"getCallSiteTarget\", MethodType.methodType(MethodHandle.class, CallSite.class));\n-                case NF_checkCustomized:\n-                    return getNamedFunction(\"checkCustomized\", MethodType.methodType(void.class, MethodHandle.class));\n-                case NF_checkVarHandleGenericType:\n-                    return getNamedFunction(\"checkVarHandleGenericType\", MethodType.methodType(MethodHandle.class, VarHandle.class, VarHandle.AccessDescriptor.class));\n-                case NF_checkVarHandleExactType:\n-                    return getNamedFunction(\"checkVarHandleExactType\", MethodType.methodType(MethodHandle.class, VarHandle.class, VarHandle.AccessDescriptor.class));\n-                case NF_directVarHandleTarget:\n-                    return getNamedFunction(\"directVarHandleTarget\", MethodType.methodType(VarHandle.class, VarHandle.class));\n-                default:\n-                    throw newInternalError(\"Unknown function: \" + func);\n-            }\n+            return switch (func) {\n+                case NF_checkExactType            -> getNamedFunction(\"checkExactType\", MethodType.methodType(void.class, MethodHandle.class, MethodType.class));\n+                case NF_checkGenericType          -> getNamedFunction(\"checkGenericType\", MethodType.methodType(MethodHandle.class, MethodHandle.class, MethodType.class));\n+                case NF_getCallSiteTarget         -> getNamedFunction(\"getCallSiteTarget\", MethodType.methodType(MethodHandle.class, CallSite.class));\n+                case NF_checkCustomized           -> getNamedFunction(\"checkCustomized\", MethodType.methodType(void.class, MethodHandle.class));\n+                case NF_checkVarHandleGenericType -> getNamedFunction(\"checkVarHandleGenericType\", MethodType.methodType(MethodHandle.class, VarHandle.class, VarHandle.AccessDescriptor.class));\n+                case NF_checkVarHandleExactType   -> getNamedFunction(\"checkVarHandleExactType\", MethodType.methodType(MethodHandle.class, VarHandle.class, VarHandle.AccessDescriptor.class));\n+                case NF_directVarHandleTarget     -> getNamedFunction(\"directVarHandleTarget\", MethodType.methodType(VarHandle.class, VarHandle.class));\n+                default -> throw newInternalError(\"Unknown function: \" + func);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/Invokers.java","additions":15,"deletions":24,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -190,7 +190,7 @@\n-            switch (type) {\n-                case 'L': return L_TYPE;\n-                case 'I': return I_TYPE;\n-                case 'J': return J_TYPE;\n-                case 'F': return F_TYPE;\n-                case 'D': return D_TYPE;\n-                case 'V': return V_TYPE;\n+            return switch (type) {\n+                case 'L' -> L_TYPE;\n+                case 'I' -> I_TYPE;\n+                case 'J' -> J_TYPE;\n+                case 'F' -> F_TYPE;\n+                case 'D' -> D_TYPE;\n+                case 'V' -> V_TYPE;\n@@ -198,8 +198,3 @@\n-                case 'Z':\n-                case 'B':\n-                case 'S':\n-                case 'C':\n-                    return I_TYPE;\n-                default:\n-                    throw newInternalError(\"Unknown type char: '\"+type+\"'\");\n-            }\n+                case 'Z', 'B', 'S', 'C' -> I_TYPE;\n+                default -> throw newInternalError(\"Unknown type char: '\" + type + \"'\");\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import java.lang.reflect.Array;\n+import java.util.Objects;\n@@ -42,1 +44,1 @@\n- *     <li><em>Linkage<\/em> occurs when the methods in this class are invoked.\n+ *     <li><p><em>Linkage<\/em> occurs when the methods in this class are invoked.\n@@ -46,7 +48,4 @@\n- *     method handle describing the desired implementation behavior\n- *     for that method, and possibly other additional metadata, and produce a\n- *     {@link CallSite} whose target can be used to create suitable function\n- *     objects.  Linkage may involve dynamically loading a new class that\n- *     implements the target interface. The {@code CallSite} can be considered a\n- *     \"factory\" for function objects and so these linkage methods are referred\n- *     to as \"metafactories\".<\/li>\n+ *     {@linkplain MethodHandleInfo direct method handle} describing the desired\n+ *     implementation behavior for that method, and possibly other additional\n+ *     metadata, and produce a {@link CallSite} whose target can be used to\n+ *     create suitable function objects.\n@@ -54,1 +53,8 @@\n- *     <li><em>Capture<\/em> occurs when the {@code CallSite}'s target is\n+ *     <p>Linkage may involve dynamically loading a new class that implements\n+ *     the target interface, or re-using a suitable existing class.\n+ *\n+ *     <p>The {@code CallSite} can be considered a \"factory\" for function\n+ *     objects and so these linkage methods are referred to as\n+ *     \"metafactories\".<\/li>\n+ *\n+ *     <li><p><em>Capture<\/em> occurs when the {@code CallSite}'s target is\n@@ -56,15 +62,8 @@\n- *     producing a function object.  This may occur many times for\n- *     a single factory {@code CallSite}.  Capture may involve allocation of a\n- *     new function object, or may return an existing function object.  The\n- *     behavior {@code MethodHandle} may have additional parameters beyond those\n- *     of the specified interface method; these are referred to as <em>captured\n- *     parameters<\/em>, which must be provided as arguments to the\n- *     {@code CallSite} target, and which may be early-bound to the behavior\n- *     {@code MethodHandle}.  The number of captured parameters and their types\n- *     are determined during linkage.\n- *     The identity of a function object produced by invoking the\n- *     {@code CallSite}'s target is unpredictable, and therefore\n- *     identity-sensitive operations (such as reference equality, object\n- *     locking, and {@code System.identityHashCode()} may produce different\n- *     results in different implementations, or even upon different invocations\n- *     in the same implementation.<\/li>\n+ *     producing a function object. This may occur many times for\n+ *     a single factory {@code CallSite}.\n+ *\n+ *     <p>If the behavior {@code MethodHandle} has additional parameters beyond\n+ *     those of the specified interface method, these are referred to as\n+ *     <em>captured parameters<\/em>, which must be provided as arguments to the\n+ *     {@code CallSite} target. The expected number and types of captured\n+ *     parameters are determined during linkage.\n@@ -72,5 +71,14 @@\n- *     <li><em>Invocation<\/em> occurs when an implemented interface method\n- *     is invoked on a function object.  This may occur many times for a single\n- *     function object.  The method referenced by the behavior {@code MethodHandle}\n- *     is invoked with the captured arguments and any additional arguments\n- *     provided on invocation, as if by {@link MethodHandle#invoke(Object...)}.<\/li>\n+ *     <p>Capture may involve allocation of a new function object, or may return\n+ *     a suitable existing function object. The identity of a function object\n+ *     produced by capture is unpredictable, and therefore identity-sensitive\n+ *     operations (such as reference equality, object locking, and {@code\n+ *     System.identityHashCode()}) may produce different results in different\n+ *     implementations, or even upon different invocations in the same\n+ *     implementation.<\/li>\n+ *\n+ *     <li><p><em>Invocation<\/em> occurs when an implemented interface method is\n+ *     invoked on a function object. This may occur many times for a single\n+ *     function object. The method referenced by the implementation\n+ *     {@code MethodHandle} is invoked, passing to it the captured arguments and\n+ *     the invocation arguments. The result of the method is returned.\n+ *     <\/li>\n@@ -84,1 +92,1 @@\n- * \"instantiated\" method type; on invocation, the arguments and eventual result\n+ * \"dynamic\" method type; on invocation, the arguments and eventual result\n@@ -97,1 +105,1 @@\n- *     <li><em>Bridging.<\/em>  It is sometimes useful to implement multiple\n+ *     <li><em>Multiple methods.<\/em>  It is sometimes useful to implement multiple\n@@ -124,1 +132,1 @@\n- *      <li>{@code invokedType} (describing the {@code CallSite} signature) has\n+ *      <li>{@code factoryType} (describing the {@code CallSite} signature) has\n@@ -126,1 +134,1 @@\n- *      <li>{@code samMethodType} (describing the implemented method type) has N\n+ *      <li>{@code interfaceMethodType} (describing the implemented method type) has N\n@@ -128,2 +136,2 @@\n- *      <li>{@code implMethod} (the {@code MethodHandle} providing the\n- *      implementation has M parameters, of types (A1..Am) and return type Ra\n+ *      <li>{@code implementation} (the {@code MethodHandle} providing the\n+ *      implementation) has M parameters, of types (A1..Am) and return type Ra\n@@ -133,1 +141,1 @@\n- *      <li>{@code instantiatedMethodType} (allowing restrictions on invocation)\n+ *      <li>{@code dynamicMethodType} (allowing restrictions on invocation)\n@@ -139,3 +147,1 @@\n- *     <li>Rd is an interface<\/li>\n- *     <li>{@code implMethod} is a <em>direct method handle<\/em><\/li>\n- *     <li>{@code samMethodType} and {@code instantiatedMethodType} have the same\n+ *     <li>{@code interfaceMethodType} and {@code dynamicMethodType} have the same\n@@ -153,1 +159,1 @@\n- * <p>Further, at capture time, if {@code implMethod} corresponds to an instance\n+ * <p>Further, at capture time, if {@code implementation} corresponds to an instance\n@@ -221,4 +227,5 @@\n- * @implNote The implementation method is described with a method handle. In\n- * theory, any method handle could be used. Currently supported are direct method\n- * handles representing invocation of virtual, interface, constructor and static\n- * methods.\n+ * <p>The implementation method is described with a direct method handle\n+ * referencing a method or constructor. In theory, any method handle could be\n+ * used, but this is not compatible with some implementation techniques and\n+ * would complicate the work implementations must do.\n+ *\n@@ -231,1 +238,1 @@\n-    \/** Flag for alternate metafactories indicating the lambda object\n+    \/** Flag for {@link #altMetafactory} indicating the lambda object\n@@ -236,3 +243,2 @@\n-     * Flag for alternate metafactories indicating the lambda object implements\n-     * other marker interfaces\n-     * besides Serializable\n+     * Flag for {@link #altMetafactory} indicating the lambda object implements\n+     * other interfaces besides {@code Serializable}\n@@ -244,1 +250,1 @@\n-     * additional bridge methods\n+     * additional methods that invoke the {@code implementation}\n@@ -252,1 +258,1 @@\n-    \/\/ special cased in java.lang.invokeBootstrapMethodInvoker to ensure\n+    \/\/ special cased in java.lang.invoke.BootstrapMethodInvoker to ensure\n@@ -272,3 +278,3 @@\n-     * implements the interface named by the return type of {@code invokedType},\n-     * declares a method with the name given by {@code invokedName} and the\n-     * signature given by {@code samMethodType}.  It may also override additional\n+     * implements the interface named by the return type of {@code factoryType},\n+     * declares a method with the name given by {@code interfaceMethodName} and the\n+     * signature given by {@code interfaceMethodType}.  It may also override additional\n@@ -283,5 +289,5 @@\n-     * @param invokedName The name of the method to implement.  When used with\n-     *                    {@code invokedynamic}, this is provided by the\n-     *                    {@code NameAndType} of the {@code InvokeDynamic}\n-     *                    structure and is stacked automatically by the VM.\n-     * @param invokedType The expected signature of the {@code CallSite}.  The\n+     * @param interfaceMethodName The name of the method to implement.  When used with\n+     *                            {@code invokedynamic}, this is provided by the\n+     *                            {@code NameAndType} of the {@code InvokeDynamic}\n+     *                            structure and is stacked automatically by the VM.\n+     * @param factoryType The expected signature of the {@code CallSite}.  The\n@@ -293,15 +299,11 @@\n-     *                    In the event that the implementation method is an\n-     *                    instance method and this signature has any parameters,\n-     *                    the first parameter in the invocation signature must\n-     *                    correspond to the receiver.\n-     * @param samMethodType Signature and return type of method to be implemented\n-     *                      by the function object.\n-     * @param implMethod A direct method handle describing the implementation\n-     *                   method which should be called (with suitable adaptation\n-     *                   of argument types, return types, and with captured\n-     *                   arguments prepended to the invocation arguments) at\n-     *                   invocation time.\n-     * @param instantiatedMethodType The signature and return type that should\n-     *                               be enforced dynamically at invocation time.\n-     *                               This may be the same as {@code samMethodType},\n-     *                               or may be a specialization of it.\n+     * @param interfaceMethodType Signature and return type of method to be\n+     *                            implemented by the function object.\n+     * @param implementation A direct method handle describing the implementation\n+     *                       method which should be called (with suitable adaptation\n+     *                       of argument types and return types, and with captured\n+     *                       arguments prepended to the invocation arguments) at\n+     *                       invocation time.\n+     * @param dynamicMethodType The signature and return type that should\n+     *                          be enforced dynamically at invocation time.\n+     *                          In simple use cases this is the same as\n+     *                          {@code interfaceMethodType}.\n@@ -309,5 +311,11 @@\n-     *         instances of the interface named by {@code invokedType}\n-     * @throws LambdaConversionException If any of the linkage invariants\n-     *                                   described {@link LambdaMetafactory above}\n-     *                                   are violated, or the lookup context\n-     *                                   does not have private access privileges.\n+     *         instances of the interface named by {@code factoryType}\n+     * @throws LambdaConversionException If {@code caller} does not have full privilege\n+     *         access, or if {@code interfaceMethodName} is not a valid JVM\n+     *         method name, or if the return type of {@code factoryType} is not\n+     *         an interface, or if {@code implementation} is not a direct method\n+     *         handle referencing a method or constructor, or if the linkage\n+     *         invariants are violated, as defined {@link LambdaMetafactory above}.\n+     * @throws NullPointerException If any argument is {@code null}.\n+     * @throws SecurityException If a security manager is present, and it\n+     *         <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n+     *         from {@code caller} to the package of {@code implementation}.\n@@ -316,5 +324,5 @@\n-                                       String invokedName,\n-                                       MethodType invokedType,\n-                                       MethodType samMethodType,\n-                                       MethodHandle implMethod,\n-                                       MethodType instantiatedMethodType)\n+                                       String interfaceMethodName,\n+                                       MethodType factoryType,\n+                                       MethodType interfaceMethodType,\n+                                       MethodHandle implementation,\n+                                       MethodType dynamicMethodType)\n@@ -323,4 +331,9 @@\n-        mf = new InnerClassLambdaMetafactory(caller, invokedType,\n-                                             invokedName, samMethodType,\n-                                             implMethod, instantiatedMethodType,\n-                                             false, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);\n+        mf = new InnerClassLambdaMetafactory(Objects.requireNonNull(caller),\n+                                             Objects.requireNonNull(factoryType),\n+                                             Objects.requireNonNull(interfaceMethodName),\n+                                             Objects.requireNonNull(interfaceMethodType),\n+                                             Objects.requireNonNull(implementation),\n+                                             Objects.requireNonNull(dynamicMethodType),\n+                                             false,\n+                                             EMPTY_CLASS_ARRAY,\n+                                             EMPTY_MT_ARRAY);\n@@ -353,2 +366,2 @@\n-     *                          String invokedName,\n-     *                          MethodType invokedType,\n+     *                          String interfaceMethodName,\n+     *                          MethodType factoryType,\n@@ -362,5 +375,5 @@\n-     *                          String invokedName,\n-     *                          MethodType invokedType,\n-     *                          MethodType samMethodType,\n-     *                          MethodHandle implMethod,\n-     *                          MethodType instantiatedMethodType,\n+     *                          String interfaceMethodName,\n+     *                          MethodType factoryType,\n+     *                          MethodType interfaceMethodType,\n+     *                          MethodHandle implementation,\n+     *                          MethodType dynamicMethodType,\n@@ -368,4 +381,4 @@\n-     *                          int markerInterfaceCount,  \/\/ IF flags has MARKERS set\n-     *                          Class... markerInterfaces, \/\/ IF flags has MARKERS set\n-     *                          int bridgeCount,           \/\/ IF flags has BRIDGES set\n-     *                          MethodType... bridges      \/\/ IF flags has BRIDGES set\n+     *                          int altInterfaceCount,        \/\/ IF flags has MARKERS set\n+     *                          Class... altInterfaces,       \/\/ IF flags has MARKERS set\n+     *                          int altMethodCount,           \/\/ IF flags has BRIDGES set\n+     *                          MethodType... altMethods      \/\/ IF flags has BRIDGES set\n@@ -383,1 +396,1 @@\n-     *     <li>{@code markerInterfaceCount} is the number of additional interfaces\n+     *     <li>{@code altInterfaceCount} is the number of additional interfaces\n@@ -386,2 +399,2 @@\n-     *     <li>{@code markerInterfaces} is a variable-length list of additional\n-     *     interfaces to implement, whose length equals {@code markerInterfaceCount},\n+     *     <li>{@code altInterfaces} is a variable-length list of additional\n+     *     interfaces to implement, whose length equals {@code altInterfaceCount},\n@@ -389,1 +402,1 @@\n-     *     <li>{@code bridgeCount} is the number of additional method signatures\n+     *     <li>{@code altMethodCount} is the number of additional method signatures\n@@ -392,2 +405,2 @@\n-     *     <li>{@code bridges} is a variable-length list of additional\n-     *     methods signatures to implement, whose length equals {@code bridgeCount},\n+     *     <li>{@code altMethods} is a variable-length list of additional\n+     *     methods signatures to implement, whose length equals {@code altMethodCount},\n@@ -397,2 +410,2 @@\n-     * <p>Each class named by {@code markerInterfaces} is subject to the same\n-     * restrictions as {@code Rd}, the return type of {@code invokedType},\n+     * <p>Each class named by {@code altInterfaces} is subject to the same\n+     * restrictions as {@code Rd}, the return type of {@code factoryType},\n@@ -400,2 +413,2 @@\n-     * named by {@code bridges} is subject to the same restrictions as\n-     * {@code samMethodType}, as described {@link LambdaMetafactory above}.\n+     * named by {@code altMethods} is subject to the same restrictions as\n+     * {@code interfaceMethodType}, as described {@link LambdaMetafactory above}.\n@@ -414,4 +427,4 @@\n-     *     of {@code invokedType} and any interfaces named by {@code markerInterfaces}<\/li>\n-     *     <li>The class declares methods with the name given by {@code invokedName},\n-     *     and the signature given by {@code samMethodType} and additional signatures\n-     *     given by {@code bridges}<\/li>\n+     *     of {@code factoryType} and any interfaces named by {@code altInterfaces}<\/li>\n+     *     <li>The class declares methods with the name given by {@code interfaceMethodName},\n+     *     and the signature given by {@code interfaceMethodType} and additional signatures\n+     *     given by {@code altMethods}<\/li>\n@@ -428,5 +441,5 @@\n-     * @param invokedName The name of the method to implement.  When used with\n-     *                    {@code invokedynamic}, this is provided by the\n-     *                    {@code NameAndType} of the {@code InvokeDynamic}\n-     *                    structure and is stacked automatically by the VM.\n-     * @param invokedType The expected signature of the {@code CallSite}.  The\n+     * @param interfaceMethodName The name of the method to implement.  When used with\n+     *                            {@code invokedynamic}, this is provided by the\n+     *                            {@code NameAndType} of the {@code InvokeDynamic}\n+     *                            structure and is stacked automatically by the VM.\n+     * @param factoryType The expected signature of the {@code CallSite}.  The\n@@ -438,9 +451,4 @@\n-     *                    In the event that the implementation method is an\n-     *                    instance method and this signature has any parameters,\n-     *                    the first parameter in the invocation signature must\n-     *                    correspond to the receiver.\n-     * @param  args       An {@code Object[]} array containing the required\n-     *                    arguments {@code samMethodType}, {@code implMethod},\n-     *                    {@code instantiatedMethodType}, {@code flags}, and any\n-     *                    optional arguments, as described\n-     *                    {@link #altMetafactory(MethodHandles.Lookup, String, MethodType, Object...)} above}\n+     * @param  args An array of {@code Object} containing the required\n+     *              arguments {@code interfaceMethodType}, {@code implementation},\n+     *              {@code dynamicMethodType}, {@code flags}, and any\n+     *              optional arguments, as described above\n@@ -448,5 +456,17 @@\n-     *         instances of the interface named by {@code invokedType}\n-     * @throws LambdaConversionException If any of the linkage invariants\n-     *                                   described {@link LambdaMetafactory above}\n-     *                                   are violated, or the lookup context\n-     *                                   does not have private access privileges.\n+     *         instances of the interface named by {@code factoryType}\n+     * @throws LambdaConversionException If {@code caller} does not have full privilege\n+     *         access, or if {@code interfaceMethodName} is not a valid JVM\n+     *         method name, or if the return type of {@code factoryType} is not\n+     *         an interface, or if any of {@code altInterfaces} is not an\n+     *         interface, or if {@code implementation} is not a direct method\n+     *         handle referencing a method or constructor, or if the linkage\n+     *         invariants are violated, as defined {@link LambdaMetafactory above}.\n+     * @throws NullPointerException If any argument, or any component of {@code args},\n+     *         is {@code null}.\n+     * @throws IllegalArgumentException If the number or types of the components\n+     *         of {@code args} do not follow the above rules, or if\n+     *         {@code altInterfaceCount} or {@code altMethodCount} are negative\n+     *         integers.\n+     * @throws SecurityException If a security manager is present, and it\n+     *         <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n+     *         from {@code caller} to the package of {@code implementation}.\n@@ -455,2 +475,2 @@\n-                                          String invokedName,\n-                                          MethodType invokedType,\n+                                          String interfaceMethodName,\n+                                          MethodType factoryType,\n@@ -459,7 +479,11 @@\n-        MethodType samMethodType = (MethodType)args[0];\n-        MethodHandle implMethod = (MethodHandle)args[1];\n-        MethodType instantiatedMethodType = (MethodType)args[2];\n-        int flags = (Integer) args[3];\n-        Class<?>[] markerInterfaces;\n-        MethodType[] bridges;\n-        int argIndex = 4;\n+        Objects.requireNonNull(caller);\n+        Objects.requireNonNull(interfaceMethodName);\n+        Objects.requireNonNull(factoryType);\n+        Objects.requireNonNull(args);\n+        int argIndex = 0;\n+        MethodType interfaceMethodType = extractArg(args, argIndex++, MethodType.class);\n+        MethodHandle implementation = extractArg(args, argIndex++, MethodHandle.class);\n+        MethodType dynamicMethodType = extractArg(args, argIndex++, MethodType.class);\n+        int flags = extractArg(args, argIndex++, Integer.class);\n+        Class<?>[] altInterfaces = EMPTY_CLASS_ARRAY;\n+        MethodType[] altMethods = EMPTY_MT_ARRAY;\n@@ -467,4 +491,8 @@\n-            int markerCount = (Integer) args[argIndex++];\n-            markerInterfaces = new Class<?>[markerCount];\n-            System.arraycopy(args, argIndex, markerInterfaces, 0, markerCount);\n-            argIndex += markerCount;\n+            int altInterfaceCount = extractArg(args, argIndex++, Integer.class);\n+            if (altInterfaceCount < 0) {\n+                throw new IllegalArgumentException(\"negative argument count\");\n+            }\n+            if (altInterfaceCount > 0) {\n+                altInterfaces = extractArgs(args, argIndex, Class.class, altInterfaceCount);\n+                argIndex += altInterfaceCount;\n+            }\n@@ -472,2 +500,0 @@\n-        else\n-            markerInterfaces = EMPTY_CLASS_ARRAY;\n@@ -475,4 +501,11 @@\n-            int bridgeCount = (Integer) args[argIndex++];\n-            bridges = new MethodType[bridgeCount];\n-            System.arraycopy(args, argIndex, bridges, 0, bridgeCount);\n-            argIndex += bridgeCount;\n+            int altMethodCount = extractArg(args, argIndex++, Integer.class);\n+            if (altMethodCount < 0) {\n+                throw new IllegalArgumentException(\"negative argument count\");\n+            }\n+            if (altMethodCount > 0) {\n+                altMethods = extractArgs(args, argIndex, MethodType.class, altMethodCount);\n+                argIndex += altMethodCount;\n+            }\n+        }\n+        if (argIndex < args.length) {\n+            throw new IllegalArgumentException(\"too many arguments\");\n@@ -480,2 +513,0 @@\n-        else\n-            bridges = EMPTY_MT_ARRAY;\n@@ -485,2 +516,2 @@\n-            boolean foundSerializableSupertype = Serializable.class.isAssignableFrom(invokedType.returnType());\n-            for (Class<?> c : markerInterfaces)\n+            boolean foundSerializableSupertype = Serializable.class.isAssignableFrom(factoryType.returnType());\n+            for (Class<?> c : altInterfaces)\n@@ -489,2 +520,2 @@\n-                markerInterfaces = Arrays.copyOf(markerInterfaces, markerInterfaces.length + 1);\n-                markerInterfaces[markerInterfaces.length-1] = Serializable.class;\n+                altInterfaces = Arrays.copyOf(altInterfaces, altInterfaces.length + 1);\n+                altInterfaces[altInterfaces.length-1] = Serializable.class;\n@@ -495,4 +526,6 @@\n-                = new InnerClassLambdaMetafactory(caller, invokedType,\n-                                                  invokedName, samMethodType,\n-                                                  implMethod,\n-                                                  instantiatedMethodType,\n+                = new InnerClassLambdaMetafactory(caller,\n+                                                  factoryType,\n+                                                  interfaceMethodName,\n+                                                  interfaceMethodType,\n+                                                  implementation,\n+                                                  dynamicMethodType,\n@@ -500,1 +533,2 @@\n-                                                  markerInterfaces, bridges);\n+                                                  altInterfaces,\n+                                                  altMethods);\n@@ -504,0 +538,21 @@\n+\n+    private static <T> T extractArg(Object[] args, int index, Class<T> type) {\n+        if (index >= args.length) {\n+            throw new IllegalArgumentException(\"missing argument\");\n+        }\n+        Object result = Objects.requireNonNull(args[index]);\n+        if (!type.isInstance(result)) {\n+            throw new IllegalArgumentException(\"argument has wrong type\");\n+        }\n+        return type.cast(result);\n+    }\n+\n+    private static <T> T[] extractArgs(Object[] args, int index, Class<T> type, int count) {\n+        @SuppressWarnings(\"unchecked\")\n+        T[] result = (T[]) Array.newInstance(type, count);\n+        for (int i = 0; i < count; i++) {\n+            result[i] = extractArg(args, index + i, type);\n+        }\n+        return result;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java","additions":217,"deletions":162,"binary":false,"changes":379,"status":"modified"},{"patch":"@@ -41,5 +41,5 @@\n-                                            String invokedName,\n-                                            MethodType invokedType,\n-                                            MethodType samMethodType,\n-                                            MemberName implMethod,\n-                                            MethodType instantiatedMethodType,\n+                                            String interfaceMethodName,\n+                                            MethodType factoryType,\n+                                            MethodType interfaceMethodType,\n+                                            MemberName implementationMember,\n+                                            MethodType dynamicMethodType,\n@@ -49,5 +49,5 @@\n-                                                   String invokedName,\n-                                                   MethodType invokedType,\n-                                                   MethodType samMethodType,\n-                                                   MemberName implMethod,\n-                                                   MethodType instantiatedMethodType);\n+                                                   String interfaceMethodName,\n+                                                   MethodType factoryType,\n+                                                   MethodType interfaceMethodType,\n+                                                   MemberName implementationMember,\n+                                                   MethodType dynamicMethodType);\n@@ -65,5 +65,5 @@\n-                            String invokedName,\n-                            MethodType invokedType,\n-                            MethodType samMethodType,\n-                            MethodHandle implMethod,\n-                            MethodType instantiatedMethodType,\n+                            String interfaceMethodName,\n+                            MethodType factoryType,\n+                            MethodType interfaceMethodType,\n+                            MethodHandle implementation,\n+                            MethodType dynamicMethodType,\n@@ -71,2 +71,2 @@\n-                            Class<?>[] markerInterfaces,\n-                            MethodType[] additionalBridges,\n+                            Class<?>[] altInterfaces,\n+                            MethodType[] altMethods,\n@@ -78,3 +78,3 @@\n-            !isSerializable && markerInterfaces.length == 0 && additionalBridges.length == 0) {\n-            addToArchive(caller, invokedName, invokedType, samMethodType,\n-                         implMethod.internalMemberName(), instantiatedMethodType,\n+            !isSerializable && altInterfaces.length == 0 && altMethods.length == 0) {\n+            addToArchive(caller, interfaceMethodName, factoryType, interfaceMethodType,\n+                         implementation.internalMemberName(), dynamicMethodType,\n@@ -96,5 +96,5 @@\n-                         String invokedName,\n-                         MethodType invokedType,\n-                         MethodType samMethodType,\n-                         MethodHandle implMethod,\n-                         MethodType instantiatedMethodType,\n+                         String interfaceMethodName,\n+                         MethodType factoryType,\n+                         MethodType interfaceMethodType,\n+                         MethodHandle implementation,\n+                         MethodType dynamicMethodType,\n@@ -102,2 +102,2 @@\n-                         Class<?>[] markerInterfaces,\n-                         MethodType[] additionalBridges) {\n+                         Class<?>[] altInterfaces,\n+                         MethodType[] altMethods) {\n@@ -108,1 +108,1 @@\n-            !CDS.isSharingEnabled() || isSerializable || markerInterfaces.length > 0 || additionalBridges.length > 0)\n+            !CDS.isSharingEnabled() || isSerializable || altInterfaces.length > 0 || altMethods.length > 0)\n@@ -111,2 +111,2 @@\n-        return findFromArchive(caller, invokedName, invokedType, samMethodType,\n-                               implMethod.internalMemberName(), instantiatedMethodType);\n+        return findFromArchive(caller, interfaceMethodName, factoryType, interfaceMethodType,\n+                               implementation.internalMemberName(), dynamicMethodType);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaProxyClassArchive.java","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -316,12 +316,15 @@\n-        if (refKind == originalRefKind)  return true;\n-        switch (originalRefKind) {\n-        case REF_invokeInterface:\n-            \/\/ Looking up an interface method, can get (e.g.) Object.hashCode\n-            assert(refKind == REF_invokeVirtual ||\n-                   refKind == REF_invokeSpecial) : this;\n-            return true;\n-        case REF_invokeVirtual:\n-        case REF_newInvokeSpecial:\n-            \/\/ Looked up a virtual, can get (e.g.) final String.hashCode.\n-            assert(refKind == REF_invokeSpecial) : this;\n-            return true;\n+        if (refKind == originalRefKind) return true;\n+        if (getClass().desiredAssertionStatus()) {\n+            switch (originalRefKind) {\n+                case REF_invokeInterface -> {\n+                    \/\/ Looking up an interface method, can get (e.g.) Object.hashCode\n+                    assert (refKind == REF_invokeVirtual || refKind == REF_invokeSpecial) : this;\n+                }\n+                case REF_invokeVirtual, REF_newInvokeSpecial -> {\n+                    \/\/ Looked up a virtual, can get (e.g.) final String.hashCode.\n+                    assert (refKind == REF_invokeSpecial) : this;\n+                }\n+                default -> {\n+                    assert (false) : this + \" != \" + MethodHandleNatives.refKindName((byte) originalRefKind);\n+                }\n+            }\n@@ -329,1 +332,0 @@\n-        assert(false) : this+\" != \"+MethodHandleNatives.refKindName((byte)originalRefKind);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1561,26 +1561,16 @@\n-        switch (info.getReferenceKind()) {\n-            case REF_getField:\n-                return Optional.of(MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.GETTER, owner, name, type.returnType()));\n-            case REF_putField:\n-                return Optional.of(MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.SETTER, owner, name, type.parameterType(0)));\n-            case REF_getStatic:\n-                return Optional.of(MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.STATIC_GETTER, owner, name, type.returnType()));\n-            case REF_putStatic:\n-                return Optional.of(MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.STATIC_SETTER, owner, name, type.parameterType(0)));\n-            case REF_invokeVirtual:\n-                return Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.VIRTUAL, owner, name, type));\n-            case REF_invokeStatic:\n-                return isInterface ?\n-                        Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, owner, name, type)) :\n-                        Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC, owner, name, type));\n-            case REF_invokeSpecial:\n-                return isInterface ?\n-                        Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_SPECIAL, owner, name, type)) :\n-                        Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.SPECIAL, owner, name, type));\n-            case REF_invokeInterface:\n-                return Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL, owner, name, type));\n-            case REF_newInvokeSpecial:\n-                return Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.CONSTRUCTOR, owner, name, type));\n-            default:\n-                return Optional.empty();\n-        }\n+        return switch (info.getReferenceKind()) {\n+            case REF_getField         -> Optional.of(MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.GETTER, owner, name, type.returnType()));\n+            case REF_putField         -> Optional.of(MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.SETTER, owner, name, type.parameterType(0)));\n+            case REF_getStatic        -> Optional.of(MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.STATIC_GETTER, owner, name, type.returnType()));\n+            case REF_putStatic        -> Optional.of(MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.STATIC_SETTER, owner, name, type.parameterType(0)));\n+            case REF_invokeVirtual    -> Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.VIRTUAL, owner, name, type));\n+            case REF_invokeStatic     -> isInterface ?\n+                                          Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, owner, name, type)) :\n+                                          Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC, owner, name, type));\n+            case REF_invokeSpecial    -> isInterface ?\n+                                          Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_SPECIAL, owner, name, type)) :\n+                                          Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.SPECIAL, owner, name, type));\n+            case REF_invokeInterface  -> Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL, owner, name, type));\n+            case REF_newInvokeSpecial -> Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.CONSTRUCTOR, owner, name, type));\n+            default -> Optional.empty();\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandle.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -112,6 +112,6 @@\n-            switch (a) {\n-                case GET: return \"getElement\";\n-                case SET: return \"setElement\";\n-                case LENGTH: return \"length\";\n-            }\n-            throw unmatchedArrayAccess(a);\n+            return switch (a) {\n+                case GET    -> \"getElement\";\n+                case SET    -> \"setElement\";\n+                case LENGTH -> \"length\";\n+                default -> throw unmatchedArrayAccess(a);\n+            };\n@@ -121,6 +121,6 @@\n-            switch (a) {\n-                case GET: return ArrayAccessor.OBJECT_ARRAY_GETTER;\n-                case SET: return ArrayAccessor.OBJECT_ARRAY_SETTER;\n-                case LENGTH: return ArrayAccessor.OBJECT_ARRAY_LENGTH;\n-            }\n-            throw unmatchedArrayAccess(a);\n+            return switch (a) {\n+                case GET    -> ArrayAccessor.OBJECT_ARRAY_GETTER;\n+                case SET    -> ArrayAccessor.OBJECT_ARRAY_SETTER;\n+                case LENGTH -> ArrayAccessor.OBJECT_ARRAY_LENGTH;\n+                default -> throw unmatchedArrayAccess(a);\n+            };\n@@ -130,6 +130,6 @@\n-            switch (a) {\n-                case GET: return ArrayAccessor.GETTER_INDEX;\n-                case SET: return ArrayAccessor.SETTER_INDEX;\n-                case LENGTH: return ArrayAccessor.LENGTH_INDEX;\n-            }\n-            throw unmatchedArrayAccess(a);\n+            return switch (a) {\n+                case GET    -> ArrayAccessor.GETTER_INDEX;\n+                case SET    -> ArrayAccessor.SETTER_INDEX;\n+                case LENGTH -> ArrayAccessor.LENGTH_INDEX;\n+                default -> throw unmatchedArrayAccess(a);\n+            };\n@@ -139,6 +139,6 @@\n-            switch (a) {\n-                case GET: return Intrinsic.ARRAY_LOAD;\n-                case SET: return Intrinsic.ARRAY_STORE;\n-                case LENGTH: return Intrinsic.ARRAY_LENGTH;\n-            }\n-            throw unmatchedArrayAccess(a);\n+            return switch (a) {\n+                case GET    -> Intrinsic.ARRAY_LOAD;\n+                case SET    -> Intrinsic.ARRAY_STORE;\n+                case LENGTH -> Intrinsic.ARRAY_LENGTH;\n+                default -> throw unmatchedArrayAccess(a);\n+            };\n@@ -216,6 +216,6 @@\n-            switch (access) {\n-                case GET:    return MethodType.methodType(elemClass,  arrayArgClass, int.class);\n-                case SET:    return MethodType.methodType(void.class, arrayArgClass, int.class, elemClass);\n-                case LENGTH: return MethodType.methodType(int.class,  arrayArgClass);\n-            }\n-            throw unmatchedArrayAccess(access);\n+            return switch (access) {\n+                case GET    -> MethodType.methodType(elemClass, arrayArgClass, int.class);\n+                case SET    -> MethodType.methodType(void.class, arrayArgClass, int.class, elemClass);\n+                case LENGTH -> MethodType.methodType(int.class, arrayArgClass);\n+                default -> throw unmatchedArrayAccess(access);\n+            };\n@@ -225,6 +225,6 @@\n-            switch (access) {\n-                case GET:    return MethodType.methodType(elemClass,  arrayClass, int.class);\n-                case SET:    return MethodType.methodType(void.class, arrayClass, int.class, elemClass);\n-                case LENGTH: return MethodType.methodType(int.class,  arrayClass);\n-            }\n-            throw unmatchedArrayAccess(access);\n+            return switch (access) {\n+                case GET    -> MethodType.methodType(elemClass, arrayClass, int.class);\n+                case SET    -> MethodType.methodType(void.class, arrayClass, int.class, elemClass);\n+                case LENGTH -> MethodType.methodType(int.class, arrayClass);\n+                default -> throw unmatchedArrayAccess(access);\n+            };\n@@ -983,1 +983,0 @@\n-        int idx;\n@@ -985,5 +984,5 @@\n-        switch (method.getName()) {\n-        case \"invoke\":       idx = 0; break;\n-        case \"invokeExact\":  idx = 1; break;\n-        default:             throw new InternalError(method.getName());\n-        }\n+        int idx = switch (method.getName()) {\n+            case \"invoke\"      -> 0;\n+            case \"invokeExact\" -> 1;\n+            default -> throw new InternalError(method.getName());\n+        };\n@@ -1398,26 +1397,18 @@\n-            switch (func) {\n-                case NF_checkSpreadArgument:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"checkSpreadArgument\", Object.class, int.class));\n-                case NF_guardWithCatch:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"guardWithCatch\", MethodHandle.class, Class.class,\n-                                    MethodHandle.class, Object[].class));\n-                case NF_tryFinally:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"tryFinally\", MethodHandle.class, MethodHandle.class, Object[].class));\n-                case NF_loop:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"loop\", BasicType[].class, LoopClauses.class, Object[].class));\n-                case NF_throwException:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"throwException\", Throwable.class));\n-                case NF_profileBoolean:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"profileBoolean\", boolean.class, int[].class));\n-                case NF_tableSwitch:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"tableSwitch\", int.class, MethodHandle.class, CasesHolder.class, Object[].class));\n-                default:\n-                    throw new InternalError(\"Undefined function: \" + func);\n-            }\n+            return switch (func) {\n+                case NF_checkSpreadArgument -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"checkSpreadArgument\", Object.class, int.class));\n+                case NF_guardWithCatch      -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"guardWithCatch\", MethodHandle.class, Class.class,\n+                                                   MethodHandle.class, Object[].class));\n+                case NF_tryFinally          -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"tryFinally\", MethodHandle.class, MethodHandle.class, Object[].class));\n+                case NF_loop                -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"loop\", BasicType[].class, LoopClauses.class, Object[].class));\n+                case NF_throwException      -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"throwException\", Throwable.class));\n+                case NF_profileBoolean      -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"profileBoolean\", boolean.class, int[].class));\n+                case NF_tableSwitch         -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"tableSwitch\", int.class, MethodHandle.class, CasesHolder.class, Object[].class));\n+                default -> throw new InternalError(\"Undefined function: \" + func);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":59,"deletions":68,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -209,12 +209,12 @@\n-        switch (refKind) {\n-        case REF_getField:          return \"getField\";\n-        case REF_getStatic:         return \"getStatic\";\n-        case REF_putField:          return \"putField\";\n-        case REF_putStatic:         return \"putStatic\";\n-        case REF_invokeVirtual:     return \"invokeVirtual\";\n-        case REF_invokeStatic:      return \"invokeStatic\";\n-        case REF_invokeSpecial:     return \"invokeSpecial\";\n-        case REF_newInvokeSpecial:  return \"newInvokeSpecial\";\n-        case REF_invokeInterface:   return \"invokeInterface\";\n-        default:                    return \"REF_???\";\n-        }\n+        return switch (refKind) {\n+            case REF_getField         -> \"getField\";\n+            case REF_getStatic        -> \"getStatic\";\n+            case REF_putField         -> \"putField\";\n+            case REF_putStatic        -> \"putStatic\";\n+            case REF_invokeVirtual    -> \"invokeVirtual\";\n+            case REF_invokeStatic     -> \"invokeStatic\";\n+            case REF_invokeSpecial    -> \"invokeSpecial\";\n+            case REF_newInvokeSpecial -> \"newInvokeSpecial\";\n+            case REF_invokeInterface  -> \"invokeInterface\";\n+            default -> \"REF_???\";\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -277,13 +277,10 @@\n-        switch (m.getName()) {\n-        case \"toString\":\n-            return (m.getReturnType() == String.class\n-                    && m.getParameterCount() == 0);\n-        case \"hashCode\":\n-            return (m.getReturnType() == int.class\n-                    && m.getParameterCount() == 0);\n-        case \"equals\":\n-            return (m.getReturnType() == boolean.class\n-                    && m.getParameterCount() == 1\n-                    && m.getParameterTypes()[0] == Object.class);\n-        }\n-        return false;\n+        return switch (m.getName()) {\n+            case \"toString\" -> m.getReturnType() == String.class\n+                               && m.getParameterCount() == 0;\n+            case \"hashCode\" -> m.getReturnType() == int.class\n+                               && m.getParameterCount() == 0;\n+            case \"equals\"   -> m.getReturnType() == boolean.class\n+                               && m.getParameterCount() == 1\n+                               && m.getParameterTypes()[0] == Object.class;\n+            default -> false;\n+        };\n@@ -294,9 +291,6 @@\n-        switch (m.getName()) {\n-        case \"toString\":\n-            return self.getClass().getName() + \"@\" + Integer.toHexString(self.hashCode());\n-        case \"hashCode\":\n-            return System.identityHashCode(self);\n-        case \"equals\":\n-            return (self == args[0]);\n-        }\n-        return null;\n+        return switch (m.getName()) {\n+            case \"toString\" -> self.getClass().getName() + \"@\" + Integer.toHexString(self.hashCode());\n+            case \"hashCode\" -> System.identityHashCode(self);\n+            case \"equals\"   -> (self == args[0]);\n+            default -> null;\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":16,"deletions":22,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -5178,7 +5178,7 @@\n-        switch (w) {\n-        case INT:     return result.bindArgumentI(pos, (int)value);\n-        case LONG:    return result.bindArgumentJ(pos, (long)value);\n-        case FLOAT:   return result.bindArgumentF(pos, (float)value);\n-        case DOUBLE:  return result.bindArgumentD(pos, (double)value);\n-        default:      return result.bindArgumentI(pos, ValueConversions.widenSubword(value));\n-        }\n+        return switch (w) {\n+            case INT    -> result.bindArgumentI(pos, (int) value);\n+            case LONG   -> result.bindArgumentJ(pos, (long) value);\n+            case FLOAT  -> result.bindArgumentF(pos, (float) value);\n+            case DOUBLE -> result.bindArgumentD(pos, (double) value);\n+            default -> result.bindArgumentI(pos, ValueConversions.widenSubword(value));\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2285,9 +2285,5 @@\n-                switch (this) {\n-                    case FIELD:\n-                    case STATIC_FIELD:\n-                        return new ConstantDesc[] {declaringClass, varType };\n-                    case ARRAY:\n-                        return new ConstantDesc[] {declaringClass };\n-                    default:\n-                        throw new InternalError(\"Cannot reach here\");\n-                }\n+                return switch (this) {\n+                    case FIELD, STATIC_FIELD -> new ConstantDesc[]{declaringClass, varType};\n+                    case ARRAY               -> new ConstantDesc[]{declaringClass};\n+                    default -> throw new InternalError(\"Cannot reach here\");\n+                };\n@@ -2388,14 +2384,10 @@\n-            switch (kind) {\n-                case FIELD:\n-                    return lookup.findVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup),\n-                                                constantName(),\n-                                                (Class<?>) varType.resolveConstantDesc(lookup));\n-                case STATIC_FIELD:\n-                    return lookup.findStaticVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup),\n-                                                      constantName(),\n-                                                      (Class<?>) varType.resolveConstantDesc(lookup));\n-                case ARRAY:\n-                    return MethodHandles.arrayElementVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup));\n-                default:\n-                    throw new InternalError(\"Cannot reach here\");\n-            }\n+            return switch (kind) {\n+                case FIELD        -> lookup.findVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup),\n+                                                          constantName(),\n+                                                          (Class<?>) varType.resolveConstantDesc(lookup));\n+                case STATIC_FIELD -> lookup.findStaticVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup),\n+                                                          constantName(),\n+                                                          (Class<?>) varType.resolveConstantDesc(lookup));\n+                case ARRAY        -> MethodHandles.arrayElementVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup));\n+                default -> throw new InternalError(\"Cannot reach here\");\n+            };\n@@ -2414,11 +2406,7 @@\n-            switch (kind) {\n-                case FIELD:\n-                case STATIC_FIELD:\n-                    return String.format(\"VarHandleDesc[%s%s.%s:%s]\",\n-                                         (kind == Kind.STATIC_FIELD) ? \"static \" : \"\",\n-                                         declaringClass.displayName(), constantName(), varType.displayName());\n-                case ARRAY:\n-                    return String.format(\"VarHandleDesc[%s[]]\", declaringClass.displayName());\n-                default:\n-                    throw new InternalError(\"Cannot reach here\");\n-            }\n+            return switch (kind) {\n+                case FIELD, STATIC_FIELD -> String.format(\"VarHandleDesc[%s%s.%s:%s]\",\n+                                                           (kind == Kind.STATIC_FIELD) ? \"static \" : \"\",\n+                                                           declaringClass.displayName(), constantName(), varType.displayName());\n+                case ARRAY               -> String.format(\"VarHandleDesc[%s[]]\", declaringClass.displayName());\n+                default -> throw new InternalError(\"Cannot reach here\");\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":22,"deletions":34,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -342,3 +342,2 @@\n-        MethodHandle handle;\n-        switch (methodName) {\n-            case \"equals\":\n+        MethodHandle handle = switch (methodName) {\n+            case \"equals\"   -> {\n@@ -347,3 +346,3 @@\n-                handle = makeEquals(recordClass, getterList);\n-                return methodType != null ? new ConstantCallSite(handle) : handle;\n-            case \"hashCode\":\n+                yield makeEquals(recordClass, getterList);\n+            }\n+            case \"hashCode\" -> {\n@@ -352,3 +351,3 @@\n-                handle = makeHashCode(recordClass, getterList);\n-                return methodType != null ? new ConstantCallSite(handle) : handle;\n-            case \"toString\":\n+                yield makeHashCode(recordClass, getterList);\n+            }\n+            case \"toString\" -> {\n@@ -360,5 +359,5 @@\n-                handle = makeToString(recordClass, getterList, nameList);\n-                return methodType != null ? new ConstantCallSite(handle) : handle;\n-            default:\n-                throw new IllegalArgumentException(methodName);\n-        }\n+                yield makeToString(recordClass, getterList, nameList);\n+            }\n+            default -> throw new IllegalArgumentException(methodName);\n+        };\n+        return methodType != null ? new ConstantCallSite(handle) : handle;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ObjectMethods.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.ConstantCallSite;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * Bootstrap methods for linking {@code invokedynamic} call sites that implement\n+ * the selection functionality of the {@code switch} statement.  The bootstraps\n+ * take additional static arguments corresponding to the {@code case} labels\n+ * of the {@code switch}, implicitly numbered sequentially from {@code [0..N)}.\n+ *\n+ * @since 17\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING)\n+public class SwitchBootstraps {\n+\n+    private SwitchBootstraps() {}\n+\n+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+\n+    private static final MethodHandle DO_SWITCH;\n+\n+    static {\n+        try {\n+            DO_SWITCH = LOOKUP.findStatic(SwitchBootstraps.class, \"doSwitch\",\n+                                           MethodType.methodType(int.class, Object.class, int.class, Object[].class));\n+        }\n+        catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    \/**\n+     * Bootstrap method for linking an {@code invokedynamic} call site that\n+     * implements a {@code switch} on a target of a reference type.  The static\n+     * arguments are an array of case labels which must be non-null and of type\n+     * {@code String} or {@code Integer} or {@code Class}.\n+     * <p>\n+     * The type of the returned {@code CallSite}'s method handle will have\n+     * a return type of {@code int}.   It has two parameters: the first argument\n+     * will be an {@code Object} instance ({@code target}) and the second\n+     * will be {@code int} ({@code restart}).\n+     * <p>\n+     * If the {@code target} is {@code null}, then the method of the call site\n+     * returns {@literal -1}.\n+     * <p>\n+     * If the {@code target} is not {@code null}, then the method of the call site\n+     * returns the index of the first element in the {@code labels} array starting from\n+     * the {@code restart} index matching one of the following conditions:\n+     * <ul>\n+     *   <li>the element is of type {@code Class} that is assignable\n+     *       from the target's class; or<\/li>\n+     *   <li>the element is of type {@code String} or {@code Integer} and\n+     *       equals to the target.<\/li>\n+     * <\/ul>\n+     * <p>\n+     * If no element in the {@code labels} array matches the target, then\n+     * the method of the call site return the length of the {@code labels} array.\n+     *\n+     * @param lookup Represents a lookup context with the accessibility\n+     *               privileges of the caller.  When used with {@code invokedynamic},\n+     *               this is stacked automatically by the VM.\n+     * @param invocationName unused\n+     * @param invocationType The invocation type of the {@code CallSite} with two parameters,\n+     *                       a reference type, an {@code int}, and {@code int} as a return type.\n+     * @param labels case labels - {@code String} and {@code Integer} constants\n+     *               and {@code Class} instances, in any combination\n+     * @return a {@code CallSite} returning the first matching element as described above\n+     *\n+     * @throws NullPointerException if any argument is {@code null}\n+     * @throws IllegalArgumentException if any element in the labels array is null, if the\n+     * invocation type is not not a method type of first parameter of a reference type,\n+     * second parameter of type {@code int} and with {@code int} as its return type,\n+     * or if {@code labels} contains an element that is not of type {@code String},\n+     * {@code Integer} or {@code Class}.\n+     * @throws Throwable if there is any error linking the call site\n+     * @jvms 4.4.6 The CONSTANT_NameAndType_info Structure\n+     * @jvms 4.4.10 The CONSTANT_Dynamic_info and CONSTANT_InvokeDynamic_info Structures\n+     *\/\n+    public static CallSite typeSwitch(MethodHandles.Lookup lookup,\n+                                      String invocationName,\n+                                      MethodType invocationType,\n+                                      Object... labels) throws Throwable {\n+        if (invocationType.parameterCount() != 2\n+            || (!invocationType.returnType().equals(int.class))\n+            || invocationType.parameterType(0).isPrimitive()\n+            || !invocationType.parameterType(1).equals(int.class))\n+            throw new IllegalArgumentException(\"Illegal invocation type \" + invocationType);\n+        requireNonNull(labels);\n+\n+        labels = labels.clone();\n+        Stream.of(labels).forEach(SwitchBootstraps::verifyLabel);\n+\n+        MethodHandle target = MethodHandles.insertArguments(DO_SWITCH, 2, (Object) labels);\n+        return new ConstantCallSite(target);\n+    }\n+\n+    private static void verifyLabel(Object label) {\n+        if (label == null) {\n+            throw new IllegalArgumentException(\"null label found\");\n+        }\n+        Class<?> labelClass = label.getClass();\n+        if (labelClass != Class.class &&\n+            labelClass != String.class &&\n+            labelClass != Integer.class) {\n+            throw new IllegalArgumentException(\"label with illegal type found: \" + label.getClass());\n+        }\n+    }\n+\n+    private static int doSwitch(Object target, int startIndex, Object[] labels) {\n+        if (target == null)\n+            return -1;\n+\n+        \/\/ Dumbest possible strategy\n+        Class<?> targetClass = target.getClass();\n+        for (int i = startIndex; i < labels.length; i++) {\n+            Object label = labels[i];\n+            if (label instanceof Class<?> c) {\n+                if (c.isAssignableFrom(targetClass))\n+                    return i;\n+            } else if (label instanceof Integer constant) {\n+                if (target instanceof Number input && constant.intValue() == input.intValue()) {\n+                    return i;\n+                } else if (target instanceof Character input && constant.intValue() == input.charValue()) {\n+                    return i;\n+                }\n+            } else if (label.equals(target)) {\n+                return i;\n+            }\n+        }\n+\n+        return labels.length;\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -214,19 +214,11 @@\n-        SocketException ex = null;\n-        switch (data[1]) {\n-        case 90:\n-            \/\/ Success!\n-            external_address = endpoint;\n-            break;\n-        case 91:\n-            ex = new SocketException(\"SOCKS request rejected\");\n-            break;\n-        case 92:\n-            ex = new SocketException(\"SOCKS server couldn't reach destination\");\n-            break;\n-        case 93:\n-            ex = new SocketException(\"SOCKS authentication failed\");\n-            break;\n-        default:\n-            ex = new SocketException(\"Reply from SOCKS server contains bad status\");\n-            break;\n-        }\n+        SocketException ex = switch (data[1]) {\n+            case 90 -> {\n+                \/\/ Success!\n+                external_address = endpoint;\n+                yield null;\n+            }\n+            case 91 -> new SocketException(\"SOCKS request rejected\");\n+            case 92 -> new SocketException(\"SOCKS server couldn't reach destination\");\n+            case 93 -> new SocketException(\"SOCKS authentication failed\");\n+            default -> new SocketException(\"Reply from SOCKS server contains bad status\");\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocksSocketImpl.java","additions":11,"deletions":19,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2806,3 +2806,2 @@\n-                FileVisitResult result;\n-                switch (ev.type()) {\n-                    case ENTRY :\n+                FileVisitResult result = switch (ev.type()) {\n+                    case ENTRY -> {\n@@ -2812,1 +2811,1 @@\n-                            result = visitor.visitFile(ev.file(), ev.attributes());\n+                            yield visitor.visitFile(ev.file(), ev.attributes());\n@@ -2814,1 +2813,1 @@\n-                            result = visitor.visitFileFailed(ev.file(), ioe);\n+                            yield visitor.visitFileFailed(ev.file(), ioe);\n@@ -2816,4 +2815,3 @@\n-                        break;\n-\n-                    case START_DIRECTORY :\n-                        result = visitor.preVisitDirectory(ev.file(), ev.attributes());\n+                    }\n+                    case START_DIRECTORY -> {\n+                        var res = visitor.preVisitDirectory(ev.file(), ev.attributes());\n@@ -2824,2 +2822,2 @@\n-                        if (result == FileVisitResult.SKIP_SUBTREE ||\n-                            result == FileVisitResult.SKIP_SIBLINGS)\n+                        if (res == FileVisitResult.SKIP_SUBTREE ||\n+                            res == FileVisitResult.SKIP_SIBLINGS)\n@@ -2827,4 +2825,4 @@\n-                        break;\n-\n-                    case END_DIRECTORY :\n-                        result = visitor.postVisitDirectory(ev.file(), ev.ioeException());\n+                        yield res;\n+                    }\n+                    case END_DIRECTORY -> {\n+                        var res = visitor.postVisitDirectory(ev.file(), ev.ioeException());\n@@ -2833,7 +2831,6 @@\n-                        if (result == FileVisitResult.SKIP_SIBLINGS)\n-                            result = FileVisitResult.CONTINUE;\n-                        break;\n-\n-                    default :\n-                        throw new AssertionError(\"Should not get here\");\n-                }\n+                        if (res == FileVisitResult.SKIP_SIBLINGS)\n+                            res = FileVisitResult.CONTINUE;\n+                        yield res;\n+                    }\n+                    default -> throw new AssertionError(\"Should not get here\");\n+                };\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Files.java","additions":19,"deletions":22,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,2 @@\n+import java.io.ObjectStreamException;\n+\n@@ -77,3 +79,4 @@\n- * Instances of this class are used to find the current instant, which can be\n- * interpreted using the stored time-zone to find the current date and time.\n- * As such, a clock can be used instead of {@link System#currentTimeMillis()}\n+ * Instances of this abstract class are used to access a pluggable representation of the\n+ * current instant, which can be interpreted using the stored time-zone to find the\n+ * current date and time.\n+ * For example, {@code Clock} can be used instead of {@link System#currentTimeMillis()}\n@@ -88,0 +91,4 @@\n+ * As such, this abstract class does not guarantee the result actually represents the current instant\n+ * on the time-line. Instead, it allows the application to provide a controlled view as to what\n+ * the current instant and time-zone are.\n+ * <p>\n@@ -89,2 +96,2 @@\n- * that requires the current instant. A dependency injection framework is one\n- * way to achieve this:\n+ * that requires the current instant and time-zone. A dependency injection framework\n+ * is one way to achieve this:\n@@ -102,1 +109,1 @@\n- * This approach allows an alternate clock, such as {@link #fixed(Instant, ZoneId) fixed}\n+ * This approach allows an alternative clock, such as {@link #fixed(Instant, ZoneId) fixed}\n@@ -106,1 +113,1 @@\n- * system clock This may use {@link System#currentTimeMillis()}, or a higher\n+ * system clock. This may use {@link System#currentTimeMillis()}, or a higher\n@@ -111,1 +118,2 @@\n- * All implementations that can be instantiated must be final, immutable and thread-safe.\n+ * All implementations must be thread-safe - a single instance must be capable of be invoked\n+ * from multiple threads without negative consequences such as race conditions.\n@@ -129,8 +137,1 @@\n- * @implNote\n- * The clock implementation provided here is based on the same underlying clock\n- * as {@link System#currentTimeMillis()}, but may have a precision finer than\n- * milliseconds if available.\n- * However, little to no guarantee is provided about the accuracy of the\n- * underlying clock. Applications requiring a more accurate clock must implement\n- * this abstract class themselves using a different external clock, such as an\n- * NTP server.\n+ * @see InstantSource\n@@ -140,1 +141,1 @@\n-public abstract class Clock {\n+public abstract class Clock implements InstantSource {\n@@ -357,1 +358,1 @@\n-     * specified duration added\n+     * specified duration added.\n@@ -411,0 +412,1 @@\n+    @Override\n@@ -431,0 +433,1 @@\n+    @Override\n@@ -444,0 +447,1 @@\n+    @Override\n@@ -476,0 +480,100 @@\n+    \/\/-----------------------------------------------------------------------\n+    \/\/ initial offset\n+    private static final long OFFSET_SEED = System.currentTimeMillis() \/ 1000 - 1024;\n+    \/\/ We don't actually need a volatile here.\n+    \/\/ We don't care if offset is set or read concurrently by multiple\n+    \/\/ threads - we just need a value which is 'recent enough' - in other\n+    \/\/ words something that has been updated at least once in the last\n+    \/\/ 2^32 secs (~136 years). And even if we by chance see an invalid\n+    \/\/ offset, the worst that can happen is that we will get a -1 value\n+    \/\/ from getNanoTimeAdjustment, forcing us to update the offset\n+    \/\/ once again.\n+    private static long offset = OFFSET_SEED;\n+\n+    static Instant currentInstant() {\n+        \/\/ Take a local copy of offset. offset can be updated concurrently\n+        \/\/ by other threads (even if we haven't made it volatile) so we will\n+        \/\/ work with a local copy.\n+        long localOffset = offset;\n+        long adjustment = VM.getNanoTimeAdjustment(localOffset);\n+\n+        if (adjustment == -1) {\n+            \/\/ -1 is a sentinel value returned by VM.getNanoTimeAdjustment\n+            \/\/ when the offset it is given is too far off the current UTC\n+            \/\/ time. In principle, this should not happen unless the\n+            \/\/ JVM has run for more than ~136 years (not likely) or\n+            \/\/ someone is fiddling with the system time, or the offset is\n+            \/\/ by chance at 1ns in the future (very unlikely).\n+            \/\/ We can easily recover from all these conditions by bringing\n+            \/\/ back the offset in range and retry.\n+\n+            \/\/ bring back the offset in range. We use -1024 to make\n+            \/\/ it more unlikely to hit the 1ns in the future condition.\n+            localOffset = System.currentTimeMillis() \/ 1000 - 1024;\n+\n+            \/\/ retry\n+            adjustment = VM.getNanoTimeAdjustment(localOffset);\n+\n+            if (adjustment == -1) {\n+                \/\/ Should not happen: we just recomputed a new offset.\n+                \/\/ It should have fixed the issue.\n+                throw new InternalError(\"Offset \" + localOffset + \" is not in range\");\n+            } else {\n+                \/\/ OK - recovery succeeded. Update the offset for the\n+                \/\/ next call...\n+                offset = localOffset;\n+            }\n+        }\n+        return Instant.ofEpochSecond(localOffset, adjustment);\n+    }\n+\n+    \/\/-----------------------------------------------------------------------\n+    \/**\n+     * An instant source that always returns the latest time from\n+     * {@link System#currentTimeMillis()} or equivalent.\n+     *\/\n+    static final class SystemInstantSource implements InstantSource, Serializable {\n+        @java.io.Serial\n+        private static final long serialVersionUID = 3232399674412L;\n+        \/\/ this is a singleton, but the class is coded such that it is not a\n+        \/\/ problem if someone hacks around and creates another instance\n+        static final SystemInstantSource INSTANCE = new SystemInstantSource();\n+\n+        SystemInstantSource() {\n+        }\n+        @Override\n+        public Clock withZone(ZoneId zone) {\n+            return Clock.system(zone);\n+        }\n+        @Override\n+        public long millis() {\n+            \/\/ System.currentTimeMillis() and VM.getNanoTimeAdjustment(offset)\n+            \/\/ use the same time source - System.currentTimeMillis() simply\n+            \/\/ limits the resolution to milliseconds.\n+            \/\/ So we take the faster path and call System.currentTimeMillis()\n+            \/\/ directly - in order to avoid the performance penalty of\n+            \/\/ VM.getNanoTimeAdjustment(offset) which is less efficient.\n+            return System.currentTimeMillis();\n+        }\n+        @Override\n+        public Instant instant() {\n+            return currentInstant();\n+        }\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof SystemInstantSource;\n+        }\n+        @Override\n+        public int hashCode() {\n+            return SystemInstantSource.class.hashCode();\n+        }\n+        @Override\n+        public String toString() {\n+            return \"SystemInstantSource\";\n+        }\n+        @java.io.Serial\n+        private Object readResolve() throws ObjectStreamException {\n+            return SystemInstantSource.INSTANCE;\n+        }\n+    }\n+\n@@ -479,1 +583,1 @@\n-     * {@link System#currentTimeMillis()}.\n+     * {@code SystemInstantSource.INSTANCE}.\n@@ -484,2 +588,0 @@\n-        private static final long OFFSET_SEED =\n-                System.currentTimeMillis()\/1000 - 1024; \/\/ initial offest\n@@ -489,9 +591,0 @@\n-        \/\/ We don't actually need a volatile here.\n-        \/\/ We don't care if offset is set or read concurrently by multiple\n-        \/\/ threads - we just need a value which is 'recent enough' - in other\n-        \/\/ words something that has been updated at least once in the last\n-        \/\/ 2^32 secs (~136 years). And even if we by chance see an invalid\n-        \/\/ offset, the worst that can happen is that we will get a -1 value\n-        \/\/ from getNanoTimeAdjustment, forcing us to update the offset\n-        \/\/ once again.\n-        private transient long offset;\n@@ -501,1 +594,0 @@\n-            this.offset = OFFSET_SEED;\n@@ -516,6 +608,1 @@\n-            \/\/ System.currentTimeMillis() and VM.getNanoTimeAdjustment(offset)\n-            \/\/ use the same time source - System.currentTimeMillis() simply\n-            \/\/ limits the resolution to milliseconds.\n-            \/\/ So we take the faster path and call System.currentTimeMillis()\n-            \/\/ directly - in order to avoid the performance penalty of\n-            \/\/ VM.getNanoTimeAdjustment(offset) which is less efficient.\n+            \/\/ inline of SystemInstantSource.INSTANCE.millis()\n@@ -526,34 +613,2 @@\n-            \/\/ Take a local copy of offset. offset can be updated concurrently\n-            \/\/ by other threads (even if we haven't made it volatile) so we will\n-            \/\/ work with a local copy.\n-            long localOffset = offset;\n-            long adjustment = VM.getNanoTimeAdjustment(localOffset);\n-\n-            if (adjustment == -1) {\n-                \/\/ -1 is a sentinel value returned by VM.getNanoTimeAdjustment\n-                \/\/ when the offset it is given is too far off the current UTC\n-                \/\/ time. In principle, this should not happen unless the\n-                \/\/ JVM has run for more than ~136 years (not likely) or\n-                \/\/ someone is fiddling with the system time, or the offset is\n-                \/\/ by chance at 1ns in the future (very unlikely).\n-                \/\/ We can easily recover from all these conditions by bringing\n-                \/\/ back the offset in range and retry.\n-\n-                \/\/ bring back the offset in range. We use -1024 to make\n-                \/\/ it more unlikely to hit the 1ns in the future condition.\n-                localOffset = System.currentTimeMillis()\/1000 - 1024;\n-\n-                \/\/ retry\n-                adjustment = VM.getNanoTimeAdjustment(localOffset);\n-\n-                if (adjustment == -1) {\n-                    \/\/ Should not happen: we just recomputed a new offset.\n-                    \/\/ It should have fixed the issue.\n-                    throw new InternalError(\"Offset \" + localOffset + \" is not in range\");\n-                } else {\n-                    \/\/ OK - recovery succeeded. Update the offset for the\n-                    \/\/ next call...\n-                    offset = localOffset;\n-                }\n-            }\n-            return Instant.ofEpochSecond(localOffset, adjustment);\n+            \/\/ inline of SystemInstantSource.INSTANCE.instant()\n+            return currentInstant();\n@@ -576,7 +631,0 @@\n-        @java.io.Serial\n-        private void readObject(ObjectInputStream is)\n-                throws IOException, ClassNotFoundException {\n-            \/\/ ensure that offset is initialized\n-            is.defaultReadObject();\n-            offset = OFFSET_SEED;\n-        }\n@@ -687,1 +735,1 @@\n-     * Implementation of a clock that adds an offset to an underlying clock.\n+     * Implementation of a clock that reduces the tick frequency of an underlying clock.\n@@ -743,0 +791,50 @@\n+    \/\/-----------------------------------------------------------------------\n+    \/**\n+     * Implementation of a clock based on an {@code InstantSource}.\n+     *\/\n+    static final class SourceClock extends Clock implements Serializable {\n+        @java.io.Serial\n+        private static final long serialVersionUID = 235386528762398L;\n+        @SuppressWarnings(\"serial\") \/\/ Not statically typed as Serializable\n+        private final InstantSource baseSource;\n+        private final ZoneId zone;\n+\n+        SourceClock(InstantSource baseSource, ZoneId zone) {\n+            this.baseSource = baseSource;\n+            this.zone = zone;\n+        }\n+        @Override\n+        public ZoneId getZone() {\n+            return zone;\n+        }\n+        @Override\n+        public Clock withZone(ZoneId zone) {\n+            if (zone.equals(this.zone)) {  \/\/ intentional NPE\n+                return this;\n+            }\n+            return new SourceClock(baseSource, zone);\n+        }\n+        @Override\n+        public long millis() {\n+            return baseSource.millis();\n+        }\n+        @Override\n+        public Instant instant() {\n+            return baseSource.instant();\n+        }\n+        @Override\n+        public boolean equals(Object obj) {\n+            return (obj instanceof SourceClock other)\n+                    && zone.equals(other.zone)\n+                    && baseSource.equals(other.baseSource);\n+        }\n+        @Override\n+        public int hashCode() {\n+            return baseSource.hashCode() ^ zone.hashCode();\n+        }\n+        @Override\n+        public String toString() {\n+            return \"SourceClock[\" + baseSource + \",\" + zone + \"]\";\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/time\/Clock.java","additions":178,"deletions":80,"binary":false,"changes":258,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -275,1 +275,1 @@\n-        return Clock.systemUTC().instant();\n+        return Clock.currentInstant();\n","filename":"src\/java.base\/share\/classes\/java\/time\/Instant.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,254 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.time;\n+\n+import java.time.Clock.SourceClock;\n+import java.time.Clock.SystemInstantSource;\n+import java.util.Objects;\n+\n+\/**\n+ * Provides access to the current instant.\n+ * <p>\n+ * Instances of this interface are used to access a pluggable representation of the current instant.\n+ * For example, {@code InstantSource} can be used instead of {@link System#currentTimeMillis()}.\n+ * <p>\n+ * The primary purpose of this abstraction is to allow alternate instant sources to be\n+ * plugged in as and when required. Applications use an object to obtain the\n+ * current time rather than a static method. This can simplify testing.\n+ * <p>\n+ * As such, this interface does not guarantee the result actually represents the current instant\n+ * on the time-line. Instead, it allows the application to provide a controlled view as to what\n+ * the current instant is.\n+ * <p>\n+ * Best practice for applications is to pass an {@code InstantSource} into any method\n+ * that requires the current instant. A dependency injection framework is one\n+ * way to achieve this:\n+ * <pre>\n+ *  public class MyBean {\n+ *    private InstantSource source;  \/\/ dependency inject\n+ *    ...\n+ *    public void process(Instant endInstant) {\n+ *      if (source.instant().isAfter(endInstant) {\n+ *        ...\n+ *      }\n+ *    }\n+ *  }\n+ * <\/pre>\n+ * This approach allows an alternative source, such as {@link #fixed(Instant) fixed}\n+ * or {@link #offset(InstantSource, Duration) offset} to be used during testing.\n+ * <p>\n+ * The {@code system} factory method provides a source based on the best available\n+ * system clock. This may use {@link System#currentTimeMillis()}, or a higher\n+ * resolution clock if one is available.\n+ *\n+ * @implSpec\n+ * This interface must be implemented with care to ensure other classes operate correctly.\n+ * All implementations must be thread-safe - a single instance must be capable of be invoked\n+ * from multiple threads without negative consequences such as race conditions.\n+ * <p>\n+ * The principal methods are defined to allow the throwing of an exception.\n+ * In normal use, no exceptions will be thrown, however one possible implementation would be to\n+ * obtain the time from a central time server across the network. Obviously, in this case the\n+ * lookup could fail, and so the method is permitted to throw an exception.\n+ * <p>\n+ * The returned instants from {@code InstantSource} work on a time-scale that ignores leap seconds,\n+ * as described in {@link Instant}. If the implementation wraps a source that provides leap\n+ * second information, then a mechanism should be used to \"smooth\" the leap second.\n+ * The Java Time-Scale mandates the use of UTC-SLS, however implementations may choose\n+ * how accurate they are with the time-scale so long as they document how they work.\n+ * Implementations are therefore not required to actually perform the UTC-SLS slew or to\n+ * otherwise be aware of leap seconds.\n+ * <p>\n+ * Implementations should implement {@code Serializable} wherever possible and must\n+ * document whether or not they do support serialization.\n+ *\n+ * @implNote\n+ * The implementation provided here is based on the same underlying system clock\n+ * as {@link System#currentTimeMillis()}, but may have a precision finer than\n+ * milliseconds if available.\n+ * However, little to no guarantee is provided about the accuracy of the\n+ * underlying system clock. Applications requiring a more accurate system clock must\n+ * implement this abstract class themselves using a different external system clock,\n+ * such as an NTP server.\n+ *\n+ * @since 17\n+ *\/\n+public interface InstantSource {\n+\n+    \/**\n+     * Obtains a source that returns the current instant using the best available\n+     * system clock.\n+     * <p>\n+     * This source is based on the best available system clock. This may use\n+     * {@link System#currentTimeMillis()}, or a higher resolution system clock if\n+     * one is available.\n+     * <p>\n+     * The returned implementation is immutable, thread-safe and\n+     * {@code Serializable}.\n+     *\n+     * @return a source that uses the best available system clock, not null\n+     *\/\n+    static InstantSource system() {\n+        return SystemInstantSource.INSTANCE;\n+    }\n+\n+    \/\/-------------------------------------------------------------------------\n+    \/**\n+     * Obtains a source that returns instants from the specified source truncated to\n+     * the nearest occurrence of the specified duration.\n+     * <p>\n+     * This source will only tick as per the specified duration. Thus, if the\n+     * duration is half a second, the source will return instants truncated to the\n+     * half second.\n+     * <p>\n+     * The tick duration must be positive. If it has a part smaller than a whole\n+     * millisecond, then the whole duration must divide into one second without\n+     * leaving a remainder. All normal tick durations will match these criteria,\n+     * including any multiple of hours, minutes, seconds and milliseconds, and\n+     * sensible nanosecond durations, such as 20ns, 250,000ns and 500,000ns.\n+     * <p>\n+     * A duration of zero or one nanosecond would have no truncation effect. Passing\n+     * one of these will return the underlying source.\n+     * <p>\n+     * Implementations may use a caching strategy for performance reasons. As such,\n+     * it is possible that the start of the requested duration observed via this\n+     * source will be later than that observed directly via the underlying source.\n+     * <p>\n+     * The returned implementation is immutable, thread-safe and\n+     * {@code Serializable} providing that the base source is.\n+     *\n+     * @param baseSource  the base source to base the ticking source on, not null\n+     * @param tickDuration  the duration of each visible tick, not negative, not null\n+     * @return a source that ticks in whole units of the duration, not null\n+     * @throws IllegalArgumentException if the duration is negative, or has a\n+     *  part smaller than a whole millisecond such that the whole duration is not\n+     *  divisible into one second\n+     * @throws ArithmeticException if the duration is too large to be represented as nanos\n+     *\/\n+    static InstantSource tick(InstantSource baseSource, Duration tickDuration) {\n+        Objects.requireNonNull(baseSource, \"baseSource\");\n+        return Clock.tick(baseSource.withZone(ZoneOffset.UTC), tickDuration);\n+    }\n+\n+    \/\/-----------------------------------------------------------------------\n+    \/**\n+     * Obtains a source that always returns the same instant.\n+     * <p>\n+     * This source simply returns the specified instant.\n+     * As such, it is not a source that represents the current instant.\n+     * The main use case for this is in testing, where the fixed source ensures\n+     * tests are not dependent on the current source.\n+     * <p>\n+     * The returned implementation is immutable, thread-safe and {@code Serializable}.\n+     *\n+     * @param fixedInstant  the instant to use, not null\n+     * @return a source that always returns the same instant, not null\n+     *\/\n+    static InstantSource fixed(Instant fixedInstant) {\n+        return Clock.fixed(fixedInstant, ZoneOffset.UTC);\n+    }\n+\n+    \/\/-------------------------------------------------------------------------\n+    \/**\n+     * Obtains a source that returns instants from the specified source with the\n+     * specified duration added.\n+     * <p>\n+     * This source wraps another source, returning instants that are later by the\n+     * specified duration. If the duration is negative, the instants will be\n+     * earlier than the current date and time.\n+     * The main use case for this is to simulate running in the future or in the past.\n+     * <p>\n+     * A duration of zero would have no offsetting effect.\n+     * Passing zero will return the underlying source.\n+     * <p>\n+     * The returned implementation is immutable, thread-safe and {@code Serializable}\n+     * providing that the base source is.\n+     *\n+     * @param baseSource  the base source to add the duration to, not null\n+     * @param offsetDuration  the duration to add, not null\n+     * @return a source based on the base source with the duration added, not null\n+     *\/\n+    static InstantSource offset(InstantSource baseSource, Duration offsetDuration) {\n+        Objects.requireNonNull(baseSource, \"baseSource\");\n+        return Clock.offset(baseSource.withZone(ZoneOffset.UTC), offsetDuration);\n+    }\n+\n+    \/\/-----------------------------------------------------------------------\n+    \/**\n+     * Gets the current instant of the source.\n+     * <p>\n+     * This returns an instant representing the current instant as defined by the source.\n+     *\n+     * @return the current instant from this source, not null\n+     * @throws DateTimeException if the instant cannot be obtained, not thrown by most implementations\n+     *\/\n+    Instant instant();\n+\n+    \/\/-------------------------------------------------------------------------\n+    \/**\n+     * Gets the current millisecond instant of the source.\n+     * <p>\n+     * This returns the millisecond-based instant, measured from 1970-01-01T00:00Z (UTC).\n+     * This is equivalent to the definition of {@link System#currentTimeMillis()}.\n+     * <p>\n+     * Most applications should avoid this method and use {@link Instant} to represent\n+     * an instant on the time-line rather than a raw millisecond value.\n+     * This method is provided to allow the use of the source in high performance use cases\n+     * where the creation of an object would be unacceptable.\n+     *\n+     * @implSpec\n+     * The default implementation calls {@link #instant()}.\n+     *\n+     * @return the current millisecond instant from this source, measured from\n+     *  the Java epoch of 1970-01-01T00:00Z (UTC), not null\n+     * @throws DateTimeException if the instant cannot be obtained, not thrown by most implementations\n+     *\/\n+    default long millis() {\n+        return instant().toEpochMilli();\n+    }\n+\n+    \/\/-----------------------------------------------------------------------\n+    \/**\n+     * Returns a clock with the specified time-zone.\n+     * <p>\n+     * This returns a {@link Clock}, which is an extension of this interface\n+     * that combines this source and the specified time-zone.\n+     * <p>\n+     * The returned implementation is immutable, thread-safe and {@code Serializable}\n+     * providing that this source is.\n+     *\n+     * @implSpec\n+     * The default implementation returns an immutable, thread-safe and\n+     * {@code Serializable} subclass of {@link Clock} that combines this\n+     * source and the specified zone.\n+     *\n+     * @param zone  the time-zone to use, not null\n+     * @return a clock based on this source with the specified time-zone, not null\n+     *\/\n+    default Clock withZone(ZoneId zone) {\n+        return new SourceClock(this, zone);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/time\/InstantSource.java","additions":254,"deletions":0,"binary":false,"changes":254,"status":"added"},{"patch":"@@ -595,2 +595,5 @@\n-     * changed using the {@code setValue} method.  This class\n-     * facilitates the process of building custom map\n+     * changed using the {@code setValue} method. Instances of\n+     * this class are not associated with any map's entry-set view.\n+     *\n+     * @apiNote\n+     * This class facilitates the process of building custom map\n@@ -728,4 +731,15 @@\n-     * An Entry maintaining an immutable key and value.  This class\n-     * does not support method {@code setValue}.  This class may be\n-     * convenient in methods that return thread-safe snapshots of\n-     * key-value mappings.\n+     * An unmodifiable Entry maintaining a key and a value.  This class\n+     * does not support the {@code setValue} method. Instances of\n+     * this class are not associated with any map's entry-set view.\n+     *\n+     * @apiNote\n+     * Instances of this class are not necessarily immutable, as the key\n+     * and value may be mutable. An instance of <i>this specific class<\/i>\n+     * is unmodifiable, because the key and value references cannot be\n+     * changed. A reference of this <i>type<\/i> may not be unmodifiable,\n+     * as a subclass may be modifiable or may provide the appearance of modifiability.\n+     * <p>\n+     * This class may be convenient in methods that return thread-safe snapshots of\n+     * key-value mappings. For alternatives, see the\n+     * {@link Map#entry Map::entry} and {@link Map.Entry#copyOf Map.Entry::copyOf}\n+     * methods.\n@@ -791,1 +805,4 @@\n-         * an <i>immutable<\/i> map entry.\n+         * an unmodifiable map entry.\n+         *\n+         * @implSpec\n+         * The implementation in this class always throws {@code UnsupportedOperationException}.\n","filename":"src\/java.base\/share\/classes\/java\/util\/AbstractMap.java","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -396,8 +396,27 @@\n-     * A map entry (key-value pair).  The {@code Map.entrySet} method returns\n-     * a collection-view of the map, whose elements are of this class.  The\n-     * <i>only<\/i> way to obtain a reference to a map entry is from the\n-     * iterator of this collection-view.  These {@code Map.Entry} objects are\n-     * valid <i>only<\/i> for the duration of the iteration; more formally,\n-     * the behavior of a map entry is undefined if the backing map has been\n-     * modified after the entry was returned by the iterator, except through\n-     * the {@code setValue} operation on the map entry.\n+     * A map entry (key-value pair). The Entry may be unmodifiable, or the\n+     * value may be modifiable if the optional {@code setValue} method is\n+     * implemented. The Entry may be independent of any map, or it may represent\n+     * an entry of the entry-set view of a map.\n+     * <p>\n+     * Instances of the {@code Map.Entry} interface may be obtained by iterating\n+     * the entry-set view of a map. These instances maintain a connection to the\n+     * original, backing map. This connection to the backing map is valid\n+     * <i>only<\/i> for the duration of iteration over the entry-set view.\n+     * During iteration of the entry-set view, if supported by the backing map,\n+     * a change to a {@code Map.Entry}'s value via the\n+     * {@link Map.Entry#setValue setValue} method will be visible in the backing map.\n+     * The behavior of such a {@code Map.Entry} instance is undefined outside of\n+     * iteration of the map's entry-set view. It is also undefined if the backing\n+     * map has been modified after the {@code Map.Entry} was returned by the\n+     * iterator, except through the {@code Map.Entry.setValue} method. In particular,\n+     * a change to the value of a mapping in the backing map might or might not be\n+     * visible in the corresponding {@code Map.Entry} element of the entry-set view.\n+     *\n+     * @apiNote\n+     * It is possible to create a {@code Map.Entry} instance that is disconnected\n+     * from a backing map by using the {@link Map.Entry#copyOf copyOf} method. For example,\n+     * the following creates a snapshot of a map's entries that is guaranteed not to\n+     * change even if the original map is modified:\n+     * <pre> {@code\n+     * var entries = map.entrySet().stream().map(Map.Entry::copyOf).toList()\n+     * }<\/pre>\n@@ -562,0 +581,31 @@\n+\n+        \/**\n+         * Returns a copy of the given {@code Map.Entry}. The returned instance is not\n+         * associated with any map. The returned instance has the same characteristics\n+         * as instances returned by the {@link Map#entry Map::entry} method.\n+         *\n+         * @apiNote\n+         * An instance obtained from a map's entry-set view has a connection to that map.\n+         * The {@code copyOf}  method may be used to create a {@code Map.Entry} instance,\n+         * containing the same key and value, that is independent of any map.\n+         *\n+         * @implNote\n+         * If the given entry was obtained from a call to {@code copyOf} or {@code Map::entry},\n+         * calling {@code copyOf} will generally not create another copy.\n+         *\n+         * @param <K> the type of the key\n+         * @param <V> the type of the value\n+         * @param e the entry to be copied\n+         * @return a map entry equal to the given entry\n+         * @throws NullPointerException if e is null or if either of its key or value is null\n+         * @since 17\n+         *\/\n+        @SuppressWarnings(\"unchecked\")\n+        public static <K, V> Map.Entry<K, V> copyOf(Map.Entry<? extends K, ? extends V> e) {\n+            Objects.requireNonNull(e);\n+            if (e instanceof KeyValueHolder) {\n+                return (Map.Entry<K, V>) e;\n+            } else {\n+                return Map.entry(e.getKey(), e.getValue());\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/Map.java","additions":58,"deletions":8,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.javac;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/**\n+ * The element annotated with this annotation should not be marked as a preview element.\n+ *\/\n+@Target({ElementType.METHOD,\n+         ElementType.CONSTRUCTOR,\n+         ElementType.FIELD,\n+         ElementType.PACKAGE,\n+         ElementType.MODULE,\n+         ElementType.TYPE})\n+@Retention(RetentionPolicy.CLASS)\n+public @interface NoPreview {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/NoPreview.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -61,0 +61,1 @@\n+        SWITCH_PATTERN_MATCHING,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V17) {\n+        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V18) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ClassReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -316,0 +316,1 @@\n+    int V18 = 0 << 16 | 62;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Opcodes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    private static final String JDK_SERIAL_FILTER_FACTORY;\n@@ -65,0 +66,1 @@\n+        JDK_SERIAL_FILTER_FACTORY = getProperty(props, \"jdk.serialFilterFactory\", null);\n@@ -187,0 +189,14 @@\n+\n+    \/**\n+     * Return the {@code jdk.serialFilterFactory} system property.\n+     *\n+     * <strong>{@link SecurityManager#checkPropertyAccess} is NOT checked\n+     * in this method. The caller of this method should take care to ensure\n+     * that the returned property is not made accessible to untrusted code.<\/strong>\n+     *\n+     * @return the {@code user.name} system property\n+     *\/\n+    public static String jdkSerialFilterFactory() {\n+        return JDK_SERIAL_FILTER_FACTORY;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/StaticProperty.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-    private static native boolean socketSupported();\n+    private static native boolean init();\n@@ -179,1 +179,1 @@\n-        supported = socketSupported();\n+        supported = init();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/UnixDomainSockets.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -359,1 +359,3 @@\n-                memberType.getClass().getName());\n+                Proxy.isProxyClass(memberType)\n+                        ? memberType.getInterfaces()[0].getName()\n+                        : memberType.getName());\n@@ -362,2 +364,7 @@\n-            result = new AnnotationTypeMismatchExceptionProxy(\n-                result.getClass() + \"[\" + result + \"]\");\n+            if (result instanceof Annotation) {\n+                result = new AnnotationTypeMismatchExceptionProxy(\n+                    result.toString());\n+            } else {\n+                result = new AnnotationTypeMismatchExceptionProxy(\n+                    result.getClass().getName() + \"[\" + result + \"]\");\n+            }\n@@ -466,4 +473,1 @@\n-        if (!enumType.isEnum()) {\n-            return new AnnotationTypeMismatchExceptionProxy(\n-                typeName + \".\" + constName);\n-        } else if (enumType != parseSig(typeName, container)) {\n+        if (!enumType.isEnum() || enumType != parseSig(typeName, container)) {\n@@ -471,1 +475,1 @@\n-                typeName + \".\" + constName);\n+                    typeName.substring(1, typeName.length() - 1).replace('\/', '.') + \".\" + constName);\n@@ -527,2 +531,1 @@\n-        } else {\n-            assert componentType.isAnnotation();\n+        } else if (componentType.isAnnotation()) {\n@@ -531,0 +534,2 @@\n+        } else {\n+            return parseUnknownArray(length, buf);\n@@ -752,0 +757,12 @@\n+    private static Object parseUnknownArray(int length,\n+                                            ByteBuffer buf) {\n+        int tag = 0;\n+\n+        for (int i = 0; i < length; i++) {\n+            tag = buf.get();\n+            skipMemberValue(tag, buf);\n+        }\n+\n+        return exceptionProxy(tag);\n+    }\n+\n@@ -758,1 +775,1 @@\n-            \"Array with component tag: \" + tag);\n+            \"Array with component tag: \" + (tag == 0 ? \"0\" : (char) tag));\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/AnnotationParser.java","additions":28,"deletions":11,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -371,1 +371,1 @@\n-            \/\/ hack for working around API bug\n+            \/\/ workaround for API bug\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPSSSignature.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -590,1 +590,1 @@\n-                SSLLogger.warning(\"SSLSocket duplex close failed\", ioe);\n+                SSLLogger.warning(\"SSLSocket duplex close failed. Debug info only. Exception details:\", ioe);\n@@ -600,1 +600,1 @@\n-                        SSLLogger.warning(\"SSLSocket close failed\", ioe);\n+                        SSLLogger.warning(\"SSLSocket close failed. Debug info only. Exception details:\", ioe);\n@@ -1137,1 +1137,1 @@\n-                    SSLLogger.warning(\"input stream close failed\", ioe);\n+                    SSLLogger.warning(\"input stream close failed. Debug info only. Exception details:\", ioe);\n@@ -1332,1 +1332,1 @@\n-                    SSLLogger.warning(\"output stream close failed\", ioe);\n+                    SSLLogger.warning(\"output stream close failed. Debug info only. Exception details:\", ioe);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-            \/\/ Hack code to deliver SSLv2 error message for SSL\/TLS connections.\n+            \/\/ Code to deliver SSLv2 error message for SSL\/TLS connections.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLTransport.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,1 @@\n-        \/\/ This is a hack to allow SunJSSE to work with 3rd party crypto\n+        \/\/ This code allows SunJSSE to work with 3rd party crypto\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/CurveDB.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -220,2 +220,0 @@\n-        store(\"AES\", KnownOIDs.AES, \"Rijndael\");\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SecurityProviderConstants.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -982,0 +982,18 @@\n+\n+#\n+# Deserialization system-wide filter factory\n+#\n+# A filter factory class name is used to configure the system-wide filter factory.\n+# The filter factory value \"OVERRIDE\" in combination with setting \"jdk.serialFilter\"\n+# indicates that the builtin filter factory can be overridden by the application.\n+# The class must be public, must have a public zero-argument constructor, implement the\n+# java.util.stream.BinaryOperator<ObjectInputFilter> interface, provide its implementation and\n+# be accessible via the application class loader.\n+# A builtin filter factory is used if no filter factory is defined.\n+# See java.io.ObjectInputFilter.Config for more information.\n+#\n+# If the system property jdk.serialFilterFactory is also specified, it supersedes\n+# the security property value defined here.\n+#\n+#jdk.serialFilterFactory=<classname>\n+\n@@ -983,1 +1001,1 @@\n-# Serialization system-wide filter\n+# Deserialization system-wide filter\n@@ -985,2 +1003,2 @@\n-# A filter, if configured, is used by java.io.ObjectInputStream during\n-# deserialization to check the contents of the stream.\n+# A filter, if configured, is used by the filter factory to provide the filter used by\n+# java.io.ObjectInputStream during deserialization to check the contents of the stream.\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1406,3 +1406,3 @@\n-Sets the maximum size (in bytes) for large pages used for the Java heap.\n-The \\f[I]size\\f[R] argument must be a power of 2 (2, 4, 8, 16, and so\n-on).\n+Sets the maximum large page size (in bytes) used by the JVM.\n+The \\f[I]size\\f[R] argument must be a valid page size supported by the\n+environment to have any effect.\n@@ -1412,2 +1412,3 @@\n-By default, the size is set to 0, meaning that the JVM chooses the size\n-for large pages automatically.\n+By default, the size is set to 0, meaning that the JVM will use the\n+default large page size for the environment as the maximum size for\n+large pages.\n@@ -1417,2 +1418,2 @@\n-The following example describes how to set the large page size to 4\n-megabytes (MB):\n+The following example describes how to set the large page size to 1\n+gigabyte (GB):\n@@ -1421,1 +1422,1 @@\n-\\f[CB]\\-XX:LargePageSizeInBytes=4m\\f[R]\n+\\f[CB]\\-XX:LargePageSizeInBytes=1g\\f[R]\n@@ -1759,0 +1760,16 @@\n+.PP\n+Event settings and .jfc options can also be specified using the following\n+syntax:\n+.TP\n+.B \\f[CB]option=\\f[R]\\f[I]value\\f[R]\n+Specifies the option value to modify. To list available options, use the \n+JAVA_HOME\/bin\/jfr tool.\n+.TP\n+.B \\f[CB]event-setting=\\f[R]\\f[I]value\\f[R]\n+Specifies the event setting value to modify. Use the form:\n+<event-name>#<setting-name>=<value>\n+To add a new event setting, prefix the event name with '+'.\n+.PP\n+In case of a conflict between a parameter and a .jfc option, the parameter\n+will take precedence. The whitespace delimiter can be omitted for timespan values, i.e. 20ms. For\n+more information about the settings syntax, see Javadoc of the jdk.jfr package.\n@@ -5123,3 +5140,2 @@\n-However, large pages page memory can negatively affect system\n-performance.\n-For example, when a large mount of memory is pinned by an application,\n+However, using large pages can negatively affect system performance.\n+For example, when a large amount of memory is pinned by an application,\n@@ -5136,4 +5152,2 @@\n-The 2.6 kernel supports large pages.\n-Some vendors have backported the code to their 2.4\\-based releases.\n-To check if your system can support large page memory, try the\n-following:\n+Linux supports large pages since version 2.6.\n+To check if your environment supports large pages, try the following:\n@@ -5146,0 +5160,1 @@\n+\\&...\n@@ -5150,13 +5165,23 @@\n-If the output shows the three \"Huge\" variables, then your system can\n-support large page memory but it needs to be configured.\n-If the command prints nothing, then your system doesn\\[aq]t support\n-large pages.\n-To configure the system to use large page memory, login as\n-\\f[CB]root\\f[R], and then follow these steps:\n-.IP \"1.\" 3\n-If you\\[aq]re using the option \\f[CB]\\-XX:+UseSHM\\f[R] (instead of\n-\\f[CB]\\-XX:+UseHugeTLBFS\\f[R]), then increase the \\f[CB]SHMMAX\\f[R] value.\n-It must be larger than the Java heap size.\n-On a system with 4 GB of physical RAM (or less), the following makes all\n-the memory sharable:\n-.RS 4\n+If the output contains items prefixed with \"Huge\", then your system\n+supports large pages.\n+The values may vary depending on environment.\n+The \\f[CB]Hugepagesize\\f[R] field shows the default large page size in\n+your environment, and the other fields show details for large pages of\n+this size.\n+Newer kernels have support for multiple large page sizes.\n+To list the supported page sizes, run this:\n+.IP\n+.nf\n+\\f[CB]\n+#\\ ls\\ \/sys\/kernel\/mm\/hugepages\/\n+hugepages\\-1048576kB\\ \\ hugepages\\-2048kB\n+\\f[R]\n+.fi\n+.PP\n+The above environment supports 2 MB and 1 GB large pages, but they need\n+to be configured so that the JVM can use them.\n+When using large pages and not enabling transparent huge pages (option\n+\\f[CB]\\-XX:+UseTransparentHugePages\\f[R]), the number of large pages must\n+be pre\\-allocated.\n+For example, to enable 8 GB of memory to be backed by 2 MB large pages,\n+login as \\f[CB]root\\f[R] and run:\n@@ -5165,1 +5190,1 @@\n-\\f[CB]#\\ echo\\ 4294967295\\ >\\ \/proc\/sys\/kernel\/shmmax\\f[R]\n+\\f[CB]#\\ echo\\ 4096\\ >\\ \/sys\/kernel\/mm\/hugepages\/hugepages\\-2048kB\/nr_hugepages\\f[R]\n@@ -5167,8 +5192,10 @@\n-.RE\n-.IP \"2.\" 3\n-If you\\[aq]re using the option \\f[CB]\\-XX:+UseSHM\\f[R] or\n-\\f[CB]\\-XX:+UseHugeTLBFS\\f[R], then specify the number of large pages.\n-In the following example, 3 GB of a 4 GB system are reserved for large\n-pages (assuming a large page size of 2048kB, then 3 GB = 3 * 1024 MB =\n-3072 MB = 3072 * 1024 kB = 3145728 kB and 3145728 kB \/ 2048 kB = 1536):\n-.RS 4\n+.PP\n+It is always recommended to check the value of \\f[CB]nr_hugepages\\f[R]\n+after the request to make sure the kernel was able to allocate the\n+requested number of large pages.\n+.PP\n+When using the option \\f[CB]\\-XX:+UseSHM\\f[R] to enable large pages you\n+also need to make sure the \\f[CB]SHMMAX\\f[R] parameter is configured to\n+allow large enough shared memory segments to be allocated.\n+To allow a maximum shared segment of 8 GB, login as \\f[CB]root\\f[R] and\n+run:\n@@ -5177,1 +5204,1 @@\n-\\f[CB]#\\ echo\\ 1536\\ >\\ \/proc\/sys\/vm\/nr_hugepages\\f[R]\n+\\f[CB]#\\ echo\\ 8589934592\\ >\\ \/proc\/sys\/kernel\/shmmax\\f[R]\n@@ -5179,0 +5206,4 @@\n+.PP\n+In some environments this is not needed since the default value is large\n+enough, but it is important to make sure the value is large enough to\n+fit the amount of memory intended to be backed by large pages.\n@@ -5181,3 +5212,4 @@\n-\\f[B]Note:\\f[R] The values contained in \\f[CB]\/proc\\f[R] resets after you\n-reboot your system, so may want to set them in an initialization script\n-(for example, \\f[CB]rc.local\\f[R] or \\f[CB]sysctl.conf\\f[R]).\n+\\f[B]Note:\\f[R] The values contained in \\f[CB]\/proc\\f[R] and \\f[CB]\/sys\\f[R]\n+reset after you reboot your system, so may want to set them in an\n+initialization script (for example, \\f[CB]rc.local\\f[R] or\n+\\f[CB]sysctl.conf\\f[R]).\n@@ -5185,10 +5217,4 @@\n-.RE\n-.IP \\[bu] 2\n-If you configure (or resize) the OS kernel parameters\n-\\f[CB]\/proc\/sys\/kernel\/shmmax\\f[R] or \\f[CB]\/proc\/sys\/vm\/nr_hugepages\\f[R],\n-Java processes may allocate large pages for areas in addition to the\n-Java heap.\n-These steps can allocate large pages for the following areas:\n-.RS 2\n-.IP \\[bu] 2\n-Java heap\n+.PP\n+If you configure the OS kernel parameters to enable use of large pages,\n+the Java processes may allocate large pages for the Java heap as well as\n+other internal areas, for example:\n@@ -5198,1 +5224,1 @@\n-The marking bitmap data structure for the parallel GC\n+Marking bitmaps\n@@ -5201,3 +5227,3 @@\n-the size of the Java heap, then the JVM can fail in allocating the code\n-cache areas on large pages because these areas are quite large in size.\n-.RE\n+the size of the Java heap, then the JVM can still fail to allocate the\n+heap using large pages because other areas such as the code cache might\n+already have used some of the configured large pages.\n","filename":"src\/java.base\/share\/man\/java.1","additions":81,"deletions":55,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -36,5 +36,5 @@\n-                                                               jstring invokedName,\n-                                                               jobject invokedType,\n-                                                               jobject methodType,\n-                                                               jobject implMethodMember,\n-                                                               jobject instantiatedMethodType,\n+                                                               jstring interfaceMethodName,\n+                                                               jobject factoryType,\n+                                                               jobject interfaceMethodType,\n+                                                               jobject implementationMember,\n+                                                               jobject dynamicMethodType,\n@@ -42,3 +42,3 @@\n-    JVM_RegisterLambdaProxyClassForArchiving(env, caller, invokedName, invokedType,\n-                                             methodType, implMethodMember,\n-                                             instantiatedMethodType, lambdaProxyClass);\n+    JVM_RegisterLambdaProxyClassForArchiving(env, caller, interfaceMethodName, factoryType,\n+                                             interfaceMethodType, implementationMember,\n+                                             dynamicMethodType, lambdaProxyClass);\n@@ -50,8 +50,8 @@\n-                                                            jstring invokedName,\n-                                                            jobject invokedType,\n-                                                            jobject methodType,\n-                                                            jobject implMethodMember,\n-                                                            jobject instantiatedMethodType) {\n-    return JVM_LookupLambdaProxyClassFromArchive(env, caller, invokedName, invokedType,\n-                                                 methodType, implMethodMember,\n-                                                 instantiatedMethodType);\n+                                                            jstring interfaceMethodName,\n+                                                            jobject factoryType,\n+                                                            jobject interfaceMethodType,\n+                                                            jobject implementationMember,\n+                                                            jobject dynamicMethodType) {\n+    return JVM_LookupLambdaProxyClassFromArchive(env, caller, interfaceMethodName, factoryType,\n+                                                 interfaceMethodType, implementationMember,\n+                                                 dynamicMethodType);\n","filename":"src\/java.base\/share\/native\/libjava\/LambdaProxyClassArchive.c","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3247,0 +3247,1 @@\n+            assert(new != NULL);\n","filename":"src\/java.base\/share\/native\/libverify\/check_code.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-Java_sun_nio_ch_UnixDomainSockets_socketSupported(JNIEnv *env, jclass cl)\n+Java_sun_nio_ch_UnixDomainSockets_init(JNIEnv *env, jclass cl)\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/UnixDomainSockets.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,3 @@\n+\/* The winsock provider ID of the Microsoft AF_UNIX implementation *\/\n+static GUID MS_PROVIDER_ID  = {0xA00943D9,0x9C2E,0x4633,{0x9B,0x59,0,0x57,0xA3,0x16,0x09,0x94}};\n+\n@@ -87,5 +90,6 @@\n-JNIEXPORT jboolean JNICALL\n-Java_sun_nio_ch_UnixDomainSockets_socketSupported(JNIEnv *env, jclass cl)\n-{\n-    SOCKET s = socket(PF_UNIX, SOCK_STREAM, 0);\n-    if (s == INVALID_SOCKET) {\n+static int cmpGuid(GUID *g1, GUID *g2) {\n+    if (g1->Data1 != g2->Data1)\n+        return JNI_FALSE;\n+    if (g1->Data2 != g2->Data2)\n+        return JNI_FALSE;\n+    if (g1->Data3 != g2->Data3)\n@@ -93,0 +97,3 @@\n+    for (int i=0; i<8; i++) {\n+        if (g1->Data4[i] != g2->Data4[i])\n+            return JNI_FALSE;\n@@ -94,1 +101,0 @@\n-    closesocket(s);\n@@ -98,0 +104,52 @@\n+static WSAPROTOCOL_INFOW provider;\n+\n+JNIEXPORT jboolean JNICALL\n+Java_sun_nio_ch_UnixDomainSockets_init(JNIEnv *env, jclass cl)\n+{\n+    WSAPROTOCOL_INFOW info[5]; \/\/ if not large enough, a buffer is malloc'd\n+    LPWSAPROTOCOL_INFOW infoPtr = &info[0];\n+    DWORD len = sizeof(info);\n+    jboolean found = JNI_FALSE;\n+\n+    \/*\n+     * First locate the Microsoft AF_UNIX Winsock provider\n+     *\/\n+    int result = WSAEnumProtocolsW(0, infoPtr, &len);\n+    if (result == SOCKET_ERROR) {\n+        if (GetLastError() == WSAENOBUFS) {\n+            infoPtr = (LPWSAPROTOCOL_INFOW)malloc(len);\n+            result = WSAEnumProtocolsW(0, infoPtr, &len);\n+            if (result == SOCKET_ERROR) {\n+                free(infoPtr);\n+                return JNI_FALSE;\n+            }\n+        } else {\n+            return JNI_FALSE;\n+        }\n+    }\n+    for (int i=0; i<result;  i++) {\n+        if (infoPtr[i].iAddressFamily == AF_UNIX) {\n+            GUID g = infoPtr[i].ProviderId;\n+            if (cmpGuid(&g, &MS_PROVIDER_ID)) {\n+                found = JNI_TRUE;\n+                provider = infoPtr[i];\n+                break;\n+            }\n+        }\n+    }\n+    if (infoPtr != &info[0]) {\n+        free(infoPtr);\n+    }\n+    \/*\n+     * check we can create a socket\n+     *\/\n+    if (found) {\n+        SOCKET s = WSASocketW(PF_UNIX, SOCK_STREAM, 0, &provider, 0, WSA_FLAG_OVERLAPPED);\n+        if (s == INVALID_SOCKET) {\n+            return JNI_FALSE;\n+        }\n+        closesocket(s);\n+    }\n+    return found;\n+}\n+\n@@ -101,1 +159,1 @@\n-    SOCKET s = socket(PF_UNIX, SOCK_STREAM, 0);\n+    SOCKET s = WSASocketW(PF_UNIX, SOCK_STREAM, 0, &provider, 0, WSA_FLAG_OVERLAPPED);\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/UnixDomainSockets.c","additions":65,"deletions":7,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -240,1 +240,9 @@\n-    RELEASE_17;\n+    RELEASE_17,\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 18.\n+     *\n+     * @since 18\n+     *\/\n+    RELEASE_18;\n@@ -249,1 +257,1 @@\n-        return RELEASE_17;\n+        return RELEASE_18;\n@@ -264,1 +272,1 @@\n-            valueOf(\"RELEASE_\" + Math.min(17, intVersion)):\n+            valueOf(\"RELEASE_\" + Math.min(18, intVersion)):\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/SourceVersion.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractAnnotationValueVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractElementVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractTypeVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleAnnotationValueVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleElementVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/TypeKindVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.Arrays;\n@@ -68,0 +69,1 @@\n+    private DisplayMode initialMode;\n@@ -71,0 +73,1 @@\n+        this.initialMode = getDisplayMode();\n@@ -204,0 +207,1 @@\n+        initialMode = device.initialMode;\n@@ -310,0 +314,13 @@\n+    \/* If the modes are the same or the only difference is that\n+     * the new mode will match any refresh rate, no need to change.\n+     *\/\n+    private boolean isSameMode(final DisplayMode newMode,\n+                               final DisplayMode oldMode) {\n+\n+        return (Objects.equals(newMode, oldMode) ||\n+                (newMode.getRefreshRate() == DisplayMode.REFRESH_RATE_UNKNOWN &&\n+                 newMode.getWidth() == oldMode.getWidth() &&\n+                 newMode.getHeight() == oldMode.getHeight() &&\n+                 newMode.getBitDepth() == oldMode.getBitDepth()));\n+    }\n+\n@@ -315,3 +332,23 @@\n-        if (!Objects.equals(dm, getDisplayMode())) {\n-            nativeSetDisplayMode(displayID, dm.getWidth(), dm.getHeight(),\n-                                 dm.getBitDepth(), dm.getRefreshRate());\n+        if (!isSameMode(dm, getDisplayMode())) {\n+            try {\n+                nativeSetDisplayMode(displayID, dm.getWidth(), dm.getHeight(),\n+                                    dm.getBitDepth(), dm.getRefreshRate());\n+            } catch (Throwable t) {\n+                \/* In some cases macOS doesn't report the initial mode\n+                 * in the list of supported modes.\n+                 * If trying to reset to that mode causes an exception\n+                 * try one more time to reset using a different API.\n+                 * This does not fix everything, such as it doesn't make\n+                 * that mode reported and it restores all devices, but\n+                 * this seems a better compromise than failing to restore\n+                 *\/\n+                if (isSameMode(dm, initialMode)) {\n+                    nativeResetDisplayMode();\n+                    if (!isSameMode(initialMode, getDisplayMode())) {\n+                        throw new IllegalArgumentException(\n+                            \"Could not reset to initial mode\");\n+                    }\n+                } else {\n+                   throw t;\n+                }\n+            }\n@@ -328,1 +365,16 @@\n-        return nativeGetDisplayModes(displayID);\n+        DisplayMode[] nativeModes = nativeGetDisplayModes(displayID);\n+        boolean match = false;\n+        for (DisplayMode mode : nativeModes) {\n+            if (initialMode.equals(mode)) {\n+                match = true;\n+                break;\n+            }\n+        }\n+        if (match) {\n+            return nativeModes;\n+        } else {\n+          int len = nativeModes.length;\n+          DisplayMode[] modes = Arrays.copyOf(nativeModes, len+1, DisplayMode[].class);\n+          modes[len] = initialMode;\n+          return modes;\n+        }\n@@ -348,0 +400,2 @@\n+    private static native void nativeResetDisplayMode();\n+\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/awt\/CGraphicsDevice.java","additions":58,"deletions":4,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+import java.security.AccessController;\n@@ -70,0 +71,1 @@\n+import sun.security.action.GetPropertyAction;\n@@ -88,0 +90,1 @@\n+    private static native void nativeSetAllowAutomaticTabbingProperty(boolean allowAutomaticWindowTabbing);\n@@ -127,0 +130,6 @@\n+    \/\/ This system property is named as jdk.* because it is not specific to AWT\n+    \/\/ and it is also used in JavaFX\n+    @SuppressWarnings(\"removal\")\n+    public static final String MAC_OS_TABBED_WINDOW = AccessController.doPrivileged(\n+            new GetPropertyAction(\"jdk.allowMacOSTabbedWindows\"));\n+\n@@ -190,0 +199,4 @@\n+    static {\n+        nativeSetAllowAutomaticTabbingProperty(Boolean.parseBoolean(MAC_OS_TABBED_WINDOW));\n+    }\n+\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CPlatformWindow.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1097,0 +1097,18 @@\n+\/*\n+ * Class:     sun_lwawt_macosx_CPlatformWindow\n+ * Method:    nativeSetAllAllowAutomaticTabbingProperty\n+ * Signature: (Z)V\n+ *\/\n+JNIEXPORT void JNICALL Java_sun_lwawt_macosx_CPlatformWindow_nativeSetAllowAutomaticTabbingProperty\n+        (JNIEnv *env, jclass clazz, jboolean allowAutomaticTabbing)\n+{\n+    JNI_COCOA_ENTER(env);\n+    [ThreadUtilities performOnMainThreadWaiting:NO block:^(){\n+        if (allowAutomaticTabbing) {\n+            [NSWindow setAllowsAutomaticWindowTabbing:YES];\n+        } else {\n+            [NSWindow setAllowsAutomaticWindowTabbing:NO];\n+        }\n+    }];\n+    JNI_COCOA_EXIT(env);\n+}\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/AWTWindow.m","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -264,0 +264,12 @@\n+\/*\n+ * Class:     sun_awt_CGraphicsDevice\n+ * Method:    nativeResetDisplayMode\n+ * Signature: ()V\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_awt_CGraphicsDevice_nativeResetDisplayMode\n+(JNIEnv *env, jclass class)\n+{\n+    CGRestorePermanentDisplayConfiguration();\n+}\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CGraphicsDevice.m","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,2 +29,1 @@\n-#define SCREEN_MEMORY_SIZE_4K (4096*2160*4) \/\/~33,7 mb\n-#define MAX_POOL_MEMORY SCREEN_MEMORY_SIZE_4K\/2\n+#define SCREEN_MEMORY_SIZE_5K (5120*4096*4) \/\/~84 mb\n@@ -308,0 +307,1 @@\n+    uint64_t _maxPoolMemory;\n@@ -323,0 +323,10 @@\n+\n+    \/\/ recommendedMaxWorkingSetSize typically greatly exceeds SCREEN_MEMORY_SIZE_5K constant.\n+    \/\/ It usually corresponds to the VRAM available to the graphics card\n+    _maxPoolMemory = self.device.recommendedMaxWorkingSetSize\/2;\n+\n+    \/\/ Set maximum to handle at least 5K screen size\n+    if (_maxPoolMemory < SCREEN_MEMORY_SIZE_5K) {\n+        _maxPoolMemory = SCREEN_MEMORY_SIZE_5K;\n+    }\n+\n@@ -348,1 +358,1 @@\n-        if (_memoryTotalAllocated + requestedBytes > MAX_POOL_MEMORY) {\n+        if (_memoryTotalAllocated + requestedBytes > _maxPoolMemory) {\n@@ -350,1 +360,1 @@\n-        } else if (_memoryTotalAllocated + requestedBytes > MAX_POOL_MEMORY\/2) {\n+        } else if (_memoryTotalAllocated + requestedBytes > _maxPoolMemory\/2) {\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLTexurePool.m","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+    float  ptSize [[point_size]];\n@@ -61,0 +62,1 @@\n+    float  ptSize [[point_size]];\n@@ -84,0 +86,1 @@\n+    float  ptSize [[point_size]];\n@@ -167,0 +170,1 @@\n+    out.ptSize = 1.0;\n@@ -189,0 +193,1 @@\n+    out.ptSize = 1.0;\n@@ -674,0 +679,1 @@\n+    out.ptSize = 1.0;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/shaders.metal","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -298,7 +298,1 @@\n-        synchronized (this) {\n-\n-            if (this.active != active) {\n-                this.active = active;\n-                \/\/sendEvents = true;\n-            }\n-        }\n+        this.active = active;\n@@ -327,6 +321,3 @@\n-        synchronized (this) {\n-\n-            if (this.started != started) {\n-                this.started = started;\n-                sendEvents = true;\n-            }\n+        if (this.started != started) {\n+            this.started = started;\n+            sendEvents = true;\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/AbstractDataLine.java","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -162,5 +162,3 @@\n-        synchronized (this) {\n-            if (this.open != open) {\n-                this.open = open;\n-                sendEvents = true;\n-            }\n+        if (this.open != open) {\n+            this.open = open;\n+            sendEvents = true;\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/AbstractLine.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1195,1 +1195,1 @@\n-        public synchronized void setMicrosecondPosition(long microseconds) {\n+        public void setMicrosecondPosition(long microseconds) {\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/DirectAudioDevice.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,0 +63,8 @@\n+ * <strong>Warning:<\/strong> The {@code JPasswordField} will not show the\n+ * original characters that were typed, instead displaying alternative text or\n+ * graphics. However this doesn't prevent the password from appearing in the\n+ * system memory. For handling confidential information such as the password\n+ * text, refer to the relevant section at\n+ * <a href=\"https:\/\/www.oracle.com\/java\/technologies\/javase\/seccodeguide.html\">\n+ * Secure Coding Guidelines<\/a>.\n+ * <p>\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JPasswordField.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @LastModified: Oct 2017\n+ * @LastModified: June 2021\n@@ -97,2 +97,2 @@\n-        final String name = variable.getName().getStringRep();\n-        return (Variable)_variables.put(name, variable);\n+        VariableBase v = _variables.put(variable.getName().getStringRep(), variable);\n+        return v instanceof Variable ? (Variable)v : null;\n@@ -103,2 +103,2 @@\n-        final String name = parameter.getName().getStringRep();\n-        return (Param)_variables.put(name, parameter);\n+        VariableBase v = _variables.put(parameter.getName().getStringRep(), parameter);\n+        return v instanceof Param ? (Param)v : null;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/compiler\/SymbolTable.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -51,0 +51,2 @@\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n@@ -102,1 +104,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: June 2021\n@@ -513,3 +515,0 @@\n-                    \/\/ if StreamResult(File) or setSystemID(File) was used,\n-                    \/\/ the systemId will be URI encoded as a result of File.toURI(),\n-                    \/\/ it must be decoded for use by URL\n@@ -517,16 +516,4 @@\n-                        URI uri = new URI(systemId) ;\n-                        systemId = \"file:\";\n-\n-                        String host = uri.getHost(); \/\/ decoded String\n-                        String path = uri.getPath(); \/\/decoded String\n-                        if (path == null) {\n-                         path = \"\";\n-                        }\n-\n-                        \/\/ if host (URI authority) then file:\/\/ + host + path\n-                        \/\/ else just path (may be absolute or relative)\n-                        if (host != null) {\n-                         systemId += \"\/\/\" + host + path;\n-                        } else {\n-                         systemId += \"\/\/\" + path;\n-                        }\n+                        Path p = Paths.get(new URI(systemId));\n+                        _ostream = new FileOutputStream(p.toFile());\n+                        _tohFactory.setOutputStream(_ostream);\n+                        return _tohFactory.getSerializationHandler();\n@@ -534,2 +521,2 @@\n-                    catch (Exception  exception) {\n-                        \/\/ URI exception which means nothing can be done so OK to ignore\n+                    catch (Exception e) {\n+                        throw new TransformerException(e);\n@@ -537,5 +524,0 @@\n-\n-                    url = new URL(systemId);\n-                    _ostream = new FileOutputStream(url.getFile());\n-                    _tohFactory.setOutputStream(_ostream);\n-                    return _tohFactory.getSerializationHandler();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/trax\/TransformerImpl.java","additions":9,"deletions":27,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n@@ -99,6 +97,4 @@\n-        try {\n-            outputStream = new FileOutputStream(f);\n-        } catch (FileNotFoundException ex) {\n-            \/\/ fall back to the original implementation for compatibility\n-            setSystemId(f.toURI().toASCIIString());\n-        }\n+        \/\/convert file to appropriate URI, f.toURI().toASCIIString()\n+        \/\/converts the URI to string as per rule specified in\n+        \/\/RFC 2396,\n+        setSystemId(f.toURI().toASCIIString());\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/transform\/stream\/StreamResult.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,2 @@\n-            File f = createAttachFile(pid);\n+            \/\/ Keep canonical version of File, to delete, in case target process ends and \/proc link has gone:\n+            File f = createAttachFile(pid).getCanonicalFile();\n@@ -278,1 +279,0 @@\n-            f = f.getCanonicalFile();\n","filename":"src\/jdk.attach\/aix\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,2 @@\n-            File f = createAttachFile(pid, ns_pid);\n+            \/\/ Keep canonical version of File, to delete, in case target process ends and \/proc link has gone:\n+            File f = createAttachFile(pid, ns_pid).getCanonicalFile();\n@@ -293,1 +294,1 @@\n-            f = f.getCanonicalFile();\n+            \/\/ Do not canonicalize the file path, or we will fail to attach to a VM in a container.\n@@ -306,1 +307,0 @@\n-            f = f.getCanonicalFile();\n","filename":"src\/jdk.attach\/linux\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.source.tree;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A marker interface for {@code Tree}s that may be used as {@link CaseTree} labels.\n+ *\n+ * @since 17\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+public interface CaseLabelTree extends Tree {}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/CaseLabelTree.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -68,0 +70,10 @@\n+    \/**\n+     * Returns the labels for this case.\n+     * For {@code default} case return a list with a single element, {@link DefaultCaseLabelTree}.\n+     *\n+     * @return labels for this case\n+     * @since 17\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    List<? extends CaseLabelTree> getLabels();\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/CaseTree.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.source.tree;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A case label that marks {@code default} in {@code case null, default}.\n+ *\n+ * @since 17\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+public interface DefaultCaseLabelTree extends CaseLabelTree {}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/DefaultCaseLabelTree.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.NoPreview;\n+\n@@ -38,1 +40,2 @@\n-public interface ExpressionTree extends Tree {}\n+@NoPreview\n+public interface ExpressionTree extends Tree, CaseLabelTree {}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/ExpressionTree.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.source.tree;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A guard pattern tree.\n+ *\n+ * @since 17\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+public interface GuardedPatternTree extends PatternTree {\n+\n+    \/**\n+     * The guarded pattern expression.\n+     * @return the guarded pattern\n+     *\/\n+    public PatternTree getPattern();\n+\n+    \/**\n+     * The guard expression.\n+     * @return the guard expression\n+     *\/\n+    public ExpressionTree getExpression();\n+\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/GuardedPatternTree.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2005, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.source.tree;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A tree node for a parenthesized pattern.\n+ *\n+ * For example:\n+ * <pre>\n+ *   ( <em>pattern<\/em> )\n+ * <\/pre>\n+ *\n+ * @jls 14.30.1 Kinds of Patterns\n+ *\n+ * @since 17\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+public interface ParenthesizedPatternTree extends PatternTree {\n+    \/**\n+     * Returns the pattern within the parentheses.\n+     * @return the pattern\n+     *\/\n+    PatternTree getPattern();\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/ParenthesizedPatternTree.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -34,1 +34,1 @@\n-public interface PatternTree extends Tree {}\n+public interface PatternTree extends Tree, CaseLabelTree {}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/PatternTree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -229,0 +231,24 @@\n+        \/**\n+         * Used for instances of {@link GuardedPatternTree}.\n+         *\n+         * @since 17\n+         *\/\n+        @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+        GUARDED_PATTERN(GuardedPatternTree.class),\n+\n+        \/**\n+         * Used for instances of {@link ParenthesizedPatternTree}.\n+         *\n+         * @since 17\n+         *\/\n+        @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+        PARENTHESIZED_PATTERN(ParenthesizedPatternTree.class),\n+\n+        \/**\n+         * Used for instances of {@link DefaultCaseLabelTree}.\n+         *\n+         * @since 17\n+         *\/\n+        @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+        DEFAULT_CASE_LABEL(DefaultCaseLabelTree.class),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -269,0 +271,10 @@\n+    \/**\n+     * Visits a DefaultCaseLabelTree node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     * @since 17\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    R visitDefaultCaseLabel(DefaultCaseLabelTree node, P p);\n+\n@@ -293,0 +305,20 @@\n+    \/**\n+     * Visits a GuardPatternTree node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     * @since 17\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    R visitGuardedPattern(GuardedPatternTree node, P p);\n+\n+    \/**\n+     * Visits a ParenthesizedPatternTree node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     * @since 17\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    R visitParenthesizedPattern(ParenthesizedPatternTree node, P p);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -38,0 +38,15 @@\n+ * <p>Here is an example to count the number of erroneous nodes in a tree:\n+ * <pre>\n+ *   class CountErrors extends DocTreeScanner&lt;Integer,Void&gt; {\n+ *      {@literal @}Override\n+ *      public Integer visitErroneous(ErroneousTree node, Void p) {\n+ *          return 1;\n+ *      }\n+ *      {@literal @}Override\n+ *      public Integer reduce(Integer r1, Integer r2) {\n+ *          return (r1 == null ? 0 : r1) + (r2 == null ? 0 : r2);\n+ *      }\n+ *   }\n+ * <\/pre>\n+ *\n+ * @implSpec\n@@ -54,14 +69,0 @@\n- * <p>Here is an example to count the number of erroneous nodes in a tree:\n- * <pre>\n- *   class CountErrors extends DocTreeScanner&lt;Integer,Void&gt; {\n- *      {@literal @}Override\n- *      public Integer visitErroneous(ErroneousTree node, Void p) {\n- *          return 1;\n- *      }\n- *      {@literal @}Override\n- *      public Integer reduce(Integer r1, Integer r2) {\n- *          return (r1 == null ? 0 : r1) + (r2 == null ? 0 : r2);\n- *      }\n- *   }\n- * <\/pre>\n- *\n@@ -131,1 +132,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -143,1 +146,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -155,1 +160,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -167,1 +174,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -179,1 +188,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -194,1 +205,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -206,1 +219,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -218,1 +233,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -230,1 +247,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -242,1 +261,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -254,1 +275,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -266,1 +289,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -278,1 +303,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -292,1 +319,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -304,1 +333,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -318,1 +349,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -330,1 +363,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -344,1 +379,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -358,1 +395,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -370,1 +409,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -382,1 +423,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -394,1 +437,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -406,1 +451,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -418,1 +465,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -433,1 +482,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -445,1 +496,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -457,1 +510,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -470,1 +525,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -483,1 +540,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -495,1 +554,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -509,1 +570,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -521,1 +584,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -533,1 +598,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -547,1 +614,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -559,1 +628,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -571,1 +642,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/DocTreeScanner.java","additions":123,"deletions":50,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,1 +99,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -111,1 +113,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -123,1 +127,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -135,1 +141,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -147,1 +155,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -159,1 +169,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -184,1 +196,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -194,1 +208,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -206,1 +222,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -218,1 +236,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -232,1 +252,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -244,1 +266,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -258,1 +282,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -270,1 +296,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -282,1 +310,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -294,1 +324,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -306,1 +338,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -320,1 +354,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -332,1 +368,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -344,1 +382,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -356,1 +396,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -368,1 +410,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -380,1 +424,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -392,1 +438,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -404,1 +452,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -416,1 +466,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -429,1 +481,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -442,1 +496,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -454,1 +510,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -466,1 +524,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -478,1 +538,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -490,1 +552,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -504,1 +568,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -516,1 +582,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -528,1 +596,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleDocTreeVisitor.java","additions":106,"deletions":36,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -99,1 +100,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -111,1 +114,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -123,1 +128,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -135,1 +142,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -147,1 +156,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -159,1 +170,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -171,1 +184,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -183,1 +198,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -195,1 +212,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -207,1 +226,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -219,1 +240,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -231,1 +254,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -243,1 +268,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -255,1 +282,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -267,1 +296,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -279,1 +310,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -291,1 +324,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -303,1 +338,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -315,1 +352,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -327,1 +366,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -339,1 +380,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -351,1 +394,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -363,1 +408,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -375,1 +422,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -387,1 +436,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -399,1 +450,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -411,1 +464,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -423,1 +478,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -435,1 +492,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -447,1 +506,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -459,1 +520,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -471,1 +534,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -483,1 +548,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -495,1 +562,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -507,1 +576,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -519,1 +590,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -531,1 +604,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -543,1 +618,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -555,1 +632,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -568,1 +647,19 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     * @since 17\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    public R visitDefaultCaseLabel(DefaultCaseLabelTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -580,1 +677,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -592,1 +691,35 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     * @since 17\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    public R visitParenthesizedPattern(ParenthesizedPatternTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     * @since 17\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    public R visitGuardedPattern(GuardedPatternTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -604,1 +737,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -616,1 +751,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -628,1 +765,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -640,1 +779,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -652,1 +793,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -664,1 +807,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -676,1 +821,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -688,1 +835,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -700,1 +849,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -712,1 +863,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -724,1 +877,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -736,1 +891,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -747,0 +904,10 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     *\/\n+    @Override\n@@ -751,0 +918,9 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     *\/\n@@ -756,0 +932,9 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     *\/\n@@ -761,0 +946,9 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     *\/\n@@ -766,0 +960,9 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     *\/\n@@ -771,0 +974,9 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     *\/\n@@ -776,0 +988,10 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     *\/\n+    @Override\n@@ -781,1 +1003,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -793,1 +1017,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":283,"deletions":57,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -37,0 +38,15 @@\n+ * <p>Here is an example to count the number of identifier nodes in a tree:\n+ * <pre>\n+ *   class CountIdentifiers extends TreeScanner&lt;Integer,Void&gt; {\n+ *      {@literal @}Override\n+ *      public Integer visitIdentifier(IdentifierTree node, Void p) {\n+ *          return 1;\n+ *      }\n+ *      {@literal @}Override\n+ *      public Integer reduce(Integer r1, Integer r2) {\n+ *          return (r1 == null ? 0 : r1) + (r2 == null ? 0 : r2);\n+ *      }\n+ *   }\n+ * <\/pre>\n+ *\n+ * @implSpec\n@@ -53,14 +69,0 @@\n- * <p>Here is an example to count the number of identifier nodes in a tree:\n- * <pre>\n- *   class CountIdentifiers extends TreeScanner&lt;Integer,Void&gt; {\n- *      {@literal @}Override\n- *      public Integer visitIdentifier(IdentifierTree node, Void p) {\n- *          return 1;\n- *      }\n- *      {@literal @}Override\n- *      public Integer reduce(Integer r1, Integer r2) {\n- *          return (r1 == null ? 0 : r1) + (r2 == null ? 0 : r2);\n- *      }\n- *   }\n- * <\/pre>\n- *\n@@ -138,1 +140,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -154,1 +158,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -168,1 +174,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -180,1 +188,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -186,1 +196,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -199,1 +208,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -219,1 +230,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -235,1 +248,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -247,1 +262,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -259,1 +276,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -273,1 +292,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -287,1 +308,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -303,1 +326,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -318,1 +343,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -330,1 +357,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -344,1 +373,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -358,1 +389,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -375,1 +408,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -389,1 +424,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -405,1 +442,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -419,1 +458,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -434,1 +475,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -449,1 +492,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -461,1 +506,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -473,1 +520,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -485,1 +534,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -497,1 +548,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -509,1 +562,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -523,1 +578,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -538,1 +595,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -555,1 +614,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -574,1 +635,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -588,1 +651,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -600,1 +665,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -614,1 +681,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -628,1 +697,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -640,1 +711,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -654,1 +727,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -668,1 +743,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -686,1 +763,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -699,1 +778,19 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     * @since 17\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    public R visitDefaultCaseLabel(DefaultCaseLabelTree node, P p) {\n+        return null;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -713,1 +810,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -725,1 +824,36 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     * @since 17\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    public R visitParenthesizedPattern(ParenthesizedPatternTree node, P p) {\n+        return scan(node.getPattern(), p);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     * @since 17\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    public R visitGuardedPattern(GuardedPatternTree node, P p) {\n+        R r = scan(node.getPattern(), p);\n+        return scanAndReduce(node.getExpression(), p, r);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -739,1 +873,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -751,1 +887,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -763,1 +901,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -775,1 +915,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -787,1 +929,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -801,1 +945,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -813,1 +959,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -825,1 +973,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -839,1 +989,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -851,1 +1003,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -863,1 +1017,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -877,1 +1033,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -890,0 +1048,9 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     *\/\n@@ -898,0 +1065,9 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     *\/\n@@ -905,0 +1081,9 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     *\/\n@@ -912,0 +1097,9 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     *\/\n@@ -919,0 +1113,9 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     *\/\n@@ -924,0 +1127,9 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     *\/\n@@ -930,1 +1142,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -942,1 +1156,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -954,1 +1170,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":290,"deletions":72,"binary":false,"changes":362,"status":"modified"},{"patch":"@@ -418,1 +418,0 @@\n-    @SuppressWarnings(\"preview\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic;\n@@ -82,0 +83,1 @@\n+    private final Source source;\n@@ -99,1 +101,1 @@\n-        Source source = Source.instance(context);\n+        source = Source.instance(context);\n@@ -186,0 +188,3 @@\n+            case CASE_NULL -> true;\n+            case PATTERN_SWITCH -> true;\n+\n@@ -239,0 +244,15 @@\n+    public void checkSourceLevel(DiagnosticPosition pos, Feature feature) {\n+        if (isPreview(feature) && !isEnabled()) {\n+            \/\/preview feature without --preview flag, error\n+            log.error(JCDiagnostic.DiagnosticFlag.SOURCE_LEVEL, pos, disabledError(feature));\n+        } else {\n+            if (!feature.allowedInSource(source)) {\n+                log.error(JCDiagnostic.DiagnosticFlag.SOURCE_LEVEL, pos,\n+                          feature.error(source.name));\n+            }\n+            if (isEnabled() && isPreview(feature)) {\n+                warnPreview(pos, feature);\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -115,1 +115,6 @@\n-    JDK17(\"17\");\n+    JDK17(\"17\"),\n+\n+    \/**\n+      * 18, tbd\n+      *\/\n+    JDK18(\"18\");\n@@ -167,0 +172,1 @@\n+        case JDK18  -> Target.JDK1_18;\n@@ -227,0 +233,2 @@\n+        CASE_NULL(JDK17, Fragments.FeatureCaseNull, DiagKind.NORMAL),\n+        PATTERN_SWITCH(JDK17, Fragments.FeaturePatternSwitch, DiagKind.PLURAL),\n@@ -307,0 +315,1 @@\n+        case JDK18  -> RELEASE_18;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1475,1 +1475,0 @@\n-        @SuppressWarnings(\"preview\")\n@@ -1524,1 +1523,0 @@\n-        @SuppressWarnings(\"preview\")\n@@ -1708,1 +1706,0 @@\n-                @SuppressWarnings(\"preview\")\n@@ -1777,1 +1774,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -1820,1 +1816,0 @@\n-        @SuppressWarnings(\"preview\")\n@@ -1831,1 +1826,0 @@\n-        @SuppressWarnings(\"preview\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -223,0 +223,1 @@\n+    public final Type switchBootstrapsType;\n@@ -588,0 +589,1 @@\n+        switchBootstrapsType = enterClass(\"java.lang.runtime.SwitchBootstraps\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1660,2 +1660,10 @@\n-            if (!enumSwitch && !stringSwitch)\n-                seltype = chk.checkType(selector.pos(), seltype, syms.intType);\n+            boolean patternSwitch;\n+            if (!enumSwitch && !stringSwitch && !errorEnumSwitch &&\n+                !types.isAssignable(seltype, syms.intType)) {\n+                preview.checkSourceLevel(selector.pos(), Feature.PATTERN_SWITCH);\n+                patternSwitch = true;\n+            } else {\n+                patternSwitch = cases.stream()\n+                                     .flatMap(c -> c.labels.stream())\n+                                     .anyMatch(l -> l.isPattern());\n+            }\n@@ -1666,1 +1674,4 @@\n-            boolean hasDefault = false;      \/\/ Is there a default label?\n+            List<Type> coveredTypes = List.nil();\n+            boolean hasDefault = false;           \/\/ Is there a default label?\n+            boolean hasTotalPattern = false;      \/\/ Is there a total pattern?\n+            boolean hasNullPattern = false;       \/\/ Is there a null pattern?\n@@ -1669,0 +1680,2 @@\n+            MatchBindings prevBindings = null;\n+            boolean prevCompletedNormally = false;\n@@ -1678,5 +1691,15 @@\n-                if (c.getExpressions().nonEmpty()) {\n-                    for (JCExpression pat : c.getExpressions()) {\n-                        if (TreeInfo.isNull(pat)) {\n-                            log.error(pat.pos(),\n-                                      Errors.SwitchNullNotAllowed);\n+                MatchBindings currentBindings = prevBindings;\n+                boolean wasTotalPattern = hasTotalPattern;\n+                for (JCCaseLabel pat : c.labels) {\n+                    if (pat.isExpression()) {\n+                        JCExpression expr = (JCExpression) pat;\n+                        if (TreeInfo.isNull(expr)) {\n+                            preview.checkSourceLevel(expr.pos(), Feature.CASE_NULL);\n+                            if (hasNullPattern) {\n+                                log.error(c.pos(), Errors.DuplicateCaseLabel);\n+                            } else if (wasTotalPattern) {\n+                                log.error(c.pos(), Errors.PatternDominated);\n+                            }\n+                            hasNullPattern = true;\n+                            attribExpr(expr, switchEnv, seltype);\n+                            matchBindings = new MatchBindings(matchBindings.bindingsWhenTrue, matchBindings.bindingsWhenFalse, true);\n@@ -1684,1 +1707,1 @@\n-                            Symbol sym = enumConstant(pat, seltype);\n+                            Symbol sym = enumConstant(expr, seltype);\n@@ -1686,1 +1709,1 @@\n-                                log.error(pat.pos(), Errors.EnumLabelMustBeUnqualifiedEnum);\n+                                log.error(expr.pos(), Errors.EnumLabelMustBeUnqualifiedEnum);\n@@ -1689,0 +1712,2 @@\n+                            } else {\n+                                checkCaseLabelDominated(pat.pos(), coveredTypes, sym.type);\n@@ -1702,1 +1727,1 @@\n-                            Type pattype = attribExpr(pat, switchEnv, seltype);\n+                            Type pattype = attribExpr(expr, switchEnv, seltype);\n@@ -1704,0 +1729,3 @@\n+                                if (!stringSwitch && !types.isAssignable(seltype, syms.intType)) {\n+                                    log.error(pat.pos(), Errors.ConstantLabelNotCompatible(pattype, seltype));\n+                                }\n@@ -1705,1 +1733,1 @@\n-                                    log.error(pat.pos(),\n+                                    log.error(expr.pos(),\n@@ -1709,0 +1737,2 @@\n+                                } else {\n+                                    checkCaseLabelDominated(pat.pos(), coveredTypes, types.boxedTypeOrType(pattype));\n@@ -1712,0 +1742,39 @@\n+                    } else if (pat.hasTag(DEFAULTCASELABEL)) {\n+                        if (hasDefault) {\n+                            log.error(pat.pos(), Errors.DuplicateDefaultLabel);\n+                        } else if (hasTotalPattern) {\n+                            log.error(pat.pos(), Errors.TotalPatternAndDefault);\n+                        } else if (matchBindings.bindingsWhenTrue.nonEmpty()) {\n+                            \/\/there was a pattern, and the execution flows into a default:\n+                            log.error(pat.pos(), Errors.FlowsThroughFromPattern);\n+                        }\n+                        hasDefault = true;\n+                        matchBindings = MatchBindingsComputer.EMPTY;\n+                    } else {\n+                        if (prevCompletedNormally) {\n+                            log.error(pat.pos(), Errors.FlowsThroughToPattern);\n+                        }\n+                        \/\/binding pattern\n+                        attribExpr(pat, switchEnv);\n+                        var primary = TreeInfo.primaryPatternType((JCPattern) pat);\n+                        Type primaryType = primary.type();\n+                        if (!primaryType.hasTag(TYPEVAR)) {\n+                            primaryType = chk.checkClassOrArrayType(pat.pos(), primaryType);\n+                        }\n+                        checkCastablePattern(pat.pos(), seltype, primaryType);\n+                        Type patternType = types.erasure(primaryType);\n+                        boolean isTotal = primary.unconditional() &&\n+                                          !patternType.isErroneous() &&\n+                                          types.isSubtype(types.erasure(seltype), patternType);\n+                        if (isTotal) {\n+                            if (hasTotalPattern) {\n+                                log.error(pat.pos(), Errors.DuplicateTotalPattern);\n+                            } else if (hasDefault) {\n+                                log.error(pat.pos(), Errors.TotalPatternAndDefault);\n+                            }\n+                            hasTotalPattern = true;\n+                        }\n+                        checkCaseLabelDominated(pat.pos(), coveredTypes, patternType);\n+                        if (primary.unconditional() && !patternType.isErroneous()) {\n+                            coveredTypes = coveredTypes.prepend(patternType);\n+                        }\n@@ -1713,4 +1782,2 @@\n-                } else if (hasDefault) {\n-                    log.error(c.pos(), Errors.DuplicateDefaultLabel);\n-                } else {\n-                    hasDefault = true;\n+                    currentBindings = matchBindingsComputer.switchCase(pat, currentBindings, matchBindings);\n+                    prevCompletedNormally = !TreeInfo.isNull(pat);\n@@ -1719,1 +1786,1 @@\n-                    switchEnv.dup(c, env.info.dup(switchEnv.info.scope.dup()));\n+                        bindingEnv(switchEnv, c, currentBindings.bindingsWhenTrue);\n@@ -1726,0 +1793,16 @@\n+\n+                boolean completesNormally = c.caseKind == CaseTree.CaseKind.STATEMENT ? flow.aliveAfter(caseEnv, c, make) : false;\n+                prevBindings = completesNormally ? currentBindings : null;\n+                prevCompletedNormally =\n+                        completesNormally &&\n+                        !(c.labels.size() == 1 &&\n+                          TreeInfo.isNull(c.labels.head) && c.stats.isEmpty());\n+            }\n+            if (switchTree.hasTag(SWITCH)) {\n+                ((JCSwitch) switchTree).hasTotalPattern = hasDefault || hasTotalPattern;\n+                ((JCSwitch) switchTree).patternSwitch = patternSwitch;\n+            } else if (switchTree.hasTag(SWITCH_EXPRESSION)) {\n+                ((JCSwitchExpression) switchTree).hasTotalPattern = hasDefault || hasTotalPattern;\n+                ((JCSwitchExpression) switchTree).patternSwitch = patternSwitch;\n+            } else {\n+                Assert.error(switchTree.getTag().name());\n@@ -1740,0 +1823,8 @@\n+        private void checkCaseLabelDominated(DiagnosticPosition pos,\n+                                             List<Type> coveredTypes, Type patternType) {\n+            for (Type existing : coveredTypes) {\n+                if (types.isSubtype(patternType, existing)) {\n+                    log.error(pos, Errors.PatternDominated);\n+                }\n+            }\n+        }\n@@ -2083,1 +2174,5 @@\n-        Env<AttrContext> env1 = env.dup(env.tree, env.info.dup(env.info.scope.dup()));\n+        return bindingEnv(env, env.tree, bindings);\n+    }\n+\n+    Env<AttrContext> bindingEnv(Env<AttrContext> env, JCTree newTree, List<BindingSymbol> bindings) {\n+        Env<AttrContext> env1 = env.dup(newTree, env.info.dup(env.info.scope.dup()));\n@@ -3997,10 +4092,1 @@\n-                Warner warner = new Warner();\n-                if (!types.isCastable(exprtype, clazztype, warner)) {\n-                    chk.basicHandler.report(tree.expr.pos(),\n-                                            diags.fragment(Fragments.InconvertibleTypes(exprtype, clazztype)));\n-                } else if (warner.hasLint(LintCategory.UNCHECKED)) {\n-                    log.error(tree.expr.pos(),\n-                              Errors.InstanceofReifiableNotSafe(exprtype, clazztype));\n-                } else {\n-                    valid = true;\n-                }\n+                valid = checkCastablePattern(tree.expr.pos(), exprtype, clazztype);\n@@ -4021,0 +4107,17 @@\n+    private boolean checkCastablePattern(DiagnosticPosition pos,\n+                                         Type exprType,\n+                                         Type pattType) {\n+        Warner warner = new Warner();\n+        if (!types.isCastable(exprType, pattType, warner)) {\n+            chk.basicHandler.report(pos,\n+                    diags.fragment(Fragments.InconvertibleTypes(exprType, pattType)));\n+            return false;\n+        } else if (warner.hasLint(LintCategory.UNCHECKED)) {\n+            log.error(pos,\n+                    Errors.InstanceofReifiableNotSafe(exprType, pattType));\n+            return false;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n@@ -4036,0 +4139,19 @@\n+\n+    @Override\n+    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n+        attribExpr(tree.pattern, env);\n+    }\n+\n+    @Override\n+    public void visitGuardPattern(JCGuardPattern tree) {\n+        attribExpr(tree.patt, env);\n+        MatchBindings afterPattern = matchBindings;\n+        Env<AttrContext> bodyEnv = bindingEnv(env, matchBindings.bindingsWhenTrue);\n+        try {\n+            attribExpr(tree.expr, bodyEnv, syms.booleanType);\n+        } finally {\n+            bodyEnv.info.scope.leave();\n+        }\n+        result = tree.type = tree.patt.type;\n+        matchBindings = matchBindingsComputer.guardedPattern(tree, afterPattern, matchBindings);\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":150,"deletions":28,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -3347,1 +3347,0 @@\n-    @SuppressWarnings(\"preview\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import com.sun.tools.javac.tree.TreeInfo.PatternPrimaryType;\n@@ -56,0 +57,2 @@\n+import com.sun.tools.javac.resources.CompilerProperties.Fragments;\n+import com.sun.tools.javac.tree.JCTree.JCParenthesizedPattern;\n@@ -57,0 +60,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.Fragment;\n@@ -664,1 +668,1 @@\n-            boolean hasDefault = false;\n+            Set<Object> constants = tree.patternSwitch ? allSwitchConstants(tree.selector) : null;\n@@ -668,6 +672,3 @@\n-                if (c.pats.isEmpty())\n-                    hasDefault = true;\n-                else {\n-                    for (JCExpression pat : c.pats) {\n-                        scan(pat);\n-                    }\n+                for (JCCaseLabel pat : c.labels) {\n+                    scan(pat);\n+                    handleConstantCaseLabel(constants, pat);\n@@ -689,1 +690,5 @@\n-            if (!hasDefault) {\n+            if ((constants == null || !constants.isEmpty()) && !tree.hasTotalPattern &&\n+                tree.patternSwitch && !TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases)) {\n+                log.error(tree, Errors.NotExhaustiveStatement);\n+            }\n+            if (!tree.hasTotalPattern) {\n@@ -700,11 +705,1 @@\n-            Set<Object> constants = null;\n-            TypeSymbol selectorSym = tree.selector.type.tsym;\n-            if ((selectorSym.flags() & ENUM) != 0) {\n-                constants = new HashSet<>();\n-                Predicate<Symbol> enumConstantFilter =\n-                        s -> (s.flags() & ENUM) != 0 && s.kind == Kind.VAR;\n-                for (Symbol s : selectorSym.members().getSymbols(enumConstantFilter)) {\n-                    constants.add(s.name);\n-                }\n-            }\n-            boolean hasDefault = false;\n+            Set<Object> constants = allSwitchConstants(tree.selector);\n@@ -715,12 +710,3 @@\n-                if (c.pats.isEmpty())\n-                    hasDefault = true;\n-                else {\n-                    for (JCExpression pat : c.pats) {\n-                        scan(pat);\n-                        if (constants != null) {\n-                            if (pat.hasTag(IDENT))\n-                                constants.remove(((JCIdent) pat).name);\n-                            if (pat.type != null)\n-                                constants.remove(pat.type.constValue());\n-                        }\n-                    }\n+                for (JCCaseLabel pat : c.labels) {\n+                    scan(pat);\n+                    handleConstantCaseLabel(constants, pat);\n@@ -740,1 +726,1 @@\n-            if ((constants == null || !constants.isEmpty()) && !hasDefault &&\n+            if ((constants == null || !constants.isEmpty()) && !tree.hasTotalPattern &&\n@@ -748,0 +734,33 @@\n+        private Set<Object> allSwitchConstants(JCExpression selector) {\n+            Set<Object> constants = null;\n+            TypeSymbol selectorSym = selector.type.tsym;\n+            if ((selectorSym.flags() & ENUM) != 0) {\n+                constants = new HashSet<>();\n+                Predicate<Symbol> enumConstantFilter =\n+                        s -> (s.flags() & ENUM) != 0 && s.kind == Kind.VAR;\n+                for (Symbol s : selectorSym.members().getSymbols(enumConstantFilter)) {\n+                    constants.add(s.name);\n+                }\n+            } else if (selectorSym.isAbstract() && selectorSym.isSealed() && selectorSym.kind == Kind.TYP) {\n+                constants = new HashSet<>();\n+                constants.addAll(((ClassSymbol) selectorSym).permitted);\n+            }\n+            return constants;\n+        }\n+\n+        private void handleConstantCaseLabel(Set<Object> constants, JCCaseLabel pat) {\n+            if (constants != null) {\n+                if (pat.isExpression()) {\n+                    JCExpression expr = (JCExpression) pat;\n+                    if (expr.hasTag(IDENT))\n+                        constants.remove(((JCIdent) expr).name);\n+                } else if (pat.isPattern()) {\n+                    PatternPrimaryType patternType = TreeInfo.primaryPatternType((JCPattern) pat);\n+\n+                    if (patternType.unconditional()) {\n+                        constants.remove(patternType.type().tsym);\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -1197,1 +1216,1 @@\n-                scan(c.pats);\n+                scan(c.labels);\n@@ -2355,1 +2374,1 @@\n-            handleSwitch(tree, tree.selector, tree.cases);\n+            handleSwitch(tree, tree.selector, tree.cases, tree.hasTotalPattern);\n@@ -2359,1 +2378,1 @@\n-            handleSwitch(tree, tree.selector, tree.cases);\n+            handleSwitch(tree, tree.selector, tree.cases, tree.hasTotalPattern);\n@@ -2362,1 +2381,2 @@\n-        private void handleSwitch(JCTree tree, JCExpression selector, List<JCCase> cases) {\n+        private void handleSwitch(JCTree tree, JCExpression selector,\n+                                  List<JCCase> cases, boolean hasTotalPattern) {\n@@ -2369,1 +2389,0 @@\n-            boolean hasDefault = false;\n@@ -2374,10 +2393,15 @@\n-                if (c.pats.isEmpty()) {\n-                    hasDefault = true;\n-                } else {\n-                    for (JCExpression pat : c.pats) {\n-                        scanExpr(pat);\n-                    }\n-                }\n-                if (hasDefault) {\n-                    inits.assign(initsSwitch);\n-                    uninits.assign(uninits.andSet(uninitsSwitch));\n+                for (JCCaseLabel pat : c.labels) {\n+                    scan(pat);\n+                }\n+                if (l.head.stats.isEmpty() &&\n+                    l.tail.nonEmpty() &&\n+                    l.tail.head.labels.size() == 1 &&\n+                    l.tail.head.labels.head.isExpression() &&\n+                    TreeInfo.isNull(l.tail.head.labels.head)) {\n+                    \/\/handling:\n+                    \/\/case Integer i:\n+                    \/\/case null:\n+                    \/\/joining these two cases together - processing Integer i pattern,\n+                    \/\/but statements from case null:\n+                    l = l.tail;\n+                    c = l.head;\n@@ -2390,4 +2414,0 @@\n-                if (!hasDefault) {\n-                    inits.assign(initsSwitch);\n-                    uninits.assign(uninits.andSet(uninitsSwitch));\n-                }\n@@ -2396,1 +2416,1 @@\n-            if (!hasDefault) {\n+            if (!hasTotalPattern) {\n@@ -2400,1 +2420,2 @@\n-                    inits.andSet(initsSwitch);\n+                    inits.assign(initsSwitch);\n+                    uninits.assign(uninits.andSet(uninitsSwitch));\n@@ -2855,0 +2876,1 @@\n+                    case GUARDPATTERN:\n@@ -2878,0 +2900,1 @@\n+                        case GUARDPATTERN:\n@@ -2886,2 +2909,6 @@\n-            String subKey = currentTree.hasTag(LAMBDA) ?\n-                  \"lambda\"  : \"inner.cls\";\n+            Fragment subKey = switch (currentTree.getTag()) {\n+                case LAMBDA -> Fragments.Lambda;\n+                case GUARDPATTERN -> Fragments.Guard;\n+                case CLASSDEF -> Fragments.InnerCls;\n+                default -> throw new AssertionError(\"Unexpected tree kind: \" + currentTree.getTag());\n+            };\n@@ -2923,0 +2950,12 @@\n+        @Override\n+        public void visitGuardPattern(JCGuardPattern tree) {\n+            scan(tree.patt);\n+            JCTree prevTree = currentTree;\n+            try {\n+                currentTree = tree;\n+                scan(tree.expr);\n+            } finally {\n+                currentTree = prevTree;\n+            }\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":94,"deletions":55,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -3586,1 +3586,2 @@\n-        handleSwitch(tree, tree.selector, tree.cases);\n+        List<JCCase> cases = tree.patternSwitch ? addDefaultIfNeeded(tree.cases) : tree.cases;\n+        handleSwitch(tree, tree.selector, cases);\n@@ -3591,1 +3592,6 @@\n-        if (tree.cases.stream().noneMatch(c -> c.pats.isEmpty())) {\n+        List<JCCase> cases = addDefaultIfNeeded(tree.cases);\n+        handleSwitch(tree, tree.selector, cases);\n+    }\n+\n+    private List<JCCase> addDefaultIfNeeded(List<JCCase> cases) {\n+        if (cases.stream().flatMap(c -> c.labels.stream()).noneMatch(p -> p.hasTag(Tag.DEFAULTCASELABEL))) {\n@@ -3594,2 +3600,2 @@\n-            JCCase c = make.Case(JCCase.STATEMENT, List.nil(), List.of(thr), null);\n-            tree.cases = tree.cases.append(c);\n+            JCCase c = make.Case(JCCase.STATEMENT, List.of(make.DefaultCaseLabel()), List.of(thr), null);\n+            cases = cases.append(c);\n@@ -3597,1 +3603,2 @@\n-        handleSwitch(tree, tree.selector, tree.cases);\n+\n+        return cases;\n@@ -3605,1 +3612,1 @@\n-            switch (c.pats.size()) {\n+            switch (c.labels.size()) {\n@@ -3616,1 +3623,1 @@\n-                    List<JCExpression> patterns = c.pats;\n+                    List<JCCaseLabel> patterns = c.labels;\n@@ -3624,1 +3631,1 @@\n-                    c.pats = patterns;\n+                    c.labels = patterns;\n@@ -3632,1 +3639,1 @@\n-                JCBreak b = make_at(c.pos()).Break(null);\n+                JCBreak b = make.at(TreeInfo.endPos(c.stats.last())).Break(null);\n@@ -3645,3 +3652,2 @@\n-        Type target = enumSwitch ? selector.type :\n-            (stringSwitch? syms.stringType : syms.intType);\n-        selector = translate(selector, target);\n+        boolean boxedSwitch = !enumSwitch && !stringSwitch && !selector.type.isPrimitive();\n+        selector = translate(selector, selector.type);\n@@ -3662,0 +3668,4 @@\n+        } else if (boxedSwitch) {\n+            \/\/An switch over boxed primitive. Pattern matching switches are already translated\n+            \/\/by TransPatterns, so all non-primitive types are only boxed primitives:\n+            result = visitBoxedPrimitiveSwitch(tree, selector, cases);\n@@ -3675,3 +3685,26 @@\n-        JCArrayAccess newSelector = make.Indexed(map.mapVar,\n-                                        make.App(make.Select(selector,\n-                                                             ordinalMethod)));\n+        JCExpression newSelector;\n+\n+        if (cases.stream().anyMatch(c -> TreeInfo.isNull(c.labels.head))) {\n+            \/\/for enum switches with case null, do:\n+            \/\/switch ($selector != null ? $mapVar[$selector.ordinal()] : -1) {...}\n+            \/\/replacing case null with case -1:\n+            VarSymbol dollar_s = new VarSymbol(FINAL|SYNTHETIC,\n+                                               names.fromString(\"s\" + tree.pos + this.target.syntheticNameChar()),\n+                                               selector.type,\n+                                               currentMethodSym);\n+            JCStatement var = make.at(tree.pos()).VarDef(dollar_s, selector).setType(dollar_s.type);\n+            newSelector = make.Indexed(map.mapVar,\n+                    make.App(make.Select(make.Ident(dollar_s),\n+                            ordinalMethod)));\n+            newSelector =\n+                    make.LetExpr(List.of(var),\n+                                 make.Conditional(makeBinary(NE, make.Ident(dollar_s), makeNull()),\n+                                                  newSelector,\n+                                                  makeLit(syms.intType, -1))\n+                                     .setType(newSelector.type))\n+                        .setType(newSelector.type);\n+        } else {\n+            newSelector = make.Indexed(map.mapVar,\n+                    make.App(make.Select(selector,\n+                            ordinalMethod)));\n+        }\n@@ -3680,3 +3713,8 @@\n-            if (c.pats.nonEmpty()) {\n-                VarSymbol label = (VarSymbol)TreeInfo.symbol(c.pats.head);\n-                JCLiteral pat = map.forConstant(label);\n+            if (c.labels.head.isExpression()) {\n+                JCExpression pat;\n+                if (TreeInfo.isNull(c.labels.head)) {\n+                    pat = makeLit(syms.intType, -1);\n+                } else {\n+                    VarSymbol label = (VarSymbol)TreeInfo.symbol((JCExpression) c.labels.head);\n+                    pat = map.forConstant(label);\n+                }\n@@ -3759,0 +3797,2 @@\n+            JCCase nullCase = null;\n+            int nullCaseLabel = -1;\n@@ -3761,12 +3801,4 @@\n-                if (oneCase.pats.nonEmpty()) { \/\/ pats is empty for a \"default\" case\n-                    JCExpression expression = oneCase.pats.head;\n-                    String labelExpr = (String) expression.type.constValue();\n-                    Integer mapping = caseLabelToPosition.put(labelExpr, casePosition);\n-                    Assert.checkNull(mapping);\n-                    int hashCode = labelExpr.hashCode();\n-\n-                    Set<String> stringSet = hashToString.get(hashCode);\n-                    if (stringSet == null) {\n-                        stringSet = new LinkedHashSet<>(1, 1.0f);\n-                        stringSet.add(labelExpr);\n-                        hashToString.put(hashCode, stringSet);\n+                if (oneCase.labels.head.isExpression()) {\n+                    if (TreeInfo.isNull(oneCase.labels.head)) {\n+                        nullCase = oneCase;\n+                        nullCaseLabel = casePosition;\n@@ -3774,2 +3806,15 @@\n-                        boolean added = stringSet.add(labelExpr);\n-                        Assert.check(added);\n+                        JCExpression expression = (JCExpression) oneCase.labels.head;\n+                        String labelExpr = (String) expression.type.constValue();\n+                        Integer mapping = caseLabelToPosition.put(labelExpr, casePosition);\n+                        Assert.checkNull(mapping);\n+                        int hashCode = labelExpr.hashCode();\n+\n+                        Set<String> stringSet = hashToString.get(hashCode);\n+                        if (stringSet == null) {\n+                            stringSet = new LinkedHashSet<>(1, 1.0f);\n+                            stringSet.add(labelExpr);\n+                            hashToString.put(hashCode, stringSet);\n+                        } else {\n+                            boolean added = stringSet.add(labelExpr);\n+                            Assert.check(added);\n+                        }\n@@ -3850,1 +3895,8 @@\n-            stmtList.append(switch1);\n+\n+            if (nullCase != null) {\n+                stmtList.append(make.If(makeBinary(NE, make.Ident(dollar_s), makeNull()), switch1, make.Exec(make.Assign(make.Ident(dollar_tmp),\n+                                                             make.Literal(nullCaseLabel)).\n+                                                 setType(dollar_tmp.type))).setType(syms.intType));\n+            } else {\n+                stmtList.append(switch1);\n+            }\n@@ -3858,2 +3910,2 @@\n-                boolean isDefault = (oneCase.pats.isEmpty());\n-                JCExpression caseExpr;\n+                boolean isDefault = !oneCase.labels.head.isExpression();\n+                JCCaseLabel caseExpr;\n@@ -3862,2 +3914,4 @@\n-                else {\n-                    caseExpr = make.Literal(caseLabelToPosition.get((String)TreeInfo.skipParens(oneCase.pats.head).\n+                else if (oneCase == nullCase) {\n+                    caseExpr = make.Literal(nullCaseLabel);\n+                } else {\n+                    caseExpr = make.Literal(caseLabelToPosition.get((String)TreeInfo.skipParens((JCExpression) oneCase.labels.head).\n@@ -3867,1 +3921,1 @@\n-                lb.append(make.Case(JCCase.STATEMENT, caseExpr == null ? List.nil() : List.of(caseExpr),\n+                lb.append(make.Case(JCCase.STATEMENT, caseExpr == null ? List.of(make.DefaultCaseLabel()) : List.of(caseExpr),\n@@ -3901,0 +3955,64 @@\n+    private JCTree visitBoxedPrimitiveSwitch(JCTree tree, JCExpression selector, List<JCCase> cases) {\n+        JCExpression newSelector;\n+\n+        if (cases.stream().anyMatch(c -> TreeInfo.isNull(c.labels.head))) {\n+            \/\/a switch over a boxed primitive, with a null case. Pick two constants that are\n+            \/\/not used by any branch in the case (c1 and c2), close to other constants that are\n+            \/\/used in the switch. Then do:\n+            \/\/switch ($selector != null ? $selector != c1 ? $selector : c2 : c1) {...}\n+            \/\/replacing case null with case c1\n+            Set<Integer> constants = new LinkedHashSet<>();\n+            JCCase nullCase = null;\n+\n+            for (JCCase c : cases) {\n+                if (TreeInfo.isNull(c.labels.head)) {\n+                    nullCase = c;\n+                } else if (!c.labels.head.hasTag(DEFAULTCASELABEL)) {\n+                    constants.add((int) c.labels.head.type.constValue());\n+                }\n+            }\n+\n+            Assert.checkNonNull(nullCase);\n+\n+            int nullValue = constants.isEmpty() ? 0 : constants.iterator().next();\n+\n+            while (constants.contains(nullValue)) nullValue++;\n+\n+            constants.add(nullValue);\n+            nullCase.labels.head = makeLit(syms.intType, nullValue);\n+\n+            int replacementValue = nullValue;\n+\n+            while (constants.contains(replacementValue)) replacementValue++;\n+\n+            VarSymbol dollar_s = new VarSymbol(FINAL|SYNTHETIC,\n+                                               names.fromString(\"s\" + tree.pos + this.target.syntheticNameChar()),\n+                                               selector.type,\n+                                               currentMethodSym);\n+            JCStatement var = make.at(tree.pos()).VarDef(dollar_s, selector).setType(dollar_s.type);\n+            JCExpression nullValueReplacement =\n+                    make.Conditional(makeBinary(NE,\n+                                                 unbox(make.Ident(dollar_s), syms.intType),\n+                                                 makeLit(syms.intType, nullValue)),\n+                                     unbox(make.Ident(dollar_s), syms.intType),\n+                                     makeLit(syms.intType, replacementValue))\n+                        .setType(syms.intType);\n+            JCExpression nullCheck =\n+                    make.Conditional(makeBinary(NE, make.Ident(dollar_s), makeNull()),\n+                                     nullValueReplacement,\n+                                     makeLit(syms.intType, nullValue))\n+                        .setType(syms.intType);\n+            newSelector = make.LetExpr(List.of(var), nullCheck).setType(syms.intType);\n+        } else {\n+            newSelector = unbox(selector, syms.intType);\n+        }\n+\n+        if (tree.hasTag(SWITCH)) {\n+            ((JCSwitch) tree).selector = newSelector;\n+        } else {\n+            ((JCSwitchExpression) tree).selector = newSelector;\n+        }\n+\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":156,"deletions":38,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCGuardPattern;\n@@ -99,7 +100,1 @@\n-                \/\/ e.T = union(x.T, y.T)\n-                \/\/ e.F = intersection(x.F, y.F) (error recovery)\n-                List<BindingSymbol> bindingsWhenTrue =\n-                        union(tree.pos(), lhsBindings.bindingsWhenTrue, rhsBindings.bindingsWhenTrue);\n-                List<BindingSymbol> bindingsWhenFalse = \/\/error recovery\n-                        intersection(tree.pos(), lhsBindings.bindingsWhenFalse, rhsBindings.bindingsWhenFalse);\n-                return new MatchBindings(bindingsWhenTrue, bindingsWhenFalse);\n+                return andOperation(tree.pos(), lhsBindings, rhsBindings);\n@@ -120,0 +115,30 @@\n+    public MatchBindings guardedPattern(JCGuardPattern tree, MatchBindings patternBindings, MatchBindings guardBindings) {\n+        return andOperation(tree.pos(), patternBindings, guardBindings);\n+    }\n+\n+    public MatchBindings andOperation(DiagnosticPosition pos, MatchBindings lhsBindings, MatchBindings rhsBindings) {\n+        \/\/ e.T = union(x.T, y.T)\n+        \/\/ e.F = intersection(x.F, y.F) (error recovery)\n+        List<BindingSymbol> bindingsWhenTrue =\n+                union(pos, lhsBindings.bindingsWhenTrue, rhsBindings.bindingsWhenTrue);\n+        List<BindingSymbol> bindingsWhenFalse = \/\/error recovery\n+                intersection(pos, lhsBindings.bindingsWhenFalse, rhsBindings.bindingsWhenFalse);\n+        return new MatchBindings(bindingsWhenTrue, bindingsWhenFalse);\n+    }\n+\n+    public MatchBindings switchCase(JCTree tree, MatchBindings prevBindings, MatchBindings currentBindings) {\n+        if (prevBindings == null)\n+            return currentBindings;\n+        if (!prevBindings.bindingsWhenTrue.isEmpty() && !currentBindings.bindingsWhenTrue.isEmpty()) {\n+            log.error(tree.pos(), Errors.FlowsThroughToPattern);\n+        }\n+        if (prevBindings.nullPattern) {\n+            return currentBindings;\n+        }\n+        if (currentBindings.nullPattern) {\n+            return prevBindings;\n+        }\n+        return new MatchBindings(intersection(tree.pos(), prevBindings.bindingsWhenTrue, currentBindings.bindingsWhenTrue),\n+                                 intersection(tree.pos(), prevBindings.bindingsWhenFalse, currentBindings.bindingsWhenFalse));\n+    }\n+\n@@ -123,0 +148,1 @@\n+            case PARENTHESIZEDPATTERN: case GUARDPATTERN:\n@@ -135,0 +161,1 @@\n+        public final boolean nullPattern;\n@@ -137,0 +164,4 @@\n+            this(bindingsWhenTrue, bindingsWhenFalse, false);\n+        }\n+\n+        public MatchBindings(List<BindingSymbol> bindingsWhenTrue, List<BindingSymbol> bindingsWhenFalse, boolean nullPattern) {\n@@ -139,0 +170,1 @@\n+            this.nullPattern = nullPattern;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MatchBindingsComputer.java","additions":39,"deletions":7,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -3420,1 +3420,1 @@\n-                !sym.kind.isResolutionError() || sym.kind == AMBIGUOUS;\n+                 !sym.kind.isResolutionError() || sym.kind == AMBIGUOUS || sym.kind == STATICERR;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import com.sun.source.tree.CaseTree;\n+import com.sun.tools.javac.code.BoundKind;\n@@ -31,0 +33,1 @@\n+import com.sun.tools.javac.code.Preview;\n@@ -33,0 +36,2 @@\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.code.Symbol.DynamicMethodSymbol;\n@@ -47,0 +52,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCSwitch;\n@@ -55,1 +61,0 @@\n-import com.sun.tools.javac.util.Log;\n@@ -59,0 +64,1 @@\n+import java.util.Collection;\n@@ -64,0 +70,4 @@\n+import com.sun.tools.javac.code.Type.ClassType;\n+import com.sun.tools.javac.code.Type.MethodType;\n+import com.sun.tools.javac.code.Type.WildcardType;\n+import com.sun.tools.javac.code.TypeTag;\n@@ -65,0 +75,1 @@\n+import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;\n@@ -68,0 +79,5 @@\n+import com.sun.tools.javac.tree.JCTree.JCBreak;\n+import com.sun.tools.javac.tree.JCTree.JCCase;\n+import com.sun.tools.javac.tree.JCTree.JCCaseLabel;\n+import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n+import com.sun.tools.javac.tree.JCTree.JCContinue;\n@@ -69,0 +85,2 @@\n+import com.sun.tools.javac.tree.JCTree.JCFieldAccess;\n+import com.sun.tools.javac.tree.JCTree.JCGuardPattern;\n@@ -70,0 +88,2 @@\n+import com.sun.tools.javac.tree.JCTree.JCParenthesizedPattern;\n+import com.sun.tools.javac.tree.JCTree.JCPattern;\n@@ -71,0 +91,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCSwitchExpression;\n@@ -73,0 +94,1 @@\n+import com.sun.tools.javac.util.Assert;\n@@ -90,0 +112,2 @@\n+    private final Attr attr;\n+    private final Resolve rs;\n@@ -92,2 +116,0 @@\n-    private final Log log;\n-    private final ConstFold constFold;\n@@ -96,0 +118,1 @@\n+    private final Preview preview;\n@@ -97,0 +120,1 @@\n+    private Env<AttrContext> env;\n@@ -109,0 +133,5 @@\n+        @Override\n+        List<JCStatement> bindingVars(int diagPos) {\n+            return List.nil();\n+        }\n+\n@@ -135,0 +164,1 @@\n+    private ClassSymbol currentClass = null;\n@@ -136,0 +166,1 @@\n+    private VarSymbol currentValue = null;\n@@ -140,0 +171,2 @@\n+        attr = Attr.instance(context);\n+        rs = Resolve.instance(context);\n@@ -143,2 +176,0 @@\n-        log = Log.instance(context);\n-        constFold = ConstFold.instance(context);\n@@ -147,0 +178,1 @@\n+        preview = Preview.instance(context);\n@@ -152,2 +184,2 @@\n-        if (tree.pattern.hasTag(Tag.BINDINGPATTERN)) {\n-            \/\/E instanceof T N\n+        if (tree.pattern instanceof JCPattern) {\n+            \/\/E instanceof $pattern\n@@ -155,1 +187,2 @@\n-            \/\/(let T' N$temp = E; N$temp instanceof T && (N = (T) N$temp == (T) N$temp))\n+            \/\/(let T' N$temp = E; N$temp instanceof typeof($pattern) && <desugared $pattern>)\n+            \/\/note the pattern desugaring performs binding variable assignments\n@@ -157,2 +190,0 @@\n-            JCBindingPattern patt = (JCBindingPattern)tree.pattern;\n-            VarSymbol pattSym = patt.var.sym;\n@@ -162,5 +193,200 @@\n-            VarSymbol temp;\n-            if (exprSym != null &&\n-                exprSym.kind == Kind.VAR &&\n-                exprSym.owner.kind.matches(Kinds.KindSelector.VAL_MTH)) {\n-                temp = (VarSymbol) exprSym;\n+            VarSymbol prevCurrentValue = currentValue;\n+            try {\n+                if (exprSym != null &&\n+                    exprSym.kind == Kind.VAR &&\n+                    exprSym.owner.kind.matches(Kinds.KindSelector.VAL_MTH)) {\n+                    currentValue = (VarSymbol) exprSym;\n+                } else {\n+                    currentValue = new VarSymbol(Flags.FINAL | Flags.SYNTHETIC,\n+                            names.fromString(\"patt\" + tree.pos + target.syntheticNameChar() + \"temp\"),\n+                            tempType,\n+                            currentMethodSym);\n+                }\n+\n+                JCExpression translatedExpr = translate(tree.expr);\n+                Type principalType = principalType((JCPattern) tree.pattern);\n+                result = makeBinary(Tag.AND,\n+                                    makeTypeTest(make.Ident(currentValue), make.Type(principalType)),\n+                                    (JCExpression) this.<JCTree>translate(tree.pattern));\n+                if (currentValue != exprSym) {\n+                    result = make.at(tree.pos).LetExpr(make.VarDef(currentValue, translatedExpr),\n+                                                        (JCExpression)result).setType(syms.booleanType);\n+                    ((LetExpr) result).needsCond = true;\n+                }\n+            } finally {\n+                currentValue = prevCurrentValue;\n+            }\n+        } else {\n+            super.visitTypeTest(tree);\n+        }\n+    }\n+\n+    @Override\n+    public void visitBindingPattern(JCBindingPattern tree) {\n+        \/\/it is assumed the primary type has already been checked:\n+        BindingSymbol binding = (BindingSymbol) tree.var.sym;\n+        Type castTargetType = principalType(tree);\n+        VarSymbol bindingVar = bindingContext.bindingDeclared(binding);\n+\n+        if (bindingVar != null) {\n+            JCAssign fakeInit = (JCAssign)make.at(TreeInfo.getStartPos(tree)).Assign(\n+                    make.Ident(bindingVar), convert(make.Ident(currentValue), castTargetType)).setType(bindingVar.erasure(types));\n+            LetExpr nestedLE = make.LetExpr(List.of(make.Exec(fakeInit)),\n+                                            make.Literal(true));\n+            nestedLE.needsCond = true;\n+            nestedLE.setType(syms.booleanType);\n+            result = nestedLE;\n+        } else {\n+            result = make.Literal(true);\n+        }\n+    }\n+\n+    @Override\n+    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n+        result = translate(tree.pattern);\n+    }\n+\n+    @Override\n+    public void visitGuardPattern(JCGuardPattern tree) {\n+        JCExpression pattern = (JCExpression) this.<JCTree>translate(tree.patt);\n+        JCExpression guard = translate(tree.expr);\n+        result = makeBinary(Tag.AND, pattern, guard);\n+    }\n+\n+    @Override\n+    public void visitSwitch(JCSwitch tree) {\n+        handleSwitch(tree, tree.selector, tree.cases, tree.hasTotalPattern, tree.patternSwitch);\n+    }\n+\n+    @Override\n+    public void visitSwitchExpression(JCSwitchExpression tree) {\n+        handleSwitch(tree, tree.selector, tree.cases, tree.hasTotalPattern, tree.patternSwitch);\n+    }\n+\n+    private void handleSwitch(JCTree tree,\n+                              JCExpression selector,\n+                              List<JCCase> cases,\n+                              boolean hasTotalPattern,\n+                              boolean patternSwitch) {\n+        Type seltype = selector.type;\n+        boolean enumSwitch = (seltype.tsym.flags() & Flags.ENUM) != 0;\n+\n+        if (patternSwitch) {\n+            Assert.check(preview.isEnabled());\n+            Assert.check(preview.usesPreview(env.toplevel.sourcefile));\n+\n+            \/\/rewrite pattern matching switches:\n+            \/\/switch ($obj) {\n+            \/\/     case $constant: $stats$\n+            \/\/     case $pattern1: $stats$\n+            \/\/     case $pattern2, null: $stats$\n+            \/\/     case $pattern3: $stats$\n+            \/\/}\n+            \/\/=>\n+            \/\/int $idx = 0;\n+            \/\/$RESTART: switch (invokeDynamic typeSwitch($constant, typeof($pattern1), typeof($pattern2), typeof($pattern3))($obj, $idx)) {\n+            \/\/     case 0:\n+            \/\/         if (!(<desugared $pattern1>)) { $idx = 1; continue $RESTART; }\n+            \/\/         $stats$\n+            \/\/     case 1:\n+            \/\/         if (!(<desugared $pattern1>)) { $idx = 2; continue $RESTART; }\n+            \/\/         $stats$\n+            \/\/     case 2, -1:\n+            \/\/         if (!(<desugared $pattern1>)) { $idx = 3; continue $RESTART; }\n+            \/\/         $stats$\n+            \/\/     case 3:\n+            \/\/         if (!(<desugared $pattern1>)) { $idx = 4; continue $RESTART; }\n+            \/\/         $stats$\n+            \/\/}\n+            \/\/notes:\n+            \/\/-pattern desugaring performs assignment to the binding variables\n+            \/\/-the selector is evaluated only once and stored in a temporary variable\n+            \/\/-typeSwitch bootstrap method can restart matching at specified index. The bootstrap will\n+            \/\/ categorize the input, and return the case index whose type or constant matches the input.\n+            \/\/ The bootstrap does not evaluate guards, which are injected at the beginning of the case's\n+            \/\/ statement list, and if the guard fails, the switch is \"continued\" and matching is\n+            \/\/ restarted from the next index.\n+            \/\/-case null is always desugared to case -1, as the typeSwitch bootstrap method will\n+            \/\/ return -1 when the input is null\n+            \/\/\n+            \/\/a special case for switches over enums with pattern case\n+            \/\/with only a single unguarded (type) pattern case, which is equivalent\n+            \/\/to a default with additional binding variable assignment:\n+            \/\/switch ($enum) {\n+            \/\/    case $constant1: $stats$\n+            \/\/    case $constant2: $stats$\n+            \/\/    case typeof($enum) e: $stats$\n+            \/\/}\n+            \/\/=>\n+            \/\/switch ($enum) {\n+            \/\/    case $constant1: $stats$\n+            \/\/    case $constant2: $stats$\n+            \/\/    default: typeof($enum) e = $enum; $stats$\n+            \/\/}\n+            \/\/constant labels in switches over enums with one or more pattern cases\n+            \/\/with guards are desugared into guards:\n+            \/\/case $constant1: $stats$\n+            \/\/=>\n+            \/\/case typeof($enum) e && e == $constant1: $stats$\n+            \/\/and handled as a normal pattern matching switch\n+            \/\/\n+            \/\/note the selector is evaluated only once and stored in a temporary variable\n+            ListBuffer<JCCase> newCases = new ListBuffer<>();\n+            for (List<JCCase> c = cases; c.nonEmpty(); c = c.tail) {\n+                if (c.head.stats.isEmpty() && c.tail.nonEmpty()) {\n+                    c.tail.head.labels = c.tail.head.labels.prependList(c.head.labels);\n+                } else {\n+                    newCases.add(c.head);\n+                }\n+            }\n+            if (enumSwitch && hasGuards(newCases)) {\n+                for (JCCase c : newCases) {\n+                    for (List<JCCaseLabel> l = c.labels; l.nonEmpty(); l = l.tail) {\n+                        if (l.head.isExpression() && !TreeInfo.isNull(l.head)) {\n+                            BindingSymbol temp = new BindingSymbol(Flags.SYNTHETIC,\n+                                    names.fromString(\"enumGuard\" + c.pos +\n+                                                     target.syntheticNameChar() + \"temp\"),\n+                                    seltype,\n+                                    currentMethodSym);\n+                            JCBindingPattern binding =\n+                                    make.at(l.head.pos()).BindingPattern(make.VarDef(temp, null));\n+                            binding.setType(seltype);\n+                            l.head = make.GuardPattern(binding,\n+                                                       makeBinary(Tag.EQ,\n+                                                                  make.Ident(temp),\n+                                                                  (JCExpression) l.head));\n+                        }\n+                    }\n+                }\n+                enumSwitch = false;\n+            }\n+            cases = newCases.toList();\n+            ListBuffer<JCStatement> statements = new ListBuffer<>();\n+            VarSymbol temp = new VarSymbol(Flags.SYNTHETIC,\n+                    names.fromString(\"selector\" + tree.pos + target.syntheticNameChar() + \"temp\"),\n+                    seltype,\n+                    currentMethodSym);\n+            boolean hasNullCase = cases.stream()\n+                                       .flatMap(c -> c.labels.stream())\n+                                       .anyMatch(p -> p.isExpression() &&\n+                                                      TreeInfo.isNull((JCExpression) p));\n+\n+            JCCase lastCase = cases.last();\n+\n+            if (hasTotalPattern && !hasNullCase) {\n+                JCCase last = lastCase;\n+                if (last.labels.stream().noneMatch(l -> l.hasTag(Tag.DEFAULTCASELABEL))) {\n+                    last.labels = last.labels.prepend(makeLit(syms.botType, null));\n+                    hasNullCase = true;\n+                }\n+            }\n+            statements.append(make.at(tree.pos).VarDef(temp, !hasNullCase ? attr.makeNullCheck(selector)\n+                                                                          : selector));\n+            VarSymbol index = new VarSymbol(Flags.SYNTHETIC,\n+                    names.fromString(tree.pos + target.syntheticNameChar() + \"index\"),\n+                    syms.intType,\n+                    currentMethodSym);\n+            statements.append(make.at(tree.pos).VarDef(index, makeLit(syms.intType, 0)));\n+\n+            if (enumSwitch) {\n+                selector = make.Ident(temp);\n@@ -168,4 +394,36 @@\n-                temp = new VarSymbol(pattSym.flags() | Flags.SYNTHETIC,\n-                        names.fromString(pattSym.name.toString() + target.syntheticNameChar() + \"temp\"),\n-                        tempType,\n-                        patt.var.sym.owner);\n+                List<Type> staticArgTypes = List.of(syms.methodHandleLookupType,\n+                                                    syms.stringType,\n+                                                    syms.methodTypeType,\n+                                                    types.makeArrayType(new ClassType(syms.classType.getEnclosingType(),\n+                                                                        List.of(new WildcardType(syms.objectType, BoundKind.UNBOUND,\n+                                                                                                 syms.boundClass)),\n+                                                                        syms.classType.tsym)));\n+                LoadableConstant[] staticArgValues =\n+                        cases.stream()\n+                             .flatMap(c -> c.labels.stream())\n+                             .map(l -> toLoadableConstant(l))\n+                             .filter(c -> c != null)\n+                             .toArray(s -> new LoadableConstant[s]);\n+\n+                Symbol bsm = rs.resolveInternalMethod(tree.pos(), env, syms.switchBootstrapsType,\n+                        names.fromString(\"typeSwitch\"), staticArgTypes, List.nil());\n+\n+                MethodType indyType = new MethodType(\n+                        List.of(syms.objectType, syms.intType),\n+                        syms.intType,\n+                        List.nil(),\n+                        syms.methodClass\n+                );\n+                DynamicMethodSymbol dynSym = new DynamicMethodSymbol(names.fromString(\"typeSwitch\"),\n+                        syms.noSymbol,\n+                        ((MethodSymbol)bsm).asHandle(),\n+                        indyType,\n+                        staticArgValues);\n+\n+                JCFieldAccess qualifier = make.Select(make.QualIdent(bsm.owner), dynSym.name);\n+                qualifier.sym = dynSym;\n+                qualifier.type = syms.intType;\n+                selector = make.Apply(List.nil(),\n+                                      qualifier,\n+                                      List.of(make.Ident(temp), make.Ident(index)))\n+                               .setType(syms.intType);\n@@ -173,14 +431,73 @@\n-            JCExpression translatedExpr = translate(tree.expr);\n-            Type castTargetType = types.boxedTypeOrType(pattSym.erasure(types));\n-\n-            result = makeTypeTest(make.Ident(temp), make.Type(castTargetType));\n-\n-            VarSymbol bindingVar = bindingContext.bindingDeclared((BindingSymbol) patt.var.sym);\n-            if (bindingVar != null) { \/\/TODO: cannot be null here?\n-                JCAssign fakeInit = (JCAssign)make.at(tree.pos).Assign(\n-                        make.Ident(bindingVar), convert(make.Ident(temp), castTargetType)).setType(bindingVar.erasure(types));\n-                LetExpr nestedLE = make.LetExpr(List.of(make.Exec(fakeInit)),\n-                                                make.Literal(true));\n-                nestedLE.needsCond = true;\n-                nestedLE.setType(syms.booleanType);\n-                result = makeBinary(Tag.AND, (JCExpression)result, nestedLE);\n+\n+            int i = 0;\n+            boolean previousCompletesNormally = false;\n+\n+            for (var c : cases) {\n+                List<JCCaseLabel> clearedPatterns = c.labels;\n+                boolean hasJoinedNull =\n+                        c.labels.size() > 1 && c.labels.stream().anyMatch(l -> l.isNullPattern());\n+                if (hasJoinedNull) {\n+                    clearedPatterns = c.labels.stream()\n+                                              .filter(l -> !l.isNullPattern())\n+                                              .collect(List.collector());\n+                }\n+                if (clearedPatterns.size() == 1 && clearedPatterns.head.isPattern() && !previousCompletesNormally) {\n+                    JCCaseLabel p = clearedPatterns.head;\n+                    bindingContext = new BasicBindingContext();\n+                    VarSymbol prevCurrentValue = currentValue;\n+                    try {\n+                        currentValue = temp;\n+                        JCExpression test = (JCExpression) this.<JCTree>translate(p);\n+                        c.stats = translate(c.stats);\n+                        JCContinue continueSwitch = make.at(clearedPatterns.head.pos()).Continue(null);\n+                        continueSwitch.target = tree;\n+                        c.stats = c.stats.prepend(make.If(makeUnary(Tag.NOT, test).setType(syms.booleanType),\n+                                                           make.Block(0, List.of(make.Exec(make.Assign(make.Ident(index),\n+                                                                                                       makeLit(syms.intType, i + 1))\n+                                                                                     .setType(syms.intType)),\n+                                                                                 continueSwitch)),\n+                                                           null));\n+                        c.stats = c.stats.prependList(bindingContext.bindingVars(c.pos));\n+                    } finally {\n+                        currentValue = prevCurrentValue;\n+                        bindingContext.pop();\n+                    }\n+                }\n+                if (enumSwitch) {\n+                    var labels = c.labels;\n+\n+                    while (labels.nonEmpty()) {\n+                        if (labels.head.isPattern()) {\n+                            labels.head = make.DefaultCaseLabel();\n+                        }\n+                        labels = labels.tail;\n+                    }\n+                } else {\n+                    ListBuffer<JCCaseLabel> translatedLabels = new ListBuffer<>();\n+                    for (var p : c.labels) {\n+                        if (p.hasTag(Tag.DEFAULTCASELABEL)) {\n+                            translatedLabels.add(p);\n+                        } else if (hasTotalPattern && c == lastCase && p.isPattern()) {\n+                            \/\/If the switch has total pattern, the last case will contain it.\n+                            \/\/Convert the total pattern to default:\n+                            translatedLabels.add(make.DefaultCaseLabel());\n+                        } else {\n+                            int value;\n+                            if (p.isNullPattern()) {\n+                                value = -1;\n+                            } else {\n+                                value = i++;\n+                            }\n+                            translatedLabels.add(make.Literal(value));\n+                        }\n+                    }\n+                    c.labels = translatedLabels.toList();\n+                }\n+                if (c.caseKind == CaseTree.CaseKind.STATEMENT) {\n+                    previousCompletesNormally = c.completesNormally;\n+                } else {\n+                    previousCompletesNormally = false;\n+                    JCBreak brk = make.at(TreeInfo.endPos(c.stats.last())).Break(null);\n+                    brk.target = tree;\n+                    c.stats = c.stats.append(brk);\n+                }\n@@ -188,3 +505,14 @@\n-            if (temp != exprSym) {\n-                result = make.at(tree.pos).LetExpr(make.VarDef(temp, translatedExpr), (JCExpression)result).setType(syms.booleanType);\n-                ((LetExpr) result).needsCond = true;\n+\n+            if (tree.hasTag(Tag.SWITCH)) {\n+                ((JCSwitch) tree).selector = selector;\n+                ((JCSwitch) tree).cases = cases;\n+                statements.append((JCSwitch) tree);\n+                result = make.Block(0, statements.toList());\n+            } else {\n+                ((JCSwitchExpression) tree).selector = selector;\n+                ((JCSwitchExpression) tree).cases = cases;\n+                LetExpr r = (LetExpr) make.LetExpr(statements.toList(), (JCSwitchExpression) tree)\n+                                          .setType(tree.type);\n+\n+                r.needsCond = true;\n+                result = r;\n@@ -192,0 +520,4 @@\n+            return ;\n+        }\n+        if (tree.hasTag(Tag.SWITCH)) {\n+            super.visitSwitch((JCSwitch) tree);\n@@ -193,1 +525,29 @@\n-            super.visitTypeTest(tree);\n+            super.visitSwitchExpression((JCSwitchExpression) tree);\n+        }\n+    }\n+\n+    private boolean hasGuards(Collection<JCCase> cases) {\n+        return cases.stream()\n+                    .flatMap(c -> c.labels.stream())\n+                    .filter(JCCaseLabel::isPattern)\n+                    .anyMatch(l -> !TreeInfo.primaryPatternType((JCPattern) l).unconditional());\n+    }\n+\n+    private Type principalType(JCPattern p) {\n+        return types.boxedTypeOrType(types.erasure(TreeInfo.primaryPatternType(p).type()));\n+    }\n+\n+    private LoadableConstant toLoadableConstant(JCCaseLabel l) {\n+        if (l.isPattern()) {\n+            return (LoadableConstant) principalType((JCPattern) l);\n+        } else if (l.isExpression() && !TreeInfo.isNull((JCExpression) l)) {\n+            Assert.checkNonNull(l.type.constValue());\n+\n+            return switch (l.type.getTag()) {\n+                case BYTE, CHAR,\n+                     SHORT, INT -> LoadableConstant.Int((Integer) l.type.constValue());\n+                case CLASS -> LoadableConstant.String((String) l.type.constValue());\n+                default -> throw new AssertionError();\n+            };\n+        } else {\n+            return null;\n@@ -311,0 +671,1 @@\n+        MethodSymbol oldMethodSym = currentMethodSym;\n@@ -312,0 +673,7 @@\n+            if (currentMethodSym == null) {\n+                \/\/ Block is a static or instance initializer.\n+                currentMethodSym =\n+                    new MethodSymbol(tree.flags | Flags.BLOCK,\n+                                     names.empty, null,\n+                                     currentClass);\n+            }\n@@ -319,0 +687,1 @@\n+            currentMethodSym = oldMethodSym;\n@@ -334,0 +703,30 @@\n+    @Override\n+    public void visitClassDef(JCClassDecl tree) {\n+        ClassSymbol prevCurrentClass = currentClass;\n+        try {\n+            currentClass = tree.sym;\n+            super.visitClassDef(tree);\n+        } finally {\n+            currentClass = prevCurrentClass;\n+        }\n+    }\n+\n+    public void visitVarDef(JCVariableDecl tree) {\n+        MethodSymbol prevMethodSym = currentMethodSym;\n+        try {\n+            tree.mods = translate(tree.mods);\n+            tree.vartype = translate(tree.vartype);\n+            if (currentMethodSym == null) {\n+                \/\/ A class or instance field initializer.\n+                currentMethodSym =\n+                    new MethodSymbol((tree.mods.flags&Flags.STATIC) | Flags.BLOCK,\n+                                     names.empty, null,\n+                                     currentClass);\n+            }\n+            if (tree.init != null) tree.init = translate(tree.init);\n+            result = tree;\n+        } finally {\n+            currentMethodSym = prevMethodSym;\n+        }\n+    }\n+\n@@ -337,0 +736,1 @@\n+            this.env = env;\n@@ -341,0 +741,1 @@\n+            this.env = null;\n@@ -369,0 +770,11 @@\n+    \/** Make an attributed unary expression.\n+     *  @param optag    The operators tree tag.\n+     *  @param arg      The operator's argument.\n+     *\/\n+    JCTree.JCUnary makeUnary(JCTree.Tag optag, JCExpression arg) {\n+        JCTree.JCUnary tree = make.Unary(optag, arg);\n+        tree.operator = operators.resolveUnary(tree, optag, arg.type);\n+        tree.type = tree.operator.type.getReturnType();\n+        return tree;\n+    }\n+\n@@ -378,0 +790,1 @@\n+        abstract List<JCStatement> bindingVars(int diagPos);\n@@ -416,0 +829,14 @@\n+        @Override\n+        List<JCStatement> bindingVars(int diagPos) {\n+            if (hoistedVarMap.isEmpty()) return List.nil();\n+            ListBuffer<JCStatement> stats = new ListBuffer<>();\n+            for (Entry<BindingSymbol, VarSymbol> e : hoistedVarMap.entrySet()) {\n+                JCVariableDecl decl = makeHoistedVarDecl(diagPos, e.getValue());\n+                if (!e.getKey().isPreserved() ||\n+                    !parent.tryPrepend(e.getKey(), decl)) {\n+                    stats.add(decl);\n+                }\n+            }\n+            return stats.toList();\n+        }\n+\n@@ -418,1 +845,0 @@\n-            if (hoistedVarMap.isEmpty()) return stat;\n@@ -429,8 +855,1 @@\n-            ListBuffer<JCStatement> stats = new ListBuffer<>();\n-            for (Entry<BindingSymbol, VarSymbol> e : hoistedVarMap.entrySet()) {\n-                JCVariableDecl decl = makeHoistedVarDecl(stat.pos, e.getValue());\n-                if (!e.getKey().isPreserved() ||\n-                    !parent.tryPrepend(e.getKey(), decl)) {\n-                    stats.add(decl);\n-                }\n-            }\n+            List<JCStatement> stats = bindingVars(stat.pos);\n@@ -438,2 +857,1 @@\n-                stats.add(stat);\n-                stat = make.at(stat.pos).Block(0, stats.toList());\n+                stat = make.at(stat.pos).Block(0, stats.append(stat));\n@@ -478,0 +896,10 @@\n+\n+    \/** Make an attributed tree representing a literal. This will be an\n+     *  Ident node in the case of boolean literals, a Literal node in all\n+     *  other cases.\n+     *  @param type       The literal's type.\n+     *  @param value      The literal's value.\n+     *\/\n+    JCExpression makeLit(Type type, Object value) {\n+        return make.Literal(type.getTag(), value).setType(type.constType(value));\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":476,"deletions":48,"binary":false,"changes":524,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.*;\n@@ -34,3 +33,0 @@\n-import com.sun.tools.javac.code.Type.IntersectionClassType;\n-import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;\n-import com.sun.tools.javac.resources.CompilerProperties.Errors;\n@@ -565,1 +561,1 @@\n-        tree.pats = translate(tree.pats, null);\n+        tree.labels = translate(tree.labels, null);\n@@ -586,0 +582,13 @@\n+    @Override\n+    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n+        tree.pattern = translate(tree.pattern, null);\n+        result = tree;\n+    }\n+\n+    @Override\n+    public void visitGuardPattern(JCGuardPattern tree) {\n+        tree.patt = translate(tree.patt, null);\n+        tree.expr = translate(tree.expr, syms.booleanType);\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCDefaultCaseLabel;\n@@ -287,1 +288,6 @@\n-        result = scan(tree.pats, that.pats) && scan(tree.stats, that.stats);\n+        result = scan(tree.labels, that.labels) && scan(tree.stats, that.stats);\n+    }\n+\n+    @Override\n+    public void visitDefaultCaseLabel(JCDefaultCaseLabel tree) {\n+        result = true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TreeDiffer.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -325,1 +325,1 @@\n-            sr.mergeWith(csp(tree.pats));\n+            sr.mergeWith(csp(tree.labels));\n@@ -330,0 +330,5 @@\n+        @Override\n+        public void visitDefaultCaseLabel(JCTree.JCDefaultCaseLabel that) {\n+            result = null;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/CRTable.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,2 @@\n-        V61(61, 0);   \/\/ JDK 17\n+        V61(61, 0),   \/\/ JDK 17\n+        V62(62, 0);   \/\/ JDK 18\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassFile.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1193,1 +1193,1 @@\n-        handleSwitch(tree, tree.selector, tree.cases);\n+        handleSwitch(tree, tree.selector, tree.cases, tree.patternSwitch);\n@@ -1238,1 +1238,1 @@\n-                handleSwitch(tree, tree.selector, tree.cases);\n+                handleSwitch(tree, tree.selector, tree.cases, tree.patternSwitch);\n@@ -1268,1 +1268,2 @@\n-    private void handleSwitch(JCTree swtch, JCExpression selector, List<JCCase> cases) {\n+    private void handleSwitch(JCTree swtch, JCExpression selector, List<JCCase> cases,\n+                              boolean patternSwitch) {\n@@ -1271,0 +1272,1 @@\n+        int switchStart = patternSwitch ? code.entryPoint() : -1;\n@@ -1300,3 +1302,3 @@\n-                if (l.head.pats.nonEmpty()) {\n-                    Assert.check(l.head.pats.size() == 1);\n-                    int val = ((Number)l.head.pats.head.type.constValue()).intValue();\n+                if (l.head.labels.head.isExpression()) {\n+                    Assert.check(l.head.labels.size() == 1);\n+                    int val = ((Number)((JCExpression) l.head.labels.head).type.constValue()).intValue();\n@@ -1374,0 +1376,6 @@\n+            if (switchEnv.info.cont != null) {\n+                Assert.check(patternSwitch);\n+                code.resolve(switchEnv.info.cont);\n+                code.resolve(code.branch(goto_), switchStart);\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -420,1 +420,1 @@\n-            StringBuilder sig = typeSig.getParameterSignature(msym.type);\n+            StringBuilder sig = typeSig.getParameterSignature(msym.type, true);\n@@ -545,1 +545,1 @@\n-        StringBuilder getParameterSignature(Type mType)\n+        StringBuilder getParameterSignature(Type mType, boolean useFlatname)\n@@ -549,1 +549,1 @@\n-                result.append(getJvmSignature(pType));\n+                result.append(getJvmSignature(pType, useFlatname));\n@@ -556,1 +556,1 @@\n-            return getJvmSignature(mType.getReturnType());\n+            return getJvmSignature(mType.getReturnType(), false);\n@@ -561,1 +561,1 @@\n-            sb.append(\"(\").append(getParameterSignature(mType)).append(\")\");\n+            sb.append(\"(\").append(getParameterSignature(mType, false)).append(\")\");\n@@ -570,0 +570,6 @@\n+            private final boolean useFlatname;\n+\n+            JvmTypeVisitor(boolean useFlatname) {\n+                super();\n+                this.useFlatname = useFlatname;\n+            }\n@@ -592,1 +598,2 @@\n-                    String classname = t.tsym.getQualifiedName().toString();\n+                    String classname = useFlatname ? t.tsym.flatName().toString()\n+                            : t.tsym.getQualifiedName().toString();\n@@ -614,1 +621,1 @@\n-        StringBuilder getJvmSignature(Type type) {\n+        StringBuilder getJvmSignature(Type type, boolean useFlatname) {\n@@ -617,1 +624,1 @@\n-            JvmTypeVisitor jv = new JvmTypeVisitor();\n+            JvmTypeVisitor jv = new JvmTypeVisitor(useFlatname);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/JNIWriter.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -88,1 +88,4 @@\n-    JDK1_17(\"17\", 61, 0);\n+    JDK1_17(\"17\", 61, 0),\n+\n+    \/** JDK 18. *\/\n+    JDK1_18(\"18\", 62, 0);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Target.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+import java.util.function.BiFunction;\n@@ -761,0 +762,27 @@\n+\n+    \/** parses patterns.\n+     *\/\n+\n+    public JCPattern parsePattern(int pos, JCModifiers mods, JCExpression parsedType, boolean inInstanceOf) {\n+        if (token.kind == LPAREN && parsedType == null) {\n+            int startPos = token.pos;\n+            accept(LPAREN);\n+            JCPattern p = parsePattern(token.pos, null, null, false);\n+            accept(RPAREN);\n+            return toP(F.at(startPos).ParenthesizedPattern(p));\n+        } else {\n+            JCPattern pattern;\n+            JCExpression e = parsedType == null ? term(EXPR | TYPE | NOLAMBDA) : parsedType;\n+            mods = mods != null ? mods : F.at(token.pos).Modifiers(0);\n+            JCVariableDecl var = toP(F.at(token.pos).VarDef(mods, ident(), e, null));\n+            pattern = toP(F.at(pos).BindingPattern(var));\n+            if (!inInstanceOf && token.kind == AMPAMP) {\n+                checkSourceLevel(Feature.PATTERN_SWITCH);\n+                nextToken();\n+                JCExpression guard = term(EXPR | NOLAMBDA);\n+                pattern = F.at(pos).GuardPattern(pattern, guard);\n+            }\n+            return pattern;\n+        }\n+    }\n+\n@@ -939,4 +967,0 @@\n-                int patternPos = token.pos;\n-                JCModifiers mods = optFinal(0);\n-                int typePos = token.pos;\n-                JCExpression type = unannotatedType(false);\n@@ -944,4 +968,3 @@\n-                if (token.kind == IDENTIFIER) {\n-                    checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);\n-                    JCVariableDecl var = toP(F.at(token.pos).VarDef(mods, ident(), type, null));\n-                    pattern = toP(F.at(patternPos).BindingPattern(var));\n+                if (token.kind == LPAREN) {\n+                    checkSourceLevel(token.pos, Feature.PATTERN_SWITCH);\n+                    pattern = parsePattern(token.pos, null, null, true);\n@@ -949,13 +972,23 @@\n-                    checkNoMods(typePos, mods.flags & ~Flags.DEPRECATED);\n-                    if (mods.annotations.nonEmpty()) {\n-                        checkSourceLevel(mods.annotations.head.pos, Feature.TYPE_ANNOTATIONS);\n-                        List<JCAnnotation> typeAnnos =\n-                                mods.annotations\n-                                    .map(decl -> {\n-                                        JCAnnotation typeAnno = F.at(decl.pos)\n-                                                                 .TypeAnnotation(decl.annotationType,\n-                                                                                  decl.args);\n-                                        endPosTable.replaceTree(decl, typeAnno);\n-                                        return typeAnno;\n-                                    });\n-                        type = insertAnnotationsToMostInner(type, typeAnnos, false);\n+                    int patternPos = token.pos;\n+                    JCModifiers mods = optFinal(0);\n+                    int typePos = token.pos;\n+                    JCExpression type = unannotatedType(false);\n+                    if (token.kind == IDENTIFIER) {\n+                        checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);\n+                        pattern = parsePattern(patternPos, mods, type, true);\n+                    } else {\n+                        checkNoMods(typePos, mods.flags & ~Flags.DEPRECATED);\n+                        if (mods.annotations.nonEmpty()) {\n+                            checkSourceLevel(mods.annotations.head.pos, Feature.TYPE_ANNOTATIONS);\n+                            List<JCAnnotation> typeAnnos =\n+                                    mods.annotations\n+                                        .map(decl -> {\n+                                            JCAnnotation typeAnno = F.at(decl.pos)\n+                                                                     .TypeAnnotation(decl.annotationType,\n+                                                                                      decl.args);\n+                                            endPosTable.replaceTree(decl, typeAnno);\n+                                            return typeAnno;\n+                                        });\n+                            type = insertAnnotationsToMostInner(type, typeAnnos, false);\n+                        }\n+                        pattern = type;\n@@ -963,1 +996,0 @@\n-                    pattern = type;\n@@ -1464,1 +1496,1 @@\n-        ListBuffer<JCExpression> pats = new ListBuffer<>();\n+        ListBuffer<JCCaseLabel> pats = new ListBuffer<>();\n@@ -1468,0 +1500,1 @@\n+            pats.append(toP(F.at(casePos).DefaultCaseLabel()));\n@@ -1471,1 +1504,2 @@\n-                pats.append(term(EXPR | NOLAMBDA));\n+                JCCaseLabel label = parseCaseLabel();\n+                pats.append(label);\n@@ -2411,1 +2445,1 @@\n-                if (token.kind == RBRACKET) {\n+                if (token.kind == RBRACKET) { \/\/ no dimension\n@@ -2414,7 +2448,3 @@\n-                    if (token.kind == RBRACKET) { \/\/ no dimension\n-                        elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);\n-                    } else {\n-                        dimAnnotations.append(maybeDimAnnos);\n-                        dims.append(parseExpression());\n-                        accept(RBRACKET);\n-                    }\n+                    dimAnnotations.append(maybeDimAnnos);\n+                    dims.append(parseExpression());\n+                    accept(RBRACKET);\n@@ -2965,1 +2995,1 @@\n-            ListBuffer<JCExpression> pats = new ListBuffer<>();\n+            ListBuffer<JCCaseLabel> pats = new ListBuffer<>();\n@@ -2967,1 +2997,1 @@\n-                pats.append(term(EXPR | NOLAMBDA));\n+                pats.append(parseCaseLabel());\n@@ -2998,0 +3028,1 @@\n+            int patternPos = token.pos;\n@@ -3013,1 +3044,2 @@\n-            c = F.at(pos).Case(caseKind, List.nil(), stats, body);\n+            JCCaseLabel defaultPattern = toP(F.at(patternPos).DefaultCaseLabel());\n+            c = F.at(pos).Case(caseKind, List.of(defaultPattern), stats, body);\n@@ -3022,0 +3054,40 @@\n+    private JCCaseLabel parseCaseLabel() {\n+        int patternPos = token.pos;\n+        JCCaseLabel label;\n+\n+        if (token.kind == DEFAULT) {\n+            checkSourceLevel(token.pos, Feature.PATTERN_SWITCH);\n+            nextToken();\n+            label = toP(F.at(patternPos).DefaultCaseLabel());\n+        } else {\n+            if (token.kind == LPAREN) {\n+                int lookahead = 0;\n+                Token ahead;\n+                while ((ahead = S.token(lookahead)).kind != EOF && ahead.kind != RPAREN && ahead.kind != AMPAMP) {\n+                    lookahead++;\n+                }\n+                Token twoBack;\n+                boolean pattern = S.token(lookahead - 1).kind == IDENTIFIER &&\n+                                  ((twoBack = S.token(lookahead - 2)).kind == IDENTIFIER ||\n+                                   twoBack.kind == GT || twoBack.kind == GTGT || twoBack.kind == GTGTGT);\n+                if (pattern) {\n+                    return parsePattern(token.pos, null, null, false);\n+                } else {\n+                    return term(EXPR | TYPE | NOLAMBDA);\n+                }\n+            } else {\n+                JCModifiers mods = optFinal(0);\n+                JCExpression e = term(EXPR | TYPE | NOLAMBDA);\n+\n+                if (token.kind == IDENTIFIER || mods.flags != 0 || mods.annotations.nonEmpty()) {\n+                    checkSourceLevel(token.pos, Feature.PATTERN_SWITCH);\n+                    return parsePattern(patternPos, null, e, false);\n+                } else {\n+                    return e;\n+                }\n+            }\n+        }\n+\n+        return label;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":107,"deletions":35,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -974,1 +974,0 @@\n-    @SuppressWarnings(\"preview\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-        @SuppressWarnings(\"preview\")\n@@ -147,1 +146,0 @@\n-        @SuppressWarnings(\"preview\")\n@@ -157,1 +155,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -193,1 +190,0 @@\n-    @SuppressWarnings(\"preview\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacRoundEnvironment.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-@SupportedSourceVersion(SourceVersion.RELEASE_17)\n+@SupportedSourceVersion(SourceVersion.RELEASE_18)\n@@ -91,1 +91,0 @@\n-    @SuppressWarnings(\"preview\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/PrintingProcessor.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -354,0 +354,3 @@\n+compiler.misc.guard=\\\n+    a guard\n+\n@@ -497,0 +500,3 @@\n+compiler.err.pattern.dominated=\\\n+    this case label is dominated by a preceding case label\n+\n@@ -500,0 +506,16 @@\n+compiler.err.duplicate.total.pattern=\\\n+    duplicate total pattern\n+\n+compiler.err.total.pattern.and.default=\\\n+    switch has both a total pattern and a default label\n+\n+# 0: type, 1: type\n+compiler.err.constant.label.not.compatible=\\\n+    constant label of type {0} is not compatible with switch selector type {1}\n+\n+compiler.err.flows.through.to.pattern=\\\n+    illegal fall-through to a pattern\n+\n+compiler.err.flows.through.from.pattern=\\\n+    illegal fall-through from a pattern\n+\n@@ -1360,0 +1382,3 @@\n+compiler.err.not.exhaustive.statement=\\\n+    the switch statement does not cover all possible input values\n+\n@@ -2961,0 +2986,6 @@\n+compiler.misc.feature.case.null=\\\n+    null in switch cases\n+\n+compiler.misc.feature.pattern.switch=\\\n+    patterns in switch statements\n+\n@@ -3482,3 +3513,0 @@\n-compiler.err.switch.null.not.allowed=\\\n-    null label in case is not allowed\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":31,"deletions":3,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -243,0 +243,3 @@\n+        DEFAULTCASELABEL,\n+        GUARDPATTERN,\n+        PARENTHESIZEDPATTERN,\n@@ -702,1 +705,9 @@\n-    public static abstract class JCExpression extends JCTree implements ExpressionTree {\n+    public static abstract class JCCaseLabel extends JCTree implements CaseLabelTree {\n+        public abstract boolean isExpression();\n+        public boolean isNullPattern() {\n+            return isExpression() && TreeInfo.isNull((JCExpression) this);\n+        }\n+        public abstract boolean isPattern();\n+    }\n+\n+    public static abstract class JCExpression extends JCCaseLabel implements ExpressionTree {\n@@ -716,0 +727,10 @@\n+\n+        @Override\n+        public boolean isExpression() {\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean isPattern() {\n+            return false;\n+        }\n@@ -800,1 +821,0 @@\n-        @SuppressWarnings(\"preview\")\n@@ -1267,0 +1287,2 @@\n+        public boolean hasTotalPattern;\n+        public boolean patternSwitch;\n@@ -1299,1 +1321,1 @@\n-        public List<JCExpression> pats;\n+        public List<JCCaseLabel> labels;\n@@ -1303,1 +1325,1 @@\n-        protected JCCase(CaseKind caseKind, List<JCExpression> pats,\n+        protected JCCase(CaseKind caseKind, List<JCCaseLabel> labels,\n@@ -1305,2 +1327,2 @@\n-            Assert.checkNonNull(pats);\n-            Assert.check(pats.isEmpty() || pats.head != null);\n+            Assert.checkNonNull(labels);\n+            Assert.check(labels.isEmpty() || labels.head != null);\n@@ -1308,1 +1330,1 @@\n-            this.pats = pats;\n+            this.labels = labels;\n@@ -1318,1 +1340,1 @@\n-        public JCExpression getExpression() { return pats.head; }\n+        public JCExpression getExpression() { return getExpressions().head; }\n@@ -1320,1 +1342,3 @@\n-        public List<JCExpression> getExpressions() { return pats; }\n+        public List<JCExpression> getExpressions() { return labels.stream().filter(p -> p instanceof JCExpression).map(p -> (JCExpression) p).collect(List.collector()); }\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public List<JCCaseLabel> getLabels() { return labels; }\n@@ -1349,0 +1373,2 @@\n+        public boolean hasTotalPattern;\n+        public boolean patternSwitch;\n@@ -2215,1 +2241,1 @@\n-    public static abstract class JCPattern extends JCTree\n+    public static abstract class JCPattern extends JCCaseLabel\n@@ -2217,0 +2243,10 @@\n+\n+        @Override\n+        public boolean isExpression() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isPattern() {\n+            return true;\n+        }\n@@ -2254,0 +2290,115 @@\n+    public static class JCDefaultCaseLabel extends JCCaseLabel\n+            implements DefaultCaseLabelTree {\n+\n+        protected JCDefaultCaseLabel() {\n+        }\n+\n+        @Override\n+        public void accept(Visitor v) {\n+            v.visitDefaultCaseLabel(this);\n+        }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.DEFAULT_CASE_LABEL;\n+        }\n+\n+        @Override\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n+            return v.visitDefaultCaseLabel(this, d);\n+        }\n+\n+        @Override\n+        public Tag getTag() {\n+            return DEFAULTCASELABEL;\n+        }\n+\n+        @Override\n+        public boolean isExpression() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isPattern() {\n+            return false;\n+        }\n+    }\n+\n+    public static class JCParenthesizedPattern extends JCPattern\n+            implements ParenthesizedPatternTree {\n+        public JCPattern pattern;\n+\n+        public JCParenthesizedPattern(JCPattern pattern) {\n+            this.pattern = pattern;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public PatternTree getPattern() {\n+            return pattern;\n+        }\n+\n+        @Override\n+        public void accept(Visitor v) {\n+            v.visitParenthesizedPattern(this);\n+        }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.PARENTHESIZED_PATTERN;\n+        }\n+\n+        @Override\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n+            return v.visitParenthesizedPattern(this, d);\n+        }\n+\n+        @Override\n+        public Tag getTag() {\n+            return PARENTHESIZEDPATTERN;\n+        }\n+    }\n+\n+    public static class JCGuardPattern extends JCPattern\n+            implements GuardedPatternTree {\n+        public JCPattern patt;\n+        public JCExpression expr;\n+\n+        public JCGuardPattern(JCPattern patt, JCExpression expr) {\n+            this.patt = patt;\n+            this.expr = expr;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public PatternTree getPattern() {\n+            return patt;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public ExpressionTree getExpression() {\n+            return expr;\n+        }\n+\n+        @Override\n+        public void accept(Visitor v) {\n+            v.visitGuardPattern(this);\n+        }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.GUARDED_PATTERN;\n+        }\n+\n+        @Override\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n+            return v.visitGuardedPattern(this, d);\n+        }\n+\n+        @Override\n+        public Tag getTag() {\n+            return Tag.GUARDPATTERN;\n+        }\n+    }\n+\n@@ -3190,1 +3341,1 @@\n-        JCCase Case(CaseTree.CaseKind caseKind, List<JCExpression> pat,\n+        JCCase Case(CaseTree.CaseKind caseKind, List<JCCaseLabel> labels,\n@@ -3294,0 +3445,3 @@\n+        public void visitDefaultCaseLabel(JCDefaultCaseLabel that) { visitTree(that); }\n+        public void visitParenthesizedPattern(JCParenthesizedPattern that) { visitTree(that); }\n+        public void visitGuardPattern(JCGuardPattern that) { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":165,"deletions":11,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -855,1 +855,1 @@\n-            if (tree.pats.isEmpty()) {\n+            if (tree.labels.size() == 1 && tree.labels.get(0).hasTag(DEFAULTCASELABEL)) {\n@@ -859,1 +859,1 @@\n-                printExprs(tree.pats);\n+                printExprs(tree.labels);\n@@ -870,1 +870,5 @@\n-                printStat(tree.stats.head);\n+                if (tree.stats.size() == 1) {\n+                    printStat(tree.stats.head);\n+                } else {\n+                    printBlock(tree.stats);\n+                }\n@@ -877,0 +881,9 @@\n+    @Override\n+    public void visitDefaultCaseLabel(JCTree.JCDefaultCaseLabel that) {\n+        try {\n+            print(\"default\");\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n@@ -902,0 +915,22 @@\n+        }\n+    }\n+\n+    @Override\n+    public void visitParenthesizedPattern(JCParenthesizedPattern patt) {\n+        try {\n+            print(\"(\");\n+            printExpr(patt.pattern);\n+            print(\")\");\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void visitGuardPattern(JCGuardPattern patt) {\n+        try {\n+            printExpr(patt.patt);\n+            print(\" && \");\n+            printExpr(patt.expr);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":38,"deletions":3,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-        List<JCExpression> pats = copy(t.pats, p);\n+        List<JCCaseLabel> labels = copy(t.labels, p);\n@@ -164,1 +164,1 @@\n-        return M.at(t.pos).Case(t.caseKind, pats, stats, body);\n+        return M.at(t.pos).Case(t.caseKind, labels, stats, body);\n@@ -500,0 +500,21 @@\n+    @DefinedBy(Api.COMPILER_TREE)\n+    public JCTree visitGuardedPattern(GuardedPatternTree node, P p) {\n+        JCGuardPattern t = (JCGuardPattern) node;\n+        JCPattern patt = copy(t.patt, p);\n+        JCExpression expr = copy(t.expr, p);\n+        return M.at(t.pos).GuardPattern(patt, expr);\n+    }\n+\n+    @DefinedBy(Api.COMPILER_TREE)\n+    public JCTree visitParenthesizedPattern(ParenthesizedPatternTree node, P p) {\n+        JCParenthesizedPattern t = (JCParenthesizedPattern) node;\n+        JCPattern pattern = copy(t.pattern, p);\n+        return M.at(t.pos).ParenthesizedPattern(pattern);\n+    }\n+\n+    @DefinedBy(Api.COMPILER_TREE)\n+    public JCTree visitDefaultCaseLabel(DefaultCaseLabelTree node, P p) {\n+        JCDefaultCaseLabel t = (JCDefaultCaseLabel) node;\n+        return M.at(t.pos).DefaultCaseLabel();\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import static com.sun.tools.javac.code.TypeTag.BOOLEAN;\n@@ -544,0 +545,4 @@\n+            case GUARDPATTERN: {\n+                JCGuardPattern node = (JCGuardPattern) tree;\n+                return getStartPos(node.patt);\n+            }\n@@ -633,0 +638,8 @@\n+            case PARENTHESIZEDPATTERN: {\n+                JCParenthesizedPattern node = (JCParenthesizedPattern) tree;\n+                return getEndPos(node.pattern, endPosTable);\n+            }\n+            case GUARDPATTERN: {\n+                JCGuardPattern node = (JCGuardPattern) tree;\n+                return getEndPos(node.expr, endPosTable);\n+            }\n@@ -1332,1 +1345,1 @@\n-               cases.stream().flatMap(c -> c.pats.stream())\n+               cases.stream().flatMap(c -> c.labels.stream())\n@@ -1335,0 +1348,24 @@\n+\n+    public static PatternPrimaryType primaryPatternType(JCPattern pat) {\n+        return switch (pat.getTag()) {\n+            case BINDINGPATTERN -> new PatternPrimaryType(((JCBindingPattern) pat).type, true);\n+            case GUARDPATTERN -> {\n+                JCGuardPattern guarded = (JCGuardPattern) pat;\n+                PatternPrimaryType nested = primaryPatternType(guarded.patt);\n+                boolean unconditional = nested.unconditional();\n+                if (guarded.expr.type.hasTag(BOOLEAN) && unconditional) {\n+                    unconditional = false;\n+                    var constValue = guarded.expr.type.constValue();\n+                    if (constValue != null && ((int) constValue) == 1) {\n+                        unconditional = true;\n+                    }\n+                }\n+                yield new PatternPrimaryType(nested.type(), unconditional);\n+            }\n+            case PARENTHESIZEDPATTERN -> primaryPatternType(((JCParenthesizedPattern) pat).pattern);\n+            default -> throw new AssertionError();\n+        };\n+    }\n+\n+    public record PatternPrimaryType(Type type, boolean unconditional) {}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-    public JCCase Case(CaseTree.CaseKind caseKind, List<JCExpression> pats,\n+    public JCCase Case(CaseTree.CaseKind caseKind, List<JCCaseLabel> labels,\n@@ -296,1 +296,1 @@\n-        JCCase tree = new JCCase(caseKind, pats, stats, body);\n+        JCCase tree = new JCCase(caseKind, labels, stats, body);\n@@ -491,0 +491,18 @@\n+    public JCDefaultCaseLabel DefaultCaseLabel() {\n+        JCDefaultCaseLabel tree = new JCDefaultCaseLabel();\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n+    public JCParenthesizedPattern ParenthesizedPattern(JCPattern pattern) {\n+        JCParenthesizedPattern tree = new JCParenthesizedPattern(pattern);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n+    public JCGuardPattern GuardPattern(JCPattern guardedPattern, JCExpression expr) {\n+        JCGuardPattern tree = new JCGuardPattern(guardedPattern, expr);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-        scan(tree.pats);\n+        scan(tree.labels);\n@@ -310,0 +310,15 @@\n+    @Override\n+    public void visitDefaultCaseLabel(JCDefaultCaseLabel tree) {\n+    }\n+\n+    @Override\n+    public void visitParenthesizedPattern(JCParenthesizedPattern that) {\n+        scan(that.pattern);\n+    }\n+\n+    @Override\n+    public void visitGuardPattern(JCGuardPattern that) {\n+        scan(that.patt);\n+        scan(that.expr);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-        tree.pats = translate(tree.pats);\n+        tree.labels = translate(tree.labels);\n@@ -366,0 +366,18 @@\n+    @Override\n+    public void visitDefaultCaseLabel(JCDefaultCaseLabel tree) {\n+        result = tree;\n+    }\n+\n+    @Override\n+    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n+        tree.pattern = translate(tree.pattern);\n+        result = tree;\n+    }\n+\n+    @Override\n+    public void visitGuardPattern(JCGuardPattern tree) {\n+        tree.patt = translate(tree.patt);\n+        tree.expr = translate(tree.expr);\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -313,33 +313,0 @@\n-    \/**\n-     * Construct a log with given I\/O redirections.\n-     * @deprecated\n-     * This constructor is provided to support\n-     *      jdk.javadoc.internal.tool.Messager.Messager(com.sun.tools.javac.util.Context,\n-     *          java.lang.String, java.io.PrintWriter, java.io.PrintWriter)\n-     *\/\n-    @Deprecated\n-    protected Log(Context context, PrintWriter errWriter, PrintWriter warnWriter, PrintWriter noticeWriter) {\n-        this(context, initWriters(errWriter, warnWriter, noticeWriter));\n-    }\n-\n-    \/**\n-     * Initialize a writer map with different streams for different types of diagnostics.\n-     * @param errWriter a stream for writing error messages\n-     * @param warnWriter a stream for writing warning messages\n-     * @param noticeWriter a stream for writing notice messages\n-     * @return a map of writers\n-     * @deprecated This method exists to support a supported but now deprecated javadoc entry point.\n-     *\/\n-    @Deprecated\n-    private static Map<WriterKind, PrintWriter>  initWriters(PrintWriter errWriter, PrintWriter warnWriter, PrintWriter noticeWriter) {\n-        Map<WriterKind, PrintWriter> writers = new EnumMap<>(WriterKind.class);\n-        writers.put(WriterKind.ERROR, errWriter);\n-        writers.put(WriterKind.WARNING, warnWriter);\n-        writers.put(WriterKind.NOTICE, noticeWriter);\n-\n-        writers.put(WriterKind.STDOUT, noticeWriter);\n-        writers.put(WriterKind.STDERR, errWriter);\n-\n-        return writers;\n-    }\n-\n@@ -776,1 +743,0 @@\n-    @Deprecated\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Log.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-@SuppressWarnings(\"preview\")\n@@ -127,1 +126,0 @@\n-    @SuppressWarnings(\"preview\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/comp\/PubapiVisitor.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -587,1 +587,1 @@\n-                \/\/ hack for working around API bug\n+                \/\/ workaround for API bug\n@@ -594,1 +594,1 @@\n-                    \/\/ hack for working around API bug\n+                    \/\/ workaround for API bug\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/CSignature.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-        return (as_long(value) & ZGlobals.ZAddressWeakBadMask()) != 0;\n+        return (as_long(value) & ZGlobals.ZAddressWeakBadMask()) != 0L;\n@@ -65,0 +65,12 @@\n+\n+    private static boolean isPowerOf2(long value) {\n+        return (value != 0L) && ((value & (value - 1)) == 0L);\n+    }\n+\n+    static boolean isIn(Address addr) {\n+        long value = as_long(addr);\n+        if (!isPowerOf2(value & ~ZGlobals.ZAddressOffsetMask())) {\n+            return false;\n+        }\n+        return (value & (ZGlobals.ZAddressMetadataMask() & ~ZGlobals.ZAddressMetadataFinalizable())) != 0L;\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZAddress.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, NTT DATA.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.gc.z;\n+\n+import sun.jvm.hotspot.debugger.Address;\n+import sun.jvm.hotspot.runtime.VM;\n+import sun.jvm.hotspot.runtime.VMObject;\n+import sun.jvm.hotspot.runtime.VMObjectFactory;\n+import sun.jvm.hotspot.types.CIntegerField;\n+import sun.jvm.hotspot.types.Type;\n+import sun.jvm.hotspot.types.TypeDataBase;\n+\n+public class ZAttachedArrayForForwarding extends VMObject {\n+    private static CIntegerField lengthField;\n+\n+    static {\n+        VM.registerVMInitializedObserver((o, d) -> initialize(VM.getVM().getTypeDataBase()));\n+    }\n+\n+    static private synchronized void initialize(TypeDataBase db) {\n+        Type type = db.lookupType(\"ZAttachedArrayForForwarding\");\n+\n+        lengthField = type.getCIntegerField(\"_length\");\n+    }\n+\n+    public ZAttachedArrayForForwarding(Address addr) {\n+        super(addr);\n+    }\n+\n+    public long length() {\n+        return lengthField.getValue(addr);\n+    }\n+\n+    \/\/ ObjectT: ZForwarding\n+    \/\/  ArrayT: ZForwardingEntry\n+    \/\/\n+    \/\/ template <typename ObjectT, typename ArrayT>\n+    \/\/ inline size_t ZAttachedArray<ObjectT, ArrayT>::object_size()\n+    private long objectSize() {\n+        return ZUtils.alignUp(ZForwarding.getSize(), ZForwardingEntry.getSize());\n+    }\n+\n+    \/\/ ArrayT* operator()(const ObjectT* obj) const\n+    public ZForwardingEntry get(ZForwarding obj) {\n+        Address o = obj.getAddress().addOffsetTo(objectSize());\n+        return VMObjectFactory.newObject(ZForwardingEntry.class, o);\n+    }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZAttachedArrayForForwarding.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,8 +44,1 @@\n-        ZHeap heap = zheap();\n-        if (heap.is_relocating(addr)) {\n-            \/\/ Forward\n-            return heap.relocate_object(addr);\n-        }\n-\n-        \/\/ Remap\n-        return ZAddress.good(addr);\n+        return zheap().relocate_object(addr);\n@@ -60,8 +53,1 @@\n-        ZHeap heap = zheap();\n-        if (heap.is_relocating(addr)) {\n-            \/\/ Forward\n-            return heap.forward_object(addr);\n-        }\n-\n-        \/\/ Remap\n-        return ZAddress.good(addr);\n+        return zheap().remapObject(addr);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZBarrier.java","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,4 @@\n-\n+    @Override\n+    public boolean isInReserved(Address a) {\n+        return heap().isIn(a);\n+    }\n@@ -109,1 +112,0 @@\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZCollectedHeap.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, NTT DATA.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.gc.z;\n+\n+import java.util.Iterator;\n+\n+import sun.jvm.hotspot.debugger.Address;\n+import sun.jvm.hotspot.runtime.VM;\n+import sun.jvm.hotspot.runtime.VMObject;\n+import sun.jvm.hotspot.runtime.VMObjectFactory;\n+import sun.jvm.hotspot.types.CIntegerField;\n+import sun.jvm.hotspot.types.Type;\n+import sun.jvm.hotspot.types.TypeDataBase;\n+\n+public class ZForwarding extends VMObject {\n+    private static Type type;\n+    private static long virtualFieldOffset;\n+    private static long entriesFieldOffset;\n+    private static CIntegerField objectAlignmentShiftField;\n+    private static CIntegerField refCountField;\n+\n+    static {\n+        VM.registerVMInitializedObserver((o, d) -> initialize(VM.getVM().getTypeDataBase()));\n+    }\n+\n+    static private synchronized void initialize(TypeDataBase db) {\n+        type = db.lookupType(\"ZForwarding\");\n+\n+        virtualFieldOffset = type.getField(\"_virtual\").getOffset();\n+        entriesFieldOffset = type.getField(\"_entries\").getOffset();\n+        objectAlignmentShiftField = type.getCIntegerField(\"_object_alignment_shift\");\n+        refCountField = type.getCIntegerField(\"_ref_count\");\n+    }\n+\n+    public ZForwarding(Address addr) {\n+        super(addr);\n+    }\n+\n+    public static long getSize() {\n+        return type.getSize();\n+    }\n+\n+    private ZVirtualMemory virtual() {\n+        return VMObjectFactory.newObject(ZVirtualMemory.class, addr.addOffsetTo(virtualFieldOffset));\n+    }\n+\n+    private ZAttachedArrayForForwarding entries() {\n+        return VMObjectFactory.newObject(ZAttachedArrayForForwarding.class, addr.addOffsetTo(entriesFieldOffset));\n+    }\n+\n+    public long start() {\n+        return virtual().start();\n+    }\n+\n+    public int objectAlignmentShift() {\n+        return (int)objectAlignmentShiftField.getValue(addr);\n+    }\n+\n+    public boolean retainPage() {\n+        return refCountField.getValue(addr) > 0;\n+    }\n+\n+    private ZForwardingEntry at(long cursor) {\n+        long offset = ZForwardingEntry.getSize() * cursor;\n+        Address entryAddress = entries().get(this).getAddress().addOffsetTo(offset);\n+        return VMObjectFactory.newObject(ZForwardingEntry.class, entryAddress);\n+    }\n+\n+    private class ZForwardEntryIterator implements Iterator<ZForwardingEntry> {\n+\n+        private long cursor;\n+\n+        private ZForwardingEntry nextEntry;\n+\n+        public ZForwardEntryIterator(long fromIndex) {\n+            long mask = entries().length() - 1;\n+            long hash = ZHash.uint32_to_uint32(fromIndex);\n+            cursor = hash & mask;\n+            nextEntry = at(cursor);\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return nextEntry.populated();\n+        }\n+\n+        @Override\n+        public ZForwardingEntry next() {\n+            ZForwardingEntry entry = nextEntry;\n+\n+            long mask = entries().length() - 1;\n+            cursor = (cursor + 1) & mask;\n+            nextEntry = at(cursor);\n+\n+            return entry;\n+        }\n+\n+        public ZForwardingEntry peak() {\n+            return nextEntry;\n+        }\n+    }\n+\n+    public ZForwardingEntry find(long fromIndex) {\n+        ZForwardEntryIterator itr = new ZForwardEntryIterator(fromIndex);\n+        while (itr.hasNext()) {\n+            ZForwardingEntry entry = itr.next();\n+            if (entry.fromIndex() == fromIndex) {\n+                return entry;\n+            }\n+        }\n+        return itr.peak();\n+    }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZForwarding.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, NTT DATA.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.gc.z;\n+\n+import sun.jvm.hotspot.debugger.Address;\n+import sun.jvm.hotspot.runtime.VM;\n+import sun.jvm.hotspot.runtime.VMObject;\n+import sun.jvm.hotspot.runtime.VMObjectFactory;\n+import sun.jvm.hotspot.types.CIntegerField;\n+import sun.jvm.hotspot.types.Type;\n+import sun.jvm.hotspot.types.TypeDataBase;\n+\n+public class ZForwardingEntry extends VMObject {\n+    private static Type type;\n+    private static CIntegerField entryField;\n+\n+    static {\n+        VM.registerVMInitializedObserver((o, d) -> initialize(VM.getVM().getTypeDataBase()));\n+    }\n+\n+    static private synchronized void initialize(TypeDataBase db) {\n+        type = db.lookupType(\"ZForwardingEntry\");\n+\n+        entryField = type.getCIntegerField(\"_entry\");\n+    }\n+\n+    public static long getSize() {\n+        return type.getSize();\n+    }\n+\n+    public ZForwardingEntry(Address addr) {\n+        super(addr);\n+    }\n+\n+    public long entry() {\n+        return entryField.getValue(addr);\n+    }\n+\n+    \/\/ typedef ZBitField<uint64_t, bool,   0,   1> field_populated\n+    private boolean fieldPopulatedDecode(long value) {\n+        long FieldMask = (1L << 1) - 1;\n+        int FieldShift = 1;\n+        int ValueShift = 0;\n+        return (((value >>> FieldShift) & FieldMask) << ValueShift) != 0L;\n+    }\n+\n+    \/\/ typedef ZBitField<uint64_t, size_t, 1,  45> field_to_offset;\n+    private long fieldToOffsetDecode(long value) {\n+        long FieldMask = (1L << 45) - 1;\n+        int FieldShift = 1;\n+        int ValueShift = 0;\n+        return ((value >>> FieldShift) & FieldMask) << ValueShift;\n+    }\n+\n+    \/\/ typedef ZBitField<uint64_t, size_t, 46, 18> field_from_index;\n+    private long fieldFromIndexDecode(long value) {\n+        long FieldMask = (1L << 18) - 1;\n+        int FieldShift = 46;\n+        int ValueShift = 0;\n+        return ((value >>> FieldShift) & FieldMask) << ValueShift;\n+    }\n+\n+    public boolean populated() {\n+        return fieldPopulatedDecode(entry());\n+    }\n+\n+    public long toOffset() {\n+        return fieldToOffsetDecode(entry());\n+    }\n+\n+    public long fromIndex() {\n+        return fieldFromIndexDecode(entry());\n+    }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZForwardingEntry.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import sun.jvm.hotspot.runtime.VMObjectFactory;\n@@ -36,2 +37,1 @@\n-    private static AddressField tableField;\n-    private static CIntegerField sizeField;\n+    private static long mapFieldOffset;\n@@ -46,2 +46,1 @@\n-        tableField = type.getAddressField(\"_table\");\n-        sizeField = type.getCIntegerField(\"_size\");\n+        mapFieldOffset = type.getAddressField(\"_map\").getOffset();\n@@ -54,2 +53,2 @@\n-    Address table() {\n-        return tableField.getAddress(addr);\n+    private ZGranuleMapForForwarding map() {\n+        return VMObjectFactory.newObject(ZGranuleMapForForwarding.class, addr.addOffsetTo(mapFieldOffset));\n@@ -58,58 +57,2 @@\n-    long size() {\n-        return sizeField.getJLong(addr);\n-    }\n-\n-    ZForwardingTableEntry at(ZForwardingTableCursor cursor) {\n-        return new ZForwardingTableEntry(table().getAddressAt(cursor._value * VM.getVM().getBytesPerLong()));\n-    }\n-\n-    ZForwardingTableEntry first(long from_index, ZForwardingTableCursor cursor) {\n-        long mask = size() - 1;\n-        long hash = ZHash.uint32_to_uint32(from_index);\n-        cursor._value = hash & mask;\n-        return at(cursor);\n-    }\n-\n-    ZForwardingTableEntry next(ZForwardingTableCursor cursor) {\n-        long mask = size() - 1;\n-        cursor._value = (cursor._value + 1) & mask;\n-        return at(cursor);\n-    }\n-\n-    ZForwardingTableEntry find(long from_index, ZForwardingTableCursor cursor) {\n-        \/\/ Reading entries in the table races with the atomic cas done for\n-        \/\/ insertion into the table. This is safe because each entry is at\n-        \/\/ most updated once (from -1 to something else).\n-        ZForwardingTableEntry entry = first(from_index, cursor);\n-        while (!entry.is_empty()) {\n-            if (entry.from_index() == from_index) {\n-                \/\/ Match found, return matching entry\n-                return entry;\n-            }\n-\n-            entry = next(cursor);\n-        }\n-\n-        \/\/ Match not found, return empty entry\n-        return entry;\n-    }\n-\n-    ZForwardingTableEntry find(long from_index) {\n-        ZForwardingTableCursor dummy = new ZForwardingTableCursor();\n-        return find(from_index, dummy);\n-    }\n-\n-    void dump() {\n-        long s = size();\n-        long count = 0;\n-        System.out.println(\"Dumping ZForwardingTable[\" + s + \"]:\");\n-        ZForwardingTableCursor cursor = new ZForwardingTableCursor();\n-        for (long i = 0; i < s; i++) {\n-            cursor._value = i;\n-            ZForwardingTableEntry entry = at(cursor);\n-            if (!entry.is_empty()) {\n-                long hash = ZHash.uint32_to_uint32(entry.from_index());\n-                System.out.println(i + \" \" + count + \" \" + entry + \" hash: \" + hash + \" masked_hash: \" + (hash & (s - 1)));\n-                count++;\n-            }\n-        }\n+    public ZForwarding get(Address o) {\n+        return VMObjectFactory.newObject(ZForwarding.class, map().get(ZAddress.offset(o)));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZForwardingTable.java","additions":8,"deletions":65,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -105,0 +105,8 @@\n+    public static long ZAddressMetadataMask() {\n+        return instance().ZAddressMetadataMask();\n+    }\n+\n+    public static long ZAddressMetadataFinalizable() {\n+        return instance().ZAddressMetadataFinalizable();\n+    }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZGlobals.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+    private static AddressField ZAddressMetadataMaskField;\n+    private static AddressField ZAddressMetadataFinalizableField;\n@@ -54,0 +56,2 @@\n+        ZAddressMetadataMaskField = type.getAddressField(\"_ZAddressMetadataMask\");\n+        ZAddressMetadataFinalizableField = type.getAddressField(\"_ZAddressMetadataFinalizable\");\n@@ -77,0 +81,8 @@\n+    long ZAddressMetadataMask() {\n+        return ZAddressMetadataMaskField.getValue(addr).getJLongAt(0);\n+    }\n+\n+    long ZAddressMetadataFinalizable() {\n+        return ZAddressMetadataFinalizableField.getValue(addr).getJLongAt(0);\n+    }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZGlobalsForVMStructs.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, NTT DATA.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.gc.z;\n+\n+import sun.jvm.hotspot.debugger.Address;\n+import sun.jvm.hotspot.runtime.VM;\n+import sun.jvm.hotspot.runtime.VMObject;\n+import sun.jvm.hotspot.types.AddressField;\n+import sun.jvm.hotspot.types.Type;\n+import sun.jvm.hotspot.types.TypeDataBase;\n+\n+public class ZGranuleMapForForwarding  extends VMObject {\n+    private static AddressField mapField;\n+\n+    static {\n+        VM.registerVMInitializedObserver((o, d) -> initialize(VM.getVM().getTypeDataBase()));\n+    }\n+\n+    static private synchronized void initialize(TypeDataBase db) {\n+        Type type = db.lookupType(\"ZGranuleMapForForwarding\");\n+\n+        mapField = type.getAddressField(\"_map\");\n+    }\n+\n+    public ZGranuleMapForForwarding(Address addr) {\n+        super(addr);\n+    }\n+\n+    private Address map() {\n+        return mapField.getValue(addr);\n+    }\n+\n+    public long size() {\n+        return ZGlobals.ZAddressOffsetMax >> ZGlobals.ZGranuleSizeShift;\n+    }\n+\n+    private long index_for_offset(long offset) {\n+        long index = offset >>> ZGlobals.ZGranuleSizeShift;\n+\n+        return index;\n+    }\n+\n+    Address at(long index) {\n+        return map().getAddressAt(index * VM.getVM().getAddressSize());\n+    }\n+\n+    Address get(long offset) {\n+        long index = index_for_offset(offset);\n+        return at(index);\n+    }\n+\n+    public class Iterator {\n+        private long next = 0;\n+\n+        boolean hasNext() {\n+            return next < size();\n+        }\n+\n+        Address next() {\n+            if (next >= size()) {\n+                throw new RuntimeException(\"OOIBE\");\n+            }\n+\n+            return at(next++);\n+        }\n+    }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZGranuleMapForForwarding.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -34,1 +34,1 @@\n-        key = uint32(key ^ (key >> 12));\n+        key = uint32(key ^ (key >>> 12));\n@@ -36,1 +36,1 @@\n-        key = uint32(key ^ (key >> 4));\n+        key = uint32(key ^ (key >>> 4));\n@@ -38,1 +38,1 @@\n-        key = uint32(key ^ (key >> 16));\n+        key = uint32(key ^ (key >>> 16));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZHash.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,2 @@\n+    private static long forwardingTableFieldOffset;\n+    private static long relocateFieldOffset;\n@@ -52,0 +54,2 @@\n+        forwardingTableFieldOffset = type.getAddressField(\"_forwarding_table\").getOffset();\n+        relocateFieldOffset = type.getAddressField(\"_relocate\").getOffset();\n@@ -67,0 +71,8 @@\n+    ZForwardingTable forwardingTable() {\n+        return VMObjectFactory.newObject(ZForwardingTable.class, addr.addOffsetTo(forwardingTableFieldOffset));\n+    }\n+\n+    ZRelocate relocate() {\n+        return VMObjectFactory.newObject(ZRelocate.class, addr.addOffsetTo(relocateFieldOffset));\n+    }\n+\n@@ -83,3 +95,6 @@\n-    Address forward_object(Address addr) {\n-        ZPage page = pageTable().get(addr);\n-        return page.forward_object(addr);\n+    Address relocate_object(Address addr) {\n+        ZForwarding forwarding = forwardingTable().get(addr);\n+        if (forwarding == null) {\n+            return ZAddress.good(addr);\n+        }\n+        return relocate().relocateObject(forwarding, ZAddress.good(addr));\n@@ -88,3 +103,16 @@\n-    Address relocate_object(Address addr) {\n-        ZPage page = pageTable().get(addr);\n-        return page.relocate_object(addr);\n+    public boolean isIn(Address addr) {\n+        if (ZAddress.isIn(addr)) {\n+            ZPage page = pageTable().get(addr);\n+            if (page != null) {\n+                return page.isIn(addr);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public Address remapObject(Address o) {\n+        ZForwarding forwarding = forwardingTable().get(addr);\n+        if (forwarding == null) {\n+            return ZAddress.good(o);\n+        }\n+        return relocate().forwardObject(forwarding, ZAddress.good(o));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZHeap.java","additions":35,"deletions":7,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-        return ZUtils.longToAddress(ZAddress.as_long(oop));\n+        return oop;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZOop.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,2 +49,0 @@\n-    private static CIntegerField refcountField;\n-    private static long forwardingFieldOffset;\n@@ -63,2 +61,0 @@\n-        refcountField = type.getCIntegerField(\"_refcount\");\n-        forwardingFieldOffset = type.getField(\"_forwarding\").getOffset();\n@@ -87,13 +83,0 @@\n-    private int refcount() {\n-        \/\/ refcount is uint32_t so need to be cautious when using this field.\n-        return refcountField.getJInt(addr);\n-    }\n-\n-    private ZForwardingTable forwarding() {\n-        return VMObjectFactory.newObject(ZForwardingTable.class, addr.addOffsetTo(forwardingFieldOffset));\n-    }\n-\n-    private boolean is_forwarding() {\n-        return forwarding().table() != null;\n-    }\n-\n@@ -101,8 +84,1 @@\n-        return is_active() && seqnum() < ZGlobals.ZGlobalSeqNum();\n-    }\n-\n-    private boolean isPageRelocating() {\n-        assert(is_active());\n-        \/\/ is_forwarding():  Has a (relocation) forwarding table\n-        \/\/ is_relocatable(): Has not been freed yet\n-        return is_forwarding() && is_relocatable();\n+        return seqnum() < ZGlobals.ZGlobalSeqNum();\n@@ -119,25 +95,0 @@\n-    Address forward_object(Address from) {\n-        \/\/ Lookup address in forwarding table\n-        long from_offset = ZAddress.offset(from);\n-        long from_index = (from_offset - start()) >> object_alignment_shift();\n-        ZForwardingTableEntry entry = forwarding().find(from_index);\n-        assert(!entry.is_empty());\n-        assert(entry.from_index() == from_index);\n-\n-        return ZAddress.good(entry.to_offset());\n-    }\n-\n-    Address relocate_object(Address from) {\n-        \/\/ Lookup address in forwarding table\n-        long from_offset = ZAddress.offset(from);\n-        long from_index = (from_offset - start()) >> object_alignment_shift();\n-        ZForwardingTableEntry entry = forwarding().find(from_index);\n-        if (!entry.is_empty() && entry.from_index() == from_index) {\n-          return ZAddress.good(entry.to_offset());\n-        }\n-\n-        \/\/ There's no relocate operation in the SA.\n-        \/\/ Mimic object pinning and return the good view of the from object.\n-        return ZAddress.good(from);\n-    }\n-\n@@ -159,2 +110,4 @@\n-    public boolean is_active() {\n-        return refcount() != 0;\n+    public boolean isIn(Address addr) {\n+        long offset = ZAddress.offset(addr);\n+        \/\/ FIXME: it does not consider the sign.\n+        return (offset >= start()) && (offset < top().asLongValue());\n@@ -176,48 +129,0 @@\n-    private void addNotRelocatedRegions(List<MemRegion> regions) {\n-        MemRegion mr = null;\n-\n-        \/\/ Some objects have already been forwarded to new locations.\n-        long topValue = top().asLongValue();\n-        for (long offsetValue = start(); offsetValue < topValue;) {\n-            Address from = ZAddress.good(ZUtils.longToAddress(offsetValue));\n-\n-            Address to = relocate_object(from);\n-\n-            long byteSize;\n-            try {\n-                byteSize = getObjectSize(to);\n-            } catch (Exception e) {\n-                \/\/ Parsing the ZHeap is inherently unsafe\n-                \/\/ when classes have been unloaded. Dead objects\n-                \/\/ might have stale Klass pointers, and there's\n-                \/\/ no way to get the size of the dead object.\n-                \/\/\n-                \/\/ If possible, run with -XX:-ClassUnloading\n-                \/\/ to ensure that all Klasses are kept alive.\n-                System.err.println(\"Unparsable regions found. Skipping: \"\n-                        + from\n-                        + \" \"\n-                        + from.addOffsetTo(topValue - offsetValue));\n-\n-                \/\/ Can't proceed further. Just return the collected regions.\n-                return;\n-            }\n-\n-            if (from.equals(to)) {\n-                \/\/ Not relocated - add region\n-                if (mr == null) {\n-                    mr = new MemRegion(from, 0 \/* wordSize *\/);\n-                    regions.add(mr);\n-                }\n-\n-                long wordSize = byteSize \/ VM.getVM().getBytesPerWord();\n-                mr.setWordSize(mr.wordSize() + wordSize);\n-            } else {\n-                \/\/ Forwarded somewhere else, split region.\n-                mr = null;\n-            }\n-\n-            offsetValue += byteSize;\n-        }\n-    }\n-\n@@ -225,6 +130,1 @@\n-        List<MemRegion> res = new ArrayList<>();\n-\n-        if (isPageRelocating()) {\n-            addNotRelocatedRegions(res);\n-        } else {\n-            Address start = ZAddress.good(ZUtils.longToAddress(start()));\n+        Address start = ZAddress.good(ZUtils.longToAddress(start()));\n@@ -232,9 +132,6 @@\n-            \/\/ Can't convert top() to a \"good\" address because it might\n-            \/\/ be at the top of the \"offset\" range, and therefore also\n-            \/\/ looks like one of the color bits. Instead use the \"good\"\n-            \/\/ address and add the size.\n-            long size = top().asLongValue() - start();\n-            Address end = start.addOffsetTo(size);\n-\n-            res.add(new MemRegion(start, end));\n-        }\n+        \/\/ Can't convert top() to a \"good\" address because it might\n+        \/\/ be at the top of the \"offset\" range, and therefore also\n+        \/\/ looks like one of the color bits. Instead use the \"good\"\n+        \/\/ address and add the size.\n+        long size = top().asLongValue() - start();\n+        Address end = start.addOffsetTo(size);\n@@ -242,1 +139,1 @@\n-        return res;\n+        return List.of(new MemRegion(start, end));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZPage.java","additions":14,"deletions":117,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-        return getEntry(o).page();\n+        return VMObjectFactory.newObject(ZPage.class, map().get(VM.getVM().getDebugger().newAddress(ZAddress.offset(o))));\n@@ -172,1 +172,1 @@\n-                return page.is_active();\n+                return page != null;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZPageTable.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, NTT DATA.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.gc.z;\n+\n+import sun.jvm.hotspot.debugger.Address;\n+import sun.jvm.hotspot.runtime.VM;\n+import sun.jvm.hotspot.runtime.VMObject;\n+import sun.jvm.hotspot.types.AddressField;\n+import sun.jvm.hotspot.types.Type;\n+import sun.jvm.hotspot.types.TypeDataBase;\n+\n+public class ZRelocate  extends VMObject {\n+\n+    static {\n+        VM.registerVMInitializedObserver((o, d) -> initialize(VM.getVM().getTypeDataBase()));\n+    }\n+\n+    static private synchronized void initialize(TypeDataBase db) {\n+        Type type = db.lookupType(\"ZRelocate\");\n+    }\n+\n+    public ZRelocate(Address addr) {\n+        super(addr);\n+    }\n+\n+    private long forwardingIndex(ZForwarding forwarding, Address from) {\n+        long fromOffset = ZAddress.offset(from);\n+        return (fromOffset - forwarding.start()) >>> forwarding.objectAlignmentShift();\n+    }\n+\n+    private Address forwardingFind(ZForwarding forwarding, Address from) {\n+        long fromIndex = forwardingIndex(forwarding, from);\n+        ZForwardingEntry entry = forwarding.find(fromIndex);\n+        return entry.populated() ? ZAddress.good(VM.getVM().getDebugger().newAddress(entry.toOffset())) : null;\n+    }\n+\n+    public Address forwardObject(ZForwarding forwarding, Address from) {\n+        return forwardingFind(forwarding, from);\n+    }\n+\n+    public Address relocateObject(ZForwarding forwarding, Address o) {\n+        Address toAddr = forwardingFind(forwarding, o);\n+        if (toAddr != null) {\n+            \/\/ Already relocated.\n+            return toAddr;\n+        } else {\n+            \/\/ Return original address because it is not yet relocated.\n+            return o;\n+        }\n+    }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZRelocate.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,4 +31,2 @@\n-    private static final long MSB = ~0L ^ (~0L >>> 1);\n-\n-    private static Address msbAddress() {\n-        return VM.getVM().getUniverse().heap().start().orWithMask(MSB).andWithMask(MSB);\n+    static Address longToAddress(long value) {\n+        return VM.getVM().getDebugger().newAddress(value);\n@@ -37,5 +35,4 @@\n-    static Address longToAddress(long value) {\n-        \/\/ If the value of an Address becomes 0, null is returned instead of an Address.\n-        \/\/ Start with a one-bit address and as a last step, remove that bit.\n-        Address oneAddress = msbAddress();\n-        return oneAddress.orWithMask(value).xorWithMask(ZAddress.as_long(oneAddress));\n+    static long alignUp(long size, long alignment) {\n+        long mask = alignment - 1;\n+        long adjusted = size + mask;\n+        return adjusted & ~mask;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZUtils.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -33,1 +33,2 @@\n-import jdk.internal.foreign.abi.aarch64.AArch64VaList;\n+import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64VaList;\n+import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64VaList;\n@@ -216,1 +217,2 @@\n-     * <p>The returned memory address is associated with the provided scope. When such scope is closed,\n+     * <p>\n+     * The returned memory address is associated with the provided scope. When such scope is closed,\n@@ -220,1 +222,4 @@\n-     * the VM will exit with a non-zero exit code.\n+     * the VM will exit with a non-zero exit code. To avoid the VM aborting due to an uncaught exception, clients\n+     * could wrap all code in the target method handle in a try\/catch block that catches any {@link Throwable}, for\n+     * instance by using the {@link java.lang.invoke.MethodHandles#catchException(MethodHandle, Class, MethodHandle)}\n+     * method handle combinator, and handle exceptions as desired in the corresponding catch block.\n@@ -533,1 +538,1 @@\n-    sealed interface VaList extends Addressable permits WinVaList, SysVVaList, AArch64VaList, SharedUtils.EmptyVaList {\n+    sealed interface VaList extends Addressable permits WinVaList, SysVVaList, LinuxAArch64VaList, MacOsAArch64VaList, SharedUtils.EmptyVaList {\n@@ -738,1 +743,1 @@\n-        sealed interface Builder permits WinVaList.Builder, SysVVaList.Builder, AArch64VaList.Builder {\n+        sealed interface Builder permits WinVaList.Builder, SysVVaList.Builder, LinuxAArch64VaList.Builder, MacOsAArch64VaList.Builder {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,2 @@\n-    AArch64;\n+    LinuxAArch64,\n+    MacOsAArch64;\n@@ -53,1 +54,6 @@\n-            current = AArch64;\n+            if (os.startsWith(\"Mac\")) {\n+                current = MacOsAArch64;\n+            } else {\n+                \/\/ The Linux ABI follows the standard AAPCS ABI\n+                current = LinuxAArch64;\n+            }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/CABI.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-            case AArch64 -> aarch64;\n+            case LinuxAArch64, MacOsAArch64 -> aarch64;\n@@ -46,4 +46,5 @@\n-        if (CABI.current() == CABI.Win64) {\n-            return Win64.asVarArg(ml);\n-        }\n-        return ml;\n+        return switch (CABI.current()) {\n+            case Win64 -> Win64.asVarArg(ml);\n+            case MacOsAArch64 -> AArch64.asVarArg(ml);\n+            default -> ml;\n+        };\n@@ -161,1 +162,1 @@\n-         * The name of the layout attribute (see {@link MemoryLayout#attributes()} used to mark variadic parameters. The\n+         * The name of the layout attribute (see {@link MemoryLayout#attributes()}) used to mark variadic parameters. The\n@@ -274,0 +275,20 @@\n+\n+        \/**\n+         * The name of the layout attribute (see {@link MemoryLayout#attributes()})\n+         * used to mark variadic parameters on systems such as macOS which pass these\n+         * entirely on the stack. The attribute value must be a boolean.\n+         *\/\n+        public final static String STACK_VARARGS_ATTRIBUTE_NAME = \"abi\/aarch64\/stack_varargs\";\n+\n+        \/**\n+         * Return a new memory layout which describes a variadic parameter to be\n+         * passed to a function. This is only required on platforms such as macOS\n+         * which pass variadic parameters entirely on the stack.\n+         * @param layout the original parameter layout.\n+         * @return a layout which is the same as {@code layout}, except for\n+         * the extra attribute {@link #STACK_VARARGS_ATTRIBUTE_NAME}, which is set\n+         * to {@code true}.\n+         *\/\n+        public static MemoryLayout asVarArg(MemoryLayout layout) {\n+            return layout.withAttribute(STACK_VARARGS_ATTRIBUTE_NAME, true);\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/PlatformLayouts.java","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        case SysV, AArch64 -> libLookup(libs -> libs.loadLibrary(\"syslookup\"));\n+        case SysV, LinuxAArch64, MacOsAArch64 -> libLookup(libs -> libs.loadLibrary(\"syslookup\"));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,2 @@\n-import jdk.internal.foreign.abi.aarch64.AArch64Linker;\n+import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64Linker;\n+import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64Linker;\n@@ -282,1 +283,2 @@\n-            case AArch64 -> AArch64Linker.getInstance();\n+            case LinuxAArch64 -> LinuxAArch64Linker.getInstance();\n+            case MacOsAArch64 -> MacOsAArch64Linker.getInstance();\n@@ -493,1 +495,2 @@\n-            case AArch64 -> AArch64Linker.newVaList(actions, scope);\n+            case LinuxAArch64 -> LinuxAArch64Linker.newVaList(actions, scope);\n+            case MacOsAArch64 -> MacOsAArch64Linker.newVaList(actions, scope);\n@@ -507,1 +510,2 @@\n-            case AArch64 -> AArch64Linker.newVaListOfAddress(ma, scope);\n+            case LinuxAArch64 -> LinuxAArch64Linker.newVaListOfAddress(ma, scope);\n+            case MacOsAArch64 -> MacOsAArch64Linker.newVaListOfAddress(ma, scope);\n@@ -515,1 +519,2 @@\n-            case AArch64 -> AArch64Linker.emptyVaList();\n+            case LinuxAArch64 -> LinuxAArch64Linker.emptyVaList();\n+            case MacOsAArch64 -> MacOsAArch64Linker.emptyVaList();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,112 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019, 2020, Arm Limited. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.foreign.abi.aarch64;\n-\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.internal.foreign.AbstractCLinker;\n-import jdk.internal.foreign.ResourceScopeImpl;\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.abi.UpcallStubs;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-\n-\/**\n- * ABI implementation based on ARM document \"Procedure Call Standard for\n- * the ARM 64-bit Architecture\".\n- *\/\n-public final class AArch64Linker extends AbstractCLinker {\n-    private static AArch64Linker instance;\n-\n-    static final long ADDRESS_SIZE = 64; \/\/ bits\n-\n-    private static final MethodHandle MH_unboxVaList;\n-    private static final MethodHandle MH_boxVaList;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            MH_unboxVaList = lookup.findVirtual(VaList.class, \"address\",\n-                MethodType.methodType(MemoryAddress.class));\n-            MH_boxVaList = MethodHandles.insertArguments(lookup.findStatic(AArch64Linker.class, \"newVaListOfAddress\",\n-                MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)), 1, ResourceScope.globalScope());\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-    }\n-\n-    public static AArch64Linker getInstance() {\n-        if (instance == null) {\n-            instance = new AArch64Linker();\n-        }\n-        return instance;\n-    }\n-\n-    @Override\n-    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(type);\n-        Objects.requireNonNull(function);\n-        MethodType llMt = SharedUtils.convertVaListCarriers(type, AArch64VaList.CARRIER);\n-        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n-        if (!type.returnType().equals(MemorySegment.class)) {\n-            \/\/ not returning segment, just insert a throwing allocator\n-            handle = MethodHandles.insertArguments(handle, 1, SharedUtils.THROWING_ALLOCATOR);\n-        }\n-        handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);\n-        return handle;\n-    }\n-\n-    @Override\n-    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n-        Objects.requireNonNull(scope);\n-        Objects.requireNonNull(target);\n-        Objects.requireNonNull(function);\n-        SharedUtils.checkExceptions(target);\n-        target = SharedUtils.boxVaLists(target, MH_boxVaList);\n-        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function), (ResourceScopeImpl) scope);\n-    }\n-\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n-        AArch64VaList.Builder builder = AArch64VaList.builder(scope);\n-        actions.accept(builder);\n-        return builder.build();\n-    }\n-\n-    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n-        return AArch64VaList.ofAddress(ma, scope);\n-    }\n-\n-    public static VaList emptyVaList() {\n-        return AArch64VaList.empty();\n-    }\n-\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Linker.java","additions":0,"deletions":112,"binary":false,"changes":112,"status":"deleted"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2019, 2020, Arm Limited. All rights reserved.\n+ * Copyright (c) 2019, 2021, Arm Limited. All rights reserved.\n@@ -99,1 +99,1 @@\n-        SharedUtils.checkFunctionTypes(mt, cDesc, AArch64Linker.ADDRESS_SIZE);\n+        SharedUtils.checkFunctionTypes(mt, cDesc, AArch64.C_POINTER.bitSize());\n@@ -210,0 +210,10 @@\n+\n+        void adjustForVarArgs(MemoryLayout layout) {\n+            if (layout.attribute(AArch64.STACK_VARARGS_ATTRIBUTE_NAME)\n+                    .map(Boolean.class::cast).orElse(false)) {\n+                \/\/ This system passes all variadic parameters on the stack. Ensure\n+                \/\/ no further arguments are allocated to registers.\n+                nRegs[StorageClasses.INTEGER] = MAX_REGISTER_ARGUMENTS;\n+                nRegs[StorageClasses.VECTOR] = MAX_REGISTER_ARGUMENTS;\n+            }\n+        }\n@@ -281,0 +291,1 @@\n+            storageCalculator.adjustForVarArgs(layout);\n@@ -383,0 +394,1 @@\n+            assert !layout.attribute(AArch64.STACK_VARARGS_ATTRIBUTE_NAME).isPresent() : \"no variadic upcalls\";\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Arm Limited. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Arm Limited. All rights reserved.\n@@ -34,1 +34,1 @@\n-enum TypeClass {\n+public enum TypeClass {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/TypeClass.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.linux;\n+\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.internal.foreign.AbstractCLinker;\n+import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.foreign.abi.UpcallStubs;\n+import jdk.internal.foreign.abi.aarch64.CallArranger;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * ABI implementation based on ARM document \"Procedure Call Standard for\n+ * the ARM 64-bit Architecture\".\n+ *\/\n+public final class LinuxAArch64Linker extends AbstractCLinker {\n+    private static LinuxAArch64Linker instance;\n+\n+    static final long ADDRESS_SIZE = 64; \/\/ bits\n+\n+    private static final MethodHandle MH_unboxVaList;\n+    private static final MethodHandle MH_boxVaList;\n+\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            MH_unboxVaList = lookup.findVirtual(VaList.class, \"address\",\n+                MethodType.methodType(MemoryAddress.class));\n+            MH_boxVaList = MethodHandles.insertArguments(lookup.findStatic(LinuxAArch64Linker.class, \"newVaListOfAddress\",\n+                MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)), 1, ResourceScope.globalScope());\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    public static LinuxAArch64Linker getInstance() {\n+        if (instance == null) {\n+            instance = new LinuxAArch64Linker();\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n+        Objects.requireNonNull(type);\n+        Objects.requireNonNull(function);\n+        MethodType llMt = SharedUtils.convertVaListCarriers(type, LinuxAArch64VaList.CARRIER);\n+        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n+        if (!type.returnType().equals(MemorySegment.class)) {\n+            \/\/ not returning segment, just insert a throwing allocator\n+            handle = MethodHandles.insertArguments(handle, 1, SharedUtils.THROWING_ALLOCATOR);\n+        }\n+        handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);\n+        return handle;\n+    }\n+\n+    @Override\n+    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n+        Objects.requireNonNull(target);\n+        Objects.requireNonNull(function);\n+        SharedUtils.checkExceptions(target);\n+        target = SharedUtils.boxVaLists(target, MH_boxVaList);\n+        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function), (ResourceScopeImpl) scope);\n+    }\n+\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n+        LinuxAArch64VaList.Builder builder = LinuxAArch64VaList.builder(scope);\n+        actions.accept(builder);\n+        return builder.build();\n+    }\n+\n+    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n+        return LinuxAArch64VaList.ofAddress(ma, scope);\n+    }\n+\n+    public static VaList emptyVaList() {\n+        return LinuxAArch64VaList.empty();\n+    }\n+\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Arm Limited. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Arm Limited. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.internal.foreign.abi.aarch64;\n+package jdk.internal.foreign.abi.aarch64.linux;\n@@ -31,0 +31,1 @@\n+import jdk.internal.foreign.abi.aarch64.*;\n@@ -49,1 +50,5 @@\n-public non-sealed class AArch64VaList implements VaList {\n+\/**\n+ * Standard va_list implementation as defined by AAPCS document and used on\n+ * Linux. Variadic parameters may be passed in registers or on the stack.\n+ *\/\n+public non-sealed class LinuxAArch64VaList implements VaList {\n@@ -108,1 +113,1 @@\n-    private AArch64VaList(MemorySegment segment, MemorySegment gpRegsArea, MemorySegment fpRegsArea) {\n+    private LinuxAArch64VaList(MemorySegment segment, MemorySegment gpRegsArea, MemorySegment fpRegsArea) {\n@@ -114,1 +119,1 @@\n-    private static AArch64VaList readFromSegment(MemorySegment segment) {\n+    private static LinuxAArch64VaList readFromSegment(MemorySegment segment) {\n@@ -120,1 +125,1 @@\n-        return new AArch64VaList(segment, gpRegsArea, fpRegsArea);\n+        return new LinuxAArch64VaList(segment, gpRegsArea, fpRegsArea);\n@@ -127,1 +132,1 @@\n-        cleaner.register(AArch64VaList.class, () -> ms.scope().close());\n+        cleaner.register(LinuxAArch64VaList.class, () -> ms.scope().close());\n@@ -249,1 +254,1 @@\n-        checkCompatibleType(carrier, layout, AArch64Linker.ADDRESS_SIZE);\n+        checkCompatibleType(carrier, layout, LinuxAArch64Linker.ADDRESS_SIZE);\n@@ -349,2 +354,2 @@\n-    static AArch64VaList.Builder builder(ResourceScope scope) {\n-        return new AArch64VaList.Builder(scope);\n+    static LinuxAArch64VaList.Builder builder(ResourceScope scope) {\n+        return new LinuxAArch64VaList.Builder(scope);\n@@ -366,1 +371,1 @@\n-        return new AArch64VaList(copy, gpRegsArea, fpRegsArea);\n+        return new LinuxAArch64VaList(copy, gpRegsArea, fpRegsArea);\n@@ -391,1 +396,1 @@\n-        return \"AArch64VaList{\"\n+        return \"LinuxAArch64VaList{\"\n@@ -443,1 +448,1 @@\n-            checkCompatibleType(carrier, layout, AArch64Linker.ADDRESS_SIZE);\n+            checkCompatibleType(carrier, layout, LinuxAArch64Linker.ADDRESS_SIZE);\n@@ -536,1 +541,1 @@\n-            return new AArch64VaList(vaListSegment, gpRegs, fpRegs);\n+            return new LinuxAArch64VaList(vaListSegment, gpRegs, fpRegs);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":20,"deletions":15,"binary":false,"changes":35,"previous_filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64VaList.java","status":"renamed"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.macos;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.internal.foreign.AbstractCLinker;\n+import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.foreign.abi.UpcallStubs;\n+import jdk.internal.foreign.abi.aarch64.CallArranger;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+import static jdk.internal.foreign.PlatformLayouts.*;\n+\n+\/**\n+ * ABI implementation for macOS on Apple silicon. Based on AAPCS with\n+ * changes to va_list and passing arguments on the stack.\n+ *\/\n+public final class MacOsAArch64Linker extends AbstractCLinker {\n+    private static MacOsAArch64Linker instance;\n+\n+    static final long ADDRESS_SIZE = 64; \/\/ bits\n+\n+    private static final MethodHandle MH_unboxVaList;\n+    private static final MethodHandle MH_boxVaList;\n+\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            MH_unboxVaList = lookup.findVirtual(VaList.class, \"address\",\n+                MethodType.methodType(MemoryAddress.class));\n+            MH_boxVaList = MethodHandles.insertArguments(lookup.findStatic(MacOsAArch64Linker.class, \"newVaListOfAddress\",\n+                MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)), 1, ResourceScope.globalScope());\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    public static MacOsAArch64Linker getInstance() {\n+        if (instance == null) {\n+            instance = new MacOsAArch64Linker();\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n+        Objects.requireNonNull(type);\n+        Objects.requireNonNull(function);\n+        MethodType llMt = SharedUtils.convertVaListCarriers(type, MacOsAArch64VaList.CARRIER);\n+        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n+        if (!type.returnType().equals(MemorySegment.class)) {\n+            \/\/ not returning segment, just insert a throwing allocator\n+            handle = MethodHandles.insertArguments(handle, 1, SharedUtils.THROWING_ALLOCATOR);\n+        }\n+        handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);\n+        return handle;\n+    }\n+\n+    @Override\n+    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n+        Objects.requireNonNull(target);\n+        Objects.requireNonNull(function);\n+        target = SharedUtils.boxVaLists(target, MH_boxVaList);\n+        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function), (ResourceScopeImpl) scope);\n+    }\n+\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n+        MacOsAArch64VaList.Builder builder = MacOsAArch64VaList.builder(scope);\n+        actions.accept(builder);\n+        return builder.build();\n+    }\n+\n+    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n+        return MacOsAArch64VaList.ofAddress(ma, scope);\n+    }\n+\n+    public static VaList emptyVaList() {\n+        return MacOsAArch64VaList.empty();\n+    }\n+\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.macos;\n+\n+import jdk.incubator.foreign.*;\n+import jdk.incubator.foreign.CLinker.VaList;\n+import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.foreign.abi.SharedUtils.SimpleVaArg;\n+import jdk.internal.foreign.abi.aarch64.*;\n+\n+import java.lang.invoke.VarHandle;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static jdk.internal.foreign.PlatformLayouts.AArch64.C_POINTER;\n+import static jdk.internal.foreign.abi.SharedUtils.alignUp;\n+\n+\/**\n+ * Simplified va_list implementation used on macOS where all variadic\n+ * parameters are passed on the stack and the type of va_list decays to\n+ * char* instead of the structure defined in the AAPCS.\n+ *\/\n+public non-sealed class MacOsAArch64VaList implements VaList {\n+    public static final Class<?> CARRIER = MemoryAddress.class;\n+    private static final long VA_SLOT_SIZE_BYTES = 8;\n+    private static final VarHandle VH_address = MemoryHandles.asAddressVarHandle(C_POINTER.varHandle(long.class));\n+\n+    private static final VaList EMPTY = new SharedUtils.EmptyVaList(MemoryAddress.NULL);\n+\n+    private MemorySegment segment;\n+    private final ResourceScope scope;\n+\n+    private MacOsAArch64VaList(MemorySegment segment, ResourceScope scope) {\n+        this.segment = segment;\n+        this.scope = scope;\n+    }\n+\n+    public static final VaList empty() {\n+        return EMPTY;\n+    }\n+\n+    @Override\n+    public int vargAsInt(MemoryLayout layout) {\n+        return (int) read(int.class, layout);\n+    }\n+\n+    @Override\n+    public long vargAsLong(MemoryLayout layout) {\n+        return (long) read(long.class, layout);\n+    }\n+\n+    @Override\n+    public double vargAsDouble(MemoryLayout layout) {\n+        return (double) read(double.class, layout);\n+    }\n+\n+    @Override\n+    public MemoryAddress vargAsAddress(MemoryLayout layout) {\n+        return (MemoryAddress) read(MemoryAddress.class, layout);\n+    }\n+\n+    @Override\n+    public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n+        Objects.requireNonNull(allocator);\n+        return (MemorySegment) read(MemorySegment.class, layout, allocator);\n+    }\n+\n+    @Override\n+    public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n+        return vargAsSegment(layout, SegmentAllocator.ofScope(scope));\n+    }\n+\n+    private Object read(Class<?> carrier, MemoryLayout layout) {\n+        return read(carrier, layout, SharedUtils.THROWING_ALLOCATOR);\n+    }\n+\n+    private Object read(Class<?> carrier, MemoryLayout layout, SegmentAllocator allocator) {\n+        Objects.requireNonNull(layout);\n+        SharedUtils.checkCompatibleType(carrier, layout, MacOsAArch64Linker.ADDRESS_SIZE);\n+        Object res;\n+        if (carrier == MemorySegment.class) {\n+            TypeClass typeClass = TypeClass.classifyLayout(layout);\n+            res = switch (typeClass) {\n+                case STRUCT_REFERENCE -> {\n+                    MemoryAddress structAddr = (MemoryAddress) VH_address.get(segment);\n+                    MemorySegment struct = structAddr.asSegment(layout.byteSize(), scope());\n+                    MemorySegment seg = allocator.allocate(layout);\n+                    seg.copyFrom(struct);\n+                    segment = segment.asSlice(VA_SLOT_SIZE_BYTES);\n+                    yield seg;\n+                }\n+                case STRUCT_REGISTER, STRUCT_HFA -> {\n+                    MemorySegment struct = allocator.allocate(layout);\n+                    struct.copyFrom(segment.asSlice(0L, layout.byteSize()));\n+                    segment = segment.asSlice(alignUp(layout.byteSize(), VA_SLOT_SIZE_BYTES));\n+                    yield struct;\n+                }\n+                default -> throw new IllegalStateException(\"Unexpected TypeClass: \" + typeClass);\n+            };\n+        } else {\n+            VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);\n+            res = reader.get(segment);\n+            segment = segment.asSlice(VA_SLOT_SIZE_BYTES);\n+        }\n+        return res;\n+    }\n+\n+    @Override\n+    public void skip(MemoryLayout... layouts) {\n+        Objects.requireNonNull(layouts);\n+\n+        for (MemoryLayout layout : layouts) {\n+            Objects.requireNonNull(layout);\n+            segment = segment.asSlice(switch (TypeClass.classifyLayout(layout)) {\n+                case STRUCT_REGISTER, STRUCT_HFA -> alignUp(layout.byteSize(), VA_SLOT_SIZE_BYTES);\n+                default -> VA_SLOT_SIZE_BYTES;\n+            });\n+        }\n+    }\n+\n+    static MacOsAArch64VaList ofAddress(MemoryAddress addr, ResourceScope scope) {\n+        MemorySegment segment = addr.asSegment(Long.MAX_VALUE, scope);\n+        return new MacOsAArch64VaList(segment, scope);\n+    }\n+\n+    static Builder builder(ResourceScope scope) {\n+        return new Builder(scope);\n+    }\n+\n+    @Override\n+    public ResourceScope scope() {\n+        return scope;\n+    }\n+\n+    @Override\n+    public VaList copy() {\n+        ((ResourceScopeImpl)scope).checkValidStateSlow();\n+        return new MacOsAArch64VaList(segment, scope);\n+    }\n+\n+    @Override\n+    public MemoryAddress address() {\n+        return segment.address();\n+    }\n+\n+    public static non-sealed class Builder implements VaList.Builder {\n+\n+        private final ResourceScope scope;\n+        private final List<SimpleVaArg> args = new ArrayList<>();\n+\n+        public Builder(ResourceScope scope) {\n+            ((ResourceScopeImpl)scope).checkValidStateSlow();\n+            this.scope = scope;\n+        }\n+\n+        private Builder arg(Class<?> carrier, MemoryLayout layout, Object value) {\n+            Objects.requireNonNull(layout);\n+            Objects.requireNonNull(value);\n+            SharedUtils.checkCompatibleType(carrier, layout, MacOsAArch64Linker.ADDRESS_SIZE);\n+            args.add(new SimpleVaArg(carrier, layout, value));\n+            return this;\n+        }\n+\n+        @Override\n+        public Builder vargFromInt(ValueLayout layout, int value) {\n+            return arg(int.class, layout, value);\n+        }\n+\n+        @Override\n+        public Builder vargFromLong(ValueLayout layout, long value) {\n+            return arg(long.class, layout, value);\n+        }\n+\n+        @Override\n+        public Builder vargFromDouble(ValueLayout layout, double value) {\n+            return arg(double.class, layout, value);\n+        }\n+\n+        @Override\n+        public Builder vargFromAddress(ValueLayout layout, Addressable value) {\n+            return arg(MemoryAddress.class, layout, value.address());\n+        }\n+\n+        @Override\n+        public Builder vargFromSegment(GroupLayout layout, MemorySegment value) {\n+            return arg(MemorySegment.class, layout, value);\n+        }\n+\n+        public VaList build() {\n+            if (args.isEmpty()) {\n+                return EMPTY;\n+            }\n+\n+            SegmentAllocator allocator = SegmentAllocator.arenaAllocator(scope);\n+\n+            \/\/ Each argument may occupy up to four slots\n+            MemorySegment segment = allocator.allocate(VA_SLOT_SIZE_BYTES * args.size() * 4);\n+\n+            List<MemorySegment> attachedSegments = new ArrayList<>();\n+            attachedSegments.add(segment);\n+            MemorySegment cursor = segment;\n+\n+            for (SimpleVaArg arg : args) {\n+                if (arg.carrier == MemorySegment.class) {\n+                    MemorySegment msArg = ((MemorySegment) arg.value);\n+                    TypeClass typeClass = TypeClass.classifyLayout(arg.layout);\n+                    switch (typeClass) {\n+                        case STRUCT_REFERENCE -> {\n+                            MemorySegment copy = allocator.allocate(arg.layout);\n+                            copy.copyFrom(msArg); \/\/ by-value\n+                            attachedSegments.add(copy);\n+                            VH_address.set(cursor, copy.address());\n+                            cursor = cursor.asSlice(VA_SLOT_SIZE_BYTES);\n+                        }\n+                        case STRUCT_REGISTER, STRUCT_HFA -> {\n+                            cursor.copyFrom(msArg.asSlice(0, arg.layout.byteSize()));\n+                            cursor = cursor.asSlice(alignUp(arg.layout.byteSize(), VA_SLOT_SIZE_BYTES));\n+                        }\n+                        default -> throw new IllegalStateException(\"Unexpected TypeClass: \" + typeClass);\n+                    }\n+                } else {\n+                    VarHandle writer = arg.varHandle();\n+                    writer.set(cursor, arg.value);\n+                    cursor = cursor.asSlice(VA_SLOT_SIZE_BYTES);\n+                }\n+            }\n+\n+            return new MacOsAArch64VaList(segment, scope);\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -333,1 +333,0 @@\n-    @Override\n@@ -336,6 +335,1 @@\n-        byte[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Byte128Shuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -333,1 +333,0 @@\n-    @Override\n@@ -336,6 +335,1 @@\n-        byte[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Byte256Shuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -333,1 +333,0 @@\n-    @Override\n@@ -336,6 +335,1 @@\n-        byte[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Byte512Shuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -333,1 +333,0 @@\n-    @Override\n@@ -336,6 +335,1 @@\n-        byte[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Byte64Shuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -333,1 +333,0 @@\n-    @Override\n@@ -336,6 +335,1 @@\n-        byte[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(ByteMaxShuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2169,0 +2169,23 @@\n+    @ForceInline\n+    private final\n+    VectorShuffle<Byte> toShuffle0(ByteSpecies dsp) {\n+        byte[] a = toArray();\n+        int[] sa = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            sa[i] = (int) a[i];\n+        }\n+        return VectorShuffle.fromArray(dsp, sa, 0);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Byte> toShuffleTemplate(Class<?> shuffleType) {\n+        ByteSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), byte.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     ByteVector::toShuffle0);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -327,1 +327,0 @@\n-    @Override\n@@ -330,6 +329,1 @@\n-        double[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Double128Shuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -327,1 +327,0 @@\n-    @Override\n@@ -330,6 +329,1 @@\n-        double[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Double256Shuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -327,1 +327,0 @@\n-    @Override\n@@ -330,6 +329,1 @@\n-        double[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Double512Shuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -327,1 +327,0 @@\n-    @Override\n@@ -330,6 +329,1 @@\n-        double[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Double64Shuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -327,1 +327,0 @@\n-    @Override\n@@ -330,6 +329,1 @@\n-        double[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(DoubleMaxShuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2076,0 +2076,23 @@\n+    @ForceInline\n+    private final\n+    VectorShuffle<Double> toShuffle0(DoubleSpecies dsp) {\n+        double[] a = toArray();\n+        int[] sa = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            sa[i] = (int) a[i];\n+        }\n+        return VectorShuffle.fromArray(dsp, sa, 0);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Double> toShuffleTemplate(Class<?> shuffleType) {\n+        DoubleSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), double.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     DoubleVector::toShuffle0);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -327,1 +327,0 @@\n-    @Override\n@@ -330,6 +329,1 @@\n-        float[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Float128Shuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -327,1 +327,0 @@\n-    @Override\n@@ -330,6 +329,1 @@\n-        float[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Float256Shuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -327,1 +327,0 @@\n-    @Override\n@@ -330,6 +329,1 @@\n-        float[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Float512Shuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -327,1 +327,0 @@\n-    @Override\n@@ -330,6 +329,1 @@\n-        float[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Float64Shuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -327,1 +327,0 @@\n-    @Override\n@@ -330,6 +329,1 @@\n-        float[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(FloatMaxShuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2088,0 +2088,23 @@\n+    @ForceInline\n+    private final\n+    VectorShuffle<Float> toShuffle0(FloatSpecies dsp) {\n+        float[] a = toArray();\n+        int[] sa = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            sa[i] = (int) a[i];\n+        }\n+        return VectorShuffle.fromArray(dsp, sa, 0);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Float> toShuffleTemplate(Class<?> shuffleType) {\n+        FloatSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), float.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     FloatVector::toShuffle0);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -333,1 +333,0 @@\n-    @Override\n@@ -336,6 +335,1 @@\n-        int[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Int128Shuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -333,1 +333,0 @@\n-    @Override\n@@ -336,6 +335,1 @@\n-        int[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Int256Shuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -333,1 +333,0 @@\n-    @Override\n@@ -336,6 +335,1 @@\n-        int[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Int512Shuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -333,1 +333,0 @@\n-    @Override\n@@ -336,6 +335,1 @@\n-        int[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Int64Shuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -333,1 +333,0 @@\n-    @Override\n@@ -336,6 +335,1 @@\n-        int[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(IntMaxShuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2168,0 +2168,23 @@\n+    @ForceInline\n+    private final\n+    VectorShuffle<Integer> toShuffle0(IntSpecies dsp) {\n+        int[] a = toArray();\n+        int[] sa = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            sa[i] = (int) a[i];\n+        }\n+        return VectorShuffle.fromArray(dsp, sa, 0);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Integer> toShuffleTemplate(Class<?> shuffleType) {\n+        IntSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), int.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     IntVector::toShuffle0);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -328,1 +328,0 @@\n-    @Override\n@@ -331,6 +330,1 @@\n-        long[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Long128Shuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -328,1 +328,0 @@\n-    @Override\n@@ -331,6 +330,1 @@\n-        long[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Long256Shuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -328,1 +328,0 @@\n-    @Override\n@@ -331,6 +330,1 @@\n-        long[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Long512Shuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -328,1 +328,0 @@\n-    @Override\n@@ -331,6 +330,1 @@\n-        long[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Long64Shuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -328,1 +328,0 @@\n-    @Override\n@@ -331,6 +330,1 @@\n-        long[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(LongMaxShuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2039,0 +2039,23 @@\n+    @ForceInline\n+    private final\n+    VectorShuffle<Long> toShuffle0(LongSpecies dsp) {\n+        long[] a = toArray();\n+        int[] sa = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            sa[i] = (int) a[i];\n+        }\n+        return VectorShuffle.fromArray(dsp, sa, 0);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Long> toShuffleTemplate(Class<?> shuffleType) {\n+        LongSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), long.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     LongVector::toShuffle0);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -333,1 +333,0 @@\n-    @Override\n@@ -336,6 +335,1 @@\n-        short[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Short128Shuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -333,1 +333,0 @@\n-    @Override\n@@ -336,6 +335,1 @@\n-        short[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Short256Shuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -333,1 +333,0 @@\n-    @Override\n@@ -336,6 +335,1 @@\n-        short[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Short512Shuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -333,1 +333,0 @@\n-    @Override\n@@ -336,6 +335,1 @@\n-        short[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Short64Shuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -333,1 +333,0 @@\n-    @Override\n@@ -336,6 +335,1 @@\n-        short[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(ShortMaxShuffle.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2169,0 +2169,23 @@\n+    @ForceInline\n+    private final\n+    VectorShuffle<Short> toShuffle0(ShortSpecies dsp) {\n+        short[] a = toArray();\n+        int[] sa = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            sa[i] = (int) a[i];\n+        }\n+        return VectorShuffle.fromArray(dsp, sa, 0);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Short> toShuffleTemplate(Class<?> shuffleType) {\n+        ShortSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), short.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     ShortVector::toShuffle0);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2436,0 +2436,23 @@\n+    @ForceInline\n+    private final\n+    VectorShuffle<$Boxtype$> toShuffle0($Type$Species dsp) {\n+        $type$[] a = toArray();\n+        int[] sa = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            sa[i] = (int) a[i];\n+        }\n+        return VectorShuffle.fromArray(dsp, sa, 0);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<$Boxtype$> toShuffleTemplate(Class<?> shuffleType) {\n+        $Type$Species vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), $type$.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     $Type$Vector::toShuffle0);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -337,1 +337,0 @@\n-    @Override\n@@ -340,6 +339,1 @@\n-        $type$[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate($shuffletype$.class); \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-                throw new BailoutException(result != config.codeInstallResultDependenciesFailed, msg);\n+                throw new BailoutException(result >= config.codeInstallResultFirstPermanentBailout, msg);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotCodeCacheProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -365,0 +365,2 @@\n+    final int codeInstallResultNMethodReclaimed = getConstant(\"JVMCI::nmethod_reclaimed\", Integer.class);\n+    final int codeInstallResultFirstPermanentBailout = getConstant(\"JVMCI::first_permanent_bailout\", Integer.class);\n@@ -379,0 +381,3 @@\n+        if (codeInstallResult == codeInstallResultNMethodReclaimed) {\n+            return \"nmethod reclaimed\";\n+        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-                    if (tool.iflag || tool.tflag || tool.uflag || tool.xflag || tool.dflag)\n+                    if (tool.iflag || tool.tflag || tool.uflag || tool.xflag || tool.dflag || tool.validate)\n@@ -68,1 +68,1 @@\n-                    if (tool.cflag || tool.tflag || tool.uflag || tool.xflag || tool.dflag)\n+                    if (tool.cflag || tool.tflag || tool.uflag || tool.xflag || tool.dflag || tool.validate)\n@@ -76,1 +76,1 @@\n-                    if (tool.cflag || tool.iflag || tool.uflag || tool.xflag || tool.dflag)\n+                    if (tool.cflag || tool.iflag || tool.uflag || tool.xflag || tool.dflag || tool.validate)\n@@ -83,1 +83,1 @@\n-                    if (tool.cflag || tool.iflag || tool.tflag || tool.xflag || tool.dflag)\n+                    if (tool.cflag || tool.iflag || tool.tflag || tool.xflag || tool.dflag || tool.validate)\n@@ -90,1 +90,1 @@\n-                    if (tool.cflag || tool.iflag  || tool.tflag || tool.uflag || tool.dflag)\n+                    if (tool.cflag || tool.iflag  || tool.tflag || tool.uflag || tool.dflag || tool.validate)\n@@ -97,1 +97,1 @@\n-                    if (tool.cflag || tool.iflag  || tool.tflag || tool.uflag || tool.xflag)\n+                    if (tool.cflag || tool.iflag  || tool.tflag || tool.uflag || tool.xflag || tool.validate)\n@@ -102,0 +102,7 @@\n+            new Option(false, OptionType.MAIN_OPERATION, \"--validate\") {\n+                void process(Main tool, String opt, String arg) throws BadArgs {\n+                    if (tool.cflag || tool.iflag  || tool.tflag || tool.uflag || tool.xflag || tool.dflag)\n+                        throw new BadArgs(\"error.multiple.main.operations\").showUsage(true);\n+                    tool.validate = true;\n+                }\n+            },\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/GNUStyleOptions.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-    boolean cflag, uflag, xflag, tflag, vflag, flag0, Mflag, iflag, pflag, dflag;\n+    boolean cflag, uflag, xflag, tflag, vflag, flag0, Mflag, iflag, pflag, dflag, validate;\n@@ -196,1 +196,1 @@\n-            throw new Error(\"Error in message file\");\n+            throw new Error(\"Error in message file\", e);\n@@ -404,0 +404,11 @@\n+            } else if (validate) {\n+                File file;\n+                if (fname != null) {\n+                    file = new File(fname);\n+                } else {\n+                    file = createTemporaryFile(\"tmpJar\", \".jar\");\n+                    try (InputStream in = new FileInputStream(FileDescriptor.in)) {\n+                        Files.copy(in, file.toPath());\n+                    }\n+                }\n+                ok = validateJar(file);\n@@ -423,0 +434,9 @@\n+    private boolean validateJar(File file) throws IOException {\n+        try (ZipFile zf = new ZipFile(file)) {\n+            return Validator.validate(this, zf);\n+        } catch (IOException e) {\n+            error(formatMsg2(\"error.validator.jarfile.exception\", fname, e.getMessage()));\n+            return true;\n+        }\n+    }\n+\n@@ -425,7 +445,3 @@\n-            try (ZipFile zf = new ZipFile(tmpfile)) {\n-                ok = Validator.validate(this, zf);\n-                if (!ok) {\n-                    error(formatMsg(\"error.validator.jarfile.invalid\", fname));\n-                }\n-            } catch (IOException e) {\n-                error(formatMsg2(\"error.validator.jarfile.exception\", fname, e.getMessage()));\n+            ok = validateJar(tmpfile);\n+            if (!ok) {\n+                error(formatMsg(\"error.validator.jarfile.invalid\", fname));\n@@ -579,1 +595,1 @@\n-        if (!cflag && !tflag && !xflag && !uflag && !iflag && !dflag) {\n+        if (!cflag && !tflag && !xflag && !uflag && !iflag && !dflag && !validate) {\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":26,"deletions":10,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-        One of options -{ctxuid} must be specified.\n+        One of options -{ctxuid} or --validate must be specified.\n@@ -238,0 +238,5 @@\n+main.help.opt.main.validate=\\\n+\\      --validate             Validate the contents of the jar archive. This option\\n\\\n+\\                             will validate that the API exported by a multi-release\\n\\\n+\\                             jar archive is consistent across all different release\\n\\\n+\\                             versions.\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar.properties","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.io.PrintWriter;\n+import java.util.Locale;\n@@ -30,0 +32,1 @@\n+import javax.tools.FileObject;\n@@ -34,1 +37,24 @@\n- * This interface provides error, warning and notice reporting.\n+ * Interface for reporting diagnostics and other messages.\n+ *\n+ * <p>Diagnostics consist of a {@link Diagnostic.Kind diagnostic kind} and a message,\n+ * and may additionally be associated with an {@link Element element},\n+ * a {@link DocTreePath tree node} in a documentation comment,\n+ * or an arbitrary position in a given {@link FileObject file}.\n+ * Other messages may be written directly to one of two streams that are informally\n+ * for use by \"standard output\" and \"diagnostic output\", where \"standard output\"\n+ * means the output that is the expected result of executing some operation,\n+ * such as the command-line help that is generated when using a {@code --help} option,\n+ * and \"diagnostic output\" refers to any errors, warnings and other output that is\n+ * a side-effect of executing the operation.\n+ *\n+ * <p>The exact manner in which diagnostics are output is unspecified and depends\n+ * on the enclosing context. For example:\n+ * <ul>\n+ * <li>The {@link javax.tools.DocumentationTool} API allows a client to specify a\n+ * {@link javax.tools.DiagnosticListener} to which diagnostics will be\n+ * {@link javax.tools.DiagnosticListener#report reported}. If no listener is specified,\n+ * diagnostics will be written to a given stream, or to {@code System.err} if no such\n+ * stream is provided.\n+ * <li>The {@link java.util.spi.ToolProvider} API allows a client to specify\n+ * the streams to be used for reporting standard and diagnostic output.\n+ * <\/ul>\n@@ -41,1 +67,18 @@\n-     * Print error message and increment error count.\n+     * Prints a diagnostic message.\n+     *\n+     * @param kind    the kind of diagnostic\n+     * @param message the message to be printed\n+     *\/\n+    void print(Diagnostic.Kind kind, String message);\n+\n+    \/**\n+     * Prints a diagnostic message related to a tree node in a documentation comment.\n+     *\n+     * @param kind    the kind of diagnostic\n+     * @param path    the path for the tree node\n+     * @param message the message to be printed\n+     *\/\n+    void print(Diagnostic.Kind kind, DocTreePath path, String message);\n+\n+    \/**\n+     * Prints a diagnostic message related to an element.\n@@ -43,2 +86,3 @@\n-     * @param kind specify the diagnostic kind\n-     * @param msg message to print\n+     * @param kind    the kind of diagnostic\n+     * @param element the element\n+     * @param message the message to be printed\n@@ -46,1 +90,1 @@\n-    void print(Diagnostic.Kind kind, String msg);\n+    void print(Diagnostic.Kind kind, Element element, String message);\n@@ -49,1 +93,3 @@\n-     * Print an error message and increment error count.\n+     * Prints a diagnostic message related to a position within a range of characters in a file.\n+     * The positions are all 0-based character offsets from the beginning of content of the file.\n+     * The positions should satisfy the relation {@code start <= pos <= end}.\n@@ -51,3 +97,26 @@\n-     * @param kind specify the diagnostic kind\n-     * @param path the DocTreePath of item where the error occurs\n-     * @param msg message to print\n+     * @param kind    the kind of diagnostic\n+     * @param file    the file\n+     * @param start   the beginning of the enclosing range\n+     * @param pos     the position\n+     * @param end     the end of the enclosing range\n+     * @param message the message to be printed\n+     *\n+     * @since 17\n+     *\/\n+    void print(Diagnostic.Kind kind, FileObject file, int start, int pos, int end, String message);\n+\n+    \/**\n+     * Returns a writer that can be used to write non-diagnostic output,\n+     * or {@code null} if no such writer is available.\n+     *\n+     * @apiNote\n+     * The value may or may not be the same as that returned by {@link #getDiagnosticWriter()}.\n+     *\n+     * @implSpec\n+     * This implementation returns {@code null}.\n+     * The implementation provided by the {@code javadoc} tool to\n+     * {@link Doclet#init(Locale, Reporter) initialize} a doclet\n+     * always returns a non-{@code null} value.\n+     *\n+     * @return the writer\n+     * @since 17\n@@ -55,1 +124,3 @@\n-    void print(Diagnostic.Kind kind, DocTreePath path, String msg);\n+    default PrintWriter getStandardWriter() {\n+        return null;\n+    }\n@@ -58,1 +129,5 @@\n-     * Print an error message and increment error count.\n+     * Returns a writer that can be used to write diagnostic output,\n+     * or {@code null} if no such writer is available.\n+     *\n+     * @apiNote\n+     * The value may or may not be the same as that returned by {@link #getStandardWriter()}.\n@@ -60,3 +135,8 @@\n-     * @param kind specify the diagnostic kind\n-     * @param e the Element for which  the error occurs\n-     * @param msg message to print\n+     * @implSpec\n+     * This implementation returns {@code null}.\n+     * The implementation provided by the {@code javadoc} tool to\n+     * {@link Doclet#init(Locale, Reporter) initialize} a doclet\n+     * always returns a non-{@code null} value.\n+     *\n+     * @return the writer\n+     * @since 17\n@@ -64,1 +144,4 @@\n-    void print(Diagnostic.Kind kind, Element e, String msg);\n+    default PrintWriter getDiagnosticWriter() {\n+        return null;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/doclet\/Reporter.java","additions":99,"deletions":16,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-        String label = resources.getText(\"doclet.All_Classes\");\n+        String label = resources.getText(\"doclet.All_Classes_And_Interfaces\");\n@@ -134,1 +134,1 @@\n-        Content titleContent = contents.allClassesLabel;\n+        Content titleContent = contents.allClassesAndInterfacesLabel;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AllClassesIndexWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,2 +88,0 @@\n-    private static final Set<String> previewModifiers = Collections.emptySet();\n-\n@@ -200,19 +198,1 @@\n-    public void addClassSignature(String modifiers, Content classInfoTree) {\n-        ContentBuilder mods = new ContentBuilder();\n-        String sep = null;\n-        for (String modifiersPart : modifiers.split(\" \")) {\n-            if (sep != null) {\n-                mods.add(sep);\n-            }\n-            if (previewModifiers.contains(modifiersPart)) {\n-                mods.add(modifiersPart);\n-                mods.add(HtmlTree.SUP(links.createLink(htmlIds.forPreviewSection(typeElement),\n-                                                       contents.previewMark)));\n-            } else {\n-                mods.add(modifiersPart);\n-            }\n-            sep = \" \";\n-        }\n-        if (modifiers.endsWith(\" \")) {\n-            mods.add(\" \");\n-        }\n+    public void addClassSignature(Content classInfoTree) {\n@@ -221,1 +201,0 @@\n-                .setModifiers(mods)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassWriterImpl.java","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-    public final Content allClassesLabel;\n@@ -145,0 +144,2 @@\n+    public final Content newAPI;\n+    public final Content newLabel;\n@@ -199,1 +200,0 @@\n-        allClassesLabel = getNonBreakResource(\"doclet.All_Classes\");\n@@ -290,0 +290,2 @@\n+        newAPI = getContent(\"doclet.New_API\");\n+        newLabel = getContent(\"doclet.New_Label\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Contents.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.ListIterator;\n@@ -32,0 +33,2 @@\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n@@ -48,2 +51,0 @@\n- *\n- * @see java.util.List\n@@ -53,0 +54,2 @@\n+    private final static String TERMINALLY_DEPRECATED_KEY = \"doclet.Terminally_Deprecated_Elements\";\n+\n@@ -59,1 +62,0 @@\n-\n@@ -83,0 +85,4 @@\n+        if (list.releases.size() > 1) {\n+            content.add(HtmlTree.SPAN(contents.getContent(\"doclet.Deprecated_Tabs_Intro\"))\n+                    .addStyle(HtmlStyle.helpNote));\n+        }\n@@ -84,1 +90,1 @@\n-                    \"doclet.For_Removal\", \"doclet.Element\", content);\n+                    TERMINALLY_DEPRECATED_KEY, \"doclet.Element\", content);\n@@ -90,1 +96,1 @@\n-            addIndexLink(HtmlIds.FOR_REMOVAL, \"doclet.For_Removal\", target);\n+            addIndexLink(HtmlIds.FOR_REMOVAL, \"doclet.Terminally_Deprecated\", target);\n@@ -94,0 +100,1 @@\n+    @Override\n@@ -103,0 +110,24 @@\n+    @Override\n+    protected void addTableTabs(Table table, String headingKey) {\n+        List<String> releases = configuration.deprecatedAPIListBuilder.releases;\n+        if (!releases.isEmpty()) {\n+            table.setDefaultTab(getTableCaption(headingKey)).setAlwaysShowDefaultTab(true);\n+            ListIterator<String> it = releases.listIterator(releases.size());\n+            while (it.hasPrevious()) {\n+                String release = it.previous();\n+                Content tab = TERMINALLY_DEPRECATED_KEY.equals(headingKey)\n+                        ? contents.getContent(\"doclet.Terminally_Deprecated_In_Release\", release)\n+                        : contents.getContent(\"doclet.Deprecated_In_Release\", release);\n+                table.addTab(tab,\n+                        element -> release.equals(utils.getDeprecatedSince(element)));\n+            }\n+            getMainBodyScript().append(table.getScript());\n+        }\n+    }\n+\n+    @Override\n+    protected Content getTableCaption(String headingKey) {\n+        Content caption = contents.getContent(headingKey);\n+        return TERMINALLY_DEPRECATED_KEY.equals(headingKey)\n+                ? caption : contents.getContent(\"doclet.Deprecated_Elements\", caption);\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/DeprecatedListWriter.java","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-        allClassesLink = links.createLink(DocPaths.ALLCLASSES_INDEX, resources.getText(\"doclet.All_Classes\"));\n+        allClassesLink = links.createLink(DocPaths.ALLCLASSES_INDEX, resources.getText(\"doclet.All_Classes_And_Interfaces\"));\n@@ -349,9 +349,0 @@\n-        \/\/ Deprecated\n-        if (configuration.conditionalPages.contains(HtmlConfiguration.ConditionalPage.DEPRECATED)) {\n-            section = newHelpSection(contents.deprecatedAPI, PageMode.DEPRECATED, subTOC);\n-            Content deprBody = getContent(\"doclet.help.deprecated.body\",\n-                    links.createLink(DocPaths.DEPRECATED_LIST, resources.getText(\"doclet.Deprecated_API\")));\n-            section.add(HtmlTree.P(deprBody));\n-            pageKindsSection.add(section);\n-        }\n-\n@@ -367,0 +358,18 @@\n+        \/\/ New\n+        if (configuration.conditionalPages.contains(HtmlConfiguration.ConditionalPage.NEW)) {\n+            section = newHelpSection(contents.newAPI, PageMode.NEW, subTOC);\n+            Content newBody = getContent(\"doclet.help.new.body\",\n+                    links.createLink(DocPaths.NEW_LIST, contents.newAPI));\n+            section.add(HtmlTree.P(newBody));\n+            pageKindsSection.add(section);\n+        }\n+\n+        \/\/ Deprecated\n+        if (configuration.conditionalPages.contains(HtmlConfiguration.ConditionalPage.DEPRECATED)) {\n+            section = newHelpSection(contents.deprecatedAPI, PageMode.DEPRECATED, subTOC);\n+            Content deprBody = getContent(\"doclet.help.deprecated.body\",\n+                    links.createLink(DocPaths.DEPRECATED_LIST, resources.getText(\"doclet.Deprecated_API\")));\n+            section.add(HtmlTree.P(deprBody));\n+            pageKindsSection.add(section);\n+        }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HelpWriter.java","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.NewAPIBuilder;\n@@ -131,0 +132,8 @@\n+    \/**\n+     * The collection of new API items, if any, to be displayed on the new-list page,\n+     * or null if the page should not be generated.\n+     * The page is only generated if the {@code --since} option is used with release\n+     * names matching {@code @since} tags in the documented code.\n+     *\/\n+    protected NewAPIBuilder newAPIPageBuilder;\n+\n@@ -149,1 +158,1 @@\n-        CONSTANT_VALUES, DEPRECATED, PREVIEW, SERIALIZED_FORM, SYSTEM_PROPERTIES\n+        CONSTANT_VALUES, DEPRECATED, PREVIEW, SERIALIZED_FORM, SYSTEM_PROPERTIES, NEW\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlConfiguration.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.NewAPIBuilder;\n@@ -176,1 +177,1 @@\n-\n+        List<String> since = configuration.getOptions().since();\n@@ -179,3 +180,3 @@\n-            DeprecatedAPIListBuilder builder = new DeprecatedAPIListBuilder(configuration);\n-            if (!builder.isEmpty()) {\n-                configuration.deprecatedAPIListBuilder = builder;\n+            DeprecatedAPIListBuilder deprecatedBuilder = new DeprecatedAPIListBuilder(configuration, since);\n+            if (!deprecatedBuilder.isEmpty()) {\n+                configuration.deprecatedAPIListBuilder = deprecatedBuilder;\n@@ -185,3 +186,10 @@\n-        PreviewAPIListBuilder builder = new PreviewAPIListBuilder(configuration);\n-        if (!builder.isEmpty()) {\n-            configuration.previewAPIListBuilder = builder;\n+        if (!since.isEmpty()) {\n+            NewAPIBuilder newAPIBuilder = new NewAPIBuilder(configuration, since);\n+            if (!newAPIBuilder.isEmpty()) {\n+                configuration.newAPIPageBuilder = newAPIBuilder;\n+                configuration.conditionalPages.add(HtmlConfiguration.ConditionalPage.NEW);\n+            }\n+        }\n+        PreviewAPIListBuilder previewBuilder = new PreviewAPIListBuilder(configuration);\n+        if (!previewBuilder.isEmpty()) {\n+            configuration.previewAPIListBuilder = previewBuilder;\n@@ -242,0 +250,4 @@\n+        if (configuration.conditionalPages.contains((HtmlConfiguration.ConditionalPage.NEW))) {\n+            NewAPIListWriter.generate(configuration);\n+        }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2106,1 +2106,2 @@\n-                .replaceAll(\"^(Module|Package|Class)$\", \"$1Declaration\");\n+                .replaceAll(\"^(Module|Package|Class)$\", \"$1Declaration\")\n+                .replace(\"API\", \"Api\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-                resources.getText(\"doclet.All_Classes\"),\n+                resources.getText(\"doclet.All_Classes_And_Interfaces\"),\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlIndexBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -112,19 +112,0 @@\n-    @Override\n-    public void addMemberHeader(TypeElement fieldType, String fieldTypeStr,\n-            String fieldDimensions, String fieldName, Content contentTree) {\n-        Content nameContent = Text.of(fieldName);\n-        Content heading = HtmlTree.HEADING(Headings.SerializedForm.MEMBER_HEADING, nameContent);\n-        contentTree.add(heading);\n-        Content pre = new HtmlTree(TagName.PRE);\n-        if (fieldType == null) {\n-            pre.add(fieldTypeStr);\n-        } else {\n-            Content fieldContent = writer.getLink(new HtmlLinkInfo(\n-                    configuration, HtmlLinkInfo.Kind.SERIAL_MEMBER, fieldType));\n-            pre.add(fieldContent);\n-        }\n-        pre.add(fieldDimensions + \" \");\n-        pre.add(fieldName);\n-        contentTree.add(pre);\n-    }\n-\n@@ -134,1 +115,1 @@\n-        Content heading = HtmlTree.HEADING(TagName.H5, nameContent);\n+        Content heading = HtmlTree.HEADING(Headings.SerializedForm.MEMBER_HEADING, nameContent);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlSerialFieldWriter.java","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+        NEW,\n@@ -174,1 +175,0 @@\n-                addDeprecatedLink(tree);\n@@ -176,0 +176,2 @@\n+                addNewLink(tree);\n+                addDeprecatedLink(tree);\n@@ -186,1 +188,0 @@\n-                addDeprecatedLink(tree);\n@@ -188,0 +189,2 @@\n+                addNewLink(tree);\n+                addDeprecatedLink(tree);\n@@ -204,1 +207,0 @@\n-                addDeprecatedLink(tree);\n@@ -206,0 +208,2 @@\n+                addNewLink(tree);\n+                addDeprecatedLink(tree);\n@@ -222,1 +226,0 @@\n-                addDeprecatedLink(tree);\n@@ -224,0 +227,2 @@\n+                addNewLink(tree);\n+                addDeprecatedLink(tree);\n@@ -245,1 +250,0 @@\n-                addDeprecatedLink(tree);\n@@ -247,0 +251,2 @@\n+                addNewLink(tree);\n+                addDeprecatedLink(tree);\n@@ -262,1 +268,0 @@\n-                addDeprecatedLink(tree);\n@@ -264,0 +269,2 @@\n+                addNewLink(tree);\n+                addDeprecatedLink(tree);\n@@ -271,0 +278,1 @@\n+            case NEW:\n@@ -277,6 +285,0 @@\n-                if (documentedPage == PageMode.DEPRECATED) {\n-                    addActivePageLink(tree, contents.deprecatedLabel,\n-                            configuration.conditionalPages.contains(HtmlConfiguration.ConditionalPage.DEPRECATED));\n-                } else {\n-                    addDeprecatedLink(tree);\n-                }\n@@ -289,0 +291,12 @@\n+                if (documentedPage == PageMode.NEW) {\n+                    addActivePageLink(tree, contents.newLabel,\n+                            configuration.conditionalPages.contains(HtmlConfiguration.ConditionalPage.NEW));\n+                } else {\n+                    addNewLink(tree);\n+                }\n+                if (documentedPage == PageMode.DEPRECATED) {\n+                    addActivePageLink(tree, contents.deprecatedLabel,\n+                            configuration.conditionalPages.contains(HtmlConfiguration.ConditionalPage.DEPRECATED));\n+                } else {\n+                    addDeprecatedLink(tree);\n+                }\n@@ -311,1 +325,0 @@\n-                addDeprecatedLink(tree);\n@@ -313,0 +326,2 @@\n+                addNewLink(tree);\n+                addDeprecatedLink(tree);\n@@ -323,1 +338,0 @@\n-                addDeprecatedLink(tree);\n@@ -325,0 +339,2 @@\n+                addNewLink(tree);\n+                addDeprecatedLink(tree);\n@@ -534,0 +550,7 @@\n+    private void addNewLink(Content tree) {\n+        if (configuration.conditionalPages.contains(HtmlConfiguration.ConditionalPage.NEW)) {\n+            tree.add(HtmlTree.LI(links.createLink(pathToRoot.resolve(DocPaths.NEW_LIST),\n+                    contents.newLabel, \"\")));\n+        }\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Navigation.java","additions":37,"deletions":14,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n+import jdk.javadoc.internal.doclets.toolkit.util.NewAPIBuilder;\n+\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import static com.sun.source.doctree.DocTree.Kind.SINCE;\n+\n+\/**\n+ * Generates a file containing a list of new API elements with the appropriate links.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\n+ *\/\n+public class NewAPIListWriter extends SummaryListWriter<NewAPIBuilder> {\n+\n+    \/**\n+     * Constructor.\n+     *\n+     * @param configuration the configuration for this doclet\n+     *\/\n+    public NewAPIListWriter(NewAPIBuilder builder, HtmlConfiguration configuration, DocPath filename) {\n+        super(configuration, filename, PageMode.NEW, \"new elements\",\n+                Text.of(getHeading(builder, configuration)),\n+                \"doclet.Window_New_List\");\n+    }\n+\n+    \/**\n+     * If the \"New API\" page is configured this method instantiates a NewAPIListWriter\n+     * and generates the file.\n+     *\n+     * @param configuration the current configuration of the doclet.\n+     * @throws DocFileIOException if there is a problem writing the new API list\n+     *\/\n+    public static void generate(HtmlConfiguration configuration) throws DocFileIOException {\n+        if (configuration.conditionalPages.contains(HtmlConfiguration.ConditionalPage.NEW)) {\n+            NewAPIBuilder builder = configuration.newAPIPageBuilder;\n+            NewAPIListWriter writer = new NewAPIListWriter(builder, configuration, DocPaths.NEW_LIST);\n+            writer.generateSummaryListFile(builder);\n+        }\n+    }\n+\n+    @Override\n+    protected void addExtraSection(NewAPIBuilder list, Content content) {\n+        if (list.releases.size() > 1) {\n+            content.add(HtmlTree.SPAN(contents.getContent(\"doclet.New_Tabs_Intro\"))\n+                    .addStyle(HtmlStyle.helpNote));\n+        }\n+    }\n+\n+    @Override\n+    protected void addTableTabs(Table table, String headingKey) {\n+        List<String> releases = configuration.newAPIPageBuilder.releases;\n+        if (!releases.isEmpty()) {\n+            table.setDefaultTab(getTableCaption(headingKey)).setAlwaysShowDefaultTab(true);\n+            ListIterator<String> it = releases.listIterator(releases.size());\n+            while (it.hasPrevious()) {\n+                String release = it.previous();\n+                table.addTab(\n+                        releases.size() == 1\n+                                ? getTableCaption(headingKey)\n+                                : contents.getContent(\n+                                        \"doclet.New_Elements_Added_In_Release\", release),\n+                        element -> {\n+                            if (!utils.hasDocCommentTree(element)) {\n+                                return false;\n+                            }\n+                            List<? extends DocTree> since = utils.getBlockTags(element, SINCE);\n+                            if (since.isEmpty()) {\n+                                return false;\n+                            }\n+                            CommentHelper ch = utils.getCommentHelper(element);\n+                            return since.stream().anyMatch(tree -> release.equals(ch.getBody(tree).toString()));\n+                        });\n+            }\n+            getMainBodyScript().append(table.getScript());\n+        }\n+    }\n+\n+    @Override\n+    protected void addComments(Element e, Content desc) {\n+        addSummaryComment(e, desc);\n+    }\n+\n+    @Override\n+    protected Content getTableCaption(String headingKey) {\n+        return contents.getContent(\"doclet.New_Elements\", super.getTableCaption(headingKey));\n+    }\n+\n+    private static String getHeading(NewAPIBuilder builder, HtmlConfiguration configuration) {\n+        String label = configuration.getOptions().sinceLabel();\n+        return label == null ? configuration.docResources.getText(\"doclet.New_API\") : label;\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/NewAPIListWriter.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -78,2 +78,1 @@\n-            depr.generateSummaryListFile(\n-                   new PreviewAPIListBuilder(configuration));\n+            depr.generateSummaryListFile(configuration.previewAPIListBuilder);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PreviewListWriter.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import javax.lang.model.element.ElementKind;\n@@ -46,0 +47,3 @@\n+import javax.lang.model.util.ElementKindVisitor14;\n+import java.util.ArrayList;\n+import java.util.Collections;\n@@ -48,0 +52,1 @@\n+import java.util.SortedSet;\n@@ -52,0 +57,1 @@\n+import static javax.lang.model.element.Modifier.FINAL;\n@@ -53,0 +59,2 @@\n+import static javax.lang.model.element.Modifier.PRIVATE;\n+import static javax.lang.model.element.Modifier.PROTECTED;\n@@ -54,0 +62,1 @@\n+import static javax.lang.model.element.Modifier.STATIC;\n@@ -95,1 +104,1 @@\n-        private final ClassWriterImpl classWriter;\n+        private final HtmlDocletWriter writer;\n@@ -100,6 +109,9 @@\n-        TypeSignature(TypeElement typeElement, ClassWriterImpl classWriter) {\n-            this.typeElement = typeElement;\n-            this.classWriter = classWriter;\n-            this.utils = classWriter.utils;\n-            this.configuration = classWriter.configuration;\n-        }\n+        private static final Set<String> previewModifiers = Collections.emptySet();\n+\n+         TypeSignature(TypeElement typeElement, HtmlDocletWriter writer) {\n+             this.typeElement = typeElement;\n+             this.writer = writer;\n+             this.utils = writer.utils;\n+             this.configuration = writer.configuration;\n+             this.modifiers = markPreviewModifiers(getModifiers());\n+         }\n@@ -114,1 +126,1 @@\n-            Content annotationInfo = classWriter.getAnnotationInfo(typeElement, true);\n+            Content annotationInfo = writer.getAnnotationInfo(typeElement, true);\n@@ -122,2 +134,2 @@\n-            if (classWriter.options.linkSource()) {\n-                classWriter.addSrcLink(typeElement, className, nameSpan);\n+            if (configuration.getOptions().linkSource()) {\n+                writer.addSrcLink(typeElement, className, nameSpan);\n@@ -131,1 +143,1 @@\n-            nameSpan.add(classWriter.getTypeParameterLinks(linkInfo));\n+            nameSpan.add(writer.getTypeParameterLinks(linkInfo));\n@@ -145,1 +157,1 @@\n-                        Content link = classWriter.getLink(new HtmlLinkInfo(configuration,\n+                        Content link = writer.getLink(new HtmlLinkInfo(configuration,\n@@ -166,1 +178,1 @@\n-                        Content link = classWriter.getLink(new HtmlLinkInfo(configuration,\n+                        Content link = writer.getLink(new HtmlLinkInfo(configuration,\n@@ -192,1 +204,1 @@\n-                    Content link = classWriter.getLink(new HtmlLinkInfo(configuration,\n+                    Content link = writer.getLink(new HtmlLinkInfo(configuration,\n@@ -198,1 +210,1 @@\n-                    Content c = Text.of(classWriter.resources.getText(\"doclet.not.exhaustive\"));\n+                    Content c = Text.of(configuration.getDocResources().getText(\"doclet.not.exhaustive\"));\n@@ -213,1 +225,1 @@\n-                classWriter.getAnnotations(e.getAnnotationMirrors(), false)\n+                writer.getAnnotations(e.getAnnotationMirrors(), false)\n@@ -215,1 +227,1 @@\n-                Content link = classWriter.getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.RECORD_COMPONENT,\n+                Content link = writer.getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.RECORD_COMPONENT,\n@@ -225,0 +237,106 @@\n+\n+        private Content markPreviewModifiers(List<String> modifiers) {\n+             Content content = new ContentBuilder();\n+             String sep = null;\n+             for (String modifier : modifiers) {\n+                 if (sep != null) {\n+                    content.add(sep);\n+                 }\n+                 content.add(modifier);\n+                 if (previewModifiers.contains(modifier)) {\n+                     content.add(HtmlTree.SUP(writer.links.createLink(\n+                             configuration.htmlIds.forPreviewSection(typeElement),\n+                             configuration.contents.previewMark)));\n+                 }\n+                 sep = \" \";\n+             }\n+             content.add(\" \");\n+             return content;\n+        }\n+\n+        private List<String> getModifiers() {\n+            SortedSet<Modifier> modifiers = new TreeSet<>(typeElement.getModifiers());\n+            modifiers.remove(NATIVE);\n+            modifiers.remove(STRICTFP);\n+            modifiers.remove(SYNCHRONIZED);\n+\n+            return new ElementKindVisitor14<List<String>, SortedSet<Modifier>>() {\n+                final List<String> list = new ArrayList<>();\n+\n+                void addVisibilityModifier(Set<Modifier> modifiers) {\n+                    if (modifiers.contains(PUBLIC)) {\n+                        list.add(\"public\");\n+                    } else if (modifiers.contains(PROTECTED)) {\n+                        list.add(\"protected\");\n+                    } else if (modifiers.contains(PRIVATE)) {\n+                        list.add(\"private\");\n+                    }\n+                }\n+\n+                void addStatic(Set<Modifier> modifiers) {\n+                    if (modifiers.contains(STATIC)) {\n+                        list.add(\"static\");\n+                    }\n+                }\n+\n+                void addSealed(TypeElement e) {\n+                    if (e.getModifiers().contains(Modifier.SEALED)) {\n+                        list.add(\"sealed\");\n+                    } else if (e.getModifiers().contains(Modifier.NON_SEALED)) {\n+                        list.add(\"non-sealed\");\n+                    }\n+                }\n+\n+                void addModifiers(Set<Modifier> modifiers) {\n+                    modifiers.stream()\n+                            .map(Modifier::toString)\n+                            .forEachOrdered(list::add);\n+                }\n+\n+                @Override\n+                public List<String> visitTypeAsInterface(TypeElement e, SortedSet<Modifier> mods) {\n+                    addVisibilityModifier(mods);\n+                    addStatic(mods);\n+                    addSealed(e);\n+                    list.add(\"interface\");\n+                    return list;\n+                }\n+\n+                @Override\n+                public List<String> visitTypeAsEnum(TypeElement e, SortedSet<Modifier> mods) {\n+                    addVisibilityModifier(mods);\n+                    addStatic(mods);\n+                    list.add(\"enum\");\n+                    return list;\n+                }\n+\n+                @Override\n+                public List<String> visitTypeAsAnnotationType(TypeElement e, SortedSet<Modifier> mods) {\n+                    addVisibilityModifier(mods);\n+                    addStatic(mods);\n+                    list.add(\"@interface\");\n+                    return list;\n+                }\n+\n+                @Override\n+                public List<String> visitTypeAsRecord(TypeElement e, SortedSet<Modifier> mods) {\n+                    mods.remove(FINAL); \/\/ suppress the implicit `final`\n+                    return visitTypeAsClass(e, mods);\n+                }\n+\n+                @Override\n+                public List<String> visitTypeAsClass(TypeElement e, SortedSet<Modifier> mods) {\n+                    addModifiers(mods);\n+                    String keyword = e.getKind() == ElementKind.RECORD ? \"record\" : \"class\";\n+                    list.add(keyword);\n+                    return list;\n+                }\n+\n+                @Override\n+                protected List<String> defaultAction(Element e, SortedSet<Modifier> mods) {\n+                    addModifiers(mods);\n+                    return list;\n+                }\n+\n+            }.visit(typeElement, modifiers);\n+        }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Signatures.java","additions":135,"deletions":17,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-public abstract class SummaryListWriter<L extends SummaryAPIListBuilder> extends SubWriterHolderWriter {\n+public class SummaryListWriter<L extends SummaryAPIListBuilder> extends SubWriterHolderWriter {\n@@ -211,1 +211,0 @@\n-            Content caption = contents.getContent(headingKey);\n@@ -213,1 +212,1 @@\n-                    .setCaption(caption)\n+                    .setCaption(getTableCaption(headingKey))\n@@ -217,0 +216,1 @@\n+            addTableTabs(table, headingKey);\n@@ -233,1 +233,1 @@\n-                table.addRow(link, desc);\n+                table.addRow(e, link, desc);\n@@ -246,1 +246,2 @@\n-    protected abstract void addComments(Element e, Content desc);\n+    protected void addComments(Element e, Content desc) {\n+    }\n@@ -280,0 +281,18 @@\n+\n+    \/**\n+     * Returns the caption for the table with the given {@code headingKey}.\n+     *\n+     * @param headingKey the key for the table heading\n+     * @return the table caption\n+     *\/\n+    protected Content getTableCaption(String headingKey) {\n+        return contents.getContent(headingKey);\n+    }\n+\n+    \/**\n+     * Allow subclasses to add extra tabs to the element tables.\n+     *\n+     * @param table the element table\n+     * @param headingKey the key for the caption (default tab)\n+     *\/\n+    protected void addTableTabs(Table table, String headingKey) {}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SummaryListWriter.java","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+    private boolean alwaysShowDefaultTab = false;\n@@ -145,0 +146,10 @@\n+    \/**\n+     * Sets whether to display the default tab even if tabs are empty or only contain a single tab.\n+     * @param showDefaultTab true if default tab should always be shown\n+     * @return this object\n+     *\/\n+    public Table setAlwaysShowDefaultTab(boolean showDefaultTab) {\n+        this.alwaysShowDefaultTab = showDefaultTab;\n+        return this;\n+    }\n+\n@@ -379,1 +390,1 @@\n-        if (tabMap == null || tabs.size() == 1) {\n+        if ((tabMap == null || tabs.size() == 1) && !alwaysShowDefaultTab) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Table.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -722,0 +722,5 @@\n+    \/**\n+     * The class of the {@code body} element for the page listing any deprecated items.\n+     *\/\n+    deprecatedInReleasePage,\n+\n@@ -752,0 +757,5 @@\n+    \/**\n+     * The class of the {@code body} element for the page listing new API elements.\n+     *\/\n+    newApiListPage,\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/HtmlStyle.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+doclet.Window_New_List=New API List\n@@ -107,0 +108,15 @@\n+doclet.Deprecated_Elements=Deprecated {0}\n+doclet.Deprecated_In_Release=Deprecated in {0}\n+doclet.Deprecated_Tabs_Intro=(The leftmost tab \"Deprecated ...\" indicates all the \\\n+    deprecated elements, regardless of the releases in which they were deprecated. \\\n+    Each of the other tabs \"Deprecated in ...\" indicates the elements deprecated \\\n+    in a specific release.)\n+doclet.New_API=New API\n+doclet.New_Elements=New {0}\n+doclet.New_Elements_Added_In_Release=Added in {0}\n+doclet.New_Label=New\n+doclet.New_Tabs_Intro=(The leftmost tab \"New ...\" indicates all the new elements, \\\n+    regardless of the releases in which they were added. Each of the other tabs \\\n+    \"Added in ...\" indicates the new elements added in a specific release. \\\n+    Any element shown under the leftmost tab is also shown under one of the \\\n+    righthand tabs.)\n@@ -110,1 +126,3 @@\n-doclet.For_Removal=For Removal\n+doclet.Terminally_Deprecated=Terminally Deprecated\n+doclet.Terminally_Deprecated_Elements=Terminally Deprecated Elements\n+doclet.Terminally_Deprecated_In_Release=Terminally Deprecated in {0}\n@@ -248,0 +266,2 @@\n+doclet.help.new.body=\\\n+    The {0} page lists APIs that have been added in recent releases.\n@@ -255,1 +275,1 @@\n-    All Classes\n+    All Classes and Interfaces\n@@ -499,0 +519,10 @@\n+doclet.usage.since.parameters=\\\n+    <release>(,<release>)*\n+doclet.usage.since.description=\\\n+    Document new and deprecated API in the specified releases\n+\n+doclet.usage.since-label.parameters=\\\n+    <text>\n+doclet.usage.since-label.description=\\\n+    Provide text to use in the heading of the \"New API\" page\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":32,"deletions":2,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.Collections;\n@@ -251,0 +252,12 @@\n+    \/**\n+     * Argument for command line option {@code --since}.\n+     * Specifies a list of release names for which to document API changes.\n+     *\/\n+    private List<String> since = List.of();\n+\n+    \/**\n+     * Argument for command line option {@code --since-label}.\n+     * Specifies custom text to use as heading of New API page.\n+     *\/\n+    private String sinceLabel;\n+\n@@ -479,0 +492,16 @@\n+                new Option(resources, \"--since\", 1) {\n+                    @Override\n+                    public boolean process(String opt, List<String> args) {\n+                        since = Arrays.stream(args.get(0).split(\",\")).map(String::trim).toList();\n+                        return true;\n+                    }\n+                },\n+\n+                new Option(resources, \"--since-label\", 1) {\n+                    @Override\n+                    public boolean process(String opt, List<String> args) {\n+                        sinceLabel = args.get(0);\n+                        return true;\n+                    }\n+                },\n+\n@@ -895,0 +924,14 @@\n+    \/**\n+     * Arguments for command line option {@code --since}.\n+     *\/\n+    public List<String> since() {\n+        return Collections.unmodifiableList(since);\n+    }\n+\n+    \/**\n+     * Arguments for command line option {@code --since-label}.\n+     *\/\n+    public String sinceLabel() {\n+        return sinceLabel;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseOptions.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -148,1 +148,0 @@\n-     * @param modifiers the modifiers for the signature\n@@ -151,1 +150,1 @@\n-    void addClassSignature(String modifiers, Content classInfoTree);\n+    void addClassSignature(Content classInfoTree);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/ClassWriter.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import javax.tools.FileObject;\n@@ -79,2 +80,2 @@\n-     * @param key the name of a resource containing the message to be printed\n-     * @param args optional arguments to be replaced in the message.\n+     * @param key  the name of a resource containing the message to be printed\n+     * @param args optional arguments to be replaced in the message\n@@ -89,4 +90,3 @@\n-     * @param path a path identifying the position to be included with\n-     *  the message\n-     * @param key the name of a resource containing the message to be printed\n-     * @param args optional arguments to be replaced in the message.\n+     * @param path a path identifying the position to be included with the message\n+     * @param key  the name of a resource containing the message to be printed\n+     * @param args optional arguments to be replaced in the message\n@@ -98,0 +98,14 @@\n+    \/**\n+     * Reports an error message to the doclet's reporter.\n+     *\n+     * @param fo    the file object to be associated with the message\n+     * @param start the start of a range of characters to be associated with the message\n+     * @param pos   the position to be associated with the message\n+     * @param end   the end of a range of characters to be associated with the message\n+     * @param key   the name of a resource containing the message to be printed\n+     * @param args  optional arguments to be replaced in the message\n+     *\/\n+    public void error(FileObject fo, int start, int pos, int end, String key, Object... args) {\n+        report(ERROR, fo, start, pos, end, resources.getText(key, args));\n+    }\n+\n@@ -103,2 +117,2 @@\n-     * @param key the name of a resource containing the message to be printed\n-     * @param args optional arguments to be replaced in the message.\n+     * @param key  the name of a resource containing the message to be printed\n+     * @param args optional arguments to be replaced in the message\n@@ -113,4 +127,3 @@\n-     * @param path a path identifying the position to be included with\n-     *  the message\n-     * @param key the name of a resource containing the message to be printed\n-     * @param args optional arguments to be replaced in the message.\n+     * @param path a path identifying the position to be included with the message\n+     * @param key  the name of a resource containing the message to be printed\n+     * @param args optional arguments to be replaced in the message\n@@ -127,4 +140,3 @@\n-     * @param e an element identifying the declaration whose position should\n-     *  to be included with the message\n-     * @param key the name of a resource containing the message to be printed\n-     * @param args optional arguments to be replaced in the message.\n+     * @param e    an element identifying the position to be included with the message\n+     * @param key  the name of a resource containing the message to be printed\n+     * @param args optional arguments to be replaced in the message\n@@ -138,0 +150,14 @@\n+    \/**\n+     * Reports a warning message to the doclet's reporter.\n+     *\n+     * @param fo    the file object to be associated with the message\n+     * @param start the start of a range of characters to be associated with the message\n+     * @param pos   the position to be associated with the message\n+     * @param end   the end of a range of characters to be associated with the message\n+     * @param key   the name of a resource containing the message to be printed\n+     * @param args  optional arguments to be replaced in the message\n+     *\/\n+    public void warning(FileObject fo, int start, int pos, int end, String key, Object... args) {\n+        report(WARNING, fo, start, pos, end, resources.getText(key, args));\n+    }\n+\n@@ -142,0 +168,1 @@\n+     * The message is written directly to the reporter's diagnostic stream.\n@@ -143,2 +170,2 @@\n-     * @param key the name of a resource containing the message to be printed\n-     * @param args optional arguments to be replaced in the message.\n+     * @param key  the name of a resource containing the message to be printed\n+     * @param args optional arguments to be replaced in the message\n@@ -148,1 +175,2 @@\n-            report(NOTE, resources.getText(key, args));\n+            \/\/ Note: we do not use report(NOTE, ...) which would prefix the output with \"Note:\"\n+            reporter.getDiagnosticWriter().println(resources.getText(key, args));\n@@ -165,0 +193,4 @@\n+\n+    private void report(Diagnostic.Kind k, FileObject fo, int start, int pos, int end, String msg) {\n+        reporter.print(k, fo, start, pos, end, msg);\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/Messages.java","additions":52,"deletions":20,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -230,13 +230,0 @@\n-        \/**\n-         * Adds the member header.\n-         *\n-         * @param fieldType the type of the field\n-         * @param fieldTypeStr the type of the field in string format, used\n-         *                     only if the type cannot be linked\n-         * @param fieldDimensions the dimensions of the field\n-         * @param fieldName the name of the field\n-         * @param contentTree content tree to which the member header will be added\n-         *\/\n-        void addMemberHeader(TypeElement fieldType, String fieldTypeStr, String fieldDimensions,\n-                             String fieldName, Content contentTree);\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/SerializedFormWriter.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -202,12 +202,0 @@\n-\n-    \/\/ TODO: The following should be replaced by a new method such as Elements.isAutomaticModule\n-    \/\/ see JDK-8261625\n-    public boolean isAutomaticModule(ModuleElement me) {\n-        if (me == null) {\n-            return false;\n-        } else {\n-            ModuleSymbol msym = (ModuleSymbol) me;\n-            return (msym.flags() & Flags.AUTOMATIC_MODULE) != 0;\n-        }\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/WorkArounds.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-        writer.addClassSignature(utils.modifiersToString(typeElement, true), classInfoTree);\n+        writer.addClassSignature(classInfoTree);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/ClassBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import javax.lang.model.type.TypeMirror;\n@@ -481,16 +482,2 @@\n-            TypeElement te = ch.getReferencedClass(tag);\n-            String fieldType = ch.getReferencedMemberName(tag);\n-            if (te != null && utils.isPrimitive(te.asType())) {\n-                fieldType = utils.getTypeName(te.asType(), false);\n-                te = null;\n-            }\n-            String refSignature = ch.getReferencedSignature(tag);\n-            \/\/ TODO: Print the signature directly, if it is an array, the\n-            \/\/ current DocTree APIs makes it very hard to distinguish\n-            \/\/ an as these are returned back as \"Array\" a DeclaredType.\n-            if (refSignature != null && refSignature.endsWith(\"[]\")) {\n-                te = null;\n-                fieldType = refSignature;\n-            }\n-            fieldWriter.addMemberHeader(te, fieldType, \"\",\n-                    tag.getName().getName().toString(), fieldsContentTree);\n+            TypeMirror type = ch.getReferencedType(tag);\n+            fieldWriter.addMemberHeader(type, tag.getName().getName().toString(), fieldsContentTree);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/SerializedFormBuilder.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -143,1 +143,0 @@\n-doclet.All_Classes=All Classes\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+\n@@ -44,0 +45,1 @@\n+    public final List<String> releases;\n@@ -49,0 +51,1 @@\n+     * @param releases list of releases\n@@ -50,1 +53,1 @@\n-    public DeprecatedAPIListBuilder(BaseConfiguration configuration) {\n+    public DeprecatedAPIListBuilder(BaseConfiguration configuration, List<String> releases) {\n@@ -52,0 +55,2 @@\n+        this.releases = releases;\n+        buildSummaryAPIInfo();\n@@ -67,1 +72,0 @@\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DeprecatedAPIListBuilder.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-    \/** The name of the fie for preview elements. *\/\n+    \/** The name of the file for preview elements. *\/\n@@ -148,0 +148,3 @@\n+    \/** The name of the file for new elements. *\/\n+    public static final DocPath NEW_LIST = DocPath.create(\"new-list.html\");\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocPaths.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -575,1 +575,1 @@\n-                if (!configuration.workArounds.isAutomaticModule(me) && issueWarning) {\n+                if (!utils.elementUtils.isAutomaticModule(me) && issueWarning) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Extern.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.util;\n+\n+import com.sun.source.doctree.DocTree;\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n+\n+import javax.lang.model.element.Element;\n+import java.util.List;\n+\n+\n+import static com.sun.source.doctree.DocTree.Kind.SINCE;\n+\n+\/**\n+ * Build list of all the packages, classes, constructors, fields and methods\n+ * that were added in one of the releases specified by the {@code --since}\n+ * option. The release names must exactly match the names used in the javadoc\n+ * {@code @since} tags of the respective elements.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class NewAPIBuilder extends SummaryAPIListBuilder {\n+\n+    public final List<String> releases;\n+\n+    public NewAPIBuilder(BaseConfiguration configuration, List<String> releases) {\n+        super(configuration, element -> isNewAPI(element, configuration.utils, releases));\n+        this.releases = releases;\n+        buildSummaryAPIInfo();\n+    }\n+\n+    private static boolean isNewAPI(Element e, Utils utils, List<String> releases) {\n+        if (!utils.hasDocCommentTree(e)) {\n+            return false;\n+        }\n+        List<? extends DocTree> since = utils.getBlockTags(e, SINCE);\n+        if (since.isEmpty()) {\n+            return false;\n+        }\n+        CommentHelper ch = utils.getCommentHelper(e);\n+        return since.stream().anyMatch(tree -> releases.contains(ch.getBody(tree).toString()));\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/NewAPIBuilder.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -47,0 +47,1 @@\n+        buildSummaryAPIInfo();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/PreviewAPIListBuilder.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -87,1 +87,0 @@\n-        buildSummaryAPIInfo();\n@@ -99,1 +98,1 @@\n-    private void buildSummaryAPIInfo() {\n+    protected void buildSummaryAPIInfo() {\n@@ -105,0 +104,1 @@\n+                handleElement(me);\n@@ -106,1 +106,0 @@\n-            handleElement(me);\n@@ -113,0 +112,1 @@\n+                handleElement(pe);\n@@ -114,1 +114,0 @@\n-            handleElement(pe);\n@@ -148,0 +147,1 @@\n+                handleElement(te);\n@@ -149,1 +149,0 @@\n-            handleElement(te);\n@@ -187,0 +186,1 @@\n+                handleElement(member);\n@@ -188,1 +188,0 @@\n-            handleElement(member);\n@@ -212,1 +211,1 @@\n-     * Additional extra processing of an analyzed element.\n+     * Additional extra processing of an included element.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/SummaryAPIListBuilder.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.util.Arrays;\n@@ -84,1 +83,0 @@\n-import javax.lang.model.util.ElementKindVisitor14;\n@@ -130,1 +128,0 @@\n-import static javax.lang.model.element.Modifier.*;\n@@ -494,98 +491,0 @@\n-    public String modifiersToString(Element e, boolean trailingSpace) {\n-        SortedSet<Modifier> modifiers = new TreeSet<>(e.getModifiers());\n-        modifiers.remove(NATIVE);\n-        modifiers.remove(STRICTFP);\n-        modifiers.remove(SYNCHRONIZED);\n-\n-        return new ElementKindVisitor14<String, SortedSet<Modifier>>() {\n-            final StringBuilder sb = new StringBuilder();\n-\n-            void addVisibilityModifier(Set<Modifier> modifiers) {\n-                if (modifiers.contains(PUBLIC)) {\n-                    append(\"public\");\n-                } else if (modifiers.contains(PROTECTED)) {\n-                    append(\"protected\");\n-                } else if (modifiers.contains(PRIVATE)) {\n-                    append(\"private\");\n-                }\n-            }\n-\n-            void addStatic(Set<Modifier> modifiers) {\n-                if (modifiers.contains(STATIC)) {\n-                    append(\"static\");\n-                }\n-            }\n-\n-            void addSealed(TypeElement e) {\n-                if (e.getModifiers().contains(Modifier.SEALED)) {\n-                    append(\"sealed\");\n-                } else if (e.getModifiers().contains(Modifier.NON_SEALED)) {\n-                    append(\"non-sealed\");\n-                }\n-            }\n-\n-            void addModifiers(Set<Modifier> modifiers) {\n-                modifiers.stream()\n-                        .map(Modifier::toString)\n-                        .forEachOrdered(this::append);\n-            }\n-\n-            void append(String s) {\n-                if (sb.length() > 0) {\n-                    sb.append(\" \");\n-                }\n-                sb.append(s);\n-            }\n-\n-            String finalString(String s) {\n-                append(s);\n-                if (trailingSpace) {\n-                    sb.append(\" \");\n-                }\n-                return sb.toString();\n-            }\n-\n-            @Override\n-            public String visitTypeAsInterface(TypeElement e, SortedSet<Modifier> mods) {\n-                addVisibilityModifier(mods);\n-                addStatic(mods);\n-                addSealed(e);\n-                return finalString(\"interface\");\n-            }\n-\n-            @Override\n-            public String visitTypeAsEnum(TypeElement e, SortedSet<Modifier> mods) {\n-                addVisibilityModifier(mods);\n-                addStatic(mods);\n-                return finalString(\"enum\");\n-            }\n-\n-            @Override\n-            public String visitTypeAsAnnotationType(TypeElement e, SortedSet<Modifier> mods) {\n-                addVisibilityModifier(mods);\n-                addStatic(mods);\n-                return finalString(\"@interface\");\n-            }\n-\n-            @Override\n-            public String visitTypeAsRecord(TypeElement e, SortedSet<Modifier> mods) {\n-                mods.remove(FINAL); \/\/ suppress the implicit `final`\n-                return visitTypeAsClass(e, mods);\n-            }\n-\n-            @Override\n-            public String visitTypeAsClass(TypeElement e, SortedSet<Modifier> mods) {\n-                addModifiers(mods);\n-                String keyword = e.getKind() == ElementKind.RECORD ? \"record\" : \"class\";\n-                return finalString(keyword);\n-            }\n-\n-            @Override\n-            protected String defaultAction(Element e, SortedSet<Modifier> mods) {\n-                addModifiers(mods);\n-                return sb.toString().trim();\n-            }\n-\n-        }.visit(e, modifiers);\n-    }\n-\n@@ -1506,1 +1405,1 @@\n-     * Return true if the given Element is deprecated for removal.\n+     * Returns true if the given Element is deprecated for removal.\n@@ -1512,0 +1411,18 @@\n+        Object forRemoval = getDeprecatedElement(e, \"forRemoval\");\n+        return forRemoval != null && (boolean) forRemoval;\n+    }\n+\n+    \/**\n+     * Returns the value of the {@code Deprecated.since} element if it is set on the given Element.\n+     *\n+     * @param e the Element to check.\n+     * @return the Deprecated.since value for e, or null.\n+     *\/\n+    public String getDeprecatedSince(Element e) {\n+        return (String) getDeprecatedElement(e, \"since\");\n+    }\n+\n+    \/**\n+     * Returns the Deprecated annotation element value of the given element, or null.\n+     *\/\n+    private Object getDeprecatedElement(Element e, String elementName) {\n@@ -1519,2 +1436,2 @@\n-                        if (element.getSimpleName().contentEquals(\"forRemoval\")) {\n-                            return Boolean.parseBoolean((pairs.get(element)).toString());\n+                        if (element.getSimpleName().contentEquals(elementName)) {\n+                            return (pairs.get(element)).getValue();\n@@ -1526,1 +1443,1 @@\n-        return false;\n+        return null;\n@@ -3199,5 +3116,6 @@\n-        if (!previewLanguageFeaturesUsed(el).isEmpty() ||\n-            configuration.workArounds.isPreviewAPI(el) ||\n-            !previewAPIs.previewAPI.isEmpty() ||\n-            !previewAPIs.reflectivePreviewAPI.isEmpty() ||\n-            !previewAPIs.declaredUsingPreviewFeature.isEmpty())  {\n+        if ((!previewLanguageFeaturesUsed(el).isEmpty() ||\n+             configuration.workArounds.isPreviewAPI(el) ||\n+             !previewAPIs.previewAPI.isEmpty() ||\n+             !previewAPIs.reflectivePreviewAPI.isEmpty() ||\n+             !previewAPIs.declaredUsingPreviewFeature.isEmpty()) &&\n+            !hasNoProviewAnnotation(el)) {\n@@ -3219,0 +3137,5 @@\n+    private boolean hasNoProviewAnnotation(Element el) {\n+        return el.getAnnotationMirrors()\n+                 .stream()\n+                 .anyMatch(am -> \"jdk.internal.javac.NoPreview\".equals(getQualifiedTypeName(am.getAnnotationType())));\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":33,"deletions":110,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-    private final Messager messager;\n+    private final JavadocLog log;\n@@ -213,1 +213,1 @@\n-        this.messager = Messager.instance0(context);\n+        this.log = JavadocLog.instance0(context);\n@@ -373,1 +373,1 @@\n-            String text = messager.getText(\"main.cannot_use_sourcepath_for_modules\",\n+            String text = log.getText(\"main.cannot_use_sourcepath_for_modules\",\n@@ -380,1 +380,1 @@\n-            String text = messager.getText(\"main.module_not_found_on_sourcepath\", moduleNames.get(0));\n+            String text = log.getText(\"main.module_not_found_on_sourcepath\", moduleNames.get(0));\n@@ -385,1 +385,1 @@\n-            String text = messager.getText(\"main.sourcepath_does_not_contain_module\", moduleNames.get(0));\n+            String text = log.getText(\"main.sourcepath_does_not_contain_module\", moduleNames.get(0));\n@@ -402,1 +402,1 @@\n-            String text = messager.getText(\"main.file.manager.list\", location);\n+            String text = log.getText(\"main.file.manager.list\", location);\n@@ -416,1 +416,1 @@\n-                String text = messager.getText(\"main.module_not_found\", m);\n+                String text = log.getText(\"main.module_not_found\", m);\n@@ -523,1 +523,1 @@\n-            String text = messager.getText(\"main.file.manager.list\", packagename);\n+            String text = log.getText(\"main.file.manager.list\", packagename);\n@@ -570,1 +570,1 @@\n-                        messager.printWarningUsingKey(dep, \"main.module_source_not_found\", dep.getQualifiedName());\n+                        log.printWarningUsingKey(dep, \"main.module_source_not_found\", dep.getQualifiedName());\n@@ -762,1 +762,1 @@\n-                messager.printWarningUsingKey(\"main.package_not_found\", modpkg.toString());\n+                log.printWarningUsingKey(\"main.package_not_found\", modpkg.toString());\n@@ -783,1 +783,1 @@\n-                String text = messager.getText(\"javadoc.class_not_found\", className);\n+                String text = log.getText(\"javadoc.class_not_found\", className);\n@@ -799,1 +799,1 @@\n-                String text = messager.getText(\"main.no_source_files_for_package\",\n+                String text = log.getText(\"main.no_source_files_for_package\",\n@@ -912,1 +912,1 @@\n-            String text = messager.getText(\"main.doclet_could_not_get_location\", msymName);\n+            String text = log.getText(\"main.doclet_could_not_get_location\", msymName);\n@@ -959,1 +959,1 @@\n-                messager.printWarning(e.getMessage());\n+                log.printWarning(e.getMessage());\n@@ -961,1 +961,1 @@\n-                messager.printWarningUsingKey(\"main.unexpected.exception\", e);\n+                log.printWarningUsingKey(\"main.unexpected.exception\", e);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/ElementsTable.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-        messager = Messager.instance0(context);\n+        log = JavadocLog.instance0(context);\n@@ -69,1 +69,1 @@\n-    final Messager messager;\n+    final JavadocLog log;\n@@ -76,1 +76,1 @@\n-        int nerrors = messager.nerrors;\n+        int nerrors = log.nerrors;\n@@ -80,2 +80,2 @@\n-            messager.nwarnings += (messager.nerrors - nerrors);\n-            messager.nerrors = nerrors;\n+            log.nwarnings += (log.nerrors - nerrors);\n+            log.nerrors = nerrors;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/JavadocEnter.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,682 @@\n+\/*\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.tool;\n+\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.lang.ref.Reference;\n+import java.lang.ref.SoftReference;\n+import java.util.EnumSet;\n+import java.util.LinkedHashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.ResourceBundle;\n+import java.util.Set;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.NestingKind;\n+import javax.tools.Diagnostic;\n+import javax.tools.Diagnostic.Kind;\n+import javax.tools.FileObject;\n+import javax.tools.ForwardingFileObject;\n+import javax.tools.JavaFileObject;\n+\n+import jdk.javadoc.doclet.Reporter;\n+\n+import com.sun.tools.javac.tree.EndPosTable;\n+import com.sun.tools.javac.util.Context.Factory;\n+import com.sun.tools.javac.util.DiagnosticSource;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.util.DocSourcePositions;\n+import com.sun.source.util.DocTreePath;\n+import com.sun.source.util.TreePath;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.JCDiagnostic;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;\n+import com.sun.tools.javac.util.JavacMessages;\n+import com.sun.tools.javac.util.Log;\n+\n+\/**\n+ * Class for reporting diagnostics and other messages.\n+ *\n+ * The class leverages the javac support for reporting diagnostics, for stylistic consistency\n+ * of diagnostic messages and to avoid code duplication.\n+ *\n+ * The class is a subtype of javac's Log, and is primarily an adapter between\n+ * javadoc method signatures and the underlying javac methods. Within this class,\n+ * the methods call down to a core {@code report} method which hands off to\n+ * a similar method in the superclass ({@code Log.report}, which takes care\n+ * of reporting the diagnostic (unless it has been suppressed), displaying\n+ * the source line and a caret to indicate the position of the issue (if appropriate),\n+ * counting errors and warnings, and so on.\n+ *\n+ * In general, the underlying javac layer is more powerful, whereas the javadoc methods are\n+ * constrained by the public {@link jdk.javadoc.doclet.Doclet} API.\n+ *\n+ * In the underlying javac layer, the following abstractions are used:\n+ * <ul>\n+ *     <li>{@code DiagnosticType} -- error, warning, note, etc.\n+ *     <li>{@code DiagnosticSource} -- a file object and a cache of its content\n+ *     <li>{@code DiagnosticPosition} -- a tuple of values (start, pos, end) for the position of a diagnostic\n+ *     <li>{@code DiagnosticFlag} -- additional flags related to the diagnostic\n+ * <\/ul>\n+ *\n+ * The javadoc layer is defined by the methods on {@code Doclet.Reporter}, and by\n+ * assorted methods defined in this class for use by the javadoc tool.\n+ * The primary data types are:\n+ * <ul>\n+ *     <li>{@code Diagnostic.Kind} -- maps to {@code DiagnosticType} and {@code Set<DiagnosticFlag>}\n+ *     <li>{@code Element} -- maps to {@code DiagnosticSource} and {@code DiagnosticPosition}\n+ *     <li>{@code DocTreePath} -- maps to {@code DiagnosticSource} and {@code DiagnosticPosition}\n+ * <\/ul>\n+ *\n+ * The reporting methods in the javac layer primarily take pre-localized (key, args) pairs,\n+ * while the methods in the javadoc layer, especially the {@code Reporter} interface, take\n+ * localized strings. To accommodate this, \"wrapper\" resources are used, whose value is {@code {0}},\n+ * to pass the localized string down to javac. A side-effect is that clients using a\n+ * {@code DiagnosticListener} with a {@code DocumentationTask} cannot access the original resource\n+ * key for the localized message.\n+ * Given the limitations of the API, it is not possible to do any better.\n+ * The javac Annotation Processing API has the same problem.\n+ *\n+ * There is a slight disparity between javac's use of streams and javadoc's use of streams.\n+ * javac reports <b>all<\/b> diagnostics to the \"error\" stream, and provides a separate\n+ * \"output\" stream for expected output, such as command-line help or the output from options\n+ * like {@code -Xprint}. javadoc API, and {@code Reporter} in particular, does not specify\n+ * the use of streams, and provides no support for identifying or specifying streams. JDK-8267204.\n+ * The current implementation\/workaround is to write errors and warnings to the \"error\"\n+ * stream and notes to the \"output\" stream.\n+ *\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\n+ * @see java.util.ResourceBundle\n+ * @see java.text.MessageFormat\n+ *\/\n+public class JavadocLog extends Log implements Reporter {\n+    \/** The overall context for the documentation run. *\/\n+    private final Context context;\n+\n+    \/** The tool environment, providing access to the tool's utility classes and tables. *\/\n+    private ToolEnvironment toolEnv;\n+\n+    \/** The utility class to access the positions of items in doc comments. *\/\n+    private DocSourcePositions sourcePositions;\n+\n+    \/**\n+     * A memory-sensitive cache of recently used {@code DiagnosticSource} objects.\n+     *\/\n+    private final LinkedHashMap<JavaFileObject, SoftReference<DiagnosticSource>> diagSourceCache;\n+\n+    \/** Get the current javadoc log, which is also the compiler log. *\/\n+    public static JavadocLog instance0(Context context) {\n+        Log instance = context.get(logKey);\n+        if (!(instance instanceof JavadocLog l))\n+            throw new InternalError(\"no JavadocLog instance!\");\n+        return l;\n+    }\n+\n+    public static void preRegister(Context context,\n+                                   final String programName) {\n+        context.put(logKey, (Factory<Log>)c -> new JavadocLog(c, programName));\n+    }\n+\n+    public static void preRegister(Context context, final String programName,\n+            final PrintWriter outWriter, final PrintWriter errWriter) {\n+        context.put(logKey, (Factory<Log>)c -> new JavadocLog(c, programName, outWriter, errWriter));\n+    }\n+\n+    final String programName;\n+\n+    private Locale locale;\n+    private final JavacMessages messages;\n+    private final JCDiagnostic.Factory javadocDiags;\n+\n+    private static PrintWriter createPrintWriter(PrintStream ps, boolean autoflush) {\n+        return new PrintWriter(ps, autoflush) {\n+            \/\/ avoid closing system streams\n+            @Override\n+            public void close() {\n+                super.flush();\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Constructor\n+     * @param programName  Name of the program (for error messages).\n+     *\/\n+    public JavadocLog(Context context, String programName) {\n+        \/\/ use the current values of System.out, System.err, in case they have been redirected\n+        this(context, programName,\n+                createPrintWriter(System.out, false),\n+                createPrintWriter(System.err, true));\n+    }\n+\n+    \/**\n+     * Constructor\n+     * @param programName  Name of the program (for error messages).\n+     * @param outWriter    Stream for notices etc.\n+     * @param errWriter    Stream for errors and warnings\n+     *\/\n+    public JavadocLog(Context context, String programName, PrintWriter outWriter, PrintWriter errWriter) {\n+        super(context, outWriter, errWriter);\n+        messages = JavacMessages.instance(context);\n+        messages.add(locale -> ResourceBundle.getBundle(\"jdk.javadoc.internal.tool.resources.javadoc\",\n+                                                         locale));\n+        javadocDiags = new JCDiagnostic.Factory(messages, \"javadoc\");\n+        this.programName = programName;\n+        this.context = context;\n+        locale = Locale.getDefault();\n+\n+        diagSourceCache = new LinkedHashMap<>() {\n+            private static final int MAX_ENTRIES = 5;\n+\n+            @Override\n+            protected boolean removeEldestEntry(Map.Entry<JavaFileObject, SoftReference<DiagnosticSource>> eldest) {\n+                return size() > MAX_ENTRIES;\n+            }\n+        };\n+    }\n+\n+    @Override \/\/ Reporter\n+    public PrintWriter getStandardWriter() {\n+        return getWriter(Log.WriterKind.STDOUT);\n+    }\n+\n+    @Override \/\/ Reporter\n+    public PrintWriter getDiagnosticWriter() {\n+        return getWriter(Log.WriterKind.STDERR);\n+    }\n+\n+    public void setLocale(Locale locale) {\n+        this.locale = locale;\n+    }\n+\n+    \/**\n+     * Returns the localized string from the tool's resource bundles.\n+     *\n+     * @param key the resource key\n+     * @param args arguments for the resource\n+     *\/\n+    String getText(String key, Object... args) {\n+        return messages.getLocalizedString(locale, key, args);\n+    }\n+\n+    @Override \/\/ Reporter\n+    public void print(Kind kind, String message) {\n+        report(kind, null, null, message);\n+    }\n+\n+    @Override \/\/ Reporter\n+    public void print(Diagnostic.Kind kind, DocTreePath path, String message) {\n+        DiagnosticType dt = getDiagnosticType(kind);\n+        Set<DiagnosticFlag> flags = getDiagnosticFlags(kind);\n+        DiagnosticSource ds = getDiagnosticSource(path);\n+        DiagnosticPosition dp = getDiagnosticPosition(path);\n+        report(dt, flags, ds, dp, message);\n+    }\n+\n+    @Override  \/\/ Reporter\n+    public void print(Kind kind, Element element, String message) {\n+        DiagnosticType dt = getDiagnosticType(kind);\n+        Set<DiagnosticFlag> flags = getDiagnosticFlags(kind);\n+        DiagnosticSource ds = getDiagnosticSource(element);\n+        DiagnosticPosition dp = getDiagnosticPosition(element);\n+        report(dt, flags, ds, dp, message);\n+    }\n+\n+    @Override \/\/ Reporter\n+    public void print(Kind kind, FileObject file, int start, int pos, int end, String message) throws IllegalArgumentException {\n+        DiagnosticType dt = getDiagnosticType(kind);\n+        Set<DiagnosticFlag> flags = getDiagnosticFlags(kind);\n+        \/\/ Although not required to do so, it is the case that any file object returned from the\n+        \/\/ javac impl of JavaFileManager will return an object that implements JavaFileObject.\n+        \/\/ See PathFileObject, which provides the primary impls of (Java)FileObject.\n+        JavaFileObject fo = file instanceof JavaFileObject _fo ? _fo : new WrappingJavaFileObject(file);\n+        DiagnosticSource ds = new DiagnosticSource(fo, this);\n+        DiagnosticPosition dp = createDiagnosticPosition(null, start, pos, end);\n+        report(dt, flags, ds, dp, message);\n+    }\n+\n+    private class WrappingJavaFileObject\n+            extends ForwardingFileObject<FileObject> implements JavaFileObject {\n+\n+        WrappingJavaFileObject(FileObject fo) {\n+            super(fo);\n+            assert !(fo instanceof JavaFileObject);\n+        }\n+\n+        @Override\n+        public Kind getKind() {\n+            String name = fileObject.getName();\n+            return name.endsWith(Kind.HTML.extension)\n+                    ? JavaFileObject.Kind.HTML\n+                    : JavaFileObject.Kind.OTHER;\n+        }\n+\n+        @Override\n+        public boolean isNameCompatible(String simpleName, Kind kind) {\n+            return false;\n+        }\n+\n+        @Override\n+        public NestingKind getNestingKind() {\n+            return null;\n+        }\n+\n+        @Override\n+        public Modifier getAccessLevel() {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * Prints an error message.\n+     *\n+     * @param message the message\n+     *\/\n+    public void printError(String message) {\n+        report(DiagnosticType.ERROR,null, null, message);\n+    }\n+\n+    \/**\n+     * Prints an error message for a given documentation tree node.\n+     *\n+     * @param path    the path for the documentation tree node\n+     * @param message the message\n+     *\/\n+    public void printError(DocTreePath path, String message) {\n+        DiagnosticSource ds = getDiagnosticSource(path);\n+        DiagnosticPosition dp = getDiagnosticPosition(path);\n+        report(DiagnosticType.ERROR, EnumSet.noneOf(DiagnosticFlag.class), ds, dp, message);\n+    }\n+\n+    \/**\n+     * Prints an error message for a given element.\n+     *\n+     * @param element the element\n+     * @param message the message\n+     *\/\n+    public void printError(Element element, String message) {\n+        DiagnosticSource ds = getDiagnosticSource(element);\n+        DiagnosticPosition dp = getDiagnosticPosition(element);\n+        report(DiagnosticType.ERROR, EnumSet.noneOf(DiagnosticFlag.class), ds, dp, message);\n+    }\n+\n+    \/**\n+     * Prints an error message.\n+     *\n+     * @param key the resource key for the message\n+     * @param args the arguments for the message\n+     *\/\n+    public void printErrorUsingKey(String key, Object... args) {\n+        printError(getText(key, args));\n+    }\n+\n+    \/**\n+     * Prints a warning message.\n+     *\n+     * @param message the message\n+     *\/\n+    public void printWarning(String message) {\n+        report(DiagnosticType.WARNING, null, null, message);\n+    }\n+\n+    \/**\n+     * Prints a warning message for a given documentation tree node.\n+     *\n+     * @param path    the path for the documentation tree node\n+     * @param message the message\n+     *\/\n+    public void printWarning(DocTreePath path, String message) {\n+        DiagnosticSource ds = getDiagnosticSource(path);\n+        DiagnosticPosition dp = getDiagnosticPosition(path);\n+        report(DiagnosticType.WARNING, EnumSet.noneOf(DiagnosticFlag.class), ds, dp, message);\n+    }\n+\n+    \/**\n+     * Prints a warning message for a given element.\n+     *\n+     * @param element the element\n+     * @param message the message\n+     *\/\n+    public void printWarning(Element element, String message) {\n+        DiagnosticSource ds = getDiagnosticSource(element);\n+        DiagnosticPosition dp = getDiagnosticPosition(element);\n+        report(DiagnosticType.WARNING, EnumSet.noneOf(DiagnosticFlag.class), ds, dp, message);\n+    }\n+\n+    \/**\n+     * Prints a warning message.\n+     *\n+     * @param key the resource key for the message\n+     * @param args the arguments for the message\n+     *\/\n+    public void printWarningUsingKey(String key, Object... args) {\n+        printWarning(getText(key, args));\n+    }\n+\n+    \/**\n+     * Prints a warning message for an element.\n+     *\n+     * @param element the element\n+     * @param key     the resource key for the message\n+     * @param args    the arguments for the message\n+     *\/\n+    public void printWarningUsingKey(Element element, String key, Object... args) {\n+        printWarning(element, getText(key, args));\n+    }\n+\n+    \/**\n+     * Prints a \"notice\" message to the standard writer.\n+     *\n+     * @param key  the resource key for the message\n+     * @param args the arguments for the message\n+     *\/\n+    public void noticeUsingKey(String key, Object... args) {\n+        printRawLines(getStandardWriter(), getText(key, args));\n+    }\n+\n+    \/**\n+     * Prints a \"notice\" message to the standard writer.\n+     *\n+     * @param message the message\n+     *\/\n+    public void notice(String message) {\n+        printRawLines(getStandardWriter(), message);\n+    }\n+\n+    \/**\n+     * Returns true if errors have been recorded.\n+     *\/\n+    public boolean hasErrors() {\n+        return nerrors != 0;\n+    }\n+\n+    \/**\n+     * Returns true if warnings have been recorded.\n+     *\/\n+    public boolean hasWarnings() {\n+        return nwarnings != 0;\n+    }\n+\n+    \/**\n+     * Prints the error and warning counts, if any, to the diagnostic writer.\n+     *\/\n+    public void printErrorWarningCounts() {\n+        printCount(nerrors, \"main.error\", \"main.errors\");\n+        printCount(nwarnings, \"main.warning\", \"main.warnings\");\n+    }\n+\n+    private void printCount(int count, String singleKey, String pluralKey) {\n+        if (count > 0) {\n+            String message = getText(count > 1 ? pluralKey : singleKey, count);\n+            if (diagListener != null) {\n+                report(DiagnosticType.NOTE, null, null, message);\n+            } else {\n+                printRawLines(getDiagnosticWriter(), message);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Reports a diagnostic message.\n+     *\n+     * @param kind    the kind of diagnostic\n+     * @param ds      the diagnostic source\n+     * @param dp      the diagnostic position\n+     * @param message the message\n+     *\/\n+    private void report(Diagnostic.Kind kind, DiagnosticSource ds, DiagnosticPosition dp, String message) {\n+        report(getDiagnosticType(kind), getDiagnosticFlags(kind), ds, dp, message);\n+    }\n+\n+    \/**\n+     * Reports a diagnostic message.\n+     *\n+     * @param dt      the diagnostic type\n+     * @param ds      the diagnostic source\n+     * @param dp      the diagnostic position\n+     * @param message the message\n+     *\/\n+    private void report(DiagnosticType dt, DiagnosticSource ds, DiagnosticPosition dp, String message) {\n+        report(dt, EnumSet.noneOf(DiagnosticFlag.class), ds, dp, message);\n+    }\n+\n+    \/**\n+     * Reports a diagnostic message, with diagnostic flags.\n+     * For javadoc, the only flag that is used is {@code MANDATORY_WARNING}, and only\n+     * because in principle the public API supports it via {@code Kind.MANDATORY_WARNING}.\n+     * javadoc itself does generate mandatory warnings.\n+     *\n+     * This is the primary low-level wrapper around the underlying {@code Log.report}.\n+     * Because we already have a localized message, we use wrapper resources (just {@code {0}})\n+     * to wrap the string. The current behavior is one wrapper per diagnostic type.\n+     * We could improve this by subtyping {@code DiagnosticInfo} to modify the resource key used.\n+     *\n+     * {@code Log} reports all diagnostics to the corresponding writer, which defaults\n+     * to the \"error\" stream, when using the two-stream constructor. That doesn't work\n+     * for javadoc, which has historically written notes to the \"output\" stream, because\n+     * the public API used by doclets does not provide for more detailed control.\n+     * Therefore, for now, javadoc continues to use the (deprecated) three-stream\n+     * constructor, with the {@code NOTE} stream set to the \"output\" stream.\n+     *\n+     * {@code Log} reports all notes with a \"Note:\" prefix. That's not good for the\n+     * standard doclet, which uses notes to report the various \"progress\" messages,\n+     * such as  \"Generating class ...\".  They can be written directly to the diagnostic\n+     * writer, but that bypasses low-level checks about whether to suppress notes,\n+     * and bypasses the diagnostic listener for API clients.\n+     * Overall, it's an over-constrained problem with no obvious good solution.\n+     *\n+     * Note: there is an intentional difference in behavior between the diagnostic source\n+     * being set to {@code null} (no source intended) and {@code NO_SOURCE} (no source available).\n+     *\n+     * @param dt      the diagnostic type\n+     * @param ds      the diagnostic source\n+     * @param dp      the diagnostic position\n+     * @param message the message\n+     *\/\n+    private void report(DiagnosticType dt, Set<DiagnosticFlag> flags, DiagnosticSource ds, DiagnosticPosition dp, String message) {\n+        report(javadocDiags.create(dt, null, flags, ds, dp, \"message\", message));\n+    }\n+\n+    \/**\n+     * Returns a diagnostic position for a documentation tree node.\n+     *\n+     * @param path the path for the documentation tree node\n+     * @return the diagnostic position\n+     *\/\n+    private DiagnosticPosition getDiagnosticPosition(DocTreePath path) {\n+        DocSourcePositions posns = getSourcePositions();\n+        CompilationUnitTree compUnit = path.getTreePath().getCompilationUnit();\n+        int start = (int) posns.getStartPosition(compUnit, path.getDocComment(), path.getLeaf());\n+        int end = (int) posns.getEndPosition(compUnit, path.getDocComment(), path.getLeaf());\n+        return createDiagnosticPosition(null, start, start, end);\n+    }\n+\n+    \/**\n+     * Returns a diagnostic position for an element, or {@code null} if the source\n+     * file is not available.\n+     *\n+     * @param element the element\n+     * @return the diagnostic position\n+     *\/\n+    private DiagnosticPosition getDiagnosticPosition(Element element) {\n+        ToolEnvironment toolEnv = getToolEnv();\n+        DocSourcePositions posns = getSourcePositions();\n+        TreePath tp = toolEnv.elementToTreePath.get(element);\n+        if (tp == null) {\n+            return null;\n+        }\n+        CompilationUnitTree compUnit = tp.getCompilationUnit();\n+        JCTree tree = (JCTree) tp.getLeaf();\n+        int start = (int) posns.getStartPosition(compUnit, tree);\n+        int pos = tree.getPreferredPosition();\n+        int end = (int) posns.getEndPosition(compUnit, tree);\n+        return createDiagnosticPosition(tree, start, pos, end);\n+    }\n+\n+    \/**\n+     * Creates a diagnostic position.\n+     *\n+     * @param tree the tree node, or null if no tree is applicable\n+     * @param start the start position\n+     * @param pos   the \"preferred\" position: this is used to position the caret in messages\n+     * @param end   the end position\n+     * @return the diagnostic position\n+     *\/\n+    private DiagnosticPosition createDiagnosticPosition(JCTree tree, int start, int pos, int end) {\n+        return new DiagnosticPosition() {\n+            @Override\n+            public JCTree getTree() {\n+                return tree;\n+            }\n+\n+            @Override\n+            public int getStartPosition() {\n+                return start;\n+            }\n+\n+            @Override\n+            public int getPreferredPosition() {\n+                return pos;\n+            }\n+\n+            @Override\n+            public int getEndPosition(EndPosTable endPosTable) {\n+                return end;\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Returns the diagnostic type for a diagnostic kind.\n+     *\n+     * @param kind the diagnostic kind\n+     * @return the diagnostic type\n+     *\/\n+    private DiagnosticType getDiagnosticType(Diagnostic.Kind kind) {\n+        return switch (kind) {\n+            case ERROR -> DiagnosticType.ERROR;\n+            case WARNING, MANDATORY_WARNING -> DiagnosticType.WARNING;\n+            case NOTE -> DiagnosticType.NOTE;\n+            case OTHER -> DiagnosticType.FRAGMENT;\n+        };\n+    }\n+\n+    \/**\n+     * Returns the diagnostic flags for a diagnostic kind.\n+     * A diagnostic kind of {@code MANDATORY_WARNING} requires the {@code MANDATORY} flag.\n+     *\n+     * @param kind the diagnostic kind\n+     * @return the flags\n+     *\/\n+    private Set<DiagnosticFlag> getDiagnosticFlags(Diagnostic.Kind kind) {\n+        return kind == Kind.MANDATORY_WARNING\n+                ? EnumSet.of(DiagnosticFlag.MANDATORY)\n+                : EnumSet.noneOf(DiagnosticFlag.class);\n+    }\n+\n+    \/**\n+     * Returns the diagnostic source for an documentation tree node.\n+     *\n+     * @param path the path for the documentation tree node\n+     * @return the diagnostic source\n+     *\/\n+    private DiagnosticSource getDiagnosticSource(DocTreePath path) {\n+        return getDiagnosticSource(path.getTreePath().getCompilationUnit().getSourceFile());\n+    }\n+\n+    \/**\n+     * Returns the diagnostic source for an element, or {@code NO_SOURCE} if the\n+     * source file is not known (for example, if the element was read from a class file).\n+     *\n+     * @param element the element\n+     * @return the diagnostic source\n+     *\/\n+    private DiagnosticSource getDiagnosticSource(Element element) {\n+        TreePath tp = getToolEnv().elementToTreePath.get(element);\n+        return tp == null ? DiagnosticSource.NO_SOURCE\n+                : getDiagnosticSource(tp.getCompilationUnit().getSourceFile());\n+    }\n+\n+    \/**\n+     * Returns the diagnostic source for a file object.\n+     *\n+     * {@code DiagnosticSource} objects are moderately expensive because they maintain\n+     * an internal copy of the content, to provide the line map.\n+     * Therefore, we keep a small memory-sensitive cache of recently used objects.\n+     *\n+     * @param fo the file object\n+     * @return the diagnostic source\n+     *\/\n+    private DiagnosticSource getDiagnosticSource(JavaFileObject fo) {\n+        Reference<DiagnosticSource> ref = diagSourceCache.get(fo);\n+        DiagnosticSource ds = ref == null ? null : ref.get();\n+        if (ds == null) {\n+            ds = new DiagnosticSource(fo, this);\n+            diagSourceCache.put(fo, new SoftReference<>(ds));\n+        }\n+        return ds;\n+    }\n+\n+    \/**\n+     * Returns the object for computing source positions.\n+     *\n+     * The value is determined lazily because the tool environment is computed lazily.\n+     *\n+     * @return the object for computing source positions\n+     *\/\n+    private DocSourcePositions getSourcePositions() {\n+        if (sourcePositions == null) {\n+            sourcePositions = getToolEnv().docTrees.getSourcePositions();\n+        }\n+        return sourcePositions;\n+    }\n+\n+    \/**\n+     * Returns the tool environment.\n+     *\n+     * The value is determined lazily, because creating it eagerly disrupts\n+     * the overall initialization of objects in the context.\n+     *\n+     * @return the tool environment\n+     *\/\n+    private ToolEnvironment getToolEnv() {\n+        if (toolEnv == null) {\n+            toolEnv = ToolEnvironment.instance(context);\n+        }\n+        return toolEnv;\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/JavadocLog.java","additions":682,"deletions":0,"binary":false,"changes":682,"status":"added"},{"patch":"@@ -73,1 +73,1 @@\n-    final Messager messager;\n+    final JavadocLog log;\n@@ -85,1 +85,1 @@\n-        messager = Messager.instance0(context);\n+        log = JavadocLog.instance0(context);\n@@ -104,1 +104,1 @@\n-        Messager messager = null;\n+        JavadocLog log = null;\n@@ -118,2 +118,2 @@\n-            \/\/ force the use of Messager as a Log\n-            messager = Messager.instance0(context);\n+            \/\/ force the use of Javadoc's subtype of Log\n+            log = JavadocLog.instance0(context);\n@@ -123,2 +123,2 @@\n-            assert messager != null;\n-            messager.error(Position.NOPOS, ex.getMessage());\n+            assert log != null;\n+            log.error(Position.NOPOS, ex.getMessage());\n@@ -145,1 +145,1 @@\n-                    String text = messager.getText(\"main.illegal_class_name\", arg);\n+                    String text = log.getText(\"main.illegal_class_name\", arg);\n@@ -149,1 +149,1 @@\n-            if (messager.hasErrors()) {\n+            if (log.hasErrors()) {\n@@ -174,1 +174,1 @@\n-                        String text = messager.getText(\"main.assertion.error\", \"fm == null\");\n+                        String text = log.getText(\"main.assertion.error\", \"fm == null\");\n@@ -177,1 +177,1 @@\n-                        String text = messager.getText(\"main.file_not_found\", arg);\n+                        String text = log.getText(\"main.file_not_found\", arg);\n@@ -181,1 +181,1 @@\n-                    String text = messager.getText(\"main.illegal_package_name\", arg);\n+                    String text = log.getText(\"main.illegal_package_name\", arg);\n@@ -194,1 +194,1 @@\n-            if (messager.hasErrors()) {\n+            if (log.hasErrors()) {\n@@ -205,1 +205,1 @@\n-            if (messager.hasErrors()) {\n+            if (log.hasErrors()) {\n@@ -213,1 +213,1 @@\n-            if (messager.hasErrors()) {\n+            if (log.hasErrors()) {\n@@ -235,1 +235,1 @@\n-            if (messager.hasErrors()) {\n+            if (log.hasErrors()) {\n@@ -239,1 +239,1 @@\n-                String text = messager.getText(\"main.internal.error\");\n+                String text = log.getText(\"main.internal.error\");\n@@ -245,1 +245,1 @@\n-        if (messager.hasErrors())\n+        if (log.hasErrors())\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/JavadocTool.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1,638 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.tool;\n-\n-import java.io.PrintWriter;\n-import java.lang.ref.Reference;\n-import java.lang.ref.SoftReference;\n-import java.util.EnumSet;\n-import java.util.LinkedHashMap;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.ResourceBundle;\n-import java.util.Set;\n-\n-import javax.lang.model.element.Element;\n-import javax.tools.Diagnostic;\n-import javax.tools.Diagnostic.Kind;\n-import javax.tools.JavaFileObject;\n-\n-import jdk.javadoc.doclet.Reporter;\n-\n-import com.sun.tools.javac.tree.EndPosTable;\n-import com.sun.tools.javac.util.Context.Factory;\n-import com.sun.tools.javac.util.DiagnosticSource;\n-import com.sun.source.tree.CompilationUnitTree;\n-import com.sun.source.util.DocSourcePositions;\n-import com.sun.source.util.DocTreePath;\n-import com.sun.source.util.TreePath;\n-import com.sun.tools.javac.tree.JCTree;\n-import com.sun.tools.javac.util.Context;\n-import com.sun.tools.javac.util.JCDiagnostic;\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;\n-import com.sun.tools.javac.util.JavacMessages;\n-import com.sun.tools.javac.util.Log;\n-\n-\/**\n- * Class for reporting diagnostics and other messages.\n- *\n- * The class leverages the javac support for reporting diagnostics, for stylistic consistency\n- * of diagnostic messages and to avoid code duplication.\n- *\n- * The class is a subtype of javac's Log, and is primarily an adapter between\n- * javadoc method signatures and the underlying javac methods. Within this class,\n- * the methods call down to a core {@code report} method which hands off to\n- * a similar method in the superclass ({@code Log.report}, which takes care\n- * of reporting the diagnostic (unless it has been suppressed), displaying\n- * the source line and a caret to indicate the position of the issue (if appropriate),\n- * counting errors and warnings, and so on.\n- *\n- * In general, the underlying javac layer is more powerful, whereas the javadoc methods are\n- * constrained by the public {@link jdk.javadoc.doclet.Doclet} API.\n- *\n- * In the underlying javac layer, the following abstractions are used:\n- * <ul>\n- *     <li>{@code DiagnosticType} -- error, warning, note, etc.\n- *     <li>{@code DiagnosticSource} -- a file object and a cache of its content\n- *     <li>{@code DiagnosticPosition} -- a tuple of values (start, pos, end) for the position of a diagnostic\n- *     <li>{@code DiagnosticFlag} -- additional flags related to the diagnostic\n- * <\/ul>\n- *\n- * The javadoc layer is defined by the methods on {@code Doclet.Reporter}, and by\n- * assorted methods defined in this class for use by the javadoc tool.\n- * The primary data types are:\n- * <ul>\n- *     <li>{@code Diagnostic.Kind} -- maps to {@code DiagnosticType} and {@code Set<DiagnosticFlag>}\n- *     <li>{@code Element} -- maps to {@code DiagnosticSource} and {@code DiagnosticPosition}\n- *     <li>{@code DocTreePath} -- maps to {@code DiagnosticSource} and {@code DiagnosticPosition}\n- * <\/ul>\n- *\n- * The reporting methods in the javac layer primarily take pre-localized (key, args) pairs,\n- * while the methods in the javadoc layer, especially the {@code Reporter} interface, take\n- * localized strings. To accommodate this, \"wrapper\" resources are used, whose value is {@code {0}},\n- * to pass the localized string down to javac. A side-effect is that clients using a\n- * {@code DiagnosticListener} with a {@code DocumentationTask} cannot access the original resource\n- * key for the localized message.\n- * Given the limitations of the API, it is not possible to do any better.\n- * The javac Annotation Processing API has the same problem.\n- *\n- * There is a slight disparity between javac's use of streams and javadoc's use of streams.\n- * javac reports <b>all<\/b> diagnostics to the \"error\" stream, and provides a separate\n- * \"output\" stream for expected output, such as command-line help or the output from options\n- * like {@code -Xprint}. javadoc API, and {@code Reporter} in particular, does not specify\n- * the use of streams, and provides no support for identifying or specifying streams. JDK-8267204.\n- * The current implementation\/workaround is to write errors and warnings to the \"error\"\n- * stream and notes to the \"output\" stream.\n- *\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\n- * @see java.util.ResourceBundle\n- * @see java.text.MessageFormat\n- *\/\n-public class Messager extends Log implements Reporter {\n-    \/** The overall context for the documentation run. *\/\n-    private final Context context;\n-\n-    \/** The tool environment, providing access to the tool's utility classes and tables. *\/\n-    private ToolEnvironment toolEnv;\n-\n-    \/** The utility class to access the positions of items in doc comments. *\/\n-    private DocSourcePositions sourcePositions;\n-\n-    \/**\n-     * A memory-sensitive cache of recently used {@code DiagnosticSource} objects.\n-     *\/\n-    private final LinkedHashMap<JavaFileObject, SoftReference<DiagnosticSource>> diagSourceCache;\n-\n-    \/** Get the current messager, which is also the compiler log. *\/\n-    public static Messager instance0(Context context) {\n-        Log instance = context.get(logKey);\n-        if (!(instance instanceof Messager m))\n-            throw new InternalError(\"no messager instance!\");\n-        return m;\n-    }\n-\n-    public static void preRegister(Context context,\n-                                   final String programName) {\n-        context.put(logKey, (Factory<Log>)c -> new Messager(c, programName));\n-    }\n-\n-    public static void preRegister(Context context, final String programName,\n-            final PrintWriter outWriter, final PrintWriter errWriter) {\n-        context.put(logKey, (Factory<Log>)c -> new Messager(c, programName, outWriter, errWriter));\n-    }\n-\n-    final String programName;\n-\n-    private Locale locale;\n-    private final JavacMessages messages;\n-    private final JCDiagnostic.Factory javadocDiags;\n-\n-    \/** The default writer for notes. *\/\n-    private static final PrintWriter defaultOutWriter = new PrintWriter(System.out);\n-    \/** The default writer for errors and warnings. *\/\n-    private static final PrintWriter defaultErrWriter = new PrintWriter(System.err);\n-\n-    \/**\n-     * Constructor\n-     * @param programName  Name of the program (for error messages).\n-     *\/\n-    public Messager(Context context, String programName) {\n-        this(context, programName, defaultOutWriter, defaultErrWriter);\n-    }\n-\n-    \/**\n-     * Constructor\n-     * @param programName  Name of the program (for error messages).\n-     * @param outWriter    Stream for notices etc.\n-     * @param errWriter    Stream for errors and warnings\n-     *\/\n-    @SuppressWarnings(\"deprecation\")\n-    public Messager(Context context, String programName, PrintWriter outWriter, PrintWriter errWriter) {\n-        super(context, errWriter, errWriter, outWriter);\n-        messages = JavacMessages.instance(context);\n-        messages.add(locale -> ResourceBundle.getBundle(\"jdk.javadoc.internal.tool.resources.javadoc\",\n-                                                         locale));\n-        javadocDiags = new JCDiagnostic.Factory(messages, \"javadoc\");\n-        this.programName = programName;\n-        this.context = context;\n-        locale = Locale.getDefault();\n-\n-        diagSourceCache = new LinkedHashMap<>() {\n-            private static final int MAX_ENTRIES = 5;\n-\n-            @Override\n-            protected boolean removeEldestEntry(Map.Entry<JavaFileObject, SoftReference<DiagnosticSource>> eldest) {\n-                return size() > MAX_ENTRIES;\n-            }\n-        };\n-    }\n-\n-    public void setLocale(Locale locale) {\n-        this.locale = locale;\n-    }\n-\n-    \/**\n-     * Returns the localized string from the tool's resource bundles.\n-     *\n-     * @param key the resource key\n-     * @param args arguments for the resource\n-     *\/\n-    String getText(String key, Object... args) {\n-        return messages.getLocalizedString(locale, key, args);\n-    }\n-\n-    @Override \/\/ Reporter\n-    public void print(Kind kind, String message) {\n-        report(kind, null, null, message);\n-    }\n-\n-    @Override \/\/ Reporter\n-    public void print(Diagnostic.Kind kind, DocTreePath path, String message) {\n-        DiagnosticType dt = getDiagnosticType(kind);\n-        Set<DiagnosticFlag> flags = getDiagnosticFlags(kind);\n-        DiagnosticSource ds = getDiagnosticSource(path);\n-        DiagnosticPosition dp = getDiagnosticPosition(path);\n-        report(dt, flags, ds, dp, message);\n-    }\n-\n-    @Override  \/\/ Reporter\n-    public void print(Kind kind, Element element, String message) {\n-        DiagnosticType dt = getDiagnosticType(kind);\n-        Set<DiagnosticFlag> flags = getDiagnosticFlags(kind);\n-        DiagnosticSource ds = getDiagnosticSource(element);\n-        DiagnosticPosition dp = getDiagnosticPosition(element);\n-        report(dt, flags, ds, dp, message);\n-    }\n-\n-    \/**\n-     * Prints an error message.\n-     *\n-     * @param message the message\n-     *\/\n-    public void printError(String message) {\n-        report(DiagnosticType.ERROR,null, null, message);\n-    }\n-\n-    \/**\n-     * Prints an error message for a given documentation tree node.\n-     *\n-     * @param path    the path for the documentation tree node\n-     * @param message the message\n-     *\/\n-    public void printError(DocTreePath path, String message) {\n-        DiagnosticSource ds = getDiagnosticSource(path);\n-        DiagnosticPosition dp = getDiagnosticPosition(path);\n-        report(DiagnosticType.ERROR, EnumSet.noneOf(DiagnosticFlag.class), ds, dp, message);\n-    }\n-\n-    \/**\n-     * Prints an error message for a given element.\n-     *\n-     * @param element the element\n-     * @param message the message\n-     *\/\n-    public void printError(Element element, String message) {\n-        DiagnosticSource ds = getDiagnosticSource(element);\n-        DiagnosticPosition dp = getDiagnosticPosition(element);\n-        report(DiagnosticType.ERROR, EnumSet.noneOf(DiagnosticFlag.class), ds, dp, message);\n-    }\n-\n-    \/**\n-     * Prints an error message.\n-     *\n-     * @param key the resource key for the message\n-     * @param args the arguments for the message\n-     *\/\n-    public void printErrorUsingKey(String key, Object... args) {\n-        printError(getText(key, args));\n-    }\n-\n-    \/**\n-     * Prints a warning message.\n-     *\n-     * @param message the message\n-     *\/\n-    public void printWarning(String message) {\n-        report(DiagnosticType.WARNING, null, null, message);\n-    }\n-\n-    \/**\n-     * Prints a warning message for a given documentation tree node.\n-     *\n-     * @param path    the path for the documentation tree node\n-     * @param message the message\n-     *\/\n-    public void printWarning(DocTreePath path, String message) {\n-        DiagnosticSource ds = getDiagnosticSource(path);\n-        DiagnosticPosition dp = getDiagnosticPosition(path);\n-        report(DiagnosticType.WARNING, EnumSet.noneOf(DiagnosticFlag.class), ds, dp, message);\n-    }\n-\n-    \/**\n-     * Prints a warning message for a given element.\n-     *\n-     * @param element the element\n-     * @param message the message\n-     *\/\n-    public void printWarning(Element element, String message) {\n-        DiagnosticSource ds = getDiagnosticSource(element);\n-        DiagnosticPosition dp = getDiagnosticPosition(element);\n-        report(DiagnosticType.WARNING, EnumSet.noneOf(DiagnosticFlag.class), ds, dp, message);\n-    }\n-\n-    \/**\n-     * Prints a warning message.\n-     *\n-     * @param key the resource key for the message\n-     * @param args the arguments for the message\n-     *\/\n-    public void printWarningUsingKey(String key, Object... args) {\n-        printWarning(getText(key, args));\n-    }\n-\n-    \/**\n-     * Prints a warning message for an element.\n-     *\n-     * @param element the element\n-     * @param key     the resource key for the message\n-     * @param args    the arguments for the message\n-     *\/\n-    public void printWarningUsingKey(Element element, String key, Object... args) {\n-        printWarning(element, getText(key, args));\n-    }\n-\n-    \/**\n-     * Prints a \"notice\" message.\n-     *\n-     * @param message the message\n-     *\/\n-    public void printNotice(String message) {\n-        report(DiagnosticType.NOTE, null, null, message);\n-    }\n-\n-    \/**\n-     * Prints a \"notice\" message for a given documentation tree node.\n-     *\n-     * @param path    the path for the documentation tree node\n-     * @param message the message\n-     *\/\n-    public void printNotice(DocTreePath path, String message) {\n-        DiagnosticSource ds = getDiagnosticSource(path);\n-        DiagnosticPosition dp = getDiagnosticPosition(path);\n-        report(DiagnosticType.NOTE, EnumSet.noneOf(DiagnosticFlag.class), ds, dp, message);\n-    }\n-\n-    \/**\n-     * Prints a \"notice\" message for a given element.\n-     *\n-     * @param element the element\n-     * @param message the message\n-     *\/\n-    public void printNotice(Element element, String message) {\n-        DiagnosticSource ds = getDiagnosticSource(element);\n-        DiagnosticPosition dp = getDiagnosticPosition(element);\n-        report(DiagnosticType.NOTE, EnumSet.noneOf(DiagnosticFlag.class), ds, dp, message);\n-    }\n-\n-    \/**\n-     * Prints a \"notice\" message.\n-     *\n-     * @param key  the resource key for the message\n-     * @param args the arguments for the message\n-     *\/\n-    public void notice(String key, Object... args) {\n-        printNotice(getText(key, args));\n-    }\n-\n-    \/**\n-     * Returns true if errors have been recorded.\n-     *\/\n-    public boolean hasErrors() {\n-        return nerrors != 0;\n-    }\n-\n-    \/**\n-     * Returns true if warnings have been recorded.\n-     *\/\n-    public boolean hasWarnings() {\n-        return nwarnings != 0;\n-    }\n-\n-    \/**\n-     * Prints the error and warning counts, if any.\n-     *\/\n-    public void printErrorWarningCounts() {\n-        if (nerrors > 0) {\n-            notice((nerrors > 1) ? \"main.errors\" : \"main.error\",\n-                   \"\" + nerrors);\n-        }\n-        if (nwarnings > 0) {\n-            notice((nwarnings > 1) ?  \"main.warnings\" : \"main.warning\",\n-                   \"\" + nwarnings);\n-        }\n-    }\n-\n-    \/**\n-     * Reports a diagnostic message.\n-     *\n-     * @param kind    the kind of diagnostic\n-     * @param ds      the diagnostic source\n-     * @param dp      the diagnostic position\n-     * @param message the message\n-     *\/\n-    private void report(Diagnostic.Kind kind, DiagnosticSource ds, DiagnosticPosition dp, String message) {\n-        report(getDiagnosticType(kind), getDiagnosticFlags(kind), ds, dp, message);\n-    }\n-\n-    \/**\n-     * Reports a diagnostic message.\n-     *\n-     * @param dt      the diagnostic type\n-     * @param ds      the diagnostic source\n-     * @param dp      the diagnostic position\n-     * @param message the message\n-     *\/\n-    private void report(DiagnosticType dt, DiagnosticSource ds, DiagnosticPosition dp, String message) {\n-        report(dt, EnumSet.noneOf(DiagnosticFlag.class), ds, dp, message);\n-    }\n-\n-    \/**\n-     * Reports a diagnostic message, with diagnostic flags.\n-     * For javadoc, the only flag that is used is {@code MANDATORY_WARNING}, and only\n-     * because in principle the public API supports it via {@code Kind.MANDATORY_WARNING}.\n-     * javadoc itself does generate mandatory warnings.\n-     *\n-     * This is the primary low-level wrapper around the underlying {@code Log.report}.\n-     * Because we already have a localized message, we use wrapper resources (just {@code {0}})\n-     * to wrap the string. The current behavior is one wrapper per diagnostic type.\n-     * We could improve this by subtyping {@code DiagnosticInfo} to modify the resource key used.\n-     *\n-     * {@code Log} reports all diagnostics to the corresponding writer, which defaults\n-     * to the \"error\" stream, when using the two-stream constructor. That doesn't work\n-     * for javadoc, which has historically written notes to the \"output\" stream, because\n-     * the public API used by doclets does not provide for more detailed control.\n-     * Therefore, for now, javadoc continues to use the (deprecated) three-stream\n-     * constructor, with the {@code NOTE} stream set to the \"output\" stream.\n-     *\n-     * {@code Log} reports all notes with a \"Note:\" prefix. That's not good for the\n-     * standard doclet, which uses notes to report the various \"progress\" messages,\n-     * such as  \"Generating class ...\".  Therefore, for now, we detect and report those\n-     * messages directly. (A better solution would be to expose access to the output\n-     * and error streams via {@code Reporter}).\n-     *\n-     * Note: there is an intentional difference in behavior between the diagnostic source\n-     * being set to {@code null} (no source intended) and {@code NO_SOURCE} (no source available).\n-     *\n-     * @param dt      the diagnostic type\n-     * @param ds      the diagnostic source\n-     * @param dp      the diagnostic position\n-     * @param message the message\n-     *\/\n-    private void report(DiagnosticType dt, Set<DiagnosticFlag> flags, DiagnosticSource ds, DiagnosticPosition dp, String message) {\n-        if (dt == DiagnosticType.NOTE && ds == null && !hasDiagnosticListener()) {\n-            printRawLines(WriterKind.STDOUT, message);\n-            getWriter(WriterKind.STDOUT).flush();\n-        } else {\n-            report(javadocDiags.create(dt, null, flags, ds, dp, \"message\", message));\n-        }\n-    }\n-\n-    \/**\n-     * Returns a diagnostic position for a documentation tree node.\n-     *\n-     * @param path the path for the documentation tree node\n-     * @return the diagnostic position\n-     *\/\n-    private DiagnosticPosition getDiagnosticPosition(DocTreePath path) {\n-        DocSourcePositions posns = getSourcePositions();\n-        CompilationUnitTree compUnit = path.getTreePath().getCompilationUnit();\n-        int start = (int) posns.getStartPosition(compUnit, path.getDocComment(), path.getLeaf());\n-        int end = (int) posns.getEndPosition(compUnit, path.getDocComment(), path.getLeaf());\n-        return createDiagnosticPosition(null, start, start, end);\n-    }\n-\n-    \/**\n-     * Returns a diagnostic position for an element, or {@code null} if the source\n-     * file is not available.\n-     *\n-     * @param element the element\n-     * @return the diagnostic position\n-     *\/\n-    private DiagnosticPosition getDiagnosticPosition(Element element) {\n-        ToolEnvironment toolEnv = getToolEnv();\n-        DocSourcePositions posns = getSourcePositions();\n-        TreePath tp = toolEnv.elementToTreePath.get(element);\n-        if (tp == null) {\n-            return null;\n-        }\n-        CompilationUnitTree compUnit = tp.getCompilationUnit();\n-        JCTree tree = (JCTree) tp.getLeaf();\n-        int start = (int) posns.getStartPosition(compUnit, tree);\n-        int pos = tree.getPreferredPosition();\n-        int end = (int) posns.getEndPosition(compUnit, tree);\n-        return createDiagnosticPosition(tree, start, pos, end);\n-    }\n-\n-    \/**\n-     * Creates a diagnostic position.\n-     *\n-     * @param tree the tree node, or null if no tree is applicable\n-     * @param start the start position\n-     * @param pos   the \"preferred\" position: this is used to position the caret in messages\n-     * @param end   the end position\n-     * @return the diagnostic position\n-     *\/\n-    private DiagnosticPosition createDiagnosticPosition(JCTree tree, int start, int pos, int end) {\n-        return new DiagnosticPosition() {\n-            @Override\n-            public JCTree getTree() {\n-                return tree;\n-            }\n-\n-            @Override\n-            public int getStartPosition() {\n-                return start;\n-            }\n-\n-            @Override\n-            public int getPreferredPosition() {\n-                return pos;\n-            }\n-\n-            @Override\n-            public int getEndPosition(EndPosTable endPosTable) {\n-                return end;\n-            }\n-        };\n-    }\n-\n-    \/**\n-     * Returns the diagnostic type for a diagnostic kind.\n-     *\n-     * @param kind the diagnostic kind\n-     * @return the diagnostic type\n-     *\/\n-    private DiagnosticType getDiagnosticType(Diagnostic.Kind kind) {\n-        return switch (kind) {\n-            case ERROR -> DiagnosticType.ERROR;\n-            case WARNING, MANDATORY_WARNING -> DiagnosticType.WARNING;\n-            case NOTE -> DiagnosticType.NOTE;\n-            case OTHER -> DiagnosticType.FRAGMENT;\n-        };\n-    }\n-\n-    \/**\n-     * Returns the diagnostic flags for a diagnostic kind.\n-     * A diagnostic kind of {@code MANDATORY_WARNING} requires the {@code MANDATORY} flag.\n-     *\n-     * @param kind the diagnostic kind\n-     * @return the flags\n-     *\/\n-    private Set<DiagnosticFlag> getDiagnosticFlags(Diagnostic.Kind kind) {\n-        return kind == Kind.MANDATORY_WARNING\n-                ? EnumSet.of(DiagnosticFlag.MANDATORY)\n-                : EnumSet.noneOf(DiagnosticFlag.class);\n-    }\n-\n-    \/**\n-     * Returns the diagnostic source for an documentation tree node.\n-     *\n-     * @param path the path for the documentation tree node\n-     * @return the diagnostic source\n-     *\/\n-    private DiagnosticSource getDiagnosticSource(DocTreePath path) {\n-        return getDiagnosticSource(path.getTreePath().getCompilationUnit().getSourceFile());\n-    }\n-\n-    \/**\n-     * Returns the diagnostic source for an element, or {@code NO_SOURCE} if the\n-     * source file is not known (for example, if the element was read from a class file).\n-     *\n-     * @param element the element\n-     * @return the diagnostic source\n-     *\/\n-    private DiagnosticSource getDiagnosticSource(Element element) {\n-        TreePath tp = getToolEnv().elementToTreePath.get(element);\n-        return tp == null ? DiagnosticSource.NO_SOURCE\n-                : getDiagnosticSource(tp.getCompilationUnit().getSourceFile());\n-    }\n-\n-    \/**\n-     * Returns the diagnostic source for a file object.\n-     *\n-     * {@code DiagnosticSource} objects are moderately expensive because they maintain\n-     * an internal copy of the content, to provide the line map.\n-     * Therefore, we keep a small memory-sensitive cache of recently used objects.\n-     *\n-     * @param fo the file object\n-     * @return the diagnostic source\n-     *\/\n-    private DiagnosticSource getDiagnosticSource(JavaFileObject fo) {\n-        Reference<DiagnosticSource> ref = diagSourceCache.get(fo);\n-        DiagnosticSource ds = ref == null ? null : ref.get();\n-        if (ds == null) {\n-            ds = new DiagnosticSource(fo, this);\n-            diagSourceCache.put(fo, new SoftReference<>(ds));\n-        }\n-        return ds;\n-    }\n-\n-    \/**\n-     * Returns the object for computing source positions.\n-     *\n-     * The value is determined lazily because the tool environment is computed lazily.\n-     *\n-     * @return the object for computing source positions\n-     *\/\n-    private DocSourcePositions getSourcePositions() {\n-        if (sourcePositions == null) {\n-            sourcePositions = getToolEnv().docTrees.getSourcePositions();\n-        }\n-        return sourcePositions;\n-    }\n-\n-    \/**\n-     * Returns the tool environment.\n-     *\n-     * The value is determined lazily, because creating it eagerly disrupts\n-     * the overall initialization of objects in the context.\n-     *\n-     * @return the tool environment\n-     *\/\n-    private ToolEnvironment getToolEnv() {\n-        if (toolEnv == null) {\n-            toolEnv = ToolEnvironment.instance(context);\n-        }\n-        return toolEnv;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/Messager.java","additions":0,"deletions":638,"binary":false,"changes":638,"status":"deleted"},{"patch":"@@ -87,1 +87,1 @@\n-    private Messager messager;\n+    private JavadocLog log;\n@@ -97,1 +97,1 @@\n-    \/\/ used to determine the locale for the messager\n+    \/\/ used to determine the locale for the log\n@@ -123,3 +123,3 @@\n-        this.messager = (outWriter == null && errWriter == null)\n-                ? new Messager(this.context, pname)\n-                : new Messager(this.context, pname, outWriter, errWriter);\n+        this.log = (outWriter == null && errWriter == null)\n+                ? new JavadocLog(this.context, pname)\n+                : new JavadocLog(this.context, pname, outWriter, errWriter);\n@@ -143,2 +143,2 @@\n-        if (log instanceof Messager m){\n-            messager = m;\n+        if (log instanceof JavadocLog l){\n+            this.log = l;\n@@ -147,3 +147,3 @@\n-            messager = (out == null)\n-                    ? new Messager(context, ProgramName)\n-                    : new Messager(context, ProgramName, out, out);\n+            this.log = (out == null)\n+                    ? new JavadocLog(context, ProgramName)\n+                    : new JavadocLog(context, ProgramName, out, out);\n@@ -186,1 +186,1 @@\n-        return new ToolOptions(context, messager, helper);\n+        return new ToolOptions(context, log, helper);\n@@ -198,1 +198,1 @@\n-        messager.notice(headerKey);\n+        log.noticeUsingKey(headerKey);\n@@ -208,1 +208,1 @@\n-            messager.notice(footerKey);\n+            log.noticeUsingKey(footerKey);\n@@ -212,1 +212,1 @@\n-        messager.notice(labelKey, messager.programName, value);\n+        log.noticeUsingKey(labelKey, log.programName, value);\n@@ -241,1 +241,1 @@\n-            parameters = sep + option.getParameters(messager);\n+            parameters = sep + option.getParameters(log);\n@@ -245,1 +245,1 @@\n-        String description = option.getDescription(messager);\n+        String description = option.getDescription(log);\n@@ -255,1 +255,1 @@\n-        messager.notice(\"main.doclet.usage.header\", name);\n+        log.noticeUsingKey(\"main.doclet.usage.header\", name);\n@@ -310,1 +310,1 @@\n-            messager.printNotice(String.format(COMPACT_FORMAT, synopses, description));\n+            log.notice(String.format(COMPACT_FORMAT, synopses, description));\n@@ -317,1 +317,1 @@\n-            messager.printNotice(SMALL_INDENT + synopses);\n+            log.notice(SMALL_INDENT + synopses);\n@@ -320,1 +320,1 @@\n-                messager.printNotice(SMALL_INDENT + name + parameters);\n+                log.notice(SMALL_INDENT + name + parameters);\n@@ -325,1 +325,1 @@\n-        messager.printNotice(LARGE_INDENT + description.replace(\"\\n\", \"\\n\" + LARGE_INDENT));\n+        log.notice(LARGE_INDENT + description.replace(\"\\n\", \"\\n\" + LARGE_INDENT));\n@@ -375,1 +375,1 @@\n-                    messager.printError(te.message);\n+                    log.printError(te.message);\n@@ -383,1 +383,1 @@\n-                messager.printError(oe.message);\n+                log.printError(oe.message);\n@@ -400,1 +400,1 @@\n-            messager.printRawLines(e.getMessage());\n+            log.printRawLines(e.getMessage());\n@@ -409,1 +409,1 @@\n-                messager.printError(oe.message);\n+                log.printError(oe.message);\n@@ -417,1 +417,1 @@\n-                messager.printError(exc.message);\n+                log.printError(exc.message);\n@@ -444,1 +444,1 @@\n-            if (this.options.rejectWarnings() && messager.hasWarnings()) {\n+            if (this.options.rejectWarnings() && log.hasWarnings()) {\n@@ -447,1 +447,1 @@\n-            boolean haveErrors = messager.hasErrors();\n+            boolean haveErrors = log.hasErrors();\n@@ -455,2 +455,2 @@\n-            messager.printErrorWarningCounts();\n-            messager.flush();\n+            log.printErrorWarningCounts();\n+            log.flush();\n@@ -462,1 +462,1 @@\n-        messager.printErrorUsingKey(\"doclet.internal.report.bug\");\n+        log.printErrorUsingKey(\"doclet.internal.report.bug\");\n@@ -496,2 +496,2 @@\n-        doclet.init(locale, messager);\n-        int beforeCount = messager.nerrors;\n+        doclet.init(locale, log);\n+        int beforeCount = log.nerrors;\n@@ -499,1 +499,1 @@\n-        int afterCount = messager.nerrors;\n+        int afterCount = log.nerrors;\n@@ -508,2 +508,2 @@\n-            if (!messager.hasErrors() && !messager.hasWarnings())\n-                messager.nerrors++;\n+            if (!log.hasErrors() && !log.hasWarnings())\n+                log.nerrors++;\n@@ -517,2 +517,2 @@\n-            if (!messager.hasErrors() && !messager.hasWarnings())\n-                messager.nerrors++;\n+            if (!log.hasErrors() && !log.hasWarnings())\n+                log.nerrors++;\n@@ -537,1 +537,1 @@\n-                    String text = messager.getText(\"main.No_modules_packages_or_classes_specified\");\n+                    String text = log.getText(\"main.No_modules_packages_or_classes_specified\");\n@@ -563,1 +563,1 @@\n-            messager.notice(\"main.done_in\", Long.toString(elapsedMillis));\n+            log.noticeUsingKey(\"main.done_in\", Long.toString(elapsedMillis));\n@@ -613,1 +613,1 @@\n-                            text = messager.getText(\"main.unnecessary_arg_provided\", argBase);\n+                            text = log.getText(\"main.unnecessary_arg_provided\", argBase);\n@@ -621,1 +621,1 @@\n-                            text = messager.getText(\"main.only_one_argument_with_equals\", argBase);\n+                            text = log.getText(\"main.only_one_argument_with_equals\", argBase);\n@@ -626,1 +626,1 @@\n-                        text = messager.getText(\"main.requires_argument\", arg);\n+                        text = log.getText(\"main.requires_argument\", arg);\n@@ -639,1 +639,1 @@\n-            text = messager.getText(\"main.invalid_flag\", arg);\n+            text = log.getText(\"main.invalid_flag\", arg);\n@@ -689,1 +689,1 @@\n-                    String text = messager.getText(\"main.more_than_one_doclet_specified_0_and_1\",\n+                    String text = log.getText(\"main.more_than_one_doclet_specified_0_and_1\",\n@@ -698,1 +698,1 @@\n-                    String text = messager.getText(\"main.more_than_one_doclet_specified_0_and_1\",\n+                    String text = log.getText(\"main.more_than_one_doclet_specified_0_and_1\",\n@@ -733,1 +733,1 @@\n-                            String text = messager.getText(\"main.doclet_could_not_set_location\",\n+                            String text = log.getText(\"main.doclet_could_not_set_location\",\n@@ -746,1 +746,1 @@\n-                        String text = messager.getText(\"main.doclet_no_classloader_found\",\n+                        String text = log.getText(\"main.doclet_no_classloader_found\",\n@@ -760,1 +760,1 @@\n-            messager.setLocale(Locale.getDefault());  \/\/ use default locale for console messages\n+            log.setLocale(Locale.getDefault());  \/\/ use default locale for console messages\n@@ -768,1 +768,1 @@\n-                String text = messager.getText(\"main.could_not_instantiate_class\", docletClass.getName());\n+                String text = log.getText(\"main.could_not_instantiate_class\", docletClass.getName());\n@@ -772,1 +772,1 @@\n-            String text = messager.getText(\"main.not_a_doclet\", docletClass.getName());\n+            String text = log.getText(\"main.not_a_doclet\", docletClass.getName());\n@@ -785,1 +785,1 @@\n-            String text = messager.getText(\"main.doclet_class_not_found\", docletName);\n+            String text = log.getText(\"main.doclet_class_not_found\", docletName);\n@@ -845,1 +845,1 @@\n-            String text = messager.getText(\"main.requires_argument\", args.get(index));\n+            String text = log.getText(\"main.requires_argument\", args.get(index));\n@@ -851,1 +851,1 @@\n-        messager.printErrorUsingKey(key, args);\n+        log.printErrorUsingKey(key, args);\n@@ -868,1 +868,1 @@\n-            String text = messager.getText(\"main.malformed_locale_name\", localeName);\n+            String text = log.getText(\"main.malformed_locale_name\", localeName);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/Start.java","additions":55,"deletions":55,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-    final Messager messager;\n+    final JavadocLog log;\n@@ -140,1 +140,1 @@\n-        messager = Messager.instance0(context);\n+        log = JavadocLog.instance0(context);\n@@ -202,1 +202,1 @@\n-        messager.notice(key);\n+        log.noticeUsingKey(key);\n@@ -215,1 +215,1 @@\n-        messager.notice(key, a1);\n+        log.noticeUsingKey(key, a1);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/ToolEnvironment.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -171,1 +171,1 @@\n-     * The messager to be used to report diagnostics..\n+     * The log to be used to report diagnostics..\n@@ -173,1 +173,1 @@\n-    private final Messager messager;\n+    private final JavadocLog log;\n@@ -184,1 +184,1 @@\n-     * @param messager the messager to be used to report diagnostics\n+     * @param log the log to be used to report diagnostics\n@@ -186,2 +186,2 @@\n-    ToolOptions(Context context, Messager messager, ShowHelper showHelper) {\n-        this.messager = messager;\n+    ToolOptions(Context context, JavadocLog log, ShowHelper showHelper) {\n+        this.log = log;\n@@ -203,1 +203,1 @@\n-        messager = null;\n+        log = null;\n@@ -649,1 +649,1 @@\n-        String getParameters(Messager messager) {\n+        String getParameters(JavadocLog log) {\n@@ -651,1 +651,1 @@\n-                    ? messager.getText(getKey(primaryName, \".arg\"))\n+                    ? log.getText(getKey(primaryName, \".arg\"))\n@@ -655,2 +655,2 @@\n-        String getDescription(Messager messager) {\n-            return messager.getText(getKey(primaryName, \".desc\"));\n+        String getDescription(JavadocLog log) {\n+            return log.getText(getKey(primaryName, \".desc\"));\n@@ -836,1 +836,1 @@\n-        return new IllegalOptionValue(showHelper::usage, messager.getText(\"main.illegal_option_value\", arg));\n+        return new IllegalOptionValue(showHelper::usage, log.getText(\"main.illegal_option_value\", arg));\n@@ -867,1 +867,1 @@\n-        return new OptionHelper.GrumpyHelper(messager) {\n+        return new OptionHelper.GrumpyHelper(log) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/ToolOptions.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -565,0 +565,16 @@\n+.PP\n+Event settings and .jfc options can also be specified using the following\n+syntax:\n+.TP\n+.B \\f[CB]option=\\f[R]\\f[I]value\\f[R]\n+Specifies the option value to modify. To list available options, use the\n+JAVA_HOME\/bin\/jfr tool.\n+.TP\n+.B \\f[CB]event-setting=\\f[R]\\f[I]value\\f[R]\n+Specifies the event setting value to modify. Use the form:\n+<event-name>#<setting-name>=<value>\n+To add a new event setting, prefix the event name with '+'.\n+.PP\n+In case of a conflict between a parameter and a .jfc option, the parameter\n+will take precedence. The whitespace delimiter can be omitted for timespan values, i.e. 20ms. For\n+more information about the settings syntax, see Javadoc of the jdk.jfr package.\n","filename":"src\/jdk.jcmd\/share\/man\/jcmd.1","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,1 +132,1 @@\n-HELP_ABOUT_DIALOG_USER_GUIDE_LINK_URL=http:\/\/docs.oracle.com\/javase\/{0}\/docs\/technotes\/guides\/management\/jconsole.html\n+HELP_ABOUT_DIALOG_USER_GUIDE_LINK_URL=http:\/\/www.oracle.com\/pls\/topic\/lookup?ctx=javase{0}&&id=using_jconsole\n","filename":"src\/jdk.jconsole\/share\/classes\/sun\/tools\/jconsole\/resources\/messages.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,1 +132,1 @@\n-HELP_ABOUT_DIALOG_USER_GUIDE_LINK_URL=http:\/\/docs.oracle.com\/javase\/{0}\/docs\/technotes\/guides\/management\/jconsole.html\n+HELP_ABOUT_DIALOG_USER_GUIDE_LINK_URL=http:\/\/www.oracle.com\/pls\/topic\/lookup?ctx=javase{0}&&id=using_jconsole\n","filename":"src\/jdk.jconsole\/share\/classes\/sun\/tools\/jconsole\/resources\/messages_ja.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,1 +132,1 @@\n-HELP_ABOUT_DIALOG_USER_GUIDE_LINK_URL=http:\/\/docs.oracle.com\/javase\/{0}\/docs\/technotes\/guides\/management\/jconsole.html\n+HELP_ABOUT_DIALOG_USER_GUIDE_LINK_URL=http:\/\/www.oracle.com\/pls\/topic\/lookup?ctx=javase{0}&&id=using_jconsole\n@@ -174,1 +174,1 @@\n-MANAGE_HOTSPOT_MBEANS_IN_COLON_=\\u7BA1\\u7406\\u4EE5\\u4E0B\\u4F4D\\u7F6E\\u7684 HotSpot MBean: \n+MANAGE_HOTSPOT_MBEANS_IN_COLON_=\\u7BA1\\u7406\\u4EE5\\u4E0B\\u4F4D\\u7F6E\\u7684 HotSpot MBean:\n","filename":"src\/jdk.jconsole\/share\/classes\/sun\/tools\/jconsole\/resources\/messages_zh_CN.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -862,1 +862,2 @@\n- \"  (see http:\/\/java.sun.com\/products\/jpda for more information)\\n\"\n+ \"  (See the \\\"VM Invocation Options\\\" section of the JPDA\\n\"\n+ \"   \\\"Connection and Invocation Details\\\" document for more information.)\\n\"\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/debugInit.c","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,5 @@\n-    JFR_DCMD(12);\n+    JFR_DCMD(12),\n+    \/**\n+     * -XX:StartFlightRecording\n+     *\/\n+    JFR_START(13);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/LogTag.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -448,6 +448,3 @@\n-        try {\n-            Field f = eventClass.getDeclaredField(EventInstrumentation.FIELD_EVENT_HANDLER);\n-            SecuritySupport.setAccessible(f);\n-            return (EventHandler) f.get(null);\n-        } catch (NoSuchFieldException | IllegalArgumentException | IllegalAccessException e) {\n-            throw new InternalError(\"Could not access event handler\");\n+        Object handler = JVM.getJVM().getHandler(eventClass);\n+        if (handler == null || handler instanceof EventHandler) {\n+            return (EventHandler) handler;\n@@ -455,0 +452,1 @@\n+        throw new InternalError(\"Could not access event handler\");\n@@ -459,6 +457,2 @@\n-        try {\n-            Field field = eventClass.getDeclaredField(EventInstrumentation.FIELD_EVENT_HANDLER);\n-            SecuritySupport.setAccessible(field);\n-            field.set(null, handler);\n-        } catch (NoSuchFieldException | IllegalArgumentException | IllegalAccessException e) {\n-            throw new InternalError(\"Could not access event handler\");\n+        if (!JVM.getJVM().setHandler(eventClass, handler)) {\n+            throw new InternalError(\"Could not set event handler\");\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Utils.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,3 @@\n+import jdk.jfr.internal.LogLevel;\n+import jdk.jfr.internal.LogTag;\n+import jdk.jfr.internal.Logger;\n@@ -53,0 +56,39 @@\n+    private String source;\n+\n+    \/\/ Called by native\n+    public abstract String[] printHelp();\n+\n+    \/\/ Called by native\n+    public abstract Argument[] getArgumentInfos();\n+\n+    \/\/ Called by native\n+    protected abstract void execute(ArgumentParser parser) throws DCmdException;\n+\n+\n+    \/\/ Called by native\n+    public final String[] execute(String source, String arg, char delimiter) throws DCmdException {\n+        this.source = source;\n+        try {\n+            boolean log = Logger.shouldLog(LogTag.JFR_DCMD, LogLevel.DEBUG);\n+            if (log) {\n+                System.out.println(arg);\n+                Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG, \"Executing \" + this.getClass().getSimpleName() + \": \" + arg);\n+            }\n+            ArgumentParser parser = new ArgumentParser(getArgumentInfos(), arg, delimiter);\n+            parser.parse();\n+            if (log) {\n+                Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG, \"DCMD options: \" + parser.getOptions());\n+                if (parser.hasExtendedOptions()) {\n+                    Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG, \"JFC options: \" + parser.getExtendedOptions());\n+                }\n+            }\n+            execute(parser);\n+            return getResult();\n+       }\n+       catch (IllegalArgumentException iae) {\n+            DCmdException e = new DCmdException(iae.getMessage());\n+            e.addSuppressed(iae);\n+            throw e;\n+        }\n+    }\n+\n@@ -58,1 +100,1 @@\n-    public final String[] getResult() {\n+    protected final String[] getResult() {\n@@ -62,0 +104,8 @@\n+    protected void logWarning(String message) {\n+        if (source.equals(\"internal\")) { \/\/ -XX:StartFlightRecording\n+            Logger.log(LogTag.JFR_START, LogLevel.WARN, message);\n+        } else { \/\/ DiagnosticMXBean or JCMD\n+            println(\"Warning! \" + message);\n+        }\n+    }\n+\n@@ -195,0 +245,24 @@\n+\n+    protected final String exampleRepository() {\n+        if (\"\\r\\n\".equals(System.lineSeparator())) {\n+            return \"C:\\\\Repositories\";\n+        } else {\n+            return \"\/Repositories\";\n+        }\n+    }\n+\n+    protected final String exampleFilename() {\n+        if (\"\\r\\n\".equals(System.lineSeparator())) {\n+            return \"C:\\\\Users\\\\user\\\\recording.jfr\";\n+        } else {\n+            return \"\/recordings\/recording.jfr\";\n+        }\n+    }\n+\n+    protected final String exampleDirectory() {\n+        if (\"\\r\\n\".equals(System.lineSeparator())) {\n+            return \"C:\\\\Directory\\\\recordings\";\n+        } else {\n+            return \"\/directory\/recordings\";\n+        }\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/AbstractDCmd.java","additions":76,"deletions":2,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.dcmd;\n+\n+record Argument(\n+    String name,\n+    String description,\n+    String type,\n+    boolean mandatory,\n+    String defaultValue,\n+    boolean allowMultiple\n+) { }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/Argument.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,337 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.dcmd;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+final class ArgumentParser {\n+    private final Map<String, Object> options = new HashMap<>();\n+    private final Map<String, Object> extendedOptions = new HashMap<>();\n+    private final StringBuilder builder = new StringBuilder();\n+    private final String text;\n+    private final char delimiter;\n+    private final String keyValueDelimiter;\n+    private final String valueDelimiter;\n+    private final Argument[] arguments;\n+    private int position;\n+\n+    ArgumentParser(Argument[] arguments, String text, char delimiter) {\n+        this.text = text;\n+        this.delimiter = delimiter;\n+        this.arguments = arguments;\n+        this.keyValueDelimiter = \"=\" + delimiter;\n+        this.valueDelimiter = Character.toString(delimiter);\n+    }\n+\n+    public Map<String, Object> parse() {\n+        eatDelimiter();\n+        while (!atEnd()) {\n+            String key = readText(keyValueDelimiter);\n+            String value = null;\n+            if (accept('=')) {\n+                value = readText(valueDelimiter);\n+            }\n+            if (!atEnd() && !accept(delimiter)) { \/\/ must be followed by delimiter\n+                throw new IllegalArgumentException(\"Expected delimiter, but found \" + currentChar());\n+            }\n+            addOption(key, value);\n+            eatDelimiter();\n+        }\n+        checkMandatory();\n+        return options;\n+    }\n+\n+    private void checkMandatory() {\n+        for (Argument arg : arguments) {\n+            if (!options.containsKey(arg.name())) {\n+                if (arg.mandatory()) {\n+                    throw new IllegalArgumentException(\"The argument '\" + arg.name() + \"' is mandatory\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    private void addOption(String key, String value) {\n+        boolean found = false;\n+        for (Argument arg : arguments) {\n+            if (arg.name().equals(key)) {\n+                found = true;\n+                Object v = value(key, arg.type(), value);\n+                if (arg.allowMultiple()) {\n+                    var list = (List<Object>) options.computeIfAbsent(key, x -> new ArrayList<>());\n+                    if (v instanceof List l) {\n+                        list.addAll(l);\n+                    } else {\n+                        list.add(v);\n+                    }\n+                } else {\n+                    if (options.containsKey(key)) {\n+                        throw new IllegalArgumentException(\"Duplicates in diagnostic command arguments\");\n+                    }\n+                    options.put(key, v);\n+                }\n+            }\n+        }\n+        if (!found) {\n+            extendedOptions.put(key, value);\n+        }\n+    }\n+\n+    private char currentChar() {\n+        return text.charAt(position);\n+    }\n+\n+    private char lastChar() {\n+        return text.charAt(position -1);\n+    }\n+\n+    private boolean atEnd() {\n+        return !(position < text.length());\n+    }\n+\n+    private void eatDelimiter() {\n+        while (!atEnd() && currentChar() == delimiter) {\n+            position++;\n+        }\n+    }\n+\n+    private boolean accept(char c) {\n+        if (!atEnd() && currentChar() == c) {\n+            position++;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    \/\/ Mostly copied from native DCmdParser\n+    private String readText(String abortChars) {\n+        builder.setLength(0);\n+        boolean quoted = false; ;\n+        while (position <= text.length() - 1 && abortChars.indexOf(currentChar()) == -1) {\n+          if (currentChar() == '\\\"' || currentChar() == '\\'') {\n+            char quote =currentChar();\n+            quoted = true;\n+            while (position < text.length() - 1) {\n+              position++;\n+              if (currentChar() == quote && lastChar() != '\\\\') {\n+                break;\n+              }\n+              builder.append(currentChar());\n+            }\n+            if (currentChar() != quote) {\n+              throw new IllegalArgumentException(\"Format error in diagnostic command arguments\");\n+            }\n+            break;\n+          }\n+          builder.append(currentChar());\n+          position++;\n+        }\n+        if (quoted) {\n+            position++;\n+        }\n+        return builder.toString();\n+    }\n+\n+    private Object value(String name, String type, String text) {\n+        return switch (type) {\n+            case \"STRING\", \"STRING SET\" -> text == null ? \"\" : text;\n+            case \"BOOLEAN\" -> parseBoolean(name, text);\n+            case \"NANOTIME\" -> parseNanotime(name, text);\n+            case \"MEMORY SIZE\" -> parseMemorySize(name, text);\n+            default -> throw new InternalError(\"Unknown type: \" + type);\n+        };\n+    }\n+\n+    private Boolean parseBoolean(String name, String text) {\n+        if (\"true\".equals(text)) {\n+            return Boolean.TRUE;\n+        }\n+        if (\"false\".equals(text)) {\n+            return Boolean.FALSE;\n+        }\n+        String msg = \"Boolean parsing error in command argument '\" + name + \"'. Could not parse: \" + text + \".\";\n+        throw new IllegalArgumentException(msg);\n+    }\n+\n+    private Object parseMemorySize(String name, String text) {\n+        if (text == null) {\n+            throw new IllegalArgumentException(\"Parsing error memory size value: syntax error, value is null\");\n+        }\n+        int index = indexOfUnit(text);\n+        String textValue = text.substring(0, index);\n+        String unit = text.substring(index);\n+        long bytes;\n+        try {\n+            bytes = Long.parseLong(textValue);\n+        } catch (NumberFormatException nfe) {\n+            throw new IllegalArgumentException(\"Parsing error memory size value: invalid value\");\n+        }\n+        if (bytes < 0) {\n+            throw new IllegalArgumentException(\"Parsing error memory size value: negative values not allowed\");\n+        }\n+        if (unit.isEmpty()) {\n+            return bytes;\n+        }\n+        return switch(unit.toLowerCase()) {\n+            case \"k\", \"kb\" -> bytes * 1024;\n+            case \"m\", \"mb\"-> bytes * 1024 * 1024;\n+            case \"g\", \"gb\" -> bytes * 1024 * 1024 * 1024;\n+            default -> throw new IllegalArgumentException(\"Parsing error memory size value: invalid value\");\n+        };\n+    }\n+\n+    private Object parseNanotime(String name, String text) {\n+        if (text == null) {\n+            throw new IllegalArgumentException(\"Integer parsing error nanotime value: syntax error, value is null\");\n+        }\n+        int index = indexOfUnit(text);\n+        String textValue = text.substring(0, index);\n+        String unit = text.substring(index);\n+        long time;\n+        try {\n+            time = Long.parseLong(textValue);\n+        } catch (NumberFormatException nfe) {\n+            throw new IllegalArgumentException(\"Integer parsing error nanotime value: syntax error\");\n+        }\n+        if (unit.isEmpty()) {\n+            if (time == 0) {\n+                return Long.valueOf(0);\n+            }\n+            throw new IllegalArgumentException(\"Integer parsing error nanotime value: unit required\");\n+        }\n+        return switch(unit) {\n+            case \"ns\" -> time;\n+            case \"us\" -> time * 1000;\n+            case \"ms\" -> time * 1000 * 1000;\n+            case \"s\" -> time * 1000 * 1000 * 1000;\n+            case \"m\" -> time * 60 * 1000 * 1000 * 1000;\n+            case \"h\" -> time * 60 * 60* 1000 * 1000 * 1000;\n+            case \"d\" -> time * 24 * 60 * 60 * 1000 * 1000 * 1000;\n+            default -> throw new IllegalArgumentException(\"Integer parsing error nanotime value: illegal unit\");\n+        };\n+    }\n+\n+    int indexOfUnit(String text) {\n+        for (int i = 0; i< text.length(); i++) {\n+            char c = text.charAt(i);\n+            if (i == 0 && c == '-') { \/\/ Accept negative values.\n+                continue;\n+            }\n+            if (!Character.isDigit(c)) {\n+                return i;\n+            }\n+        }\n+        return text.length();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    <T> T getOption(String name) {\n+        return (T) options.get(name);\n+    }\n+\n+    Map<String, Object> getOptions() {\n+        return options;\n+    }\n+\n+    void checkUnknownArguments() {\n+        if (!extendedOptions.isEmpty()) {\n+            String name = extendedOptions.keySet().iterator().next();\n+            throw new IllegalArgumentException(\"Unknown argument '\"  + name + \"' in diagnostic command.\");\n+        }\n+    }\n+\n+    Map<String, Object> getExtendedOptions() {\n+        return extendedOptions;\n+    }\n+\n+    boolean hasExtendedOptions() {\n+        return !extendedOptions.isEmpty();\n+    }\n+\n+    void checkSpelling(Set<String> excludeSet) {\n+        for (String name : extendedOptions.keySet()) {\n+            if (!excludeSet.contains(name)) { \/\/ ignore names specified in .jfc\n+                checkSpellingError(name);\n+            }\n+        }\n+    }\n+\n+    private void checkSpellingError(String name) {\n+        for (Argument a : arguments) {\n+            String expected = a.name();\n+            String s = name.toLowerCase();\n+            int lengthDifference = expected.length() - s.length();\n+            boolean spellingError = false;\n+            if (lengthDifference == 0) {\n+                if (expected.equals(s)) {\n+                    spellingError = true; \/\/ incorrect case, or we wouldn't be here\n+                } else {\n+                    if (s.length() < 6) {\n+                        spellingError = diff(expected, s) < 2; \/\/ one incorrect letter\n+                    } else {\n+                        spellingError = diff(expected, s) < 3; \/\/ two incorrect letter\n+                    }\n+                }\n+            }\n+            if (lengthDifference == 1) {\n+                spellingError = inSequence(expected, s); \/\/ missing letter\n+            }\n+            if (lengthDifference == -1) {\n+                spellingError = inSequence(s, expected); \/\/ additional letter\n+            }\n+            if (spellingError) {\n+                throw new IllegalArgumentException(\"Error! Did you mean '\" + expected + \"' instead of '\" + name + \"'?\");\n+            }\n+        }\n+    }\n+\n+    private int diff(String a, String b) {\n+        int count = a.length();\n+        for (int i = 0; i < a.length(); i++) {\n+            if (a.charAt(i) == b.charAt(i)) {\n+                count--;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    private boolean inSequence(String longer, String shorter) {\n+        int l = 0;\n+        int s = 0;\n+        while (l < longer.length() && s < shorter.length()) {\n+            if (longer.charAt(l) == shorter.charAt(s)) {\n+                s++;\n+            }\n+            l++;\n+        }\n+        return shorter.length() == s; \/\/ if 0, all letters in longer found in shorter\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/ArgumentParser.java","additions":337,"deletions":0,"binary":false,"changes":337,"status":"added"},{"patch":"@@ -39,3 +39,0 @@\n-import jdk.jfr.internal.LogLevel;\n-import jdk.jfr.internal.LogTag;\n-import jdk.jfr.internal.Logger;\n@@ -49,16 +46,0 @@\n-    \/**\n-     * Execute JFR.check\n-     *\n-     * @param recordingText name or id of the recording to check, or\n-     *        {@code null} to show a list of all recordings.\n-     *\n-     * @param verbose if event settings should be included.\n-     *\n-     * @return result output\n-     *\n-     * @throws DCmdException if the check could not be completed.\n-     *\/\n-    public String[] execute(String recordingText, Boolean verbose) throws DCmdException {\n-        executeInternal(recordingText, verbose);\n-        return getResult();\n-    }\n@@ -66,4 +47,5 @@\n-    private void executeInternal(String name, Boolean verbose) throws DCmdException {\n-        if (Logger.shouldLog(LogTag.JFR_DCMD, LogLevel.DEBUG)) {\n-            Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG, \"Executing DCmdCheck: name=\" + name + \", verbose=\" + verbose);\n-        }\n+    @Override\n+    protected void execute(ArgumentParser parser) throws DCmdException {\n+        parser.checkUnknownArguments();\n+        Boolean verbose = parser.getOption(\"verbose\");\n+        String name = parser.getOption(\"name\");\n@@ -164,0 +146,38 @@\n+\n+    @Override\n+    public String[] printHelp() {\n+            \/\/ 0123456789001234567890012345678900123456789001234567890012345678900123456789001234567890\n+        return \"\"\"\n+               Syntax : JFR.check [options]\n+\n+               Options:\n+\n+                 name     (Optional) Name of the flight recording. (STRING, no default value)\n+\n+                 verbose  (Optional) Flag for printing the event settings for the recording\n+                          (BOOLEAN, false)\n+\n+               Options must be specified using the <key> or <key>=<value> syntax.\n+\n+               Example usage:\n+\n+                $ jcmd <pid> JFR.check\n+                $ jcmd <pid> JFR.check verbose=true\n+                $ jcmd <pid> JFR.check name=1\n+                $ jcmd <pid> JFR.check name=benchmark\n+                $ jcmd <pid> JFR.check name=2 verbose=true\n+\n+               \"\"\".lines().toArray(String[]::new);\n+    }\n+\n+    @Override\n+    public Argument[] getArgumentInfos() {\n+        return new Argument[] {\n+            new Argument(\"name\",\n+                \"Recording name, e.g. \\\\\\\"My Recording\\\\\\\" or omit to see all recordings\",\n+                \"STRING\", false, null, false),\n+            new Argument(\"verbose\",\n+                \"Print event settings for the recording(s)\",\"BOOLEAN\",\n+                false, \"false\", false)\n+        };\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdCheck.java","additions":43,"deletions":23,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -244,0 +244,15 @@\n+\n+    @Override\n+    public String[] printHelp() {\n+        throw new InternalError(\"Should not reach here!\");\n+    }\n+\n+    @Override\n+    public Argument[] getArgumentInfos() {\n+        throw new InternalError(\"Should not reach here!\");\n+    }\n+\n+    @Override\n+    protected void execute(ArgumentParser parser) throws DCmdException {\n+        throw new InternalError(\"Should not reach here!\");\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdConfigure.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,3 +40,0 @@\n-import jdk.jfr.internal.LogLevel;\n-import jdk.jfr.internal.LogTag;\n-import jdk.jfr.internal.Logger;\n@@ -56,27 +53,11 @@\n-    \/**\n-     * Execute JFR.dump.\n-     *\n-     * @param name name or id of the recording to dump, or {@code null} to dump everything\n-     *\n-     * @param filename file path where recording should be written, not null\n-     * @param maxAge how far back in time to dump, may be null\n-     * @param maxSize how far back in size to dump data from, may be null\n-     * @param begin point in time to dump data from, may be null\n-     * @param end point in time to dump data to, may be null\n-     * @param pathToGcRoots if Java heap should be swept for reference chains\n-     *\n-     * @return result output\n-     *\n-     * @throws DCmdException if the dump could not be completed\n-     *\/\n-    public String[] execute(String name, String filename, Long maxAge, Long maxSize, String begin, String end, Boolean pathToGcRoots) throws DCmdException {\n-        if (Logger.shouldLog(LogTag.JFR_DCMD, LogLevel.DEBUG)) {\n-            Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG,\n-                    \"Executing DCmdDump: name=\" + name +\n-                    \", filename=\" + filename +\n-                    \", maxage=\" + maxAge +\n-                    \", maxsize=\" + maxSize +\n-                    \", begin=\" + begin +\n-                    \", end=\" + end +\n-                    \", path-to-gc-roots=\" + pathToGcRoots);\n-        }\n+\n+    @Override\n+    public void execute(ArgumentParser parser) throws DCmdException {\n+        parser.checkUnknownArguments();\n+        String name = parser.getOption(\"name\");\n+        String filename = parser.getOption(\"filename\");\n+        Long maxAge = parser.getOption(\"maxage\");\n+        Long maxSize = parser.getOption(\"maxsize\");\n+        String begin = parser.getOption(\"begin\");\n+        String end = parser.getOption(\"end\");\n+        Boolean pathToGcRoots = parser.getOption(\"path-to-gc-roots\");\n@@ -137,1 +118,0 @@\n-        return getResult();\n@@ -216,0 +196,104 @@\n+    @Override\n+    public String[] printHelp() {\n+            \/\/ 0123456789001234567890012345678900123456789001234567890012345678900123456789001234567890\n+        return \"\"\"\n+               Syntax : JFR.dump [options]\n+\n+               Options:\n+\n+                 begin           (Optional) Specify the time from which recording data will be included\n+                                 in the dump file. The format is specified as local time.\n+                                 (STRING, no default value)\n+\n+                 end             (Optional) Specify the time to which recording data will be included\n+                                 in the dump file. The format is specified as local time.\n+                                 (STRING, no default value)\n+\n+                                 Note: For both begin and end, the time must be in a format that can\n+                                 be read by any of these methods:\n+\n+                                  java.time.LocalTime::parse(String),\n+                                  java.time.LocalDateTime::parse(String)\n+                                  java.time.Instant::parse(String)\n+\n+                                 For example, \"13:20:15\", \"2020-03-17T09:00:00\" or\n+                                 \"2020-03-17T09:00:00Z\".\n+\n+                                 Note: begin and end times correspond to the timestamps found within\n+                                 the recorded information in the flight recording data.\n+\n+                                 Another option is to use a time relative to the current time that is\n+                                 specified by a negative integer followed by \"s\", \"m\" or \"h\".\n+                                 For example, \"-12h\", \"-15m\" or \"-30s\"\n+\n+                 filename        (Optional) Name of the file to which the flight recording data is\n+                                 dumped. If no filename is given, a filename is generated from the PID\n+                                 and the current date. The filename may also be a directory in which\n+                                 case, the filename is generated from the PID and the current date in\n+                                 the specified directory. (STRING, no default value)\n+\n+                 maxage          (Optional) Length of time for dumping the flight recording data to a\n+                                 file. (INTEGER followed by 's' for seconds 'm' for minutes or 'h' for\n+                                 hours, no default value)\n+\n+                 maxsize         (Optional) Maximum size for the amount of data to dump from a flight\n+                                 recording in bytes if one of the following suffixes is not used:\n+                                 'm' or 'M' for megabytes OR 'g' or 'G' for gigabytes.\n+                                 (STRING, no default value)\n+\n+                 name            (Optional) Name of the recording. If no name is given, data from all\n+                                 recordings is dumped. (STRING, no default value)\n+\n+                 path-to-gc-root (Optional) Flag for saving the path to garbage collection (GC) roots\n+                                 at the time the recording data is dumped. The path information is\n+                                 useful for finding memory leaks but collecting it can cause the\n+                                 application to pause for a short period of time. Turn on this flag\n+                                 only when you have an application that you suspect has a memory\n+                                 leak. (BOOLEAN, false)\n+\n+               Options must be specified using the <key> or <key>=<value> syntax.\n+\n+               Example usage:\n+\n+                $ jcmd <pid> JFR.dump\n+                $ jcmd <pid> JFR.dump filename=recording.jfr\n+                $ jcmd <pid> JFR.dump filename=%s\n+                $ jcmd <pid> JFR.dump name=1 filename=%s\n+                $ jcmd <pid> JFR.dump maxage=1h\n+                $ jcmd <pid> JFR.dump maxage=1h maxsize=50M\n+                $ jcmd <pid> JFR.dump fillename=leaks.jfr path-to-gc-root=true\n+                $ jcmd <pid> JFR.dump begin=13:15\n+                $ jcmd <pid> JFR.dump begin=13:15 end=21:30:00\n+                $ jcmd <pid> JFR.dump end=18:00 maxage=10m\n+                $ jcmd <pid> JFR.dump begin=2021-09-15T09:00:00 end=2021-09-15T10:00:00\n+                $ jcmd <pid> JFR.dump begin=-1h\n+                $ jcmd <pid> JFR.dump begin=-15m end=-5m\n+\n+               \"\"\".formatted(exampleDirectory(), exampleFilename()).lines().toArray(String[]::new);\n+    }\n+\n+    @Override\n+    public Argument[] getArgumentInfos() {\n+        return new Argument[] {\n+           new Argument(\"name\",\n+               \"Recording name, e.g. \\\\\\\"My Recording\\\\\\\"\",\n+               \"STRING\", false, null, false),\n+           new Argument(\"filename\",\n+               \"Copy recording data to file, e.g. \\\\\\\"\" + exampleFilename() + \"\\\\\\\"\",\n+               \"STRING\", false, null, false),\n+           new Argument(\"maxage\",\n+               \"Maximum duration to dump, in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or 0 for no limit\",\n+               \"NANOTIME\", false, null, false),\n+           new Argument(\"maxsize\", \"Maximum amount of bytes to dump, in (M)B or (G)B, e.g. 500M, or 0 for no limit\",\n+               \"MEMORY SIZE\", false, \"hotspot-pid-xxxxx-id-y-YYYY_MM_dd_HH_mm_ss.jfr\", false),\n+           new Argument(\"begin\",\n+               \"Point in time to dump data from, e.g. 09:00, 21:35:00, 2018-06-03T18:12:56.827Z, 2018-06-03T20:13:46.832, -10m, -3h, or -1d\",\n+               \"STRING\", false, null, false),\n+           new Argument(\"end\",\n+               \"Point in time to dump data to, e.g. 09:00, 21:35:00, 2018-06-03T18:12:56.827Z, 2018-06-03T20:13:46.832, -10m, -3h, or -1d\",\n+               \"STRING\", false, null, false),\n+           new Argument(\"path-to-gc-roots\",\n+               \"Collect path to GC roots\",\n+               \"BOOLEAN\", false, \"false\", false)\n+        };\n+    }\n@@ -217,0 +301,1 @@\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdDump.java","additions":117,"deletions":32,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,4 @@\n-import java.util.Arrays;\n-import java.util.HashMap;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n@@ -38,0 +40,1 @@\n+import java.util.Set;\n@@ -42,3 +45,0 @@\n-import jdk.jfr.internal.LogLevel;\n-import jdk.jfr.internal.LogTag;\n-import jdk.jfr.internal.Logger;\n@@ -51,0 +51,2 @@\n+import jdk.jfr.internal.jfc.model.JFCModel;\n+import jdk.jfr.internal.jfc.model.XmlInput;\n@@ -59,39 +61,11 @@\n-    \/**\n-     * Execute JFR.start.\n-     *\n-     * @param name optional name that can be used to identify recording.\n-     * @param settings names of settings files to use, i.e. \"default\" or\n-     *        \"default.jfc\".\n-     * @param delay delay before recording is started, in nanoseconds. Must be\n-     *        at least 1 second.\n-     * @param duration duration of the recording, in nanoseconds. Must be at\n-     *        least 1 second.\n-     * @param disk if recording should be persisted to disk\n-     * @param path file path where recording data should be written\n-     * @param maxAge how long recording data should be kept in the disk\n-     *        repository, or {@code 0} if no limit should be set.\n-     *\n-     * @param maxSize the minimum amount data to keep in the disk repository\n-     *        before it is discarded, or {@code 0} if no limit should be\n-     *        set.\n-     *\n-     * @param dumpOnExit if recording should dump on exit\n-     *\n-     * @return result output\n-     *\n-     * @throws DCmdException if recording could not be started\n-     *\/\n-    @SuppressWarnings(\"resource\")\n-    public String[] execute(String name, String[] settings, Long delay, Long duration, Boolean disk, String path, Long maxAge, Long maxSize, Long flush, Boolean dumpOnExit, Boolean pathToGcRoots) throws DCmdException {\n-        if (Logger.shouldLog(LogTag.JFR_DCMD, LogLevel.DEBUG)) {\n-            Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG, \"Executing DCmdStart: name=\" + name +\n-                    \", settings=\" + Arrays.asList(settings) +\n-                    \", delay=\" + delay +\n-                    \", duration=\" + duration +\n-                    \", disk=\" + disk+\n-                    \", filename=\" + path +\n-                    \", maxage=\" + maxAge +\n-                    \", flush-interval=\" + flush +\n-                    \", maxsize=\" + maxSize +\n-                    \", dumponexit=\" + dumpOnExit +\n-                    \", path-to-gc-roots=\" + pathToGcRoots);\n+    private Object source;\n+\n+    @Override\n+    public void execute(ArgumentParser parser) throws DCmdException {\n+        String name = parser.getOption(\"name\");\n+        List<String> list = parser.getOption(\"settings\");\n+        String[] settings = null;\n+        if (list == null) {\n+            settings = new String[] {\"default.jfc\"};\n+        } else {\n+            settings = list.toArray(new String[0]);\n@@ -99,0 +73,13 @@\n+        if (settings.length == 1 && \"none\".equals(settings[0])) {\n+            settings = new String[0];\n+        }\n+        Long delay = parser.getOption(\"delay\");\n+        Long duration = parser.getOption(\"duration\");\n+        Boolean disk = parser.getOption(\"disk\");\n+        String path = parser.getOption(\"filename\");\n+        Long maxAge = parser.getOption(\"maxage\");\n+        Long maxSize = parser.getOption(\"maxsize\");\n+        Long flush = parser.getOption(\"flush-interval\");\n+        Boolean dumpOnExit = parser.getOption(\"dumponexit\");\n+        Boolean pathToGcRoots = parser.getOption(\"path-to-gc-roots\");\n+\n@@ -114,9 +101,6 @@\n-        Map<String, String> s = new HashMap<>();\n-        for (String configName : settings) {\n-            try {\n-                s.putAll(JFC.createKnown(configName).getSettings());\n-            } catch(FileNotFoundException e) {\n-                throw new DCmdException(\"Could not find settings file'\" + configName + \"'\", e);\n-            } catch (IOException | ParseException e) {\n-                throw new DCmdException(\"Could not parse settings file '\" + settings[0] + \"'\", e);\n-            }\n+\n+        LinkedHashMap<String, String> s;\n+        if (parser.hasExtendedOptions()) {\n+           s = configureExtended(settings, parser);\n+        } else {\n+           s = configureStandard(settings);\n@@ -239,0 +223,1 @@\n+    }\n@@ -240,1 +225,12 @@\n-        return getResult();\n+    private LinkedHashMap<String, String> configureStandard(String[] settings) throws DCmdException {\n+        LinkedHashMap<String, String> s = new LinkedHashMap<>();\n+        for (String configName : settings) {\n+            try {\n+                s.putAll(JFC.createKnown(configName).getSettings());\n+            } catch(FileNotFoundException e) {\n+                throw new DCmdException(\"Could not find settings file'\" + configName + \"'\", e);\n+            } catch (IOException | ParseException e) {\n+                throw new DCmdException(\"Could not parse settings file '\" + settings[0] + \"'\", e);\n+            }\n+        }\n+        return s;\n@@ -243,0 +239,36 @@\n+    private LinkedHashMap<String, String> configureExtended(String[] settings, ArgumentParser parser) throws DCmdException {\n+        List<SafePath> paths = new ArrayList<>();\n+        for (String setting : settings) {\n+            paths.add(JFC.createSafePath(setting));\n+        }\n+        try {\n+            JFCModel model = new JFCModel(paths);\n+            Set<String> jfcOptions = new HashSet<>();\n+            for (XmlInput input : model.getInputs()) {\n+                jfcOptions.add(input.getName());\n+            }\n+            parser.checkSpelling(jfcOptions);\n+            Map<String, String> jfcSettings = model.getSettings();\n+            for (var entry : parser.getExtendedOptions().entrySet()) {\n+                String value = (String)entry.getValue();\n+                String optionName = entry.getKey();\n+                boolean added = optionName.startsWith(\"+\");\n+                if (!added && !jfcOptions.contains(optionName) && !jfcSettings.containsKey(optionName)) {\n+                    \/\/ Option\/setting doesn't exist and it is not a spelling error.\n+                    \/\/ By not throwing an exception, and instead print a warning,\n+                    \/\/ it is easier migrate to a newer JDK version without\n+                    \/\/ breaking startup scripts\n+                     logWarning(\"The .jfc option\/setting '\" + optionName + \"' doesn't exist.\");\n+                } else {\n+                    model.configure(entry.getKey(), value);\n+                }\n+            }\n+            return model.getSettings();\n+         } catch (IllegalArgumentException iae) {\n+             throw new DCmdException(iae.getMessage()); \/\/ spelling error, invalid value\n+         } catch (FileNotFoundException ioe) {\n+             throw new DCmdException(\"Could not find settings file'\" + settings[0] + \"'\", ioe);\n+         } catch (IOException | ParseException e) {\n+             throw new DCmdException(\"Could not parse settings file '\" + settings[0] + \"'\", e);\n+         }\n+    }\n@@ -274,0 +306,150 @@\n+\n+    @Override\n+    public String[] printHelp() {\n+        \/\/ 0123456789001234567890012345678900123456789001234567890012345678900123456789001234567890\n+        return \"\"\"\n+               Syntax : JFR.start [options]\n+\n+               Options:\n+\n+                 delay           (Optional) Length of time to wait before starting to record\n+                                 (INTEGER followed by 's' for seconds 'm' for minutes or h' for\n+                                 hours, 0s)\n+\n+                 disk            (Optional) Flag for also writing the data to disk while recording\n+                                 (BOOLEAN, true)\n+\n+                 dumponexit      (Optional) Flag for writing the recording to disk when the Java\n+                                 Virtual Machine (JVM) shuts down. If set to 'true' and no value\n+                                 is given for filename, the recording is written to a file in the\n+                                 directory where the process was started. The file name is a\n+                                 system-generated name that contains the process ID, the recording\n+                                 ID and the current time stamp. (For example:\n+                                 id-1-2021_09_14_09_00.jfr) (BOOLEAN, false)\n+\n+                 duration        (Optional) Length of time to record. Note that 0s means forever\n+                                 (INTEGER followed by 's' for seconds 'm' for minutes or 'h' for\n+                                 hours, 0s)\n+\n+                 filename        (Optional) Name of the file to which the flight recording data is\n+                                 written when the recording is stopped. If no filename is given, a\n+                                 filename is generated from the PID and the current date and is\n+                                 placed in the directory where the process was started. The\n+                                 filename may also be a directory in which case, the filename is\n+                                 generated from the PID and the current date in the specified\n+                                 directory. (STRING, no default value)\n+\n+                 maxage          (Optional) Maximum time to keep the recorded data on disk. This\n+                                 parameter is valid only when the disk parameter is set to true.\n+                                 Note 0s means forever. (INTEGER followed by 's' for seconds 'm'\n+                                 for minutes or 'h' for hours, 0s)\n+\n+                 maxsize         (Optional) Maximum size of the data to keep on disk in bytes if\n+                                 one of the following suffixes is not used: 'm' or 'M' for\n+                                 megabytes OR 'g' or 'G' for gigabytes. This parameter is valid\n+                                 only when the disk parameter is set to 'true'. The value must not\n+                                 be less than the value for the maxchunksize parameter set with\n+                                 the JFR.configure command. (STRING, 0 (no max size))\n+\n+                 name            (Optional) Name of the recording. If no name is provided, a name\n+                                 is generated. Make note of the generated name that is shown in\n+                                 the response to the command so that you can use it with other\n+                                 commands. (STRING, system-generated default name)\n+\n+                 path-to-gc-root (Optional) Flag for saving the path to garbage collection (GC)\n+                                 roots at the end of a recording. The path information is useful\n+                                 for finding memory leaks but collecting it is time consuming.\n+                                 Turn on this flag only when you have an application that you\n+                                 suspect has a memory leak. If the settings parameter is set to\n+                                 'profile', then the information collected includes the stack\n+                                 trace from where the potential leaking object wasallocated.\n+                                 (BOOLEAN, false)\n+\n+                 settings        (Optional) Name of the settings file that identifies which events\n+                                 to record. To specify more than one file, use the settings\n+                                 parameter repeatedly. Include the path if the file is not in\n+                                 JAVA-HOME\/lib\/jfr. The following profiles are included with the\n+                                 JDK in the JAVA-HOME\/lib\/jfr directory: 'default.jfc': collects a\n+                                 predefined set of information with low overhead, so it has minimal\n+                                 impact on performance and can be used with recordings that run\n+                                 continuously; 'profile.jfc': Provides more data than the\n+                                 'default.jfc' profile, but with more overhead and impact on\n+                                 performance. Use this configuration for short periods of time\n+                                 when more information is needed. Use none to start a recording\n+                                 without a predefined configuration file. (STRING,\n+                                 JAVA-HOME\/lib\/jfr\/default.jfc)\n+\n+               Event settings and .jfc options can also be specified using the following syntax:\n+\n+                 jfc-option=value    (Optional) The option value to modify. To see available\n+                                     options for a .jfc file, use the 'jfr configure' command.\n+\n+                 event-setting=value (Optional) The event setting value to modify. Use the form:\n+                                     <event-name>#<setting-name>=<value>\n+                                     To add a new event setting, prefix the event name with '+'.\n+\n+               In case of a conflict between a parameter and a .jfc option, the parameter will\n+               take  precedence. The whitespace character can be omitted for timespan values,\n+               i.e. 20s. For more information about the settings syntax, see Javadoc of the\n+               jdk.jfr package.\n+\n+               Options must be specified using the <key> or <key>=<value> syntax.\n+\n+               Example usage:\n+\n+                $ jcmd <pid> JFR.start\n+                $ jcmd <pid> JFR.start filename=dump.jfr\n+                $ jcmd <pid> JFR.start filename=%s\n+                $ jcmd <pid> JFR.start dumponexit=true\n+                $ jcmd <pid> JFR.start maxage=1h,maxsize=1000M\n+                $ jcmd <pid> JFR.start settings=profile\n+                $ jcmd <pid> JFR.start delay=5m,settings=my.jfc\n+                $ jcmd <pid> JFR.start gc=high method-profiling=high\n+                $ jcmd <pid> JFR.start jdk.JavaMonitorEnter#threshold=1ms\n+                $ jcmd <pid> JFR.start +HelloWorld#enabled=true +HelloWorld#stackTrace=true\n+                $ jcmd <pid> JFR.start settings=user.jfc com.example.UserDefined#enabled=true\n+                $ jcmd <pid> JFR.start settings=none +Hello#enabled=true\n+\n+               Note, if the default event settings are modified, overhead may exceed 1%%.\n+\n+               \"\"\".formatted(exampleDirectory()).lines().toArray(String[]::new);\n+    }\n+\n+    @Override\n+    public Argument[] getArgumentInfos() {\n+        return new Argument[] {\n+            new Argument(\"name\",\n+                \"Name that can be used to identify recording, e.g. \\\\\\\"My Recording\\\\\\\"\",\n+                \"STRING\", false, null, false),\n+            new Argument(\"settings\",\n+                \"Settings file(s), e.g. profile or default. See JAVA_HOME\/lib\/jfr\",\n+                \"STRING SET\", false, \"deafult.jfc\", true),\n+            new Argument(\"delay\",\n+                \"Delay recording start with (s)econds, (m)inutes), (h)ours), or (d)ays, e.g. 5h.\",\n+                \"NANOTIME\", false, \"0s\", false),\n+            new Argument(\"duration\",\n+                \"Duration of recording in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 300s.\",\n+                \"NANOTIME\", false, null, false),\n+            new Argument(\"disk\",\n+                \"Recording should be persisted to disk\",\n+                \"BOOLEAN\", false, \"true\", false),\n+            new Argument(\"filename\",\n+                \"Resulting recording filename, e.g. \\\\\\\"\" + exampleFilename() +  \"\\\\\\\"\",\n+                \"STRING\", false, \"hotspot-pid-xxxxx-id-y-YYYY_MM_dd_HH_mm_ss.jfr\", false),\n+            new Argument(\"maxage\",\n+                \"Maximum time to keep recorded data (on disk) in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or 0 for no limit\",\n+                \"NANOTIME\", false, \"0\", false),\n+            new Argument(\"maxsize\",\n+                \"Maximum amount of bytes to keep (on disk) in (k)B, (M)B or (G)B, e.g. 500M, or 0 for no limit\",\n+                \"MEMORY SIZE\", false, \"250M\", false),\n+            new Argument(\"flush-interval\",\n+                \"Dump running recording when JVM shuts down\",\n+                \"NANOTIME\", false, \"1s\", false),\n+            new Argument(\"dumponexit\",\n+                \"Minimum time before flushing buffers, measured in (s)econds, e.g. 4 s, or 0 for flushing when a recording ends\",\n+                \"BOOLEAN\", false, \"false\", false),\n+            new Argument(\"path-to-gc-roots\",\n+                \"Collect path to GC roots\",\n+                \"BOOLEAN\", false, \"false\", false)\n+        };\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdStart.java","additions":237,"deletions":55,"binary":false,"changes":292,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,0 @@\n-import jdk.jfr.internal.LogLevel;\n-import jdk.jfr.internal.LogTag;\n-import jdk.jfr.internal.Logger;\n@@ -44,19 +41,5 @@\n-    \/**\n-     * Execute JFR.stop\n-     *\n-     * Requires that either {@code name} or {@code id} is set.\n-     *\n-     * @param name name or id of the recording to stop.\n-     *\n-     * @param filename file path where data should be written after recording has\n-     *        been stopped, or {@code null} if recording shouldn't be written\n-     *        to disk.\n-     * @return result text\n-     *\n-     * @throws DCmdException if recording could not be stopped\n-     *\/\n-    public String[] execute(String name, String filename) throws DCmdException {\n-        if (Logger.shouldLog(LogTag.JFR_DCMD, LogLevel.DEBUG)) {\n-            Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG, \"Executing DCmdStart: name=\" + name + \", filename=\" + filename);\n-        }\n-\n+    @Override\n+    protected void execute(ArgumentParser parser)  throws DCmdException {\n+        parser.checkUnknownArguments();\n+        String name = parser.getOption(\"name\");\n+        String filename = parser.getOption(\"filename\");\n@@ -79,1 +62,0 @@\n-            return getResult();\n@@ -87,0 +69,38 @@\n+\n+    @Override\n+    public String[] printHelp() {\n+            \/\/ 0123456789001234567890012345678900123456789001234567890012345678900123456789001234567890\n+        return \"\"\"\n+               Syntax : JFR.stop [options]\n+\n+               Options:\n+\n+                 filename  (Optional) Name of the file to which the recording is written when the\n+                           recording is stopped. If no path is provided, the data from the recording\n+                           is discarded. (STRING, no default value)\n+\n+                 name      Name of the recording (STRING, no default value)\n+\n+               Options must be specified using the <key> or <key>=<value> syntax.\n+\n+               Example usage:\n+\n+                $ jcmd <pid> JFR.stop name=1\n+                $ jcmd <pid> JFR.stop name=benchmark filename=%s\n+                $ jcmd <pid> JFR.stop name=5 filename=recording.jfr\n+\n+               \"\"\".formatted(exampleDirectory()).\n+               lines().toArray(String[]::new);\n+    }\n+\n+    @Override\n+    public Argument[] getArgumentInfos() {\n+        return new Argument[] {\n+            new Argument(\"name\",\n+                \"Recording text,.e.g \\\\\\\"My Recording\\\\\\\"\",\n+                \"STRING\", true, null, false),\n+            new Argument(\"filename\",\n+                \"Copy recording data to file, e.g. \\\\\\\"\" + exampleFilename() +  \"\\\\\\\"\",\n+                \"STRING\", false, null, false)\n+        };\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdStop.java","additions":44,"deletions":24,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -120,0 +120,26 @@\n+    \/**\n+     * Create a path to a .jfc file.\n+     * <p>\n+     * If the name is predefined name,\n+     * i.e. \"default\" or \"profile.jfc\", it will return the path for\n+     * the predefined path in the JDK.\n+     *\n+     * @param path textual representation of the path\n+     *\n+     * @return a safe path, not null\n+     *\/\n+    public static SafePath createSafePath(String path) {\n+        for (SafePath predefined : SecuritySupport.getPredefinedJFCFiles()) {\n+            try {\n+                String name = JFC.nameFromPath(predefined.toPath());\n+                if (name.equals(path) || (name + \".jfc\").equals(path)) {\n+                    return predefined;\n+                }\n+            } catch (IOException e) {\n+                throw new InternalError(\"Error in predefined .jfc file\", e);\n+            }\n+        }\n+        return new SafePath(path);\n+    }\n+\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/jfc\/JFC.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -123,0 +123,10 @@\n+    public LinkedHashMap<String, String> getSettings() {\n+        LinkedHashMap<String, String> result = new LinkedHashMap<>();\n+        for (XmlEvent event : configuration.getEvents()) {\n+            for (XmlSetting setting : event.getSettings()) {\n+                result.put(event.getName() + \"#\" + setting.getName(), setting.getContent());\n+            }\n+        }\n+        return result;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/jfc\/model\/JFCModel.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-            paths.add(makeSafePath(name));\n+            paths.add(JFC.createSafePath(name));\n@@ -244,13 +244,0 @@\n-    private SafePath makeSafePath(String path) {\n-        for (SafePath predefined : SecuritySupport.getPredefinedJFCFiles()) {\n-            try {\n-                String name = JFC.nameFromPath(predefined.toPath());\n-                if (name.equals(path) || (name + \".jfc\").equals(path)) {\n-                    return predefined;\n-                }\n-            } catch (IOException e) {\n-                throw new InternalError(\"Error in predefined .jfc file\", e);\n-            }\n-        }\n-        return new SafePath(path);\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Configure.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -349,0 +349,6 @@\n+    <event name=\"jdk.SystemGC\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"threshold\">0 ms<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -349,0 +349,6 @@\n+    <event name=\"jdk.SystemGC\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"threshold\">0 ms<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting> \n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -161,2 +161,4 @@\n-        ResourcePool result = generateJImage(allContent,\n-             writer, plugins, plugins.getJImageFileOutputStream());\n+        ResourcePool result;\n+        try (DataOutputStream out = plugins.getJImageFileOutputStream()) {\n+            result = generateJImage(allContent, writer, plugins, out);\n+        }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImageFileCreator.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.nio.file.FileVisitResult;\n@@ -44,0 +45,2 @@\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n@@ -228,0 +231,1 @@\n+        Path outputPath = null;\n@@ -268,0 +272,1 @@\n+            outputPath = config.getOutput();\n@@ -282,2 +287,8 @@\n-        } catch (PluginException | IllegalArgumentException |\n-                 UncheckedIOException |IOException | ResolutionException e) {\n+        } catch (PluginException | UncheckedIOException | IOException e) {\n+            log.println(taskHelper.getMessage(\"error.prefix\") + \" \" + e.getMessage());\n+            if (DEBUG) {\n+                e.printStackTrace(log);\n+            }\n+            cleanupOutput(outputPath);\n+            return EXIT_ERROR;\n+        } catch (IllegalArgumentException | ResolutionException e) {\n@@ -301,0 +312,1 @@\n+            cleanupOutput(outputPath);\n@@ -307,0 +319,13 @@\n+    private void cleanupOutput(Path dir) {\n+        try {\n+            if (dir != null && Files.isDirectory(dir)) {\n+                deleteDirectory(dir);\n+            }\n+        } catch (IOException io) {\n+            log.println(taskHelper.getMessage(\"error.prefix\") + \" \" + io.getMessage());\n+            if (DEBUG) {\n+                io.printStackTrace(log);\n+            }\n+        }\n+    }\n+\n@@ -471,0 +496,22 @@\n+    private static void deleteDirectory(Path dir) throws IOException {\n+        Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                    throws IOException {\n+                Files.delete(file);\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override\n+            public FileVisitResult postVisitDirectory(Path dir, IOException e)\n+                    throws IOException {\n+                if (e == null) {\n+                    Files.delete(dir);\n+                    return FileVisitResult.CONTINUE;\n+                } else {\n+                    \/\/ directory iteration failed.\n+                    throw e;\n+                }\n+            }\n+        });\n+    }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":49,"deletions":2,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -423,1 +423,1 @@\n-                    throw new PluginException(PluginsResourceBundle.\n+                    throw new IllegalArgumentException(PluginsResourceBundle.\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/TaskHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.Optional;\n@@ -49,0 +50,1 @@\n+import static jdk.jpackage.internal.StandardBundlerParam.ABOUT_URL;\n@@ -440,0 +442,3 @@\n+        data.put(\"APPLICATION_HOMEPAGE\", Optional.ofNullable(\n+                ABOUT_URL.fetchFrom(params)).map(value -> \"Homepage: \" + value).orElse(\n+                \"\"));\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebBundler.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.util.Optional;\n@@ -47,0 +48,1 @@\n+import static jdk.jpackage.internal.StandardBundlerParam.ABOUT_URL;\n@@ -190,0 +192,3 @@\n+        data.put(\"APPLICATION_URL\", Optional.ofNullable(ABOUT_URL.fetchFrom(\n+                params)).orElse(\"\"));\n+\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmBundler.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -11,0 +11,1 @@\n+APPLICATION_HOMEPAGE\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/resources\/template.control","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -8,0 +8,4 @@\n+%if \"xAPPLICATION_URL\" != \"x\"\n+URL: APPLICATION_URL\n+%endif\n+\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/resources\/template.spec","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -663,2 +663,4 @@\n-    const tstring::size_type pos = path.rfind(_T(\".exe\"));\n-    if (pos == tstring::npos) {\n+    \/\/ allow for \".*\" (last dot beyond the last slash)\n+    const tstring::size_type pos = path.rfind(_T(\".\"));\n+    const tstring::size_type spos = path.rfind(_T(\"\\\\\/\"));\n+    if (pos == tstring::npos || (spos > pos && spos != tstring::npos)) {\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/WinFileUtils.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -66,2 +66,7 @@\n-static void next_line(FILE *f) {\n-    while (fgetc(f) != '\\n');\n+static int next_line(FILE *f) {\n+    int c;\n+    do {\n+        c = fgetc(f);\n+    } while (c != '\\n' && c != EOF);\n+\n+    return c;\n@@ -96,1 +101,4 @@\n-    next_line(fh);\n+    if (next_line(fh) == EOF) {\n+        fclose(fh);\n+        return -2;\n+    }\n@@ -109,1 +117,4 @@\n-            next_line(fh);\n+            if (next_line(fh) == EOF) {\n+                fclose(fh);\n+                return -2;\n+            }\n","filename":"src\/jdk.management\/linux\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,0 +167,1 @@\n+        int thickness = 1;\n@@ -169,0 +170,1 @@\n+            thickness = 2;\n@@ -177,1 +179,1 @@\n-        middleWidget.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createLineBorder(borderColor, 1), BorderFactory.createLineBorder(innerBorderColor, 1)));\n+        middleWidget.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createLineBorder(borderColor, thickness), BorderFactory.createLineBorder(innerBorderColor, 1)));\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/FigureWidget.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.awt.BasicStroke;\n@@ -106,0 +107,3 @@\n+                g.setStroke(new BasicStroke(1.5f));\n+            } else {\n+                g.setStroke(new BasicStroke(1f));\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/SlotWidget.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-JAVA_RELEASE = 7\n+JAVA_RELEASE = 15\n@@ -119,1 +119,0 @@\n-\n","filename":"test\/failure_handler\/Makefile","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-The library requires jtreg 4b13+ and JDK 7+.\n+The library requires jtreg 4b13+ and JDK 15+.\n@@ -105,1 +105,0 @@\n-\n","filename":"test\/failure_handler\/README","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.failurehandler;\n+\n+import java.nio.file.Path;\n+\n+public interface CoreInfoGatherer {\n+    void gatherCoreInfo(HtmlSection section, Path core);\n+}\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/CoreInfoGatherer.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,4 @@\n+    public CoreInfoGatherer getCoreInfoGatherer() {\n+        return create();\n+    }\n+\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/GathererFactory.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.io.IOException;\n@@ -30,0 +31,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -35,0 +38,1 @@\n+import java.util.zip.GZIPInputStream;\n@@ -36,1 +40,1 @@\n-public class ToolKit implements EnvironmentInfoGatherer, ProcessInfoGatherer {\n+public class ToolKit implements EnvironmentInfoGatherer, ProcessInfoGatherer, CoreInfoGatherer {\n@@ -39,0 +43,1 @@\n+    private final PrintWriter log;\n@@ -42,0 +47,1 @@\n+        this.log = log;\n@@ -54,0 +60,21 @@\n+    @Override\n+    public void gatherCoreInfo(HtmlSection section, Path core) {\n+        if (core.getFileName().toString().endsWith(\".gz\")) {\n+            Path unpackedCore = Path.of(core.toString().replace(\".gz\", \"\"));\n+            try (GZIPInputStream gzis = new GZIPInputStream(Files.newInputStream(core))) {\n+                Files.copy(gzis, unpackedCore);\n+                for (ActionSet set : actions) {\n+                    set.gatherCoreInfo(section, unpackedCore);\n+                }\n+                Files.delete(unpackedCore);\n+            } catch (IOException ioe) {\n+                log.printf(\"Unexpected exception whilc opening %s\", core.getFileName().toString());\n+                ioe.printStackTrace(log);\n+            }\n+        } else {\n+            for (ActionSet set : actions) {\n+                set.gatherCoreInfo(section, core);\n+            }\n+        }\n+    }\n+\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/ToolKit.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import com.sun.tools.attach.VirtualMachine;\n-import com.sun.tools.attach.VirtualMachineDescriptor;\n@@ -137,1 +135,1 @@\n-    private File findApp(String app) {\n+    public File findApp(String app) {\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/action\/ActionHelper.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import jdk.test.failurehandler.CoreInfoGatherer;\n@@ -31,0 +32,1 @@\n+import java.io.IOException;\n@@ -32,0 +34,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -35,0 +39,1 @@\n+import java.util.zip.GZIPInputStream;\n@@ -36,1 +41,1 @@\n-public class ActionSet implements ProcessInfoGatherer, EnvironmentInfoGatherer {\n+public class ActionSet implements ProcessInfoGatherer, EnvironmentInfoGatherer, CoreInfoGatherer {\n@@ -39,0 +44,2 @@\n+    private static final String CORES_PROPERTY = \"cores\";\n+\n@@ -49,0 +56,1 @@\n+    private final List<PatternAction> coreActions;\n@@ -58,0 +66,1 @@\n+        coreActions = getPatternActions(log, p, CORES_PROPERTY);\n@@ -126,0 +135,7 @@\n+\n+    @Override\n+    public void gatherCoreInfo(HtmlSection section, Path core) {\n+        for (PatternAction action : coreActions) {\n+            helper.runPatternAction(action, section, core.toString());\n+        }\n+    }\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/action\/ActionSet.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,3 @@\n+        for (int i = 0, n = args.length; i < n; ++i) {\n+            args[i] = args[i].replace(\"%java\", helper.findApp(\"java\").getAbsolutePath());\n+        }\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/action\/PatternAction.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.nio.file.Files;\n@@ -38,2 +39,0 @@\n-import java.util.HashMap;\n-import java.util.Map;\n@@ -48,0 +47,2 @@\n+    public static final String CORES_OUTPUT = \"cores.html\";\n+\n@@ -67,1 +68,1 @@\n-        PrintWriter log;\n+        PrintWriter log1;\n@@ -70,1 +71,1 @@\n-            log = new PrintWriter(new FileWriter(\n+            log1 = new PrintWriter(new FileWriter(\n@@ -74,2 +75,2 @@\n-            log = new PrintWriter(System.out);\n-            log.printf(\"ERROR: %s cannot open log file %s\", name,\n+            log1 = new PrintWriter(System.out);\n+            log1.printf(\"ERROR: %s cannot open log file %s\", name,\n@@ -77,1 +78,1 @@\n-            e.printStackTrace(log);\n+            e.printStackTrace(log1);\n@@ -79,0 +80,1 @@\n+        final PrintWriter log = log1;\n@@ -86,0 +88,5 @@\n+            Files.walk(workDir)\n+                    .filter(Files::isRegularFile)\n+                    .filter(f -> (f.getFileName().toString().contains(\"core\") || f.getFileName().toString().contains(\"mdmp\")))\n+                    .forEach(core -> gatherCoreInfo(workDir, name,\n+                            core, log, gathererFactory.getCoreInfoGatherer()));\n@@ -99,0 +106,16 @@\n+    private void gatherCoreInfo(Path workDir, String name, Path core, PrintWriter log,\n+                               CoreInfoGatherer gatherer) {\n+        File output = workDir.resolve(CORES_OUTPUT).toFile();\n+        try (HtmlPage html = new HtmlPage(new PrintWriter(\n+                new FileWriter(output, true), true))) {\n+            try (ElapsedTimePrinter timePrinter\n+                         = new ElapsedTimePrinter(new Stopwatch(), name, log)) {\n+                gatherer.gatherCoreInfo(html.getRootSection(), core);\n+            }\n+        } catch (Throwable e) {\n+            log.printf(\"ERROR: exception in observer on getting environment \"\n+                    + \"information %s:\", name);\n+            e.printStackTrace(log);\n+        }\n+    }\n+\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/jtreg\/GatherDiagnosticInfoObserver.java","additions":31,"deletions":8,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  jstack\n+  jstack jhsdb.jstack\n@@ -54,0 +54,1 @@\n+jcmd.vm.info.args=%p VM.info\n@@ -63,0 +64,9 @@\n+jhsdb.app=jhsdb\n+jhsdb.jstack.args=jstack --mixed --pid %p\n+jhsdb.jstack.params.repeat=6\n+\n+cores=jhsdb.jstack\n+jhsdb.jstack.app=jhsdb\n+# Assume that java standard laucher has been used\n+jhsdb.jstack.args=jstack --mixed --core %p --exe %java\n+\n","filename":"test\/failure_handler\/src\/share\/conf\/common.properties","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+\n@@ -58,0 +59,7 @@\n+\n+cores=native.gdb\n+native.gdb.app=gdb\n+# Assume that java standard laucher has been used\n+native.gdb.args=%java\\0-c\\0%p\\0-batch\\0-ex\\0thread apply all backtrace\n+native.gdb.args.delimiter=\\0\n+\n@@ -126,1 +134,0 @@\n-\n","filename":"test\/failure_handler\/src\/share\/conf\/linux.properties","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +67,7 @@\n+\n+cores=native.lldb\n+native.lldb.app=lldb\n+native.lldb.delimiter=\\0\n+# Assume that java standard laucher has been used\n+native.lldb.args=--core\\0%p\\0%java\\0-o\\0thread backtrace all\\0-o\\0quit\n+\n","filename":"test\/failure_handler\/src\/share\/conf\/mac.properties","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1487,0 +1487,8 @@\n+          [\"cmhi\", \"cmhi\", \"8B\"], [\"cmhi\", \"cmhi\", \"16B\"],\n+          [\"cmhi\", \"cmhi\", \"4H\"], [\"cmhi\", \"cmhi\", \"8H\"],\n+          [\"cmhi\", \"cmhi\", \"2S\"], [\"cmhi\", \"cmhi\", \"4S\"],\n+          [\"cmhi\", \"cmhi\", \"2D\"],\n+          [\"cmhs\", \"cmhs\", \"8B\"], [\"cmhs\", \"cmhs\", \"16B\"],\n+          [\"cmhs\", \"cmhs\", \"4H\"], [\"cmhs\", \"cmhs\", \"8H\"],\n+          [\"cmhs\", \"cmhs\", \"2S\"], [\"cmhs\", \"cmhs\", \"4S\"],\n+          [\"cmhs\", \"cmhs\", \"2D\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -676,10 +676,24 @@\n-    __ fcmgt(v14, __ T2S, v15, v16);                   \/\/       fcmgt   v14.2S, v15.2S, v16.2S\n-    __ fcmgt(v21, __ T4S, v22, v23);                   \/\/       fcmgt   v21.4S, v22.4S, v23.4S\n-    __ fcmgt(v3, __ T2D, v4, v5);                      \/\/       fcmgt   v3.2D, v4.2D, v5.2D\n-    __ cmge(v23, __ T8B, v24, v25);                    \/\/       cmge    v23.8B, v24.8B, v25.8B\n-    __ cmge(v8, __ T16B, v9, v10);                     \/\/       cmge    v8.16B, v9.16B, v10.16B\n-    __ cmge(v24, __ T4H, v25, v26);                    \/\/       cmge    v24.4H, v25.4H, v26.4H\n-    __ cmge(v19, __ T8H, v20, v21);                    \/\/       cmge    v19.8H, v20.8H, v21.8H\n-    __ cmge(v15, __ T2S, v16, v17);                    \/\/       cmge    v15.2S, v16.2S, v17.2S\n-    __ cmge(v16, __ T4S, v17, v18);                    \/\/       cmge    v16.4S, v17.4S, v18.4S\n-    __ cmge(v2, __ T2D, v3, v4);                       \/\/       cmge    v2.2D, v3.2D, v4.2D\n+    __ cmhi(v14, __ T8B, v15, v16);                    \/\/       cmhi    v14.8B, v15.8B, v16.8B\n+    __ cmhi(v21, __ T16B, v22, v23);                   \/\/       cmhi    v21.16B, v22.16B, v23.16B\n+    __ cmhi(v3, __ T4H, v4, v5);                       \/\/       cmhi    v3.4H, v4.4H, v5.4H\n+    __ cmhi(v23, __ T8H, v24, v25);                    \/\/       cmhi    v23.8H, v24.8H, v25.8H\n+    __ cmhi(v8, __ T2S, v9, v10);                      \/\/       cmhi    v8.2S, v9.2S, v10.2S\n+    __ cmhi(v24, __ T4S, v25, v26);                    \/\/       cmhi    v24.4S, v25.4S, v26.4S\n+    __ cmhi(v19, __ T2D, v20, v21);                    \/\/       cmhi    v19.2D, v20.2D, v21.2D\n+    __ cmhs(v15, __ T8B, v16, v17);                    \/\/       cmhs    v15.8B, v16.8B, v17.8B\n+    __ cmhs(v16, __ T16B, v17, v18);                   \/\/       cmhs    v16.16B, v17.16B, v18.16B\n+    __ cmhs(v2, __ T4H, v3, v4);                       \/\/       cmhs    v2.4H, v3.4H, v4.4H\n+    __ cmhs(v1, __ T8H, v2, v3);                       \/\/       cmhs    v1.8H, v2.8H, v3.8H\n+    __ cmhs(v0, __ T2S, v1, v2);                       \/\/       cmhs    v0.2S, v1.2S, v2.2S\n+    __ cmhs(v24, __ T4S, v25, v26);                    \/\/       cmhs    v24.4S, v25.4S, v26.4S\n+    __ cmhs(v4, __ T2D, v5, v6);                       \/\/       cmhs    v4.2D, v5.2D, v6.2D\n+    __ fcmgt(v3, __ T2S, v4, v5);                      \/\/       fcmgt   v3.2S, v4.2S, v5.2S\n+    __ fcmgt(v11, __ T4S, v12, v13);                   \/\/       fcmgt   v11.4S, v12.4S, v13.4S\n+    __ fcmgt(v30, __ T2D, v31, v0);                    \/\/       fcmgt   v30.2D, v31.2D, v0.2D\n+    __ cmge(v27, __ T8B, v28, v29);                    \/\/       cmge    v27.8B, v28.8B, v29.8B\n+    __ cmge(v9, __ T16B, v10, v11);                    \/\/       cmge    v9.16B, v10.16B, v11.16B\n+    __ cmge(v25, __ T4H, v26, v27);                    \/\/       cmge    v25.4H, v26.4H, v27.4H\n+    __ cmge(v2, __ T8H, v3, v4);                       \/\/       cmge    v2.8H, v3.8H, v4.8H\n+    __ cmge(v12, __ T2S, v13, v14);                    \/\/       cmge    v12.2S, v13.2S, v14.2S\n+    __ cmge(v17, __ T4S, v18, v19);                    \/\/       cmge    v17.4S, v18.4S, v19.4S\n+    __ cmge(v30, __ T2D, v31, v0);                     \/\/       cmge    v30.2D, v31.2D, v0.2D\n@@ -687,2 +701,2 @@\n-    __ fcmge(v0, __ T4S, v1, v2);                      \/\/       fcmge   v0.4S, v1.4S, v2.4S\n-    __ fcmge(v24, __ T2D, v25, v26);                   \/\/       fcmge   v24.2D, v25.2D, v26.2D\n+    __ fcmge(v12, __ T4S, v13, v14);                   \/\/       fcmge   v12.4S, v13.4S, v14.4S\n+    __ fcmge(v28, __ T2D, v29, v30);                   \/\/       fcmge   v28.2D, v29.2D, v30.2D\n@@ -782,9 +796,9 @@\n-    __ swp(Assembler::xword, r4, r3, r12);             \/\/       swp     x4, x3, [x12]\n-    __ ldadd(Assembler::xword, zr, r28, r10);          \/\/       ldadd   xzr, x28, [x10]\n-    __ ldbic(Assembler::xword, r26, r2, r12);          \/\/       ldclr   x26, x2, [x12]\n-    __ ldeor(Assembler::xword, r16, zr, r1);           \/\/       ldeor   x16, xzr, [x1]\n-    __ ldorr(Assembler::xword, r13, r29, r0);          \/\/       ldset   x13, x29, [x0]\n-    __ ldsmin(Assembler::xword, r19, r12, r17);        \/\/       ldsmin  x19, x12, [x17]\n-    __ ldsmax(Assembler::xword, r22, r13, r28);        \/\/       ldsmax  x22, x13, [x28]\n-    __ ldumin(Assembler::xword, r30, zr, r1);          \/\/       ldumin  x30, xzr, [x1]\n-    __ ldumax(Assembler::xword, r26, r28, r4);         \/\/       ldumax  x26, x28, [x4]\n+    __ swp(Assembler::xword, r0, r19, r12);            \/\/       swp     x0, x19, [x12]\n+    __ ldadd(Assembler::xword, r17, r22, r13);         \/\/       ldadd   x17, x22, [x13]\n+    __ ldbic(Assembler::xword, r28, r30, sp);          \/\/       ldclr   x28, x30, [sp]\n+    __ ldeor(Assembler::xword, r1, r26, r28);          \/\/       ldeor   x1, x26, [x28]\n+    __ ldorr(Assembler::xword, r4, r30, r4);           \/\/       ldset   x4, x30, [x4]\n+    __ ldsmin(Assembler::xword, r6, r30, r26);         \/\/       ldsmin  x6, x30, [x26]\n+    __ ldsmax(Assembler::xword, r16, r9, r8);          \/\/       ldsmax  x16, x9, [x8]\n+    __ ldumin(Assembler::xword, r12, r0, r20);         \/\/       ldumin  x12, x0, [x20]\n+    __ ldumax(Assembler::xword, r1, r24, r2);          \/\/       ldumax  x1, x24, [x2]\n@@ -793,9 +807,9 @@\n-    __ swpa(Assembler::xword, r30, r4, r6);            \/\/       swpa    x30, x4, [x6]\n-    __ ldadda(Assembler::xword, r30, r26, r15);        \/\/       ldadda  x30, x26, [x15]\n-    __ ldbica(Assembler::xword, r9, r8, r12);          \/\/       ldclra  x9, x8, [x12]\n-    __ ldeora(Assembler::xword, r0, r20, r1);          \/\/       ldeora  x0, x20, [x1]\n-    __ ldorra(Assembler::xword, r24, r2, r0);          \/\/       ldseta  x24, x2, [x0]\n-    __ ldsmina(Assembler::xword, r9, r24, r26);        \/\/       ldsmina x9, x24, [x26]\n-    __ ldsmaxa(Assembler::xword, r16, r30, r3);        \/\/       ldsmaxa x16, x30, [x3]\n-    __ ldumina(Assembler::xword, r10, r23, r10);       \/\/       ldumina x10, x23, [x10]\n-    __ ldumaxa(Assembler::xword, r4, r16, r2);         \/\/       ldumaxa x4, x16, [x2]\n+    __ swpa(Assembler::xword, r0, r9, r24);            \/\/       swpa    x0, x9, [x24]\n+    __ ldadda(Assembler::xword, r26, r16, r30);        \/\/       ldadda  x26, x16, [x30]\n+    __ ldbica(Assembler::xword, r3, r10, r23);         \/\/       ldclra  x3, x10, [x23]\n+    __ ldeora(Assembler::xword, r10, r4, r15);         \/\/       ldeora  x10, x4, [x15]\n+    __ ldorra(Assembler::xword, r2, r11, r8);          \/\/       ldseta  x2, x11, [x8]\n+    __ ldsmina(Assembler::xword, r10, r15, r17);       \/\/       ldsmina x10, x15, [x17]\n+    __ ldsmaxa(Assembler::xword, r2, r10, r12);        \/\/       ldsmaxa x2, x10, [x12]\n+    __ ldumina(Assembler::xword, r12, r15, r13);       \/\/       ldumina x12, x15, [x13]\n+    __ ldumaxa(Assembler::xword, r2, r7, r20);         \/\/       ldumaxa x2, x7, [x20]\n@@ -804,9 +818,9 @@\n-    __ swpal(Assembler::xword, r11, r8, r10);          \/\/       swpal   x11, x8, [x10]\n-    __ ldaddal(Assembler::xword, r15, r17, r2);        \/\/       ldaddal x15, x17, [x2]\n-    __ ldbical(Assembler::xword, r10, r12, r12);       \/\/       ldclral x10, x12, [x12]\n-    __ ldeoral(Assembler::xword, r15, r13, r2);        \/\/       ldeoral x15, x13, [x2]\n-    __ ldorral(Assembler::xword, r7, r20, r26);        \/\/       ldsetal x7, x20, [x26]\n-    __ ldsminal(Assembler::xword, r16, r4, r2);        \/\/       ldsminal        x16, x4, [x2]\n-    __ ldsmaxal(Assembler::xword, r4, r12, r15);       \/\/       ldsmaxal        x4, x12, [x15]\n-    __ lduminal(Assembler::xword, r21, r16, r15);      \/\/       lduminal        x21, x16, [x15]\n-    __ ldumaxal(Assembler::xword, r11, r21, r23);      \/\/       ldumaxal        x11, x21, [x23]\n+    __ swpal(Assembler::xword, r26, r16, r4);          \/\/       swpal   x26, x16, [x4]\n+    __ ldaddal(Assembler::xword, r2, r4, r12);         \/\/       ldaddal x2, x4, [x12]\n+    __ ldbical(Assembler::xword, r16, r21, r16);       \/\/       ldclral x16, x21, [x16]\n+    __ ldeoral(Assembler::xword, r16, r11, r21);       \/\/       ldeoral x16, x11, [x21]\n+    __ ldorral(Assembler::xword, r23, r12, r26);       \/\/       ldsetal x23, x12, [x26]\n+    __ ldsminal(Assembler::xword, r23, r28, r14);      \/\/       ldsminal        x23, x28, [x14]\n+    __ ldsmaxal(Assembler::xword, r11, r24, r1);       \/\/       ldsmaxal        x11, x24, [x1]\n+    __ lduminal(Assembler::xword, r12, zr, r10);       \/\/       lduminal        x12, xzr, [x10]\n+    __ ldumaxal(Assembler::xword, r16, r7, r2);        \/\/       ldumaxal        x16, x7, [x2]\n@@ -815,9 +829,9 @@\n-    __ swpl(Assembler::xword, r12, r26, r23);          \/\/       swpl    x12, x26, [x23]\n-    __ ldaddl(Assembler::xword, r28, r14, r11);        \/\/       ldaddl  x28, x14, [x11]\n-    __ ldbicl(Assembler::xword, r24, r1, r12);         \/\/       ldclrl  x24, x1, [x12]\n-    __ ldeorl(Assembler::xword, zr, r10, r16);         \/\/       ldeorl  xzr, x10, [x16]\n-    __ ldorrl(Assembler::xword, r7, r2, r3);           \/\/       ldsetl  x7, x2, [x3]\n-    __ ldsminl(Assembler::xword, r13, r19, r17);       \/\/       ldsminl x13, x19, [x17]\n-    __ ldsmaxl(Assembler::xword, r16, r3, r1);         \/\/       ldsmaxl x16, x3, [x1]\n-    __ lduminl(Assembler::xword, r11, r30, r5);        \/\/       lduminl x11, x30, [x5]\n-    __ ldumaxl(Assembler::xword, r8, r15, r29);        \/\/       ldumaxl x8, x15, [x29]\n+    __ swpl(Assembler::xword, r3, r13, r19);           \/\/       swpl    x3, x13, [x19]\n+    __ ldaddl(Assembler::xword, r17, r16, r3);         \/\/       ldaddl  x17, x16, [x3]\n+    __ ldbicl(Assembler::xword, r1, r11, r30);         \/\/       ldclrl  x1, x11, [x30]\n+    __ ldeorl(Assembler::xword, r5, r8, r15);          \/\/       ldeorl  x5, x8, [x15]\n+    __ ldorrl(Assembler::xword, r29, r30, r0);         \/\/       ldsetl  x29, x30, [x0]\n+    __ ldsminl(Assembler::xword, r20, r7, r20);        \/\/       ldsminl x20, x7, [x20]\n+    __ ldsmaxl(Assembler::xword, r23, r28, r21);       \/\/       ldsmaxl x23, x28, [x21]\n+    __ lduminl(Assembler::xword, r27, r25, r5);        \/\/       lduminl x27, x25, [x5]\n+    __ ldumaxl(Assembler::xword, r1, r23, r16);        \/\/       ldumaxl x1, x23, [x16]\n@@ -826,9 +840,9 @@\n-    __ swp(Assembler::word, r30, r0, r20);             \/\/       swp     w30, w0, [x20]\n-    __ ldadd(Assembler::word, r7, r20, r23);           \/\/       ldadd   w7, w20, [x23]\n-    __ ldbic(Assembler::word, r28, r21, r27);          \/\/       ldclr   w28, w21, [x27]\n-    __ ldeor(Assembler::word, r25, r5, r1);            \/\/       ldeor   w25, w5, [x1]\n-    __ ldorr(Assembler::word, r23, r16, sp);           \/\/       ldset   w23, w16, [sp]\n-    __ ldsmin(Assembler::word, r5, r12, r9);           \/\/       ldsmin  w5, w12, [x9]\n-    __ ldsmax(Assembler::word, r28, r15, r29);         \/\/       ldsmax  w28, w15, [x29]\n-    __ ldumin(Assembler::word, r22, zr, r19);          \/\/       ldumin  w22, wzr, [x19]\n-    __ ldumax(Assembler::word, zr, r5, r14);           \/\/       ldumax  wzr, w5, [x14]\n+    __ swp(Assembler::word, zr, r5, r12);              \/\/       swp     wzr, w5, [x12]\n+    __ ldadd(Assembler::word, r9, r28, r15);           \/\/       ldadd   w9, w28, [x15]\n+    __ ldbic(Assembler::word, r29, r22, sp);           \/\/       ldclr   w29, w22, [sp]\n+    __ ldeor(Assembler::word, r19, zr, r5);            \/\/       ldeor   w19, wzr, [x5]\n+    __ ldorr(Assembler::word, r14, r16, sp);           \/\/       ldset   w14, w16, [sp]\n+    __ ldsmin(Assembler::word, r16, r27, r20);         \/\/       ldsmin  w16, w27, [x20]\n+    __ ldsmax(Assembler::word, r16, r12, r11);         \/\/       ldsmax  w16, w12, [x11]\n+    __ ldumin(Assembler::word, r9, r6, r30);           \/\/       ldumin  w9, w6, [x30]\n+    __ ldumax(Assembler::word, r17, r27, r28);         \/\/       ldumax  w17, w27, [x28]\n@@ -837,9 +851,9 @@\n-    __ swpa(Assembler::word, r16, zr, r15);            \/\/       swpa    w16, wzr, [x15]\n-    __ ldadda(Assembler::word, r27, r20, r16);         \/\/       ldadda  w27, w20, [x16]\n-    __ ldbica(Assembler::word, r12, r11, r9);          \/\/       ldclra  w12, w11, [x9]\n-    __ ldeora(Assembler::word, r6, r30, r17);          \/\/       ldeora  w6, w30, [x17]\n-    __ ldorra(Assembler::word, r27, r28, r30);         \/\/       ldseta  w27, w28, [x30]\n-    __ ldsmina(Assembler::word, r7, r10, r20);         \/\/       ldsmina w7, w10, [x20]\n-    __ ldsmaxa(Assembler::word, r10, r4, r24);         \/\/       ldsmaxa w10, w4, [x24]\n-    __ ldumina(Assembler::word, r17, r17, r22);        \/\/       ldumina w17, w17, [x22]\n-    __ ldumaxa(Assembler::word, r3, r29, r15);         \/\/       ldumaxa w3, w29, [x15]\n+    __ swpa(Assembler::word, r30, r7, r10);            \/\/       swpa    w30, w7, [x10]\n+    __ ldadda(Assembler::word, r20, r10, r4);          \/\/       ldadda  w20, w10, [x4]\n+    __ ldbica(Assembler::word, r24, r17, r17);         \/\/       ldclra  w24, w17, [x17]\n+    __ ldeora(Assembler::word, r22, r3, r29);          \/\/       ldeora  w22, w3, [x29]\n+    __ ldorra(Assembler::word, r15, r22, r19);         \/\/       ldseta  w15, w22, [x19]\n+    __ ldsmina(Assembler::word, r19, r22, r2);         \/\/       ldsmina w19, w22, [x2]\n+    __ ldsmaxa(Assembler::word, r15, r6, r12);         \/\/       ldsmaxa w15, w6, [x12]\n+    __ ldumina(Assembler::word, r16, r11, r13);        \/\/       ldumina w16, w11, [x13]\n+    __ ldumaxa(Assembler::word, r23, r1, r30);         \/\/       ldumaxa w23, w1, [x30]\n@@ -848,9 +862,9 @@\n-    __ swpal(Assembler::word, r22, r19, r19);          \/\/       swpal   w22, w19, [x19]\n-    __ ldaddal(Assembler::word, r22, r2, r15);         \/\/       ldaddal w22, w2, [x15]\n-    __ ldbical(Assembler::word, r6, r12, r16);         \/\/       ldclral w6, w12, [x16]\n-    __ ldeoral(Assembler::word, r11, r13, r23);        \/\/       ldeoral w11, w13, [x23]\n-    __ ldorral(Assembler::word, r1, r30, r19);         \/\/       ldsetal w1, w30, [x19]\n-    __ ldsminal(Assembler::word, r5, r17, r2);         \/\/       ldsminal        w5, w17, [x2]\n-    __ ldsmaxal(Assembler::word, r16, r22, r13);       \/\/       ldsmaxal        w16, w22, [x13]\n-    __ lduminal(Assembler::word, r10, r21, r29);       \/\/       lduminal        w10, w21, [x29]\n-    __ ldumaxal(Assembler::word, r27, r12, r27);       \/\/       ldumaxal        w27, w12, [x27]\n+    __ swpal(Assembler::word, r19, r5, r17);           \/\/       swpal   w19, w5, [x17]\n+    __ ldaddal(Assembler::word, r2, r16, r22);         \/\/       ldaddal w2, w16, [x22]\n+    __ ldbical(Assembler::word, r13, r10, r21);        \/\/       ldclral w13, w10, [x21]\n+    __ ldeoral(Assembler::word, r29, r27, r12);        \/\/       ldeoral w29, w27, [x12]\n+    __ ldorral(Assembler::word, r27, r3, r1);          \/\/       ldsetal w27, w3, [x1]\n+    __ ldsminal(Assembler::word, zr, r24, r19);        \/\/       ldsminal        wzr, w24, [x19]\n+    __ ldsmaxal(Assembler::word, r17, r9, r28);        \/\/       ldsmaxal        w17, w9, [x28]\n+    __ lduminal(Assembler::word, r27, r15, r7);        \/\/       lduminal        w27, w15, [x7]\n+    __ ldumaxal(Assembler::word, r21, r23, sp);        \/\/       ldumaxal        w21, w23, [sp]\n@@ -859,9 +873,9 @@\n-    __ swpl(Assembler::word, r3, r1, sp);              \/\/       swpl    w3, w1, [sp]\n-    __ ldaddl(Assembler::word, r24, r19, r17);         \/\/       ldaddl  w24, w19, [x17]\n-    __ ldbicl(Assembler::word, r9, r28, r27);          \/\/       ldclrl  w9, w28, [x27]\n-    __ ldeorl(Assembler::word, r15, r7, r21);          \/\/       ldeorl  w15, w7, [x21]\n-    __ ldorrl(Assembler::word, r23, zr, r25);          \/\/       ldsetl  w23, wzr, [x25]\n-    __ ldsminl(Assembler::word, r2, zr, r27);          \/\/       ldsminl w2, wzr, [x27]\n-    __ ldsmaxl(Assembler::word, r16, r10, r23);        \/\/       ldsmaxl w16, w10, [x23]\n-    __ lduminl(Assembler::word, r19, r3, r15);         \/\/       lduminl w19, w3, [x15]\n-    __ ldumaxl(Assembler::word, r0, r25, r26);         \/\/       ldumaxl w0, w25, [x26]\n+    __ swpl(Assembler::word, r25, r2, sp);             \/\/       swpl    w25, w2, [sp]\n+    __ ldaddl(Assembler::word, r27, r16, r10);         \/\/       ldaddl  w27, w16, [x10]\n+    __ ldbicl(Assembler::word, r23, r19, r3);          \/\/       ldclrl  w23, w19, [x3]\n+    __ ldeorl(Assembler::word, r16, r0, r25);          \/\/       ldeorl  w16, w0, [x25]\n+    __ ldorrl(Assembler::word, r26, r23, r2);          \/\/       ldsetl  w26, w23, [x2]\n+    __ ldsminl(Assembler::word, r16, r12, r4);         \/\/       ldsminl w16, w12, [x4]\n+    __ ldsmaxl(Assembler::word, r28, r30, r29);        \/\/       ldsmaxl w28, w30, [x29]\n+    __ lduminl(Assembler::word, r16, r27, r6);         \/\/       lduminl w16, w27, [x6]\n+    __ ldumaxl(Assembler::word, r9, r29, r15);         \/\/       ldumaxl w9, w29, [x15]\n@@ -870,4 +884,4 @@\n-    __ bcax(v22, __ T16B, v2, v17, v12);               \/\/       bcax            v22.16B, v2.16B, v17.16B, v12.16B\n-    __ eor3(v3, __ T16B, v27, v29, v28);               \/\/       eor3            v3.16B, v27.16B, v29.16B, v28.16B\n-    __ rax1(v16, __ T2D, v26, v6);                     \/\/       rax1            v16.2D, v26.2D, v6.2D\n-    __ xar(v9, __ T2D, v28, v17, 14);                  \/\/       xar             v9.2D, v28.2D, v17.2D, #14\n+    __ bcax(v7, __ T16B, v4, v7, v15);                 \/\/       bcax            v7.16B, v4.16B, v7.16B, v15.16B\n+    __ eor3(v9, __ T16B, v22, v8, v2);                 \/\/       eor3            v9.16B, v22.16B, v8.16B, v2.16B\n+    __ rax1(v27, __ T2D, v20, v30);                    \/\/       rax1            v27.2D, v20.2D, v30.2D\n+    __ xar(v5, __ T2D, v26, v0, 34);                   \/\/       xar             v5.2D, v26.2D, v0.2D, #34\n@@ -876,4 +890,4 @@\n-    __ sha512h(v4, __ T2D, v7, v15);                   \/\/       sha512h         q4, q7, v15.2D\n-    __ sha512h2(v9, __ T2D, v22, v8);                  \/\/       sha512h2                q9, q22, v8.2D\n-    __ sha512su0(v2, __ T2D, v27);                     \/\/       sha512su0               v2.2D, v27.2D\n-    __ sha512su1(v20, __ T2D, v30, v5);                \/\/       sha512su1               v20.2D, v30.2D, v5.2D\n+    __ sha512h(v14, __ T2D, v3, v25);                  \/\/       sha512h         q14, q3, v25.2D\n+    __ sha512h2(v8, __ T2D, v27, v21);                 \/\/       sha512h2                q8, q27, v21.2D\n+    __ sha512su0(v26, __ T2D, v26);                    \/\/       sha512su0               v26.2D, v26.2D\n+    __ sha512su1(v24, __ T2D, v22, v0);                \/\/       sha512su1               v24.2D, v22.2D, v0.2D\n@@ -882,39 +896,39 @@\n-    __ sve_add(z26, __ H, z0, z16);                    \/\/       add     z26.h, z0.h, z16.h\n-    __ sve_sub(z3, __ D, z25, z8);                     \/\/       sub     z3.d, z25.d, z8.d\n-    __ sve_fadd(z21, __ D, z26, z26);                  \/\/       fadd    z21.d, z26.d, z26.d\n-    __ sve_fmul(z22, __ S, z0, z4);                    \/\/       fmul    z22.s, z0.s, z4.s\n-    __ sve_fsub(z17, __ S, z0, z3);                    \/\/       fsub    z17.s, z0.s, z3.s\n-    __ sve_abs(z1, __ B, p2, z6);                      \/\/       abs     z1.b, p2\/m, z6.b\n-    __ sve_add(z9, __ S, p7, z7);                      \/\/       add     z9.s, p7\/m, z9.s, z7.s\n-    __ sve_asr(z22, __ H, p5, z5);                     \/\/       asr     z22.h, p5\/m, z22.h, z5.h\n-    __ sve_cnt(z8, __ B, p4, z30);                     \/\/       cnt     z8.b, p4\/m, z30.b\n-    __ sve_lsl(z17, __ D, p0, z11);                    \/\/       lsl     z17.d, p0\/m, z17.d, z11.d\n-    __ sve_lsr(z28, __ S, p0, z26);                    \/\/       lsr     z28.s, p0\/m, z28.s, z26.s\n-    __ sve_mul(z28, __ D, p3, z13);                    \/\/       mul     z28.d, p3\/m, z28.d, z13.d\n-    __ sve_neg(z16, __ B, p6, z5);                     \/\/       neg     z16.b, p6\/m, z5.b\n-    __ sve_not(z13, __ H, p2, z15);                    \/\/       not     z13.h, p2\/m, z15.h\n-    __ sve_smax(z26, __ B, p5, z11);                   \/\/       smax    z26.b, p5\/m, z26.b, z11.b\n-    __ sve_smin(z22, __ B, p4, z4);                    \/\/       smin    z22.b, p4\/m, z22.b, z4.b\n-    __ sve_sub(z19, __ H, p4, z17);                    \/\/       sub     z19.h, p4\/m, z19.h, z17.h\n-    __ sve_fabs(z14, __ D, p3, z2);                    \/\/       fabs    z14.d, p3\/m, z2.d\n-    __ sve_fadd(z3, __ S, p5, z23);                    \/\/       fadd    z3.s, p5\/m, z3.s, z23.s\n-    __ sve_fdiv(z6, __ S, p1, z17);                    \/\/       fdiv    z6.s, p1\/m, z6.s, z17.s\n-    __ sve_fmax(z27, __ S, p4, z16);                   \/\/       fmax    z27.s, p4\/m, z27.s, z16.s\n-    __ sve_fmin(z2, __ S, p7, z3);                     \/\/       fmin    z2.s, p7\/m, z2.s, z3.s\n-    __ sve_fmul(z6, __ S, p4, z19);                    \/\/       fmul    z6.s, p4\/m, z6.s, z19.s\n-    __ sve_fneg(z12, __ D, p5, z8);                    \/\/       fneg    z12.d, p5\/m, z8.d\n-    __ sve_frintm(z19, __ S, p4, z0);                  \/\/       frintm  z19.s, p4\/m, z0.s\n-    __ sve_frintn(z23, __ D, p1, z19);                 \/\/       frintn  z23.d, p1\/m, z19.d\n-    __ sve_frintp(z13, __ S, p4, z6);                  \/\/       frintp  z13.s, p4\/m, z6.s\n-    __ sve_fsqrt(z7, __ D, p3, z17);                   \/\/       fsqrt   z7.d, p3\/m, z17.d\n-    __ sve_fsub(z8, __ D, p2, z22);                    \/\/       fsub    z8.d, p2\/m, z8.d, z22.d\n-    __ sve_fmla(z22, __ S, p7, z2, z3);                \/\/       fmla    z22.s, p7\/m, z2.s, z3.s\n-    __ sve_fmls(z17, __ D, p5, z7, z4);                \/\/       fmls    z17.d, p5\/m, z7.d, z4.d\n-    __ sve_fnmla(z7, __ D, p0, z8, z16);               \/\/       fnmla   z7.d, p0\/m, z8.d, z16.d\n-    __ sve_fnmls(z22, __ D, p1, z15, z9);              \/\/       fnmls   z22.d, p1\/m, z15.d, z9.d\n-    __ sve_mla(z11, __ S, p6, z5, z30);                \/\/       mla     z11.s, p6\/m, z5.s, z30.s\n-    __ sve_mls(z13, __ H, p5, z11, z1);                \/\/       mls     z13.h, p5\/m, z11.h, z1.h\n-    __ sve_and(z8, z20, z16);                          \/\/       and     z8.d, z20.d, z16.d\n-    __ sve_eor(z15, z4, z4);                           \/\/       eor     z15.d, z4.d, z4.d\n-    __ sve_orr(z8, z6, z29);                           \/\/       orr     z8.d, z6.d, z29.d\n-    __ sve_bic(z28, z16, z29);                         \/\/       bic     z28.d, z16.d, z29.d\n+    __ sve_add(z4, __ B, z6, z17);                     \/\/       add     z4.b, z6.b, z17.b\n+    __ sve_sub(z3, __ H, z15, z1);                     \/\/       sub     z3.h, z15.h, z1.h\n+    __ sve_fadd(z6, __ D, z5, z9);                     \/\/       fadd    z6.d, z5.d, z9.d\n+    __ sve_fmul(z7, __ D, z20, z22);                   \/\/       fmul    z7.d, z20.d, z22.d\n+    __ sve_fsub(z5, __ D, z10, z8);                    \/\/       fsub    z5.d, z10.d, z8.d\n+    __ sve_abs(z30, __ B, p1, z17);                    \/\/       abs     z30.b, p1\/m, z17.b\n+    __ sve_add(z11, __ B, p7, z28);                    \/\/       add     z11.b, p7\/m, z11.b, z28.b\n+    __ sve_asr(z26, __ H, p5, z28);                    \/\/       asr     z26.h, p5\/m, z26.h, z28.h\n+    __ sve_cnt(z13, __ D, p7, z16);                    \/\/       cnt     z13.d, p7\/m, z16.d\n+    __ sve_lsl(z5, __ H, p0, z13);                     \/\/       lsl     z5.h, p0\/m, z5.h, z13.h\n+    __ sve_lsr(z15, __ S, p2, z26);                    \/\/       lsr     z15.s, p2\/m, z15.s, z26.s\n+    __ sve_mul(z11, __ S, p1, z22);                    \/\/       mul     z11.s, p1\/m, z11.s, z22.s\n+    __ sve_neg(z4, __ S, p0, z19);                     \/\/       neg     z4.s, p0\/m, z19.s\n+    __ sve_not(z17, __ H, p3, z14);                    \/\/       not     z17.h, p3\/m, z14.h\n+    __ sve_smax(z2, __ S, p4, z3);                     \/\/       smax    z2.s, p4\/m, z2.s, z3.s\n+    __ sve_smin(z23, __ B, p1, z6);                    \/\/       smin    z23.b, p1\/m, z23.b, z6.b\n+    __ sve_sub(z17, __ S, p3, z27);                    \/\/       sub     z17.s, p3\/m, z17.s, z27.s\n+    __ sve_fabs(z16, __ D, p1, z2);                    \/\/       fabs    z16.d, p1\/m, z2.d\n+    __ sve_fadd(z3, __ D, p1, z6);                     \/\/       fadd    z3.d, p1\/m, z3.d, z6.d\n+    __ sve_fdiv(z19, __ D, p3, z12);                   \/\/       fdiv    z19.d, p3\/m, z19.d, z12.d\n+    __ sve_fmax(z8, __ D, p6, z19);                    \/\/       fmax    z8.d, p6\/m, z8.d, z19.d\n+    __ sve_fmin(z0, __ S, p2, z23);                    \/\/       fmin    z0.s, p2\/m, z0.s, z23.s\n+    __ sve_fmul(z19, __ D, p7, z13);                   \/\/       fmul    z19.d, p7\/m, z19.d, z13.d\n+    __ sve_fneg(z6, __ S, p0, z7);                     \/\/       fneg    z6.s, p0\/m, z7.s\n+    __ sve_frintm(z17, __ S, p6, z8);                  \/\/       frintm  z17.s, p6\/m, z8.s\n+    __ sve_frintn(z22, __ D, p5, z22);                 \/\/       frintn  z22.d, p5\/m, z22.d\n+    __ sve_frintp(z2, __ D, p0, z15);                  \/\/       frintp  z2.d, p0\/m, z15.d\n+    __ sve_fsqrt(z20, __ D, p1, z4);                   \/\/       fsqrt   z20.d, p1\/m, z4.d\n+    __ sve_fsub(z7, __ D, p0, z8);                     \/\/       fsub    z7.d, p0\/m, z7.d, z8.d\n+    __ sve_fmla(z19, __ S, p5, z4, z15);               \/\/       fmla    z19.s, p5\/m, z4.s, z15.s\n+    __ sve_fmls(z22, __ D, p2, z25, z5);               \/\/       fmls    z22.d, p2\/m, z25.d, z5.d\n+    __ sve_fnmla(z16, __ S, p3, z22, z11);             \/\/       fnmla   z16.s, p3\/m, z22.s, z11.s\n+    __ sve_fnmls(z13, __ D, p2, z20, z16);             \/\/       fnmls   z13.d, p2\/m, z20.d, z16.d\n+    __ sve_mla(z15, __ H, p1, z4, z17);                \/\/       mla     z15.h, p1\/m, z4.h, z17.h\n+    __ sve_mls(z6, __ S, p7, z4, z28);                 \/\/       mls     z6.s, p7\/m, z4.s, z28.s\n+    __ sve_and(z29, z26, z9);                          \/\/       and     z29.d, z26.d, z9.d\n+    __ sve_eor(z2, z11, z28);                          \/\/       eor     z2.d, z11.d, z28.d\n+    __ sve_orr(z7, z1, z26);                           \/\/       orr     z7.d, z1.d, z26.d\n+    __ sve_bic(z17, z14, z8);                          \/\/       bic     z17.d, z14.d, z8.d\n@@ -923,9 +937,9 @@\n-    __ sve_andv(v9, __ H, p3, z2);                     \/\/       andv h9, p3, z2.h\n-    __ sve_orv(v28, __ B, p0, z7);                     \/\/       orv b28, p0, z7.b\n-    __ sve_eorv(v26, __ H, p5, z17);                   \/\/       eorv h26, p5, z17.h\n-    __ sve_smaxv(v8, __ D, p4, z21);                   \/\/       smaxv d8, p4, z21.d\n-    __ sve_sminv(v5, __ S, p5, z21);                   \/\/       sminv s5, p5, z21.s\n-    __ sve_fminv(v22, __ D, p4, z29);                  \/\/       fminv d22, p4, z29.d\n-    __ sve_fmaxv(v19, __ D, p0, z4);                   \/\/       fmaxv d19, p0, z4.d\n-    __ sve_fadda(v23, __ S, p1, z19);                  \/\/       fadda s23, p1, s23, z19.s\n-    __ sve_uaddv(v23, __ B, p6, z19);                  \/\/       uaddv d23, p6, z19.b\n+    __ sve_andv(v21, __ S, p6, z5);                    \/\/       andv s21, p6, z5.s\n+    __ sve_orv(v21, __ S, p4, z22);                    \/\/       orv s21, p4, z22.s\n+    __ sve_eorv(v29, __ B, p5, z19);                   \/\/       eorv b29, p5, z19.b\n+    __ sve_smaxv(v4, __ B, p4, z23);                   \/\/       smaxv b4, p4, z23.b\n+    __ sve_sminv(v19, __ D, p1, z23);                  \/\/       sminv d19, p1, z23.d\n+    __ sve_fminv(v19, __ S, p0, z8);                   \/\/       fminv s19, p0, z8.s\n+    __ sve_fmaxv(v14, __ D, p6, z17);                  \/\/       fmaxv d14, p6, z17.d\n+    __ sve_fadda(v21, __ S, p1, z30);                  \/\/       fadda s21, p1, s21, z30.s\n+    __ sve_uaddv(v10, __ B, p5, z12);                  \/\/       uaddv d10, p5, z12.b\n@@ -950,7 +964,7 @@\n-    0x14000000,     0x17ffffd7,     0x140002ed,     0x94000000,\n-    0x97ffffd4,     0x940002ea,     0x3400000a,     0x34fffa2a,\n-    0x34005cea,     0x35000008,     0x35fff9c8,     0x35005c88,\n-    0xb400000b,     0xb4fff96b,     0xb4005c2b,     0xb500001d,\n-    0xb5fff91d,     0xb5005bdd,     0x10000013,     0x10fff8b3,\n-    0x10005b73,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36305af6,     0x3758000c,     0x375ff7cc,     0x37585a8c,\n+    0x14000000,     0x17ffffd7,     0x140002fb,     0x94000000,\n+    0x97ffffd4,     0x940002f8,     0x3400000a,     0x34fffa2a,\n+    0x34005eaa,     0x35000008,     0x35fff9c8,     0x35005e48,\n+    0xb400000b,     0xb4fff96b,     0xb4005deb,     0xb500001d,\n+    0xb5fff91d,     0xb5005d9d,     0x10000013,     0x10fff8b3,\n+    0x10005d33,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36305cb6,     0x3758000c,     0x375ff7cc,     0x37585c4c,\n@@ -961,13 +975,13 @@\n-    0x54005860,     0x54000001,     0x54fff541,     0x54005801,\n-    0x54000002,     0x54fff4e2,     0x540057a2,     0x54000002,\n-    0x54fff482,     0x54005742,     0x54000003,     0x54fff423,\n-    0x540056e3,     0x54000003,     0x54fff3c3,     0x54005683,\n-    0x54000004,     0x54fff364,     0x54005624,     0x54000005,\n-    0x54fff305,     0x540055c5,     0x54000006,     0x54fff2a6,\n-    0x54005566,     0x54000007,     0x54fff247,     0x54005507,\n-    0x54000008,     0x54fff1e8,     0x540054a8,     0x54000009,\n-    0x54fff189,     0x54005449,     0x5400000a,     0x54fff12a,\n-    0x540053ea,     0x5400000b,     0x54fff0cb,     0x5400538b,\n-    0x5400000c,     0x54fff06c,     0x5400532c,     0x5400000d,\n-    0x54fff00d,     0x540052cd,     0x5400000e,     0x54ffefae,\n-    0x5400526e,     0x5400000f,     0x54ffef4f,     0x5400520f,\n+    0x54005a20,     0x54000001,     0x54fff541,     0x540059c1,\n+    0x54000002,     0x54fff4e2,     0x54005962,     0x54000002,\n+    0x54fff482,     0x54005902,     0x54000003,     0x54fff423,\n+    0x540058a3,     0x54000003,     0x54fff3c3,     0x54005843,\n+    0x54000004,     0x54fff364,     0x540057e4,     0x54000005,\n+    0x54fff305,     0x54005785,     0x54000006,     0x54fff2a6,\n+    0x54005726,     0x54000007,     0x54fff247,     0x540056c7,\n+    0x54000008,     0x54fff1e8,     0x54005668,     0x54000009,\n+    0x54fff189,     0x54005609,     0x5400000a,     0x54fff12a,\n+    0x540055aa,     0x5400000b,     0x54fff0cb,     0x5400554b,\n+    0x5400000c,     0x54fff06c,     0x540054ec,     0x5400000d,\n+    0x54fff00d,     0x5400548d,     0x5400000e,     0x54ffefae,\n+    0x5400542e,     0x5400000f,     0x54ffef4f,     0x540053cf,\n@@ -1005,1 +1019,1 @@\n-    0xbd1b1869,     0x5800425b,     0x1800000b,     0xf8945060,\n+    0xbd1b1869,     0x5800441b,     0x1800000b,     0xf8945060,\n@@ -1080,58 +1094,62 @@\n-    0x0eb93717,     0x4ebc377a,     0x4ef93717,     0x2eb0e5ee,\n-    0x6eb7e6d5,     0x6ee5e483,     0x0e393f17,     0x4e2a3d28,\n-    0x0e7a3f38,     0x4e753e93,     0x0eb13e0f,     0x4eb23e30,\n-    0x4ee43c62,     0x2e23e441,     0x6e22e420,     0x6e7ae738,\n-    0xba5fd3e3,     0x3a5f03e5,     0xfa411be4,     0x7a42cbe2,\n-    0x93df03ff,     0xc820ffff,     0x8822fc7f,     0xc8247cbf,\n-    0x88267fff,     0x4e010fe0,     0x4e081fe1,     0x4e0c1fe1,\n-    0x4e0a1fe1,     0x4e071fe1,     0x4e042c20,     0x4e062c20,\n-    0x4e052c20,     0x4e083c20,     0x0e0c3c20,     0x0e0a3c20,\n-    0x0e073c20,     0x4cc0ac3f,     0x05a08020,     0x04b0e3e0,\n-    0x0470e7e1,     0x042f9c20,     0x043f9c35,     0x047f9c20,\n-    0x04ff9c20,     0x04299420,     0x04319160,     0x0461943e,\n-    0x04a19020,     0x042053ff,     0x047f5401,     0x25208028,\n-    0x2538cfe0,     0x2578d001,     0x25b8efe2,     0x25f8f007,\n-    0xa400a3e0,     0xa4a8a7ea,     0xa547a814,     0xa4084ffe,\n-    0xa55c53e0,     0xa5e1540b,     0xe400fbf6,     0xe408ffff,\n-    0xe547e400,     0xe4014be0,     0xe4a84fe0,     0xe5f15000,\n-    0x858043e0,     0x85a043ff,     0xe59f5d08,     0x1e601000,\n-    0x1e603000,     0x1e621000,     0x1e623000,     0x1e641000,\n-    0x1e643000,     0x1e661000,     0x1e663000,     0x1e681000,\n-    0x1e683000,     0x1e6a1000,     0x1e6a3000,     0x1e6c1000,\n-    0x1e6c3000,     0x1e6e1000,     0x1e6e3000,     0x1e701000,\n-    0x1e703000,     0x1e721000,     0x1e723000,     0x1e741000,\n-    0x1e743000,     0x1e761000,     0x1e763000,     0x1e781000,\n-    0x1e783000,     0x1e7a1000,     0x1e7a3000,     0x1e7c1000,\n-    0x1e7c3000,     0x1e7e1000,     0x1e7e3000,     0xf8248183,\n-    0xf83f015c,     0xf83a1182,     0xf830203f,     0xf82d301d,\n-    0xf833522c,     0xf836438d,     0xf83e703f,     0xf83a609c,\n-    0xf8be80c4,     0xf8be01fa,     0xf8a91188,     0xf8a02034,\n-    0xf8b83002,     0xf8a95358,     0xf8b0407e,     0xf8aa7157,\n-    0xf8a46050,     0xf8eb8148,     0xf8ef0051,     0xf8ea118c,\n-    0xf8ef204d,     0xf8e73354,     0xf8f05044,     0xf8e441ec,\n-    0xf8f571f0,     0xf8eb62f5,     0xf86c82fa,     0xf87c016e,\n-    0xf8781181,     0xf87f220a,     0xf8673062,     0xf86d5233,\n-    0xf8704023,     0xf86b70be,     0xf86863af,     0xb83e8280,\n-    0xb82702f4,     0xb83c1375,     0xb8392025,     0xb83733f0,\n-    0xb825512c,     0xb83c43af,     0xb836727f,     0xb83f61c5,\n-    0xb8b081ff,     0xb8bb0214,     0xb8ac112b,     0xb8a6223e,\n-    0xb8bb33dc,     0xb8a7528a,     0xb8aa4304,     0xb8b172d1,\n-    0xb8a361fd,     0xb8f68273,     0xb8f601e2,     0xb8e6120c,\n-    0xb8eb22ed,     0xb8e1327e,     0xb8e55051,     0xb8f041b6,\n-    0xb8ea73b5,     0xb8fb636c,     0xb86383e1,     0xb8780233,\n-    0xb869137c,     0xb86f22a7,     0xb877333f,     0xb862537f,\n-    0xb87042ea,     0xb87371e3,     0xb8606359,     0xce313056,\n-    0xce1d7363,     0xce668f50,     0xce913b89,     0xce6f80e4,\n-    0xce6886c9,     0xcec08362,     0xce658bd4,     0x0470001a,\n-    0x04e80723,     0x65da0355,     0x65840816,     0x65830411,\n-    0x0416a8c1,     0x04801ce9,     0x045094b6,     0x041ab3c8,\n-    0x04d38171,     0x0491835c,     0x04d00dbc,     0x0417b8b0,\n-    0x045ea9ed,     0x0408157a,     0x040a1096,     0x04411233,\n-    0x04dcac4e,     0x658096e3,     0x658d8626,     0x6586921b,\n-    0x65879c62,     0x65829266,     0x04ddb50c,     0x6582b013,\n-    0x65c0a677,     0x6581b0cd,     0x65cdae27,     0x65c18ac8,\n-    0x65a31c56,     0x65e434f1,     0x65f04107,     0x65e965f6,\n-    0x049e58ab,     0x0441756d,     0x04303288,     0x04a4308f,\n-    0x047d30c8,     0x04fd321c,     0x045a2c49,     0x041820fc,\n-    0x0459363a,     0x04c832a8,     0x048a36a5,     0x65c733b6,\n-    0x65c62093,     0x65982677,     0x04013a77,\n+    0x0eb93717,     0x4ebc377a,     0x4ef93717,     0x2e3035ee,\n+    0x6e3736d5,     0x2e653483,     0x6e793717,     0x2eaa3528,\n+    0x6eba3738,     0x6ef53693,     0x2e313e0f,     0x6e323e30,\n+    0x2e643c62,     0x6e633c41,     0x2ea23c20,     0x6eba3f38,\n+    0x6ee63ca4,     0x2ea5e483,     0x6eade58b,     0x6ee0e7fe,\n+    0x0e3d3f9b,     0x4e2b3d49,     0x0e7b3f59,     0x4e643c62,\n+    0x0eae3dac,     0x4eb33e51,     0x4ee03ffe,     0x2e23e441,\n+    0x6e2ee5ac,     0x6e7ee7bc,     0xba5fd3e3,     0x3a5f03e5,\n+    0xfa411be4,     0x7a42cbe2,     0x93df03ff,     0xc820ffff,\n+    0x8822fc7f,     0xc8247cbf,     0x88267fff,     0x4e010fe0,\n+    0x4e081fe1,     0x4e0c1fe1,     0x4e0a1fe1,     0x4e071fe1,\n+    0x4e042c20,     0x4e062c20,     0x4e052c20,     0x4e083c20,\n+    0x0e0c3c20,     0x0e0a3c20,     0x0e073c20,     0x4cc0ac3f,\n+    0x05a08020,     0x04b0e3e0,     0x0470e7e1,     0x042f9c20,\n+    0x043f9c35,     0x047f9c20,     0x04ff9c20,     0x04299420,\n+    0x04319160,     0x0461943e,     0x04a19020,     0x042053ff,\n+    0x047f5401,     0x25208028,     0x2538cfe0,     0x2578d001,\n+    0x25b8efe2,     0x25f8f007,     0xa400a3e0,     0xa4a8a7ea,\n+    0xa547a814,     0xa4084ffe,     0xa55c53e0,     0xa5e1540b,\n+    0xe400fbf6,     0xe408ffff,     0xe547e400,     0xe4014be0,\n+    0xe4a84fe0,     0xe5f15000,     0x858043e0,     0x85a043ff,\n+    0xe59f5d08,     0x1e601000,     0x1e603000,     0x1e621000,\n+    0x1e623000,     0x1e641000,     0x1e643000,     0x1e661000,\n+    0x1e663000,     0x1e681000,     0x1e683000,     0x1e6a1000,\n+    0x1e6a3000,     0x1e6c1000,     0x1e6c3000,     0x1e6e1000,\n+    0x1e6e3000,     0x1e701000,     0x1e703000,     0x1e721000,\n+    0x1e723000,     0x1e741000,     0x1e743000,     0x1e761000,\n+    0x1e763000,     0x1e781000,     0x1e783000,     0x1e7a1000,\n+    0x1e7a3000,     0x1e7c1000,     0x1e7c3000,     0x1e7e1000,\n+    0x1e7e3000,     0xf8208193,     0xf83101b6,     0xf83c13fe,\n+    0xf821239a,     0xf824309e,     0xf826535e,     0xf8304109,\n+    0xf82c7280,     0xf8216058,     0xf8a08309,     0xf8ba03d0,\n+    0xf8a312ea,     0xf8aa21e4,     0xf8a2310b,     0xf8aa522f,\n+    0xf8a2418a,     0xf8ac71af,     0xf8a26287,     0xf8fa8090,\n+    0xf8e20184,     0xf8f01215,     0xf8f022ab,     0xf8f7334c,\n+    0xf8f751dc,     0xf8eb4038,     0xf8ec715f,     0xf8f06047,\n+    0xf863826d,     0xf8710070,     0xf86113cb,     0xf86521e8,\n+    0xf87d301e,     0xf8745287,     0xf87742bc,     0xf87b70b9,\n+    0xf8616217,     0xb83f8185,     0xb82901fc,     0xb83d13f6,\n+    0xb83320bf,     0xb82e33f0,     0xb830529b,     0xb830416c,\n+    0xb82973c6,     0xb831639b,     0xb8be8147,     0xb8b4008a,\n+    0xb8b81231,     0xb8b623a3,     0xb8af3276,     0xb8b35056,\n+    0xb8af4186,     0xb8b071ab,     0xb8b763c1,     0xb8f38225,\n+    0xb8e202d0,     0xb8ed12aa,     0xb8fd219b,     0xb8fb3023,\n+    0xb8ff5278,     0xb8f14389,     0xb8fb70ef,     0xb8f563f7,\n+    0xb87983e2,     0xb87b0150,     0xb8771073,     0xb8702320,\n+    0xb87a3057,     0xb870508c,     0xb87c43be,     0xb87070db,\n+    0xb86961fd,     0xce273c87,     0xce080ac9,     0xce7e8e9b,\n+    0xce808b45,     0xce79806e,     0xce758768,     0xcec0835a,\n+    0xce608ad8,     0x043100c4,     0x046105e3,     0x65c900a6,\n+    0x65d60a87,     0x65c80545,     0x0416a63e,     0x04001f8b,\n+    0x0450979a,     0x04dabe0d,     0x045381a5,     0x04918b4f,\n+    0x049006cb,     0x0497a264,     0x045eadd1,     0x04881062,\n+    0x040a04d7,     0x04810f71,     0x04dca450,     0x65c084c3,\n+    0x65cd8d93,     0x65c69a68,     0x65878ae0,     0x65c29db3,\n+    0x049da0e6,     0x6582b911,     0x65c0b6d6,     0x65c1a1e2,\n+    0x65cda494,     0x65c18107,     0x65af1493,     0x65e52b36,\n+    0x65ab4ed0,     0x65f06a8d,     0x0451448f,     0x049c7c86,\n+    0x0429335d,     0x04bc3162,     0x047a3027,     0x04e831d1,\n+    0x049a38b5,     0x049832d5,     0x0419367d,     0x040832e4,\n+    0x04ca26f3,     0x65872113,     0x65c63a2e,     0x659827d5,\n+    0x0401358a,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":237,"deletions":219,"binary":false,"changes":456,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,2 @@\n+  EXPECT_EQ(queue.peek(match_1), (uintptr_t)0) << \"Must be empty.\";\n+  EXPECT_EQ(queue.peek(match_all), (uintptr_t)0) << \"Must be empty.\";\n@@ -71,0 +73,3 @@\n+  EXPECT_EQ(queue.peek(match_1), (uintptr_t)1) << \"Must match 1.\";\n+  EXPECT_NE(queue.peek(match_all), (uintptr_t)0) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.peek(match_even), (uintptr_t)0) << \"Must not contain a value.\";\n@@ -87,0 +92,5 @@\n+  EXPECT_EQ(queue.peek(match_1), (uintptr_t)1) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.peek(match_2), (uintptr_t)2) << \"Must contain a value.\";\n+  EXPECT_NE(queue.peek(match_all), (uintptr_t)0) << \"Must contain a value.\";\n+  EXPECT_NE(queue.peek(match_even), (uintptr_t)0) << \"Must contain a value.\";\n+\n@@ -95,0 +105,5 @@\n+  EXPECT_EQ(queue.peek(match_1), (uintptr_t)0) << \"Must not contain a value.\";\n+  EXPECT_EQ(queue.peek(match_2), (uintptr_t)2) << \"Must contain a value.\";\n+  EXPECT_NE(queue.peek(match_all), (uintptr_t)0) << \"Must contain a value.\";\n+  EXPECT_NE(queue.peek(match_even), (uintptr_t)0) << \"Must contain a value.\";\n+\n@@ -97,0 +112,1 @@\n+  EXPECT_EQ(queue.peek(match_even), (uintptr_t)2) << \"Must not be empty.\";\n@@ -109,0 +125,5 @@\n+  EXPECT_EQ(queue.peek(match_3), (uintptr_t)3) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.peek(match_2), (uintptr_t)0) << \"Must be empty.\";\n+  EXPECT_EQ(queue.peek(match_all), (uintptr_t)3) << \"Must contain a value.\";\n+  EXPECT_EQ(queue.peek(match_even), (uintptr_t)0) << \"Must be empty.\";\n+\n@@ -131,0 +152,3 @@\n+  EXPECT_EQ(queue.peek(match_even), (uintptr_t)2) << \"Must not be empty.\";\n+  EXPECT_EQ(queue.peek(match_all), (uintptr_t)1) << \"Must not be empty.\";\n+\n@@ -163,0 +187,1 @@\n+        while (_fq->peek(*this) == 0) {}\n","filename":"test\/hotspot\/gtest\/utilities\/test_filterQueue.cpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-runtime\/cds\/appcds\/dynamicArchive\/TestDynamicDumpAtOom.java 8267954 linux-x64\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,6 +32,0 @@\n-serviceability\/sa\/ClhsdbDumpheap.java                         8220624   generic-all\n-serviceability\/sa\/ClhsdbFindPC.java#id0                       8220624   generic-all\n-serviceability\/sa\/ClhsdbFindPC.java#id1                       8220624   generic-all\n-serviceability\/sa\/ClhsdbFindPC.java#id2                       8220624   generic-all\n-serviceability\/sa\/ClhsdbFindPC.java#id3                       8220624   generic-all\n-serviceability\/sa\/ClhsdbInspect.java                          8220624   generic-all\n@@ -39,2 +33,0 @@\n-serviceability\/sa\/ClhsdbSymbol.java                           8220624   generic-all\n-serviceability\/sa\/TestHeapDumpForInvokeDynamic.java           8220624   generic-all\n@@ -42,2 +34,0 @@\n-serviceability\/sa\/TestJmapCore.java                           8220624   generic-all\n-serviceability\/sa\/TestJmapCoreMetaspace.java                  8267045   generic-all\n@@ -45,0 +35,1 @@\n+serviceability\/sa\/TestJmapCore.java                           8268283 linux-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList-zgc.txt","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -91,1 +91,0 @@\n-gtest\/AsyncLogGtest.java 8267926 generic-all\n@@ -106,1 +105,5 @@\n-serviceability\/sa\/sadebugd\/DebugdConnectTest.java 8239062 macosx-x64\n+serviceability\/sa\/sadebugd\/DebugdConnectTest.java 8239062,8268570 generic-all\n+serviceability\/attach\/RemovingUnixDomainSocketTest.java 8268570 generic-all\n+serviceability\/sa\/TestJhsdbJstackLock.java 8268570 generic-all\n+serviceability\/sa\/JhsdbThreadInfoTest.java 8268570 generic-all\n+\n@@ -136,0 +139,1 @@\n+vmTestbase\/nsk\/jdi\/HiddenClass\/events\/events001.java                 8257705 generic-all\n@@ -147,0 +151,2 @@\n+vmTestbase\/nsk\/jvmti\/SuspendThread\/suspendthrd003\/TestDescription.java 8264605 generic-all\n+vmTestbase\/nsk\/jvmti\/PopFrame\/popframe011\/TestDescription.java 8266593 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=0 -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=0 -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOptions\n@@ -36,1 +36,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=0 -XX:MaxVectorSize=64\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=0 -XX:MaxVectorSize=64\n@@ -39,1 +39,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption\n@@ -42,1 +42,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=64\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=64\n@@ -45,1 +45,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=64 -XX:MaxVectorSize=64\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=64 -XX:MaxVectorSize=64\n@@ -48,1 +48,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption -XX:ArrayCopyLoadStoreMaxElem=16\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption -XX:ArrayCopyLoadStoreMaxElem=16\n@@ -51,1 +51,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=64 -XX:MaxVectorSize=64 -XX:ArrayCopyLoadStoreMaxElem=16\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=64 -XX:MaxVectorSize=64 -XX:ArrayCopyLoadStoreMaxElem=16\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyConjoint.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=0 -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=0 -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOptions\n@@ -36,1 +36,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=0 -XX:MaxVectorSize=64\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=0 -XX:MaxVectorSize=64\n@@ -39,1 +39,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption\n@@ -42,1 +42,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=64\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=64\n@@ -45,1 +45,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=64 -XX:MaxVectorSize=64\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=64 -XX:MaxVectorSize=64\n@@ -48,1 +48,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption -XX:ArrayCopyLoadStoreMaxElem=16\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=32 -XX:+UnlockDiagnosticVMOptions -XX:MaxVectorSize=32 -XX:+UnlockDiagnosticVMOption -XX:ArrayCopyLoadStoreMaxElem=16\n@@ -51,1 +51,1 @@\n- *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayCopyPartialInlineSize=64 -XX:MaxVectorSize=64 -XX:ArrayCopyLoadStoreMaxElem=16\n+ *      -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:ArrayOperationPartialInlineSize=64 -XX:MaxVectorSize=64 -XX:ArrayCopyLoadStoreMaxElem=16\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyDisjoint.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,288 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.intrinsics;\n+\n+\/*\n+ * @test\n+ * @requires vm.opt.final.UseVectorizedMismatchIntrinsic == true\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.util\n+ *\n+ *  @run main\/othervm -XX:CompileCommand=quiet -XX:CompileCommand=compileonly,*::test*\n+ *                    -Xbatch -XX:-TieredCompilation\n+ *                    -XX:UseAVX=3\n+ *                     compiler.intrinsics.VectorizedMismatchTest\n+ *\n+ *  @run main\/othervm -XX:CompileCommand=quiet -XX:CompileCommand=compileonly,*::test*\n+ *                    -Xbatch -XX:-TieredCompilation\n+ *                    -XX:+UnlockDiagnosticVMOptions -XX:UseAVX=3 -XX:AVX3Threshold=0\n+ *                     compiler.intrinsics.VectorizedMismatchTest\n+ *\/\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.util.ArraysSupport;\n+\n+public class VectorizedMismatchTest {\n+    private boolean[] boolean_a = new boolean[128];\n+    private boolean[] boolean_b = new boolean[128];\n+\n+    int testBooleanConstantLength(int length) {\n+        boolean[] obja = boolean_a;\n+        boolean[] objb = boolean_b;\n+        long offset = Unsafe.ARRAY_BOOLEAN_BASE_OFFSET;\n+        int scale = ArraysSupport.LOG2_ARRAY_BOOLEAN_INDEX_SCALE;\n+        return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, length, scale);\n+    }\n+\n+    int testBooleanConstantLength0()   { return testBooleanConstantLength(0);   }\n+    int testBooleanConstantLength1()   { return testBooleanConstantLength(1);   }\n+    int testBooleanConstantLength64()  { return testBooleanConstantLength(64);  }\n+    int testBooleanConstantLength128() { return testBooleanConstantLength(128); }\n+\n+    \/* ==================================================================================== *\/\n+\n+    private byte[] byte_a = new byte[128];\n+    private byte[] byte_b = new byte[128];\n+\n+    int testByteConstantLength(int length) {\n+        byte[] obja = byte_a;\n+        byte[] objb = byte_b;\n+        long offset = Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+        int scale = ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE;\n+        return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, length, scale);\n+    }\n+\n+    int testByteConstantLength0()   { return testByteConstantLength(0);   }\n+    int testByteConstantLength1()   { return testByteConstantLength(1);   }\n+    int testByteConstantLength64()  { return testByteConstantLength(64);  }\n+    int testByteConstantLength128() { return testByteConstantLength(128); }\n+\n+    \/* ==================================================================================== *\/\n+\n+    private short[] short_a = new short[64];\n+    private short[] short_b = new short[64];\n+\n+    int testShortConstantLength(int length) {\n+        short[] obja = short_a;\n+        short[] objb = short_b;\n+        long offset = Unsafe.ARRAY_SHORT_BASE_OFFSET;\n+        int scale = ArraysSupport.LOG2_ARRAY_SHORT_INDEX_SCALE;\n+        return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, length, scale);\n+    }\n+\n+    int testShortConstantLength0()  { return testShortConstantLength(0);  }\n+    int testShortConstantLength1()  { return testShortConstantLength(1);  }\n+    int testShortConstantLength32() { return testShortConstantLength(32); }\n+    int testShortConstantLength64() { return testShortConstantLength(64); }\n+\n+    \/* ==================================================================================== *\/\n+\n+    private char[] char_a = new char[64];\n+    private char[] char_b = new char[64];\n+\n+    int testCharConstantLength(int length) {\n+        char[] obja = char_a;\n+        char[] objb = char_b;\n+        long offset = Unsafe.ARRAY_CHAR_BASE_OFFSET;\n+        int scale = ArraysSupport.LOG2_ARRAY_CHAR_INDEX_SCALE;\n+        return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, length, scale);\n+    }\n+\n+    int testCharConstantLength0()  { return testCharConstantLength(0);  }\n+    int testCharConstantLength1()  { return testCharConstantLength(1);  }\n+    int testCharConstantLength32() { return testCharConstantLength(32); }\n+    int testCharConstantLength64() { return testCharConstantLength(64); }\n+\n+    \/* ==================================================================================== *\/\n+\n+    private int[] int_a = new int[32];\n+    private int[] int_b = new int[32];\n+\n+    int testIntConstantLength(int length) {\n+        int[] obja = int_a;\n+        int[] objb = int_b;\n+        long offset = Unsafe.ARRAY_INT_BASE_OFFSET;\n+        int scale = ArraysSupport.LOG2_ARRAY_INT_INDEX_SCALE;\n+        return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, length, scale);\n+    }\n+\n+    int testIntConstantLength0()  { return testIntConstantLength(0);  }\n+    int testIntConstantLength1()  { return testIntConstantLength(1);  }\n+    int testIntConstantLength16() { return testIntConstantLength(16); }\n+    int testIntConstantLength32() { return testIntConstantLength(32); }\n+\n+    \/* ==================================================================================== *\/\n+\n+    private float[] float_a = new float[32];\n+    private float[] float_b = new float[32];\n+\n+    int testFloatConstantLength(int length) {\n+        float[] obja = float_a;\n+        float[] objb = float_b;\n+        long offset = Unsafe.ARRAY_FLOAT_BASE_OFFSET;\n+        int scale = ArraysSupport.LOG2_ARRAY_FLOAT_INDEX_SCALE;\n+        return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, length, scale);\n+    }\n+\n+    int testFloatConstantLength0()  { return testFloatConstantLength(0);  }\n+    int testFloatConstantLength1()  { return testFloatConstantLength(1);  }\n+    int testFloatConstantLength16() { return testFloatConstantLength(16); }\n+    int testFloatConstantLength32() { return testFloatConstantLength(32); }\n+\n+    \/* ==================================================================================== *\/\n+\n+    private long[] long_a = new long[16];\n+    private long[] long_b = new long[16];\n+\n+    int testLongConstantLength(int length) {\n+        long[] obja = long_a;\n+        long[] objb = long_b;\n+        long offset = Unsafe.ARRAY_LONG_BASE_OFFSET;\n+        int scale = ArraysSupport.LOG2_ARRAY_LONG_INDEX_SCALE;\n+        return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, length, scale);\n+    }\n+\n+    int testLongConstantLength0()  { return testLongConstantLength(0);  }\n+    int testLongConstantLength1()  { return testLongConstantLength(1);  }\n+    int testLongConstantLength8()  { return testLongConstantLength(8);  }\n+    int testLongConstantLength16() { return testLongConstantLength(16); }\n+\n+    \/* ==================================================================================== *\/\n+\n+    private double[] double_a = new double[16];\n+    private double[] double_b = new double[16];\n+\n+    int testDoubleConstantLength(int length) {\n+        double[] obja = double_a;\n+        double[] objb = double_b;\n+        long offset = Unsafe.ARRAY_DOUBLE_BASE_OFFSET;\n+        int  scale  = ArraysSupport.LOG2_ARRAY_DOUBLE_INDEX_SCALE;\n+        return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, length, scale);\n+    }\n+\n+    int testDoubleConstantLength0()  { return testDoubleConstantLength(0);  }\n+    int testDoubleConstantLength1()  { return testDoubleConstantLength(1);  }\n+    int testDoubleConstantLength8()  { return testDoubleConstantLength(8);  }\n+    int testDoubleConstantLength16() { return testDoubleConstantLength(16); }\n+\n+    \/* ==================================================================================== *\/\n+\n+    static class ClassInitTest {\n+        static final int LENGTH = 64;\n+        static final int RESULT;\n+        static {\n+            byte[] arr1 = new byte[LENGTH];\n+            byte[] arr2 = new byte[LENGTH];\n+            for (int i = 0; i < 20_000; i++) {\n+                test(arr1, arr2);\n+            }\n+            RESULT = test(arr1, arr2);\n+        }\n+\n+        static int test(byte[] obja, byte[] objb) {\n+            long offset = Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+            int  scale  = ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE;\n+            return ArraysSupport.vectorizedMismatch(obja, offset, objb, offset, LENGTH, scale); \/\/ LENGTH is not considered a constant\n+        }\n+    }\n+\n+    int testConstantBeingInitialized() {\n+        return ClassInitTest.RESULT; \/\/ trigger class initialization\n+    }\n+\n+    \/* ==================================================================================== *\/\n+\n+    int testLoopUnswitch(int length) {\n+        long offset = Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+        int  scale  = ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE;\n+\n+        int acc = 0;\n+        for (int i = 0; i < 32; i++) {\n+            acc += ArraysSupport.vectorizedMismatch(byte_a, offset, byte_b, offset, length, scale);\n+        }\n+        return acc;\n+    }\n+\n+    int testLoopHoist(int length, int stride) {\n+        long offset = Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+        int  scale  = ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE;\n+\n+        int acc = 0;\n+\n+        for (int i = 0; i < 32; i += stride) {\n+            acc += ArraysSupport.vectorizedMismatch(byte_a, offset, byte_b, offset, length, scale);\n+        }\n+        return acc;\n+    }\n+\n+    \/* ==================================================================================== *\/\n+\n+    public static void main(String[] args) {\n+        VectorizedMismatchTest t = new VectorizedMismatchTest();\n+        for (int i = 0; i < 20_000; i++) {\n+            t.testBooleanConstantLength0();\n+            t.testBooleanConstantLength1();\n+            t.testBooleanConstantLength64();\n+            t.testBooleanConstantLength128();\n+\n+            t.testByteConstantLength0();\n+            t.testByteConstantLength1();\n+            t.testByteConstantLength64();\n+            t.testByteConstantLength128();\n+\n+            t.testShortConstantLength0();\n+            t.testShortConstantLength1();\n+            t.testShortConstantLength32();\n+            t.testShortConstantLength64();\n+\n+            t.testCharConstantLength0();\n+            t.testCharConstantLength1();\n+            t.testCharConstantLength32();\n+            t.testCharConstantLength64();\n+\n+            t.testIntConstantLength0();\n+            t.testIntConstantLength1();\n+            t.testIntConstantLength16();\n+            t.testIntConstantLength32();\n+\n+            t.testFloatConstantLength0();\n+            t.testFloatConstantLength1();\n+            t.testFloatConstantLength16();\n+            t.testFloatConstantLength32();\n+\n+            t.testLongConstantLength0();\n+            t.testLongConstantLength1();\n+            t.testLongConstantLength8();\n+            t.testLongConstantLength16();\n+\n+            t.testDoubleConstantLength0();\n+            t.testDoubleConstantLength1();\n+            t.testDoubleConstantLength8();\n+            t.testDoubleConstantLength16();\n+\n+            t.testLoopUnswitch(32);\n+            t.testLoopHoist(128, 2);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/VectorizedMismatchTest.java","additions":288,"deletions":0,"binary":false,"changes":288,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import compiler.lib.ir_framework.test.TestVM;\n+import jdk.test.lib.Utils;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Base info class which provides some useful utility methods and information about a test.\n+ * <p>\n+ * <b>Base tests<\/b> and <b>checked tests<\/b> use {@link TestInfo} while <b>custom run tests<\/b> use {@link RunInfo}.\n+ *\n+ * @see Test\n+ * @see Check\n+ * @see Run\n+ *\/\n+abstract public class AbstractInfo {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    protected final Class<?> testClass;\n+    private boolean onWarmUp = true;\n+\n+    AbstractInfo(Class<?> testClass) {\n+        this.testClass = testClass;\n+    }\n+\n+    \/**\n+     * Get the initialized {@link Random} object.\n+     *\n+     * @return the random object.\n+     *\/\n+    public Random getRandom() {\n+        return RANDOM;\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the framework is currently warming up the associated test.\n+     *\n+     * @return the warm-up status of the associated test.\n+     *\n+     * @see Warmup\n+     *\/\n+    public boolean isWarmUp() {\n+        return onWarmUp;\n+    }\n+\n+    \/**\n+     * Get the method object of the method {@code name} of class {@code c} with arguments {@code args}.\n+     *\n+     * @param c    the class containing the method.\n+     * @param name the name of the method.\n+     * @param args the arguments of the method, leave empty if no arguments.\n+     *\n+     * @return the method object of the requested method.\n+     *\/\n+    public Method getMethod(Class<?> c, String name, Class<?>... args) {\n+        try {\n+            return c.getMethod(name, args);\n+        } catch (NoSuchMethodException e) {\n+            String parameters = args == null || args.length == 0 ? \"\" :\n+                    \" with arguments [\" + Arrays.stream(args).map(Class::getName).collect(Collectors.joining(\",\")) + \"]\";\n+            throw new TestRunException(\"Could not find method \" + name + \" in \" + c + parameters, e);\n+        }\n+    }\n+\n+    \/**\n+     * Get the method object of the method {@code name} of the test class with arguments {@code args}.\n+     *\n+     * @param name the name of the method in the test class.\n+     * @param args the arguments of the method, leave empty if no arguments.\n+     *\n+     * @return the method object of the requested method in the test class.\n+     *\/\n+    public Method getTestClassMethod(String name, Class<?>... args) {\n+        return getMethod(testClass, name, args);\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the test VM runs with flags that allow C2 compilations.\n+     *\n+     * @return {@code true} if C2 compilations are allowed;\n+     *         {@code false} otherwise (run with {@code -XX:TieredStopAtLevel={1,2,3}, -XX:-UseCompiler}).\n+     *\/\n+    public boolean isC2CompilationEnabled() {\n+        return TestVM.USE_COMPILER && !TestVM.TEST_C1;\n+    }\n+\n+    \/**\n+     * Called by {@link TestFramework} when the warm-up is finished. Should not be called by user code.\n+     *\/\n+    public void setWarmUpFinished() {\n+        onWarmUp = false;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/AbstractInfo.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+\/**\n+ * Well-defined argument values that can be used in the {@link Arguments} annotation at a {@link Test} method for a\n+ * <b>base test<\/b> or a <b>checked test<\/b>.\n+ *\n+ * @see Arguments\n+ * @see Test\n+ * @see Check\n+ *\/\n+public enum Argument {\n+    \/**\n+     * Provides the default value for any kind of primitive type and object type if the class provides a default constructor.\n+     *\/\n+    DEFAULT,\n+    \/**\n+     * Provides the number 42 for any primitive number type.\n+     *\/\n+    NUMBER_42,\n+    \/**\n+     * Provides the number -42 for any primitive number type.\n+     *\/\n+    NUMBER_MINUS_42,\n+    \/**\n+     * Provides the minimum value of the specified primitive number type.\n+     *\/\n+    MIN,\n+    \/**\n+     * Provides the maximum value of the specified primitive number type.\n+     *\/\n+    MAX,\n+    \/**\n+     * Provides the boolean value false.\n+     *\/\n+    FALSE,\n+    \/**\n+     * Provides the boolean value true.\n+     *\/\n+    TRUE,\n+    \/**\n+     * Provides a different boolean value on each test invocation, starting with false.\n+     *\/\n+    BOOLEAN_TOGGLE_FIRST_FALSE,\n+    \/**\n+     * Provides a different boolean value on each test invocation, starting with true.\n+     *\/\n+    BOOLEAN_TOGGLE_FIRST_TRUE,\n+    \/**\n+     * Provides a random primitive value on the first test invocation and reuses the same value for all invocation of the test.\n+     * Float and double values are restricted to the range [-10000,10000].\n+     *\/\n+    RANDOM_ONCE,\n+    \/**\n+     * Provides a different random primitive value on each test invocation.\n+     * Float and double values are restricted to the range [-10000,10000].\n+     *\/\n+    RANDOM_EACH,\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Argument.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/**\n+ * This annotation is used to specify well-defined {@link Argument} values for test methods (specifying {@link Test}) when\n+ * used as part of a <b>base test<\/b> or <b>checked test<\/b>.\n+ *\n+ * @see Argument\n+ * @see Test\n+ * @see Check\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface Arguments {\n+    \/**\n+     * Get the argument value.\n+     *\/\n+    Argument[] value();\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Arguments.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/**\n+ * Annotation for a check method of a <b>checked test<\/b>.\n+ *\n+ * <p>\n+ * Let {@code t} be a test method specifying the {@link Test @Test} annotation and {@code c} be a check method specifying\n+ * the {@code @Check(test = \"t\")} annotation. These two methods represent a so-called <i>checked test<\/i>. The only\n+ * difference to a <i>base test<\/i> (see {@link Test}) is that the framework will invoke the check method {@code c}\n+ * directly after the invocation of the test method {@code t} which allows to do some additional verification,\n+ * including the return value of {@code t}. The framework does the following, similar as for <i>base tests<\/i>:\n+ * <ol>\n+ *     <li><p>The framework warms {@code t} up by invoking it for a predefined number of iterations (default: 2000)\n+ *            or any number specified by an additional {@link Warmup @Warmup} annotation at {@code t} or by using\n+ *            {@link TestFramework#setDefaultWarmup(int)} (could also be 0 which skips the warm-up completely which is\n+ *            similar to simulating {@code -Xcomp}). After each invocation of {@code t}, the framework also invokes\n+ *            {@code c} if the {@code @Check} annotation specifies {@link CheckAt#EACH_INVOCATION} at {@link #when()}.\n+ *            More information about the warm-up in general can be found at {@link Warmup}<\/li>\n+ *     <li><p>After the warm-up, the framework compiles {@code t} at the specified compilation level set by\n+ *            {@link Test#compLevel()} (default {@link CompLevel#ANY} will pick the highest available level which is\n+ *            usually {@link CompLevel#C2}).<\/li>\n+ *     <li><p>The framework invokes {@code t} one more time to run the compilation. Afterwards, the framework will\n+ *            always invoke {@code c} again to be able perform additional checks after the compilation of {@code t}.<\/li>\n+ *     <li><p>The framework checks any specified {@link IR @IR} constraints at the test method {@code t}.\n+ *            More information about IR matching can be found at {@link IR}.<\/li>\n+ * <\/ol>\n+ *\n+ * <p>\n+ * The test method {@code t} has the same properties and follows the same constraints as stated in {@link Test}.\n+ * <p>\n+ * The following additional constraints must be met for the test method {@code t} and check method {@code c}:\n+ * <ul>\n+ *     <li><p>{@code c} must specify the method name {@code t} as property in {@code @Check(test = \"t\")}\n+ *     (see {@link #test()}. Specifying a non-{@code @Test} annotated method or a {@code @Test} method that\n+ *     has already been used by another {@code @Check} or {@link Run @Run} method results in a {@link TestFormatException}.\n+ *     <li><p>{@code c} can specify the following method parameter combinations:\n+ *     <ul>\n+ *         <li><p>void<\/li>\n+ *         <li><p>One parameter: {@link TestInfo} which provides some information about {@code t} and utility methods.<\/li>\n+ *         <li><p>One parameter: the <i>exact<\/i> same type as the return value of {@code t}. When {@code c} is\n+ *                invoked by the framework, this parameter contains the return value of {@code t}.<\/li>\n+ *         <li><p>1st parameter: {@link TestInfo}; 2nd parameter: the <i>exact<\/i> same type as the return value of\n+ *                {@code t} (see above)<\/li>\n+ *         <li><p> Any other combination will result in a {@link TestFormatException}.\n+ *     <\/ul>\n+ *     <li><p>{@code c} is not compiled nor inlined.\n+ *     <li><p>{@code c} must be part of the test class. Using {@code @Check} in nested or other classes is not allowed.<\/li>\n+ *     <li><p>{@code c} cannot specify any helper-method-specific compile command annotations\n+ *            ({@link ForceCompile @ForceCompile}, {@link DontCompile @DontCompile}, {@link ForceInline @ForceInline},\n+ *            {@link DontInline @DontInline}).<\/li>\n+ * <\/ul>\n+ *\n+ * <p>\n+ * If no verification is required, use a <i>base test<\/i> (see {@link Test}). If {@code t} must be invoked with more\n+ * complex or varying arguments and\/or the {@code t} must be invoked differently in subsequent invocations, use a\n+ * <i>custom run test<\/i> (see {@link Run}).\n+ *\n+ * <p>\n+ * Examples on how to write checked tests can be found in {@link jdk.test.lib.hotspot.ir_framework.examples.CheckedTestExample}\n+ * and also as part of the internal testing in the package {@link jdk.test.lib.hotspot.ir_framework.tests}.\n+ *\n+ * @see Test\n+ * @see TestInfo\n+ * @see CheckAt\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface Check {\n+    \/**\n+     * The unique associated {@link Test} method for this {@code @Check} annotated check method. The framework will directly\n+     * invoke the {@code @Check} method after each invocation or only after the compilation of the associated {@code @Test}\n+     * method (depending on the value set with {@link #when()}).\n+     * <p>\n+     * If a non-{@code @Test} annotated method or a {@code @Test} method that has already been used by another\n+     * {@code @Check} or {@link Run} method is specified, then a {@link TestFormatException} is thrown.\n+     *\n+     * @see Test\n+     *\/\n+    String test();\n+    \/**\n+     * When should the {@code @Check} method be invoked? By default, the check is done after each invocation which is\n+     * encouraged if performance is not critical.\n+     *\n+     * @see CheckAt\n+     *\/\n+    CheckAt when() default CheckAt.EACH_INVOCATION;\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Check.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+\/**\n+ * This enum is used in {@link Check#when()} of a <b>checked test<\/b> to specify when the framework will invoke the\n+ * check method after invoking the associated {@link Test} method.\n+ *\n+ * @see Check\n+ * @see Test\n+ *\/\n+public enum CheckAt {\n+    \/**\n+     * Default: Invoke the {@link Check} method each time after invoking the associated {@link Test} method.\n+     *\/\n+    EACH_INVOCATION,\n+    \/**\n+     * Invoke the {@link Check} method only once after the warm-up of the associated {@link Test} method had been completed\n+     * and the framework has compiled the associated {@link Test} method.\n+     *\/\n+    COMPILED,\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/CheckAt.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+import compiler.lib.ir_framework.shared.TestRun;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import compiler.lib.ir_framework.test.TestVM;\n+import jdk.test.lib.Utils;\n+\n+import java.lang.reflect.Executable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\/**\n+ * Compilation levels used by the framework to initiate a compilation of a method. The compilation levels map to the used\n+ * levels in HotSpot (apart from the framework specific values {@link #SKIP} and {@link #WAIT_FOR_COMPILATION} that cannot\n+ * be found in HotSpot). The HotSpot specific levels must be in sync with hotspot\/share\/compiler\/compilerDefinitions.hpp.\n+ *\n+ * <p>\n+ * The compilation levels can be specified in the {@link Test}, {@link ForceCompile}, and\n+ * {@link ForceCompileClassInitializer} annotation.\n+ *\n+ * @see Test\n+ * @see ForceCompile\n+ * @see ForceCompileClassInitializer\n+ *\/\n+public enum CompLevel {\n+    \/**\n+     * Can only be used at {@link Test#compLevel()}. After the warm-up, the framework keeps invoking the test over a span\n+     * of 10s (configurable by setting the property flag {@code -DWaitForCompilationTimeout}) until HotSpot compiles the\n+     * {@link Test} method. If the method was not compiled after 10s, an exception is thrown. The framework does not wait\n+     * for the compilation if the test VM is run with {@code -Xcomp}, {@code -XX:-UseCompiler}, or\n+     * {@code -DExcludeRandom=true}.\n+     *\/\n+    WAIT_FOR_COMPILATION(-4),\n+    \/**\n+     * Can only be used at {@link Test#compLevel()}. Skip a compilation of the {@link Test @Test} method completely.\n+     *\/\n+    SKIP(-3),\n+    \/**\n+     *  Use any compilation level depending on the usage:\n+     *  <ul>\n+     *      <li><p>{@link Test @Test}, {@link ForceCompile @ForceCompile}: Use the highest available compilation level\n+     *      which is usually C2.<\/li>\n+     *      <li><p>{@link DontCompile @DontCompile}: Prevents any compilation of the associated helper method.<\/li>\n+     *  <\/ul>\n+     *\/\n+    ANY(-1),\n+    \/**\n+     *  Compilation level 1: C1 compilation without any profile information.\n+     *\/\n+    C1_SIMPLE(1),\n+    \/**\n+     *  Compilation level 2: C1 compilation with limited profile information: Includes Invocation and backedge counters.\n+     *\/\n+    C1_LIMITED_PROFILE(2),\n+    \/**\n+     *  Compilation level 3: C1 compilation with full profile information: Includes Invocation and backedge counters with MDO.\n+     *\/\n+    C1_FULL_PROFILE(3),\n+    \/**\n+     * Compilation level 4: C2 compilation with full optimizations.\n+     *\/\n+    C2(4),\n+\n+    ;\n+\n+    private static final Map<Integer, CompLevel> TYPES_BY_VALUE = new HashMap<>();\n+    private final int value;\n+\n+    static {\n+        for (CompLevel level : CompLevel.values()) {\n+            TYPES_BY_VALUE.put(level.value, level);\n+        }\n+    }\n+\n+    CompLevel(int level) {\n+        this.value = level;\n+    }\n+\n+    \/**\n+     * Get the compilation level as integer value. These will match the levels specified in HotSpot (if available).\n+     *\n+     * @return the compilation level as integer.\n+     *\/\n+    public int getValue() {\n+        return value;\n+    }\n+\n+    \/**\n+     * Get the compilation level enum from the specified integer.\n+     *\n+     * @param value the compilation level as integer.\n+     * @throws TestRunException if {@code value} does not specify a valid compilation level.\n+     * @return the compilation level enum for {@code value}.\n+     *\/\n+    public static CompLevel forValue(int value) {\n+        CompLevel level = TYPES_BY_VALUE.get(value);\n+        TestRun.check(level != null, \"Invalid compilation level \" + value);\n+        return level;\n+    }\n+\n+    \/**\n+     * Called by {@link TestFramework} to check if this compilation level is not part of the compiler.\n+     *\/\n+    public boolean isNotCompilationLevelOfCompiler(Compiler c) {\n+        return switch (c) {\n+            case C1 -> !isC1();\n+            case C2 -> this != C2;\n+            default -> throw new TestFrameworkException(\"Should not be called with compiler \" + c);\n+        };\n+    }\n+\n+    \/**\n+     * Called by {@link TestFramework} to flip compilation levels.\n+     *\/\n+    public CompLevel flipCompLevel() {\n+        switch (this) {\n+            case C1_SIMPLE, C1_LIMITED_PROFILE, C1_FULL_PROFILE -> {\n+                return CompLevel.C2;\n+            }\n+            case C2 -> {\n+                return CompLevel.C1_SIMPLE;\n+            }\n+        }\n+        return this;\n+    }\n+\n+    \/**\n+     * Called by {@link TestFramework}. Return the compilation level when only allowing a compilation with the specified\n+     * compiler.\n+     *\/\n+    public CompLevel excludeCompilationRandomly(Executable ex) {\n+        if (Utils.getRandomInstance().nextBoolean()) {\n+            \/\/ No exclusion\n+            return this;\n+        }\n+        Compiler compiler = TestVM.excludeRandomly(ex);\n+        return switch (compiler) {\n+            case ANY -> SKIP;\n+            case C1 -> isC1() ? SKIP : this;\n+            case C2 -> this == C2 ? SKIP : this;\n+        };\n+    }\n+\n+    private boolean isC1() {\n+        return this == C1_SIMPLE || this == C1_LIMITED_PROFILE || this == C1_FULL_PROFILE;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/CompLevel.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+\/**\n+ * Compilers to select for {@link DontCompile}. HotSpot does not handle the exclusion of a C1 method at a specific level.\n+ * It can only exclude a method for the entire C1 compilation. Thus, this annotation is provided for {@link DontCompile}\n+ * instead of {@link CompLevel}.\n+ *\n+ * @see DontCompile\n+ *\/\n+public enum Compiler {\n+    \/**\n+     * Selecting both the C1 and C2 compiler. This must be in sync with hotspot\/share\/compiler\/compilerDefinitions.hpp.\n+     *\/\n+    ANY(-1),\n+    \/**\n+     * The C1 compiler.\n+     *\/\n+    C1(1),\n+    \/**\n+     * The C2 compiler.\n+     *\/\n+    C2(4),\n+\n+    ;\n+\n+    private final int value;\n+\n+    Compiler(int level) {\n+        this.value = level;\n+    }\n+\n+    \/**\n+     * Get the compilation level as integer value. These will match the levels specified in HotSpot (if available).\n+     *\n+     * @return the compilation level as integer.\n+     *\/\n+    public int getValue() {\n+        return value;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Compiler.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/**\n+ * Prevent a compilation of the annotated <b>helper method<\/b> (not specifying {@link Test @Test},\n+ * {@link Check @Check} or {@link Run @Run}) with the specified compiler.\n+ *\n+ * <ul>\n+ *     <li><p>{@link Compiler#ANY} (default): No C1 or C2 compilation.<\/li>\n+ *     <li><p>{@link Compiler#C1}: No C1 compilation, C2 compilation still possible.<\/li>\n+ *     <li><p>{@link Compiler#C2}: No C2 compilation, C1 compilation still possible.<\/li>\n+ * <\/ul>\n+ * <p>\n+ * Using this annotation on <i>non-helper methods<\/i> results in a {@link TestFormatException TestFormatException}.\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface DontCompile {\n+    \/**\n+     * The compiler with which a compilation of a helper method is excluded.\n+     *\/\n+    Compiler value() default Compiler.ANY;\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/DontCompile.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/**\n+ * Prevent an inlining of the annotated <b>helper method<\/b> (not specifying {@link Test @Test}, {@link Check @Check},\n+ * or {@link Run @Run}). <i>Non-helper methods<\/i> are never inlined. Explicitly using this annotation on\n+ * <i>non-helper methods<\/i> results in a {@link TestFormatException}.\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface DontInline {\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/DontInline.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/**\n+ * Force a compilation of the annotated <b>helper method<\/b> (not specifying {@link Test @Test}, {@link Check @Check},\n+ * or {@link Test @Run}) immediately at the specified level. {@link CompLevel#SKIP} and\n+ * {@link CompLevel#WAIT_FOR_COMPILATION} do not apply and result in a {@link TestFormatException}.\n+ *\n+ * <p>\n+ * Using this annotation on <i>non-helper<\/i> methods also results in a {@link TestFormatException}.\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface ForceCompile {\n+    \/**\n+     * The compilation level to compile the helper method at.\n+     *\/\n+    CompLevel value() default CompLevel.ANY;\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/ForceCompile.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/**\n+ * Force a compilation of the static class initializer method ({@code <clinit>}) of the annotated test or helper class\n+ * immediately at the specified level. {@link CompLevel#SKIP} and {@link CompLevel#WAIT_FOR_COMPILATION} do not apply\n+ * and result in a {@link TestFormatException}.\n+\n+ * <p>\n+ *  Using this annotation on non-classes also results in a {@link TestFormatException}.\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface ForceCompileClassInitializer {\n+    \/**\n+     * The compilation level to compile the static class initializer method ({@code <clinit>}) at.\n+     *\/\n+    CompLevel value() default CompLevel.ANY;\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/ForceCompileClassInitializer.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/**\n+ * Force an inlining of the annotated <b>helper method<\/b> (not specifying {@link Test @Test}, {@link Check @Check},\n+ * or {@link Test @Run}). Using this annotation on <i>non-helper methods<\/i> results in a {@link TestFormatException}.\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface ForceInline {\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/ForceInline.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.driver.IRViolationException;\n+\n+import java.lang.annotation.Repeatable;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/**\n+ * This annotation is used to define a constraint\/rule\/check on the resulting IR of a test method (method with\n+ * {@link Test @Test} annotation). A test method can define multiple {@code @IR} rules.\n+ * <p>\n+ * There are two kinds of checks that can be specified:\n+ * <ul>\n+ *     <li><p>{@link #failOn()}: Specify a list of (node) regexes that should not be matched on the {@code PrintIdeal} or\n+ *            {@code PrintOptoAssembly} output.<\/li>\n+ *     <li><p>{@link #counts()}: Specify a list of ({@code regex,count}) pairs: The (node) {@code regex} should be matched\n+ *            for the specified amount in {@code count} on the {@code PrintIdeal} or {@code PrintOptoAssembly} output.<\/li>\n+ * <\/ul>\n+ * An IR rule must specify either or both of these two checks. If one or both of the checks fails, an\n+ * {@link IRViolationException} is thrown. A user can provide a custom regex string or specify any of the default node\n+ * regexes defined in {@link IRNode}.\n+ * <p>\n+ * Sometimes, the shape of the resulting IR is changed by commonly used VM flags in such a way that an IR rule no longer\n+ * applies. Generally, the framework does <b>not<\/b> apply any IR rules when any of the following flags are used:\n+ * {@code -Xint, -XX:-UseCompiler, -XX:TieredStopAtLevel={1,2,3}, -DExcludeRandom=true, -DFlipC1C2=true}.\n+ * Furthermore, a JTreg test could be run with additional VM and Javaoptions flags. The IR verification is <b>not<\/b>\n+ * performed in this case if any of these JTreg flags is used that is not part of the whitelist specified by\n+ * {@link TestFramework#JTREG_WHITELIST_FLAGS}.\n+ * <p>\n+ * For any other flag specified either by user code (e.g. {@link Scenario#Scenario(int, String...)},\n+ * {@link TestFramework#runWithFlags(String...) etc.} or as part of the JTreg whitelist, IR verification is applied.\n+ * To restrict the application of IR rules when certain flags are present that could change the IR, each {@code @IR}\n+ * annotation can specify additional preconditions on the allowed test VM flags that must hold when an IR rule is applied.\n+ * If the specified preconditions fail, then the framework does not apply the IR rule. These preconditions can be\n+ * set with {@link #applyIf()}, {@link #applyIfNot()}, {@link #applyIfAnd()}, or {@link #applyIfOr()}.\n+ * <p>\n+ * Examples on how to write tests with IR rules can be found in {@link jdk.test.lib.hotspot.ir_framework.examples.IRExample}\n+ * and also as part of the internal testing in {@link jdk.test.lib.hotspot.ir_framework.tests.TestIRMatching}.\n+ *\n+ * @see Test\n+ * @see IRNode\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+@Repeatable(IRs.class)\n+public @interface IR {\n+    \/**\n+     * Define a list of (node) regexes. If any of these regexes are matched on the PrintIdeal or PrintOptoAssembly, the\n+     * IR rule fails and an {@link IRViolationException} is thrown.\n+     *\/\n+    String[] failOn() default {};\n+\n+    \/**\n+     * Define a list of ((node) regexes,count) string pairs: A regex to be matched on the PrintIdeal or PrintOptoAssembly\n+     * is immediately followed by a number specifying how often the regex should be matched. The number can be proceeded\n+     * by comparators ({@code =, !=, <, <=, =>, >}) where the equality operator is optional (default if no comparator is\n+     * specified).\n+     * <p>\n+     * If any constraint on the number of regexes cannot be met, the IR rule fails and an\n+     * {@link IRViolationException} is thrown.\n+     *\/\n+    String[] counts() default {};\n+\n+    \/**\n+     * Define a single VM flag precondition which <i>must hold<\/i> when applying the IR rule. If the VM flag precondition\n+     * fails, then the IR rule is not applied. This is useful if a commonly used flag alters the IR in such a way that an IR rule\n+     * would fail.\n+     * <p>\n+     * The precondition is a (flag, value) string pair where the flag must be a valid VM flag and the value must conform\n+     * with the type of the VM flag. A number based flag value can be proceeded with an additional comparator\n+     * ({@code =, !=, <, <=, =>, >}) where the equality operator is optional (default if no comparator is specified).\n+     * <p>\n+     * This is the inverse of {@link #applyIfNot()}. For multiple preconditions, use {@link #applyIfAnd()} or\n+     * {@link #applyIfOr()} depending on the use case.\n+     *\/\n+    String[] applyIf() default {};\n+\n+    \/**\n+     * Define a single VM flag precondition which <i>must <b>not<\/b> hold<\/i> when applying the IR rule. If, however,\n+     * the VM flag precondition holds, then the IR rule is not applied. This could also be defined as <i>negative<\/i>\n+     * precondition. This is useful if a commonly used flag alters the IR in such a way that an IR rule would fail.\n+     * <p>\n+     * The precondition is a (flag, value) string pair where the flag must be a valid VM flag and the value must conform\n+     * with the type of the VM flag. A number based flag value can be proceeded with an additional comparator\n+     * ({@code =, !=, <, <=, =>, >}) where the equality operator is optional (default if no comparator is specified).\n+     * <p>\n+     * This is the inverse of {@link #applyIf()}. For multiple preconditions, use {@link #applyIfAnd()} or\n+     * {@link #applyIfOr()} depending on the use case.\n+     *\/\n+    String[] applyIfNot() default {};\n+\n+    \/**\n+     * Define a list of at least two VM flag precondition which <i><b>all<\/b> must hold<\/i> when applying the IR rule.\n+     * If the one of the VM flag preconditions does not hold, then the IR rule is not applied. This is useful if\n+     * commonly used flags alter the IR in such a way that an IR rule would fail. This can also be defined as conjunction\n+     * of preconditions.\n+     * <p>\n+     * A precondition is a (flag, value) string pair where the flag must be a valid VM flag and the value must conform\n+     * with the type of the VM flag. A number based flag value can be proceeded with an additional comparator\n+     * ({@code =, !=, <, <=, =>, >}) where the equality operator is optional (default if no comparator is specified).\n+     * <p>\n+     * Use  {@link #applyIfOr()} for disjunction and for single precondition constraints use {@link #applyIf()} or\n+     * {@link #applyIfNot()} depending on the use case.\n+     *\/\n+    String[] applyIfAnd() default {};\n+\n+    \/**\n+     * Define a list of at least two VM flag precondition from which <i><b>at least one<\/b> must hold<\/i> when applying\n+     * the IR rule. If none of the VM flag preconditions holds, then the IR rule is not applied. This is useful if\n+     * commonly used flags alter the IR in such a way that an IR rule would fail. This can also be defined as disjunction\n+     * of preconditions.\n+     * <p>\n+     * A precondition is a (flag, value) string pair where the flag must be a valid VM flag and the value must conform\n+     * with the type of the VM flag. A number based flag value can be proceeded with an additional comparator\n+     * ({@code =, !=, <, <=, =>, >}) where the equality operator is optional (default if no comparator is specified).\n+     * <p>\n+     * Use  {@link #applyIfAnd()} for conjunction and for single precondition constraints use {@link #applyIf()} or\n+     * {@link #applyIfNot()} depending on the use case.\n+     *\/\n+    String[] applyIfOr() default {};\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IR.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.driver.IRMatcher;\n+import compiler.lib.ir_framework.shared.TestFormat;\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * This class provides default regex strings that can be used in {@link IR @IR} annotations to specify IR constraints.\n+ * <p>\n+ * There are two types of default regexes:\n+ * <ul>\n+ *     <li><p>Standalone regexes: Use them directly.<\/li>\n+ *     <li><p>Composite regexes: Their names contain \"{@code _OF}\" and expect another string in a list in\n+ *            {@link IR#failOn()} and {@link IR#counts()}. They cannot be use as standalone regex and will result in a\n+ *            {@link TestFormatException} when doing so.<\/li>\n+ * <\/ul>\n+ *\n+ * @see IR\n+ *\/\n+public class IRNode {\n+    private static final String START = \"(\\\\d+(\\\\s){2}(\";\n+    private static final String MID = \".*)+(\\\\s){2}===.*\";\n+    private static final String END = \")\";\n+\n+    public static final String ALLOC = \"(.*precise klass .*\\\\R(.*(movl|xorl|nop|spill).*\\\\R)*.*call,static  wrapper for: _new_instance_Java\" + END;\n+    public static final String ALLOC_OF = \"(.*precise klass .*\";\n+    public static final String ALLOC_ARRAY = \"(.*precise klass \\\\[L.*\\\\R(.*(movl|xorl|nop|spill).*\\\\R)*.*call,static  wrapper for: _new_array_Java\" + END;\n+    public static final String ALLOC_ARRAY_OF = \"(.*precise klass \\\\[L.*\";\n+\n+    public static final String CHECKCAST_ARRAY = \"(cmp.*precise klass \\\\[.*;:\" + END;\n+    public static final String CHECKCAST_ARRAY_OF = \"(cmp.*precise klass \\\\[.*\";\n+    public static final String CHECKCAST_ARRAYCOPY = \"(.*call_leaf_nofp,runtime  checkcast_arraycopy.*\" + END;\n+\n+    public static final String FIELD_ACCESS = \"(.*Field: *\" + END;\n+\n+    public static final String STORE = START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + END;\n+    public static final String STORE_B = START + \"StoreB\" + MID + END; \/\/ Store to boolean is also mapped to byte\n+    public static final String STORE_C = START + \"StoreC\" + MID + END;\n+    public static final String STORE_I = START + \"StoreI\" + MID + END; \/\/ Store to short is also mapped to int\n+    public static final String STORE_L = START + \"StoreL\" + MID + END;\n+    public static final String STORE_F = START + \"StoreF\" + MID + END;\n+    public static final String STORE_D = START + \"StoreD\" + MID + END;\n+    public static final String STORE_P = START + \"StoreP\" + MID + END;\n+    public static final String STORE_N = START + \"StoreN\" + MID + END;\n+    public static final String STORE_OF_CLASS = START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + \"@\\\\S*\";\n+    public static final String STORE_B_OF_CLASS = START + \"StoreB\" + MID + \"@\\\\S*\";\n+    public static final String STORE_C_OF_CLASS = START + \"StoreC\" + MID + \"@\\\\S*\";\n+    public static final String STORE_I_OF_CLASS = START + \"StoreI\" + MID + \"@\\\\S*\";\n+    public static final String STORE_L_OF_CLASS = START + \"StoreL\" + MID + \"@\\\\S*\";\n+    public static final String STORE_F_OF_CLASS = START + \"StoreF\" + MID + \"@\\\\S*\";\n+    public static final String STORE_D_OF_CLASS = START + \"StoreD\" + MID + \"@\\\\S*\";\n+    public static final String STORE_P_OF_CLASS = START + \"StoreP\" + MID + \"@\\\\S*\";\n+    public static final String STORE_N_OF_CLASS = START + \"StoreN\" + MID + \"@\\\\S*\";\n+    public static final String STORE_OF_FIELD = START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + \"@.*name=\";\n+\n+    public static final String LOAD = START + \"Load(B|UB|S|US|I|L|F|D|P|N)\" + MID + END;\n+    public static final String LOAD_B = START + \"LoadB\" + MID + END;\n+    public static final String LOAD_UB = START + \"LoadUB\" + MID + END; \/\/ Load from boolean\n+    public static final String LOAD_S = START + \"LoadS\" + MID + END;\n+    public static final String LOAD_US = START + \"LoadUS\" + MID + END; \/\/ Load from char\n+    public static final String LOAD_I = START + \"LoadI\" + MID + END;\n+    public static final String LOAD_L = START + \"LoadL\" + MID + END;\n+    public static final String LOAD_F = START + \"LoadF\" + MID + END;\n+    public static final String LOAD_D = START + \"LoadD\" + MID + END;\n+    public static final String LOAD_P = START + \"LoadP\" + MID + END;\n+    public static final String LOAD_N = START + \"LoadN\" + MID + END;\n+    public static final String LOAD_OF_CLASS = START + \"Load(B|UB|S|US|I|L|F|D|P|N)\" + MID + \"@\\\\S*\";\n+    public static final String LOAD_B_OF_CLASS = START + \"LoadB\" + MID + \"@\\\\S*\";\n+    public static final String LOAD_UB_OF_CLASS = START + \"LoadUB\" + MID + \"@\\\\S*\";\n+    public static final String LOAD_S_OF_CLASS = START + \"LoadS\" + MID + \"@\\\\S*\";\n+    public static final String LOAD_US_OF_CLASS = START + \"LoadUS\" + MID + \"@\\\\S*\";\n+    public static final String LOAD_I_OF_CLASS = START + \"LoadI\" + MID + \"@\\\\S*\";\n+    public static final String LOAD_L_OF_CLASS = START + \"LoadL\" + MID + \"@\\\\S*\";\n+    public static final String LOAD_F_OF_CLASS = START + \"LoadF\" + MID + \"@\\\\S*\";\n+    public static final String LOAD_D_OF_CLASS = START + \"LoadD\" + MID + \"@\\\\S*\";\n+    public static final String LOAD_P_OF_CLASS = START + \"LoadP\" + MID + \"@\\\\S*\";\n+    public static final String LOAD_N_OF_CLASS = START + \"LoadN\" + MID + \"@\\\\S*\";\n+    public static final String LOAD_OF_FIELD = START + \"Load(B|C|S|I|L|F|D|P|N)\" + MID + \"@.*name=\";\n+    public static final String LOAD_KLASS  = START + \"LoadK\" + MID + END;\n+\n+    public static final String LOOP   = START + \"Loop\" + MID + \"\" + END;\n+    public static final String COUNTEDLOOP = START + \"CountedLoop\\\\b\" + MID + \"\" + END;\n+    public static final String COUNTEDLOOP_MAIN = START + \"CountedLoop\\\\b\" + MID + \"main\" + END;\n+\n+    public static final String CALL = START + \"CallStaticJava\" + MID + END;\n+    public static final String TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*reason\" + END;\n+    public static final String PREDICATE_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*predicate\" + END;\n+    public static final String UNSTABLE_IF_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*unstable_if\" + END;\n+    public static final String CLASS_CHECK_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*class_check\" + END;\n+    public static final String NULL_CHECK_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*null_check\" + END;\n+    public static final String NULL_ASSERT_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*null_assert\" + END;\n+    public static final String RANGE_CHECK_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*range_check\" + END;\n+    public static final String UNHANDLED_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*unhandled\" + END;\n+    public static final String INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*intrinsic_or_type_checked_inlining\" + END;\n+\n+    public static final String SCOPE_OBJECT = \"(.*# ScObj.*\" + END;\n+    public static final String MEMBAR = START + \"MemBar\" + MID + END;\n+\n+\n+    private static final String ALLOC_OF_POSTFIX =  \":.*\\\\R(.*(movl|xorl|nop|spill).*\\\\R)*.*call,static  wrapper for: _new_instance_Java\" + END;\n+    private static final String ALLOC_ARRAY_OF_POSTFIX = \";:.*\\\\R(.*(movl|xorl|nop|spill).*\\\\R)*.*call,static  wrapper for: _new_array_Java\" + END;\n+    private static final String CHECKCAST_ARRAY_OF_POSTFIX = \";:\" + END;\n+    private static final String STORE_OF_FIELD_POSTFIX = \",.*\" + END;\n+    private static final String STORE_OF_CLASS_POSTFIX = \"(:|\\\\+)\\\\S* \\\\*\" + END;\n+    private static final String LOAD_OF_CLASS_POSTFIX = \"(:|\\\\+)\\\\S* \\\\*\" + END;\n+    private static final String LOAD_OF_FIELD_POSTFIX = \",.*\" + END;\n+\n+    \/**\n+     * Called by {@link IRMatcher} to merge special composite nodes together with additional user-defined input.\n+     *\/\n+    public static List<String> mergeNodes(String[] nodes) {\n+        List<String> mergedNodes = new ArrayList<>();\n+        for (int i = 0; i < nodes.length; i += 2) {\n+            String node = nodes[i];\n+            switch (node) {\n+                case ALLOC_OF -> mergeCompositeNodes(nodes, mergedNodes, i, node, ALLOC_OF_POSTFIX, \"ALLOC_OF\");\n+                case ALLOC_ARRAY_OF -> mergeCompositeNodes(nodes, mergedNodes, i, node, ALLOC_ARRAY_OF_POSTFIX, \"ALLOC_ARRAY_OF\");\n+                case CHECKCAST_ARRAY_OF -> mergeCompositeNodes(nodes, mergedNodes, i, node, CHECKCAST_ARRAY_OF_POSTFIX, \"CHECKCAST_ARRAY_OF\");\n+                case STORE_OF_CLASS, STORE_B_OF_CLASS, STORE_C_OF_CLASS, STORE_D_OF_CLASS, STORE_F_OF_CLASS, STORE_I_OF_CLASS,\n+                        STORE_L_OF_CLASS, STORE_N_OF_CLASS, STORE_P_OF_CLASS\n+                        -> mergeCompositeNodes(nodes, mergedNodes, i, node, STORE_OF_CLASS_POSTFIX, \"STORE_OF_CLASS\");\n+                case STORE_OF_FIELD -> mergeCompositeNodes(nodes, mergedNodes, i, node, STORE_OF_FIELD_POSTFIX, \"STORE_OF_FIELD\");\n+                case LOAD_OF_CLASS, LOAD_B_OF_CLASS, LOAD_UB_OF_CLASS, LOAD_D_OF_CLASS, LOAD_F_OF_CLASS, LOAD_I_OF_CLASS, LOAD_L_OF_CLASS,\n+                        LOAD_N_OF_CLASS, LOAD_P_OF_CLASS, LOAD_S_OF_CLASS, LOAD_US_OF_CLASS\n+                        -> mergeCompositeNodes(nodes, mergedNodes, i, node, LOAD_OF_CLASS_POSTFIX, \"LOAD_OF_CLASS\");\n+                case LOAD_OF_FIELD -> mergeCompositeNodes(nodes, mergedNodes, i, node, LOAD_OF_FIELD_POSTFIX, \"LOAD_OF_FIELD\");\n+                default -> {\n+                    i--; \/\/ No composite node, do not increment by 2.\n+                    mergedNodes.add(node);\n+                }\n+            }\n+        }\n+        return mergedNodes;\n+    }\n+\n+    private static void mergeCompositeNodes(String[] nodes, List<String> mergedNodes, int i, String node, String postFix, String varName) {\n+        TestFormat.check(i + 1 < nodes.length, \"Must provide class name at index \" + (i + 1) + \" right after \" + varName);\n+        mergedNodes.add(node + Pattern.quote(nodes[i + 1]) + postFix);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/**\n+ * Annotation to allow to specify multiple {@link IR @IR} annotations at a {@link Test @Test} method.\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface IRs {\n+    IR[] value();\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRs.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+# IR Test Framework\n+This folder contains a test framework whose main purpose is to perform regex-based checks on the C2 IR shape of test methods emitted by the VM flags _-XX:+PrintIdeal_ and _-XX:+PrintOptoAssembly_. The framework can also be used for other non-IR matching (and non-compiler) tests by providing easy to use annotations for commonly used testing patterns and compiler control flags.\n+\n+## 1. How to Use the Framework\n+The framework is intended to be used in JTreg tests. The JTreg header of the test must contain `@library \/test\/lib \/` (2 paths) and should be run as a driver with `@run driver`. Annotate the test code with the supported framework annotations and call the framework from within the test's `main()` method. A simple example is shown below:\n+\n+    \/*\n+     * @test\n+     * @summary A simple test using the test framework.\n+     * @library \/test\/lib \/\n+     * @run driver my.package.MySimpleTest\n+     *\/\n+    \n+    package my.package;\n+    \n+    import compiler.lib.ir_framework.*;\n+\n+    public class MySimpleTest {\n+        \n+        public static void main(String[] args) {\n+            TestFramework.run(); \/\/ The framework runs all tests of this class.\n+        }\n+    \n+        @Test\n+        @IR(failOn = IRNode.STORE) \/\/ Fail if the IR of myTest() contains any stores.\n+        public void myTest() {\n+            \/* ... *\/\n+        }\n+    }\n+\n+There are various ways how to set up and run a test within the `main()` method of a JTreg test. These are described and can be found in the [TestFramework](.\/TestFramework.java) class.\n+   \n+## 2. Features\n+The framework offers various annotations and flags to control how your test code should be invoked and being checked. This section gives an overview over all these features.\n+\n+### 2.1 Different Tests\n+There are three kinds of tests depending on how much control is needed over the test invocation.\n+#### Base Tests\n+The simplest form of testing provides a single `@Test` annotated method which the framework will invoke as part of the testing. The test method has no or well-defined arguments that the framework can automatically provide. \n+\n+More information on base tests with a precise definition can be found in the Javadocs of [Test](.\/Test.java). Concrete examples on how to specify a base test can be found in [BaseTestsExample](..\/..\/..\/testlibrary_tests\/ir_framework\/examples\/BaseTestExample.java).\n+\n+#### Checked Tests\n+The base tests do not provide any way of verification by user code. A checked test enables this by allowing the user to define an additional `@Check` annotated method which is invoked directly after the `@Test` annotated method. This allows the user to perform various checks about the test method including return value verification.\n+\n+More information on checked tests with a precise definition can be found in the Javadocs of [Check](.\/Check.java). Concrete examples on how to specify a checked test can be found in [CheckedTestsExample](..\/..\/..\/testlibrary_tests\/ir_framework\/examples\/CheckedTestExample.java).\n+\n+#### Custom Run Tests\n+Neither the base nor the checked tests provide any control over how a `@Test` annotated method is invoked in terms of customized argument values and\/or conditions for the invocation itself. A custom run test gives full control over the invocation of the `@Test` annotated method to the user. The framework calls a dedicated `@Run` annotated method from which the user can invoke the `@Test` method according to his\/her needs.\n+\n+More information on checked tests with a precise definition can be found in the Javadocs of [Run](.\/Run.java). Concrete examples on how to specify a custom run test can be found in [CustomRunTestsExample](..\/..\/..\/testlibrary_tests\/ir_framework\/examples\/CustomRunTestExample.java).\n+\n+### 2.2 IR Verification\n+The main feature of this framework is to perform a simple but yet powerful regex-based C2 IR matching on the output of _-XX:+PrintIdeal_ and _-XX:+PrintOptoAssembly_. For simplicity, we will refer to the \"IR\" or \"IR matching\" when actually meaning the combined output of _-XX:+PrintIdeal_ and _-XX:+PrintOptoAssembly_ for a C2 compilation.\n+\n+The user has the possibility to add an additional `@IR` annotation to any `@Test` annotated method (regardless of the kind of test mentioned in section 2.1) to specify a constraint\/rule on the compiled IR shape. The `@IR` annotation provides two kinds of regex checks:\n+\n+ - A `failOn` check that verifies that the provided regex is not matched in the C2 IR.\n+ - A `counts` check that verifies that the provided regex is matched a user defined number of times in the C2 IR.\n+ \n+A regex can either be a custom string or any of the default regexes provided by the framework in [IRNode](.\/IRNode.java) for some commonly used IR nodes (also provides the possibility of composite regexes).\n+\n+An IR verification cannot always be performed. For example, a JTreg test could be run with _-Xint_ or not a debug build (_-XX:+PrintIdeal_ and _-XX:+PrintOptoAssembly_ are debug build flags). But also CI tier testing could add additional JTreg VM and Javaoptions flags which could make an IR rule unstable. \n+\n+In general, the framework will only perform IR verification if the used VM flags allow a C2 compilation and if non-critical additional JTreg VM and Javaoptions are provided (see whiteflag list in [TestFramework](.\/TestFramework.java)). The user test code, however, can specify any flags which still allow an IR verification to be performed if a C2 compilation is done (expected flags by user defined `@IR` annotations). \n+\n+An `@IR` annotation allows additional preconditions\/restrictions on the currently present VM flags to enable or disable rules when certain flags are present or have a specific value (see `applyIfXX` properties of an `@IR` annotation).\n+\n+More information about IR matching can be found in the Javadocs of [IR](.\/IR.java). Concrete examples on how to specify IR constraint\/rules can be found in [IRExample](..\/..\/..\/testlibrary_tests\/ir_framework\/examples\/IRExample.java) and [TestIRMatching](..\/..\/..\/testlibrary_tests\/ir_framework\/tests\/TestIRMatching.java) (an internal framework test).\n+\n+### 2.3 Test VM Flags and Scenarios\n+The recommended way to use the framework is by defining a single `@run driver` statement in the JTreg header which, however, does not allow the specification of additional test VM flags. Instead, the user has the possibility to provide VM flags by calling `TestFramework.runWithFlags()` or by creating a `TestFramework` builder object on which `addFlags()` can be called.\n+\n+If a user wants to provide multiple flag combinations for a single test, he or she has the option to provide different scenarios. A scenario based flag will always have precedence over other user defined flags. More information about scenarios can be found in the Javadocs of [Scenario](.\/Scenario.java).\n+\n+### 2.4 Compiler Controls\n+The framework allows the use of additional compiler control annotations for helper method and classes in the same fashion as JMH does. The following annotations are supported and described in the referenced Javadocs for the annotation class:\n+\n+- [@DontInline](.\/DontInline.java)\n+- [@ForceInline](.\/ForceInline.java)\n+- [@DontCompile](.\/DontCompile.java)\n+- [@ForceCompile](.\/DontCompile.java)\n+- [@ForceCompileClassInitializer](.\/ForceCompileClassInitializer.java)\n+\n+### 2.5 Framework Debug and Stress Flags\n+The framework provides various stress and debug flags. They should mainly be used as JTreg VM and\/or Javaoptions (apart from `VerifyIR`). The following (property) flags are supported:\n+\n+- `-DVerifyIR=false`: Explicitly disable IR verification. This is useful, for example, if some scenarios use VM flags that let `@IR` annotation rules fail and the user does not want to provide separate IR rules or add flag preconditions to the already existing IR rules.\n+- `-DTest=test1,test2`: Provide a list of `@Test` method names which should be executed.\n+- `-DExclude=test3`: Provide a list of `@Test` method names which should be excluded from execution.\n+- `-DScenarios=1,2`: Provide a list of scenario indexes to specify which scenarios should be executed.\n+- `-DWarmup=200`: Provide a new default value of the number of warm-up iterations (framework default is 2000). This might have an influence on the resulting IR and could lead to matching failures (the user can also set a fixed default warm-up value in a test with `testFrameworkObject.setDefaultWarmup(200)`).\n+- `-DVerbose=true`: Enable more fain-grained logging (slows the execution down).\n+- `-DReproduce=true`: Flag to use when directly running a test VM to bypass dependencies to the driver VM state (for example, when reproducing an issue).\n+- `-DPrintTimes=true`: Print the execution time measurements of each executed test.\n+- `-DVerifyVM=true`: The framework runs the test VM with additional verification flags (slows the execution down).\n+- `-DExcluceRandom=true`: The framework randomly excludes some methods from compilation. IR verification is disabled completely with this flag.\n+- `-DFlipC1C2=true`: The framework compiles all `@Test` annotated method with C1 if a C2 compilation would have been applied and vice versa. IR verification is disabled completely with this flag.\n+- `-DShuffleTests=false`: Disables the random execution order of all tests (such a shuffling is always done by default).\n+- `-DDumpReplay=true`: Add the `DumpReplay` directive to the test VM.\n+- `-DGCAfter=true`: Perform `System.gc()` after each test (slows the execution down).\n+- `-TestCompilationTimeout=20`: Change the default waiting time (default: 10s) for a compilation of a normal `@Test` annotated method.\n+- `-DWaitForCompilationTimeout=20`: Change the default waiting time (default: 10s) for a compilation of a `@Test` annotated method with compilation level [WAIT\\_FOR\\_COMPILATION](.\/CompLevel.java).\n+- `-DIgnoreCompilerControls=false`: Ignore all compiler controls applied in the framework. This includes any compiler control annotations (`@DontCompile`, `@DontInline`, `@ForceCompile`, `@ForceInline`, `@ForceCompileStaticInitializer`), the exclusion of `@Run` and `@Check` methods from compilation, and the directive to not inline `@Test` annotated methods.\n+\n+\n+## 3. Test Framework Execution\n+This section gives an overview of how the framework is executing a JTreg test that calls the framework from within its `main()` method.\n+\n+The framework will spawn a new \"test VM\" to execute the user defined tests. The test VM collects all tests of the test class specified by the user code in `main()` and ensures that there is no violation of the required format by the framework. In a next step, the framework does the following for each test in general:\n+1. Warm the test up for a predefined number of times (default 2000). This can also be adapted for all tests by using `testFrameworkobject.setDefaultWarmup(100)` or for individual tests with an additional [@Warmup](.\/Warmup.java) annotation. \n+2. After the warm-up is finished, the framework compiles the associated `@Test` annotated method at the specified compilation level (default: C2).\n+3. After the compilation, the test is invoked one more time.\n+\n+Once the test VM terminates, IR verification (if possible) is performed on the output of the test VM. If any test throws an exception during its execution or if IR matching fails, the failures are collected and reported in a pretty format. Check the standard error and output for more information and how to reproduce these failures.\n+\n+Some of the steps above can be different due to the kind of the test or due to using non-default annotation properties. These details and differences are described in the Javadocs for the three tests (see section 2.1 Different Tests).\n+\n+More information about the internals and the workflow of the framework can be found in the Javadocs of [TestFramework](.\/TestFramework.java).  \n+ \n+## 4. Internal Framework Tests\n+There are various tests to verify the correctness of the test framework. These tests can be found in [ir_framework](..\/..\/..\/testlibrary_tests\/ir_framework) and can directly be run with JTreg. The tests are part of the normal JTreg tests of HotSpot and should be run upon changing the framework code as a minimal form of testing.\n+\n+Additional testing was performed by converting all compiler Inline Types tests that used the currently present IR test framework in Valhalla (see [JDK-8263024](https:\/\/bugs.openjdk.java.net\/browse\/JDK-8263024)). It is strongly advised to make sure a change to the framework still lets these converted tests in Valhalla pass as part of an additional testing step.\n+\n+## 5. Framework Package Structure\n+A user only needs to import classes from the package `compiler.lib.ir_framework` (e.g. `import compiler.lib.ir_framework.*;`) which represents the interface classes to the framework. The remaining framework internal classes are kept in separate subpackages and should not directly be imported:\n+\n+- `compiler.lib.ir_framework.driver`: These classes are used while running the driver VM (same VM as the one running the user code's `main()` method of a JTreg test).\n+- `compiler.lib.ir_framework.flag`: These classes are used while running the flag VM to determine additional flags for the test VM which are required for IR verification.\n+- `compiler.lib.ir_framework.test`: These classes are used while running the test VM (i.e. the actual execution of the user tests as described in section 3).\n+- `compiler.lib.ir_framework.shared`: These classes can be called from either the driver, flag, or test VM.\n+\n+## 6. Summary\n+The initial design and feature set was kept simple and straight forward and serves well for small to medium sized tests. There are a lot of possibilities to further enhance the framework and make it more powerful. This can be tackled in additional RFEs. A few ideas can be found as subtasks of the [initial RFE](https:\/\/bugs.openjdk.java.net\/browse\/JDK-8254129) for this framework.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/README.md","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/**\n+ * Annotation for a run method of a <b>custom run test<\/b>.\n+ *\n+ * <p>\n+ * Let {@code t} be a test method specifying the {@link Test @Test} annotation and {@code r} be a run method specifying\n+ * the {@code @Run(test = \"t\")} annotation. These two methods represent a so-called <i>custom run test<\/i>. The only\n+ * difference to a <i>base test<\/i> (see {@link Test}) is that the framework will not invoke the test method {@code t}\n+ * but instead the run method {@code r} which is then responsible to invoke {@code t} in any way and optionally do any\n+ * additional verification (e.g. of the return value). If {@code r} does not specify {@link RunMode#STANDALONE} as\n+ * {@link #mode()} property, the framework does the following, similar as for <i>base tests<\/i>:\n+ * <ol>\n+ *     <li><p>The framework warms {@code r} up by invoking it for a predefined number of iterations (default: 2000)\n+ *            or any number specified by an additional {@link Warmup} annotation at the run method {@code r} or by using\n+ *            {@link TestFramework#setDefaultWarmup(int)} (could also be 0 which skips the warm-up completely which is\n+ *            similar to simulating {@code -Xcomp}). More information about the warm-up in general can be found in\n+ *            {@link Warmup @Warmup}.<\/li>\n+ *     <li><p>After the warm-up, the framework compiles the test method {@code t} at the specified compilation level set by\n+ *            {@link Test#compLevel()} (default {@link CompLevel#ANY} will pick the highest available level which is usually\n+ *            {@link CompLevel#C2}).<\/li>\n+ *     <li><p>The framework invokes the run method {@code r} one more time to check the compilation.<\/li>\n+ *     <li><p>The framework checks any specified {@link IR @IR} constraints at the test method {@code t}.\n+ *            More information about IR matching can be found at {@link IR}.<\/li>\n+ * <\/ol>\n+ *\n+ * <p>\n+ *  If {@code r} specifies {@link RunMode#STANDALONE} as {@link #mode()} property, the framework gives complete\n+ *  control to the run method {@code r}:\n+ * <ol>\n+ *     <li><p>The framework invokes the run method {@code r} only one time without any warm-up or compilation of\n+ *            {@code t} ({@link Warmup @Warmup} is not allowed at {@code r} in this case).<\/li>\n+ *     <li><p>After this single invocation, the framework directly checks any specified {@link IR} constraints at the test\n+ *            method {@code t}. The run method {@code r} needs to make sure to reliably trigger a C2 compilation. Otherwise,\n+ *            IR matching will fail. More information about IR matching can be found at {@link IR}.<\/li>\n+ * <\/ol>\n+ *\n+ * <p>\n+ * The test method {@code t} and run method {@code r} have the following properties:\n+ * <ul>\n+ *     <li><p>{@code t} can specify any parameter or return type except {@link AbstractInfo} or any of its subclasses.<\/li>\n+ *     <li><p>{@code t} is not inlined.\n+ *     <li><p>{@code r} is not compiled nor inlined.\n+ *     <li><p>{@code r} is responsible to invoke {@code t} in any way (once, multiple times or even skipping on some\n+ *                      invocations of {@code r}).\n+ *     <li><p>{@code r} can specify the following method parameter combinations:\n+ *     <ul>\n+ *         <li><p>void<\/li>\n+ *         <li><p>One parameter: {@link RunInfo} which provides some information about {@code t} and utility methods.<\/li>\n+ *         <li><p>Any other combination will result in a {@link TestFormatException}.\n+ *     <\/ul>\n+ *     <li><p>{@code t} and {@code r} must be part of the test class. Using {@code @Run} and {@code @Test} in nested or\n+ *             other helper classes is not allowed.<\/li>\n+ *     <li><p>{@code t} and {@code r} cannot specify any helper-method-specific compile command annotations\n+ *            ({@link ForceCompile @ForceCompile}, {@link DontCompile @DontCompile}, {@link ForceInline @ForceInline},\n+ *            {@link DontInline @DontInline}).<\/li>\n+ * <\/ul>\n+ *\n+ * <p>\n+ * Examples on how to write custom run tests can be found in {@link jdk.test.lib.hotspot.ir_framework.examples.CustomRunTestExample}\n+ * and also as part of the internal testing in the package {@link jdk.test.lib.hotspot.ir_framework.tests}.\n+ *\n+ * @see Test\n+ * @see RunInfo\n+ * @see RunMode\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface Run {\n+    \/**\n+     * The associated {@link Test @Test} methods (one or more) for this {@code @Run} annotated run method.\n+     * The framework directly invokes the run method instead of the associated {@code @Test} methods.\n+     *\/\n+    String[] test();\n+\n+    \/**\n+     * The mode of this custom run test.\n+     *\n+     * @see RunMode\n+     *\/\n+    RunMode mode() default RunMode.NORMAL;\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Run.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,237 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.test.DeclaredTest;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import compiler.lib.ir_framework.test.TestVM;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/**\n+ * Test info class which provides some useful utility methods and information about a <b>custom run test<\/b>.\n+ *\n+ * @see Run\n+ *\/\n+public class RunInfo extends AbstractInfo {\n+    private final Method testMethod;\n+    private final DeclaredTest test;\n+    private final Map<String, DeclaredTest> tests;\n+    private final boolean hasMultipleTests;\n+\n+    public RunInfo(List<DeclaredTest> tests) {\n+        super(tests.get(0).getTestMethod().getDeclaringClass());\n+        this.test = tests.get(0);\n+        this.testMethod = test.getTestMethod();\n+        this.hasMultipleTests = tests.size() != 1;\n+        if (hasMultipleTests) {\n+            this.tests = new HashMap<>();\n+            for (DeclaredTest test : tests) {\n+                this.tests.put(test.getTestMethod().getName(), test);\n+            }\n+        } else {\n+            this.tests = null;\n+        }\n+    }\n+\n+    \/**\n+     * Get the associated test method object of this custom run test. This method can only be called if <i>one<\/i> test\n+     * method is specified in the custom run test ({@link Run#test()}). Otherwise, use {@link #getTest(String)}.\n+     *\n+     * @return the associated test method object.\n+     * @throws TestRunException if called for a custom run test that specifies multiple test methods in {@link Run#test()}.\n+     *\/\n+    public Method getTest() {\n+        checkSingleTest(\"getTest\");\n+        return testMethod;\n+    }\n+\n+    \/**\n+     * Get the associated method object of the test method with the name {@code testName}. This method can only be called\n+     * if the custom run test specifies more than one test method in ({@link Run#test()}). Otherwise, use {@link #getTest()}.\n+     *\n+     * @param testName the test method for which the method object should be returned.\n+     * @return the associated test method object with the name {@code testName}.\n+     * @throws TestRunException if there is no test method with the name {@code testName} or if called with only\n+     *         <i>one<\/i> associated test method.\n+     *\/\n+    public Method getTest(String testName) {\n+        checkMultipleTests(\"getTest\");\n+        return getMethod(testName);\n+    }\n+\n+    \/**\n+     * Return a boolean indicating if the framework skipped a compilation of the associated test method after the warm-up\n+     * due to VM flags not allowing a compilation on the requested level in {@link Test#compLevel()}. This method can only\n+     * be called if <i>one<\/i> test method is specified in the custom run test ({@link Run#test()}). Otherwise, use\n+     * {@link #isCompilationSkipped(String)}.\n+     *\n+     * @return {@code true} if the framework skipped compilation of the test;\n+     *         {@code false} otherwise.\n+     * @throws TestRunException if called for a custom run test that specifies multiple test methods in {@link Run#test()}.\n+     *\/\n+    public boolean isCompilationSkipped() {\n+        checkSingleTest(\"isCompilationSkipped\");\n+        return test.getCompLevel() == CompLevel.SKIP;\n+    }\n+\n+    \/**\n+     * Return a boolean indicating if the framework skipped a compilation of the associated test method with the name\n+     * {@code testName} after the warm-up due to VM flags not allowing a compilation on the requested level in\n+     * {@link Test#compLevel()}. This method can only be called if the custom run test specifies more than one test method\n+     * in ({@link Run#test()}). Otherwise, use {@link #isCompilationSkipped()}.\n+     *\n+     * @param testName the test method for which the method object should be returned.\n+     * @return {@code true} if the framework skipped compilation of the test;\n+     *         {@code false} otherwise.\n+     * @throws TestRunException if there is no test method with the name {@code testName} or if called with only\n+     *         <i>one<\/i> associated test method.\n+     *\/\n+    public boolean isCompilationSkipped(String testName) {\n+        checkMultipleTests(\"isCompilationSkipped\");\n+        return getDeclaredTest(testName).getCompLevel() == CompLevel.SKIP;\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the associated test method is C1 compiled. This method can only be called if\n+     * <i>one<\/i> test method is specified in the custom run test ({@link Run#test()}). Otherwise, use\n+     * {@link #isTestC1Compiled(String)}.\n+     *\n+     * @return {@code true} if the associated test method is C1 compiled;\n+     *         {@code false} otherwise.\n+     * @throws TestRunException if called for a custom run test that specifies multiple test methods in {@link Run#test()}.\n+     *\/\n+    public boolean isTestC1Compiled() {\n+        checkSingleTest(\"isTestC1Compiled\");\n+        return TestVM.isC1Compiled(testMethod);\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the associated test method with the name {@code testName} is C1 compiled.\n+     * This method can only be called if the custom run test specifies more than one test method in ({@link Run#test()}).\n+     * Otherwise, use {@link #isTestC1Compiled()}.\n+     *\n+     * @param testName the name of the test method.\n+     * @return {@code true} if the test method with the name {@code testName} is C1 compiled;\n+     *         {@code false} otherwise.\n+     * @throws TestRunException if there is no test method with the name {@code testName} or if called with only\n+     *         <i>one<\/i> associated test method.\n+     *\/\n+    public boolean isTestC1Compiled(String testName) {\n+        checkMultipleTests(\"isTestC1Compiled\");\n+        return TestVM.isC1Compiled(getMethod(testName));\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the associated test method is C2 compiled. This method can only be called if\n+     * <i>one<\/i> test method is specified in the custom run test ({@link Run#test()}). Otherwise, use\n+     * {@link #isTestC2Compiled(String)}.\n+     *\n+     * @return {@code true} if the associated test method is C2 compiled;\n+     *         {@code false} otherwise.\n+     * @throws TestRunException if called for a custom run test that specifies multiple test methods in {@link Run#test()}.\n+     *\/\n+    public boolean isTestC2Compiled() {\n+        checkSingleTest(\"isTestC2Compiled\");\n+        return TestVM.isC2Compiled(testMethod);\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the associated test method with the name {@code testName} is C2 compiled.\n+     * This method can only be called if the custom run test specifies more than one test method in ({@link Run#test()}).\n+     * Otherwise, use {@link #isTestC2Compiled()}.\n+     *\n+     * @param testName the name of the test method.\n+     * @return {@code true} if the test method with the name {@code testName} is C2 compiled;\n+     *         {@code false} otherwise.\n+     * @throws TestRunException if there is no test method with the name {@code testName} or if called with only\n+     *         <i>one<\/i> associated test method.\n+     *\/\n+    public boolean isTestC2Compiled(String testName) {\n+        checkMultipleTests(\"isTestC2Compiled\");\n+        return TestVM.isC2Compiled(getMethod(testName));\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the associated test method is compiled at {@code compLevel}. This method can only\n+     * be called if <i>one<\/i> test method is specified in the custom run test ({@link Run#test()}).\n+     * Otherwise, use {@link #isTestCompiledAtLevel(String, CompLevel)}.\n+     *\n+     * @param compLevel the compilation level\n+     * @return {@code true} if the associated test method is compiled at {@code compLevel};\n+     *         {@code false} otherwise.\n+     * @throws TestRunException if called for a custom run test that specifies multiple test methods in {@link Run#test()}.\n+     *\/\n+    public boolean isTestCompiledAtLevel(CompLevel compLevel) {\n+        checkSingleTest(\"isTestCompiledAtLevel\");\n+        return TestVM.isCompiledAtLevel(testMethod, compLevel);\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the associated test method with the name {@code testName} is compiled at\n+     * {@code compLevel}. This method can only be called if the custom run test specifies more than one test method\n+     * in ({@link Run#test()}). Otherwise, use {@link #isTestCompiledAtLevel(CompLevel)}.\n+     *\n+     * @param testName the name of the test method.\n+     * @param compLevel the compilation level.\n+     * @return {@code true} if the test method with the name {@code testName} is compiled at {@code compLevel};\n+     *         {@code false} otherwise.\n+     * @throws TestRunException if there is no test method with the name {@code testName} oor if called with only\n+     *         <i>one<\/i> associated test method.\n+     *\/\n+    public boolean isTestCompiledAtLevel(String testName, CompLevel compLevel) {\n+        checkMultipleTests(\"isTestCompiledAtLevel\");\n+        return TestVM.isCompiledAtLevel(getMethod(testName), compLevel);\n+    }\n+\n+    private void checkSingleTest(String calledMethod) {\n+        if (hasMultipleTests) {\n+            throw new TestRunException(\"Use \" + calledMethod + \"(String) with testName String argument in @Run method \" +\n+                                       \"for custom run test that specifies more than one @Test method.\");\n+        }\n+    }\n+\n+    private void checkMultipleTests(String calledMethod) {\n+        if (!hasMultipleTests) {\n+            throw new TestRunException(\"Use \" + calledMethod + \"() without testName String argument in @Run method \" +\n+                                       \"for custom run test that specifies exactly one @Test method.\");\n+        }\n+    }\n+\n+    private DeclaredTest getDeclaredTest(String testName) {\n+        DeclaredTest test = tests.get(testName);\n+        if (test == null) {\n+            throw new TestRunException(\"Could not find @Test \\\"\" + testName + \"\\\" in \" + testClass + \" being associated with\" +\n+                                       \" corresponding @Run method.\");\n+        }\n+        return test;\n+    }\n+\n+    private Method getMethod(String testName) {\n+        return getDeclaredTest(testName).getTestMethod();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/RunInfo.java","additions":237,"deletions":0,"binary":false,"changes":237,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+\/**\n+ * The run mode for a <b>custom run test<\/b> specified in {@link Run#mode}.\n+ *\n+ * @see Run\n+ *\/\n+public enum RunMode {\n+    \/**\n+     * Default mode: First warm up the run method (if a warm-up is done), then compile the associated {@link Test}\n+     * method and finally invoke the run method once more.\n+     *\/\n+    NORMAL,\n+    \/**\n+     * Standalone mode: There is no warm-up and no compilation done by the framework. The run method is responsible to\n+     * trigger the compilation(s), especially in regard of possible {@link IR} annotations at the associated {@link Test}\n+     * method.\n+     *\/\n+    STANDALONE,\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/RunMode.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestRunException;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * This class represents a scenario that can be executed by the {@link TestFramework}.\n+ * <p>\n+ * A JTreg test should use the test framework with {@code @run driver} (without directly specify any additional flags).\n+ * If a test should run with additional flags, use {@link TestFramework#runWithFlags(String...)} or\n+ * {@link TestFramework#addFlags(String...)}. If, however, the test should be run with different settings (equivalent\n+ * to having multiple {@code @run} entries in a normal JTreg test), use scenarios. A scenario will be run with the\n+ * scenario specific VM flags, if any, and optionally specified VM flags with {@link TestFramework#addFlags(String...)}\n+ * whereas scenario VM flags will have precedence.\n+ * <p>\n+ * There is also the possibility to specify additional VM flags for all scenarios by using {@code DScenarioFlags}.\n+ *\n+ * @see TestFramework\n+ *\/\n+public class Scenario {\n+    private static final String ADDITIONAL_SCENARIO_FLAGS_PROPERTY = System.getProperty(\"ScenarioFlags\", \"\");\n+    private static final String SCENARIOS_PROPERTY = System.getProperty(\"Scenarios\", \"\");\n+    private static final List<String> ADDITIONAL_SCENARIO_FLAGS;\n+    private static final Set<Integer> ENABLED_SCENARIOS;\n+\n+    private final List<String> flags;\n+    private final int index;\n+    private final boolean enabled;\n+    private String testVMOutput;\n+\n+    static {\n+        if (!SCENARIOS_PROPERTY.isEmpty()) {\n+            var split = SCENARIOS_PROPERTY.split(\"\\\\s*,\\\\s*\");\n+            try {\n+                ENABLED_SCENARIOS = Arrays.stream(split).map(Integer::parseInt).collect(Collectors.toSet());\n+            } catch (NumberFormatException e) {\n+                throw new TestRunException(\"Provided a scenario index in the -DScenario comma-separated list which is not \"\n+                                           + \"a number: \" + SCENARIOS_PROPERTY);\n+            }\n+        } else {\n+            ENABLED_SCENARIOS = Collections.emptySet();\n+        }\n+\n+        ADDITIONAL_SCENARIO_FLAGS = ADDITIONAL_SCENARIO_FLAGS_PROPERTY.isEmpty() ? Collections.emptyList() :\n+                Arrays.asList(ADDITIONAL_SCENARIO_FLAGS_PROPERTY.split(\"\\\\s*,\\\\s*\"));\n+    }\n+\n+    \/**\n+     * Create a scenario with {@code index} that will be run with the additional VM flags specified in {@code flags}\n+     * (or without any if null or parameter not provided).\n+     * <p>\n+     * The scenario {@code index} must be unique to be distinguishable in the stdout and stderr output and when specifying\n+     * {@code -DScenarios} (see {@link Scenario}).\n+     *\n+     * @param index the unique scenario index.\n+     * @param flags the scenario flags or null (i.e. no parameter specified) if no flags should be used.\n+     *\/\n+    public Scenario(int index, String... flags) {\n+        this.index = index;\n+        if (flags != null) {\n+            this.flags = new ArrayList<>(Arrays.asList(flags));\n+            this.flags.addAll(ADDITIONAL_SCENARIO_FLAGS);\n+        } else {\n+            this.flags = new ArrayList<>();\n+        }\n+        this.enabled = ENABLED_SCENARIOS.isEmpty() || ENABLED_SCENARIOS.contains(index);\n+    }\n+\n+    \/**\n+     * Add additional VM flags to this scenario.\n+     *\n+     * @param flags the additional scenario VM flags.\n+     *\/\n+    public void addFlags(String... flags) {\n+        if (flags != null) {\n+            this.flags.addAll(Arrays.asList(flags));\n+        }\n+    }\n+\n+    \/**\n+     * Get all scenario specific VM flags as defined in {@link #Scenario(int, String...)}.\n+     *\n+     * @return the scenario VM flags.\n+     *\/\n+    public List<String> getFlags() {\n+        return flags;\n+    }\n+\n+    \/**\n+     * Get the unique scenario index as defined in {@link #Scenario(int, String...)}.\n+     *\n+     * @return the scenario index.\n+     *\/\n+    public int getIndex() {\n+        return index;\n+    }\n+\n+    \/**\n+     * Get the test VM output (stdout + stderr) of this scenario from the last execution of the framework.\n+     *\n+     * @return the test VM output.\n+     *\/\n+    public String getTestVMOutput() {\n+        return testVMOutput;\n+    }\n+\n+    \/**\n+     * Set the test VM output, called by the framework.\n+     *\/\n+    void setTestVMOutput(String testVMOutput) {\n+        this.testVMOutput = testVMOutput;\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if this scenario will be executed by the test framework. This only depends on\n+     * the property flag {@code -DScenarios} (see {@link Scenario}). This is only used by the framework internally.\n+     *\n+     * @return {@code true} if {@code -DScenarios} is either not set or if {@code -DScenarios} specifies the scenario\n+     *         index set by {@link #Scenario(int, String...)}.\n+     *         {@code false} otherwise.\n+     *\/\n+    boolean isEnabled() {\n+        return enabled;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Scenario.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/**\n+ * Annotate all methods in your test class which the framework should test with {@code @Test}.\n+ * <p>\n+ * Let {@code m} be a test method specifying the {@code @Test} annotation. If {@code m} is neither part of a\n+ * <b>checked test<\/b> (an additional method specifying {@link Check @Check} with {@code @Check(test = \"m\")}) nor part\n+ * of a <b>custom run test<\/b> (an additional method specifying {@link Run @Run} with {@code @Run(test = \"m\")}),\n+ * then {@code m} is a so-called <b>base test<\/b> and the the framework invokes {@code m} in the following way:\n+ * <ol>\n+ *     <li><p>The framework warms {@code m} up by invoking it for a predefined number of iterations (default: 2000)\n+ *     or any number specified by an additional {@link Warmup @Warmup} annotation at {@code m} or by using\n+ *     {@link TestFramework#setDefaultWarmup(int)} (could also be 0 which skips the warm-up completely which is similar\n+ *     to simulating {@code -Xcomp}). More information about the warm-up in general can be found at {@link Warmup}<\/li>\n+ *     <li><p>After the warm-up, the framework compiles {@code m} at the specified compilation level set by\n+ *     {@link #compLevel()} (default {@link CompLevel#ANY} will pick the highest available level which is usually\n+ *     {@link CompLevel#C2}).<\/li>\n+ *     <li><p>The framework invokes {@code m} one more time to run the compilation.<\/li>\n+ *     <li><p>The framework checks any specified {@link IR @IR} constraints at {@code m}. More information about IR matching\n+ *     can be found at {@link IR}.<\/li>\n+ * <\/ol>\n+ *\n+ * <p>\n+ * {@code m} has the following properties:\n+ * <ul>\n+ *     <li><p>If {@code m} specifies no parameters, the framework can directly invoke {@code m}.<\/li>\n+ *     <li><p>If {@code m} specifies parameters, the framework needs to know how to invoke {@code m}. Use {@link Arguments}\n+ *     with {@link Argument} properties for each parameter to use well-defined parameters by the framework. If the method\n+ *     requires a more specific argument value, use a custom run test (see {@link Run}).<\/li>\n+ *     <li><p>{@code m} cannot specify {@link AbstractInfo} or any of its subclasses as parameter or return type.<\/li>\n+ *     <li><p>{@code m} is not inlined by the framework.<\/li>\n+ *     <li><p>Verification of the return value of {@code m} can only be done in a checked test (see {@link Check}) or\n+ *     custom run test (see {@link Run}).<\/li>\n+ * <\/ul>\n+ *\n+ * <p>\n+ * The following constraints must be met for the test method {@code m} specifying {@code @Test}:\n+ * <ul>\n+ *     <li><p>{@code m} must be part of the test class. Using {@code @Test} in nested or helper classes is not allowed.<\/li>\n+ *     <li><p>{@code m} cannot have the same name as another {@code @Test} method in the same test class. Method\n+ *     overloading is only allowed (but not encouraged) with other non-{@code @Test} methods.<\/li>\n+ *     <li><p>{@code m} cannot specify any helper-method-specific compile command annotations\n+ *            ({@link ForceCompile @ForceCompile}, {@link DontCompile @DontCompile}, {@link ForceInline @ForceInline},\n+ *            {@link DontInline @DontInline}). <\/li>\n+ * <\/ul>\n+ *\n+ * <p>\n+ * Examples on how to write base tests can be found in {@link jdk.test.lib.hotspot.ir_framework.examples.BaseTestExample}\n+ * and also as part of the internal testing in the package {@link jdk.test.lib.hotspot.ir_framework.tests}.\n+ *\n+ * @see Arguments\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface Test {\n+    \/**\n+     * Specify at which compilation level the framework should eventually compile the test method after an optional\n+     * warm-up period. The default {@link CompLevel#ANY} will let the framework compile the method at the highest\n+     * available level which is usually {@link CompLevel#C2}.\n+     *\/\n+    CompLevel compLevel() default CompLevel.ANY;\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Test.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,718 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.driver.*;\n+import compiler.lib.ir_framework.shared.*;\n+import compiler.lib.ir_framework.test.*;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import sun.hotspot.WhiteBox;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * This class represents the main entry point to the test framework whose main purpose is to perform regex-based checks on\n+ * the C2 IR shape emitted by the VM flags {@code -XX:+PrintIdeal} and {@code -XX:+PrintOptoAssembly}. The framework can\n+ * also be used for other non-IR matching (and non-compiler) tests by providing easy to use annotations for commonly used\n+ * testing patterns and compiler control flags.\n+ * <p>\n+ * The framework offers various annotations to control how your test code should be invoked and being checked. There are\n+ * three kinds of tests depending on how much control is needed over the test invocation:\n+ * <b>Base tests<\/b> (see {@link Test}), <b>checked tests<\/b> (see {@link Check}), and <b>custom run tests<\/b>\n+ * (see {@link Run}). Each type of test needs to define a unique <i>test method<\/i> that specifies a {@link Test @Test}\n+ * annotation which represents the test code that is eventually executed by the test framework. More information about\n+ * the usage and how to write different tests can be found in {@link Test}, {@link Check}, and {@link Run}.\n+ * <p>\n+ * Each test method can specify an arbitrary number of IR rules. This is done by using {@link IR @IR} annotations which\n+ * can define regex strings that are matched on the output of {@code -XX:+PrintIdeal} and {@code -XX:+PrintOptoAssembly}.\n+ * The matching is done after the test method was (optionally) warmed up and compiled. More information about the usage\n+ * and how to write different IR rules can be found at {@link IR}.\n+ * <p>\n+ * This framework should be used with the following JTreg setup in your Test.java file in package <i>some.package<\/i>:\n+ * <pre>\n+ * {@literal @}library \/test\/lib\n+ * {@literal @}run driver some.package.Test\n+ * <\/pre>\n+ * Note that even though the framework uses the Whitebox API internally, it is not required to build and enabel it in the\n+ * JTreg test if the test itself is not utilizing any Whitebox features directly.\n+ * <p>\n+ * To specify additional flags, use {@link #runWithFlags(String...)}, {@link #addFlags(String...)}, or\n+ * {@link #addScenarios(Scenario...)} where the scenarios can also be used to run different flag combinations\n+ * (instead of specifying multiple JTreg {@code @run} entries).\n+ * <p>\n+ * After annotating your test code with the framework specific annotations, the framework needs to be invoked from the\n+ * {@code main()} method of your JTreg test. There are two ways to do so. The first way is by calling the various\n+ * {@code runXX()} methods of {@link TestFramework}. The second way, which gives more control, is to create a new\n+ * {@code TestFramework} builder object on which {@link #start()} needs to be eventually called to start the testing.\n+ * <p>\n+ * The framework is called from the <i>driver VM<\/i> in which the JTreg test is initially run by specifying {@code\n+ * @run driver} in the JTreg header. This strips all additionally specified JTreg VM and Javaoptions.\n+ * The framework creates a new <i>flag VM<\/i> with all these flags added again in order to figure out which flags are\n+ * required to run the tests specified in the test class (e.g. {@code -XX:+PrintIdeal} and {@code -XX:+PrintOptoAssembly}\n+ * for IR matching).\n+ * <p>\n+ * After the flag VM terminates, it starts a new <i>test VM<\/i> which performs the execution of the specified\n+ * tests in the test class as described in {@link Test}, {@link Check}, and {@link Run}.\n+ * <p>\n+ * In a last step, once the test VM has terminated without exceptions, IR matching is performed if there are any IR\n+ * rules and if no VM flags disable it (e.g. not running with {@code -Xint}, see {@link IR} for more details).\n+ * The IR regex matching is done on the output of {@code -XX:+PrintIdeal} and {@code -XX:+PrintOptoAssembly} by parsing\n+ * the hotspot_pid file of the test VM. Failing IR rules are reported by throwing a {@link IRViolationException}.\n+ *\n+ * @see Test\n+ * @see Check\n+ * @see Run\n+ * @see IR\n+ *\/\n+public class TestFramework {\n+    \/**\n+     * JTreg can define additional VM (-Dtest.vm.opts) and Javaoptions (-Dtest.java.opts) flags. IR verification is only\n+     * performed when all these additional JTreg flags (does not include additionally added framework and scenario flags\n+     * by user code) are whitelisted.\n+     *\n+     * A flag is whitelisted if it is a property flag (starting with -D), -ea, -esa, or if the flag name contains any of\n+     * the entries of this list as a substring (partial match).\n+     *\/\n+    public static final Set<String> JTREG_WHITELIST_FLAGS = new HashSet<>(\n+            Arrays.asList(\n+                    \/\/ The following substrings are part of more than one VM flag\n+                    \"RAM\",\n+                    \"Heap\",\n+                    \"Trace\",\n+                    \"Print\",\n+                    \"Verify\",\n+                    \"TLAB\",\n+                    \"UseNewCode\",\n+                    \"Xmn\",\n+                    \"Xms\",\n+                    \"Xmx\",\n+                    \"Xss\",\n+                    \/\/ The following substrings are only part of one VM flag (=exact match)\n+                    \"CreateCoredumpOnCrash\",\n+                    \"IgnoreUnrecognizedVMOptions\",\n+                    \"UnlockDiagnosticVMOptions\",\n+                    \"UnlockExperimentalVMOptions\",\n+                    \"BackgroundCompilation\",\n+                    \"Xbatch\",\n+                    \"TieredCompilation\",\n+                    \"Xmixed\",\n+                    \"server\",\n+                    \"Xlog\",\n+                    \"LogCompilation\"\n+            )\n+    );\n+\n+    public static final boolean VERBOSE = Boolean.getBoolean(\"Verbose\");\n+    public static final boolean TESTLIST = !System.getProperty(\"Test\", \"\").isEmpty();\n+    public static final boolean EXCLUDELIST = !System.getProperty(\"Exclude\", \"\").isEmpty();\n+    private static final boolean REPORT_STDOUT = Boolean.getBoolean(\"ReportStdout\");\n+    \/\/ Only used for internal testing and should not be used for normal user testing.\n+    private static final boolean SKIP_WHITEBOX_INSTALL = Boolean.getBoolean(\"SkipWhiteBoxInstall\");\n+\n+    private static final String RERUN_HINT = \"\"\"\n+                                               #############################################################\n+                                                - To only run the failed tests use -DTest, -DExclude,\n+                                                  and\/or -DScenarios.\n+                                                - To also get the standard output of the test VM run with\n+                                                  -DReportStdout=true or for even more fine-grained logging\n+                                                  use -DVerbose=true.\n+                                               #############################################################\n+                                             \"\"\" + System.lineSeparator();\n+\n+    private boolean irVerificationPossible = Boolean.parseBoolean(System.getProperty(\"VerifyIR\", \"true\"));\n+    private boolean shouldVerifyIR; \/\/ Should we perform IR matching?\n+    private static boolean toggleBool;\n+\n+    private final Class<?> testClass;\n+    private Set<Class<?>> helperClasses;\n+    private List<Scenario> scenarios;\n+    private Set<Integer> scenarioIndices;\n+    private List<String> flags;\n+    private int defaultWarmup = -1;\n+\n+    \/*\n+     * Public interface methods\n+     *\/\n+\n+    \/**\n+     * Creates an instance acting as a builder to test the class from which this constructor was invoked from.\n+     * Use this constructor if you want to use multiple run options (flags, helper classes, scenarios).\n+     * Use the associated add methods ({@link #addFlags(String...)}, {@link #addScenarios(Scenario...)},\n+     * {@link #addHelperClasses(Class...)}) to set up everything and then start the testing by invoking {@link #start()}.\n+     *\/\n+    public TestFramework() {\n+        this(StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE).getCallerClass());\n+    }\n+\n+    \/**\n+     * Creates an instance acting as a builder to test {@code testClass}.\n+     * Use this constructor if you want to use multiple run options (flags, helper classes, scenarios).\n+     * Use the associated add methods ({@link #addFlags(String...)}, @link #addScenarios(Scenario...)},\n+     * {@link #addHelperClasses(Class...)}) to set up everything and then start the testing by invoking {@link #start()}.\n+     *\n+     * @param testClass the class to be tested by the framework.\n+     * @see #TestFramework()\n+     *\/\n+    public TestFramework(Class<?> testClass) {\n+        TestRun.check(testClass != null, \"Test class cannot be null\");\n+        this.testClass = testClass;\n+        if (VERBOSE) {\n+            System.out.println(\"Test class: \" + testClass);\n+        }\n+    }\n+\n+    \/**\n+     * Tests the class from which this method was invoked from.\n+     *\/\n+    public static void run() {\n+        StackWalker walker = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n+        run(walker.getCallerClass());\n+    }\n+\n+    \/**\n+     * Tests {@code testClass}.\n+     *\n+     * @param testClass the class to be tested by the framework.\n+     * @see #run()\n+     *\/\n+    public static void run(Class<?> testClass) {\n+        TestFramework framework = new TestFramework(testClass);\n+        framework.start();\n+    }\n+\n+    \/**\n+     * Tests the class from which this method was invoked from. The test VM is called with the specified {@code flags}.\n+     * <ul>\n+     *     <li><p>The {@code flags} override any set VM or Javaoptions flags by JTreg by default.<p>\n+     *            Use {@code -DPreferCommandLineFlags=true} if you want to prefer the JTreg VM and  Javaoptions flags over\n+     *            the specified {@code flags} of this method.<\/li>\n+     *     <li><p>If you want to run your entire JTreg test with additional flags, use this method.<\/li>\n+     *     <li><p>If you want to run your entire JTreg test with additional flags but for another test class then the one\n+     *            from which this method was called from, use {@link #addFlags(String...)}, use this method.<\/li>\n+     *     <li><p>If you want to run your JTreg test with multiple flag combinations, use\n+     *            {@link #addScenarios(Scenario...)}<\/li>\n+     * <\/ul>\n+     *\n+     * @param flags VM flags to be used for the test VM.\n+     *\/\n+    public static void runWithFlags(String... flags) {\n+        StackWalker walker = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n+        TestFramework framework = new TestFramework(walker.getCallerClass());\n+        framework.addFlags(flags);\n+        framework.start();\n+    }\n+\n+    \/**\n+     * Add VM flags to be used for the test VM. These flags override any VM or Javaoptions set by JTreg by default.<p>\n+     * Use {@code -DPreferCommandLineFlags=true} if you want to prefer the VM or Javaoptions over the scenario flags.\n+     *\n+     * <p>\n+     * The testing can be started by invoking {@link #start()}\n+     *\n+     * @param flags VM options to be applied to the test VM.\n+     * @return the same framework instance.\n+     *\/\n+    public TestFramework addFlags(String... flags) {\n+        TestRun.check(flags != null && Arrays.stream(flags).noneMatch(Objects::isNull), \"A flag cannot be null\");\n+        if (this.flags == null) {\n+            this.flags = new ArrayList<>();\n+        }\n+        this.flags.addAll(Arrays.asList(flags));\n+        return this;\n+    }\n+\n+    \/**\n+     * Add helper classes that can specify additional compile command annotations ({@link ForceCompile @ForceCompile},\n+     * {@link DontCompile @DontCompile}, {@link ForceInline @ForceInline}, {@link DontInline @DontInline}) to be applied\n+     * while testing {@code testClass} (also see description of {@link TestFramework}).\n+     *\n+     * <p>\n+     * Duplicates in {@code helperClasses} are ignored. If a class is used by the test class that does not specify any\n+     * compile command annotations, you do not need to include it with this method. If no helper class specifies any\n+     * compile commands, you do not need to call this method at all.\n+     *\n+     * <p>\n+     * The testing can be started by invoking {@link #start()}.\n+     *\n+     * @param helperClasses helper classes containing compile command annotations ({@link ForceCompile},\n+     *                      {@link DontCompile}, {@link ForceInline}, {@link DontInline}) to be applied\n+     *                      while testing {@code testClass} (also see description of {@link TestFramework}).\n+     * @return the same framework instance.\n+     *\/\n+    public TestFramework addHelperClasses(Class<?>... helperClasses) {\n+        TestRun.check(helperClasses != null && Arrays.stream(helperClasses).noneMatch(Objects::isNull),\n+                      \"A Helper class cannot be null\");\n+        if (this.helperClasses == null) {\n+            this.helperClasses = new HashSet<>();\n+        }\n+\n+        this.helperClasses.addAll(Arrays.asList(helperClasses));\n+        return this;\n+    }\n+\n+    \/**\n+     * Add scenarios to be used for the test VM. A test VM is called for each scenario in {@code scenarios} by using the\n+     * specified VM flags in the scenario. The scenario flags override any flags set by {@link #addFlags(String...)}\n+     * and thus also override any VM or Javaoptions set by JTreg by default.<p>\n+     * Use {@code -DPreferCommandLineFlags=true} if you want to prefer the VM and Javaoptions over the scenario flags.\n+     *\n+     * <p>\n+     * The testing can be started by invoking {@link #start()}\n+     *\n+     * @param scenarios scenarios which specify specific flags for the test VM.\n+     * @return the same framework instance.\n+     *\/\n+    public TestFramework addScenarios(Scenario... scenarios) {\n+        TestFormat.check(scenarios != null && Arrays.stream(scenarios).noneMatch(Objects::isNull),\n+                         \"A scenario cannot be null\");\n+        if (this.scenarios == null) {\n+            this.scenarios = new ArrayList<>();\n+            this.scenarioIndices = new HashSet<>();\n+        }\n+\n+        for (Scenario scenario : scenarios) {\n+            int scenarioIndex = scenario.getIndex();\n+            TestFormat.check(scenarioIndices.add(scenarioIndex),\n+                             \"Cannot define two scenarios with the same index \" + scenarioIndex);\n+            this.scenarios.add(scenario);\n+        }\n+        return this;\n+    }\n+\n+    \/**\n+     * Start the testing of the implicitly (by {@link #TestFramework()}) or explicitly (by {@link #TestFramework(Class)})\n+     * set test class.\n+     *\/\n+    public void start() {\n+        if (!SKIP_WHITEBOX_INSTALL) {\n+            installWhiteBox();\n+        }\n+        disableIRVerificationIfNotFeasible();\n+\n+        if (scenarios == null) {\n+            try {\n+                start(null);\n+            } catch (TestVMException e) {\n+                System.err.println(System.lineSeparator() + e.getExceptionInfo() + RERUN_HINT);\n+                throw e;\n+            } catch (IRViolationException e) {\n+                System.out.println(\"Compilation(s) of failed match(es):\");\n+                System.out.println(e.getCompilations());\n+                System.err.println(System.lineSeparator() + e.getExceptionInfo() + System.lineSeparator() + RERUN_HINT);\n+                throw e;\n+            }\n+        } else {\n+            startWithScenarios();\n+        }\n+    }\n+\n+    \/**\n+     * Set a new default warm-up (overriding the framework default of 2000 at\n+     * {@link TestVM#WARMUP_ITERATIONS}) to be applied for all tests that do not specify an explicit\n+     * warm-up with {@link Warmup @Warmup}.\n+     *\n+     * @param defaultWarmup a new non-negative default warm-up.\n+     * @return the same framework instance.\n+     *\/\n+    public TestFramework setDefaultWarmup(int defaultWarmup) {\n+        TestFormat.check(defaultWarmup >= 0, \"Cannot specify a negative default warm-up\");\n+        this.defaultWarmup = defaultWarmup;\n+        return this;\n+    }\n+\n+    \/**\n+     * Get the VM output of the test VM. Use {@code -DVerbose=true} to enable more debug information. If scenarios\n+     * were run, use {@link Scenario#getTestVMOutput()}.\n+     *\n+     * @return the last test VM output.\n+     *\/\n+    public static String getLastTestVMOutput() {\n+        return TestVMProcess.getLastTestVMOutput();\n+    }\n+\n+    \/*\n+     * The following methods are only intended to be called from actual @Test methods and not from the main() method of\n+     * a JTreg test. Calling these methods from main() results in a linking exception (Whitebox not yet loaded and enabled).\n+     *\/\n+\n+    \/**\n+     * Compile {@code m} at compilation level {@code compLevel}. {@code m} is first enqueued and might not be compiled,\n+     * yet, upon returning from this method.\n+     *\n+     * @param m the method to be compiled.\n+     * @param compLevel the (valid) compilation level at which the method should be compiled.\n+     * @throws TestRunException if compilation level is {@link CompLevel#SKIP} or {@link CompLevel#WAIT_FOR_COMPILATION}.\n+     *\/\n+    public static void compile(Method m, CompLevel compLevel) {\n+        TestVM.compile(m, compLevel);\n+    }\n+\n+    \/**\n+     * Deoptimize {@code m}.\n+     *\n+     * @param m the method to be deoptimized.\n+     *\/\n+    public static void deoptimize(Method m) {\n+        TestVM.deoptimize(m);\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if {@code m} is compiled at any level.\n+     *\n+     * @param m the method to be checked.\n+     * @return {@code true} if {@code m} is compiled at any level;\n+     *         {@code false} otherwise.\n+     *\/\n+    public static boolean isCompiled(Method m) {\n+        return TestVM.isCompiled(m);\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if {@code m} is compiled with C1.\n+     *\n+     * @param m the method to be checked.\n+     * @return {@code true} if {@code m} is compiled with C1;\n+     *         {@code false} otherwise.\n+     *\/\n+    public static boolean isC1Compiled(Method m) {\n+        return TestVM.isC1Compiled(m);\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if {@code m} is compiled with C2.\n+     *\n+     * @param m the method to be checked.\n+     * @return {@code true} if {@code m} is compiled with C2;\n+     *         {@code false} otherwise.\n+     *\/\n+    public static boolean isC2Compiled(Method m) {\n+        return TestVM.isC2Compiled(m);\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if {@code m} is compiled at the specified {@code compLevel}.\n+     *\n+     * @param m the method to be checked.\n+     * @param compLevel the compilation level.\n+     * @return {@code true} if {@code m} is compiled at {@code compLevel};\n+     *         {@code false} otherwise.\n+     *\/\n+    public static boolean isCompiledAtLevel(Method m, CompLevel compLevel) {\n+        return TestVM.isCompiledAtLevel(m, compLevel);\n+    }\n+\n+    \/**\n+     * Checks if {@code m} is compiled at any level.\n+     *\n+     * @param m the method to be checked.\n+     * @throws TestRunException if {@code m} is not compiled at any level.\n+     *\/\n+    public static void assertCompiled(Method m) {\n+        TestVM.assertCompiled(m);\n+    }\n+\n+    \/**\n+     * Checks if {@code m} is not compiled at any level.\n+     *\n+     * @param m the method to be checked.\n+     * @throws TestRunException if {@code m} is compiled at any level.\n+     *\/\n+    public static void assertNotCompiled(Method m) {\n+        TestVM.assertNotCompiled(m);\n+    }\n+\n+    \/**\n+     * Verifies that {@code m} is compiled with C1.\n+     *\n+     * @param m the method to be verified.\n+     * @throws TestRunException if {@code m} is not compiled with C1.\n+     *\/\n+    public static void assertCompiledByC1(Method m) {\n+        TestVM.assertCompiledByC1(m);\n+    }\n+\n+    \/**\n+     * Verifies that {@code m} is compiled with C2.\n+     *\n+     * @param m the method to be checked.\n+     * @throws TestRunException if {@code m} is not compiled with C2.\n+     *\/\n+    public static void assertCompiledByC2(Method m) {\n+        TestVM.assertCompiledByC2(m);\n+    }\n+\n+    \/**\n+     * Verifies that {@code m} is compiled at the specified {@code compLevel}.\n+     *\n+     * @param m the method to be checked.\n+     * @param compLevel the compilation level.\n+     * @throws TestRunException if {@code m} is not compiled at {@code compLevel}.\n+     *\/\n+    public static void assertCompiledAtLevel(Method m, CompLevel compLevel) {\n+        TestVM.assertCompiledAtLevel(m, compLevel);\n+    }\n+\n+    \/**\n+     * Verifies that {@code m} was deoptimized after being C1 compiled.\n+     *\n+     * @param m the method to be checked.\n+     * @throws TestRunException if {@code m} is was not deoptimized after being C1 compiled.\n+     *\/\n+    public static void assertDeoptimizedByC1(Method m) {\n+        TestVM.assertDeoptimizedByC1(m);\n+    }\n+\n+    \/**\n+     * Verifies that {@code m} was deoptimized after being C2 compiled.\n+     *\n+     * @param m the method to be checked.\n+     * @throws TestRunException if {@code m} is was not deoptimized after being C2 compiled.\n+     *\/\n+    public static void assertDeoptimizedByC2(Method m) {\n+        TestVM.assertDeoptimizedByC2(m);\n+    }\n+\n+    \/**\n+     * Returns a different boolean each time this method is invoked (switching between {@code false} and {@code true}).\n+     * The very first invocation returns {@code false}. Note that this method could be used by different tests and\n+     * thus the first invocation for a test could be {@code true} or {@code false} depending on how many times\n+     * other tests have already invoked this method.\n+     *\n+     * @return an inverted boolean of the result of the last invocation of this method.\n+     *\/\n+    public static boolean toggleBoolean() {\n+        toggleBool = !toggleBool;\n+        return toggleBool;\n+    }\n+\n+    \/*\n+     * End of public interface methods\n+     *\/\n+\n+    \/**\n+     * Used to move Whitebox class to the right folder in the JTreg test\n+     *\/\n+    private void installWhiteBox() {\n+        try {\n+            ClassFileInstaller.main(WhiteBox.class.getName());\n+        } catch (Exception e) {\n+            throw new Error(\"failed to install whitebox classes\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Disable IR verification completely in certain cases.\n+     *\/\n+    private void disableIRVerificationIfNotFeasible() {\n+        if (irVerificationPossible) {\n+            irVerificationPossible = Platform.isDebugBuild() && !Platform.isInt() && !Platform.isComp();\n+            if (!irVerificationPossible) {\n+                System.out.println(\"IR verification disabled due to not running a debug build (required for PrintIdeal\" +\n+                                   \"and PrintOptoAssembly), running with -Xint, or -Xcomp (use warm-up of 0 instead)\");\n+                return;\n+            }\n+\n+            irVerificationPossible = hasIRAnnotations();\n+            if (!irVerificationPossible) {\n+                System.out.println(\"IR verification disabled due to test \" + testClass + \" not specifying any @IR annotations\");\n+                return;\n+            }\n+\n+            \/\/ No IR verification is done if additional non-whitelisted JTreg VM or Javaoptions flag is specified.\n+            irVerificationPossible = onlyWhitelistedJTregVMAndJavaOptsFlags();\n+            if (!irVerificationPossible) {\n+                System.out.println(\"IR verification disabled due to using non-whitelisted JTreg VM or Javaoptions flag(s).\"\n+                                   + System.lineSeparator());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * For scenarios: Run the tests with the scenario settings and collect all exceptions to be able to run all\n+     * scenarios without prematurely throwing an exception. Format violations, however, are wrong for all scenarios\n+     * and thus is reported immediately on the first scenario execution.\n+     *\/\n+    private void startWithScenarios() {\n+        Map<Scenario, Exception> exceptionMap = new TreeMap<>(Comparator.comparingInt(Scenario::getIndex));\n+        for (Scenario scenario : scenarios) {\n+            try {\n+                start(scenario);\n+            } catch (TestFormatException e) {\n+                \/\/ Test format violation is wrong for all the scenarios. Only report once.\n+                throw e;\n+            } catch (Exception e) {\n+                exceptionMap.put(scenario, e);\n+            }\n+        }\n+        if (!exceptionMap.isEmpty()) {\n+            reportScenarioFailures(exceptionMap);\n+        }\n+    }\n+\n+    private void reportScenarioFailures(Map<Scenario, Exception> exceptionMap) {\n+        String failedScenarios = \"The following scenarios have failed: #\"\n+                                 + exceptionMap.keySet().stream()\n+                                               .map(s -> String.valueOf(s.getIndex()))\n+                                               .collect(Collectors.joining(\", #\"));\n+        StringBuilder builder = new StringBuilder(failedScenarios);\n+        builder.append(System.lineSeparator()).append(System.lineSeparator());\n+        for (Map.Entry<Scenario, Exception> entry : exceptionMap.entrySet()) {\n+            Exception e = entry.getValue();\n+            Scenario scenario = entry.getKey();\n+            String errorMsg = \"\";\n+            if (scenario != null) {\n+                errorMsg = getScenarioTitleAndFlags(scenario);\n+            }\n+            if (e instanceof IRViolationException irException) {\n+                \/\/ For IR violations, only show the actual violations and not the (uninteresting) stack trace.\n+                System.out.println((scenario != null ? \"Scenario #\" + scenario.getIndex() + \" - \" : \"\")\n+                                   + \"Compilation(s) of failed matche(s):\");\n+                System.out.println(irException.getCompilations());\n+                builder.append(errorMsg).append(System.lineSeparator()).append(irException.getExceptionInfo());\n+            } else if (e instanceof TestVMException testVMException) {\n+                builder.append(errorMsg).append(System.lineSeparator()).append(testVMException.getExceptionInfo());\n+            } else {\n+                \/\/ Print stack trace otherwise\n+                StringWriter errors = new StringWriter();\n+                e.printStackTrace(new PrintWriter(errors));\n+                builder.append(errors.toString());\n+            }\n+            builder.append(System.lineSeparator());\n+        }\n+        System.err.println(builder.toString());\n+        if (!VERBOSE && !REPORT_STDOUT && !TESTLIST && !EXCLUDELIST) {\n+            \/\/ Provide a hint to the user how to get additional output\/debugging information.\n+            System.err.println(RERUN_HINT);\n+        }\n+        throw new TestRunException(failedScenarios + \". Please check stderr for more information.\");\n+    }\n+\n+    private static String getScenarioTitleAndFlags(Scenario scenario) {\n+        StringBuilder builder = new StringBuilder();\n+        String title = \"Scenario #\" + scenario.getIndex();\n+        builder.append(title).append(System.lineSeparator()).append(\"=\".repeat(title.length()))\n+               .append(System.lineSeparator());\n+        builder.append(\"Scenario flags: [\").append(String.join(\", \", scenario.getFlags())).append(\"]\")\n+               .append(System.lineSeparator());\n+        return builder.toString();\n+    }\n+\n+    \/**\n+     * Execute a separate \"flag\" VM with White Box access to determine all test VM flags. The flag VM sends an encoding of\n+     * all required flags for the test VM to the driver VM over a socket. Once the flag VM exits, this driver VM parses the\n+     * test VM flags, which also determine if IR matching should be done, and then starts the test VM to execute all tests.\n+     *\/\n+    private void start(Scenario scenario) {\n+        if (scenario != null && !scenario.isEnabled()) {\n+            System.out.println(\"Disabled scenario #\" + scenario.getIndex() + \"! This scenario is not present in set flag \" +\n+                               \"-DScenarios and is therefore not executed.\");\n+            return;\n+        }\n+        shouldVerifyIR = irVerificationPossible;\n+        try {\n+            \/\/ Use TestFramework flags and scenario flags for new VMs.\n+            List<String> additionalFlags = new ArrayList<>();\n+            if (flags != null) {\n+                additionalFlags.addAll(flags);\n+            }\n+            if (scenario != null) {\n+                List<String> scenarioFlags = scenario.getFlags();\n+                String scenarioFlagsString = scenarioFlags.isEmpty() ? \"\" : \" - [\" + String.join(\", \", scenarioFlags) + \"]\";\n+                System.out.println(\"Scenario #\" + scenario.getIndex() + scenarioFlagsString + \":\");\n+                additionalFlags.addAll(scenarioFlags);\n+            }\n+            String frameworkAndScenarioFlags = additionalFlags.isEmpty() ?\n+                    \"\" : \" - [\" + String.join(\", \", additionalFlags) + \"]\";\n+\n+            if (shouldVerifyIR) {\n+                \/\/ Only need to use flag VM if an IR verification is possibly done.\n+                System.out.println(\"Run Flag VM:\");\n+                FlagVMProcess flagVMProcess = new FlagVMProcess(testClass, additionalFlags);\n+                shouldVerifyIR = flagVMProcess.shouldVerifyIR();\n+                if (shouldVerifyIR) {\n+                    \/\/ Add more flags for the test VM which are required to do IR verification.\n+                    additionalFlags.addAll(flagVMProcess.getTestVMFlags());\n+                } \/\/ else: Flag VM found a reason to not do IR verification.\n+            } else {\n+                System.out.println(\"Skip Flag VM due to not performing IR verification.\");\n+            }\n+\n+            System.out.println(\"Run Test VM\" + frameworkAndScenarioFlags + \":\");\n+            runTestVM(additionalFlags);\n+        } finally {\n+            if (scenario != null) {\n+                scenario.setTestVMOutput(TestVMProcess.getLastTestVMOutput());\n+            }\n+            System.out.println();\n+        }\n+    }\n+\n+    private boolean hasIRAnnotations() {\n+        return Arrays.stream(testClass.getDeclaredMethods()).anyMatch(m -> m.getAnnotationsByType(IR.class) != null);\n+    }\n+\n+    private boolean onlyWhitelistedJTregVMAndJavaOptsFlags() {\n+        List<String> flags = Arrays.stream(Utils.getTestJavaOpts())\n+                                   .map(s -> s.replaceFirst(\"-XX:[+|-]?|-(?=[^D|^e])\", \"\"))\n+                                   .collect(Collectors.toList());\n+        for (String flag : flags) {\n+            \/\/ Property flags (prefix -D), -ea and -esa are whitelisted.\n+            if (!flag.startsWith(\"-D\") && !flag.startsWith(\"-e\") && JTREG_WHITELIST_FLAGS.stream().noneMatch(flag::contains)) {\n+                \/\/ Found VM flag that is not whitelisted\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private void runTestVM(List<String> additionalFlags) {\n+        TestVMProcess testVMProcess = new TestVMProcess(additionalFlags, testClass, helperClasses, defaultWarmup);\n+        if (shouldVerifyIR) {\n+            try {\n+                new IRMatcher(testVMProcess.getHotspotPidFileName(), testVMProcess.getIrEncoding(), testClass);\n+            } catch (IRViolationException e) {\n+                e.addCommandLine(testVMProcess.getCommandLine());\n+                throw e;\n+            }\n+        } else {\n+            System.out.println(\"IR verification disabled either due to no @IR annotations, through explicitly setting \" +\n+                               \"-DVerify=false, due to not running a debug build, using a non-whitelisted JTreg VM or \" +\n+                               \"Javaopts flag like -Xint, or running the test VM with other VM flags added by user code \" +\n+                               \"that make the IR verification impossible (e.g. -XX:-UseCompile, \" +\n+                               \"-XX:TieredStopAtLevel=[1,2,3], etc.).\");\n+        }\n+    }\n+\n+    public static void check(boolean test, String failureMessage) {\n+        if (!test) {\n+            throw new TestFrameworkException(failureMessage);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":718,"deletions":0,"binary":false,"changes":718,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.test.DeclaredTest;\n+import compiler.lib.ir_framework.test.TestVM;\n+\n+import java.lang.reflect.Method;\n+\n+\/**\n+ * Test info class which provides some useful utility methods and information about a <b>checked test<\/b>.\n+ *\n+ * @see Test\n+ * @see Check\n+ *\/\n+public class TestInfo extends AbstractInfo {\n+    private final Method testMethod;\n+    private final boolean compilationSkipped;\n+\n+    public TestInfo(Method testMethod, CompLevel testCmpLevel) {\n+        super(testMethod.getDeclaringClass());\n+        this.testMethod = testMethod;\n+        this.compilationSkipped = testCmpLevel == CompLevel.SKIP;\n+    }\n+\n+    \/**\n+     * Get the associated test method object.\n+     *\n+     * @return the associated test method object.\n+     *\/\n+    public Method getTest() {\n+        return testMethod;\n+    }\n+\n+    \/**\n+     * Return a boolean indicating if the framework skipped a compilation after the warm-up due to VM flags not\n+     * allowing a compilation on the requested level in {@link Test#compLevel()}.\n+     *\n+     * @return {@code true} if the framework skipped compilation of the test;\n+     *         {@code false} otherwise.\n+     *\/\n+    public boolean isCompilationSkipped() {\n+        return compilationSkipped;\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the associated test method is C1 compiled.\n+     *\n+     * @return {@code true} if the test method is C1 compiled;\n+     *         {@code false} otherwise.\n+     *\/\n+    public boolean isC1Compiled() {\n+        return TestVM.isC1Compiled(testMethod);\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the associated test method is C2 compiled.\n+     *\n+     * @return {@code true} if the test method is C2 compiled;\n+     *         {@code false} otherwise.\n+     *\/\n+    public boolean isC2Compiled() {\n+        return TestVM.isC2Compiled(testMethod);\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the associated test method is compiled at {@code compLevel}.\n+     *\n+     * @param compLevel the compilation level.\n+     * @return {@code true} if the test method is compiled at {@code compLevel};\n+     *         {@code false} otherwise.\n+     *\/\n+    public boolean isCompiledAtLevel(CompLevel compLevel) {\n+        return TestVM.isCompiledAtLevel(testMethod, compLevel);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestInfo.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/**\n+ * This annotation overrides the default number (2000) of times the framework should warm up a test.\n+ * <ul>\n+ *     <li><p>Any positive value or zero is permitted. A warm-up of zero allows a simulation of {@code -Xcomp}.<\/li>\n+ *     <li><p>Custom run tests (see {@link Run}) must specify a {@code @Warmup} annotation at the run method.<\/li>\n+ *     <li><p>Base and checked tests (see {@link Test}, {@link Check}) must specify a {@code @Warmup} annotation at\n+ *            the test method.<\/li>\n+ * <\/ul>\n+ *\n+ * @see Test\n+ * @see Check\n+ * @see Run\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface Warmup {\n+    \/**\n+     * The warm-up iterations for the test.\n+     *\/\n+    int value();\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Warmup.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver;\n+\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+import compiler.lib.ir_framework.flag.FlagVM;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * This class prepares, creates, and runs the \"flag\" VM with verification of proper termination. The flag VM determines\n+ * the flags required for the \"test\" VM. The flag VM writes these flags to a dedicated file which is then parsed by this\n+ * class after the termination of the flag VM.\n+ *\n+ * @see FlagVM\n+ *\/\n+public class FlagVMProcess {\n+    private static final boolean VERBOSE = Boolean.getBoolean(\"Verbose\");\n+\n+    private final List<String> cmds;\n+    private final List<String> testVMFlags;\n+    private boolean shouldVerifyIR;\n+    private String testVMFlagsFile;\n+    private OutputAnalyzer oa;\n+\n+    public FlagVMProcess(Class<?> testClass, List<String> additionalFlags) {\n+        cmds = new ArrayList<>();\n+        testVMFlags = new ArrayList<>();\n+        prepareVMFlags(testClass, additionalFlags);\n+        start();\n+        parseTestVMFlags();\n+    }\n+\n+    private void parseTestVMFlags() {\n+        String flags = readFlagsFromFile();\n+        if (VERBOSE) {\n+            System.out.println(\"Read data from \" + testVMFlagsFile + \":\");\n+            System.out.println(flags);\n+        }\n+        String patternString = \"(.*DShouldDoIRVerification=(true|false).*)\";\n+        Pattern pattern = Pattern.compile(patternString);\n+        Matcher matcher = pattern.matcher(flags);\n+        TestFramework.check(matcher.find(), \"Invalid flag encoding emitted by flag VM\");\n+        \/\/ Maybe we run with flags that make IR verification impossible\n+        shouldVerifyIR = Boolean.parseBoolean(matcher.group(2));\n+        testVMFlags.addAll(Arrays.asList(matcher.group(1).split(FlagVM.TEST_VM_FLAGS_DELIMITER)));\n+    }\n+\n+    private String readFlagsFromFile() {\n+        try (var br = Files.newBufferedReader(Paths.get(testVMFlagsFile))) {\n+            String flags = br.readLine();\n+            TestFramework.check(br.readLine() == null, testVMFlagsFile + \" should only contain one line.\");\n+            return flags;\n+\n+        } catch (IOException e) {\n+            throw new TestFrameworkException(\"Error while reading from file \" + testVMFlagsFile, e);\n+        }\n+    }\n+\n+    \/**\n+     * The flag VM needs White Box access to prepare all test VM flags. The flag VM will write the test VM flags to\n+     * a dedicated file which is afterwards parsed by the driver VM and added as flags to the test VM.\n+     *\/\n+    private void prepareVMFlags(Class<?> testClass, List<String> additionalFlags) {\n+        cmds.add(\"-Dtest.jdk=\" + Utils.TEST_JDK);\n+        \/\/ Set java.library.path so JNI tests which rely on jtreg nativepath setting work\n+        cmds.add(\"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH);\n+        cmds.add(\"-cp\");\n+        cmds.add(Utils.TEST_CLASS_PATH);\n+        cmds.add(\"-Xbootclasspath\/a:.\");\n+        cmds.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        cmds.add(\"-XX:+WhiteBoxAPI\");\n+        \/\/ TestFramework and scenario flags might have an influence on the later used test VM flags. Add them as well.\n+        cmds.addAll(additionalFlags);\n+        cmds.add(FlagVM.class.getCanonicalName());\n+        cmds.add(testClass.getCanonicalName());\n+    }\n+\n+    private void start() {\n+        try {\n+            \/\/ Run \"flag\" VM with White Box access to determine the test VM flags and if IR verification should be done.\n+            oa = ProcessTools.executeTestJvm(cmds);\n+        } catch (Exception e) {\n+            throw new TestRunException(\"Failed to execute TestFramework flag VM\", e);\n+        }\n+        testVMFlagsFile = FlagVM.TEST_VM_FLAGS_FILE_PREFIX + oa.pid()\n+                          + FlagVM.TEST_VM_FLAGS_FILE_POSTFIX;\n+        checkFlagVMExitCode();\n+    }\n+\n+    private void checkFlagVMExitCode() {\n+        String flagVMOutput = oa.getOutput();\n+        int exitCode = oa.getExitValue();\n+        if (VERBOSE && exitCode == 0) {\n+            System.out.println(\"--- OUTPUT TestFramework flag VM ---\");\n+            System.out.println(flagVMOutput);\n+        }\n+\n+        if (exitCode != 0) {\n+            System.err.println(\"--- OUTPUT TestFramework flag VM ---\");\n+            System.err.println(flagVMOutput);\n+            throw new RuntimeException(\"TestFramework flag VM exited with \" + exitCode);\n+        }\n+    }\n+\n+    public List<String> getTestVMFlags() {\n+        return testVMFlags;\n+    }\n+\n+    public boolean shouldVerifyIR() {\n+        return shouldVerifyIR;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/FlagVMProcess.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,493 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.shared.*;\n+import compiler.lib.ir_framework.test.*;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Parse the hotspot pid file of the test VM to match all @IR rules.\n+ *\/\n+public class IRMatcher {\n+    private static final boolean PRINT_IR_ENCODING = Boolean.parseBoolean(System.getProperty(\"PrintIREncoding\", \"false\"));\n+    private static final Pattern IR_ENCODING_PATTERN =\n+            Pattern.compile(\"(?<=\" + IREncodingPrinter.START + \"\\r?\\n)[\\\\s\\\\S]*(?=\" + IREncodingPrinter.END + \")\");\n+    private static final Pattern COMPILE_ID_PATTERN = Pattern.compile(\"compile_id='(\\\\d+)'\");\n+\n+    private final Map<String, IRMethod> compilations;\n+    private final Class<?> testClass;\n+    private final Map<Method, List<String>> fails;\n+    private final Pattern compileIdPatternForTestClass;\n+    private final String hotspotPidFileName;\n+    private IRMethod irMethod; \/\/ Current IR method to which rules are applied\n+    private Method method; \/\/ Current method to which rules are applied\n+    private IR irAnno; \/\/ Current IR annotation that is processed.\n+    private int irRuleIndex; \/\/ Current IR rule index;\n+\n+    public IRMatcher(String hotspotPidFileName, String irEncoding, Class<?> testClass) {\n+        this.compilations = new HashMap<>();\n+        this.fails = new HashMap<>();\n+        this.testClass = testClass;\n+        this.compileIdPatternForTestClass = Pattern.compile(\"compile_id='(\\\\d+)'.*\" + Pattern.quote(testClass.getCanonicalName())\n+                                                            + \" (\\\\S+)\");\n+        this.hotspotPidFileName = hotspotPidFileName;\n+        setupTestMethods(irEncoding);\n+        if (TestFramework.VERBOSE || PRINT_IR_ENCODING) {\n+            System.out.println(\"Read IR encoding from test VM:\");\n+            System.out.println(irEncoding);\n+        }\n+        if (!compilations.isEmpty()) {\n+            parseHotspotPidFile();\n+            applyRules();\n+        }\n+    }\n+\n+    \/**\n+     * Sets up a map testname -> IRMethod (containing the PrintIdeal and PrintOptoAssembly output for testname).\n+     *\/\n+    private void setupTestMethods(String irEncoding) {\n+        Map<String, int[]> irRulesMap = parseIREncoding(irEncoding);\n+        for (Method m : testClass.getDeclaredMethods()) {\n+            method = m;\n+            IR[] irAnnos = m.getAnnotationsByType(IR.class);\n+            if (irAnnos.length > 0) {\n+                \/\/ Validation of legal @IR attributes and placement of the annotation was already done in Test VM.\n+                int[] ids = irRulesMap.get(m.getName());\n+                TestFramework.check(ids != null, \"Should find method name in validIrRulesMap for \" + m);\n+                TestFramework.check(ids.length > 0, \"Did not find any rule indices for \" + m);\n+                TestFramework.check(ids[ids.length - 1] < irAnnos.length, \"Invalid IR rule index found in validIrRulesMap for \" + m);\n+                if (ids[0] != IREncodingPrinter.NO_RULE_APPLIED) {\n+                    \/\/ If -1, than there was no matching IR rule for the given conditions.\n+                    compilations.put(m.getName(), new IRMethod(m, ids, irAnnos));\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Read the IR encoding emitted by the test VM to decide if an @IR rule must be checked for a method.\n+     *\/\n+    private Map<String, int[]> parseIREncoding(String irEncoding) {\n+        Map<String, int[]> irRulesMap = new HashMap<>();\n+        Matcher matcher = IR_ENCODING_PATTERN.matcher(irEncoding);\n+        TestFramework.check(matcher.find(), \"Did not find IR encoding\");\n+        String[] lines = matcher.group(0).split(\"\\\\R\");\n+\n+        \/\/ Skip first line containing information about the format only\n+        for (int i = 1; i < lines.length; i++) {\n+            String line = lines[i].trim();\n+            String[] splitComma = line.split(\",\");\n+            if (splitComma.length < 2) {\n+                throw new TestFrameworkException(\"Invalid IR match rule encoding. No comma found: \" + splitComma[0]);\n+            }\n+            String testName = splitComma[0];\n+            int[] irRulesIdx = new int[splitComma.length - 1];\n+            for (int j = 1; j < splitComma.length; j++) {\n+                try {\n+                    irRulesIdx[j - 1] = Integer.parseInt(splitComma[j]);\n+                } catch (NumberFormatException e) {\n+                    throw new TestFrameworkException(\"Invalid IR match rule encoding. No number found: \" + splitComma[j]);\n+                }\n+            }\n+            irRulesMap.put(testName, irRulesIdx);\n+        }\n+        return irRulesMap;\n+    }\n+\n+    \/**\n+     * Parse the hotspot_pid*.log file from the test VM. Read the PrintIdeal and PrintOptoAssembly entries for all\n+     * methods of the test class that need to be IR matched (according to IR encoding).\n+     *\/\n+    private void parseHotspotPidFile() {\n+        Map<Integer, String> compileIdMap = new HashMap<>();\n+        try (var br = Files.newBufferedReader(Paths.get(hotspotPidFileName))) {\n+            String line;\n+            StringBuilder builder = new StringBuilder();\n+            boolean append = false;\n+            String currentMethod = \"\";\n+            while ((line = br.readLine()) != null) {\n+                if (append && line.startsWith(\"<\/\")) {\n+                    flushOutput(line, builder, currentMethod);\n+                    append = false;\n+                    currentMethod = \"\";\n+                    continue;\n+                } else if (append) {\n+                    appendLine(builder, line);\n+                    continue;\n+                }\n+\n+                if (maybeTestEntry(line)) {\n+                    addTestMethodCompileId(compileIdMap, line);\n+                } else if (isPrintIdealStart(line)) {\n+                    String methodName = getMethodName(compileIdMap, line);\n+                    if (methodName != null) {\n+                        currentMethod = methodName;\n+                        append = true; \/\/ Append all following lines until we hit the closing <\/ideal> tag.\n+                    }\n+                } else if (isPrintOptoAssemblyStart(line)) {\n+                    String methodName = getMethodName(compileIdMap, line);\n+                    if (methodName != null) {\n+                        TestFramework.check(compilations.containsKey(methodName), \"Must be second entry of \" + methodName);\n+                        currentMethod = methodName;\n+                        append = true; \/\/ Append all following lines until we hit the closing <\/opto_assembly> tag.\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new TestFrameworkException(\"Error while reading \" + hotspotPidFileName, e);\n+        }\n+    }\n+\n+    \/**\n+     * Write the input to the IR method and reset the builder.\n+     *\/\n+    private void flushOutput(String line, StringBuilder builder, String currentMethod) {\n+        TestFramework.check(!currentMethod.isEmpty(), \"current method must be set\");\n+        IRMethod irMethod = compilations.get(currentMethod);\n+        if (line.startsWith(\"<\/i\")) {\n+            \/\/ PrintIdeal\n+            irMethod.setIdealOutput(builder.toString());\n+        } else {\n+            \/\/ PrintOptoAssembly\n+            irMethod.setOptoAssemblyOutput(builder.toString());\n+        }\n+        builder.setLength(0);\n+    }\n+\n+    \/**\n+     * Only consider non-osr (no \"compile_kind\") and compilations with C2 (no \"level\")\n+     *\/\n+    private boolean maybeTestEntry(String line) {\n+        return line.startsWith(\"<task_queued\") && !line.contains(\"compile_kind='\") && !line.contains(\"level='\");\n+    }\n+\n+    \/**\n+     * Need to escape XML special characters.\n+     *\/\n+    private static void appendLine(StringBuilder builder, String line) {\n+        if (line.contains(\"&\")) {\n+            line = line.replace(\"&lt;\", \"<\");\n+            line = line.replace(\"&gt;\", \">\");\n+            line = line.replace(\"&quot;\", \"\\\"\");\n+            line = line.replace(\"&apos;\", \"'\");\n+            line = line.replace(\"&amp;\", \"&\");\n+        }\n+        builder.append(line).append(System.lineSeparator());\n+    }\n+\n+    private static int getCompileId(Matcher matcher) {\n+        int compileId;\n+        try {\n+            compileId = Integer.parseInt(matcher.group(1));\n+        } catch (NumberFormatException e) {\n+            throw new TestRunException(\"Could not parse compile id\", e);\n+        }\n+        return compileId;\n+    }\n+\n+    \/**\n+     * Parse the compile id from this line if it belongs to a method that needs to be IR tested (part of test class\n+     * and IR encoding from the test VM specifies that this method has @IR rules to be checked).\n+     *\/\n+    private void addTestMethodCompileId(Map<Integer, String> compileIdMap, String line) {\n+        Matcher matcher = compileIdPatternForTestClass.matcher(line);\n+        if (matcher.find()) {\n+            \/\/ Only care about test class entries. Might have non-class entries as well if user specified additional\n+            \/\/ compile commands. Ignore these.\n+            String methodName = matcher.group(2);\n+            if (compilations.containsKey(methodName)) {\n+                \/\/ We only care about methods that we are actually gonna IR match based on IR encoding.\n+                int compileId = getCompileId(matcher);\n+                TestRun.check(!methodName.isEmpty(), \"method name cannot be empty\");\n+                compileIdMap.put(compileId, methodName);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Make sure that line does not contain compile_kind which is used for OSR compilations which we are not\n+     * interested in.\n+     *\/\n+    private static boolean isPrintIdealStart(String line) {\n+        return line.startsWith(\"<ideal\") && !line.contains(\"compile_kind='\");\n+    }\n+\n+    \/**\n+     * Make sure that line does not contain compile_kind which is used for OSR compilations which we are not\n+     * interested in.\n+     *\/\n+    private static boolean isPrintOptoAssemblyStart(String line) {\n+        return line.startsWith(\"<opto_assembly\") && !line.contains(\"compile_kind='\");\n+    }\n+\n+    \/**\n+     * Get method name for this line by looking up the compile id.\n+     * Returns null if not an interesting method (i.e. from test class).\n+     *\/\n+    private String getMethodName(Map<Integer, String> compileIdMap, String line) {\n+        Matcher matcher = COMPILE_ID_PATTERN.matcher(line);\n+        TestFramework.check(matcher.find(), \"Is \" + hotspotPidFileName + \" corrupted?\");\n+        int compileId = getCompileId(matcher);\n+        return compileIdMap.get(compileId);\n+    }\n+\n+    \/**\n+     * Do an IR matching of all methods with appliable @IR rules fetched during parsing of the hotspot pid file.\n+     *\/\n+    private void applyRules() {\n+        compilations.values().forEach(this::applyRulesForMethod);\n+        reportFailuresIfAny();\n+    }\n+\n+    private void applyRulesForMethod(IRMethod irMethod) {\n+        this.irMethod = irMethod;\n+        method = irMethod.getMethod();\n+        String testOutput = irMethod.getOutput();\n+        if (testOutput.isEmpty()) {\n+            String msg = \"Method was not compiled. Did you specify any compiler directives preventing a compilation or used a \" +\n+                         \"@Run method in STANDALONE mode? In the latter case, make sure to always trigger a C2 compilation \" +\n+                         \"by invoking the test enough times.\";\n+            fails.computeIfAbsent(method, k -> new ArrayList<>()).add(msg);\n+            return;\n+        }\n+\n+        if (TestFramework.VERBOSE) {\n+            System.out.println(\"Output of \" + method + \":\");\n+            System.out.println(testOutput);\n+        }\n+        Arrays.stream(irMethod.getRuleIds()).forEach(this::applyIRRule);\n+    }\n+\n+    \/**\n+     * Apply a single @IR rule as part of a method.\n+     *\/\n+    private void applyIRRule(int id) {\n+        irAnno = irMethod.getIrAnno(id);\n+        irRuleIndex = id;\n+        StringBuilder failMsg = new StringBuilder();\n+        applyFailOn(failMsg);\n+        try {\n+            applyCounts(failMsg);\n+        } catch (TestFormatException e) {\n+            \/\/ Logged. Continue to check other rules.\n+        }\n+        if (!failMsg.isEmpty()) {\n+            failMsg.insert(0, \"@IR rule \" + (id + 1) + \": \\\"\" + irAnno + \"\\\"\" + System.lineSeparator());\n+            fails.computeIfAbsent(method, k -> new ArrayList<>()).add(failMsg.toString());\n+        }\n+    }\n+\n+    \/**\n+     * Apply the failOn regexes of the @IR rule.\n+     *\/\n+    private void applyFailOn(StringBuilder failMsg) {\n+        if (irAnno.failOn().length != 0) {\n+            String failOnRegex = String.join(\"|\", IRNode.mergeNodes(irAnno.failOn()));\n+            Pattern pattern = Pattern.compile(failOnRegex);\n+            Matcher matcher = pattern.matcher(irMethod.getOutput());\n+            long matchCount = matcher.results().count();\n+            if (matchCount > 0) {\n+                addFailOnFailsForOutput(failMsg, pattern, matchCount);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A failOn regex failed. Apply all regexes again to log the exact regex which failed. The failure is later reported\n+     * to the user.\n+     *\/\n+    private void addFailOnFailsForOutput(StringBuilder failMsg, Pattern pattern, long matchCount) {\n+        long idealCount = pattern.matcher(irMethod.getIdealOutput()).results().count();\n+        long optoAssemblyCount = pattern.matcher(irMethod.getOptoAssemblyOutput()).results().count();\n+        if (matchCount != idealCount + optoAssemblyCount || (idealCount != 0 && optoAssemblyCount != 0)) {\n+            \/\/ Report with Ideal and Opto Assembly\n+            addFailOnFailsForOutput(failMsg, irMethod.getOutput());\n+            irMethod.needsAllOutput();\n+        } else if (optoAssemblyCount == 0) {\n+            \/\/ Report with Ideal only\n+            addFailOnFailsForOutput(failMsg, irMethod.getIdealOutput());\n+            irMethod.needsIdeal();\n+        } else {\n+            \/\/ Report with Opto Assembly only\n+            addFailOnFailsForOutput(failMsg, irMethod.getOptoAssemblyOutput());\n+            irMethod.needsOptoAssembly();\n+        }\n+    }\n+\n+    \/**\n+     * Apply the regexes to the testOutput and log the failures.\n+     *\/\n+    private void addFailOnFailsForOutput(StringBuilder failMsg, String testOutput) {\n+        List<String> failOnNodes = IRNode.mergeNodes(irAnno.failOn());\n+        Pattern pattern;\n+        Matcher matcher;\n+        failMsg.append(\"- failOn: Graph contains forbidden nodes:\").append(System.lineSeparator());\n+        int nodeId = 1;\n+        for (String nodeRegex : failOnNodes) {\n+            pattern = Pattern.compile(nodeRegex);\n+            matcher = pattern.matcher(testOutput);\n+            long matchCount = matcher.results().count();\n+            if (matchCount > 0) {\n+                matcher.reset();\n+                failMsg.append(\"    Regex \").append(nodeId).append(\": \").append(nodeRegex).append(System.lineSeparator());\n+                failMsg.append(\"    Matched forbidden node\").append(matchCount > 1 ? \"s (\" + matchCount + \")\" : \"\")\n+                       .append(\":\").append(System.lineSeparator());\n+                matcher.results().forEach(r -> failMsg.append(\"      \").append(r.group()).append(System.lineSeparator()));\n+            }\n+            nodeId++;\n+        }\n+    }\n+\n+    \/**\n+     * Apply the counts regexes of the @IR rule.\n+     *\/\n+    private void applyCounts(StringBuilder failMsg) {\n+        if (irAnno.counts().length != 0) {\n+            boolean hasFails = false;\n+            String testOutput = irMethod.getOutput();\n+            int countsId = 1;\n+            final List<String> nodesWithCount = IRNode.mergeNodes(irAnno.counts());\n+            for (int i = 0; i < nodesWithCount.size(); i += 2) {\n+                String node = nodesWithCount.get(i);\n+                TestFormat.check(i + 1 < nodesWithCount.size(), \"Missing count\" + getPostfixErrorMsg(node));\n+                String countString = nodesWithCount.get(i + 1);\n+                long expectedCount;\n+                ParsedComparator<Long> parsedComparator;\n+                try {\n+                    parsedComparator = ParsedComparator.parseComparator(countString);\n+                    expectedCount = Long.parseLong(parsedComparator.getStrippedString());\n+                } catch (NumberFormatException e) {\n+                    TestFormat.fail(\"Provided invalid count \\\"\" + countString + \"\\\"\" + getPostfixErrorMsg(node));\n+                    return;\n+                } catch (CheckedTestFrameworkException e) {\n+                    TestFormat.fail(\"Invalid comparator \\\"\" + e.getMessage() + \"\\\" in \\\"\" + countString + \"\\\" for count\" + getPostfixErrorMsg(node));\n+                    return;\n+                } catch (IndexOutOfBoundsException e) {\n+                    TestFormat.fail(\"Provided empty value\" + getPostfixErrorMsg(node));\n+                    return;\n+                }\n+                TestFormat.check(expectedCount >= 0,\"Provided invalid negative count \\\"\" + countString + \"\\\"\" + getPostfixErrorMsg(node));\n+\n+                Pattern pattern = Pattern.compile(node);\n+                Matcher matcher = pattern.matcher(testOutput);\n+                long actualCount = matcher.results().count();\n+                if (!parsedComparator.getPredicate().test(actualCount, expectedCount)) {\n+                    if (!hasFails) {\n+                        failMsg.append(\"- counts: Graph contains wrong number of nodes:\").append(System.lineSeparator());\n+                        hasFails = true;\n+                    }\n+                    addCountsFail(failMsg, node, pattern, expectedCount, actualCount, countsId);\n+                }\n+                countsId++;\n+            }\n+        }\n+    }\n+\n+    private String getPostfixErrorMsg(String node) {\n+        return \" for IR rule \" + irRuleIndex + \", node \\\"\" + node + \"\\\" at \" + method;\n+    }\n+\n+    \/**\n+     * A counts regex failed. Apply all regexes again to log the exact regex which failed. The failure is later reported\n+     * to the user.\n+     *\/\n+    private void addCountsFail(StringBuilder failMsg, String node, Pattern pattern, long expectedCount, long actualCount, int countsId) {\n+        failMsg.append(\"    Regex \").append(countsId).append(\": \").append(node).append(System.lineSeparator());\n+        failMsg.append(\"    Expected \").append(expectedCount).append(\" but found \").append(actualCount);\n+\n+        if (actualCount > 0) {\n+            Matcher matcher = pattern.matcher(irMethod.getOutput());\n+            long idealCount = pattern.matcher(irMethod.getIdealOutput()).results().count();\n+            long optoAssemblyCount = pattern.matcher(irMethod.getOptoAssemblyOutput()).results().count();\n+            if (actualCount != idealCount + optoAssemblyCount || (idealCount != 0 && optoAssemblyCount != 0)) {\n+                irMethod.needsAllOutput();\n+            } else if (optoAssemblyCount == 0) {\n+                irMethod.needsIdeal();\n+            } else {\n+                irMethod.needsOptoAssembly();\n+            }\n+            failMsg.append(\" node\").append(actualCount > 1 ? \"s\" : \"\").append(\":\").append(System.lineSeparator());\n+            matcher.results().forEach(r -> failMsg.append(\"      \").append(r.group()).append(System.lineSeparator()));\n+        } else {\n+            irMethod.needsAllOutput();\n+            failMsg.append(\" nodes.\").append(System.lineSeparator());\n+        }\n+    }\n+\n+    \/**\n+     * Report all IR violations in a pretty format to the user. Depending on the failed regex, we only report\n+     * PrintIdeal or PrintOptoAssembly if the match failed there. If there were failures that matched things\n+     * in both outputs than the entire output is reported. Throws IRViolationException from which the compilation\n+     * can be read and reported to the stdout separately. The exception message only includes the summary of the\n+     * failures.\n+     *\/\n+    private void reportFailuresIfAny() {\n+        TestFormat.reportIfAnyFailures();\n+        if (!fails.isEmpty()) {\n+            StringBuilder failuresBuilder = new StringBuilder();\n+            StringBuilder compilationsBuilder = new StringBuilder();\n+            int failures = 0;\n+            for (Map.Entry<Method, List<String>> entry : fails.entrySet()) {\n+                Method method = entry.getKey();\n+                compilationsBuilder.append(\">>> Compilation of \").append(method).append(\":\").append(System.lineSeparator());\n+                IRMethod irMethod = compilations.get(method.getName());\n+                String output;\n+                if (irMethod.usesIdeal() && irMethod.usesOptoAssembly()) {\n+                    output = irMethod.getOutput();\n+                } else if (irMethod.usesIdeal()) {\n+                    output = irMethod.getIdealOutput();\n+                } else if (irMethod.usesOptoAssembly()) {\n+                    output = irMethod.getOptoAssemblyOutput();\n+                } else {\n+                    output = \"<empty>\";\n+                }\n+                compilationsBuilder.append(output).append(System.lineSeparator()).append(System.lineSeparator());\n+                List<String> list = entry.getValue();\n+                failuresBuilder.append(\"- Method \\\"\").append(method).append(\"\\\":\").append(System.lineSeparator());\n+                failures += list.size();\n+                list.forEach(s -> failuresBuilder.append(\"  * \")\n+                                                 .append(s.replace(System.lineSeparator(),\n+                                                                   System.lineSeparator() + \"    \").trim())\n+                                                 .append(System.lineSeparator()));\n+                failuresBuilder.append(System.lineSeparator());\n+            }\n+            failuresBuilder.insert(0, (\"One or more @IR rules failed:\" + System.lineSeparator()\n+                                       + System.lineSeparator() + \"Failed IR Rules (\" + failures + \")\"\n+                                       + System.lineSeparator()) + \"-----------------\"\n+                                       + \"-\".repeat(String.valueOf(failures).length()) + System.lineSeparator());\n+            failuresBuilder.append(\">>> Check stdout for compilation output of the failed methods\")\n+                           .append(System.lineSeparator()).append(System.lineSeparator());\n+            throw new IRViolationException(failuresBuilder.toString(), compilationsBuilder.toString());\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/IRMatcher.java","additions":493,"deletions":0,"binary":false,"changes":493,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver;\n+\n+import compiler.lib.ir_framework.IR;\n+\n+import java.lang.reflect.Method;\n+\n+\/**\n+ * Helper class to store information about a method that needs to be IR matched.\n+ *\/\n+class IRMethod {\n+    private final Method method;\n+    private final int[] ruleIds;\n+    private final IR[] irAnnos;\n+    private final StringBuilder outputBuilder;\n+    private String output;\n+    private String idealOutput;\n+    private String optoAssemblyOutput;\n+    private boolean needsIdeal;\n+    private boolean needsOptoAssembly;\n+\n+    public IRMethod(Method method, int[] ruleIds, IR[] irAnnos) {\n+        this.method = method;\n+        this.ruleIds = ruleIds;\n+        this.irAnnos = irAnnos;\n+        this.outputBuilder = new StringBuilder();\n+        this.output = \"\";\n+        this.idealOutput = \"\";\n+        this.optoAssemblyOutput = \"\";\n+    }\n+\n+    public Method getMethod() {\n+        return method;\n+    }\n+\n+    public int[] getRuleIds() {\n+        return ruleIds;\n+    }\n+\n+    public IR getIrAnno(int idx) {\n+        return irAnnos[idx];\n+    }\n+\n+    \/**\n+     * The Ideal output comes always before the Opto Assembly output. We might parse multiple C2 compilations of this method.\n+     * Only keep the very last one by overriding 'output'.\n+     *\/\n+    public void setIdealOutput(String idealOutput) {\n+        outputBuilder.setLength(0);\n+        this.idealOutput = \"PrintIdeal:\" + System.lineSeparator() + idealOutput;\n+        outputBuilder.append(this.idealOutput);\n+    }\n+\n+    \/**\n+     * The Opto Assembly output comes after the Ideal output. Simply append to 'output'.\n+     *\/\n+    public void setOptoAssemblyOutput(String optoAssemblyOutput) {\n+        this.optoAssemblyOutput = \"PrintOptoAssembly:\" + System.lineSeparator() + optoAssemblyOutput;\n+        outputBuilder.append(System.lineSeparator()).append(System.lineSeparator()).append(this.optoAssemblyOutput);\n+        output = outputBuilder.toString();\n+    }\n+\n+    public String getOutput() {\n+        return output;\n+    }\n+\n+    public String getIdealOutput() {\n+        return idealOutput;\n+    }\n+\n+    public String getOptoAssemblyOutput() {\n+        return optoAssemblyOutput;\n+    }\n+\n+    public void needsAllOutput() {\n+        needsIdeal();\n+        needsOptoAssembly();\n+    }\n+\n+    public void needsIdeal() {\n+        needsIdeal = true;\n+    }\n+\n+    public boolean usesIdeal() {\n+        return needsIdeal;\n+    }\n+\n+    public void needsOptoAssembly() {\n+        needsOptoAssembly = true;\n+    }\n+\n+    public boolean usesOptoAssembly() {\n+        return needsOptoAssembly;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/IRMethod.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.Test;\n+\n+\/**\n+ * Exception that is thrown if an {@link IR} rule\/constraint failed. The exception message contains a detailed list of\n+ * all failures, including failing method(s), {@code @IR} rule(s) (the first {@code @IR} constraint is rule 1) and the\n+ * specific regex(es) that could not be matched.\n+ *\n+ * @see IR\n+ * @see Test\n+ *\/\n+public class IRViolationException extends RuntimeException {\n+    private final String compilations;\n+    private String exceptionInfo;\n+\n+    IRViolationException(String message, String compilations) {\n+        super(\"There were one or multiple IR rule failures. Please check stderr for more information.\");\n+        this.exceptionInfo = message;\n+        this.compilations = compilations;\n+    }\n+\n+    \/**\n+     * Get some more detailed information about the violated IR rule(s) and how to reproduce it.\n+     *\n+     * @return a formatted string containing information about the violated IR rule(s) and how to reproduce it.\n+     *\/\n+    public String getExceptionInfo() {\n+        return exceptionInfo;\n+    }\n+\n+    public String getCompilations() {\n+        return compilations;\n+    }\n+\n+    public void addCommandLine(String commandLine) {\n+        this.exceptionInfo = commandLine + System.lineSeparator() + exceptionInfo;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/IRViolationException.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+\n+\/**\n+ * Exception that is thrown if the test VM has thrown any kind of exception (except for {@link TestFormatException}).\n+ *\/\n+public class TestVMException extends RuntimeException {\n+    private final String exceptionInfo;\n+\n+    TestVMException(String exceptionInfo) {\n+        super(\"There were one or multiple errors. Please check stderr for more information.\");\n+        this.exceptionInfo = exceptionInfo;\n+    }\n+\n+    \/**\n+     * Get some more detailed information about the exception thrown in the test VM and how to reproduce it.\n+     *\n+     * @return a formatted string containing information about the exception of the test VM and how to reproduce it.\n+     *\/\n+    public String getExceptionInfo() {\n+        return exceptionInfo;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/TestVMException.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver;\n+\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+import compiler.lib.ir_framework.shared.TestFrameworkSocket;\n+import compiler.lib.ir_framework.shared.NoTestsRunException;\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+import compiler.lib.ir_framework.test.TestVM;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * This class prepares, creates, and runs the \"test\" VM with verification of proper termination. The class also stores\n+ * information about the test VM which is later queried for IR matching. The communication between this driver VM\n+ * and the test VM is done over a dedicated socket.\n+ *\n+ * @see TestVM\n+ * @see TestFrameworkSocket\n+ *\/\n+public class TestVMProcess {\n+    private static final boolean VERBOSE = Boolean.getBoolean(\"Verbose\");\n+    private static final boolean PREFER_COMMAND_LINE_FLAGS = Boolean.getBoolean(\"PreferCommandLineFlags\");\n+    private static final int WARMUP_ITERATIONS = Integer.getInteger(\"Warmup\", -1);\n+    private static final boolean VERIFY_VM = Boolean.getBoolean(\"VerifyVM\") && Platform.isDebugBuild();\n+    private static final boolean REPORT_STDOUT = Boolean.getBoolean(\"ReportStdout\");\n+    private static final boolean EXCLUDE_RANDOM = Boolean.getBoolean(\"ExcludeRandom\");\n+\n+    private static String lastTestVMOutput = \"\";\n+\n+    private final ArrayList<String> cmds;\n+    private String hotspotPidFileName;\n+    private String commandLine;\n+    private OutputAnalyzer oa;\n+    private String irEncoding;\n+\n+    public TestVMProcess(List<String> additionalFlags, Class<?> testClass, Set<Class<?>> helperClasses, int defaultWarmup) {\n+        this.cmds = new ArrayList<>();\n+        TestFrameworkSocket socket = new TestFrameworkSocket();\n+        try (socket) {\n+            prepareTestVMFlags(additionalFlags, socket, testClass, helperClasses, defaultWarmup);\n+            start();\n+        }\n+        processSocketOutput(socket.getOutput());\n+        checkTestVMExitCode();\n+    }\n+\n+    public String getCommandLine() {\n+        return commandLine;\n+    }\n+\n+    public String getIrEncoding() {\n+        return irEncoding;\n+    }\n+\n+    public String getHotspotPidFileName() {\n+        return hotspotPidFileName;\n+    }\n+\n+    public static String getLastTestVMOutput() {\n+        return lastTestVMOutput;\n+    }\n+\n+    private void prepareTestVMFlags(List<String> additionalFlags, TestFrameworkSocket socket, Class<?> testClass,\n+                                    Set<Class<?>> helperClasses, int defaultWarmup) {\n+        \/\/ Set java.library.path so JNI tests which rely on jtreg nativepath setting work\n+        cmds.add(\"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH);\n+        \/\/ Need White Box access in test VM.\n+        cmds.add(\"-Xbootclasspath\/a:.\");\n+        cmds.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        cmds.add(\"-XX:+WhiteBoxAPI\");\n+        String[] jtregVMFlags = Utils.getTestJavaOpts();\n+        if (!PREFER_COMMAND_LINE_FLAGS) {\n+            cmds.addAll(Arrays.asList(jtregVMFlags));\n+        }\n+        \/\/ Add server property flag that enables test VM to print encoding for IR verification last and debug messages.\n+        cmds.add(socket.getPortPropertyFlag());\n+        cmds.addAll(additionalFlags);\n+        cmds.addAll(Arrays.asList(getDefaultFlags()));\n+        if (VERIFY_VM) {\n+            cmds.addAll(Arrays.asList(getVerifyFlags()));\n+        }\n+\n+        if (PREFER_COMMAND_LINE_FLAGS) {\n+            \/\/ Prefer flags set via the command line over the ones set by scenarios.\n+            cmds.addAll(Arrays.asList(jtregVMFlags));\n+        }\n+\n+        if (WARMUP_ITERATIONS < 0 && defaultWarmup != -1) {\n+            \/\/ Only use the set warmup for the framework if not overridden by a valid -DWarmup property set by a test.\n+            cmds.add(\"-DWarmup=\" + defaultWarmup);\n+        }\n+\n+        cmds.add(TestVM.class.getName());\n+        cmds.add(testClass.getName());\n+        if (helperClasses != null) {\n+            helperClasses.forEach(c -> cmds.add(c.getName()));\n+        }\n+    }\n+\n+    \/**\n+     * Default flags that are added used for the test VM.\n+     *\/\n+    private static String[] getDefaultFlags() {\n+        return new String[] {\"-XX:-BackgroundCompilation\", \"-XX:CompileCommand=quiet\"};\n+    }\n+\n+    \/**\n+     * Additional verification flags that are used if -DVerifyVM=true is with a debug build.\n+     *\/\n+    private static String[] getVerifyFlags() {\n+        return new String[] {\n+                \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+VerifyOops\", \"-XX:+VerifyStack\", \"-XX:+VerifyLastFrame\",\n+                \"-XX:+VerifyBeforeGC\", \"-XX:+VerifyAfterGC\", \"-XX:+VerifyDuringGC\", \"-XX:+VerifyAdapterSharing\"\n+        };\n+    }\n+\n+    private void start() {\n+        ProcessBuilder process = ProcessTools.createJavaProcessBuilder(cmds);\n+        try {\n+            \/\/ Calls 'main' of TestVM to run all specified tests with commands 'cmds'.\n+            \/\/ Use executeProcess instead of executeTestJvm as we have already added the JTreg VM and\n+            \/\/ Java options in prepareTestVMFlags().\n+            oa = ProcessTools.executeProcess(process);\n+        } catch (Exception e) {\n+            throw new TestFrameworkException(\"Error while executing Test VM\", e);\n+        }\n+        commandLine = \"Command Line:\" + System.lineSeparator() + String.join(\" \", process.command())\n+                      + System.lineSeparator();\n+        hotspotPidFileName = String.format(\"hotspot_pid%d.log\", oa.pid());\n+        lastTestVMOutput = oa.getOutput();\n+    }\n+\n+    \/**\n+     * Process the socket output: All prefixed lines are dumped to the standard output while the remaining lines\n+     * represent the IR encoding used for IR matching later.\n+     *\/\n+    private void processSocketOutput(String output) {\n+        if (TestFramework.TESTLIST || TestFramework.EXCLUDELIST) {\n+            StringBuilder builder = new StringBuilder();\n+            Scanner scanner = new Scanner(output);\n+            System.out.println(System.lineSeparator() + \"Run flag defined test list\");\n+            System.out.println(\"--------------------------\");\n+            while (scanner.hasNextLine()) {\n+                String line = scanner.nextLine();\n+                if (line.startsWith(TestFrameworkSocket.STDOUT_PREFIX)) {\n+                    line = \"> \" + line.substring(TestFrameworkSocket.STDOUT_PREFIX.length());\n+                    System.out.println(line);\n+                } else {\n+                    builder.append(line).append(System.lineSeparator());\n+                }\n+            }\n+            System.out.println();\n+            irEncoding = builder.toString();\n+        } else {\n+            irEncoding = output;\n+        }\n+    }\n+\n+    private void checkTestVMExitCode() {\n+        final int exitCode = oa.getExitValue();\n+        if (EXCLUDE_RANDOM || REPORT_STDOUT || (VERBOSE && exitCode == 0)) {\n+            System.out.println(\"--- OUTPUT TestFramework test VM ---\");\n+            System.out.println(oa.getOutput());\n+        }\n+\n+        if (exitCode != 0) {\n+            throwTestVMException();\n+        }\n+    }\n+\n+    \/**\n+     * Exit code was non-zero of test VM. Check the stderr to determine what kind of exception that should be thrown to\n+     * react accordingly later.\n+     *\/\n+    private void throwTestVMException() {\n+        String stdErr = oa.getStderr();\n+        if (stdErr.contains(\"TestFormat.reportIfAnyFailures\")) {\n+            Pattern pattern = Pattern.compile(\"Violations \\\\(\\\\d+\\\\)[\\\\s\\\\S]*(?=\/============\/)\");\n+            Matcher matcher = pattern.matcher(stdErr);\n+            TestFramework.check(matcher.find(), \"Must find violation matches\");\n+            throw new TestFormatException(System.lineSeparator() + System.lineSeparator() + matcher.group());\n+        } else if (stdErr.contains(\"NoTestsRunException\")) {\n+            throw new NoTestsRunException(\">>> No tests run due to empty set specified with -DTest and\/or -DExclude. \" +\n+                                          \"Make sure to define a set of at least one @Test method\");\n+        } else {\n+            throw new TestVMException(getExceptionInfo());\n+        }\n+    }\n+\n+    \/**\n+     * Get more detailed information about the exception in a pretty format.\n+     *\/\n+    private String getExceptionInfo() {\n+        int exitCode = oa.getExitValue();\n+        String stdErr = oa.getStderr();\n+        String stdOut = \"\";\n+        if (exitCode == 134) {\n+            \/\/ Also dump the stdout if we experience a JVM error (e.g. to show hit assertions etc.).\n+            stdOut = System.lineSeparator() + System.lineSeparator() + \"Standard Output\" + System.lineSeparator()\n+                     + \"---------------\" + System.lineSeparator() + oa.getOutput();\n+        }\n+        return \"TestFramework test VM exited with code \" + exitCode + System.lineSeparator() + stdOut\n+               + System.lineSeparator() + commandLine + System.lineSeparator() + System.lineSeparator()\n+               + \"Error Output\" + System.lineSeparator() + \"------------\" + System.lineSeparator() + stdErr\n+               + System.lineSeparator() + System.lineSeparator();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/TestVMProcess.java","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.flag;\n+\n+import compiler.lib.ir_framework.CompLevel;\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import jdk.test.lib.process.ProcessTools;\n+import sun.hotspot.WhiteBox;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+\/**\n+ * This class' main method is called from {@link TestFramework} and represents the so-called \"flag VM\". It uses the\n+ * Whitebox API to determine the necessary additional flags to run the test VM (e.g. to do IR matching). It returns\n+ * the flags over the dedicated TestFramework socket.\n+ *\/\n+public class FlagVM {\n+    public static final String TEST_VM_FLAGS_FILE_PREFIX = \"test-vm-flags-pid-\";\n+    public static final String TEST_VM_FLAGS_FILE_POSTFIX = \".log\";\n+    public static final String TEST_VM_FLAGS_DELIMITER = \" \";\n+\n+    private static final String TEST_VM_FLAGS_FILE;\n+    private static final WhiteBox WHITE_BOX;\n+\n+    static {\n+        try {\n+            WHITE_BOX = WhiteBox.getWhiteBox();\n+            TEST_VM_FLAGS_FILE = TEST_VM_FLAGS_FILE_PREFIX + ProcessTools.getProcessId() + TEST_VM_FLAGS_FILE_POSTFIX;\n+        } catch (UnsatisfiedLinkError e) {\n+            throw new TestFrameworkException(\"Could not load WhiteBox\", e);\n+        } catch (Exception e) {\n+            throw new TestFrameworkException(\"Could not get process id\", e);\n+        }\n+    }\n+\n+\n+    private static final boolean TIERED_COMPILATION = (Boolean)WHITE_BOX.getVMFlag(\"TieredCompilation\");\n+    private static final CompLevel TIERED_COMPILATION_STOP_AT_LEVEL =\n+            CompLevel.forValue(((Long)WHITE_BOX.getVMFlag(\"TieredStopAtLevel\")).intValue());\n+    private static final boolean TEST_C1 = TIERED_COMPILATION\n+                                           && TIERED_COMPILATION_STOP_AT_LEVEL.getValue() < CompLevel.C2.getValue();\n+\n+    private static final boolean VERBOSE = Boolean.getBoolean(\"Verbose\");\n+    private static final boolean USE_COMPILER = WHITE_BOX.getBooleanVMFlag(\"UseCompiler\");\n+    private static final boolean EXCLUDE_RANDOM = Boolean.getBoolean(\"ExcludeRandom\");\n+    private static final boolean FLIP_C1_C2 = Boolean.getBoolean(\"FlipC1C2\");\n+    private static final boolean REQUESTED_VERIFY_IR = Boolean.parseBoolean(System.getProperty(\"VerifyIR\", \"true\"));\n+    private static final boolean VERIFY_IR = REQUESTED_VERIFY_IR && USE_COMPILER && !EXCLUDE_RANDOM && !FLIP_C1_C2 && !TEST_C1;\n+\n+    private static String[] getPrintFlags() {\n+        return new String[] {\"-XX:+PrintCompilation\", \"-XX:+UnlockDiagnosticVMOptions\"};\n+    }\n+\n+    \/**\n+     * Main entry point of the flag VM.\n+     *\/\n+    public static void main(String[] args) {\n+        String testClassName = args[0];\n+        if (VERBOSE) {\n+            System.out.println(\"FlagVM main() called. Prepare test VM flags to run class \" + testClassName);\n+        }\n+        Class<?> testClass;\n+        try {\n+            testClass = Class.forName(testClassName);\n+        } catch (Exception e) {\n+            throw new TestRunException(\"Could not find test class \" + testClassName, e);\n+        }\n+        emitTestVMFlags(prepareTestVmFlags(testClass));\n+    }\n+\n+    \/**\n+     * Emit test VM flags to the dedicated test VM flags file to parse them from the TestFramework \"driver\" VM again\n+     * which adds them to the test VM.\n+     *\/\n+    private static void emitTestVMFlags(ArrayList<String> flags) {\n+        try (var bw = Files.newBufferedWriter(Paths.get(TEST_VM_FLAGS_FILE))) {\n+            bw.write(String.join(TEST_VM_FLAGS_DELIMITER, flags));\n+        } catch (IOException e) {\n+            throw new TestFrameworkException(\"Error while writing to file \" + TEST_VM_FLAGS_FILE, e);\n+        }\n+    }\n+\n+    private static ArrayList<String> prepareTestVmFlags(Class<?> testClass) {\n+        return setupIrVerificationFlags(testClass);\n+    }\n+\n+    private static ArrayList<String> setupIrVerificationFlags(Class<?> testClass) {\n+        ArrayList<String> cmds = new ArrayList<>();\n+        if (VERIFY_IR) {\n+            \/\/ Add print flags for IR verification\n+            cmds.addAll(Arrays.asList(getPrintFlags()));\n+            cmds.add(\"-XX:+LogCompilation\");\n+            cmds.add(\"-XX:CompileCommand=log,\" + testClass.getCanonicalName() + \"::*\");\n+            addBoolOptionForClass(cmds, testClass, \"PrintIdeal\");\n+            addBoolOptionForClass(cmds, testClass, \"PrintOptoAssembly\");\n+            \/\/ Always trap for exception throwing to not confuse IR verification\n+            cmds.add(\"-XX:-OmitStackTraceInFastThrow\");\n+            cmds.add(\"-DShouldDoIRVerification=true\");\n+        } else {\n+            cmds.add(\"-DShouldDoIRVerification=false\");\n+        }\n+        return cmds;\n+    }\n+\n+    private static void addBoolOptionForClass(ArrayList<String> cmds, Class<?> testClass, String option) {\n+        cmds.add(\"-XX:CompileCommand=option,\" + testClass.getCanonicalName() + \"::*,bool,\" + option + \",true\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/flag\/FlagVM.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+\/**\n+ * Checked internal exceptions in the framework to propagate error handling.\n+ *\/\n+public class CheckedTestFrameworkException extends Exception {\n+    public CheckedTestFrameworkException(String msg) {\n+        super(msg);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/CheckedTestFrameworkException.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+\/**\n+ * Exception that is thrown by the test VM if no tests are run as a result of specifying {@code -DTest} and\/or\n+ * {@code -DExclude} defining an empty set with the used test VM flags.\n+ *\/\n+public class NoTestsRunException extends RuntimeException {\n+    \/**\n+     * Default constructor used by test VM\n+     *\/\n+    public NoTestsRunException() {}\n+\n+    \/**\n+     * Constructor used to eventually throw the exception in the driver VM.\n+     *\/\n+    public NoTestsRunException(String message) {\n+        super(message);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/NoTestsRunException.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+import java.util.function.BiPredicate;\n+\n+\/**\n+ * Utility class to parse a comparator either in the applyIf* or in the counts properties of an @IR rules.\n+ *\/\n+public class ParsedComparator<T extends Comparable<T>> {\n+    private final String strippedString;\n+    private final BiPredicate<T, T> predicate;\n+    private final String comparator;\n+\n+    public ParsedComparator(String strippedString, BiPredicate<T, T> predicate, String comparator) {\n+        this.strippedString = strippedString;\n+        this.predicate = predicate;\n+        this.comparator = comparator;\n+    }\n+\n+    public String getStrippedString() {\n+        return strippedString;\n+    }\n+\n+    public BiPredicate<T, T> getPredicate() {\n+        return predicate;\n+    }\n+\n+    public String getComparator() {\n+        return comparator;\n+    }\n+\n+    \/**\n+     * Return parsed comparator object which provides the predicate to perform the test.\n+     * Allowed comparators: <, <=, >, =>, =, !=\n+     *\/\n+    public static <T extends Comparable<T>> ParsedComparator<T> parseComparator(String value) throws CheckedTestFrameworkException {\n+        BiPredicate<T, T> comparison;\n+        value = value.trim();\n+        String comparator = \"\";\n+        switch (value.charAt(0)) {\n+            case '<':\n+                if (value.charAt(1) == '=') {\n+                    comparator = \"<=\";\n+                    comparison = (x, y) -> x.compareTo(y) <= 0;\n+                    value = value.substring(2).trim();\n+                } else {\n+                    comparator = \"<\";\n+                    comparison = (x, y) -> x.compareTo(y) < 0;\n+                    value = value.substring(1).trim();\n+                }\n+                break;\n+            case '>':\n+                if (value.charAt(1) == '=') {\n+                    comparator = \">=\";\n+                    comparison = (x, y) -> x.compareTo(y) >= 0;\n+                    value = value.substring(2).trim();\n+                } else {\n+                    comparator = \">\";\n+                    comparison = (x, y) -> x.compareTo(y) > 0;\n+                    value = value.substring(1).trim();\n+                }\n+                break;\n+            case '!':\n+                if (value.charAt(1) != '=') {\n+                    throw new CheckedTestFrameworkException(value.substring(0, 1));\n+                }\n+                comparator = \"!=\";\n+                comparison = (x, y) -> x.compareTo(y) != 0;\n+                value = value.substring(2).trim();\n+                break;\n+            case '=': \/\/ Allowed syntax, equivalent to not using any symbol.\n+                comparator = \"=\";\n+                value = value.substring(1).trim();\n+                \/\/ Fall through\n+            default:\n+                comparison = (x, y) -> x.compareTo(y) == 0;\n+                value = value.trim();\n+                break;\n+        }\n+        return new ParsedComparator<>(value, comparison, comparator);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/ParsedComparator.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Utility class to report a {@link TestFormatException}.\n+ *\/\n+public class TestFormat {\n+    private static final List<String> FAILURES = new ArrayList<>();\n+\n+    public static void check(boolean test, String failureMessage) {\n+        if (!test) {\n+            fail(failureMessage);\n+        }\n+    }\n+\n+    public static void checkNoThrow(boolean test, String failureMessage) {\n+        if (!test) {\n+            failNoThrow(failureMessage);\n+        }\n+    }\n+\n+    public static void fail(String failureMessage) {\n+        FAILURES.add(failureMessage);\n+        throw new TestFormatException(failureMessage);\n+    }\n+\n+    public static void failNoThrow(String failureMessage) {\n+        FAILURES.add(failureMessage);\n+    }\n+\n+    public static void reportIfAnyFailures() {\n+        if (FAILURES.isEmpty()) {\n+            \/\/ No format violation detected.\n+            return;\n+        }\n+        StringBuilder builder = new StringBuilder();\n+        builder.append(System.lineSeparator()).append(\"One or more format violations have been detected:\")\n+               .append(System.lineSeparator()).append(System.lineSeparator());\n+        builder.append(\"Violations (\").append(FAILURES.size()).append(\")\").append(System.lineSeparator());\n+        builder.append(\"-------------\").append(\"-\".repeat(String.valueOf(FAILURES.size()).length()))\n+               .append(System.lineSeparator());\n+        for (String failure : FAILURES) {\n+            builder.append(\" - \").append(failure).append(System.lineSeparator());\n+        }\n+        builder.append(\"\/============\/\");\n+        FAILURES.clear();\n+        throw new TestFormatException(builder.toString());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestFormat.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+\/**\n+ * Exception that is thrown if a JTreg test violates the supported format by the test framework.\n+ *\/\n+public class TestFormatException extends RuntimeException {\n+    public TestFormatException(String message) {\n+        super(message);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestFormatException.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+\/**\n+ * Exception that is thrown if there is an internal error in the framework. This is most likely an indicator of a bug\n+ * in the framework.\n+ *\/\n+public class TestFrameworkException extends RuntimeException {\n+    public TestFrameworkException(String message) {\n+        super(\"Internal Test Framework exception - please file a bug:\" + System.lineSeparator() + message);\n+    }\n+\n+    public TestFrameworkException(String message, Throwable e) {\n+        super(\"Internal Test Framework exception - please file a bug:\" + System.lineSeparator() + message, e);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestFrameworkException.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+import compiler.lib.ir_framework.TestFramework;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.FutureTask;\n+\n+\/**\n+ * Dedicated socket to send data from the flag and test VM back to the driver VM.\n+ *\/\n+public class TestFrameworkSocket implements AutoCloseable {\n+    public static final String STDOUT_PREFIX = \"[STDOUT]\";\n+    \/\/ Static fields used for test VM only.\n+    private static final String SERVER_PORT_PROPERTY = \"ir.framework.server.port\";\n+    private static final int SERVER_PORT = Integer.getInteger(SERVER_PORT_PROPERTY, -1);\n+\n+    private static final boolean REPRODUCE = Boolean.getBoolean(\"Reproduce\");\n+    private static final String HOSTNAME = null;\n+    private static Socket clientSocket = null;\n+    private static PrintWriter clientWriter = null;\n+\n+    private final String serverPortPropertyFlag;\n+    private FutureTask<String> socketTask;\n+    private final ServerSocket serverSocket;\n+\n+    public TestFrameworkSocket() {\n+        try {\n+            serverSocket = new ServerSocket(0);\n+        } catch (IOException e) {\n+            throw new TestFrameworkException(\"Failed to create TestFramework server socket\", e);\n+        }\n+        int port = serverSocket.getLocalPort();\n+        if (TestFramework.VERBOSE) {\n+            System.out.println(\"TestFramework server socket uses port \" + port);\n+        }\n+        serverPortPropertyFlag = \"-D\" + SERVER_PORT_PROPERTY + \"=\" + port;\n+        start();\n+    }\n+\n+    public String getPortPropertyFlag() {\n+        return serverPortPropertyFlag;\n+    }\n+\n+    private void start() {\n+        socketTask = initSocketTask();\n+        Thread socketThread = new Thread(socketTask);\n+        socketThread.start();\n+    }\n+\n+    \/**\n+     * Waits for a client (created by flag or test VM) to connect. Return the messages received from the client.\n+     *\/\n+    private FutureTask<String> initSocketTask() {\n+        return new FutureTask<>(() -> {\n+            try (Socket clientSocket = serverSocket.accept();\n+                 BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()))\n+            ) {\n+                StringBuilder builder = new StringBuilder();\n+                String next;\n+                while ((next = in.readLine()) != null) {\n+                    builder.append(next).append(System.lineSeparator());\n+                }\n+                return builder.toString();\n+            } catch (IOException e) {\n+                throw new TestFrameworkException(\"Server socket error\", e);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void close() {\n+        try {\n+            serverSocket.close();\n+        } catch (IOException e) {\n+            throw new TestFrameworkException(\"Could not close socket\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Only called by test VM to write to server socket.\n+     *\/\n+    public static void write(String msg, String type) {\n+        write(msg, type, false);\n+    }\n+\n+    \/**\n+     * Only called by test VM to write to server socket.\n+     *\/\n+    public static void write(String msg, String type, boolean stdout) {\n+        if (REPRODUCE) {\n+            System.out.println(\"Debugging Test VM: Skip writing due to -DReproduce\");\n+            return;\n+        }\n+        TestFramework.check(SERVER_PORT != -1, \"Server port was not set correctly for flag and\/or test VM \"\n+                                               + \"or method not called from flag or test VM\");\n+        try {\n+            \/\/ Keep the client socket open until the test VM terminates (calls closeClientSocket before exiting main()).\n+            if (clientSocket == null) {\n+                clientSocket = new Socket(HOSTNAME, SERVER_PORT);\n+                clientWriter = new PrintWriter(clientSocket.getOutputStream(), true);\n+            }\n+            if (stdout) {\n+                msg = STDOUT_PREFIX + msg;\n+            }\n+            clientWriter.println(msg);\n+        } catch (Exception e) {\n+            \/\/ When the test VM is directly run, we should ignore all messages that would normally be sent to the\n+            \/\/ driver VM.\n+            String failMsg = System.lineSeparator() + System.lineSeparator() + \"\"\"\n+                             ###########################################################\n+                              Did you directly run the test VM (TestVM class)\n+                              to reproduce a bug?\n+                              => Append the flag -DReproduce=true and try again!\n+                             ###########################################################\n+                             \"\"\";\n+            throw new TestRunException(failMsg, e);\n+        }\n+        if (TestFramework.VERBOSE) {\n+            System.out.println(\"Written \" + type + \" to socket:\");\n+            System.out.println(msg);\n+        }\n+    }\n+\n+    \/**\n+     * Closes (and flushes) the printer to the socket and the socket itself. Is called as last thing before exiting\n+     * the main() method of the flag and the test VM.\n+     *\/\n+    public static void closeClientSocket() {\n+        if (clientSocket != null) {\n+            try {\n+                clientWriter.close();\n+                clientSocket.close();\n+            } catch (IOException e) {\n+                throw new RuntimeException(\"Could not close TestVM socket\", e);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Get the socket output of the flag VM.\n+     *\/\n+    public String getOutput() {\n+        try {\n+            return socketTask.get();\n+        } catch (ExecutionException e) {\n+            \/\/ Thrown when socket task was not finished, yet (i.e. no client sent data) but socket was already closed.\n+            return \"\";\n+        } catch (Exception e) {\n+            throw new TestFrameworkException(\"Could not read from socket task\", e);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestFrameworkSocket.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+\/**\n+ * Utility class to report a {@link TestRunException}.\n+ *\/\n+public class TestRun {\n+    public static void check(boolean test, String failureMessage) {\n+        if (!test) {\n+            throw new TestRunException(failureMessage);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestRun.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+\/**\n+ * Exception that is thrown if the JTreg test throws an exception during the execution of individual tests of the\n+ * test class.\n+ *\/\n+public class TestRunException extends RuntimeException {\n+    public TestRunException(String message) {\n+        super(message);\n+    }\n+\n+    public TestRunException(String message, Exception e) {\n+        super(message, e);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestRunException.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,221 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.test;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.shared.TestRun;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import sun.hotspot.WhiteBox;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+\n+\/**\n+ * Abstract super class for base, checked and custom run tests.\n+ *\/\n+abstract class AbstractTest {\n+    protected static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    protected static final int TEST_COMPILATION_TIMEOUT = Integer.parseInt(System.getProperty(\"TestCompilationTimeout\", \"10000\"));\n+    protected static final int WAIT_FOR_COMPILATION_TIMEOUT = Integer.parseInt(System.getProperty(\"WaitForCompilationTimeout\", \"10000\"));\n+    protected static final boolean VERIFY_OOPS = (Boolean)WHITE_BOX.getVMFlag(\"VerifyOops\");\n+\n+    protected final int warmupIterations;\n+    protected final boolean skip;\n+\n+    AbstractTest(int warmupIterations, boolean skip) {\n+        this.warmupIterations = warmupIterations;\n+        this.skip = skip;\n+    }\n+\n+    protected boolean shouldCompile(DeclaredTest test) {\n+        return test.getCompLevel() != CompLevel.SKIP;\n+    }\n+\n+    abstract String getName();\n+\n+    \/**\n+     * Should test be executed?\n+     *\/\n+    public boolean isSkipped() {\n+        return skip;\n+    }\n+\n+    \/**\n+     * See {@link CompLevel#WAIT_FOR_COMPILATION}.\n+     *\/\n+    protected static boolean isWaitForCompilation(DeclaredTest test) {\n+        return test.getCompLevel() == CompLevel.WAIT_FOR_COMPILATION;\n+    }\n+\n+    protected static Object createInvocationTarget(Method method) {\n+        Class<?> clazz = method.getDeclaringClass();\n+        Object invocationTarget;\n+        if (Modifier.isStatic(method.getModifiers())) {\n+            invocationTarget = null;\n+        } else {\n+            try {\n+                Constructor<?> constructor = clazz.getDeclaredConstructor();\n+                constructor.setAccessible(true);\n+                invocationTarget = constructor.newInstance();\n+            } catch (Exception e) {\n+                throw new TestRunException(\"Could not create instance of \" + clazz\n+                                           + \". Make sure there is a constructor without arguments.\", e);\n+            }\n+        }\n+        return invocationTarget;\n+    }\n+\n+    \/**\n+     * Run the associated test.\n+     *\/\n+    public void run() {\n+        if (skip) {\n+            return;\n+        }\n+        onStart();\n+        for (int i = 0; i < warmupIterations; i++) {\n+            invokeTest();\n+        }\n+        onWarmupFinished();\n+        compileTest();\n+        \/\/ Always run the test as a last step of the test execution.\n+        invokeTest();\n+    }\n+\n+    protected void onStart() {\n+        \/\/ Do nothing by default.\n+    }\n+\n+    abstract protected void invokeTest();\n+\n+    abstract protected void onWarmupFinished();\n+\n+    abstract protected void compileTest();\n+\n+    protected void compileMethod(DeclaredTest test) {\n+        final Method testMethod = test.getTestMethod();\n+        TestRun.check(WHITE_BOX.isMethodCompilable(testMethod, test.getCompLevel().getValue(), false),\n+                      \"Method \" + testMethod + \" not compilable at level \" + test.getCompLevel()\n+                      + \". Did you use compileonly without including all @Test methods?\");\n+        TestRun.check(WHITE_BOX.isMethodCompilable(testMethod),\n+                      \"Method \" + testMethod + \" not compilable at level \" + test.getCompLevel()\n+                      + \". Did you use compileonly without including all @Test methods?\");\n+        if (TestFramework.VERBOSE) {\n+            System.out.println(\"Compile method \" + testMethod + \" after warm-up...\");\n+        }\n+\n+        final boolean maybeCodeBufferOverflow = (TestVM.TEST_C1 && VERIFY_OOPS);\n+        final long started = System.currentTimeMillis();\n+        long elapsed = 0;\n+        int lastCompilationLevel = -10;\n+        enqueueMethodForCompilation(test);\n+\n+        do {\n+            if (!WHITE_BOX.isMethodQueuedForCompilation(testMethod)) {\n+                if (elapsed > 0) {\n+                    if (TestVM.VERBOSE) {\n+                        System.out.println(testMethod + \" is not in queue anymore due to compiling it simultaneously on \" +\n+                                           \"a different level. Enqueue again.\");\n+                    }\n+                    enqueueMethodForCompilation(test);\n+                }\n+            }\n+            if (maybeCodeBufferOverflow && elapsed > 1000 && !WHITE_BOX.isMethodCompiled(testMethod, false)) {\n+                \/\/ Let's disable VerifyOops temporarily and retry.\n+                WHITE_BOX.setBooleanVMFlag(\"VerifyOops\", false);\n+                WHITE_BOX.clearMethodState(testMethod);\n+                enqueueMethodForCompilation(test);\n+                WHITE_BOX.setBooleanVMFlag(\"VerifyOops\", true);\n+            }\n+\n+            lastCompilationLevel = WHITE_BOX.getMethodCompilationLevel(testMethod, false);\n+            if (lastCompilationLevel == test.getCompLevel().getValue()) {\n+                break;\n+            }\n+            elapsed = System.currentTimeMillis() - started;\n+        } while (elapsed < TEST_COMPILATION_TIMEOUT);\n+        TestRun.check(elapsed < TEST_COMPILATION_TIMEOUT,\n+                      \"Could not compile \" + testMethod + \" at level \" + test.getCompLevel() + \" after \"\n+                      + TEST_COMPILATION_TIMEOUT\/1000 + \"s. Last compilation level: \" + lastCompilationLevel);\n+        checkCompilationLevel(test);\n+    }\n+\n+    private void enqueueMethodForCompilation(DeclaredTest test) {\n+        TestVM.enqueueForCompilation(test.getTestMethod(), test.getCompLevel());\n+    }\n+\n+    protected void checkCompilationLevel(DeclaredTest test) {\n+        CompLevel level = CompLevel.forValue(WHITE_BOX.getMethodCompilationLevel(test.getTestMethod()));\n+        TestRun.check(level == test.getCompLevel(),  \"Compilation level should be \" + test.getCompLevel().name()\n+                                                     + \" (requested) but was \" + level.name() + \" for \" + test.getTestMethod());\n+    }\n+\n+    final protected void waitForCompilation(DeclaredTest test) {\n+        final Method testMethod = test.getTestMethod();\n+        final boolean maybeCodeBufferOverflow = (TestVM.TEST_C1 && VERIFY_OOPS);\n+        final long started = System.currentTimeMillis();\n+        boolean stateCleared = false;\n+        long elapsed;\n+        do {\n+            elapsed = System.currentTimeMillis() - started;\n+            int level = WHITE_BOX.getMethodCompilationLevel(testMethod);\n+            if (maybeCodeBufferOverflow && elapsed > 5000\n+                && (!WHITE_BOX.isMethodCompiled(testMethod, false) || level != test.getCompLevel().getValue())) {\n+                retryDisabledVerifyOops(testMethod, stateCleared);\n+                stateCleared = true;\n+            } else {\n+                invokeTest();\n+            }\n+\n+            boolean isCompiled = WHITE_BOX.isMethodCompiled(testMethod, false);\n+            if (TestVM.VERBOSE) {\n+                System.out.println(\"Is \" + testMethod + \" compiled? \" + isCompiled);\n+            }\n+            if (isCompiled || TestVM.XCOMP || TestVM.EXCLUDE_RANDOM) {\n+                \/\/ Don't wait for compilation if -Xcomp is enabled or if we are randomly excluding methods from compilation.\n+                return;\n+            }\n+        } while (elapsed < WAIT_FOR_COMPILATION_TIMEOUT);\n+        throw new TestRunException(testMethod + \" not compiled after waiting for \"\n+                                   + WAIT_FOR_COMPILATION_TIMEOUT\/1000 + \" s\");\n+    }\n+\n+    \/**\n+     * If it takes too long, try to disable Verify Oops.\n+     *\/\n+    private void retryDisabledVerifyOops(Method testMethod, boolean stateCleared) {\n+        System.out.println(\"Temporarily disabling VerifyOops\");\n+        try {\n+            WHITE_BOX.setBooleanVMFlag(\"VerifyOops\", false);\n+            if (!stateCleared) {\n+                WHITE_BOX.clearMethodState(testMethod);\n+            }\n+            invokeTest();\n+        } finally {\n+            WHITE_BOX.setBooleanVMFlag(\"VerifyOops\", true);\n+            System.out.println(\"Re-enabled VerifyOops\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/AbstractTest.java","additions":221,"deletions":0,"binary":false,"changes":221,"status":"added"},{"patch":"@@ -0,0 +1,333 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.test;\n+\n+import compiler.lib.ir_framework.Argument;\n+import compiler.lib.ir_framework.Arguments;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+import compiler.lib.ir_framework.shared.TestFormat;\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+import jdk.test.lib.Utils;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Parameter;\n+import java.util.Random;\n+\n+\/**\n+ * This class represents an argument value specified by {@link Argument} in {@link Arguments}.\n+ *\/\n+class ArgumentValue {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    private final Object argumentValue;\n+    private final boolean isRandomEach;\n+    private final boolean isFixedRandom;\n+    private final Class<?> randomClass;\n+\n+    ArgumentValue() {\n+        this.argumentValue = null;\n+        this.isRandomEach = false;\n+        this.randomClass = null;\n+        this.isFixedRandom = false;\n+    }\n+\n+    private ArgumentValue(Object argumentValue, boolean isFixedRandom) {\n+        this.argumentValue = argumentValue;\n+        this.isRandomEach = false;\n+        this.randomClass = null;\n+        this.isFixedRandom = isFixedRandom;\n+    }\n+\n+    private ArgumentValue(Object argumentValue, Class<?> randomClass) {\n+        this.argumentValue = argumentValue;\n+        this.isRandomEach = true;\n+        this.randomClass = randomClass;\n+        this.isFixedRandom = false;\n+    }\n+\n+    \/**\n+     * Return all arguments for the @Arguments annotation.\n+     *\n+     * @param m The @Test method.\n+     * @return Returns an array with Argument objects for each specified argument in the @Arguments annotation of m.\n+     *         Returns null if method has no @Arguments annotation.\n+     *\/\n+    public static ArgumentValue[] getArguments(Method m) {\n+        Arguments argumentsAnno = m.getAnnotation(Arguments.class);\n+        if (argumentsAnno == null) {\n+            return null;\n+        }\n+        Argument[] values = argumentsAnno.value();\n+        ArgumentValue[] arguments = new ArgumentValue[values.length];\n+        Class<?>[] declaredParameters = m.getParameterTypes();\n+        Parameter[] declaredParameterObjects = m.getParameters();\n+        try {\n+            TestFormat.check(values.length == declaredParameters.length,\n+                             \"Number of argument values provided in @Arguments does not match the number \" +\n+                             \"of actual arguments in \" + m);\n+\n+            for (int i = 0; i < values.length; i++) {\n+                Argument specifiedArg = values[i];\n+                Class<?> parameter = declaredParameters[i];\n+                Parameter parameterObj = declaredParameterObjects[i];\n+                try {\n+                    switch (specifiedArg) {\n+                        case DEFAULT -> {\n+                            try {\n+                                arguments[i] = createDefault(parameter);\n+                            } catch (NoSuchMethodException e) {\n+                                TestFormat.fail(\"Cannot create new default instance of \" + parameter\n+                                                + \" for \" + m + \" due to missing default constructor\");\n+                            } catch (Exception e) {\n+                                TestFormat.fail(\"Cannot create new default instance of \" + parameter\n+                                                + \" for \" + m + \": \" + e.getCause());\n+                            }\n+                        }\n+                        case NUMBER_42 -> {\n+                            TestFormat.check(isNumber(parameter), \"Provided invalid NUMBER_42 argument \" +\n+                                                                  \"for non-number \" + parameterObj + \" for \" + m);\n+                            arguments[i] = create((byte) 42);\n+                        }\n+                        case NUMBER_MINUS_42 -> {\n+                            TestFormat.check(isNumber(parameter), \"Provided invalid NUMBER_MINUS_42 argument \" +\n+                                                                  \"for non-number \" + parameterObj + \" for \" + m);\n+                            arguments[i] = create((byte) -42);\n+                        }\n+                        case MIN -> {\n+                            TestFormat.check(isNumber(parameter) || isChar(parameter),\n+                                             \"Provided invalid MIN argument for non-number \"\n+                                             + parameterObj + \" for \" + m);\n+                            arguments[i] = createMin(parameter);\n+                        }\n+                        case MAX -> {\n+                            TestFormat.check(isNumber(parameter) || isChar(parameter),\n+                                             \"Provided invalid MAX argument for non-number \"\n+                                             + parameterObj + \" for \" + m);\n+                            arguments[i] = createMax(parameter);\n+                        }\n+                        case FALSE -> {\n+                            TestFormat.check(ArgumentValue.isBoolean(parameter),\n+                                             \"Provided invalid FALSE argument for non-boolean \"\n+                                             + parameterObj + \" for \" + m);\n+                            arguments[i] = create(false);\n+                        }\n+                        case TRUE -> {\n+                            TestFormat.check(ArgumentValue.isBoolean(parameter),\n+                                             \"Provided invalid TRUE argument for non-boolean \"\n+                                             + parameterObj + \" for \" + m);\n+                            arguments[i] = create(true);\n+                        }\n+                        case BOOLEAN_TOGGLE_FIRST_FALSE -> {\n+                            TestFormat.check(isBoolean(parameter),\n+                                             \"Provided invalid BOOLEAN_TOGGLE_FIRST_FALSE argument for non-boolean \"\n+                                             + parameterObj + \" for \" + m);\n+                            arguments[i] = BooleanToggleValue.create(false);\n+                        }\n+                        case BOOLEAN_TOGGLE_FIRST_TRUE -> {\n+                            TestFormat.check(ArgumentValue.isBoolean(parameter),\n+                                             \"Provided invalid BOOLEAN_TOGGLE_FIRST_TRUE argument for non-boolean \"\n+                                             + parameterObj + \" for \" + m);\n+                            arguments[i] = BooleanToggleValue.create(true);\n+                        }\n+                        case RANDOM_ONCE -> {\n+                            TestFormat.check(isPrimitiveType(parameter),\n+                                             \"Provided invalid RANDOM_ONCE argument for non-primitive type \"\n+                                             + parameterObj + \" for \" + m);\n+                            arguments[i] = createRandom(parameter);\n+                        }\n+                        case RANDOM_EACH -> {\n+                            TestFormat.check(isPrimitiveType(parameter),\n+                                             \"Provided invalid RANDOM_EACH argument for non-primitive type \"\n+                                             + parameterObj + \" for \" + m);\n+                            arguments[i] = createRandomEach(parameter);\n+                        }\n+                    }\n+                } catch (TestFormatException e) {\n+                    \/\/ Catch and continue to check arguments.\n+                }\n+            }\n+        } catch (TestFormatException e) {\n+            \/\/ Catch and return empty array to check for additional failures.\n+            return new ArgumentValue[0];\n+        }\n+        return arguments;\n+    }\n+\n+    private static ArgumentValue create(Object argumentValue) {\n+        return new ArgumentValue(argumentValue, false);\n+    }\n+\n+    private static ArgumentValue createDefault(Class<?> c) throws Exception {\n+        if (ArgumentValue.isNumber(c)) {\n+            return ArgumentValue.create((byte)0);\n+        } else if (ArgumentValue.isChar(c)) {\n+            return ArgumentValue.create('\\u0000');\n+        } else if (ArgumentValue.isBoolean(c)) {\n+            return ArgumentValue.create(false);\n+        } else {\n+            \/\/ Object\n+            Constructor<?> constructor = c.getDeclaredConstructor();\n+            constructor.setAccessible(true); \/\/ Make sure to have access to private default constructor\n+            return ArgumentValue.create(constructor.newInstance());\n+        }\n+    }\n+\n+    private static ArgumentValue createMin(Class<?> c) {\n+        Object argument;\n+        if (c.equals(byte.class)) {\n+            argument = Byte.MIN_VALUE;\n+        } else if (isChar(c)) {\n+            argument = Character.MIN_VALUE;\n+        }  else if (c.equals(short.class)) {\n+            argument = Short.MIN_VALUE;\n+        } else if (c.equals(int.class)) {\n+            argument = Integer.MIN_VALUE;\n+        } else if (c.equals(long.class)) {\n+            argument = Long.MIN_VALUE;\n+        } else if (c.equals(float.class)) {\n+            argument = Float.MIN_VALUE;\n+        } else if (c.equals(double.class)) {\n+            argument = Double.MIN_VALUE;\n+        } else {\n+            throw new TestFrameworkException(\"Invalid class passed to createMin()\");\n+        }\n+        return new ArgumentValue(argument, false);\n+    }\n+\n+    private static ArgumentValue createMax(Class<?> c) {\n+        Object argument;\n+        if (c.equals(byte.class)) {\n+            argument = Byte.MAX_VALUE;\n+        } else if (isChar(c)) {\n+            argument = Character.MAX_VALUE;\n+        }  else if (c.equals(short.class)) {\n+            argument = Short.MAX_VALUE;\n+        } else if (c.equals(int.class)) {\n+            argument = Integer.MAX_VALUE;\n+        } else if (c.equals(long.class)) {\n+            argument = Long.MAX_VALUE;\n+        } else if (c.equals(float.class)) {\n+            argument = Float.MAX_VALUE;\n+        } else if (c.equals(double.class)) {\n+            argument = Double.MAX_VALUE;\n+        } else {\n+            throw new TestFrameworkException(\"Invalid class passed to createMax()\");\n+        }\n+        return new ArgumentValue(argument, false);\n+    }\n+\n+    private static ArgumentValue createRandom(Class<?> c) {\n+        return new ArgumentValue(getRandom(c), true);\n+    }\n+\n+    private static ArgumentValue createRandomEach(Class<?> c) {\n+        return new ArgumentValue(null, c);\n+    }\n+\n+    public boolean isFixedRandom() {\n+        return isFixedRandom;\n+    }\n+\n+    public Object getArgument() {\n+        if (isRandomEach) {\n+            return getRandom(randomClass);\n+        } else {\n+            return argumentValue;\n+        }\n+    }\n+\n+    private static boolean isPrimitiveType(Class<?> c) {\n+        return isNumber(c) || isBoolean(c) || isChar(c);\n+    }\n+\n+    private static boolean isBoolean(Class<?> c) {\n+        return c.equals(boolean.class);\n+    }\n+\n+    private static boolean isChar(Class<?> c) {\n+        return c.equals(char.class);\n+    }\n+\n+    private static boolean isNumber(Class<?> c) {\n+        return isIntNumber(c) || isFloatNumber(c);\n+    }\n+\n+    private static boolean isIntNumber(Class<?> c) {\n+        return c.equals(byte.class)\n+                || c.equals(short.class)\n+                || c.equals(int.class)\n+                || c.equals(long.class);\n+    }\n+\n+    private static boolean isFloatNumber(Class<?> c) {\n+        return c.equals(float.class) || c.equals(double.class);\n+    }\n+\n+    private static Object getRandom(Class<?> c) {\n+        if (isBoolean(c)) {\n+            return RANDOM.nextBoolean();\n+        } else if (c.equals(byte.class)) {\n+            return (byte) RANDOM.nextInt(256);\n+        } else if (isChar(c)) {\n+            return (char) RANDOM.nextInt(65536);\n+        }  else if (c.equals(short.class)) {\n+            return (short) RANDOM.nextInt(65536);\n+        } else if (c.equals(int.class)) {\n+            return RANDOM.nextInt();\n+        } else if (c.equals(long.class)) {\n+            return RANDOM.nextLong();\n+        } else if (c.equals(float.class)) {\n+            \/\/ Get float between -10000 and 10000.\n+            return RANDOM.nextFloat() * 20000 - 10000;\n+        } else if (c.equals(double.class)) {\n+            \/\/ Get double between -10000 and 10000.\n+            return RANDOM.nextDouble() * 20000 - 10000;\n+        } else {\n+            TestFormat.fail(\"Cannot generate random value for non-primitive type\");\n+            return null;\n+        }\n+    }\n+}\n+\n+\/**\n+ * Special class to handle boolean toggle argument values.\n+ *\/\n+class BooleanToggleValue extends ArgumentValue {\n+    private boolean previousBoolean;\n+\n+    BooleanToggleValue(boolean firstBoolean) {\n+        this.previousBoolean = !firstBoolean;\n+    }\n+\n+    @Override\n+    public Object getArgument() {\n+        previousBoolean = !previousBoolean;\n+        return previousBoolean;\n+    }\n+\n+    static BooleanToggleValue create(boolean firstBoolean) {\n+        return new BooleanToggleValue(firstBoolean);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/ArgumentValue.java","additions":333,"deletions":0,"binary":false,"changes":333,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.test;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+\n+import java.lang.reflect.Method;\n+\n+\/**\n+ * A base test only consists of a single @Test method. See {@link Test} for more details and its precise definition.\n+ *\/\n+class BaseTest extends AbstractTest {\n+    private final DeclaredTest test;\n+    protected final Method testMethod;\n+    protected final TestInfo testInfo;\n+    protected final Object invocationTarget;\n+    private final boolean shouldCompile;\n+    private final boolean waitForCompilation;\n+\n+    public BaseTest(DeclaredTest test, boolean skip) {\n+        super(test.getWarmupIterations(), skip);\n+        this.test = test;\n+        this.testMethod = test.getTestMethod();\n+        this.testInfo = new TestInfo(testMethod, test.getCompLevel());\n+        this.invocationTarget = createInvocationTarget(testMethod);\n+        this.shouldCompile = shouldCompile(test);\n+        this.waitForCompilation = isWaitForCompilation(test);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Base Test: @Test \" + testMethod.getName();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return testMethod.getName();\n+    }\n+\n+    @Override\n+    protected void onStart() {\n+        test.printFixedRandomArguments();\n+    }\n+\n+    @Override\n+    public void onWarmupFinished() {\n+        testInfo.setWarmUpFinished();\n+    }\n+\n+    @Override\n+    protected void invokeTest() {\n+        verify(invokeTestMethod());\n+    }\n+\n+    private Object invokeTestMethod() {\n+        try {\n+            if (test.hasArguments()) {\n+                return testMethod.invoke(invocationTarget, test.getArguments());\n+            } else {\n+                return testMethod.invoke(invocationTarget);\n+            }\n+        } catch (Exception e) {\n+            throw new TestRunException(\"There was an error while invoking @Test method \" + testMethod\n+                                       + \". Used arguments: \" + test.getArgumentsString(), e);\n+        }\n+    }\n+\n+    @Override\n+    protected void compileTest() {\n+        if (shouldCompile) {\n+            if (waitForCompilation) {\n+                waitForCompilation(test);\n+            } else {\n+                compileMethod(test);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Verify the result\n+     *\/\n+    public void verify(Object result) { \/* no verification in BaseTests *\/ }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/BaseTest.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.test;\n+\n+import compiler.lib.ir_framework.Check;\n+import compiler.lib.ir_framework.CheckAt;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+\n+\/**\n+ * A checked test is an extension of a base test with additional verification done in a @Check method.\n+ * See {@link Check} for more details and its precise definition.\n+ *\/\n+class CheckedTest extends BaseTest {\n+    private final Method checkMethod;\n+    private final CheckAt checkAt;\n+    private final Parameter parameter;\n+    private final Object checkInvocationTarget;\n+\n+    enum Parameter {\n+        NONE, RETURN_ONLY, TEST_INFO_ONLY, BOTH\n+    }\n+\n+    public CheckedTest(DeclaredTest test, Method checkMethod, Check checkSpecification, Parameter parameter, boolean excludedByUser) {\n+        super(test, excludedByUser);\n+        \/\/ Make sure we can also call non-public or public methods in package private classes\n+        checkMethod.setAccessible(true);\n+        this.checkMethod = checkMethod;\n+        this.checkAt = checkSpecification.when();\n+        this.parameter = parameter;\n+        \/\/ Use the same invocation target\n+        if (Modifier.isStatic(checkMethod.getModifiers())) {\n+            this.checkInvocationTarget = null;\n+        } else {\n+            \/\/ Use the same invocation target as the test method if check method is non-static.\n+            this.checkInvocationTarget = this.invocationTarget != null ? this.invocationTarget : createInvocationTarget(checkMethod);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Checked Test: @Check \" + checkMethod.getName() + \" - @Test: \" + testMethod.getName();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return checkMethod.getName();\n+    }\n+\n+    @Override\n+    public void verify(Object result) {\n+        boolean shouldVerify = false;\n+        switch (checkAt) {\n+            case EACH_INVOCATION -> shouldVerify = true;\n+            case COMPILED -> shouldVerify = !testInfo.isWarmUp();\n+        }\n+        if (shouldVerify) {\n+            try {\n+                switch (parameter) {\n+                    case NONE -> checkMethod.invoke(checkInvocationTarget);\n+                    case RETURN_ONLY -> checkMethod.invoke(checkInvocationTarget, result);\n+                    case TEST_INFO_ONLY -> checkMethod.invoke(checkInvocationTarget, testInfo);\n+                    case BOTH -> checkMethod.invoke(checkInvocationTarget, result, testInfo);\n+                }\n+            } catch (Exception e) {\n+                throw new TestRunException(\"There was an error while invoking @Check method \" + checkMethod, e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/CheckedTest.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.test;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.shared.TestFormat;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import sun.hotspot.WhiteBox;\n+\n+import java.lang.reflect.Method;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * A custom run test allows the user to have full control over how the @Test method is invoked by specifying\n+ * a dedicated @Run method. See {@link Run} for more details and its precise definition.\n+ *\/\n+class CustomRunTest extends AbstractTest {\n+    private final Method runMethod;\n+    private final RunMode mode;\n+    private final Object runInvocationTarget;\n+    private final List<DeclaredTest> tests;\n+    private final RunInfo runInfo;\n+\n+    public CustomRunTest(Method runMethod, Warmup warmUpAnno, Run runSpecification, List<DeclaredTest> tests, boolean skip) {\n+        \/\/ Make sure we can also call non-public or public methods in package private classes\n+        super(warmUpAnno != null ? warmUpAnno.value() : TestVM.WARMUP_ITERATIONS, skip);\n+        TestFormat.checkNoThrow(warmupIterations >= 0, \"Cannot have negative value for @Warmup at \" + runMethod);\n+        runMethod.setAccessible(true);\n+        this.runMethod = runMethod;\n+        this.runInvocationTarget = createInvocationTarget(runMethod);\n+        this.mode = runSpecification.mode();\n+        this.tests = tests;\n+        this.runInfo = new RunInfo(tests);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String s = \"Custom Run Test: @Run: \" + runMethod.getName() + \" - @Test\";\n+        if (tests.size() == 1) {\n+            s += \": \" + tests.get(0).getTestMethod().getName();\n+        } else {\n+            s += \"s: {\" + tests.stream().map(t -> t.getTestMethod().getName())\n+                               .collect(Collectors.joining(\",\")) + \"}\";\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    String getName() {\n+        return runMethod.getName();\n+    }\n+\n+    @Override\n+    public void run() {\n+        if (skip) {\n+            return;\n+        }\n+        switch (mode) {\n+            case STANDALONE -> {\n+                runInfo.setWarmUpFinished();\n+                invokeTest();\n+            }\/\/ Invoke once but do not apply anything else.\n+            case NORMAL -> super.run();\n+        }\n+    }\n+\n+    @Override\n+    public void onWarmupFinished() {\n+        runInfo.setWarmUpFinished();\n+    }\n+\n+    @Override\n+    protected void compileTest() {\n+        if (tests.size() == 1) {\n+            compileSingleTest();\n+        } else {\n+            compileMultipleTests();\n+        }\n+    }\n+\n+    private void compileSingleTest() {\n+        DeclaredTest test = tests.get(0);\n+        if (shouldCompile(test)) {\n+            if (isWaitForCompilation(test)) {\n+                waitForCompilation(test);\n+            } else {\n+                compileMethod(test);\n+            }\n+        }\n+    }\n+\n+    private void compileMultipleTests() {\n+        boolean anyWaitForCompilation = false;\n+        boolean anyCompileMethod = false;\n+        ExecutorService executor = Executors.newFixedThreadPool(tests.size());\n+        for (DeclaredTest test : tests) {\n+            if (shouldCompile(test)) {\n+                if (isWaitForCompilation(test)) {\n+                    anyWaitForCompilation = true;\n+                    executor.execute(() -> waitForCompilation(test));\n+                } else {\n+                    anyCompileMethod = true;\n+                    executor.execute(() -> compileMethod(test));\n+                }\n+            }\n+        }\n+        executor.shutdown();\n+        int timeout;\n+        if (anyCompileMethod && anyWaitForCompilation) {\n+            timeout = Math.max(WAIT_FOR_COMPILATION_TIMEOUT, TEST_COMPILATION_TIMEOUT) + 5000;\n+        } else if (anyWaitForCompilation) {\n+            timeout = WAIT_FOR_COMPILATION_TIMEOUT + 5000;\n+        } else {\n+            timeout = TEST_COMPILATION_TIMEOUT + 5000;\n+        }\n+        try {\n+            executor.awaitTermination(timeout, TimeUnit.MILLISECONDS);\n+        } catch (InterruptedException e) {\n+            throw new TestRunException(\"Some compilations did not complete after \" + timeout\n+                                       + \"ms for @Run method \" + runMethod);\n+        }\n+    }\n+\n+    \/**\n+     * Do not directly run the test but rather the run method that is responsible for invoking the actual test.\n+     *\/\n+    @Override\n+    protected void invokeTest() {\n+        try {\n+            if (runMethod.getParameterCount() == 1) {\n+                runMethod.invoke(runInvocationTarget, runInfo);\n+            } else {\n+                runMethod.invoke(runInvocationTarget);\n+            }\n+        } catch (Exception e) {\n+            throw new TestRunException(\"There was an error while invoking @Run method \" + runMethod, e);\n+        }\n+    }\n+\n+    @Override\n+    protected void checkCompilationLevel(DeclaredTest test) {\n+        CompLevel level = CompLevel.forValue(WhiteBox.getWhiteBox().getMethodCompilationLevel(test.getTestMethod()));\n+        if (level != test.getCompLevel()) {\n+            String message = \"Compilation level should be \" + test.getCompLevel().name() + \" (requested) but was \"\n+                             + level.name() + \" for \" + test.getTestMethod() + \".\";\n+            switch (mode) {\n+                case STANDALONE -> throw new TestFrameworkException(\"Should not be called for STANDALONE method \" + runMethod);\n+                case NORMAL -> message = message + System.lineSeparator() + \"Check your @Run method \" + runMethod\n+                                         + \" to ensure that \" + test.getTestMethod()\n+                                         + \" is called at least once in each iteration.\";\n+            }\n+            throw new TestRunException(message);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/CustomRunTest.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.test;\n+\n+import compiler.lib.ir_framework.CompLevel;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+\n+\/**\n+ * This class represents a @Test method.\n+ *\/\n+public class DeclaredTest {\n+    private final Method testMethod;\n+    private final ArgumentValue[] arguments;\n+    private final int warmupIterations;\n+    private final CompLevel compLevel;\n+    private Method attachedMethod;\n+\n+    public DeclaredTest(Method testMethod, ArgumentValue[] arguments, CompLevel compLevel, int warmupIterations) {\n+        \/\/ Make sure we can also call non-public or public methods in package private classes\n+        testMethod.setAccessible(true);\n+        this.testMethod = testMethod;\n+        this.compLevel = compLevel;\n+        this.arguments = arguments;\n+        this.warmupIterations = warmupIterations;\n+        this.attachedMethod = null;\n+    }\n+\n+    public Method getTestMethod() {\n+        return testMethod;\n+    }\n+\n+    public CompLevel getCompLevel() {\n+        return compLevel;\n+    }\n+\n+    public int getWarmupIterations() {\n+        return warmupIterations;\n+    }\n+\n+    public boolean hasArguments() {\n+        return arguments != null;\n+    }\n+\n+    public Object[] getArguments() {\n+        return Arrays.stream(arguments).map(ArgumentValue::getArgument).toArray();\n+    }\n+\n+    public void setAttachedMethod(Method m) {\n+        attachedMethod = m;\n+    }\n+\n+    public Method getAttachedMethod() {\n+        return attachedMethod;\n+    }\n+\n+    public void printFixedRandomArguments() {\n+        if (hasArguments()) {\n+            boolean hasRandomArgs = false;\n+            StringBuilder builder = new StringBuilder(\"Fixed random arguments for method \").append(testMethod).append(\": \");\n+            for (int i = 0; i < arguments.length; i++) {\n+                ArgumentValue argument = arguments[i];\n+                if (argument.isFixedRandom()) {\n+                    hasRandomArgs = true;\n+                    Object argumentVal = argument.getArgument();\n+                    builder.append(\"arg \").append(i).append(\": \").append(argumentVal.toString());\n+                    if (argumentVal instanceof Character) {\n+                        builder.append(\" (\").append((int)(Character)argumentVal).append(\")\");\n+                    }\n+                    builder.append(\", \");\n+                }\n+            }\n+            if (hasRandomArgs) {\n+                \/\/ Drop the last comma and space.\n+                builder.setLength(builder.length() - 2);\n+                System.out.println(builder.toString());\n+            }\n+        }\n+    }\n+\n+    public String getArgumentsString() {\n+        if (hasArguments()) {\n+            StringBuilder builder = new StringBuilder();\n+            for (int i = 0; i < arguments.length; i++) {\n+                builder.append(\"arg \").append(i).append(\": \").append(arguments[i].getArgument()).append(\", \");\n+            }\n+            builder.setLength(builder.length() - 2);\n+            return builder.toString();\n+        } else {\n+            return \"<void>\";\n+        }\n+    }\n+\n+    public Object invoke(Object obj, Object... args) {\n+        try {\n+            return testMethod.invoke(obj, args);\n+        } catch (Exception e) {\n+            throw new TestRunException(\"There was an error while invoking @Test method \" + testMethod, e);\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/DeclaredTest.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,290 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.test;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.shared.*;\n+import sun.hotspot.WhiteBox;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+\/**\n+ * Prints an encoding to the dedicated test framework socket whether @IR rules of @Test methods should be applied or not.\n+ * This is done during the execution of the test VM by checking the active VM flags. This encoding is eventually parsed\n+ * and checked by the IRMatcher class in the driver VM after the termination of the test VM.\n+ *\/\n+public class IREncodingPrinter {\n+    public static final String START = \"##### IRMatchRulesEncoding - used by TestFramework #####\";\n+    public static final String END = \"----- END -----\";\n+    public static final int NO_RULE_APPLIED = -1;\n+\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    private static final List<Function<String, Object>> LONG_GETTERS = Arrays.asList(\n+            WHITE_BOX::getIntVMFlag, WHITE_BOX::getUintVMFlag, WHITE_BOX::getIntxVMFlag,\n+            WHITE_BOX::getUintxVMFlag, WHITE_BOX::getUint64VMFlag, WHITE_BOX::getSizeTVMFlag);\n+\n+    private final StringBuilder output = new StringBuilder();\n+    private Method method;\n+    private int ruleIndex;\n+\n+    public IREncodingPrinter() {\n+        output.append(START).append(System.lineSeparator());\n+        output.append(\"<method>,{comma separated applied @IR rule ids}\").append(System.lineSeparator());\n+    }\n+\n+    \/**\n+     * Emits \"<method>,{ids}\" where {ids} is either:\n+     * - indices of all @IR rules that should be applied, separated by a comma\n+     * - \"-1\" if no @IR rule should not be applied\n+     *\/\n+    public void emitRuleEncoding(Method m, boolean skipped) {\n+        method = m;\n+        int i = 0;\n+        ArrayList<Integer> validRules = new ArrayList<>();\n+        IR[] irAnnos = m.getAnnotationsByType(IR.class);\n+        if (!skipped) {\n+            for (IR irAnno : irAnnos) {\n+                ruleIndex = i + 1;\n+                try {\n+                    if (shouldApplyIrRule(irAnno)) {\n+                        validRules.add(i);\n+                    }\n+                } catch (TestFormatException e) {\n+                    \/\/ Catch logged failure and continue to check other IR annotations.\n+                }\n+                i++;\n+            }\n+        }\n+        if (irAnnos.length != 0) {\n+            output.append(m.getName());\n+            if (validRules.isEmpty()) {\n+                output.append(\",\" + NO_RULE_APPLIED);\n+            } else {\n+                for (i = 0; i < validRules.size(); i++) {\n+                    output.append(\",\").append(validRules.get(i));\n+                }\n+            }\n+            output.append(System.lineSeparator());\n+        }\n+    }\n+\n+    private boolean shouldApplyIrRule(IR irAnno) {\n+        checkIRAnnotations(irAnno);\n+        if (irAnno.applyIf().length != 0) {\n+            return hasAllRequiredFlags(irAnno.applyIf(), \"applyIf\");\n+        }\n+\n+        if (irAnno.applyIfNot().length != 0) {\n+            return hasNoRequiredFlags(irAnno.applyIfNot(), \"applyIfNot\");\n+        }\n+\n+        if (irAnno.applyIfAnd().length != 0) {\n+            return hasAllRequiredFlags(irAnno.applyIfAnd(), \"applyIfAnd\");\n+        }\n+\n+        if (irAnno.applyIfOr().length != 0) {\n+            return !hasNoRequiredFlags(irAnno.applyIfOr(), \"applyIfOr\");\n+        }\n+        \/\/ No conditions, always apply.\n+        return true;\n+    }\n+\n+    private void checkIRAnnotations(IR irAnno) {\n+        TestFormat.checkNoThrow(irAnno.counts().length != 0 || irAnno.failOn().length != 0,\n+                                \"Must specify either counts or failOn constraint\" + failAt());\n+        int applyRules = 0;\n+        if (irAnno.applyIfAnd().length != 0) {\n+            applyRules++;\n+            TestFormat.checkNoThrow(irAnno.applyIfAnd().length > 2,\n+                                    \"Use applyIf or applyIfNot or at least 2 conditions for applyIfAnd\" + failAt());\n+        }\n+        if (irAnno.applyIfOr().length != 0) {\n+            applyRules++;\n+            TestFormat.checkNoThrow(irAnno.applyIfOr().length > 2,\n+                                    \"Use applyIf or applyIfNot or at least 2 conditions for applyIfOr\" + failAt());\n+        }\n+        if (irAnno.applyIf().length != 0) {\n+            applyRules++;\n+            TestFormat.checkNoThrow(irAnno.applyIf().length <= 2,\n+                                    \"Use applyIfAnd or applyIfOr or only 1 condition for applyIf\" + failAt());\n+        }\n+        if (irAnno.applyIfNot().length != 0) {\n+            applyRules++;\n+            TestFormat.checkNoThrow(irAnno.applyIfNot().length <= 2,\n+                                    \"Use applyIfAnd or applyIfOr or only 1 condition for applyIfNot\" + failAt());\n+        }\n+        TestFormat.checkNoThrow(applyRules <= 1,\n+                                \"Can only specify one apply constraint \" + failAt());\n+\n+    }\n+\n+    private boolean hasAllRequiredFlags(String[] andRules, String ruleType) {\n+        boolean returnValue = true;\n+        for (int i = 0; i < andRules.length; i++) {\n+            String flag = andRules[i].trim();\n+            i++;\n+            TestFormat.check(i < andRules.length, \"Missing value for flag \" + flag + \" in \" + ruleType + failAt());\n+            String value = andRules[i].trim();\n+            if (!check(flag, value) && returnValue) {\n+                \/\/ Rule will not be applied but keep processing the other flags to verify that they are sane.\n+                returnValue = false;\n+            }\n+        }\n+        return returnValue;\n+    }\n+\n+    private boolean hasNoRequiredFlags(String[] orRules, String ruleType) {\n+        boolean returnValue = true;\n+        for (int i = 0; i < orRules.length; i++) {\n+            String flag = orRules[i];\n+            i++;\n+            TestFormat.check(i < orRules.length, \"Missing value for flag \" + flag + \" in \" + ruleType + failAt());\n+            String value = orRules[i];\n+            if (check(flag, value) && returnValue) {\n+                \/\/ Rule will not be applied but keep processing the other flags to verify that they are sane.\n+                returnValue = false;\n+            }\n+        }\n+        return returnValue;\n+    }\n+\n+    private boolean check(String flag, String value) {\n+        if (flag.isEmpty()) {\n+            TestFormat.failNoThrow(\"Provided empty flag\" + failAt());\n+            return false;\n+        }\n+        if (value.isEmpty()) {\n+            TestFormat.failNoThrow(\"Provided empty value for flag \" + flag + failAt());\n+            return false;\n+        }\n+        Object actualFlagValue = WHITE_BOX.getBooleanVMFlag(flag);\n+        if (actualFlagValue != null) {\n+            return checkBooleanFlag(flag, value, (Boolean) actualFlagValue);\n+        }\n+        actualFlagValue = LONG_GETTERS.stream().map(f -> f.apply(flag)).filter(Objects::nonNull).findAny().orElse(null);\n+        if (actualFlagValue != null) {\n+            return checkLongFlag(flag, value, (Long) actualFlagValue);\n+        }\n+        actualFlagValue = WHITE_BOX.getDoubleVMFlag(flag);\n+        if (actualFlagValue != null) {\n+            return checkDoubleFlag(flag, value, (Double) actualFlagValue);\n+        }\n+        actualFlagValue = WHITE_BOX.getStringVMFlag(flag);\n+        if (actualFlagValue != null) {\n+            return value.equals(actualFlagValue);\n+        }\n+\n+        \/\/ This could be improved if the Whitebox offers a \"isVMFlag\" function. For now, just check if we can actually set\n+        \/\/ a value for a string flag. If we find this value, it's a string flag. If null is returned, the flag is unknown.\n+        WHITE_BOX.setStringVMFlag(flag, \"test\");\n+        String stringFlagValue = WHITE_BOX.getStringVMFlag(flag);\n+        if (stringFlagValue == null) {\n+            TestFormat.failNoThrow(\"Could not find VM flag \\\"\" + flag + \"\\\"\" + failAt());\n+            return false;\n+        }\n+        TestFramework.check(stringFlagValue.equals(\"test\"),\n+                         \"Must find newly set flag value \\\"test\\\" but found \" + failAt());\n+        WHITE_BOX.setStringVMFlag(flag, null); \/\/ reset flag to NULL\n+        return false;\n+    }\n+\n+    private boolean checkBooleanFlag(String flag, String value, boolean actualFlagValue) {\n+        boolean booleanValue = false;\n+        if (\"true\".equalsIgnoreCase(value)) {\n+            booleanValue = true;\n+        } else if (!\"false\".equalsIgnoreCase(value)) {\n+            TestFormat.failNoThrow(\"Invalid value \\\"\" + value + \"\\\" for boolean flag \" + flag + failAt());\n+            return false;\n+        }\n+        return booleanValue == actualFlagValue;\n+    }\n+\n+    private boolean checkLongFlag(String flag, String value, long actualFlagValue) {\n+        long longValue;\n+        ParsedComparator<Long> parsedComparator;\n+        try {\n+            parsedComparator = ParsedComparator.parseComparator(value);\n+        } catch (CheckedTestFrameworkException e) {\n+            TestFormat.failNoThrow(\"Invalid comparator in \\\"\" + value + \"\\\" for integer based flag \" + flag + failAt());\n+            return false;\n+        }  catch (IndexOutOfBoundsException e) {\n+            TestFormat.failNoThrow(\"Provided empty value for integer based flag \" + flag + failAt());\n+            return false;\n+        }\n+        try {\n+            longValue = Long.parseLong(parsedComparator.getStrippedString());\n+        } catch (NumberFormatException e) {\n+            String comparator = parsedComparator.getComparator();\n+            if (!comparator.isEmpty()) {\n+                comparator = \"after comparator \\\"\" + parsedComparator.getComparator() + \"\\\"\";\n+            }\n+            TestFormat.failNoThrow(\"Invalid value \\\"\" + parsedComparator.getStrippedString() + \"\\\" \"\n+                            + comparator + \" for integer based flag \" + flag + failAt());\n+            return false;\n+        }\n+        return parsedComparator.getPredicate().test(actualFlagValue, longValue);\n+    }\n+\n+    private boolean checkDoubleFlag(String flag, String value, double actualFlagValue) {\n+        double doubleValue;\n+        ParsedComparator<Double> parsedComparator;\n+        try {\n+            parsedComparator = ParsedComparator.parseComparator(value);\n+        } catch (CheckedTestFrameworkException e) {\n+            TestFormat.failNoThrow(\"Invalid comparator in \\\"\" + value + \"\\\" for floating point based flag \" + flag + failAt());\n+            return false;\n+        } catch (IndexOutOfBoundsException e) {\n+            TestFormat.failNoThrow(\"Provided empty value for floating point based flag \" + flag + failAt());\n+            return false;\n+        }\n+        try {\n+            doubleValue = Double.parseDouble(parsedComparator.getStrippedString());\n+        } catch (NumberFormatException e) {\n+            String comparator = parsedComparator.getComparator();\n+            if (!comparator.isEmpty()) {\n+                comparator = \"after comparator \\\"\" + parsedComparator.getComparator() + \"\\\"\";\n+            }\n+            TestFormat.failNoThrow(\"Invalid value \\\"\" + parsedComparator.getStrippedString() + \"\\\" \"\n+                    + comparator + \" for floating point based flag \" + flag + failAt());\n+            return false;\n+        }\n+        return parsedComparator.getPredicate().test(actualFlagValue, doubleValue);\n+    }\n+\n+    private String failAt() {\n+        return \" for @IR rule \" + ruleIndex + \" at \" + method;\n+    }\n+\n+    public void emit() {\n+        output.append(END);\n+        TestFrameworkSocket.write(output.toString(), \"IR rule application encoding\");\n+    }\n+}\n+\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":290,"deletions":0,"binary":false,"changes":290,"status":"added"},{"patch":"@@ -0,0 +1,955 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.test;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.Compiler;\n+import compiler.lib.ir_framework.shared.*;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import sun.hotspot.WhiteBox;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * This class' main method is called from {@link TestFramework} and represents the so-called \"test VM\". The class is\n+ * the heart of the framework and is responsible for executing all the specified tests in the test class. It uses the\n+ * Whitebox API and reflection to achieve this task.\n+ *\/\n+public class TestVM {\n+    private static final WhiteBox WHITE_BOX;\n+\n+    static {\n+        try {\n+            WHITE_BOX = WhiteBox.getWhiteBox();\n+        } catch (UnsatisfiedLinkError e) {\n+            System.err.println(System.lineSeparator() + \"\"\"\n+                               ##########################################################\n+                                - Did you call a test-related interface method from\n+                                  TestFramework in main() of your test? Make sure to\n+                                  only call setup\/run methods and no checks or\n+                                  assertions from main() of your test!\n+                                - Are you rerunning the test VM (TestVM class)\n+                                  directly after a JTreg run? Make sure to start it\n+                                  from within JTwork\/scratch and with the flag\n+                                  -DReproduce=true!\n+                               ##########################################################\n+                               \"\"\");\n+            throw e;\n+        }\n+    }\n+\n+    \/**\n+     * The default number of warm-up iterations used to warm up a {@link Test} annotated test method.\n+     * Use {@code -DWarmup=XY} to specify a different default value. An individual warm-up can also be\n+     * set by specifying a {@link Warmup} iteration for a test.\n+     *\/\n+    public static final int WARMUP_ITERATIONS = Integer.parseInt(System.getProperty(\"Warmup\", \"2000\"));\n+\n+    private static final boolean TIERED_COMPILATION = (Boolean)WHITE_BOX.getVMFlag(\"TieredCompilation\");\n+    private static final CompLevel TIERED_COMPILATION_STOP_AT_LEVEL = CompLevel.forValue(((Long)WHITE_BOX.getVMFlag(\"TieredStopAtLevel\")).intValue());\n+    public static final boolean TEST_C1 = TIERED_COMPILATION && TIERED_COMPILATION_STOP_AT_LEVEL.getValue() < CompLevel.C2.getValue();\n+\n+    static final boolean XCOMP = Platform.isComp();\n+    static final boolean VERBOSE = Boolean.getBoolean(\"Verbose\");\n+    private static final boolean PRINT_TIMES = Boolean.getBoolean(\"PrintTimes\");\n+    public static final boolean USE_COMPILER = WHITE_BOX.getBooleanVMFlag(\"UseCompiler\");\n+    static final boolean EXCLUDE_RANDOM = Boolean.getBoolean(\"ExcludeRandom\");\n+    private static final String TESTLIST = System.getProperty(\"Test\", \"\");\n+    private static final String EXCLUDELIST = System.getProperty(\"Exclude\", \"\");\n+    private static final boolean DUMP_REPLAY = Boolean.getBoolean(\"DumpReplay\");\n+    private static final boolean GC_AFTER = Boolean.getBoolean(\"GCAfter\");\n+    private static final boolean SHUFFLE_TESTS = Boolean.parseBoolean(System.getProperty(\"ShuffleTests\", \"true\"));\n+    \/\/ Use separate flag as VERIFY_IR could have been set by user but due to other flags it was disabled by flag VM.\n+    private static final boolean PRINT_VALID_IR_RULES = Boolean.getBoolean(\"ShouldDoIRVerification\");\n+    protected static final long PER_METHOD_TRAP_LIMIT = (Long)WHITE_BOX.getVMFlag(\"PerMethodTrapLimit\");\n+    protected static final boolean PROFILE_INTERPRETER = (Boolean)WHITE_BOX.getVMFlag(\"ProfileInterpreter\");\n+    private static final boolean FLIP_C1_C2 = Boolean.getBoolean(\"FlipC1C2\");\n+    private static final boolean IGNORE_COMPILER_CONTROLS = Boolean.getBoolean(\"IgnoreCompilerControls\");\n+\n+    private final HashMap<Method, DeclaredTest> declaredTests = new HashMap<>();\n+    private final List<AbstractTest> allTests = new ArrayList<>();\n+    private final HashMap<String, Method> testMethodMap = new HashMap<>();\n+    private final List<String> excludeList;\n+    private final List<String> testList;\n+    private Set<Class<?>> helperClasses = null; \/\/ Helper classes that contain framework annotations to be processed.\n+    private final IREncodingPrinter irMatchRulePrinter;\n+    private final Class<?> testClass;\n+    private final Map<Executable, CompLevel> forceCompileMap = new HashMap<>();\n+\n+    private TestVM(Class<?> testClass) {\n+        TestRun.check(testClass != null, \"Test class cannot be null\");\n+        this.testClass = testClass;\n+        this.testList = createTestFilterList(TESTLIST, testClass);\n+        this.excludeList = createTestFilterList(EXCLUDELIST, testClass);\n+\n+        if (PRINT_VALID_IR_RULES) {\n+            irMatchRulePrinter = new IREncodingPrinter();\n+        } else {\n+            irMatchRulePrinter = null;\n+        }\n+    }\n+\n+    \/**\n+     * Parse \"test1,test2,test3\" into a list.\n+     *\/\n+    private static List<String> createTestFilterList(String list, Class<?> testClass) {\n+        List<String> filterList = null;\n+        if (!list.isEmpty()) {\n+            String classPrefix = testClass.getSimpleName() + \".\";\n+            filterList = new ArrayList<>(Arrays.asList(list.split(\",\")));\n+            for (int i = filterList.size() - 1; i >= 0; i--) {\n+                String test = filterList.get(i);\n+                if (test.indexOf(\".\") > 0) {\n+                    if (test.startsWith(classPrefix)) {\n+                        test = test.substring(classPrefix.length());\n+                        filterList.set(i, test);\n+                    } else {\n+                        filterList.remove(i);\n+                    }\n+                }\n+            }\n+        }\n+        return filterList;\n+    }\n+\n+    \/**\n+     * Main entry point of the test VM.\n+     *\/\n+    public static void main(String[] args) {\n+        try {\n+            String testClassName = args[0];\n+            System.out.println(\"TestVM main() called - about to run tests in class \" + testClassName);\n+            Class<?> testClass = getClassObject(testClassName, \"test\");\n+\n+            TestVM framework = new TestVM(testClass);\n+            framework.addHelperClasses(args);\n+            framework.start();\n+        } finally {\n+            TestFrameworkSocket.closeClientSocket();\n+        }\n+    }\n+\n+    protected static Class<?> getClassObject(String className, String classType) {\n+        try {\n+            return Class.forName(className);\n+        } catch (Exception e) {\n+            throw new TestRunException(\"Could not find \" + classType + \" class\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Set up all helper classes and verify they are specified correctly.\n+     *\/\n+    private void addHelperClasses(String[] args) {\n+        Class<?>[] helperClassesList = getHelperClasses(args);\n+        if (helperClassesList != null) {\n+            TestRun.check(Arrays.stream(helperClassesList).noneMatch(Objects::isNull), \"A Helper class cannot be null\");\n+            this.helperClasses = new HashSet<>();\n+\n+            for (Class<?> helperClass : helperClassesList) {\n+                if (Arrays.stream(testClass.getDeclaredClasses()).anyMatch(c -> c == helperClass)) {\n+                    \/\/ Nested class of test class is automatically treated as helper class\n+                    TestFormat.failNoThrow(\"Nested \" + helperClass + \" inside test \" + testClass + \" is implicitly\"\n+                                           + \" treated as helper class and does not need to be specified as such.\");\n+                    continue;\n+                }\n+                TestRun.check(!this.helperClasses.contains(helperClass), \"Cannot add the same class twice: \" + helperClass);\n+                this.helperClasses.add(helperClass);\n+            }\n+        }\n+    }\n+\n+    private static Class<?>[] getHelperClasses(String[] args) {\n+        if (args.length == 1) {\n+            return null;\n+        }\n+        Class<?>[] helperClasses = new Class<?>[args.length - 1]; \/\/ First argument is test class\n+        for (int i = 1; i < args.length; i++) {\n+            String helperClassName = args[i];\n+            helperClasses[i - 1] = getClassObject(helperClassName, \"helper\");\n+        }\n+        return helperClasses;\n+    }\n+\n+    private void checkHelperClass(Class<?> clazz) {\n+        checkAnnotationsInClass(clazz, \"helper\");\n+        for (Class<?> c : clazz.getDeclaredClasses()) {\n+            checkAnnotationsInClass(c, \"nested (and helper)\");\n+        }\n+    }\n+\n+    private void checkAnnotationsInClass(Class<?> c, String clazzType) {\n+        Method[] methods = c.getDeclaredMethods();\n+        for (Method m : methods) {\n+            TestFormat.checkNoThrow(getAnnotation(m, Test.class) == null,\n+                                    \"Cannot use @Test annotation in \" + clazzType + \" \" + c + \" at \" + m);\n+            TestFormat.checkNoThrow(getAnnotation(m, Run.class) == null,\n+                                    \"Cannot use @Run annotation in \" + clazzType + \" \" + c + \" at \" + m);\n+            TestFormat.checkNoThrow(getAnnotation(m, Check.class) == null,\n+                                    \"Cannot use @Check annotation in \" + clazzType + \" \" + c + \" at \" + m);\n+        }\n+    }\n+\n+    \/**\n+     * Only called by internal tests testing the framework itself. Accessed by reflection. Not exposed to normal users.\n+     *\/\n+    private static void runTestsOnSameVM(Class<?> testClass) {\n+        if (testClass == null) {\n+            StackWalker walker = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n+            testClass = walker.getCallerClass();\n+        }\n+        TestVM framework = new TestVM(testClass);\n+        framework.start();\n+    }\n+\n+    \/**\n+     * Once everything is initialized and set up, start collecting tests and executing them afterwards.\n+     *\/\n+    private void start() {\n+        setupTests();\n+        checkForcedCompilationsCompleted();\n+        runTests();\n+    }\n+\n+    private void setupTests() {\n+        for (Class<?> clazz : testClass.getDeclaredClasses()) {\n+            checkAnnotationsInClass(clazz, \"inner\");\n+        }\n+        if (DUMP_REPLAY) {\n+            addReplay();\n+        }\n+        \/\/ Make sure to first setup test methods and make them non-inlineable and only then process compile commands.\n+        setupDeclaredTests();\n+        processControlAnnotations(testClass);\n+        processHelperClasses();\n+        setupCheckedAndCustomRunTests();\n+\n+        \/\/ All remaining tests are simple base tests without check or specific way to run them.\n+        addBaseTests();\n+        if (PRINT_VALID_IR_RULES) {\n+            irMatchRulePrinter.emit();\n+        }\n+        TestFormat.reportIfAnyFailures();\n+        declaredTests.clear();\n+        testMethodMap.clear();\n+    }\n+\n+    private void addBaseTests() {\n+        declaredTests.forEach((m, test) -> {\n+            if (test.getAttachedMethod() == null) {\n+                try {\n+                    Arguments argumentsAnno = getAnnotation(m, Arguments.class);\n+                    TestFormat.check(argumentsAnno != null || m.getParameterCount() == 0, \"Missing @Arguments annotation to define arguments of \" + m);\n+                    BaseTest baseTest = new BaseTest(test, shouldExcludeTest(m.getName()));\n+                    allTests.add(baseTest);\n+                    if (PRINT_VALID_IR_RULES) {\n+                       irMatchRulePrinter.emitRuleEncoding(m, baseTest.isSkipped());\n+                    }\n+                } catch (TestFormatException e) {\n+                    \/\/ Failure logged. Continue and report later.\n+                }\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Check if user wants to exclude this test by checking the -DTest and -DExclude lists.\n+     *\/\n+    private boolean shouldExcludeTest(String testName) {\n+        boolean hasTestList = testList != null;\n+        boolean hasExcludeList = excludeList != null;\n+        if (hasTestList) {\n+            return !testList.contains(testName) || (hasExcludeList && excludeList.contains(testName));\n+        } else if (hasExcludeList) {\n+            return excludeList.contains(testName);\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Generate replay compilation files.\n+     *\/\n+    private void addReplay() {\n+        String directive = \"[{ match: \\\"*.*\\\", DumpReplay: true }]\";\n+        TestFramework.check(WHITE_BOX.addCompilerDirective(directive) == 1, \"Failed to add DUMP_REPLAY directive\");\n+    }\n+\n+    private void processControlAnnotations(Class<?> clazz) {\n+        if (IGNORE_COMPILER_CONTROLS) {\n+            return;\n+        }\n+        \/\/ Also apply compile commands to all inner classes of 'clazz'.\n+        ArrayList<Class<?>> classes = new ArrayList<>(Arrays.asList(clazz.getDeclaredClasses()));\n+        classes.add(clazz);\n+        for (Class<?> c : classes) {\n+            applyClassAnnotations(c);\n+            List<Executable> executables = new ArrayList<>(Arrays.asList(c.getDeclaredMethods()));\n+            Collections.addAll(executables, c.getDeclaredConstructors());\n+            for (Executable ex : executables) {\n+                checkClassAnnotations(ex);\n+                try {\n+                    applyIndependentCompilationCommands(ex);\n+                } catch (TestFormatException e) {\n+                    \/\/ Failure logged. Continue and report later.\n+                }\n+            }\n+\n+            \/\/ Only force compilation now because above annotations affect inlining\n+            for (Executable ex : executables) {\n+                try {\n+                    applyForceCompileCommand(ex);\n+                } catch (TestFormatException e) {\n+                    \/\/ Failure logged. Continue and report later.\n+                }\n+            }\n+        }\n+    }\n+\n+    private void applyClassAnnotations(Class<?> c) {\n+        ForceCompileClassInitializer anno = getAnnotation(c, ForceCompileClassInitializer.class);\n+        if (anno == null) {\n+            return;\n+        }\n+\n+        \/\/ Compile class initializer\n+        CompLevel level = anno.value();\n+        if (level == CompLevel.SKIP || level == CompLevel.WAIT_FOR_COMPILATION) {\n+            TestFormat.failNoThrow(\"Cannot define compilation level SKIP or WAIT_FOR_COMPILATION in \" +\n+                                   \"@ForceCompileClassInitializer at \" + c);\n+            return;\n+        }\n+        level = restrictCompLevel(anno.value());\n+        if (level != CompLevel.SKIP) {\n+            \/\/ Make sure class is initialized to avoid compilation bailout of <clinit>\n+            getClassObject(c.getName(), \"nested\"); \/\/ calls Class.forName() to initialize 'c'\n+            TestFormat.checkNoThrow(WHITE_BOX.enqueueInitializerForCompilation(c, level.getValue()),\n+                                    \"Failed to enqueue <clinit> of \" + c + \" for compilation. Did you specify \"\n+                                    + \"@ForceCompileClassInitializer without providing a static class initialization? \"\n+                                    + \"Make sure to provide any form of static initialization or remove the annotation.\");\n+        }\n+    }\n+\n+    private void checkClassAnnotations(Executable ex) {\n+        TestFormat.checkNoThrow(getAnnotation(ex, ForceCompileClassInitializer.class) == null,\n+                                \"@ForceCompileClassInitializer only allowed at classes but not at method \" + ex);\n+    }\n+\n+    \/**\n+     * Exclude a method from compilation with a compiler randomly. Return the compiler for which the method was made\n+     * not compilable.\n+     *\/\n+    public static Compiler excludeRandomly(Executable ex) {\n+        Compiler compiler = switch (Utils.getRandomInstance().nextInt() % 3) {\n+            case 1 -> Compiler.C1;\n+            case 2 -> Compiler.C2;\n+            default -> Compiler.ANY;\n+        };\n+        WHITE_BOX.makeMethodNotCompilable(ex, compiler.getValue(), false);\n+        WHITE_BOX.makeMethodNotCompilable(ex, compiler.getValue(), true);\n+        System.out.println(\"Excluding from \" + compiler.name() + \" compilation: \" + ex);\n+        return compiler;\n+    }\n+\n+    private void applyIndependentCompilationCommands(Executable ex) {\n+        ForceInline forceInlineAnno = getAnnotation(ex, ForceInline.class);\n+        DontInline dontInlineAnno = getAnnotation(ex, DontInline.class);\n+        ForceCompile forceCompileAnno = getAnnotation(ex, ForceCompile.class);\n+        DontCompile dontCompileAnno = getAnnotation(ex, DontCompile.class);\n+        checkCompilationCommandAnnotations(ex, forceInlineAnno, dontInlineAnno, forceCompileAnno, dontCompileAnno);\n+        \/\/ First handle inline annotations\n+        if (dontInlineAnno != null) {\n+            WHITE_BOX.testSetDontInlineMethod(ex, true);\n+        } else if (forceInlineAnno != null) {\n+            WHITE_BOX.testSetForceInlineMethod(ex, true);\n+        }\n+        if (dontCompileAnno != null) {\n+            dontCompileWithCompiler(ex, dontCompileAnno.value());\n+        }\n+        if (EXCLUDE_RANDOM && getAnnotation(ex, Test.class) == null && forceCompileAnno == null && dontCompileAnno == null) {\n+            \/\/ Randomly exclude helper methods from compilation\n+            if (Utils.getRandomInstance().nextBoolean()) {\n+                excludeRandomly(ex);\n+            }\n+        }\n+    }\n+\n+    private void checkCompilationCommandAnnotations(Executable ex, ForceInline forceInlineAnno, DontInline dontInlineAnno, ForceCompile forceCompileAnno, DontCompile dontCompileAnno) {\n+        Test testAnno = getAnnotation(ex, Test.class);\n+        Run runAnno = getAnnotation(ex, Run.class);\n+        Check checkAnno = getAnnotation(ex, Check.class);\n+        TestFormat.check((testAnno == null && runAnno == null && checkAnno == null) || Stream.of(forceCompileAnno, dontCompileAnno, forceInlineAnno, dontInlineAnno).noneMatch(Objects::nonNull),\n+                         \"Cannot use explicit compile command annotations (@ForceInline, @DontInline, \" +\n+                         \"@ForceCompile or @DontCompile) together with @Test, @Check or @Run: \" + ex + \". Use compLevel in @Test for fine tuning.\");\n+        if (Stream.of(forceInlineAnno, dontCompileAnno, dontInlineAnno).filter(Objects::nonNull).count() > 1) {\n+            \/\/ Failure\n+            TestFormat.check(dontCompileAnno == null || dontInlineAnno == null,\n+                             \"@DontInline is implicitely done with @DontCompile annotation at \" + ex);\n+            TestFormat.fail(\"Cannot mix @ForceInline, @DontInline and @DontCompile at the same time at \" + ex);\n+        }\n+        TestFormat.check(forceInlineAnno == null || dontInlineAnno == null, \"Cannot have @ForceInline and @DontInline at the same time at \" + ex);\n+        if (forceCompileAnno != null && dontCompileAnno != null) {\n+            CompLevel forceCompileLevel = forceCompileAnno.value();\n+            Compiler dontCompileCompiler = dontCompileAnno.value();\n+            TestFormat.check(dontCompileCompiler != Compiler.ANY,\n+                             \"Cannot have @DontCompile(Compiler.ANY) and @ForceCompile at the same time at \" + ex);\n+            TestFormat.check(forceCompileLevel != CompLevel.ANY,\n+                             \"Cannot have @ForceCompile(CompLevel.ANY) and @DontCompile at the same time at \" + ex);\n+            TestFormat.check(forceCompileLevel.isNotCompilationLevelOfCompiler(dontCompileCompiler),\n+                             \"Overlapping compilation level and compiler with @ForceCompile and @DontCompile at \" + ex);\n+        }\n+    }\n+\n+    \/**\n+     * Exlude the method from compilation and make sure it is not inlined.\n+     *\/\n+    private void dontCompileAndDontInlineMethod(Method m) {\n+        if (!IGNORE_COMPILER_CONTROLS) {\n+            WHITE_BOX.makeMethodNotCompilable(m, CompLevel.ANY.getValue(), true);\n+            WHITE_BOX.makeMethodNotCompilable(m, CompLevel.ANY.getValue(), false);\n+            WHITE_BOX.testSetDontInlineMethod(m, true);\n+        }\n+    }\n+\n+    private void dontCompileWithCompiler(Executable ex, Compiler compiler) {\n+        if (VERBOSE) {\n+            System.out.println(\"dontCompileWithCompiler \" + ex + \" , compiler = \" + compiler.name());\n+        }\n+        WHITE_BOX.makeMethodNotCompilable(ex, compiler.getValue(), true);\n+        WHITE_BOX.makeMethodNotCompilable(ex, compiler.getValue(), false);\n+        if (compiler == Compiler.ANY) {\n+            WHITE_BOX.testSetDontInlineMethod(ex, true);\n+        }\n+    }\n+\n+    private void applyForceCompileCommand(Executable ex) {\n+        ForceCompile forceCompileAnno = getAnnotation(ex, ForceCompile.class);\n+        if (forceCompileAnno != null) {\n+            CompLevel complevel = forceCompileAnno.value();\n+            TestFormat.check(complevel != CompLevel.SKIP && complevel != CompLevel.WAIT_FOR_COMPILATION,\n+                             \"Cannot define compilation level SKIP or WAIT_FOR_COMPILATION in @ForceCompile at \" + ex);\n+            complevel = restrictCompLevel(forceCompileAnno.value());\n+            if (FLIP_C1_C2) {\n+                complevel = complevel.flipCompLevel();\n+            }\n+            if (EXCLUDE_RANDOM) {\n+                complevel = complevel.excludeCompilationRandomly(ex);\n+            }\n+            if (complevel != CompLevel.SKIP) {\n+                enqueueForCompilation(ex, complevel);\n+                forceCompileMap.put(ex, complevel);\n+            }\n+        }\n+    }\n+\n+    static void enqueueForCompilation(Executable ex, CompLevel requestedCompLevel) {\n+        if (TestVM.VERBOSE) {\n+            System.out.println(\"enqueueForCompilation \" + ex + \", level = \" + requestedCompLevel);\n+        }\n+        CompLevel compLevel = restrictCompLevel(requestedCompLevel);\n+        if (compLevel != CompLevel.SKIP) {\n+            WHITE_BOX.enqueueMethodForCompilation(ex, compLevel.getValue());\n+        } else {\n+            System.out.println(\"Skipped compilation on level \" + requestedCompLevel + \" due to VM flags not allowing it.\");\n+        }\n+    }\n+\n+    \/**\n+     * Setup @Test annotated method an add them to the declaredTests map to have a convenient way of accessing them\n+     * once setting up a framework test (base  checked, or custom run test).\n+     *\/\n+    private void setupDeclaredTests() {\n+        for (Method m : testClass.getDeclaredMethods()) {\n+            Test testAnno = getAnnotation(m, Test.class);\n+            try {\n+                if (testAnno != null) {\n+                    addDeclaredTest(m);\n+                } else {\n+                    TestFormat.checkNoThrow(!m.isAnnotationPresent(IR.class), \"Found @IR annotation on non-@Test method \" + m);\n+                    TestFormat.checkNoThrow(!m.isAnnotationPresent(Warmup.class) || getAnnotation(m, Run.class) != null,\n+                                     \"Found @Warmup annotation on non-@Test or non-@Run method \" + m);\n+                }\n+            } catch (TestFormatException e) {\n+                \/\/ Failure logged. Continue and report later.\n+            }\n+        }\n+        TestFormat.checkNoThrow(!declaredTests.isEmpty(), \"Did not specify any @Test methods in \" + testClass);\n+    }\n+\n+    private void addDeclaredTest(Method m) {\n+        Test testAnno = getAnnotation(m, Test.class);\n+        checkTestAnnotations(m, testAnno);\n+        Warmup warmup = getAnnotation(m, Warmup.class);\n+        int warmupIterations = WARMUP_ITERATIONS;\n+        if (warmup != null) {\n+            warmupIterations = warmup.value();\n+            TestFormat.checkNoThrow(warmupIterations >= 0, \"Cannot have negative value for @Warmup at \" + m);\n+        }\n+\n+        if (!IGNORE_COMPILER_CONTROLS) {\n+            \/\/ Don't inline test methods by default. Do not apply this when -DIgnoreCompilerControls=true is set.\n+            WHITE_BOX.testSetDontInlineMethod(m, true);\n+        }\n+        CompLevel compLevel = restrictCompLevel(testAnno.compLevel());\n+        if (FLIP_C1_C2) {\n+            compLevel = compLevel.flipCompLevel();\n+        }\n+        if (EXCLUDE_RANDOM) {\n+            compLevel = compLevel.excludeCompilationRandomly(m);\n+        }\n+        DeclaredTest test = new DeclaredTest(m, ArgumentValue.getArguments(m), compLevel, warmupIterations);\n+        declaredTests.put(m, test);\n+        testMethodMap.put(m.getName(), m);\n+    }\n+\n+    private void checkTestAnnotations(Method m, Test testAnno) {\n+        TestFormat.check(!testMethodMap.containsKey(m.getName()),\n+                         \"Cannot overload two @Test methods: \" + m + \", \" + testMethodMap.get(m.getName()));\n+        TestFormat.check(testAnno != null, m + \" must be a method with a @Test annotation\");\n+\n+        Check checkAnno = getAnnotation(m, Check.class);\n+        Run runAnno = getAnnotation(m, Run.class);\n+        TestFormat.check(checkAnno == null && runAnno == null,\n+                         m + \" has invalid @Check or @Run annotation while @Test annotation is present.\");\n+\n+        TestFormat.checkNoThrow(Arrays.stream(m.getParameterTypes()).noneMatch(AbstractInfo.class::isAssignableFrom),\n+                                \"Cannot \" + AbstractInfo.class + \" or any of its subclasses as parameter type at \" +\n+                                \"@Test method \" + m);\n+\n+        TestFormat.checkNoThrow(!AbstractInfo.class.isAssignableFrom(m.getReturnType()),\n+                                \"Cannot \" + AbstractInfo.class + \" or any of its subclasses as return type at \" +\n+                                \"@Test method \" + m);\n+    }\n+\n+\n+    \/**\n+     * Get the appropriate level as permitted by the test scenario and VM flags.\n+     *\/\n+    private static CompLevel restrictCompLevel(CompLevel compLevel) {\n+        if (!USE_COMPILER) {\n+            return CompLevel.SKIP;\n+        }\n+        if (compLevel == CompLevel.ANY) {\n+            \/\/ Use highest available compilation level by default (usually C2).\n+            compLevel = TIERED_COMPILATION_STOP_AT_LEVEL;\n+        }\n+        if (!TIERED_COMPILATION && compLevel.getValue() < CompLevel.C2.getValue()) {\n+            return CompLevel.SKIP;\n+        }\n+        if (TIERED_COMPILATION && compLevel.getValue() > TIERED_COMPILATION_STOP_AT_LEVEL.getValue()) {\n+            return CompLevel.SKIP;\n+        }\n+        return compLevel;\n+    }\n+\n+    \/**\n+     * Verify that the helper classes do not contain illegal framework annotations and then apply the actions as\n+     * specified by the different helper class annotations.\n+     *\/\n+    private void processHelperClasses() {\n+        if (helperClasses != null) {\n+            for (Class<?> helperClass : helperClasses) {\n+                \/\/ Process the helper classes and apply the explicit compile commands\n+                TestFormat.checkNoThrow(helperClass != testClass,\n+                                        \"Cannot specify test \" + testClass + \" as helper class, too.\");\n+                checkHelperClass(helperClass);\n+                processControlAnnotations(helperClass);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * First set up checked (with @Check) and custom run tests (with @Run). All remaining unmatched\/unused @Test methods\n+     * are treated as base tests and set up as such later.\n+     *\/\n+    private void setupCheckedAndCustomRunTests() {\n+        for (Method m : testClass.getDeclaredMethods()) {\n+            Check checkAnno = getAnnotation(m, Check.class);\n+            Run runAnno = getAnnotation(m, Run.class);\n+            Arguments argumentsAnno = getAnnotation(m, Arguments.class);\n+            try {\n+                TestFormat.check(argumentsAnno == null || (checkAnno == null && runAnno == null),\n+                                 \"Cannot have @Argument annotation in combination with @Run or @Check at \" + m);\n+                if (checkAnno != null) {\n+                    addCheckedTest(m, checkAnno, runAnno);\n+                } else if (runAnno != null) {\n+                    addCustomRunTest(m, runAnno);\n+                }\n+            } catch (TestFormatException e) {\n+                \/\/ Failure logged. Continue and report later.\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Set up a checked test by first verifying the correct format of the @Test and @Check method and then adding it\n+     * to the allTests list which keeps track of all framework tests that are eventually executed.\n+     *\/\n+    private void addCheckedTest(Method m, Check checkAnno, Run runAnno) {\n+        Method testMethod = testMethodMap.get(checkAnno.test());\n+        DeclaredTest test = declaredTests.get(testMethod);\n+        checkCheckedTest(m, checkAnno, runAnno, testMethod, test);\n+        test.setAttachedMethod(m);\n+        CheckedTest.Parameter parameter = getCheckedTestParameter(m, testMethod);\n+        dontCompileAndDontInlineMethod(m);\n+        CheckedTest checkedTest = new CheckedTest(test, m, checkAnno, parameter, shouldExcludeTest(testMethod.getName()));\n+        allTests.add(checkedTest);\n+        if (PRINT_VALID_IR_RULES) {\n+            \/\/ Only need to emit IR verification information if IR verification is actually performed.\n+            irMatchRulePrinter.emitRuleEncoding(m, checkedTest.isSkipped());\n+        }\n+    }\n+\n+    private void checkCheckedTest(Method m, Check checkAnno, Run runAnno, Method testMethod, DeclaredTest test) {\n+        TestFormat.check(runAnno == null, m + \" has invalid @Run annotation while @Check annotation is present.\");\n+        TestFormat.check(testMethod != null, \"Did not find associated test method \\\"\" + m.getDeclaringClass().getName()\n+                                             + \".\" + checkAnno.test() + \"\\\" for @Check at \" + m);\n+        TestFormat.check(test != null, \"Missing @Test annotation for associated test method \" + testMethod + \" for @Check at \" + m);\n+        Method attachedMethod = test.getAttachedMethod();\n+        TestFormat.check(attachedMethod == null,\n+                         \"Cannot use @Test \" + testMethod + \" for more than one @Run or one @Check method. Found: \" + m + \", \" + attachedMethod);\n+    }\n+\n+    \/**\n+     * Only allow parameters as specified in {@link Check}.\n+     *\/\n+    private CheckedTest.Parameter getCheckedTestParameter(Method m, Method testMethod) {\n+        boolean firstParameterTestInfo = m.getParameterCount() > 0 && m.getParameterTypes()[0].equals(TestInfo.class);\n+        boolean secondParameterTestInfo = m.getParameterCount() > 1 && m.getParameterTypes()[1].equals(TestInfo.class);\n+        CheckedTest.Parameter parameter = null;\n+        Class<?> testReturnType = testMethod.getReturnType();\n+        switch (m.getParameterCount()) {\n+            case 0 -> parameter = CheckedTest.Parameter.NONE;\n+            case 1 -> {\n+                TestFormat.checkNoThrow(firstParameterTestInfo || m.getParameterTypes()[0] == testReturnType,\n+                                        \"Single-parameter version of @Check method \" + m + \" must match return type of @Test \" + testMethod);\n+                parameter = firstParameterTestInfo ? CheckedTest.Parameter.TEST_INFO_ONLY : CheckedTest.Parameter.RETURN_ONLY;\n+            }\n+            case 2 -> {\n+                TestFormat.checkNoThrow(m.getParameterTypes()[0] == testReturnType && secondParameterTestInfo,\n+                                        \"Two-parameter version of @Check method \" + m + \" must provide as first parameter the same\"\n+                                        + \" return type as @Test method \" + testMethod + \" and as second parameter an object of \" + TestInfo.class);\n+                parameter = CheckedTest.Parameter.BOTH;\n+            }\n+            default -> TestFormat.failNoThrow(\"@Check method \" + m + \" must provide either a none, single or two-parameter variant.\");\n+        }\n+        return parameter;\n+    }\n+\n+    \/**\n+     * Set up a custom run test by first verifying the correct format of the @Test and @Run method and then adding it\n+     * to the allTests list which keeps track of all framework tests that are eventually executed.\n+     *\/\n+    private void addCustomRunTest(Method m, Run runAnno) {\n+        checkRunMethod(m, runAnno);\n+        List<DeclaredTest> tests = new ArrayList<>();\n+        boolean shouldExcludeTest = true;\n+        for (String testName : runAnno.test()) {\n+            try {\n+                Method testMethod = testMethodMap.get(testName);\n+                DeclaredTest test = declaredTests.get(testMethod);\n+                checkCustomRunTest(m, testName, testMethod, test, runAnno.mode());\n+                test.setAttachedMethod(m);\n+                tests.add(test);\n+                \/\/ Only exclude custom run test if all test methods excluded\n+                shouldExcludeTest &= shouldExcludeTest(testMethod.getName());\n+            } catch (TestFormatException e) {\n+                \/\/ Logged, continue.\n+            }\n+        }\n+        if (tests.isEmpty()) {\n+            return; \/\/ There was a format violation. Return.\n+        }\n+        dontCompileAndDontInlineMethod(m);\n+        CustomRunTest customRunTest = new CustomRunTest(m, getAnnotation(m, Warmup.class), runAnno, tests, shouldExcludeTest);\n+        allTests.add(customRunTest);\n+        if (PRINT_VALID_IR_RULES) {\n+            tests.forEach(test -> irMatchRulePrinter.emitRuleEncoding(test.getTestMethod(), customRunTest.isSkipped()));\n+        }\n+    }\n+\n+    \/**\n+     * Only allow parameters as specified in {@link Run}.\n+     *\/\n+    private void checkCustomRunTest(Method m, String testName, Method testMethod, DeclaredTest test, RunMode runMode) {\n+        TestFormat.check(testMethod != null, \"Did not find associated @Test method \\\"\"  + m.getDeclaringClass().getName()\n+                                             + \".\" + testName + \"\\\" specified in @Run at \" + m);\n+        TestFormat.check(test != null,\n+                         \"Missing @Test annotation for associated test method \" + testName + \" for @Run at \" + m);\n+        Method attachedMethod = test.getAttachedMethod();\n+        TestFormat.check(attachedMethod == null,\n+                         \"Cannot use @Test \" + testMethod + \" for more than one @Run\/@Check method. Found: \"\n+                         + m + \", \" + attachedMethod);\n+        TestFormat.check(!test.hasArguments(),\n+                         \"Cannot use @Arguments at test method \" + testMethod + \" in combination with @Run method \" + m);\n+        Warmup warmupAnno = getAnnotation(testMethod, Warmup.class);\n+        TestFormat.checkNoThrow(warmupAnno == null,\n+                         \"Cannot set @Warmup at @Test method \" + testMethod + \" when used with its @Run method \"\n+                         + m + \". Use @Warmup at @Run method instead.\");\n+        Test testAnno = getAnnotation(testMethod, Test.class);\n+        TestFormat.checkNoThrow(runMode != RunMode.STANDALONE || testAnno.compLevel() == CompLevel.ANY,\n+                                \"Setting explicit compilation level for @Test method \" + testMethod + \" has no effect \"\n+                                + \"when used with STANDALONE @Run method \" + m);\n+    }\n+\n+    private void checkRunMethod(Method m, Run runAnno) {\n+        TestFormat.check(runAnno.test().length > 0, \"@Run method \" + m + \" must specify at least one test method\");\n+        TestFormat.checkNoThrow(m.getParameterCount() == 0 || (m.getParameterCount() == 1 && m.getParameterTypes()[0].equals(RunInfo.class)),\n+                                \"@Run method \" + m + \" must specify either no parameter or exactly one \" + RunInfo.class + \" parameter.\");\n+        Warmup warmupAnno = getAnnotation(m, Warmup.class);\n+        TestFormat.checkNoThrow(warmupAnno == null || runAnno.mode() != RunMode.STANDALONE,\n+                                \"Cannot set @Warmup at @Run method \" + m + \" when used with RunMode.STANDALONE. The @Run method is only invoked once.\");\n+    }\n+\n+    private static <T extends Annotation> T getAnnotation(AnnotatedElement element, Class<T> c) {\n+        T[] annos =  element.getAnnotationsByType(c);\n+        TestFormat.check(annos.length < 2, element + \" has duplicated annotations\");\n+        return Arrays.stream(annos).findFirst().orElse(null);\n+    }\n+\n+    \/**\n+     * Ensure that all compilations that were enforced (added to compilation queue) by framework annotations are\n+     * completed. Wait if necessary for a short amount of time for their completion.\n+     *\/\n+    private void checkForcedCompilationsCompleted() {\n+        if (forceCompileMap.isEmpty()) {\n+            return;\n+        }\n+        final long started = System.currentTimeMillis();\n+        long elapsed;\n+        do {\n+            forceCompileMap.entrySet().removeIf(entry -> WHITE_BOX.getMethodCompilationLevel(entry.getKey()) == entry.getValue().getValue());\n+            if (forceCompileMap.isEmpty()) {\n+                \/\/ All @ForceCompile methods are compiled at the requested level.\n+                return;\n+            }\n+            \/\/ Retry again if not yet compiled.\n+            forceCompileMap.forEach(TestVM::enqueueForCompilation);\n+            elapsed = System.currentTimeMillis() - started;\n+        } while (elapsed < 5000);\n+        StringBuilder builder = new StringBuilder();\n+        forceCompileMap.forEach((key, value) -> builder.append(\"- \").append(key).append(\" at CompLevel.\").append(value)\n+                                                       .append(System.lineSeparator()));\n+        throw new TestRunException(\"Could not force compile the following @ForceCompile methods:\"\n+                                   + System.lineSeparator() + builder.toString());\n+    }\n+\n+    \/**\n+     * Once all framework tests are collected, they are run in this method.\n+     *\/\n+    private void runTests() {\n+        TreeMap<Long, String> durations = (PRINT_TIMES || VERBOSE) ? new TreeMap<>() : null;\n+        long startTime = System.nanoTime();\n+        List<AbstractTest> testList;\n+        boolean testFilterPresent = testFilterPresent();\n+        if (testFilterPresent) {\n+            \/\/ Only run the specified tests by the user filters -DTest and\/or -DExclude.\n+            testList = allTests.stream().filter(test -> !test.isSkipped()).collect(Collectors.toList());\n+            if (testList.isEmpty()) {\n+                \/\/ Throw an exception to inform the user about an empty specified test set with -DTest and\/or -DExclude\n+                throw new NoTestsRunException();\n+            }\n+        } else {\n+            testList = allTests;\n+        }\n+\n+        if (SHUFFLE_TESTS) {\n+            \/\/ Execute tests in random order (execution sequence affects profiling). This is done by default.\n+            Collections.shuffle(testList, Utils.getRandomInstance());\n+        }\n+        StringBuilder builder = new StringBuilder();\n+        int failures = 0;\n+\n+        \/\/ Execute all tests and keep track of each exception that is thrown. These are then reported once all tests\n+        \/\/ are executing. This prevents a premature exit without running all tests.\n+        for (AbstractTest test : testList) {\n+            if (VERBOSE) {\n+                System.out.println(\"Run \" + test.toString());\n+            }\n+            if (testFilterPresent) {\n+                TestFrameworkSocket.write(\"Run \" + test.toString(), \"testfilter\", true);\n+            }\n+            try {\n+                test.run();\n+            } catch (TestRunException e) {\n+                StringWriter sw = new StringWriter();\n+                PrintWriter pw = new PrintWriter(sw);\n+                e.printStackTrace(pw);\n+                builder.append(test.toString()).append(\":\").append(System.lineSeparator()).append(sw.toString())\n+                       .append(System.lineSeparator()).append(System.lineSeparator());\n+                failures++;\n+            }\n+            if (PRINT_TIMES || VERBOSE) {\n+                long endTime = System.nanoTime();\n+                long duration = (endTime - startTime);\n+                durations.put(duration, test.getName());\n+                if (VERBOSE) {\n+                    System.out.println(\"Done \" + test.getName() + \": \" + duration + \" ns = \" + (duration \/ 1000000) + \" ms\");\n+                }\n+            }\n+            if (GC_AFTER) {\n+                System.out.println(\"doing GC\");\n+                WHITE_BOX.fullGC();\n+            }\n+        }\n+\n+        \/\/ Print execution times\n+        if (VERBOSE || PRINT_TIMES) {\n+            System.out.println(System.lineSeparator() + System.lineSeparator() + \"Test execution times:\");\n+            for (Map.Entry<Long, String> entry : durations.entrySet()) {\n+                System.out.format(\"%-10s%15d ns%n\", entry.getValue() + \":\", entry.getKey());\n+            }\n+        }\n+\n+        if (failures > 0) {\n+            \/\/ Finally, report all occurred exceptions in a nice format.\n+            String msg = System.lineSeparator() + System.lineSeparator() + \"Test Failures (\" + failures + \")\"\n+                         + System.lineSeparator() + \"----------------\" + \"-\".repeat(String.valueOf(failures).length());\n+            throw new TestRunException(msg + System.lineSeparator() + builder.toString());\n+        }\n+    }\n+\n+    private boolean testFilterPresent() {\n+        return testList != null || excludeList != null;\n+    }\n+\n+    enum TriState {\n+        Maybe,\n+        Yes,\n+        No\n+    }\n+\n+    public static void compile(Method m, CompLevel compLevel) {\n+        TestRun.check(compLevel != CompLevel.SKIP && compLevel != CompLevel.WAIT_FOR_COMPILATION,\n+                         \"Invalid compilation request with level \" + compLevel);\n+        enqueueForCompilation(m, compLevel);\n+    }\n+\n+    public static void deoptimize(Method m) {\n+        WHITE_BOX.deoptimizeMethod(m);\n+    }\n+\n+    public static boolean isCompiled(Method m) {\n+        return compiledAtLevel(m, CompLevel.ANY) == TriState.Yes;\n+    }\n+\n+    public static boolean isC1Compiled(Method m) {\n+        return compiledByC1(m) == TriState.Yes;\n+    }\n+\n+    public static boolean isC2Compiled(Method m) {\n+        return compiledByC2(m) == TriState.Yes;\n+    }\n+\n+    public static boolean isCompiledAtLevel(Method m, CompLevel compLevel) {\n+        return compiledAtLevel(m, compLevel) == TriState.Yes;\n+    }\n+\n+    public static void assertDeoptimizedByC1(Method m) {\n+        if (notUnstableDeoptAssertion(m, CompLevel.C1_SIMPLE)) {\n+            TestRun.check(compiledByC1(m) != TriState.Yes || PER_METHOD_TRAP_LIMIT == 0 || !PROFILE_INTERPRETER,\n+                          m + \" should have been deoptimized by C1\");\n+        }\n+    }\n+\n+    public static void assertDeoptimizedByC2(Method m) {\n+        if (notUnstableDeoptAssertion(m, CompLevel.C2)) {\n+            TestRun.check(compiledByC2(m) != TriState.Yes || PER_METHOD_TRAP_LIMIT == 0 || !PROFILE_INTERPRETER,\n+                          m + \" should have been deoptimized by C2\");\n+        }\n+    }\n+\n+    \/**\n+     * Some VM flags could make the deopt assertions unstable.\n+     *\/\n+    private static boolean notUnstableDeoptAssertion(Method m, CompLevel level) {\n+        return (USE_COMPILER && !XCOMP && !IGNORE_COMPILER_CONTROLS && !TEST_C1 &&\n+               (!EXCLUDE_RANDOM || WHITE_BOX.isMethodCompilable(m, level.getValue(), false)));\n+    }\n+\n+    public static void assertCompiledByC1(Method m) {\n+        TestRun.check(compiledByC1(m) != TriState.No, m + \" should have been C1 compiled\");\n+    }\n+\n+    public static void assertCompiledByC2(Method m) {\n+        TestRun.check(compiledByC2(m) != TriState.No, m + \" should have been C2 compiled\");\n+    }\n+\n+    public static void assertCompiledAtLevel(Method m, CompLevel level) {\n+        TestRun.check(compiledAtLevel(m, level) != TriState.No, m + \" should have been compiled at level \" + level.name());\n+    }\n+\n+    public static void assertNotCompiled(Method m) {\n+        TestRun.check(!isC1Compiled(m), m + \" should not have been compiled by C1\");\n+        TestRun.check(!isC2Compiled(m), m + \" should not have been compiled by C2\");\n+    }\n+\n+    public static void assertCompiled(Method m) {\n+        TestRun.check(compiledByC1(m) != TriState.No || compiledByC2(m) != TriState.No, m + \" should have been compiled\");\n+    }\n+\n+    private static TriState compiledByC1(Method m) {\n+        TriState triState = compiledAtLevel(m, CompLevel.C1_SIMPLE);\n+        if (triState != TriState.No) {\n+            return triState;\n+        }\n+        triState = compiledAtLevel(m, CompLevel.C1_LIMITED_PROFILE);\n+        if (triState != TriState.No) {\n+            return triState;\n+        }\n+        triState = compiledAtLevel(m, CompLevel.C1_FULL_PROFILE);\n+        return triState;\n+    }\n+\n+    private static TriState compiledByC2(Method m) {\n+        return compiledAtLevel(m, CompLevel.C2);\n+    }\n+\n+    private static TriState compiledAtLevel(Method m, CompLevel level) {\n+        if (WHITE_BOX.isMethodCompiled(m, false)) {\n+            switch (level) {\n+                case C1_SIMPLE, C1_LIMITED_PROFILE, C1_FULL_PROFILE, C2 -> {\n+                    if (WHITE_BOX.getMethodCompilationLevel(m, false) == level.getValue()) {\n+                        return TriState.Yes;\n+                    }\n+                }\n+                case ANY -> {\n+                    return TriState.Yes;\n+                }\n+                default -> throw new TestRunException(\"compiledAtLevel() should not be called with \" + level);\n+            }\n+        }\n+        if (!USE_COMPILER || XCOMP || TEST_C1 || IGNORE_COMPILER_CONTROLS ||\n+            (EXCLUDE_RANDOM && !WHITE_BOX.isMethodCompilable(m, level.getValue(), false))) {\n+            return TriState.Maybe;\n+        }\n+        return TriState.No;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/TestVM.java","additions":955,"deletions":0,"binary":false,"changes":955,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8268017\n+ * @summary C2: assert(phi_type->isa_int() || phi_type->isa_ptr() || phi_type->isa_long()) failed: bad phi type\n+ *\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=TestCastFFAtPhi TestCastFFAtPhi\n+ *\n+ *\/\n+\n+public class TestCastFFAtPhi {\n+    static int N = 400;\n+    static double dArrFld[] = new double[N];\n+    static long iMeth_check_sum = 0;\n+\n+    static {\n+        init(dArrFld, 90.71133);\n+    }\n+\n+    float fArrFld[] = new float[N];\n+\n+    public static void main(String[] strArr) {\n+        TestCastFFAtPhi _instance = new TestCastFFAtPhi();\n+        for (int i = 0; i < 10; i++) {\n+            _instance.mainTest();\n+        }\n+    }\n+\n+    void mainTest() {\n+        int i24 = 121110, i28, i30;\n+        float f2 = 2.486F;\n+\n+        for (i28 = 322; i28 > 6; i28--) {\n+            i30 = 1;\n+            do {\n+                i24 = (int) f2;\n+                fArrFld[1] += i30;\n+                switch (((i28 % 4) * 5) + 32) {\n+                    case 36:\n+                        f2 *= f2;\n+                }\n+            } while (++i30 < 80);\n+        }\n+        System.out.println(i24 + \",\");\n+    }\n+\n+    public static void init(double[] a, double seed) {\n+        for (int j = 0; j < a.length; j++) {\n+            a[j] = (j % 2 == 0) ? seed + j : seed - j;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestCastFFAtPhi.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8268360\n+ * @summary Test node placement when its use is inside infinite loop.\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:CompileCommand=compileonly,compiler.loopopts.TestInfLoopNearUsePlacement::test\n+ *                   compiler.loopopts.TestInfLoopNearUsePlacement\n+ *\/\n+\n+package compiler.loopopts;\n+\n+import jdk.test.lib.Utils;\n+\n+public class TestInfLoopNearUsePlacement {\n+\n+    static void test() {\n+        long loa[] = new long[42];\n+\n+        try {\n+            for (int i = 0; i < 42; i++) {\n+                Thread.sleep(1);\n+                loa[i] = 42L;\n+            }\n+        } catch (InterruptedException e) {}\n+\n+        loa[0] = 1L;\n+        \/\/ Infinite loop: loop's variable is reset on each iteration\n+        for (int i = 0; i < 21; i++) {\n+            loa[0] += 1L;\n+            i = 1;\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Execute test in own thread because it contains an infinite loop\n+        Thread thread = new Thread() {\n+            public void run() {\n+                for (int i = 0; i < 100; ++i) {\n+                    test();\n+                }\n+            }\n+        };\n+        thread.setDaemon(true);\n+        thread.start();\n+        \/\/ Give thread some time to trigger compilation\n+        Thread.sleep(Utils.adjustTimeout(5000));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestInfLoopNearUsePlacement.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8263303\n+ * @summary C2 compilation fails with assert(found_sfpt) failed: no node in loop that's not input to safepoint\n+ *\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:LoopUnrollLimit=0 TestPinnedUseInOuterLSMUnusedBySfpt\n+ *\n+ *\/\n+\n+public class TestPinnedUseInOuterLSMUnusedBySfpt {\n+    public static void main(String[] args) {\n+        int[] array = new int[10000];\n+        for (int i = 0; i < 20_000; i++) {\n+            test(100, array, 42);\n+            test(100, array, 0);\n+        }\n+    }\n+\n+    private static float test(int stop, int[] array, int val) {\n+        if (array == null) {\n+        }\n+        int j;\n+        for (j = 0; j < 10; j++) {\n+\n+        }\n+        int i;\n+        int v = 0;\n+        float f = 1;\n+        for (i = 0; i < 10000; i++) {\n+            if ((j - 10) * i + val == 42) {\n+                f *= 2;\n+            } else {\n+                f *= 3;\n+            }\n+            v = (j - 10) * array[i];\n+            if (i % 10001 != i) {\n+                return v;\n+            }\n+        }\n+        return v + array[i-1] + f;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopstripmining\/TestPinnedUseInOuterLSMUnusedBySfpt.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -40,1 +40,0 @@\n-import jdk.test.lib.process.ProcessTools;\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestParallelRefProc.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+    System.out.println(output.getStdout());\n@@ -63,2 +64,2 @@\n-    output.shouldContain(\"Live humongous\");\n-    output.shouldContain(\"Dead humongous region\");\n+    output.shouldContain(\"Humongous region\");\n+    output.shouldContain(\"Reclaimed humongous region\");\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestG1TraceEagerReclaimHumongousObjects.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -244,0 +244,2 @@\n+                                                                  \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                                  \"-XX:-G1AllowPreventiveGC\",\n@@ -255,0 +257,2 @@\n+                                                   \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                   \"-XX:-G1AllowPreventiveGC\",\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -50,0 +50,4 @@\n+    static {\n+        System.loadLibrary(\"LinkToNativeRBP\");\n+    }\n+\n@@ -51,1 +55,1 @@\n-    static final LibraryLookup lookup = LibraryLookup.ofLibrary(\"LinkToNativeRBP\");\n+    static final SymbolLookup lookup = SymbolLookup.loaderLookup();\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestLinkToNativeRBP.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @run main GetObjectSizeOverflow\n+ * @run driver GetObjectSizeOverflow\n@@ -46,1 +46,0 @@\n-import jdk.test.lib.Platform;\n@@ -49,1 +48,0 @@\n-import jtreg.SkippedException;\n@@ -54,3 +52,3 @@\n-        PrintWriter pw = new PrintWriter(\"MANIFEST.MF\");\n-        pw.println(\"Premain-Class: GetObjectSizeOverflowAgent\");\n-        pw.close();\n+        try (var pw = new PrintWriter(\"MANIFEST.MF\")) {\n+            pw.println(\"Premain-Class: GetObjectSizeOverflowAgent\");\n+        }\n@@ -58,3 +56,2 @@\n-        ProcessBuilder pb = new ProcessBuilder();\n-        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jar\"), \"cmf\", \"MANIFEST.MF\", \"agent.jar\", \"GetObjectSizeOverflowAgent.class\"});\n-        pb.start().waitFor();\n+        var jar = new ProcessBuilder(JDKToolFinder.getJDKTool(\"jar\"), \"cmf\", \"MANIFEST.MF\", \"agent.jar\", \"GetObjectSizeOverflowAgent.class\");\n+        new OutputAnalyzer(jar.start()).shouldHaveExitValue(0);\n@@ -64,1 +61,0 @@\n-\n@@ -66,0 +62,1 @@\n+        output.shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/resourcehogs\/serviceability\/jvmti\/GetObjectSizeOverflow.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Run invocation tests with old CHA (-XX:-UseVtableBasedCHA)\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ *          java.base\/jdk.internal.misc\n+ * @compile shared\/AbstractGenerator.java shared\/AccessCheck.java shared\/AccessType.java\n+ *          shared\/Caller.java shared\/ExecutorGenerator.java shared\/Utils.java\n+ *          shared\/ByteArrayClassLoader.java shared\/Checker.java shared\/GenericClassGenerator.java\n+ * @compile invokespecial\/Checker.java invokespecial\/ClassGenerator.java invokespecial\/Generator.java\n+ *          invokevirtual\/Checker.java invokevirtual\/ClassGenerator.java invokevirtual\/Generator.java\n+ *          invokeinterface\/Checker.java invokeinterface\/ClassGenerator.java invokeinterface\/Generator.java\n+ *\n+ * @run driver\/timeout=1800 invocationOldCHATests\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.compiler.InMemoryJavaCompiler;\n+\n+public class invocationOldCHATests {\n+\n+    public static void runTest(String whichTests, String classFileVersion) throws Throwable {\n+        System.out.println(\"\\nOld CHA invocation tests, Tests: \" + whichTests +\n+                           \", class file version: \" + classFileVersion);\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-Xmx128M\",\n+            \"-Xcomp\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-UseVtableBasedCHA\",\n+            \"--add-exports\", \"java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED\",\n+            whichTests, \"--classfile_version=\" + classFileVersion);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        try {\n+            output.shouldContain(\"EXECUTION STATUS: PASSED\");\n+            output.shouldHaveExitValue(0);\n+        } catch (Throwable e) {\n+            System.out.println(\n+                \"\\nNote that an entry such as 'B.m\/C.m' in the failure chart means that\" +\n+                \" the test case failed because method B.m was invoked but the test \" +\n+                \"expected method C.m to be invoked. Similarly, a result such as 'AME\/C.m'\" +\n+                \" means that an AbstractMethodError exception was thrown but the test\" +\n+                \" case expected method C.m to be invoked.\");\n+            System.out.println(\n+                \"\\nAlso note that passing --dump to invoke*.Generator will\" +\n+                \" dump the generated classes (for debugging purposes).\\n\");\n+\n+            throw e;\n+        }\n+    }\n+\n+    public static void main(String args[]) throws Throwable {\n+        \/\/ Get current major class file version and test with it.\n+        byte klassbuf[] = InMemoryJavaCompiler.compile(\"blah\", \"public class blah { }\");\n+        int major_version = klassbuf[6] << 8 | klassbuf[7];\n+        runTest(\"invokespecial.Generator\", String.valueOf(major_version));\n+        runTest(\"invokeinterface.Generator\", String.valueOf(major_version));\n+        runTest(\"invokevirtual.Generator\", String.valueOf(major_version));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/InvocationTests\/invocationOldCHATests.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8167108\n+ * @bug 8167108 8266130\n@@ -28,1 +28,1 @@\n- * @run main\/othervm -Xlog:thread+smr=debug InterruptAtExit\n+ * @run main\/othervm InterruptAtExit\n@@ -34,2 +34,2 @@\n-    final static int N_THREADS = 32;\n-    final static int N_LATE_CALLS = 1000;\n+    private final static int DEF_TIME_MAX = 30;  \/\/ default max # secs to test\n+    private final static String PROG_NAME = \"InterruptAtExit\";\n@@ -45,2 +45,1 @@\n-            \/\/ Wait for main thread to interrupt us so we\n-            \/\/ can race to exit.\n+            \/\/ Wait for main thread to tell us to race to the exit.\n@@ -49,1 +48,2 @@\n-            \/\/ ignore because we expect one\n+            \/\/ Ignore because we are testing java.lang.Thread.interrupt()\n+            \/\/ and one may arrive before we leave the 'try { }' block.\n@@ -54,1 +54,11 @@\n-        InterruptAtExit threads[] = new InterruptAtExit[N_THREADS];\n+        int timeMax = 0;\n+        if (args.length == 0) {\n+            timeMax = DEF_TIME_MAX;\n+        } else {\n+            try {\n+                timeMax = Integer.parseUnsignedInt(args[0]);\n+            } catch (NumberFormatException nfe) {\n+                System.err.println(\"'\" + args[0] + \"': invalid timeMax value.\");\n+                usage();\n+            }\n+        }\n@@ -56,4 +66,9 @@\n-        for (int i = 0; i < N_THREADS; i++ ) {\n-            threads[i] = new InterruptAtExit();\n-            int late_count = 1;\n-            threads[i].start();\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long count = 0;\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+\n+            InterruptAtExit thread = new InterruptAtExit();\n+            thread.start();\n@@ -62,7 +77,6 @@\n-                threads[i].startSyncObj.await();\n-\n-                \/\/ The first interrupt() call will break the\n-                \/\/ worker out of the exitSyncObj.await() call\n-                \/\/ and the rest will come in during thread exit.\n-                for (; late_count <= N_LATE_CALLS; late_count++) {\n-                    threads[i].interrupt();\n+                thread.startSyncObj.await();\n+                \/\/ Tell the worker thread to race to the exit and the\n+                \/\/ Thread.interrupt() calls will come in during thread exit.\n+                thread.exitSyncObj.countDown();\n+                while (true) {\n+                    thread.interrupt();\n@@ -70,1 +84,1 @@\n-                    if (!threads[i].isAlive()) {\n+                    if (!thread.isAlive()) {\n@@ -80,8 +94,0 @@\n-            System.out.println(\"INFO: thread #\" + i + \": made \" + late_count +\n-                               \" late calls to java.lang.Thread.interrupt()\");\n-            System.out.println(\"INFO: thread #\" + i + \": N_LATE_CALLS==\" +\n-                               N_LATE_CALLS + \" value is \" +\n-                               ((late_count >= N_LATE_CALLS) ? \"NOT \" : \"\") +\n-                               \"large enough to cause a Thread.interrupt() \" +\n-                               \"call after thread exit.\");\n-\n@@ -89,1 +95,1 @@\n-                threads[i].join();\n+                thread.join();\n@@ -93,5 +99,1 @@\n-            threads[i].interrupt();\n-            if (threads[i].isAlive()) {\n-                throw new Error(\"Expected !Thread.isAlive() after thread #\" +\n-                                i + \" has been join()'ed\");\n-            }\n+            thread.interrupt();\n@@ -100,0 +102,3 @@\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n+\n@@ -106,0 +111,9 @@\n+\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + PROG_NAME + \" [time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    time_max  max looping time in seconds\");\n+        System.err.println(\"              (default is \" + DEF_TIME_MAX +\n+                           \" seconds)\");\n+        System.exit(1);\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/InterruptAtExit.java","additions":49,"deletions":35,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8167108\n+ * @bug 8167108 8266130\n@@ -28,1 +28,1 @@\n- * @run main\/othervm -Xlog:thread+smr=debug IsInterruptedAtExit\n+ * @run main\/othervm IsInterruptedAtExit\n@@ -34,2 +34,2 @@\n-    final static int N_THREADS = 32;\n-    final static int N_LATE_CALLS = 2000;\n+    private final static int DEF_TIME_MAX = 30;  \/\/ default max # secs to test\n+    private final static String PROG_NAME = \"IsInterruptedAtExit\";\n@@ -45,2 +45,1 @@\n-            \/\/ Wait for main thread to interrupt us so we\n-            \/\/ can race to exit.\n+            \/\/ Wait for main thread to tell us to race to the exit.\n@@ -49,1 +48,1 @@\n-            \/\/ ignore because we expect one\n+            throw new RuntimeException(\"Unexpected: \" + e);\n@@ -54,1 +53,11 @@\n-        IsInterruptedAtExit threads[] = new IsInterruptedAtExit[N_THREADS];\n+        int timeMax = 0;\n+        if (args.length == 0) {\n+            timeMax = DEF_TIME_MAX;\n+        } else {\n+            try {\n+                timeMax = Integer.parseUnsignedInt(args[0]);\n+            } catch (NumberFormatException nfe) {\n+                System.err.println(\"'\" + args[0] + \"': invalid timeMax value.\");\n+                usage();\n+            }\n+        }\n@@ -56,4 +65,9 @@\n-        for (int i = 0; i < N_THREADS; i++ ) {\n-            threads[i] = new IsInterruptedAtExit();\n-            int late_count = 1;\n-            threads[i].start();\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long count = 0;\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+\n+            IsInterruptedAtExit thread = new IsInterruptedAtExit();\n+            thread.start();\n@@ -62,8 +76,7 @@\n-                threads[i].startSyncObj.await();\n-\n-                \/\/ This interrupt() call will break the worker out of\n-                \/\/ the exitSyncObj.await() call and the isInterrupted()\n-                \/\/ calls will come in during thread exit.\n-                threads[i].interrupt();\n-                for (; late_count <= N_LATE_CALLS; late_count++) {\n-                    threads[i].isInterrupted();\n+                thread.startSyncObj.await();\n+                \/\/ Tell the worker thread to race to the exit and the\n+                \/\/ Thread.isInterrupted() calls will come in during\n+                \/\/ thread exit.\n+                thread.exitSyncObj.countDown();\n+                while (true) {\n+                    thread.isInterrupted();\n@@ -71,1 +84,1 @@\n-                    if (!threads[i].isAlive()) {\n+                    if (!thread.isAlive()) {\n@@ -81,8 +94,0 @@\n-            System.out.println(\"INFO: thread #\" + i + \": made \" + late_count +\n-                               \" late calls to java.lang.Thread.isInterrupted()\");\n-            System.out.println(\"INFO: thread #\" + i + \": N_LATE_CALLS==\" +\n-                               N_LATE_CALLS + \" value is \" +\n-                               ((late_count >= N_LATE_CALLS) ? \"NOT \" : \"\") +\n-                               \"large enough to cause a Thread.isInterrupted() \" +\n-                               \"call after thread exit.\");\n-\n@@ -90,1 +95,1 @@\n-                threads[i].join();\n+                thread.join();\n@@ -94,5 +99,1 @@\n-            threads[i].isInterrupted();\n-            if (threads[i].isAlive()) {\n-                throw new Error(\"Expected !Thread.isAlive() after thread #\" +\n-                                i + \" has been join()'ed\");\n-            }\n+            thread.isInterrupted();\n@@ -101,0 +102,3 @@\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n+\n@@ -107,0 +111,9 @@\n+\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + PROG_NAME + \" [time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    time_max  max looping time in seconds\");\n+        System.err.println(\"              (default is \" + DEF_TIME_MAX +\n+                           \" seconds)\");\n+        System.exit(1);\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/IsInterruptedAtExit.java","additions":49,"deletions":36,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8167108\n- * @summary Stress test java.lang.Thread.resume() at thread exit.\n- * @run main\/othervm -Xlog:thread+smr=debug ResumeAtExit\n- *\/\n-\n-import java.util.concurrent.CountDownLatch;\n-\n-public class ResumeAtExit extends Thread {\n-    final static int N_THREADS = 32;\n-    final static int N_LATE_CALLS = 2000;\n-\n-    public CountDownLatch exitSyncObj = new CountDownLatch(1);\n-    public CountDownLatch startSyncObj = new CountDownLatch(1);\n-\n-    @Override\n-    public void run() {\n-        \/\/ Tell main thread we have started.\n-        startSyncObj.countDown();\n-        try {\n-            \/\/ Wait for main thread to interrupt us so we\n-            \/\/ can race to exit.\n-            exitSyncObj.await();\n-        } catch (InterruptedException e) {\n-            \/\/ ignore because we expect one\n-        }\n-    }\n-\n-    public static void main(String[] args) {\n-        ResumeAtExit threads[] = new ResumeAtExit[N_THREADS];\n-\n-        for (int i = 0; i < N_THREADS; i++ ) {\n-            threads[i] = new ResumeAtExit();\n-            int late_count = 1;\n-            threads[i].start();\n-            try {\n-                \/\/ Wait for the worker thread to get going.\n-                threads[i].startSyncObj.await();\n-\n-                \/\/ This interrupt() call will break the worker out\n-                \/\/ of the exitSyncObj.await() call and the resume()\n-                \/\/ calls will come in during thread exit.\n-                threads[i].interrupt();\n-                for (; late_count <= N_LATE_CALLS; late_count++) {\n-                    threads[i].resume();\n-\n-                    if (!threads[i].isAlive()) {\n-                        \/\/ Done with Thread.resume() calls since\n-                        \/\/ thread is not alive.\n-                        break;\n-                    }\n-                }\n-            } catch (InterruptedException e) {\n-                throw new Error(\"Unexpected: \" + e);\n-            }\n-\n-            System.out.println(\"INFO: thread #\" + i + \": made \" + late_count +\n-                               \" late calls to java.lang.Thread.resume()\");\n-            System.out.println(\"INFO: thread #\" + i + \": N_LATE_CALLS==\" +\n-                               N_LATE_CALLS + \" value is \" +\n-                               ((late_count >= N_LATE_CALLS) ? \"NOT \" : \"\") +\n-                               \"large enough to cause a Thread.resume() \" +\n-                               \"call after thread exit.\");\n-\n-            try {\n-                threads[i].join();\n-            } catch (InterruptedException e) {\n-                throw new Error(\"Unexpected: \" + e);\n-            }\n-            threads[i].resume();\n-            if (threads[i].isAlive()) {\n-                throw new Error(\"Expected !Thread.isAlive() after thread #\" +\n-                                i + \" has been join()'ed\");\n-            }\n-        }\n-\n-        String cmd = System.getProperty(\"sun.java.command\");\n-        if (cmd != null && !cmd.startsWith(\"com.sun.javatest.regtest.agent.MainWrapper\")) {\n-            \/\/ Exit with success in a non-JavaTest environment:\n-            System.exit(0);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/ResumeAtExit.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8167108\n+ * @bug 8167108 8266130\n@@ -28,1 +28,1 @@\n- * @run main\/othervm -Xlog:thread+smr=debug SetNameAtExit\n+ * @run main\/othervm SetNameAtExit\n@@ -34,2 +34,2 @@\n-    final static int N_THREADS = 32;\n-    final static int N_LATE_CALLS = 1000;\n+    private final static int DEF_TIME_MAX = 30;  \/\/ default max # secs to test\n+    private final static String PROG_NAME = \"SetNameAtExit\";\n@@ -45,2 +45,1 @@\n-            \/\/ Wait for main thread to interrupt us so we\n-            \/\/ can race to exit.\n+            \/\/ Wait for main thread to tell us to race to the exit.\n@@ -49,1 +48,1 @@\n-            \/\/ ignore because we expect one\n+            throw new RuntimeException(\"Unexpected: \" + e);\n@@ -54,1 +53,11 @@\n-        SetNameAtExit threads[] = new SetNameAtExit[N_THREADS];\n+        int timeMax = 0;\n+        if (args.length == 0) {\n+            timeMax = DEF_TIME_MAX;\n+        } else {\n+            try {\n+                timeMax = Integer.parseUnsignedInt(args[0]);\n+            } catch (NumberFormatException nfe) {\n+                System.err.println(\"'\" + args[0] + \"': invalid timeMax value.\");\n+                usage();\n+            }\n+        }\n@@ -56,4 +65,9 @@\n-        for (int i = 0; i < N_THREADS; i++ ) {\n-            threads[i] = new SetNameAtExit();\n-            int late_count = 1;\n-            threads[i].start();\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long count = 0;\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+\n+            SetNameAtExit thread = new SetNameAtExit();\n+            thread.start();\n@@ -62,8 +76,7 @@\n-                threads[i].startSyncObj.await();\n-\n-                \/\/ This interrupt() call will break the worker out\n-                \/\/ of the exitSyncObj.await() call and the setName()\n-                \/\/ calls will come in during thread exit.\n-                threads[i].interrupt();\n-                for (; late_count <= N_LATE_CALLS; late_count++) {\n-                    threads[i].setName(\"T\" + i + \"-\" + late_count);\n+                thread.startSyncObj.await();\n+                \/\/ Tell the worker thread to race to the exit and the\n+                \/\/ Thread.setName() calls will come in during thread exit.\n+                thread.exitSyncObj.countDown();\n+                long late_count = 0;\n+                while (true) {\n+                    thread.setName(\"T\" + count + \"-\" + late_count++);\n@@ -71,1 +84,1 @@\n-                    if (!threads[i].isAlive()) {\n+                    if (!thread.isAlive()) {\n@@ -81,8 +94,0 @@\n-            System.out.println(\"INFO: thread #\" + i + \": made \" + late_count +\n-                               \" late calls to java.lang.Thread.setName()\");\n-            System.out.println(\"INFO: thread #\" + i + \": N_LATE_CALLS==\" +\n-                               N_LATE_CALLS + \" value is \" +\n-                               ((late_count >= N_LATE_CALLS) ? \"NOT \" : \"\") +\n-                               \"large enough to cause a Thread.setName() \" +\n-                               \"call after thread exit.\");\n-\n@@ -90,1 +95,1 @@\n-                threads[i].join();\n+                thread.join();\n@@ -94,5 +99,1 @@\n-            threads[i].setName(\"T\" + i + \"-done\");\n-            if (threads[i].isAlive()) {\n-                throw new Error(\"Expected !Thread.isAlive() after thread #\" +\n-                                i + \" has been join()'ed\");\n-            }\n+            thread.setName(\"T\" + count + \"-done\");\n@@ -101,0 +102,3 @@\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n+\n@@ -107,0 +111,9 @@\n+\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + PROG_NAME + \" [time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    time_max  max looping time in seconds\");\n+        System.err.println(\"              (default is \" + DEF_TIME_MAX +\n+                           \" seconds)\");\n+        System.exit(1);\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/SetNameAtExit.java","additions":49,"deletions":36,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8167108\n+ * @bug 8167108 8266130\n@@ -28,1 +28,1 @@\n- * @run main\/othervm -Xlog:thread+smr=debug SetPriorityAtExit\n+ * @run main\/othervm SetPriorityAtExit\n@@ -34,2 +34,2 @@\n-    final static int N_THREADS = 32;\n-    final static int N_LATE_CALLS = 2000;\n+    private final static int DEF_TIME_MAX = 30;  \/\/ default max # secs to test\n+    private final static String PROG_NAME = \"SetPriorityAtExit\";\n@@ -37,2 +37,2 @@\n-    final static int MIN = java.lang.Thread.MIN_PRIORITY;\n-    final static int NORM = java.lang.Thread.NORM_PRIORITY;\n+    private final static int MIN = java.lang.Thread.MIN_PRIORITY;\n+    private final static int NORM = java.lang.Thread.NORM_PRIORITY;\n@@ -48,2 +48,1 @@\n-            \/\/ Wait for main thread to interrupt us so we\n-            \/\/ can race to exit.\n+            \/\/ Wait for main thread to tell us to race to the exit.\n@@ -52,1 +51,1 @@\n-            \/\/ ignore because we expect one\n+            throw new RuntimeException(\"Unexpected: \" + e);\n@@ -57,1 +56,11 @@\n-        SetPriorityAtExit threads[] = new SetPriorityAtExit[N_THREADS];\n+        int timeMax = 0;\n+        if (args.length == 0) {\n+            timeMax = DEF_TIME_MAX;\n+        } else {\n+            try {\n+                timeMax = Integer.parseUnsignedInt(args[0]);\n+            } catch (NumberFormatException nfe) {\n+                System.err.println(\"'\" + args[0] + \"': invalid timeMax value.\");\n+                usage();\n+            }\n+        }\n@@ -59,0 +68,3 @@\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long count = 0;\n@@ -60,4 +72,5 @@\n-        for (int i = 0; i < N_THREADS; i++ ) {\n-            threads[i] = new SetPriorityAtExit();\n-            int late_count = 1;\n-            threads[i].start();\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+            SetPriorityAtExit thread = new SetPriorityAtExit();\n+            thread.start();\n@@ -66,8 +79,7 @@\n-                threads[i].startSyncObj.await();\n-\n-                \/\/ This interrupt() call will break the worker out of\n-                \/\/ the exitSyncObj.await() call and the setPriority()\n-                \/\/ calls will come in during thread exit.\n-                threads[i].interrupt();\n-                for (; late_count <= N_LATE_CALLS; late_count++) {\n-                    threads[i].setPriority(prio);\n+                thread.startSyncObj.await();\n+                \/\/ Tell the worker thread to race to the exit and the\n+                \/\/ Thread.setPriority() calls will come in during\n+                \/\/ thread exit.\n+                thread.exitSyncObj.countDown();\n+                while (true) {\n+                    thread.setPriority(prio);\n@@ -80,1 +92,1 @@\n-                    if (!threads[i].isAlive()) {\n+                    if (!thread.isAlive()) {\n@@ -89,8 +101,1 @@\n-\n-            System.out.println(\"INFO: thread #\" + i + \": made \" + late_count +\n-                               \" late calls to java.lang.Thread.setPriority()\");\n-            System.out.println(\"INFO: thread #\" + i + \": N_LATE_CALLS==\" +\n-                               N_LATE_CALLS + \" value is \" +\n-                               ((late_count >= N_LATE_CALLS) ? \"NOT \" : \"\") +\n-                               \"large enough to cause a Thread.setPriority() \" +\n-                               \"call after thread exit.\");\n+            thread.setPriority(prio);\n@@ -99,1 +104,1 @@\n-                threads[i].join();\n+                thread.join();\n@@ -103,5 +108,1 @@\n-            threads[i].setPriority(prio);\n-            if (threads[i].isAlive()) {\n-                throw new Error(\"Expected !Thread.isAlive() after thread #\" +\n-                                i + \" has been join()'ed\");\n-            }\n+            thread.setPriority(prio);\n@@ -110,0 +111,3 @@\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n+\n@@ -116,0 +120,9 @@\n+\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + PROG_NAME + \" [time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    time_max  max looping time in seconds\");\n+        System.err.println(\"              (default is \" + DEF_TIME_MAX +\n+                           \" seconds)\");\n+        System.exit(1);\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/SetPriorityAtExit.java","additions":51,"deletions":38,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8167108\n+ * @bug 8167108 8266130\n@@ -28,1 +28,1 @@\n- * @run main\/othervm -Xlog:thread+smr=debug StopAtExit\n+ * @run main\/othervm StopAtExit\n@@ -35,2 +35,2 @@\n-    final static int N_THREADS = 32;\n-    final static int N_LATE_CALLS = 1000;\n+    private final static int DEF_TIME_MAX = 30;  \/\/ default max # secs to test\n+    private final static String PROG_NAME = \"StopAtExit\";\n@@ -47,2 +47,1 @@\n-                \/\/ Wait for main thread to interrupt us so we\n-                \/\/ can race to exit.\n+                \/\/ Wait for main thread to tell us to race to the exit.\n@@ -51,1 +50,1 @@\n-                \/\/ ignore because we expect one\n+                throw new RuntimeException(\"Unexpected: \" + e);\n@@ -61,1 +60,11 @@\n-        StopAtExit threads[] = new StopAtExit[N_THREADS];\n+        int timeMax = 0;\n+        if (args.length == 0) {\n+            timeMax = DEF_TIME_MAX;\n+        } else {\n+            try {\n+                timeMax = Integer.parseUnsignedInt(args[0]);\n+            } catch (NumberFormatException nfe) {\n+                System.err.println(\"'\" + args[0] + \"': invalid timeMax value.\");\n+                usage();\n+            }\n+        }\n@@ -63,4 +72,9 @@\n-        for (int i = 0; i < N_THREADS; i++ ) {\n-            threads[i] = new StopAtExit();\n-            int late_count = 1;\n-            threads[i].start();\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long count = 0;\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+\n+            StopAtExit thread = new StopAtExit();\n+            thread.start();\n@@ -69,8 +83,6 @@\n-                threads[i].startSyncObj.await();\n-\n-                \/\/ This interrupt() call will break the worker out\n-                \/\/ of the exitSyncObj.await() call and the stop()\n-                \/\/ calls will come in during thread exit.\n-                threads[i].interrupt();\n-                for (; late_count <= N_LATE_CALLS; late_count++) {\n-                    threads[i].stop();\n+                thread.startSyncObj.await();\n+                \/\/ Tell the worker thread to race to the exit and the\n+                \/\/ Thread.stop() calls will come in during thread exit.\n+                thread.exitSyncObj.countDown();\n+                while (true) {\n+                    thread.stop();\n@@ -78,1 +90,1 @@\n-                    if (!threads[i].isAlive()) {\n+                    if (!thread.isAlive()) {\n@@ -93,8 +105,0 @@\n-            System.out.println(\"INFO: thread #\" + i + \": made \" + late_count +\n-                               \" late calls to java.lang.Thread.stop()\");\n-            System.out.println(\"INFO: thread #\" + i + \": N_LATE_CALLS==\" +\n-                               N_LATE_CALLS + \" value is \" +\n-                               ((late_count >= N_LATE_CALLS) ? \"NOT \" : \"\") +\n-                               \"large enough to cause a Thread.stop() \" +\n-                               \"call after thread exit.\");\n-\n@@ -102,1 +106,1 @@\n-                threads[i].join();\n+                thread.join();\n@@ -106,5 +110,1 @@\n-            threads[i].stop();\n-            if (threads[i].isAlive()) {\n-                throw new Error(\"Expected !Thread.isAlive() after thread #\" +\n-                                i + \" has been join()'ed\");\n-            }\n+            thread.stop();\n@@ -113,0 +113,3 @@\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n+\n@@ -119,0 +122,9 @@\n+\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + PROG_NAME + \" [time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    time_max  max looping time in seconds\");\n+        System.err.println(\"              (default is \" + DEF_TIME_MAX +\n+                           \" seconds)\");\n+        System.exit(1);\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/StopAtExit.java","additions":48,"deletions":36,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Non jar file in the classpath will be skipped during dump time and runtime.\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @compile test-classes\/Hello.java\n+ * @compile test-classes\/HelloMore.java\n+ * @run driver NonJarInClasspath\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class NonJarInClasspath {\n+\n+    public static void main(String[] args) throws Exception {\n+        String appJar = JarBuilder.getOrCreateHelloJar();\n+        String appJar2 = JarBuilder.build(\"hellomore\", \"HelloMore\");\n+\n+        String outDir = CDSTestUtils.getOutputDir();\n+        String newFile = \"non-exist.jar\";\n+        String nonJarPath = outDir + File.separator + newFile;\n+        String classPath = appJar + File.pathSeparator + nonJarPath + File.pathSeparator + appJar2;\n+        File nonJar = new File(outDir, newFile);\n+        nonJar.createNewFile();\n+\n+        TestCommon.testDump(classPath, TestCommon.list(\"Hello\", \"HelloMore\"));\n+\n+        TestCommon.run(\n+            \"-cp\", classPath,\n+            \"-Xlog:class+load\",\n+            \"Hello\")\n+          .assertNormalExit(out -> {\n+              out.shouldContain(\"Hello source: shared objects file\");\n+          });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/NonJarInClasspath.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -32,2 +32,2 @@\n- * @run main RedefineRecord buildagent\n- * @run main\/othervm\/timeout=6000 RedefineRecord runtest\n+ * @run driver RedefineRecord buildagent\n+ * @run driver\/timeout=6000 RedefineRecord runtest\n","filename":"test\/hotspot\/jtreg\/runtime\/records\/RedefineRecord.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n- * @run main\/othervm RedefinePermittedSubclass buildagent\n- * @run main\/othervm\/timeout=6000 RedefinePermittedSubclass runtest\n+ * @run driver RedefinePermittedSubclass buildagent\n+ * @run driver\/timeout=6000 RedefinePermittedSubclass runtest\n@@ -131,0 +131,1 @@\n+            output.shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/runtime\/sealedClasses\/RedefinePermittedSubclass.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n- * @run main\/othervm RedefineSealedClass buildagent\n- * @run main\/othervm\/timeout=6000 RedefineSealedClass runtest\n+ * @run driver RedefineSealedClass buildagent\n+ * @run driver\/timeout=6000 RedefineSealedClass runtest\n@@ -113,0 +113,1 @@\n+            output.shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/runtime\/sealedClasses\/RedefineSealedClass.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * @run main\/othervm OverriderMsg\n+ * @run driver OverriderMsg\n","filename":"test\/hotspot\/jtreg\/runtime\/verifier\/OverriderMsg.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,2 @@\n- * @run main\/othervm TestANewArray 49\n- * @run main\/othervm TestANewArray 52\n+ * @run driver TestANewArray 49\n+ * @run driver TestANewArray 52\n","filename":"test\/hotspot\/jtreg\/runtime\/verifier\/TestANewArray.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,4 +40,4 @@\n- * @run main\/othervm TestMultiANewArray 49\n- * @run main\/othervm TestMultiANewArray 50\n- * @run main\/othervm TestMultiANewArray 51\n- * @run main\/othervm TestMultiANewArray 52\n+ * @run driver TestMultiANewArray 49\n+ * @run driver TestMultiANewArray 50\n+ * @run driver TestMultiANewArray 51\n+ * @run driver TestMultiANewArray 52\n","filename":"test\/hotspot\/jtreg\/runtime\/verifier\/TestMultiANewArray.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main AttachNegativePidTest\n+ * @run driver AttachNegativePidTest\n","filename":"test\/hotspot\/jtreg\/serviceability\/attach\/AttachNegativePidTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main AttachSetGetFlag\n+ * @run driver AttachSetGetFlag\n","filename":"test\/hotspot\/jtreg\/serviceability\/attach\/AttachSetGetFlag.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main AttachWithStalePidFile\n+ * @run driver AttachWithStalePidFile\n","filename":"test\/hotspot\/jtreg\/serviceability\/attach\/AttachWithStalePidFile.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main RemovingUnixDomainSocketTest\n+ * @run driver RemovingUnixDomainSocketTest\n","filename":"test\/hotspot\/jtreg\/serviceability\/attach\/RemovingUnixDomainSocketTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/CodeHeapAnalyticsParams.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,2 @@\n+        pipe = IOPipe.startDebuggerPipe(binder);\n+\n@@ -69,2 +71,0 @@\n-        pipe = new IOPipe(debuggee);\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/framework\/TestProcessLauncher.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-        if (cmd.equals(\"quit\")) {\n+        if (\"quit\".equals(cmd)) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/framework\/process\/TestJavaProcess.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/gc\/RunFinalizationTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8212155\n+ * @summary Test concurrent enabling and posting of DynamicCodeGenerated events.\n+ * @requires vm.jvmti\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:DynamicCodeGenerated DynamicCodeGeneratedTest\n+ *\/\n+\n+import java.lang.ref.Reference;\n+\n+public class DynamicCodeGeneratedTest {\n+    static {\n+        System.loadLibrary(\"DynamicCodeGenerated\");\n+    }\n+    public static native void changeEventNotificationMode();\n+\n+    public static void main(String[] args) {\n+        \/\/ Try to enable DynamicCodeGenerated event while it is posted\n+        \/\/ using JvmtiDynamicCodeEventCollector from VtableStubs::find_stub\n+        Thread t = new Thread(() -> {\n+            changeEventNotificationMode();\n+        });\n+        t.setDaemon(true);\n+        t.start();\n+\n+        for (int i = 0; i < 2000; i++) {\n+            new Thread(() -> {\n+                String result = \"string\" + System.currentTimeMillis();\n+                Reference.reachabilityFence(result);\n+            }).start();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/DynamicCodeGenerated\/DynamicCodeGeneratedTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include <jvmti.h>\n+\n+static jvmtiEnv* jvmti = NULL;\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+JNIEXPORT\n+void JNICALL Java_DynamicCodeGeneratedTest_changeEventNotificationMode(JNIEnv* jni, jclass cls) {\n+  while (true) {\n+    jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_DYNAMIC_CODE_GENERATED, NULL);\n+    jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_DYNAMIC_CODE_GENERATED, NULL);\n+  }\n+}\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+void JNICALL DynamicCodeGenerated(jvmtiEnv* jvmti, const char* name, const void* address, jint length) {\n+\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM* vm, char* options, void* reserved) {\n+    vm->GetEnv((void**)&jvmti, JVMTI_VERSION_1_0);\n+    jvmtiEventCallbacks callbacks;\n+    memset(&callbacks, 0, sizeof(callbacks));\n+    callbacks.DynamicCodeGenerated = DynamicCodeGenerated;\n+    jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+\n+    return 0;\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/DynamicCodeGenerated\/libDynamicCodeGenerated.cpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -42,1 +42,1 @@\n- * @run main GetObjectSizeClass\n+ * @run driver GetObjectSizeClass\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetObjectSizeClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n- * @run main RedefineLeak buildagent\n- * @run main\/othervm\/timeout=6000  RedefineLeak runtest\n+ * @run driver RedefineLeak buildagent\n+ * @run driver\/timeout=6000  RedefineLeak runtest\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineLeak.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main TestLambdaFormRetransformation\n+ * @run driver TestLambdaFormRetransformation\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/TestLambdaFormRetransformation.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @run main TestRedefineWithUnresolvedClass\n+ * @run driver TestRedefineWithUnresolvedClass\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/TestRedefineWithUnresolvedClass.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/serviceability\/logging\/TestBasicLogOutput.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/serviceability\/logging\/TestDefaultLogOutput.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @summary Ensure proper parsing of unquoted full output names for -Xlog arguments.\n@@ -28,0 +27,2 @@\n+ * @summary Ensure proper parsing of unquoted full output names for -Xlog arguments.\n+ * @requires vm.flagless\n@@ -63,0 +64,1 @@\n+            Asserts.assertFalse(file.exists());\n@@ -70,1 +72,1 @@\n-            file.deleteOnExit(); \/\/ Clean up after test\n+            file.delete();\n","filename":"test\/hotspot\/jtreg\/serviceability\/logging\/TestFullNames.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/serviceability\/logging\/TestMultipleXlogArgs.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/serviceability\/logging\/TestQuotedLogOutputs.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\/timeout=2400 CDSJMapClstats\n+ * @run driver\/timeout=2400 CDSJMapClstats\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/CDSJMapClstats.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @run main\/othervm ClhsdbDumpclass\n+ * @run driver ClhsdbDumpclass\n@@ -73,2 +73,2 @@\n-            launcher.addToolArg(APP_DOT_CLASSNAME);\n-            System.out.println(\"> javap \" + APP_DOT_CLASSNAME);\n+            launcher.addToolArg(classFile.toString());\n+            System.out.println(\"> javap \" + classFile.toString());\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbDumpclass.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * @run main\/othervm ClhsdbFlags\n+ * @run driver ClhsdbFlags\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbFlags.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * @run main\/othervm ClhsdbJstackXcompStress\n+ * @run driver ClhsdbJstackXcompStress\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbJstackXcompStress.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run main DeadlockDetectionTest\n+ * @run driver DeadlockDetectionTest\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/DeadlockDetectionTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main JhsdbThreadInfoTest\n+ * @run driver JhsdbThreadInfoTest\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/JhsdbThreadInfoTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n- * @run main TestCpoolForInvokeDynamic\n+ * @run driver TestCpoolForInvokeDynamic\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestCpoolForInvokeDynamic.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n- * @run main TestDefaultMethods\n+ * @run driver TestDefaultMethods\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestDefaultMethods.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n- * @run main\/othervm TestHeapDumpForInvokeDynamic\n+ * @run driver TestHeapDumpForInvokeDynamic\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestHeapDumpForInvokeDynamic.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @run main\/othervm TestJhsdbJstackLineNumbers\n+ * @run driver TestJhsdbJstackLineNumbers\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackLineNumbers.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm TestJhsdbJstackLock\n+ * @run driver TestJhsdbJstackLock\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackLock.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * @run main\/othervm TestJhsdbJstackMixed\n+ * @run driver TestJhsdbJstackMixed\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackMixed.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * @run main TestObjectMonitorIterate\n+ * @run driver TestObjectMonitorIterate\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestObjectMonitorIterate.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n- * @run main\/othervm TestRevPtrsForInvokeDynamic\n+ * @run driver TestRevPtrsForInvokeDynamic\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestRevPtrsForInvokeDynamic.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * @run main\/othervm TestSysProps\n+ * @run driver TestSysProps\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestSysProps.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n- * @run main JMapHProfLargeHeapTest\n+ * @run driver JMapHProfLargeHeapTest\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/jmap-hprof\/JMapHProfLargeHeapTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * @run main\/othervm ClhsdbAttachToDebugServer\n+ * @run driver ClhsdbAttachToDebugServer\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/sadebugd\/ClhsdbAttachToDebugServer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @run main\/othervm ClhsdbTestConnectArgument\n+ * @run driver ClhsdbTestConnectArgument\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/sadebugd\/ClhsdbTestConnectArgument.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @run main\/othervm DebugdConnectTest\n+ * @run driver DebugdConnectTest\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/sadebugd\/DebugdConnectTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * @run main\/othervm DisableRegistryTest\n+ * @run driver DisableRegistryTest\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/sadebugd\/DisableRegistryTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @run main\/othervm PmapOnDebugdTest\n+ * @run driver PmapOnDebugdTest\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/sadebugd\/PmapOnDebugdTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * @run main\/othervm RunCommandOnServerTest\n+ * @run driver RunCommandOnServerTest\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/sadebugd\/RunCommandOnServerTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @run main\/othervm SADebugDTest\n+ * @run driver SADebugDTest\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/sadebugd\/SADebugDTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.examples;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.test.TestVM; \/\/ Only used for Javadocs\n+\n+\/*\n+ * @test\n+ * @summary Example test to use the new test framework.\n+ * @library \/test\/lib \/\n+ * @run driver ir_framework.examples.BaseTestExample\n+ *\/\n+\n+\/**\n+ * If there is no warm up specified the Test Framework will do the following:\n+ * <ol>\n+ *     <li><p>Invoke @Test method {@link TestVM#WARMUP_ITERATIONS} many times.<\/li>\n+ *     <li><p>Then do compilation of @Test method. <b>(**)<\/b><\/li>\n+ *     <li><p>Invoke @Test method once again<\/li>\n+ * <\/ol>\n+ * <p>\n+ *\n+ * Configurable things for simple tests (no @Run or @Check) at @Test method:\n+ * <ul>\n+ *     <li><p>compLevel: Specify at which compilation level the test should be compiled by the framework at step <b>(**)<\/b>.\n+ *                       If {@link CompLevel#WAIT_FOR_COMPILATION} is specified, the framework will continue invoke the\n+ *                       method until HotSpot compiles it. If it is not compiled after 10s, an exception is thrown.<\/li>\n+ *     <li><p>@Warmup: Change warm-up iterations of test (defined by default by TestVM.WARMUP_ITERATIONS)<\/li>\n+ *     <li><p>@Arguments: If a @Test method specifies arguments, you need to provide arguments by using @Arguments such\n+ *                        that the framework knows how to call the method. If you need more complex values, use @Run.<\/li>\n+ *     <li><p>@IR: Arbitrary number of @IR rules.<\/li>\n+ * <\/ul>\n+ *\n+ * @see Test\n+ * @see Arguments\n+ * @see Warmup\n+ * @see TestFramework\n+ *\/\n+public class BaseTestExample {\n+    int iFld;\n+\n+    public static void main(String[] args) {\n+        TestFramework.run(); \/\/ equivalent to TestFramework.run(BaseTestExample.class)\n+    }\n+\n+    \/\/ Test without arguments.\n+    @Test\n+    public void mostBasicTest() {\n+        iFld = 42;\n+    }\n+\n+    \/\/ Test with arguments. Use Argument class to choose a value.\n+    \/\/ Object arguments need to have an associated default constructor in its class.\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.MAX})\n+    public void basicTestWithArguments(int x, long y) {\n+        iFld = x;\n+    }\n+\n+    \/\/ @Warmup needs to be positive or zero. In case of zero, the method is directly compiled (simulated -Xcomp).\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.MAX})\n+    @Warmup(100)\n+    public void basicTestWithDifferentWarmup(int x, long y) {\n+        iFld = x;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/examples\/BaseTestExample.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.examples;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.test.TestVM; \/\/ Only used for Javadocs\n+\n+\/*\n+ * @test\n+ * @summary Example test to use the new test framework.\n+ * @library \/test\/lib \/\n+ * @run driver ir_framework.examples.CheckedTestExample\n+ *\/\n+\n+\/**\n+ * If there is no non-default warm-up specified, the Test Framework will do the following:\n+ * <ol>\n+ *     <li><p>Invoke @Test method {@link TestVM#WARMUP_ITERATIONS} many times.<\/li>\n+ *     <li><p>By default, after each invocation, the @Check method of the @Test method is invoked. This can be disabled\n+ *            by using {@link CheckAt#COMPILED}<\/li>\n+ *     <li><p>After the warm-up, the @Test method is compiled.<\/li>\n+ *     <li><p>Invoke @Test method once again and then always invoke the @Check method once again.<\/li>\n+ * <\/ol>\n+ * <p>\n+ *\n+ * Configurable things for checked tests:\n+ * <ul>\n+ *     <li><p>At @Test method:<\/li>\n+ *     <ul>\n+ *         <li><p>@Warmup: Change warm-up iterations of test (defined by default by TestVM.WARMUP_ITERATIONS)<\/li>\n+ *         <li><p>@Arguments: If a @Test method specifies arguments, you need to provide arguments by using @Arguments\n+ *                            such that the framework knows how to call the method. If you need more complex values, use a\n+ *                            custom run test with @Run.<\/li>\n+ *         <li><p>@IR: Arbitrary number of @IR rules.<\/li>\n+ *     <\/ul>\n+ *     <li><p>At @Check method:<\/li>\n+ *     <ul>\n+ *         <li><p>{@link Check#when}: When should the @Check method be invoked.<\/li>\n+ *         <li><p>No @IR annotations.<\/li>\n+ *     <\/ul>\n+ * <\/ul>\n+ *\n+ * @see Check\n+ * @see Test\n+ * @see Arguments\n+ * @see Warmup\n+ * @see TestFramework\n+ *\/\n+public class CheckedTestExample {\n+\n+    public static void main(String[] args) {\n+        TestFramework.run(); \/\/ equivalent to TestFramework.run(CheckedTestExample.class)\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT) \/\/ As with normal tests, you need to tell the framework what the argument is.\n+    @Warmup(100) \/\/ As with normal tests, you can specify the warmup iterations.\n+    public int test(int x) {\n+        return 42;\n+    }\n+\n+    \/\/ Check method for test(). Invoked directly after test() by the Test Framework.\n+    @Check(test = \"test\") \/\/ Specify the @Test method for which this method is a check.\n+    public void basicCheck() {\n+        \/\/ Do some checks after an invocation.\n+    }\n+\n+    @Test\n+    public int test2() {\n+        return 42;\n+    }\n+\n+    \/\/ This version of @Check passes the return value from test2() as an argument.\n+    \/\/ The return type and the parameter type must match.\n+    @Check(test = \"test2\")\n+    public void checkWithReturn(int returnValue) {\n+        \/\/ Do some checks after an invocation.\n+        if (returnValue != 42) {\n+            throw new RuntimeException(\"Must match\");\n+        }\n+    }\n+\n+    @Test\n+    public int test3() {\n+        return 42;\n+    }\n+\n+    \/\/ This version of @Check passes a TestInfo object to the check which contains some additional information about the test.\n+    @Check(test = \"test3\")\n+    public void checkWithTestInfo(TestInfo info) {\n+        \/\/ Do some checks after an invocation. Additional queries with TestInfo.\n+        if (!info.isWarmUp()) {\n+            \/\/ ...\n+        }\n+    }\n+\n+    @Test\n+    public int test4() {\n+        return 42;\n+    }\n+\n+    \/\/ This version of @Check passes the return value and a TestInfo object to the check which contains some additional\n+    \/\/ information about the test. The order of the arguments is important. The return value must come first and the\n+    \/\/ the TestInfo parameter second. Any other combination or use of different arguments are forbidden for @Check methods.\n+    @Check(test = \"test4\")\n+    public void checkWithReturnAndTestInfo(int returnValue, TestInfo info) {\n+        \/\/ Do some checks after an invocation. Additional queries with TestInfo.\n+        if (returnValue != 42) {\n+            throw new RuntimeException(\"Must match\");\n+        }\n+        if (!info.isWarmUp()) {\n+            \/\/ ...\n+        }\n+    }\n+\n+    @Test\n+    public int test5() {\n+        return 42;\n+    }\n+\n+    \/\/ Check method for test5() is only invoked once warmup is finished and test() has been compiled by the Test Framework.\n+    @Check(test = \"test5\", when = CheckAt.COMPILED) \/\/ Specify the @Test method for which this method is a check.\n+    public void checkAfterCompiled(TestInfo info) {\n+        \/\/ Do some checks after compilation.\n+        TestFramework.assertCompiled(info.getTest()); \/\/ Test is compiled by framework after warm-up.\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/examples\/CheckedTestExample.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.examples;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.test.TestVM; \/\/ Only used for Javadocs\n+\n+\/*\n+ * @test\n+ * @summary Example test to use the new test framework.\n+ * @library \/test\/lib \/\n+ * @run driver ir_framework.examples.CustomRunTestExample\n+ *\/\n+\n+\/**\n+ * If there is no warm-up specified, the Test Framework will do the following:\n+ * <ol>\n+ *     <li><p>Invoke @Run method {@link TestVM#WARMUP_ITERATIONS} many times. Note that the @Run method\n+ *            is responsible to invoke the @Test methods to warm it up properly. This is not done by the framework. Not\n+ *            invoking a @Test method will result in an -Xcomp like compilation of the method as there is no profile\n+ *            information for it. The @Run method can do any arbitrary argument setup and return value verification and\n+ *            can invoke the @Test methods multiple times in a single invocation of the @Run method or even skip some\n+ *            test invocations.<\/li>\n+ *     <li><p>After the warm-up, the @Test methods are compiled (there can be multiple @Test methods).<\/li>\n+ *     <li><p>Invoke the @Run method once again.<\/li>\n+ * <\/ol>\n+ * <p>\n+ *\n+ * Configurable things for custom run tests:\n+ * <ul>\n+ *     <li><p>At @Test methods:<\/li>\n+ *     <ul>\n+ *         <li><p>@IR: Arbitrary number of @IR rules.<\/li>\n+ *         <li><p>No @Warmup, this must be set at @Run method.<\/li>\n+ *         <li><p>No @Arguments, the arguments are set by @Run method.<\/li>\n+ *     <\/ul>\n+ *     <li><p>At @Run method:<\/li>\n+ *     <ul>\n+ *         <li><p>@Warmup: Change warm-up iterations of @Run method (defined by default by\n+ *                         TestVM.WARMUP_ITERATIONS)<\/li>\n+ *         <li><p>{@link Run#test}: Specify any number of @Test methods. They cannot be shared with other @Check or @Run\n+ *                                  methods.<\/li>\n+ *         <li><p>{@link Run#mode}: Choose between normal invocation as described above or {@link RunMode#STANDALONE}.\n+ *                                  STANDALONE only invokes the @Run method once without warm-up or a compilation by the\n+ *                                  Test Framework. The only thing done by the framework is the verification of any @IR\n+ *                                  rules afterwards. The STANDALONE @Run method needs to make sure that a C2 compilation\n+ *                                  is reliably triggered if there are any @IR rules.<\/li>\n+ *         <li><p>No @IR annotations<\/li>\n+ *     <\/ul>\n+ * <\/ul>\n+ *\n+ * @see Run\n+ * @see Test\n+ * @see RunMode\n+ * @see TestFramework\n+ *\/\n+public class CustomRunTestExample {\n+\n+    public static void main(String[] args) {\n+        TestFramework.run(); \/\/ equivalent to TestFramework.run(CustomRunTestExample.class)\n+    }\n+\n+    @Test\n+    public int test(int x) {\n+        return x;\n+    }\n+\n+    \/\/ Run method for test(). Invoked directly by Test Framework instead of test().\n+    \/\/ Can do anything you like. It's also possible to skip or do multiple invocations of test()\n+    @Run(test = \"test\") \/\/ Specify the @Test method for which this method is a runner.\n+    public void basicRun() {\n+        int returnValue = test(34);\n+        if (returnValue != 34) {\n+            throw new RuntimeException(\"Must match\");\n+        }\n+    }\n+\n+    @Test\n+    public int test2(int x) {\n+        return x;\n+    }\n+\n+    \/\/ This version of @Run passes the RunInfo object as an argument. No other arguments and combiniations are allowed.\n+    @Run(test = \"test2\")\n+    public void runWithRunInfo(RunInfo info) {\n+        \/\/ We could also skip some invocations. This might have an influence on possible @IR rules, need to be careful.\n+        if (info.getRandom().nextBoolean()) {\n+            int returnValue = test(34);\n+            if (returnValue != 34) {\n+                throw new RuntimeException(\"Must match\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public int test3(int x) {\n+        return x;\n+    }\n+\n+    \/\/ This version of @Run uses a user defined @Warmup.\n+    @Run(test = \"test3\")\n+    @Warmup(100)\n+    public void runWithWarmUp() {\n+        int returnValue = test3(34);\n+        if (returnValue != 34) {\n+            throw new RuntimeException(\"Must match\");\n+        }\n+    }\n+\n+    @Test\n+    public int test4(int x) {\n+        return x;\n+    }\n+\n+    \/\/ This version of @Run is only invoked once by the Test Framework. There is no warm-up and no compilation done\n+    \/\/ by the Test Framework. The only thing done by the framework is @IR rule verification.\n+    @Run(test = \"test4\", mode = RunMode.STANDALONE)\n+    public void runOnlyOnce() {\n+        int returnValue = test4(34);\n+        if (returnValue != 34) {\n+            throw new RuntimeException(\"Must match\");\n+        }\n+    }\n+\n+    @Test\n+    public int test5(int x) {\n+        return x;\n+    }\n+\n+    @Test\n+    public int test6(int x) {\n+        return x;\n+    }\n+\n+    \/\/ This version of @Run can run multiple test methods and get them IR checked as part of this custom run test.\n+    @Run(test = {\"test5\", \"test6\"})\n+    public void runMultipleTests() {\n+        int returnValue = test5(34);\n+        if (returnValue != 34) {\n+            throw new RuntimeException(\"Must match\");\n+        }\n+        returnValue = test6(42);\n+        if (returnValue != 42) {\n+            throw new RuntimeException(\"Must match\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/examples\/CustomRunTestExample.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.examples;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.driver.IRViolationException;\n+\n+\/*\n+ * @test\n+ * @summary Example test to use the new test framework.\n+ * @library \/test\/lib \/\n+ * @run driver ir_framework.examples.IRExample\n+ *\/\n+\n+\/**\n+ * Multiple @IR rules can be specified at @Test methods. The framework performs a regex based match on the PrintIdeal\n+ * and PrintOptoAssembly of the run test VM. Some default string regexes for IR nodes are defined in the framework\n+ * IRNode class. There are two kinds of checks:\n+ * <ul>\n+ *     <li><p>{@link IR#failOn}: One or more (IR node) regexes that are not allowed to occur in the IR (neither in\n+ *                               PrintIdeal nor in PrintOptoAssembly)<\/li>\n+ *     <li><p>{@link IR#counts}: One or more regexes-count pairs specifies how often an (IR node) regex must be found in\n+ *                               PrintIdeal and PrintOptoAssembly.<\/li>\n+ * <\/ul>\n+ * <p>\n+ *\n+ * One might also want to restrict the application of certain @IR rules depending on the used flags in the test VM.\n+ * These could be flags defined by the user or by JTreg. In the latter case, the flags must be whitelisted (see\n+ * {@link TestFramework}) most of them should not have an impact on the IR except for different GC flags which should\n+ * be considered) to enable a verification by the framework (see below). The @IR rules thus have an option to restrict\n+ * their application:\n+ * <ul>\n+ *     <li><p>{@link IR#applyIf}: Only apply a rule if a flag has a certain value<\/li>\n+ *     <li><p>{@link IR#applyIfNot}: Only apply a rule if a flag has NOT a certain value (inverse of applyIf)<\/li>\n+ *     <li><p>{@link IR#applyIfAnd}: Only apply a rule if all flags have the specified value<\/li>\n+ *     <li><p>{@link IR#applyIfOr}: Only apply a rule if at least one flag has the specified value<\/li>\n+ * <\/ul>\n+ * <p>\n+ *\n+ * The framework, however, does not perform the verification if:\n+ * <ul>\n+ *     <li><p>-DVerifyIR=false is used<\/li>\n+ *     <li><p>The test is run with a non-debug build<\/li>\n+ *     <li><p>-Xcomp, -Xint, -XX:-UseCompile, -XX:CompileThreshold, -DFlipC1C2=true, or -DExcludeRandom=true are used.<\/li>\n+ *     <li><p>JTreg specifies non-whitelisted flags as VM and\/or Javaoptions (could change the IR in an unexpected way)<\/li>\n+ * <\/ul>\n+ *\n+ * @see IR\n+ * @see Test\n+ * @see TestFramework\n+ *\/\n+\/\/ This test is expected to fail when run with JTreg.\n+public class IRExample {\n+    int iFld, iFld2, iFld3;\n+    public static void main(String[] args) {\n+        TestFramework.run(); \/\/ First run tests from IRExample\n+        try {\n+            TestFramework.run(FailingExamples.class); \/\/ Secondly, run tests from FailingExamples\n+        } catch (IRViolationException e) {\n+            \/\/ Expected. Check stderr\/stdout to see how IR failures are reported (always printed, regardless if\n+            \/\/ exception is thrown or not). Uncomment the \"throw\" statement below to get a completely failing test.\n+            \/\/throw e;\n+        }\n+    }\n+\n+    \/\/ Rules with failOn constraint which all pass\n+    @Test\n+    @IR(failOn = IRNode.LOAD) \/\/ 1 default regex\n+    @IR(failOn = {IRNode.LOAD, IRNode.LOOP}) \/\/ 2 default regexes\n+    @IR(failOn = {IRNode.LOAD, \"some regex that does not occur\"}) \/\/ 1 default regex and a user-defined regex\n+    \/\/ Rule with special configurable default regexes. All regexes with a \"_OF\" postfix in IR node expect a\n+    \/\/ second string specifying an additional required information.\n+    @IR(failOn = {IRNode.STORE_OF_FIELD, \"iFld2\", IRNode.LOAD, IRNode.STORE_OF_CLASS, \"Foo\"})\n+    \/\/ Only apply this rule if the VM flag UseZGC is true\n+    @IR(applyIf = {\"UseZGC\", \"true\"}, failOn = IRNode.LOAD)\n+    \/\/ We can also use comparators (<, <=, >, >=, !=, =) to restrict the rules.\n+    \/\/ This rule is only applied if the loop unroll limit is 10 or greater.\n+    @IR(applyIf = {\"LoopUnrollLimit\", \">= 10\"}, failOn = IRNode.LOAD)\n+    public void goodFailOn() {\n+        iFld = 42; \/\/ No load, no loop, no store to iFld2, no store to class Foo\n+    }\n+\n+    \/\/ Rules with counts constraint which all pass\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"2\"}) \/\/ 1 default regex\n+    @IR(counts = {IRNode.LOAD, \"0\"}) \/\/ equivalent to failOn = IRNode.LOAD\n+    @IR(counts = {IRNode.STORE, \"2\",\n+                  IRNode.LOAD, \"0\"}) \/\/ 2 default regexes\n+    @IR(counts = {IRNode.STORE, \"2\",\n+                  \"some regex that does not occur\", \"0\"}) \/\/ 1 default regex and a user-defined regex\n+    \/\/ Rule with special configurable default regexes. All regexes with a \"_OF\" postfix in IR node expect a\n+    \/\/ second string specifying an additional required information.\n+    @IR(counts = {IRNode.STORE_OF_FIELD, \"iFld\", \"1\",\n+                  IRNode.STORE, \"2\",\n+                  IRNode.STORE_OF_CLASS, \"IRExample\", \"2\"})\n+    public void goodCounts() {\n+        iFld = 42; \/\/ No load, store to iFld in class IRExample\n+        iFld2 = 42; \/\/ No load, store to iFld2 in class IRExample\n+    }\n+\n+    \/\/ @IR rules can also specify both type of checks in the same rule\n+    @Test\n+    @IR(failOn = {IRNode.ALLOC,\n+                  IRNode.LOOP},\n+        counts = {IRNode.LOAD, \"2\",\n+                  IRNode.LOAD_OF_FIELD, \"iFld2\", \"1\",\n+                  IRNode.LOAD_OF_CLASS, \"IRExample\", \"2\"})\n+    public void mixFailOnAndCounts() {\n+        iFld = iFld2;\n+        iFld2 = iFld3;\n+    }\n+}\n+\n+class FailingExamples {\n+    int iFld2, iFld3;\n+    IRExample irExample = new IRExample();\n+\n+    \/\/ Rules with failOn constraint which all fail.\n+    @Test\n+    @IR(failOn = IRNode.STORE)\n+    @IR(failOn = {IRNode.STORE, IRNode.LOOP}) \/\/ LOOP regex not found but STORE regex, letting the rule fail\n+    @IR(failOn = {IRNode.LOOP, IRNode.STORE}) \/\/ Order does not matter\n+    @IR(failOn = {IRNode.STORE, IRNode.LOAD}) \/\/ STORE and LOAD regex found, letting the rule fail\n+    @IR(failOn = {\"LoadI\"}) \/\/ LoadI can be found in PrintIdeal letting the rule fail\n+    \/\/ Store to iFld, store, and store to class IRExample, all 3 regexes found letting the rule fail\n+    @IR(failOn = {IRNode.STORE_OF_FIELD, \"iFld\", IRNode.STORE, IRNode.STORE_OF_CLASS, \"IRExample\"})\n+    public void badFailOn() {\n+        irExample.iFld = iFld2; \/\/ Store to iFld in class IRExample, load from iFld2\n+    }\n+\n+\n+    \/\/ Rules with counts constraint which all fail\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"1\"}) \/\/ There are 2 stores\n+    @IR(counts = {IRNode.LOAD, \"0\"}) \/\/ equivalent to failOn = IRNode.LOAD, there is 1 load\n+    @IR(counts = {IRNode.STORE, \"1\",\n+                  IRNode.LOAD, \"1\"}) \/\/ first constraint holds (there is 1 load) but 2 stores, letting this rule fail\n+    @IR(counts = {IRNode.LOAD, \"1\",\n+                  IRNode.STORE, \"1\"}) \/\/ order does not matter\n+    @IR(counts = {\"some regex that does not occur\", \"1\"}) \/\/ user-defined regex does not occur once\n+    \/\/ Rule with special configurable default regexes. All regexes with a \"_OF\" postfix in IR node expect a\n+    \/\/ second string specifying an additional required information.\n+    @IR(counts = {IRNode.STORE_OF_FIELD, \"iFld\", \"2\", \/\/ Only one store to iFld\n+                  IRNode.LOAD, \"2\", \/\/ Only 1 load\n+                  IRNode.STORE_OF_CLASS, \"Foo\", \"1\"}) \/\/ No store to class Foo\n+    public void badCounts() {\n+        irExample.iFld = iFld3; \/\/ No load, store to iFld in class IRExample\n+        iFld2 = 42; \/\/ No load, store to iFld2 in class IRExample\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/examples\/IRExample.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+# Framework internal tests\n+This folder contains tests which test the functionality of the framework. These are run with JTreg and are part of tier testing. All tests are run without additional VM and Javaopts flags. These tests must pass whenever the framework is updated.\n+\n+Additional testing should be performed with the converted Valhalla tests to make sure a changeset is correct (these are part of the Valhalla CI).\n+\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/README.md","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,427 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @requires vm.flagless\n+ * @summary Test different access modifiers an make sure, the framework can access all methods.\n+ * @library \/test\/lib \/\n+ * @run driver ir_framework.tests.TestAccessModifiers\n+ *\/\n+\n+public class TestAccessModifiers {\n+    public static void main(String[] args) {\n+        TestFramework.run(PackagePrivate.class);\n+    }\n+}\n+\n+class PackagePrivate {\n+    @Test\n+    public void test() {\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void test2(int x) {\n+    }\n+\n+    @Test\n+    public static int staticPublicPrivate() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticPublicPrivate\")\n+    private void staticPublicPrivateCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    protected static int staticProtectedPrivate() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticProtectedPrivate\")\n+    private void staticProtectedPrivateCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    static int staticDefaultPrivate() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticDefaultPrivate\")\n+    private void staticDefaultPrivateCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    private static int staticPrivatePrivate() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticPrivatePrivate\")\n+    private void staticPrivatePrivateCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    public static int staticPublicDefault() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticPublicDefault\")\n+    void staticPublicDefaultCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    protected static int staticProtectedDefault() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticProtectedDefault\")\n+    void staticProtectedDefaultCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    static int staticDefaultDefault() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticDefaultDefault\")\n+    void staticDefaultDefaultCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    private static int staticPrivateDefault() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticPrivateDefault\")\n+    void staticPrivateDefaultCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    public static int staticPublicProtected() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticPublicProtected\")\n+    protected void staticPublicProtectedCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    protected static int staticProtectedProtected() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticProtectedProtected\")\n+    protected void staticProtectedProtectedCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    static int staticDefaultProtected() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticDefaultProtected\")\n+    protected void staticDefaultProtectedCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    private static int staticPrivateProtected() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticPrivateProtected\")\n+    protected void staticPrivateProtectedCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    public static int staticPublicPublic() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticPublicPublic\")\n+    public void staticPublicPublicCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    protected static int staticProtectedPublic() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticProtectedPublic\")\n+    public void staticProtectedPublicCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    static int staticDefaultPublic() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticDefaultPublic\")\n+    public void staticDefaultPublicCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    private static int staticPrivatePublic() {\n+        return 42;\n+    }\n+\n+    @Check(test = \"staticPrivatePublic\")\n+    public void staticPrivatePublicCheck(int retValue) {\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    static int staticDefaultPrivate2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticDefaultPrivate2\")\n+    private void staticDefaultPrivateRun() {\n+        int retValue = staticDefaultPrivate2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    private static int staticPrivatePrivate2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticPrivatePrivate2\")\n+    private void staticPrivatePrivateRun() {\n+        int retValue = staticPrivatePrivate2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    public static int staticPublicDefault2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticPublicDefault2\")\n+    void staticPublicDefaultRun() {\n+        int retValue = staticPublicDefault2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    protected static int staticProtectedDefault2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticProtectedDefault2\")\n+    void staticProtectedDefaultRun() {\n+        int retValue = staticProtectedDefault2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    static int staticDefaultDefault2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticDefaultDefault2\")\n+    void staticDefaultDefaultRun() {\n+        int retValue = staticDefaultDefault2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    private static int staticPrivateDefault2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticPrivateDefault2\")\n+    void staticPrivateDefaultRun() {\n+        int retValue = staticPrivateDefault2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    public static int staticPublicProtected2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticPublicProtected2\")\n+    protected void staticPublicProtectedRun() {\n+        int retValue = staticPublicProtected2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    protected static int staticProtectedProtected2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticProtectedProtected2\")\n+    protected void staticProtectedProtectedRun() {\n+        int retValue = staticProtectedProtected2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    static int staticDefaultProtected2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticDefaultProtected2\")\n+    protected void staticDefaultProtectedRun() {\n+        int retValue = staticDefaultProtected2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    private static int staticPrivateProtected2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticPrivateProtected2\")\n+    protected void staticPrivateProtectedRun() {\n+        int retValue = staticPrivateProtected2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    public static int staticPublicPublic2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticPublicPublic2\")\n+    public void staticPublicPublicRun() {\n+        int retValue = staticPublicPublic2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    protected static int staticProtectedPublic2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticProtectedPublic2\")\n+    public void staticProtectedPublicRun() {\n+        int retValue = staticProtectedPublic2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    static int staticDefaultPublic2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticDefaultPublic2\")\n+    public void staticDefaultPublicRun() {\n+        int retValue = staticDefaultPublic2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+    @Test\n+    private static int staticPrivatePublic2() {\n+        return 42;\n+    }\n+\n+    @Run(test = \"staticPrivatePublic2\")\n+    public void staticPrivatePublicRun() {\n+        int retValue = staticPrivatePublic2();\n+        if (retValue != 42) {\n+            throw new RuntimeException(\"Needs to be 42\");\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestAccessModifiers.java","additions":427,"deletions":0,"binary":false,"changes":427,"status":"added"},{"patch":"@@ -0,0 +1,1003 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.Compiler;\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+import jdk.test.lib.Asserts;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true & vm.compiler2.enabled & vm.flagless\n+ * @summary Test test format violations.\n+ * @library \/test\/lib \/\n+ * @run driver ir_framework.tests.TestBadFormat\n+ *\/\n+\n+public class TestBadFormat {\n+\n+    public static void main(String[] args) {\n+        expectTestFormatException(BadNoTests.class);\n+        expectTestFormatException(BadArgumentsAnnotation.class);\n+        expectTestFormatException(BadOverloadedMethod.class);\n+        expectTestFormatException(BadCompilerControl.class);\n+        expectTestFormatException(BadWarmup.class);\n+        expectTestFormatException(BadBaseTests.class);\n+        expectTestFormatException(BadRunTests.class);\n+        expectTestFormatException(BadCheckTest.class);\n+        expectTestFormatException(BadIRAnnotations.class);\n+        expectTestFormatException(BadInnerClassTest.class);\n+        expectTestFormatException(BadCompileClassInitializer.class, BadCompileClassInitializerHelper1.class,\n+                                  BadCompileClassInitializerHelper2.class, BadCompileClassInitializerHelper3.class);\n+    }\n+\n+    private static void expectTestFormatException(Class<?> clazz, Class<?>... helpers) {\n+        try {\n+            if (helpers == null) {\n+                TestFramework.run(clazz);\n+            } else {\n+                new TestFramework(clazz).addHelperClasses(helpers).start();\n+            }\n+        } catch (Exception e) {\n+            if (!(e instanceof TestFormatException)) {\n+                e.printStackTrace();\n+                Asserts.fail(\"Unexpected exception\", e);\n+            }\n+            String msg = e.getMessage();\n+            Violations violations = getViolations(clazz, helpers);\n+            violations.getFailedMethods().forEach(\n+                    f -> Asserts.assertTrue(msg.contains(f),\n+                                            \"Could not find \" + f + \" in violations\" + System.lineSeparator() + msg));\n+            Pattern pattern = Pattern.compile(\"Violations \\\\((\\\\d+)\\\\)\");\n+            Matcher matcher = pattern.matcher(msg);\n+            Asserts.assertTrue(matcher.find(), \"Could not find violations in\" + System.lineSeparator() + msg);\n+            int violationCount = Integer.parseInt(matcher.group(1));\n+            Asserts.assertEQ(violationCount, violations.getViolationCount(), msg);\n+            return;\n+        }\n+        throw new RuntimeException(\"Should catch an exception\");\n+    }\n+\n+    private static Violations getViolations(Class<?> clazz, Class<?>... helpers) {\n+        Violations violations = new Violations();\n+        collectViolations(clazz, violations);\n+        if (helpers != null) {\n+            Arrays.stream(helpers).forEach(c -> collectViolations(c, violations));\n+        }\n+        return violations;\n+    }\n+\n+    private static void collectViolations(Class<?> clazz, Violations violations) {\n+        getViolationsOfClass(clazz, violations);\n+        for (Class<?> c : clazz.getDeclaredClasses()) {\n+            getViolationsOfClass(c, violations);\n+        }\n+    }\n+\n+    private static void getViolationsOfClass(Class<?> clazz, Violations violations) {\n+        ClassFail classFail = clazz.getDeclaredAnnotation(ClassFail.class);\n+        if (classFail != null) {\n+            violations.addFail(clazz);\n+        }\n+        for (Method m : clazz.getDeclaredMethods()) {\n+            NoFail noFail = m.getDeclaredAnnotation(NoFail.class);\n+            if (noFail == null) {\n+                FailCount failCount = m.getDeclaredAnnotation(FailCount.class);\n+                if (failCount != null) {\n+                    violations.addFail(m, failCount.value());\n+                } else {\n+                    violations.addFail(m, 1);\n+                }\n+            } else {\n+                \/\/ Cannot define both annotation at the same method.\n+                Asserts.assertEQ(m.getDeclaredAnnotation(FailCount.class), null);\n+            }\n+        }\n+    }\n+\n+}\n+\n+\/\/ Specify at least one @Test\n+@ClassFail\n+class BadNoTests {\n+\n+}\n+\n+class BadArgumentsAnnotation {\n+\n+    @Test\n+    public void noArgAnnotation(int a) {}\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void argNumberMismatch(int a, int b) {}\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void argNumberMismatch2() {}\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_42)\n+    public void notBoolean(boolean a) {}\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_MINUS_42)\n+    public void notBoolean2(boolean a) {}\n+\n+    @Test\n+    @Arguments(Argument.TRUE)\n+    public void notNumber(int a) {}\n+\n+    @Test\n+    @Arguments(Argument.FALSE)\n+    public void notNumber2(int a) {}\n+\n+    @Test\n+    @Arguments(Argument.BOOLEAN_TOGGLE_FIRST_TRUE)\n+    public void notNumber3(int a) {}\n+\n+    @Test\n+    @Arguments(Argument.BOOLEAN_TOGGLE_FIRST_FALSE)\n+    public void notNumber4(int a) {}\n+\n+    @Test\n+    @Arguments({Argument.BOOLEAN_TOGGLE_FIRST_FALSE, Argument.TRUE})\n+    public void notNumber5(boolean a, int b) {}\n+\n+    @FailCount(2)\n+    @Test\n+    @Arguments({Argument.BOOLEAN_TOGGLE_FIRST_FALSE, Argument.NUMBER_42})\n+    public void notNumber6(int a, boolean b) {}\n+\n+    @FailCount(2)\n+    @Test\n+    @Arguments({Argument.MIN, Argument.MAX})\n+    public void notNumber7(boolean a, boolean b) {}\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void missingDefaultConstructor(ClassNoDefaultConstructor a) {}\n+\n+    @Test\n+    @Arguments(Argument.TRUE)\n+    public void wrongArgumentNumberWithRun(Object o1, Object o2) {\n+    }\n+\n+    \/\/ Also fails: Cannot use @Arguments together with @Run\n+    @Run(test=\"wrongArgumentNumberWithRun\")\n+    public void forRun() {\n+    }\n+\n+    @Test\n+    @Arguments(Argument.TRUE)\n+    public void wrongArgumentNumberWithCheck(Object o1, Object o2) {\n+    }\n+\n+    @NoFail\n+    @Check(test=\"wrongArgumentNumberWithCheck\")\n+    public void forCheck() {\n+    }\n+}\n+\n+class BadOverloadedMethod {\n+\n+    @FailCount(0) \/\/ Combined with both sameName() below\n+    @Test\n+    public void sameName() {}\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void sameName(boolean a) {}\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void sameName(double a) {}\n+}\n+\n+class BadCompilerControl {\n+\n+    @Test\n+    @DontCompile\n+    public void test1() {}\n+\n+    @Test\n+    @ForceCompile\n+    public void test2() {}\n+\n+    @Test\n+    @DontInline\n+    public void test3() {}\n+\n+    @Test\n+    @ForceInline\n+    public void test4() {}\n+\n+    @Test\n+    @ForceInline\n+    @ForceCompile\n+    @DontInline\n+    @DontCompile\n+    public void test5() {}\n+\n+    @DontInline\n+    @ForceInline\n+    public void mix1() {}\n+\n+    @DontCompile\n+    @ForceCompile\n+    public void mix2() {}\n+\n+    @NoFail\n+    @Test\n+    public void test6() {}\n+\n+    @Run(test = \"test6\")\n+    @DontCompile\n+    public void notAtRun() {}\n+\n+    @NoFail\n+    @Test\n+    public void test7() {}\n+\n+    @Run(test = \"test7\")\n+    @ForceCompile\n+    public void notAtRun2() {}\n+\n+    @NoFail\n+    @Test\n+    public void test8() {}\n+\n+    @Run(test = \"test8\")\n+    @DontInline\n+    public void notAtRun3() {}\n+\n+    @NoFail\n+    @Test\n+    public void test9() {}\n+\n+    @Run(test = \"test9\")\n+    @ForceInline\n+    public void notAtRun4() {}\n+\n+    @NoFail\n+    @Test\n+    public void test10() {}\n+\n+    @Run(test = \"test10\")\n+    @ForceInline\n+    @ForceCompile\n+    @DontInline\n+    @DontCompile\n+    public void notAtRun5() {}\n+\n+    @NoFail\n+    @Test\n+    public void test11() {}\n+\n+    @Check(test = \"test11\")\n+    @DontCompile\n+    public void notAtCheck() {}\n+\n+    @NoFail\n+    @Test\n+    public void test12() {}\n+\n+    @Check(test = \"test12\")\n+    @ForceCompile\n+    public void notAtCheck2() {}\n+\n+    @NoFail\n+    @Test\n+    public void test13() {}\n+\n+    @Check(test = \"test13\")\n+    @DontInline\n+    public void notAtCheck3() {}\n+\n+    @NoFail\n+    @Test\n+    public void test14() {}\n+\n+    @Check(test = \"test14\")\n+    @ForceInline\n+    public void notAtCheck4() {}\n+\n+    @NoFail\n+    @Test\n+    public void test15() {}\n+\n+    @Check(test = \"test15\")\n+    @ForceInline\n+    @ForceCompile\n+    @DontInline\n+    @DontCompile\n+    public void notAtCheck5() {}\n+\n+    @ForceCompile(CompLevel.SKIP)\n+    public void invalidSkip1() {}\n+\n+    @ForceCompile(CompLevel.WAIT_FOR_COMPILATION)\n+    public void invalidWaitForCompilation() {}\n+\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    @DontCompile(Compiler.C1)\n+    public void overlappingCompile1() {}\n+\n+    @ForceCompile(CompLevel.C2)\n+    @DontCompile(Compiler.C2)\n+    public void overlappingCompile2() {}\n+\n+    @ForceCompile(CompLevel.ANY)\n+    @DontCompile(Compiler.C1)\n+    public void invalidMix1() {}\n+\n+    @ForceCompile(CompLevel.ANY)\n+    @DontCompile(Compiler.C2)\n+    public void invalidMix2() {}\n+\n+    @ForceCompile(CompLevel.ANY)\n+    @DontCompile\n+    public void invalidMix3() {}\n+}\n+\n+class BadWarmup {\n+\n+    @Warmup(10000)\n+    public void warmUpNonTest() {}\n+\n+    @Test\n+    @Warmup(1)\n+    public void someTest() {}\n+\n+    @FailCount(0) \/\/ Combined with someTest()\n+    @Run(test = \"someTest\")\n+    @Warmup(1)\n+    public void twoWarmups() {}\n+\n+    @Test\n+    @Warmup(-1)\n+    public void negativeWarmup() {}\n+\n+    @NoFail\n+    @Test\n+    public void someTest2() {}\n+\n+    @Run(test = \"someTest2\")\n+    @Warmup(-1)\n+    public void negativeWarmup2() {}\n+\n+    @NoFail\n+    @Test\n+    public void someTest3() {}\n+\n+    @FailCount(2) \/\/ Negative warmup and invoke once\n+    @Run(test = \"someTest3\", mode = RunMode.STANDALONE)\n+    @Warmup(-1)\n+    public void noWarmupAtStandalone() {}\n+\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public void testNoCompLevelStandalone() {}\n+\n+    @Test(compLevel = CompLevel.WAIT_FOR_COMPILATION)\n+    public void testNoCompLevelStandalone2() {}\n+\n+    @NoFail\n+    @Test\n+    public void someTest4() {}\n+\n+    @FailCount(0) \/\/ Negative warmup and invoke once\n+    @Run(test = {\"someTest4\", \"testNoCompLevelStandalone\", \"testNoCompLevelStandalone2\"}, mode = RunMode.STANDALONE)\n+    public void runNoCompLevelStandalone() {}\n+}\n+\n+class BadBaseTests {\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    @FailCount(3) \/\/ No default constructor + parameter + return\n+    public TestInfo cannotUseTestInfoAsParameterOrReturn(TestInfo info) {\n+        return null;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    @FailCount(3) \/\/ No default constructor + parameter + return\n+    public RunInfo cannotUseRunInfoAsParameterOrReturn(RunInfo info) {\n+        return null;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    @FailCount(3) \/\/ No default constructor + parameter + return\n+    public AbstractInfo cannotUseAbstractInfoAsParameterOrReturn(AbstractInfo info) {\n+        return null;\n+    }\n+}\n+\n+class BadRunTests {\n+    @Run(test = \"runForRun2\")\n+    public void runForRun() {}\n+\n+    @Run(test = \"runForRun\")\n+    public void runForRun2() {}\n+\n+    @Test\n+    public void sharedByTwo() {}\n+\n+    @FailCount(0) \/\/ Combined with sharedByTwo()\n+    @Run(test = \"sharedByTwo\")\n+    public void share1() {}\n+\n+    @FailCount(0) \/\/ Combined with sharedByTwo()\n+    @Run(test = \"sharedByTwo\")\n+    public void share2() {}\n+\n+    @Run(test = \"doesNotExist\")\n+    public void noTestExists() {}\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void argTest(int x) {}\n+\n+    @FailCount(0) \/\/ Combined with argTest()\n+    @Run(test = \"argTest\")\n+    public void noArgumentAnnotationForRun() {}\n+\n+    @NoFail\n+    @Test\n+    public void test1() {}\n+\n+    @Run(test = \"test1\")\n+    public void wrongParameters1(int x) {}\n+\n+    @NoFail\n+    @Test\n+    public void test2() {}\n+\n+    @Run(test = \"test2\")\n+    public void wrongParameters(RunInfo info, int x) {}\n+\n+    @Test\n+    public void invalidShare() {}\n+\n+    @FailCount(0) \/\/ Combined with invalidShare()\n+    @Run(test = \"invalidShare\")\n+    public void shareSameTestTwice1() {}\n+\n+    @FailCount(0) \/\/ Combined with invalidShare()\n+    @Run(test = \"invalidShare\")\n+    public void shareSameTestTwice2() {}\n+\n+    @Test\n+    public void invalidShareCheckRun() {}\n+\n+    @FailCount(0) \/\/ Combined with invalidShare()\n+    @Run(test = \"invalidShareCheckRun\")\n+    public void invalidShareCheckRun1() {}\n+\n+    @FailCount(0) \/\/ Combined with invalidShare()\n+    @Check(test = \"invalidShareCheckRun\")\n+    public void invalidShareCheckRun2() {}\n+\n+    @NoFail\n+    @Test\n+    public void testInvalidRunWithArgAnnotation() {}\n+\n+    @Arguments(Argument.DEFAULT)\n+    @Run(test = \"testInvalidRunWithArgAnnotation\")\n+    public void invalidRunWithArgAnnotation(RunInfo info) {}\n+\n+    @NoFail\n+    @Test\n+    public void testRunWithTestInfo() {}\n+\n+    @Run(test = \"testRunWithTestInfo\")\n+    public void invalidRunWithTestInfo(TestInfo info) {}\n+\n+    @Run(test = {})\n+    public void invalidRunWithNoTest() {}\n+\n+    @Run(test = \"\")\n+    public void invalidRunWithEmptyTestName() {}\n+\n+    @NoFail\n+    @Test\n+    public void someExistingTest() {}\n+\n+    @FailCount(2)\n+    @Run(test = {\"unknown1\", \"someExistingTest\", \"unknown2\"})\n+    public void invalidRunWithInvalidTests() {}\n+\n+    @NoFail\n+    @Test\n+    public void testInvalidReuse() {}\n+\n+    @Test\n+    public void testInvalidReuse2() {}\n+\n+    @NoFail\n+    @Test\n+    public void testInvalidReuse3() {}\n+\n+    @FailCount(0)\n+    @Run(test = {\"testInvalidReuse\", \"testInvalidReuse2\"})\n+    public void runInvalidReuse1() {}\n+\n+    @FailCount(0)\n+    @Run(test = {\"testInvalidReuse2\", \"testInvalidReuse3\"})\n+    public void runInvalidReuse2() {}\n+}\n+\n+class BadCheckTest {\n+    @Check(test = \"checkForCheck2\")\n+    public void checkForCheck() {}\n+\n+    @Check(test = \"checkForCheck\")\n+    public void checkForCheck2() {}\n+\n+    @Test\n+    public void sharedByTwo() {}\n+\n+    @FailCount(0) \/\/ Combined with sharedByTwo()\n+    @Check(test = \"sharedByTwo\")\n+    public void share1() {}\n+\n+    @FailCount(0) \/\/ Combined with sharedByTwo()\n+    @Check(test = \"sharedByTwo\")\n+    public void share2() {}\n+\n+    @Check(test = \"doesNotExist\")\n+    public void noTestExists() {}\n+\n+    @NoFail\n+    @Test\n+    public void test1() {}\n+\n+    @Check(test = \"test1\")\n+    public void wrongReturnParameter1(int x) {}\n+\n+    @NoFail\n+    @Test\n+    public short test2() {\n+        return 3;\n+    }\n+\n+    @Check(test = \"test2\")\n+    public void wrongReturnParameter2(int x) {}\n+\n+    @NoFail\n+    @Test\n+    public short test3() {\n+        return 3;\n+    }\n+\n+    @Check(test = \"test3\")\n+    public void wrongReturnParameter3(String x) {}\n+\n+    @NoFail\n+    @Test\n+    public short test4() {\n+        return 3;\n+    }\n+\n+    @Check(test = \"test4\")\n+    public void wrongReturnParameter4(TestInfo info, int x) {} \/\/ Must flip parameters\n+\n+    @NoFail\n+    @Test\n+    public int test5() {\n+        return 3;\n+    }\n+\n+    @Check(test = \"test5\")\n+    public void wrongReturnParameter5(short x, TestInfo info) {}\n+\n+    @Test\n+    public void invalidShare() {}\n+\n+    @FailCount(0) \/\/ Combined with invalidShare()\n+    @Check(test = \"invalidShare\")\n+    public void shareSameTestTwice1() {}\n+\n+    @FailCount(0) \/\/ Combined with invalidShare()\n+    @Check(test = \"invalidShare\")\n+    public void shareSameTestTwice2() {}\n+\n+    @NoFail\n+    @Test\n+    public void testInvalidRunWithArgAnnotation() {}\n+\n+    @Arguments(Argument.DEFAULT)\n+    @Check(test = \"testInvalidRunWithArgAnnotation\")\n+    public void invalidRunWithArgAnnotation(TestInfo info) {}\n+}\n+\n+class BadIRAnnotations {\n+    @IR(failOn = IRNode.CALL)\n+    public void noIRAtNonTest() {}\n+\n+    @NoFail\n+    @Test\n+    public void test() {}\n+\n+    @Run(test = \"test\")\n+    @IR(failOn = IRNode.CALL)\n+    public void noIRAtRun() {}\n+\n+    @NoFail\n+    @Test\n+    public void test2() {}\n+\n+    @Check(test = \"test2\")\n+    @IR(failOn = IRNode.CALL)\n+    public void noIRAtCheck() {}\n+\n+    @Test\n+    @IR\n+    public void mustSpecifyAtLeastOneConstraint() {\n+    }\n+\n+    @FailCount(2)\n+    @Test\n+    @IR\n+    @IR\n+    public void mustSpecifyAtLeastOneConstraint2() {\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"TLABRefillWasteFraction\", \"50\"})\n+    public void mustSpecifyAtLeastOneConstraint3() {\n+    }\n+\n+    @FailCount(3)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"50\"}, applyIfNot = {\"UseTLAB\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"50\", \"UseTLAB\", \"true\"},\n+        applyIfOr = {\"TLABRefillWasteFraction\", \"50\", \"UseTLAB\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"50\"}, applyIfNot = {\"TLABRefillWasteFraction\", \"50\"},\n+        applyIfAnd = {\"TLABRefillWasteFraction\", \"50\", \"UseTLAB\", \"true\"},\n+        applyIfOr = {\"TLABRefillWasteFraction\", \"50\", \"UseTLAB\", \"true\"})\n+    public void onlyOneApply() {}\n+\n+    @FailCount(3)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"50\", \"UseTLAB\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"51\", \"UseTLAB\"})\n+    public void applyIfTooManyFlags() {}\n+\n+    @FailCount(2)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"Bla\"})\n+    public void applyIfMissingValue() {}\n+\n+    @FailCount(2)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIf = {\"PrintIdealGraphFilee\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"Bla\", \"foo\"})\n+    public void applyIfUnknownFlag() {}\n+\n+    @FailCount(5)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIf = {\"PrintIdealGraphFile\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"UseTLAB\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\" \", \" \"})\n+    public void applyIfEmptyValue() {}\n+\n+    @FailCount(5)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"! 34\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"!== 34\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<<= 34\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"=<34\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<\"})\n+    public void applyIfFaultyComparator() {}\n+\n+    @FailCount(3)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"TLABRefillWasteFraction\", \"50\", \"UseTLAB\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"TLABRefillWasteFraction\", \"50\", \"UseTLAB\"})\n+    public void applyIfNotTooManyFlags() {}\n+\n+    @FailCount(2)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"TLABRefillWasteFraction\"})\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"Bla\"})\n+    public void applyIfNotMissingValue() {}\n+\n+    @FailCount(2)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"PrintIdealGraphFilee\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"Bla\", \"foo\"})\n+    public void applyIfNotUnknownFlag() {}\n+\n+    @FailCount(5)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"PrintIdealGraphFile\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"UseTLAB\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\" \", \" \"})\n+    public void applyIfNotEmptyValue() {}\n+\n+    @FailCount(5)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"TLABRefillWasteFraction\", \"! 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"TLABRefillWasteFraction\", \"!== 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"TLABRefillWasteFraction\", \"<<= 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"TLABRefillWasteFraction\", \"=<34\"})\n+    @IR(failOn = IRNode.CALL, applyIfNot = {\"TLABRefillWasteFraction\", \"<\"})\n+    public void applyIfNotFaultyComparator() {}\n+\n+\n+    @FailCount(2)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"50\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"51\", \"UseTLAB\"})\n+    public void applyIfAndNotEnoughFlags() {}\n+\n+    @FailCount(5)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"51\", \"UseTLAB\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"Bla\"})\n+    public void applyIfAndMissingValue() {}\n+\n+    @FailCount(3)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"PrintIdealGraphFilee\", \"true\", \"TLABRefillWasteFraction\", \"< 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"!= 50\", \"Bla\", \"bla\", \"Bla2\", \"bla2\"})\n+    public void applyIfAndUnknownFlag() {}\n+\n+    @FailCount(18)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"PrintIdealGraphFile\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"PrintIdealGraphFile\", \"\", \"PrintIdealGraphFile\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"UseTLAB\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"UseTLAB\", \"\", \"UseTLAB\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"\", \"true\", \"\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"\", \"\", \"\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\" \", \" \", \" \", \" \"})\n+    public void applyIfAndEmptyValue() {}\n+\n+    @FailCount(20)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"! 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"! 34\", \"TLABRefillWasteFraction\", \"! 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"!== 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"!== 34\", \"TLABRefillWasteFraction\", \"=== 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"<<= 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"<<= 34\", \"TLABRefillWasteFraction\", \">>= 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"=<34\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"=<34\", \"TLABRefillWasteFraction\", \"=<34\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"<\"})\n+    @IR(failOn = IRNode.CALL, applyIfAnd = {\"TLABRefillWasteFraction\", \"<\", \"TLABRefillWasteFraction\", \"!=\"})\n+    public void applyIfAndFaultyComparator() {}\n+\n+    @FailCount(2)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"50\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"51\", \"UseTLAB\"})\n+    public void applyIfOrNotEnoughFlags() {}\n+\n+    @FailCount(5)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"51\", \"UseTLAB\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"Bla\"})\n+    public void applyIfOrMissingValue() {}\n+\n+    @FailCount(3)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"PrintIdealGraphFilee\", \"true\", \"TLABRefillWasteFraction\", \"< 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"!= 50\", \"Bla\", \"bla\", \"Bla2\", \"bla2\"})\n+    public void applyIfOrUnknownFlag() {}\n+\n+    @FailCount(18)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"PrintIdealGraphFile\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"PrintIdealGraphFile\", \"\", \"PrintIdealGraphFile\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"UseTLAB\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"UseTLAB\", \"\", \"UseTLAB\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"\", \"true\", \"\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"\", \"\", \"\", \"\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\" \", \" \", \" \", \" \"})\n+    public void applyIfOrEmptyValue() {}\n+\n+    @FailCount(20)\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"! 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"! 34\", \"TLABRefillWasteFraction\", \"! 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"!== 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"!== 34\", \"TLABRefillWasteFraction\", \"=== 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"<<= 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"<<= 34\", \"TLABRefillWasteFraction\", \">>= 34\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"=<34\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"=<34\", \"TLABRefillWasteFraction\", \"=<34\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"<\"})\n+    @IR(failOn = IRNode.CALL, applyIfOr = {\"TLABRefillWasteFraction\", \"<\", \"TLABRefillWasteFraction\", \"!=\"})\n+    public void applyIfOrFaultyComparator() {}\n+\n+\n+    @Test\n+    @FailCount(3)\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"SomeString\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"48\"}) \/\/ valid\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"48.5\"})\n+    public void wrongFlagValueLongFlag() {}\n+\n+    @Test\n+    @FailCount(3)\n+    @IR(failOn = IRNode.CALL, applyIf = {\"UseTLAB\", \"true\"}) \/\/ valid\n+    @IR(failOn = IRNode.CALL, applyIf = {\"UseTLAB\", \"SomeString\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"UseTLAB\", \"48\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"UseTLAB\", \"48.5\"})\n+    public void wrongFlagValueBooleanFlag() {}\n+\n+    @Test\n+    @FailCount(2)\n+    @IR(failOn = IRNode.CALL, applyIf = {\"CompileThresholdScaling\", \"true\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"CompileThresholdScaling\", \"SomeString\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"CompileThresholdScaling\", \"48\"}) \/\/ valid\n+    @IR(failOn = IRNode.CALL, applyIf = {\"CompileThresholdScaling\", \"48.5\"}) \/\/ valid\n+    public void wrongFlagValueDoubleFlag() {}\n+\n+    @Test\n+    @NoFail\n+    @IR(failOn = IRNode.CALL, applyIf = {\"ErrorFile\", \"true\"}) \/\/ valid\n+    @IR(failOn = IRNode.CALL, applyIf = {\"ErrorFile\", \"SomeString\"}) \/\/ valid\n+    @IR(failOn = IRNode.CALL, applyIf = {\"ErrorFile\", \"48\"}) \/\/ valid\n+    @IR(failOn = IRNode.CALL, applyIf = {\"ErrorFile\", \"48.5\"}) \/\/ valid\n+    public void anyValueForStringFlags() {}\n+}\n+\n+@ClassFail\n+class BadInnerClassTest {\n+\n+    class InnerClass {\n+        @Test\n+        public void noTestInInnerClass1() {}\n+\n+        @Test\n+        public void noTestInInnerClass2() {}\n+\n+        @Check(test = \"noTestInInnerClass2\")\n+        public void checkNoTestInInnerClass2() {}\n+\n+        @Test\n+        public void noTestInInnerClass3() {}\n+\n+        @Run(test = \"noTestInInnerClass3\")\n+        public void checkNoTestInInnerClass3() {}\n+    }\n+\n+\n+    static class StaticInnerClass {\n+        @Test\n+        public void noTestInInnerStaticClass1() {}\n+\n+        @Test\n+        public void noTestInStaticInnerClass2() {}\n+\n+        @Check(test = \"noTestInStaticInnerClass2\")\n+        public void checkNoTestInStaticInnerClass2() {}\n+\n+        @Test\n+        public void noTestInStaticInnerClass3() {}\n+\n+        @Run(test = \"noTestInStaticInnerClass3\")\n+        public void checkNoTestInStaticInnerClass3() {}\n+    }\n+}\n+\n+@ForceCompileClassInitializer\n+class BadCompileClassInitializer {\n+    static int iFld = 3;\n+\n+    @Test\n+    @ForceCompileClassInitializer\n+    public void test() {}\n+\n+    @ForceCompileClassInitializer\n+    public void helper() {}\n+}\n+\n+@ClassFail\n+@ForceCompileClassInitializer(CompLevel.SKIP)\n+class BadCompileClassInitializerHelper1 {\n+\n+}\n+\n+@ClassFail\n+@ForceCompileClassInitializer(CompLevel.WAIT_FOR_COMPILATION)\n+class BadCompileClassInitializerHelper2 {\n+\n+}\n+\n+@ClassFail\n+@ForceCompileClassInitializer\n+class BadCompileClassInitializerHelper3 {\n+    \/\/ no <clinit>\n+}\n+\n+class ClassNoDefaultConstructor {\n+    private ClassNoDefaultConstructor(int i) {\n+    }\n+}\n+\n+\/\/ Test specific annotation:\n+\/\/ All methods without such an annotation must occur in the violation messages.\n+@Retention(RetentionPolicy.RUNTIME)\n+@interface NoFail {}\n+\n+\/\/ Test specific annotation:\n+\/\/ Specify a fail count for a method without @NoFail. Use the value 0 if multiple methods are part of the same violation.\n+@Retention(RetentionPolicy.RUNTIME)\n+@interface FailCount {\n+    int value();\n+}\n+\n+\/\/ Class specific annotation:\n+\/\/ All classes with such an annotation have exactly one violation with the clas name in it.\n+@Retention(RetentionPolicy.RUNTIME)\n+@interface ClassFail {}\n+\n+class Violations {\n+    private final List<String> failedMethods = new ArrayList<>();\n+    private int violations;\n+\n+    public int getViolationCount() {\n+        return violations;\n+    }\n+\n+    public List<String> getFailedMethods() {\n+        return failedMethods;\n+    }\n+\n+    public void addFail(Method m, int count) {\n+        failedMethods.add(m.getName());\n+        violations += count;\n+    }\n+\n+    public void addFail(Class<?> c) {\n+        failedMethods.add(c.getName());\n+        violations += 1;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestBadFormat.java","additions":1003,"deletions":0,"binary":false,"changes":1003,"status":"added"},{"patch":"@@ -0,0 +1,1086 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.test.TestVM;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ * @summary Test basics of the framework. This test runs directly the test VM which normally does not happen.\n+ * @library \/test\/lib \/\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch ir_framework.tests.TestBasics\n+ *\/\n+\n+public class TestBasics {\n+    private static boolean wasExecuted = false;\n+    private boolean lastToggleBoolean = true;\n+    private final static int[] executed = new int[100];\n+    private final static int[] executedOnce = new int[5];\n+    private long[] nonFloatingRandomNumbers = new long[10];\n+    private double[] floatingRandomNumbers = new double[10];\n+    private Boolean[] randomBooleans = new Boolean[64];\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Run on same VM to make this test easier as we are not interested in any output processing.\n+        Class<?> c = TestFramework.class; \/\/ Enable JTreg test to compile TestFramework\n+        Method runTestsOnSameVM = TestVM.class.getDeclaredMethod(\"runTestsOnSameVM\", Class.class);\n+        runTestsOnSameVM.setAccessible(true);\n+        runTestsOnSameVM.invoke(null, new Object[]{ null });\n+\n+        if (wasExecuted) {\n+            throw new RuntimeException(\"Executed non @Test method or a method that was not intended to be run\");\n+        }\n+        for (int i = 0; i < executed.length; i++) {\n+            int value = executed[i];\n+            if (value != TestVM.WARMUP_ITERATIONS + 1) {\n+                \/\/ Warmups + 1 C2 compiled invocation\n+                throw new RuntimeException(\"Test \" + i + \"  was executed \" + value + \" times instead stead of \"\n+                                           + (TestVM.WARMUP_ITERATIONS + 1) + \" times.\" );\n+            }\n+        }\n+\n+        for (int value : executedOnce) {\n+            if (value != 1) {\n+                throw new RuntimeException(\"Check function should have been executed exactly once\");\n+            }\n+        }\n+    }\n+\n+    private void clearNonFloatingRandomNumbers() {\n+        nonFloatingRandomNumbers = new long[10];\n+    }\n+\n+    private void clearFloatingRandomNumbers() {\n+        floatingRandomNumbers = new double[10];\n+    }\n+\n+    private void clearRandomBooleans() {\n+        randomBooleans = new Boolean[64];\n+    }\n+\n+    \/\/ Base test, no arguments, directly invoked.\n+    @Test\n+    public void test() {\n+        executed[0]++;\n+    }\n+\n+    \/\/ Not a test\n+    public void noTest() {\n+        wasExecuted = true;\n+    }\n+\n+    \/\/ Not a test\n+    public void test2() {\n+        wasExecuted = true;\n+    }\n+\n+    \/\/ Can overload non- @Test\n+    public static void test2(int i) {\n+        wasExecuted = true;\n+    }\n+\n+    \/\/ Can overload a @Test if it is not a @Test itself.\n+    public static void test(double i) {\n+        wasExecuted = true;\n+    }\n+\n+    @Test\n+    public static void staticTest() {\n+        executed[1]++;\n+    }\n+\n+    @Test\n+    public final void finalTest() {\n+        executed[2]++;\n+    }\n+\n+    @Test\n+    public int returnValueTest() {\n+        executed[3]++;\n+        return 4;\n+    }\n+\n+    \/\/ Base test, with arguments, directly invoked.\n+    \/\/ Specify the argument values with @Arguments\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void byteDefaultArgument(byte x) {\n+        executed[4]++;\n+        if (x != 0) {\n+            throw new RuntimeException(\"Must be 0\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void shortDefaultArgument(short x) {\n+        executed[5]++;\n+        if (x != 0) {\n+            throw new RuntimeException(\"Must be 0\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void intDefaultArgument(int x) {\n+        executed[6]++;\n+        if (x != 0) {\n+            throw new RuntimeException(\"Must be 0\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void longDefaultArgument(long x) {\n+        executed[7]++;\n+        if (x != 0L) {\n+            throw new RuntimeException(\"Must be 0\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void floatDefaultArgument(float x) {\n+        executed[8]++;\n+        if (x != 0.0f) {\n+            throw new RuntimeException(\"Must be 0.0\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void doubleDefaultArgument(double x) {\n+        executed[9]++;\n+        if (x != 0.0f) {\n+            throw new RuntimeException(\"Must be 0.0\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void charDefaultArgument(char x) {\n+        executed[10]++;\n+        if (x != '\\u0000') {\n+            throw new RuntimeException(\"Must be \\u0000\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void booleanDefaultArgument(boolean x) {\n+        executed[11]++;\n+        if (x) {\n+            throw new RuntimeException(\"Must be false\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void stringObjectDefaultArgument(String x) {\n+        executed[12]++;\n+        if (x == null || x.length() != 0) {\n+            throw new RuntimeException(\"Default string object must be non-null and having a length of zero\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    public void defaultObjectDefaultArgument(DefaultObject x) {\n+        executed[13]++;\n+        if (x == null || x.i != 4) {\n+            throw new RuntimeException(\"Default object must not be null and its i field must be 4\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_42)\n+    public void byte42(byte x) {\n+        executed[14]++;\n+        if (x != 42) {\n+            throw new RuntimeException(\"Must be 42\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_42)\n+    public void short42(short x) {\n+        executed[15]++;\n+        if (x != 42) {\n+            throw new RuntimeException(\"Must be 42\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_42)\n+    public void int42(int x) {\n+        executed[16]++;\n+        if (x != 42) {\n+            throw new RuntimeException(\"Must be 42\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_42)\n+    public void long42(long x) {\n+        executed[17]++;\n+        if (x != 42) {\n+            throw new RuntimeException(\"Must be 42\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_42)\n+    public void float42(float x) {\n+        executed[18]++;\n+        if (x != 42.0) {\n+            throw new RuntimeException(\"Must be 42\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_42)\n+    public void double42(double x) {\n+        executed[19]++;\n+        if (x != 42.0) {\n+            throw new RuntimeException(\"Must be 42\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.FALSE)\n+    public void booleanFalse(boolean x) {\n+        executed[20]++;\n+        if (x) {\n+            throw new RuntimeException(\"Must be false\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.TRUE)\n+    public void booleanTrue(boolean x) {\n+        executed[21]++;\n+        if (!x) {\n+            throw new RuntimeException(\"Must be true\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_ONCE)\n+    public void randomByte(byte x) {\n+        executed[22]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_ONCE)\n+    public void randomShort(short x) {\n+        executed[23]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_ONCE)\n+    public void randomInt(int x) {\n+        executed[24]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_ONCE)\n+    public void randomLong(long x) {\n+        executed[25]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_ONCE)\n+    public void randomFloat(float x) {\n+        executed[26]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_ONCE)\n+    public void randomDouble(double x) {\n+        executed[27]++;\n+    }\n+\n+    \/\/ Not executed\n+    public void randomNotExecutedTest(double x) {\n+        wasExecuted = true;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_ONCE)\n+    public void randomBoolean(boolean x) {\n+        executed[28]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.BOOLEAN_TOGGLE_FIRST_FALSE)\n+    public void booleanToggleFirstFalse(boolean x) {\n+        if (executed[29] == 0) {\n+            \/\/ First invocation\n+            if (x) {\n+                throw new RuntimeException(\"BOOLEAN_TOGGLE_FIRST_FALSE must be false on first invocation\");\n+            }\n+        } else if (x == lastToggleBoolean) {\n+            throw new RuntimeException(\"BOOLEAN_TOGGLE_FIRST_FALSE did not toggle\");\n+        }\n+        lastToggleBoolean = x;\n+        executed[29]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    public void randomEachByte(byte x) {\n+        checkNonFloatingRandomNumber(x, executed[30]);\n+        executed[30]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    public void randomEachShort(short x) {\n+        checkNonFloatingRandomNumber(x, executed[31]);\n+        executed[31]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    public void randomEachInt(int x) {\n+        checkNonFloatingRandomNumber(x, executed[32]);\n+        executed[32]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    public void randomEachLong(long x) {\n+        checkNonFloatingRandomNumber(x, executed[33]);\n+        executed[33]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    public void randomEachChar(char x) {\n+        checkNonFloatingRandomNumber(x, executed[34]);\n+        executed[34]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    public void randomEachFloat(float x) {\n+        checkFloatingRandomNumber(x, executed[35]);\n+        executed[35]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    public void randomEachDouble(double x) {\n+        checkFloatingRandomNumber(x, executed[36]);\n+        executed[36]++;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    public void randomEachBoolean(boolean x) {\n+        checkRandomBoolean(x, executed[37]);\n+        executed[37]++;\n+    }\n+\n+    private void checkNonFloatingRandomNumber(long x, int invocationCount) {\n+        int mod10 = invocationCount % 10;\n+        if (invocationCount > 0 && mod10 == 0) {\n+            \/\/ Not first invocation\n+            \/\/ Check the last 10 numbers and ensure that there are at least 2 different ones.\n+            \/\/ All numbers are equal? Very unlikely nd we should really consider to play the lottery...\n+            long first = nonFloatingRandomNumbers[0];\n+            if (Arrays.stream(nonFloatingRandomNumbers).allMatch(n -> n == first)) {\n+                throw new RuntimeException(\"RANDOM_EACH does not generate random integer numbers\");\n+            }\n+            clearNonFloatingRandomNumbers();\n+        }\n+        nonFloatingRandomNumbers[mod10] = x;\n+    }\n+\n+    private void checkFloatingRandomNumber(double x, int invocationCount) {\n+        int mod10 = invocationCount % 10;\n+        if (invocationCount > 0 && mod10 == 0) {\n+            \/\/ Not first invocation\n+            \/\/ Check the last 10 numbers and ensure that there are at least 2 different ones.\n+            \/\/ All numbers are equal? Very unlikely nd we should really consider to play the lottery...\n+            double first = floatingRandomNumbers[0];\n+            if (Arrays.stream(floatingRandomNumbers).allMatch(n -> n == first)) {\n+                throw new RuntimeException(\"RANDOM_EACH does not generate random floating point numbers\");\n+            }\n+            clearFloatingRandomNumbers();\n+        }\n+        floatingRandomNumbers[mod10] = x;\n+    }\n+\n+    private void checkRandomBoolean(boolean x, int invocationCount) {\n+        int mod64 = invocationCount % 64;\n+        if (invocationCount > 0 && mod64 == 0) {\n+            \/\/ Not first invocation\n+            \/\/ Check the last 64 booleans and ensure that there are at least one true and one false.\n+            \/\/ All booleans are equal? Very unlikely (chance of 2^64) and we should really consider\n+            \/\/ to play the lottery...\n+            if (Arrays.stream(randomBooleans).allMatch(b -> b == randomBooleans[0])) {\n+                throw new RuntimeException(\"RANDOM_EACH does not generate random booleans\");\n+            }\n+            clearRandomBooleans();\n+        }\n+        randomBooleans[mod64] = x;\n+    }\n+\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_MINUS_42)\n+    public void byteMinus42(byte x) {\n+        executed[38]++;\n+        if (x != -42) {\n+            throw new RuntimeException(\"Must be -42\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_MINUS_42)\n+    public void shortMinus42(short x) {\n+        executed[39]++;\n+        if (x != -42) {\n+            throw new RuntimeException(\"Must be -42\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_MINUS_42)\n+    public void intMinus42(int x) {\n+        executed[40]++;\n+        if (x != -42) {\n+            throw new RuntimeException(\"Must be -42\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_MINUS_42)\n+    public void longMinus42(long x) {\n+        executed[41]++;\n+        if (x != -42) {\n+            throw new RuntimeException(\"Must be -42\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_MINUS_42)\n+    public void floatMinus42(float x) {\n+        executed[42]++;\n+        if (x != -42.0) {\n+            throw new RuntimeException(\"Must be -42\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_MINUS_42)\n+    public void doubleMinus42(double x) {\n+        executed[43]++;\n+        if (x != -42.0) {\n+            throw new RuntimeException(\"Must be -42\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MIN)\n+    public void byteMin(byte x) {\n+        executed[79]++;\n+        if (x != Byte.MIN_VALUE) {\n+            throw new RuntimeException(\"Must be MIN_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MIN)\n+    public void charMin(char x) {\n+        executed[80]++;\n+        if (x != Character.MIN_VALUE) {\n+            throw new RuntimeException(\"Must be MIN_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MIN)\n+    public void shortMin(short x) {\n+        executed[81]++;\n+        if (x != Short.MIN_VALUE) {\n+            throw new RuntimeException(\"Must be MIN_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MIN)\n+    public void intMin(int x) {\n+        executed[82]++;\n+        if (x != Integer.MIN_VALUE) {\n+            throw new RuntimeException(\"Must be MIN_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MIN)\n+    public void longMin(long x) {\n+        executed[83]++;\n+        if (x != Long.MIN_VALUE) {\n+            throw new RuntimeException(\"Must be MIN_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MIN)\n+    public void floatMin(float x) {\n+        executed[84]++;\n+        if (x != Float.MIN_VALUE) {\n+            throw new RuntimeException(\"Must be MIN_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MIN)\n+    public void doubleMin(double x) {\n+        executed[85]++;\n+        if (x != Double.MIN_VALUE) {\n+            throw new RuntimeException(\"Must be MIN_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MAX)\n+    public void byteMax(byte x) {\n+        executed[86]++;\n+        if (x != Byte.MAX_VALUE) {\n+            throw new RuntimeException(\"Must be MAX_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MAX)\n+    public void charMax(char x) {\n+        executed[87]++;\n+        if (x != Character.MAX_VALUE) {\n+            throw new RuntimeException(\"Must be MAX_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MAX)\n+    public void shortMax(short x) {\n+        executed[88]++;\n+        if (x != Short.MAX_VALUE) {\n+            throw new RuntimeException(\"Must be MAX_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MAX)\n+    public void intMax(int x) {\n+        executed[89]++;\n+        if (x != Integer.MAX_VALUE) {\n+            throw new RuntimeException(\"Must be MAX_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MAX)\n+    public void longMax(long x) {\n+        executed[90]++;\n+        if (x != Long.MAX_VALUE) {\n+            throw new RuntimeException(\"Must be MAX_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MAX)\n+    public void floatMax(float x) {\n+        executed[91]++;\n+        if (x != Float.MAX_VALUE) {\n+            throw new RuntimeException(\"Must be MAX_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(Argument.MAX)\n+    public void doubleMax(double x) {\n+        executed[78]++;\n+        if (x != Double.MAX_VALUE) {\n+            throw new RuntimeException(\"Must be MAX_VALUE\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    public void twoArgsDefault1(byte x, short y) {\n+        executed[44]++;\n+        if (x != 0 || y != 0) {\n+            throw new RuntimeException(\"Both must be 0\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    public void twoArgsDefault2(int x, short y) {\n+        executed[45]++;\n+        if (x != 0 || y != 0) {\n+            throw new RuntimeException(\"Both must be 0\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    public void twoArgsDefault3(short x, long y) {\n+        executed[46]++;\n+        if (x != 0 || y != 0) {\n+            throw new RuntimeException(\"Both must be 0\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    public void twoArgsDefault4(float x, boolean y) {\n+        executed[47]++;\n+        if (x != 0.0 || y) {\n+            throw new RuntimeException(\"Must be 0 and false\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    public void twoArgsDefault5(boolean x, char y) {\n+        executed[48]++;\n+        if (x || y != '\\u0000') {\n+            throw new RuntimeException(\"Must be false and \\u0000\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({Argument.DEFAULT, Argument.DEFAULT})\n+    public void twoArgsDefault6(char x, byte y) {\n+        executed[49]++;\n+        if (x != '\\u0000' || y != 0) {\n+            throw new RuntimeException(\"Must be\\u0000 and 0\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_ONCE, Argument.RANDOM_ONCE})\n+    public void twoArgsRandomOnce(char x, byte y) {\n+        executed[50]++;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_ONCE, Argument.RANDOM_ONCE,\n+                Argument.RANDOM_ONCE, Argument.RANDOM_ONCE,\n+                Argument.RANDOM_ONCE, Argument.RANDOM_ONCE,\n+                Argument.RANDOM_ONCE, Argument.RANDOM_ONCE})\n+    public void checkRandomOnceDifferentArgs(int a, int b, int c, int d, int e, int f, int g, int h) {\n+        if (Stream.of(a, b, c, d, e, f, g, h).allMatch(i -> i == a)) {\n+            throw new RuntimeException(\"RANDOM_ONCE does not produce random values for different arguments\");\n+        }\n+        executed[51]++;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_ONCE, Argument.RANDOM_ONCE,\n+                Argument.RANDOM_ONCE, Argument.RANDOM_ONCE,\n+                Argument.RANDOM_ONCE, Argument.RANDOM_ONCE,\n+                Argument.RANDOM_ONCE, Argument.RANDOM_ONCE})\n+    public void checkMixedRandoms1(byte a, short b, int c, long d, char e, boolean f, float g, double h) {\n+        executed[52]++;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH,\n+                Argument.RANDOM_EACH, Argument.RANDOM_EACH,\n+                Argument.RANDOM_EACH, Argument.RANDOM_EACH,\n+                Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    public void checkMixedRandoms2(byte a, short b, int c, long d, char e, boolean f, float g, double h) {\n+        executed[53]++;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_ONCE, Argument.RANDOM_ONCE,\n+                Argument.RANDOM_EACH, Argument.RANDOM_EACH,\n+                Argument.RANDOM_ONCE, Argument.RANDOM_EACH,\n+                Argument.RANDOM_EACH, Argument.RANDOM_ONCE})\n+    public void checkMixedRandoms3(byte a, short b, int c, long d, char e, boolean f, float g, double h) {\n+        executed[54]++;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.NUMBER_42, Argument.NUMBER_42,\n+                Argument.NUMBER_42, Argument.NUMBER_42,\n+                Argument.NUMBER_42, Argument.NUMBER_42})\n+    public void check42Mix1(byte a, short b, int c, long d, float e, double f) {\n+        if (a != 42 || b != 42 || c != 42 || d != 42 || e != 42.0 || f != 42.0) {\n+            throw new RuntimeException(\"Must all be 42\");\n+        }\n+        executed[55]++;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.NUMBER_MINUS_42, Argument.NUMBER_MINUS_42,\n+                Argument.NUMBER_MINUS_42, Argument.NUMBER_MINUS_42,\n+                Argument.NUMBER_MINUS_42, Argument.NUMBER_MINUS_42})\n+    public void check42Mix2(byte a, short b, int c, long d, float e, double f) {\n+        if (a != -42 || b != -42 || c != -42 || d != -42 || e != -42.0 || f != -42.0) {\n+            throw new RuntimeException(\"Must all be -42\");\n+        }\n+        executed[56]++;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.NUMBER_MINUS_42, Argument.NUMBER_42,\n+                Argument.NUMBER_MINUS_42, Argument.NUMBER_MINUS_42,\n+                Argument.NUMBER_42, Argument.NUMBER_MINUS_42})\n+    public void check42Mix3(byte a, short b, int c, long d, float e, double f) {\n+        if (a != -42 || b != 42 || c != -42 || d != -42 || e != 42.0 || f != -42.0) {\n+            throw new RuntimeException(\"Do not match the right 42 version\");\n+        }\n+        executed[57]++;\n+    }\n+\n+\n+    @Test\n+    @Arguments(Argument.BOOLEAN_TOGGLE_FIRST_TRUE)\n+    public void booleanToggleFirstTrue(boolean x) {\n+        if (executed[58] == 0) {\n+            \/\/ First invocation\n+            if (!x) {\n+                throw new RuntimeException(\"BOOLEAN_TOGGLE_FIRST_FALSE must be false on first invocation\");\n+            }\n+        } else if (x == lastToggleBoolean) {\n+            throw new RuntimeException(\"BOOLEAN_TOGGLE_FIRST_FALSE did not toggle\");\n+        }\n+        lastToggleBoolean = x;\n+        executed[58]++;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.BOOLEAN_TOGGLE_FIRST_FALSE, Argument.BOOLEAN_TOGGLE_FIRST_TRUE})\n+    public void checkTwoToggles(boolean b1, boolean b2) {\n+        if (executed[59] == 0) {\n+            \/\/ First invocation\n+            if (b1 || !b2) {\n+                throw new RuntimeException(\"BOOLEAN_TOGGLES have wrong initial value\");\n+            }\n+        } else if (b1 == b2) {\n+            throw new RuntimeException(\"Boolean values must be different\");\n+        } else if (b1 == lastToggleBoolean) {\n+            throw new RuntimeException(\"Booleans did not toggle\");\n+        }\n+        lastToggleBoolean = b1;\n+        executed[59]++;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.BOOLEAN_TOGGLE_FIRST_FALSE, Argument.FALSE,\n+                Argument.TRUE, Argument.BOOLEAN_TOGGLE_FIRST_TRUE})\n+    public void booleanMix(boolean b1, boolean b2, boolean b3, boolean b4) {\n+        if (executed[60] == 0) {\n+            \/\/ First invocation\n+            if (b1 || b2 || !b3 || !b4) {\n+                throw new RuntimeException(\"BOOLEAN_TOGGLES have wrong initial value\");\n+            }\n+        } else if (b1 == b4) {\n+            throw new RuntimeException(\"Boolean values must be different\");\n+        } else if (b1 == lastToggleBoolean) {\n+            throw new RuntimeException(\"Booleans did not toggle\");\n+        }\n+        lastToggleBoolean = b1;\n+        executed[60]++;\n+    }\n+\n+    \/*\n+     * Checked tests.\n+     *\/\n+\n+    @Test\n+    public int testCheck() {\n+        executed[63]++;\n+        return 1;\n+    }\n+\n+    \/\/ Checked test. Check invoked after invoking \"testCheck\". Perform some more things after invocation.\n+    @Check(test = \"testCheck\")\n+    public void checkTestCheck() {\n+        executed[64]++; \/\/ Executed on each invocation\n+    }\n+\n+    @Test\n+    public int testCheckReturn() {\n+        executed[65]++;\n+        return 2;\n+    }\n+\n+    \/\/ Checked test with return value. Perform checks on it.\n+    @Check(test = \"testCheckReturn\")\n+    public void checkTestCheckReturn(int returnValue) {\n+        if (returnValue != 2) {\n+            throw new RuntimeException(\"Must be 2\");\n+        }\n+        executed[66]++; \/\/ Executed on each invocation\n+    }\n+\n+    @Test\n+    @Arguments(Argument.NUMBER_42)\n+    public short testCheckWithArgs(short x) {\n+        executed[94]++;\n+        return x;\n+    }\n+\n+    @Check(test = \"testCheckWithArgs\")\n+    public void checkTestCheckWithArgs(short returnValue) {\n+        if (returnValue != 42) {\n+            throw new RuntimeException(\"Must be 42\");\n+        }\n+        executed[95]++; \/\/ Executed on each invocation\n+    }\n+\n+    @Test\n+    public int testCheckTestInfo() {\n+        executed[67]++;\n+        return 3;\n+    }\n+\n+    \/\/ Checked test with info object about test.\n+    @Check(test = \"testCheckTestInfo\")\n+    public void checkTestCheckTestInfo(TestInfo testInfo) {\n+        executed[68]++; \/\/ Executed on each invocation\n+    }\n+\n+\n+    @Test\n+    public int testCheckBoth() {\n+        executed[69]++;\n+        return 4;\n+    }\n+\n+    \/\/ Checked test with return value and info object about test.\n+    @Check(test = \"testCheckBoth\")\n+    public void checkTestCheckTestInfo(int returnValue, TestInfo testInfo) {\n+        if (returnValue != 4) {\n+            throw new RuntimeException(\"Must be 4\");\n+        }\n+        executed[70]++; \/\/ Executed on each invocation\n+    }\n+\n+    @Test\n+    public int testCheckOnce() {\n+        executed[71]++;\n+        return 1;\n+    }\n+\n+    \/\/ Check method only invoked once after method is compiled after warm up.\n+    @Check(test = \"testCheckOnce\", when = CheckAt.COMPILED)\n+    public void checkTestCheckOnce() {\n+        executedOnce[0]++; \/\/ Executed once\n+    }\n+\n+    @Test\n+    public int testCheckReturnOnce() {\n+        executed[72]++;\n+        return 2;\n+    }\n+\n+    @Check(test = \"testCheckReturnOnce\", when = CheckAt.COMPILED)\n+    public void checkTestCheckReturnOnce(int returnValue) {\n+        if (returnValue != 2) {\n+            throw new RuntimeException(\"Must be 2\");\n+        }\n+        executedOnce[1]++; \/\/ Executed once\n+    }\n+\n+    @Test\n+    public int testCheckTestInfoOnce() {\n+        executed[73]++;\n+        return 3;\n+    }\n+\n+    @Check(test = \"testCheckTestInfoOnce\", when = CheckAt.COMPILED)\n+    public void checkTestCheckTestInfoOnce(TestInfo testInfo) {\n+        executedOnce[2]++; \/\/ Executed once\n+    }\n+\n+    @Test\n+    public int testCheckBothOnce() {\n+        executed[74]++;\n+        return 4;\n+    }\n+\n+    @Check(test = \"testCheckBothOnce\", when = CheckAt.COMPILED)\n+    public void checkTestCheckBothOnce(int returnValue, TestInfo testInfo) {\n+        if (returnValue != 4) {\n+            throw new RuntimeException(\"Must be 4\");\n+        }\n+        executedOnce[3]++; \/\/ Executed once\n+    }\n+\n+    @Test\n+    public void sameName() {\n+        executed[76]++;\n+    }\n+\n+    \/\/ Allowed to overload test method if not test method itself\n+    public void sameName(boolean a) {\n+        wasExecuted = true;\n+    }\n+\n+    \/\/ Allowed to overload test method if not test method itself\n+    @Check(test = \"sameName\")\n+    public void sameName(TestInfo info) {\n+        executed[77]++;\n+    }\n+\n+\n+    \/*\n+     * Custom run tests.\n+     *\/\n+\n+    @Test\n+    public void sameName2() {\n+        executed[92]++;\n+    }\n+\n+    \/\/ Allowed to overload test method if not test method itself\n+    @Run(test = \"sameName2\")\n+    public void sameName2(RunInfo info) {\n+        executed[93]++;\n+        sameName2();\n+    }\n+\n+    @Test\n+    public void testRun() {\n+        executed[61]++;\n+    }\n+\n+    \/\/ Custom run test. This method is invoked each time instead of @Test method. This method responsible for calling\n+    \/\/ the @Test method. @Test method is compiled after warm up. This is similar to the verifiers in the old Valhalla framework.\n+    @Run(test = \"testRun\")\n+    public void runTestRun(RunInfo info) {\n+        testRun();\n+    }\n+\n+    @Test\n+    public void testRunNoTestInfo(int i) { \/\/ Argument allowed when run by @Run\n+        executed[62]++;\n+    }\n+\n+    @Run(test = \"testRunNoTestInfo\")\n+    public void runTestRunNoTestInfo() {\n+        testRunNoTestInfo(3);\n+    }\n+\n+    @Test\n+    public void testNotRun() {\n+        wasExecuted = true;\n+    }\n+\n+    @Run(test = \"testNotRun\")\n+    public void runTestNotRun() {\n+        \/\/ Do not execute the test. Pointless but need to test that as well.\n+    }\n+\n+    @Test\n+    public void testRunOnce() {\n+        executedOnce[4]++;\n+    }\n+\n+    \/\/ Custom run test that is only invoked once. There is no warm up and no compilation. This method is responsible\n+    \/\/ for triggering compilation.\n+    @Run(test = \"testRunOnce\", mode = RunMode.STANDALONE)\n+    public void runTestRunOnce(RunInfo info) {\n+        testRunOnce();\n+    }\n+\n+    @Test\n+    public void testRunOnce2() {\n+        executed[75]++;\n+    }\n+\n+    @Run(test = \"testRunOnce2\", mode = RunMode.STANDALONE)\n+    public void runTestRunOnce2(RunInfo info) {\n+        for (int i = 0; i < TestVM.WARMUP_ITERATIONS + 1; i++) {\n+            testRunOnce2();\n+        }\n+    }\n+\n+    @Test\n+    public void testRunMultiple() {\n+        executed[96]++;\n+    }\n+\n+    @Test\n+    public void testRunMultiple2() {\n+        executed[97]++;\n+    }\n+\n+    @Test\n+    public void testRunMultipleNotExecuted() {\n+        wasExecuted = true;\n+    }\n+\n+    @Run(test = {\"testRunMultiple\", \"testRunMultiple2\", \"testRunMultipleNotExecuted\"})\n+    public void runTestRunMultiple() {\n+        testRunMultiple();\n+        testRunMultiple2();\n+    }\n+\n+\n+    @Test\n+    public void testRunMultiple3() {\n+        executed[98]++;\n+    }\n+\n+    @Test\n+    public void testRunMultiple4() {\n+        executed[99]++;\n+    }\n+\n+    @Test\n+    public void testRunMultipleNotExecuted2() {\n+        wasExecuted = true;\n+    }\n+\n+    @Run(test = {\"testRunMultiple3\", \"testRunMultiple4\", \"testRunMultipleNotExecuted2\"}, mode = RunMode.STANDALONE)\n+    public void runTestRunMultipl2(RunInfo info) {\n+        for (int i = 0; i < TestVM.WARMUP_ITERATIONS + 1; i++) {\n+            testRunMultiple3();\n+            testRunMultiple4();\n+        }\n+    }\n+}\n+\n+class DefaultObject {\n+    int i = 4;\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestBasics.java","additions":1086,"deletions":0,"binary":false,"changes":1086,"status":"added"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.test.TestVM;\n+\n+import java.lang.reflect.Method;\n+\n+\/*\n+ * @test\n+ * @requires vm.flagless\n+ * @summary Test if compilation levels are used correctly in the framework.\n+ *          This test partly runs directly the test VM which normally does and should not happen in user tests.\n+ * @library \/test\/lib \/\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -DSkipWhiteBoxInstall=true -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *                   -Xbatch -XX:+WhiteBoxAPI ir_framework.tests.TestCompLevels\n+ *\/\n+\n+public class TestCompLevels {\n+    static int[] testExecuted = new int[5];\n+\n+    public static void main(String[] args) throws Exception {\n+        Method runTestsOnSameVM = TestVM.class.getDeclaredMethod(\"runTestsOnSameVM\", Class.class);\n+        runTestsOnSameVM.setAccessible(true);\n+        runTestsOnSameVM.invoke(null, new Object[]{null});\n+\n+        for (int i = 0; i < testExecuted.length; i++) {\n+            int value = testExecuted[i];\n+            if (value != TestVM.WARMUP_ITERATIONS + 1) {\n+                \/\/ Warmups + 1 compiled invocation\n+                throw new RuntimeException(\"Test \" + i + \"  was executed \" + value + \" times stead of \"\n+                                           + TestVM.WARMUP_ITERATIONS + 1 + \" times.\" );\n+            }\n+        }\n+        TestFramework framework = new TestFramework(TestNoTiered.class);\n+        framework.setDefaultWarmup(10).addFlags(\"-XX:-TieredCompilation\").start();\n+        framework = new TestFramework(TestNoTiered.class);\n+        framework.setDefaultWarmup(10).addScenarios(new Scenario(0, \"-XX:-TieredCompilation\")).start();\n+        framework = new TestFramework(TestStopAtLevel1.class);\n+        framework.setDefaultWarmup(10).addFlags(\"-XX:TieredStopAtLevel=1\").start();\n+        framework = new TestFramework(TestStopAtLevel1.class);\n+        framework.setDefaultWarmup(10).addScenarios(new Scenario(0, \"-XX:TieredStopAtLevel=1\")).start();\n+    }\n+\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public void testC1() {\n+        testExecuted[0]++;\n+    }\n+\n+    @Check(test = \"testC1\", when = CheckAt.COMPILED)\n+    public void checkTestC1(TestInfo info) {\n+        TestFramework.assertCompiledAtLevel(info.getTest(), CompLevel.C1_SIMPLE);\n+    }\n+\n+    @Test(compLevel = CompLevel.C1_LIMITED_PROFILE)\n+    public void testC1Limited() {\n+        testExecuted[1]++;\n+    }\n+\n+    @Check(test = \"testC1Limited\", when = CheckAt.COMPILED)\n+    public void checkTestLimited(TestInfo info) {\n+        TestFramework.assertCompiledAtLevel(info.getTest(), CompLevel.C1_LIMITED_PROFILE);\n+    }\n+\n+    @Test(compLevel = CompLevel.C1_FULL_PROFILE)\n+    public void testC1Full() {\n+        testExecuted[2]++;\n+    }\n+\n+    @Check(test = \"testC1Full\", when = CheckAt.COMPILED)\n+    public void checkTestC1Full(TestInfo info) {\n+        TestFramework.assertCompiledAtLevel(info.getTest(), CompLevel.C1_FULL_PROFILE);\n+    }\n+\n+    @Test(compLevel = CompLevel.C2)\n+    public void testC2() {\n+        testExecuted[3]++;\n+    }\n+\n+    @Check(test = \"testC2\", when = CheckAt.COMPILED)\n+    public void checkTestC2(TestInfo info) {\n+        TestFramework.assertCompiledAtLevel(info.getTest(), CompLevel.C2);\n+    }\n+\n+    @Test(compLevel = CompLevel.SKIP)\n+    public void testSkip() {\n+        testExecuted[4]++; \/\/ Executed by eventually not compiled by framework\n+    }\n+}\n+\n+class TestNoTiered {\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public void level1() {\n+    }\n+\n+    @Check(test = \"level1\")\n+    public void check1(TestInfo info) {\n+        TestFramework.assertNotCompiled(info.getTest()); \/\/ Never compiled without C1\n+    }\n+\n+    @Test(compLevel = CompLevel.C1_LIMITED_PROFILE)\n+    public void level2() {\n+    }\n+\n+    @Check(test = \"level2\")\n+    public void check2(TestInfo info) {\n+        TestFramework.assertNotCompiled(info.getTest()); \/\/ Never compiled without C1\n+    }\n+\n+    @Test(compLevel = CompLevel.C1_FULL_PROFILE)\n+    public void level3() {\n+    }\n+\n+    @Check(test = \"level3\")\n+    public void check3(TestInfo info) {\n+        TestFramework.assertNotCompiled(info.getTest()); \/\/ Never compiled without C1\n+    }\n+\n+    @Test(compLevel = CompLevel.C2)\n+    public void level4() {\n+    }\n+\n+    @Check(test = \"level4\")\n+    public void check4(TestInfo info) {\n+        if (info.isWarmUp()) {\n+            TestFramework.assertNotCompiled(info.getTest()); \/\/ Never compiled without C1\n+        } else {\n+            if (TestFramework.isC1Compiled(info.getTest())) {\n+                throw new RuntimeException(\"Cannot be compiled with C1\"); \/\/ Never compiled without C1\n+            }\n+            TestFramework.assertCompiledByC2(info.getTest());\n+        }\n+    }\n+\n+    @Test(compLevel = CompLevel.SKIP)\n+    public void skip() {\n+    }\n+\n+    @Check(test = \"skip\")\n+    public void checkSkip(TestInfo info) {\n+        TestFramework.assertNotCompiled(info.getTest()); \/\/ Never compiled\n+    }\n+}\n+\n+class TestStopAtLevel1 {\n+    @Test(compLevel = CompLevel.C1_SIMPLE)\n+    public int level1() {\n+        return 34;\n+    }\n+\n+    @Check(test = \"level1\")\n+    public void check1(int result, TestInfo info) {\n+        if (info.isWarmUp()) {\n+            TestFramework.assertNotCompiled(info.getTest()); \/\/ Not compiled yet\n+        } else {\n+            TestFramework.assertCompiledByC1(info.getTest());\n+            if (TestFramework.isC2Compiled(info.getTest())) {\n+                throw new RuntimeException(\"Cannot be compiled by C2\");\n+            }\n+            System.out.println(\"TestStopAtLevel1=\" + result);\n+        }\n+    }\n+\n+    @Test(compLevel = CompLevel.C1_LIMITED_PROFILE)\n+    public void level2() {\n+    }\n+\n+    @Check(test = \"level2\")\n+    public void check2(TestInfo info) {\n+        TestFramework.assertNotCompiled(info.getTest()); \/\/ Never with level 2\n+    }\n+\n+    @Test(compLevel = CompLevel.C1_FULL_PROFILE)\n+    public void level3() {\n+    }\n+\n+    @Check(test = \"level3\")\n+    public void check3(TestInfo info) {\n+        TestFramework.assertNotCompiled(info.getTest()); \/\/ Never with level 3\n+    }\n+\n+    @Test(compLevel = CompLevel.C2)\n+    public void level4() {\n+    }\n+\n+    @Check(test = \"level4\")\n+    public void check4(TestInfo info) {\n+        TestFramework.assertNotCompiled(info.getTest()); \/\/ Never with level 4\n+    }\n+\n+    @Test(compLevel = CompLevel.SKIP)\n+    public void skip() {\n+    }\n+\n+    @Check(test = \"skip\")\n+    public void checkSkip(TestInfo info) {\n+        TestFramework.assertNotCompiled(info.getTest()); \/\/ Never compiled\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestCompLevels.java","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -0,0 +1,389 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.Compiler;\n+import compiler.lib.ir_framework.test.TestVM;\n+import jdk.test.lib.Asserts;\n+import sun.hotspot.WhiteBox;\n+\n+import java.lang.reflect.Method;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true & vm.compMode != \"Xint\" & vm.compiler2.enabled & vm.flagless\n+ * @summary Test if compilation control annotaions are handled correctly in the framework.\n+ *          This test partly runs directly the test VM which normally does and should not happen in user tests.\n+ * @library \/test\/lib \/\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -DSkipWhiteBoxInstall=true -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *                   -Xbatch -XX:+WhiteBoxAPI ir_framework.tests.TestControls\n+ *\/\n+\n+public class TestControls {\n+    static int[] executed = new int[15];\n+    static boolean wasExecuted = false;\n+    static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    public int iFld;\n+\n+    public static void main(String[] args) throws Exception {\n+        Method runTestsOnSameVM = TestVM.class.getDeclaredMethod(\"runTestsOnSameVM\", Class.class);\n+        runTestsOnSameVM.setAccessible(true);\n+        runTestsOnSameVM.invoke(null, new Object[]{ null });\n+        final int defaultIterations = TestVM.WARMUP_ITERATIONS + 1;\n+        Asserts.assertEQ(executed[0], 1001);\n+        Asserts.assertEQ(executed[1], 101);\n+        Asserts.assertEQ(executed[2], 10000);\n+        Asserts.assertEQ(executed[3], 10000);\n+        Asserts.assertEQ(executed[4], defaultIterations);\n+        Asserts.assertEQ(executed[5], defaultIterations);\n+        Asserts.assertEQ(executed[6], 5001);\n+        Asserts.assertEQ(executed[7], 5001);\n+        Asserts.assertEQ(executed[8], 1);\n+        Asserts.assertEQ(executed[9], 5000);\n+        Asserts.assertEQ(executed[10], 1);\n+        Asserts.assertEQ(executed[11], 2);\n+        Asserts.assertEQ(executed[12], 1);\n+        Asserts.assertEQ(executed[13], 1);\n+        Asserts.assertFalse(wasExecuted);\n+        final long started = System.currentTimeMillis();\n+        long elapsed = 0;\n+        Method overloadDouble = TestControls.class.getDeclaredMethod(\"overload\", double.class);\n+        Method overloadInt = TestControls.class.getDeclaredMethod(\"overload\", int.class);\n+        while (!(TestFramework.isC2Compiled(overloadInt) && TestFramework.isCompiledAtLevel(overloadDouble, CompLevel.C1_LIMITED_PROFILE)) && elapsed < 5000) {\n+            elapsed = System.currentTimeMillis() - started;\n+        }\n+        TestFramework.assertCompiledAtLevel(TestControls.class.getDeclaredMethod(\"overload\", double.class), CompLevel.C1_LIMITED_PROFILE);\n+        TestFramework.assertCompiledByC2(TestControls.class.getDeclaredMethod(\"overload\", int.class));\n+\n+        TestFramework framework = new TestFramework(ClassInitializerTest.class);\n+        framework.addFlags(\"-XX:+PrintCompilation\").addHelperClasses(ClassInitializerHelper.class).start();\n+        String output = TestFramework.getLastTestVMOutput();\n+        Pattern p = Pattern.compile(\"4.*ClassInitializerTest::<clinit>\");\n+        Matcher m = p.matcher(output);\n+        Asserts.assertTrue(m.find());\n+        p = Pattern.compile(\"2.*ClassInitializerHelper::<clinit>\");\n+        m = p.matcher(output);\n+        Asserts.assertTrue(m.find());\n+\n+        new TestFramework(TestWarmup.class).setDefaultWarmup(500).start();\n+        TestFramework.run(ExplicitSkip.class);\n+    }\n+\n+    @Test\n+    @Warmup(1000)\n+    public void test1() {\n+        executed[0]++;\n+    }\n+\n+    @Check(test = \"test1\")\n+    public void check1(TestInfo info) {\n+        if (executed[0] <= 1000) {\n+            Asserts.assertTrue(info.isWarmUp());\n+        } else {\n+            Asserts.assertTrue(!info.isWarmUp() && executed[0] == 1001);\n+            TestFramework.assertCompiledByC2(info.getTest());\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(100)\n+    public void test2() {\n+        executed[1]++;\n+    }\n+\n+    @Check(test = \"test2\", when = CheckAt.COMPILED)\n+    public void check2(TestInfo info) {\n+        Asserts.assertTrue(!info.isWarmUp() && executed[1] == 101);\n+        TestFramework.assertCompiledByC2(info.getTest());\n+    }\n+\n+    @Test\n+    public void overload() {\n+        executed[4]++;\n+    }\n+\n+    @ForceCompile\n+    @DontInline\n+    public static void overload(int i) {\n+        wasExecuted = true;\n+    }\n+\n+    @ForceCompile(CompLevel.C1_LIMITED_PROFILE)\n+    @ForceInline\n+    public static void overload(double i) {\n+        wasExecuted = true;\n+    }\n+\n+    @Check(test = \"overload\")\n+    public void checkOverload()  {\n+        executed[5]++;\n+    }\n+\n+    @Test\n+    public void testDontCompile() {\n+        executed[2]++;\n+    }\n+\n+    @DontCompile\n+    public static void dontCompile() {\n+        executed[3]++;\n+    }\n+\n+    @Run(test = \"testDontCompile\", mode = RunMode.STANDALONE)\n+    public void runTestDontCompile() throws NoSuchMethodException {\n+        for (int i = 0; i < 10000; i++) {\n+            dontCompile(); \/\/ Should not compile this method\n+            testDontCompile();\n+        }\n+        TestFramework.assertNotCompiled(TestControls.class.getDeclaredMethod(\"dontCompile\"));\n+    }\n+\n+    @Test\n+    public void testCompileAtLevel1() {\n+        executed[6]++;\n+    }\n+\n+    @DontCompile(Compiler.ANY)\n+    public static void dontCompile2() {\n+        executed[7]++;\n+    }\n+\n+    @Run(test = \"testCompileAtLevel1\")\n+    @Warmup(5000)\n+    public void runTestDontCompile2(RunInfo info) throws NoSuchMethodException {\n+        dontCompile2();\n+        testCompileAtLevel1();\n+        if (!info.isWarmUp()) {\n+            executed[8]++;\n+            int compLevel = WHITE_BOX.getMethodCompilationLevel(TestControls.class.getDeclaredMethod(\"dontCompile2\"), false);\n+            Asserts.assertLessThan(compLevel, CompLevel.C1_LIMITED_PROFILE.getValue());\n+        } else {\n+            executed[9]++;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    public void noWarmup() {\n+        executed[10]++;\n+    }\n+\n+    @Test\n+    public void noWarmup2() {\n+        executed[11]++;\n+    }\n+\n+    @Run(test = \"noWarmup2\")\n+    @Warmup(0)\n+    public void runNoWarmup2(RunInfo info) {\n+        noWarmup2();\n+        noWarmup2();\n+        Asserts.assertTrue(!info.isWarmUp());\n+        executed[12]++;\n+    }\n+\n+    @Test\n+    public void testCompilation() {\n+        wasExecuted = true;\n+    }\n+\n+    @DontCompile(Compiler.ANY)\n+    public void dontCompileAny() {\n+        for (int i = 0; i < 10; i++) {\n+            iFld = i;\n+        }\n+    }\n+\n+    @DontCompile(Compiler.C1)\n+    public void dontCompileC1() {\n+        for (int i = 0; i < 10; i++) {\n+            iFld = 3;\n+        }\n+    }\n+\n+    @DontCompile(Compiler.C2)\n+    public void dontCompileC2(int x, boolean b) {\n+        for (int i = 0; i < 10; i++) {\n+            iFld = x;\n+        }\n+    }\n+\n+    \/\/ Default is C2.\n+    @ForceCompile\n+    public void forceCompileDefault() {\n+        wasExecuted = true;\n+    }\n+\n+    \/\/ ANY maps to C2.\n+    @ForceCompile\n+    public void forceCompileAny() {\n+        wasExecuted = true;\n+    }\n+\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    public void forceCompileC1() {\n+        wasExecuted = true;\n+    }\n+\n+    @ForceCompile(CompLevel.C1_LIMITED_PROFILE)\n+    public void forceCompileC1Limited() {\n+        wasExecuted = true;\n+    }\n+\n+    @ForceCompile(CompLevel.C1_FULL_PROFILE)\n+    public void forceCompileC1Full() {\n+        wasExecuted = true;\n+    }\n+\n+    @ForceCompile(CompLevel.C2)\n+    public void forceCompileC2() {\n+        wasExecuted = true;\n+    }\n+\n+    @ForceCompile(CompLevel.C1_SIMPLE)\n+    @DontCompile(Compiler.C2)\n+    public void forceC1DontC2() {\n+        wasExecuted = true;\n+    }\n+\n+    @ForceCompile(CompLevel.C2)\n+    @DontCompile(Compiler.C1)\n+    public void forceC2DontC1() {\n+        wasExecuted = true;\n+    }\n+\n+    @Run(test = \"testCompilation\")\n+    @Warmup(0)\n+    public void runTestCompilation(RunInfo info) {\n+        for (int i = 0; i < 100000; i++) {\n+            dontCompileAny();\n+            dontCompileC1();\n+            dontCompileC2(i, i % 2 == 0);\n+        }\n+        TestFramework.assertCompiledByC2(info.getTest());\n+        TestFramework.assertNotCompiled(info.getTestClassMethod(\"dontCompileAny\"));\n+        TestFramework.assertCompiledByC2(info.getTestClassMethod(\"dontCompileC1\"));\n+        TestFramework.assertCompiledByC1(info.getTestClassMethod(\"dontCompileC2\", int.class, boolean.class));\n+\n+        TestFramework.assertCompiledAtLevel(info.getTestClassMethod(\"forceCompileDefault\"), CompLevel.C2);\n+        TestFramework.assertCompiledAtLevel(info.getTestClassMethod(\"forceCompileAny\"), CompLevel.C2);\n+        TestFramework.assertCompiledAtLevel(info.getTestClassMethod(\"forceCompileC2\"), CompLevel.C2);\n+        TestFramework.assertCompiledAtLevel(info.getTestClassMethod(\"forceCompileC1\"), CompLevel.C1_SIMPLE);\n+        TestFramework.assertCompiledAtLevel(info.getTestClassMethod(\"forceCompileC1Limited\"), CompLevel.C1_LIMITED_PROFILE);\n+        TestFramework.assertCompiledAtLevel(info.getTestClassMethod(\"forceCompileC1Full\"), CompLevel.C1_FULL_PROFILE);\n+\n+        TestFramework.assertCompiledAtLevel(info.getTestClassMethod(\"forceC1DontC2\"), CompLevel.C1_SIMPLE);\n+        TestFramework.assertCompiledAtLevel(info.getTestClassMethod(\"forceC2DontC1\"), CompLevel.C2);\n+        executed[13]++;\n+    }\n+}\n+\n+@ForceCompileClassInitializer\n+class ClassInitializerTest {\n+\n+    static int i;\n+    static Object o;\n+    static {\n+        i = 3;\n+        o = new Object();\n+    }\n+    @Test\n+    public void test() {}\n+}\n+\n+@ForceCompileClassInitializer(CompLevel.C1_LIMITED_PROFILE)\n+class ClassInitializerHelper {\n+    static int i;\n+    static {\n+        i = 3;\n+    }\n+}\n+\n+class TestWarmup {\n+    int iFld;\n+    int iFld2;\n+    int iFldCheck;\n+    int iFldCheck2;\n+\n+    @Test\n+    @Warmup(200)\n+    public void test() {\n+        iFld++;\n+    }\n+\n+    @Test\n+    public void test2() {\n+        iFld2++;\n+    }\n+\n+    @Check(test = \"test\")\n+    public void checkTest(TestInfo info) {\n+        iFldCheck++;\n+        if (iFldCheck != iFld) {\n+            throw new RuntimeException(iFld + \" must be equal \" + iFldCheck);\n+        }\n+        if (!info.isWarmUp()) {\n+            if (iFld != 201) {\n+                throw new RuntimeException(\"Must be 201 but was \" + iFld);\n+            }\n+        }\n+    }\n+\n+    @Check(test = \"test2\")\n+    public void checkTest2(TestInfo info) {\n+        iFldCheck2++;\n+        if (iFldCheck2 != iFld2) {\n+            throw new RuntimeException(iFld2 + \" must be equal \" + iFldCheck2);\n+        }\n+        if (!info.isWarmUp()) {\n+            if (iFld2 != 501) {\n+                throw new RuntimeException(\"Must be 501 but was \" + iFld2);\n+            }\n+        }\n+    }\n+}\n+\n+\n+class ExplicitSkip {\n+    int iFld;\n+\n+    \/\/ Test skipped and thus also no IR verification should be done.\n+    @Test(compLevel = CompLevel.SKIP)\n+    @IR(counts = {IRNode.STORE_I, \"1\"})\n+    public int test(int x) {\n+        iFld = x;\n+        return x;\n+    }\n+\n+    @Run(test = \"test\")\n+    public void run(RunInfo info) {\n+        test(34);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestControls.java","additions":389,"deletions":0,"binary":false,"changes":389,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+\/*\n+ * @test\n+ * @requires vm.debug == true & vm.compMode != \"Xint\" & vm.compiler2.enabled & vm.flagless\n+ * @summary Sanity test remaining framework property flags.\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -DFlipC1C2=true ir_framework.tests.TestDFlags\n+ * @run main\/othervm -DExcludeRandom=true ir_framework.tests.TestDFlags\n+ * @run main\/othervm -DVerifyVM=true ir_framework.tests.TestDFlags\n+ * @run main\/othervm -DDumpReplay=true ir_framework.tests.TestDFlags\n+ * @run main\/othervm -DVerbose=true ir_framework.tests.TestDFlags\n+ * @run main\/othervm -DShuffleTests=false ir_framework.tests.TestDFlags\n+ * @run main\/othervm -DReproduce=true ir_framework.tests.TestDFlags\n+ * @run main\/othervm -DReportStdout=true ir_framework.tests.TestDFlags\n+ * @run main\/othervm -DGCAfter=true ir_framework.tests.TestDFlags\n+ * @run main\/othervm -DPrintTimes=true ir_framework.tests.TestDFlags\n+ * @run main\/othervm -DVerifyIR=false ir_framework.tests.TestDFlags\n+ *\/\n+\n+public class TestDFlags {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    public int c1() {\n+        return 34;\n+    }\n+\n+\n+    @Test\n+    public void c2() {\n+        for (int i = 0; i < 100; i++) {\n+        }\n+    }\n+\n+    @Test\n+    public void c2_2() {\n+        for (int i = 0; i < 100; i++) {\n+        }\n+    }\n+\n+    @Test\n+    public void c2_3() {\n+        for (int i = 0; i < 100; i++) {\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestDFlags.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import sun.hotspot.WhiteBox;\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true & vm.flagless\n+ * @summary Test -DIgnoreCompilerControls property flag.\n+ * @library \/test\/lib \/\n+ * @run driver ir_framework.tests.TestDIgnoreCompilerControls\n+ *\/\n+\n+public class TestDIgnoreCompilerControls {\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 0) {\n+            TestFramework.run();\n+        } else {\n+            OutputAnalyzer oa = run(\"true\");\n+            oa.shouldHaveExitValue(0);\n+            oa = run(\"false\");\n+            oa.shouldNotHaveExitValue(0);\n+            Asserts.assertTrue(oa.getOutput().contains(\"fail run\"), \"did not find run: \" + oa.getOutput());\n+            Asserts.assertTrue(oa.getOutput().contains(\"fail check\"), \"did not find check\" + oa.getOutput());\n+        }\n+    }\n+\n+    private static OutputAnalyzer run(String flagValue) throws Exception {\n+        OutputAnalyzer oa;\n+        ProcessBuilder process = ProcessTools.createJavaProcessBuilder(\n+                \"-Dtest.class.path=\" + Utils.TEST_CLASS_PATH, \"-Dtest.jdk=\" + Utils.TEST_JDK,\n+                \"-Dtest.vm.opts=-DIgnoreCompilerControls=\" + flagValue,\n+                \"ir_framework.tests.TestDIgnoreCompilerControls\", flagValue);\n+        oa = ProcessTools.executeProcess(process);\n+        return oa;\n+    }\n+\n+    @Test\n+    public void test() { }\n+\n+    @Run(test = \"test\")\n+    @Warmup(10000)\n+    public void run(RunInfo info) throws NoSuchMethodException {\n+        if (!info.isWarmUp()) {\n+            \/\/ Should be compiled with -DIgnoreCompilerControls=true\n+            Asserts.assertTrue(WhiteBox.getWhiteBox().isMethodCompiled(getClass().getDeclaredMethod(\"run\", RunInfo.class)), \"fail run\");\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    public void test2() {}\n+\n+\n+    @Check(test = \"test2\")\n+    public void check(TestInfo info) throws NoSuchMethodException {\n+        if (!info.isWarmUp()) {\n+            \/\/ Should be compiled with -DIgnoreCompilerControls=true\n+            Asserts.assertTrue(WhiteBox.getWhiteBox().isMethodCompiled(getClass().getDeclaredMethod(\"check\", TestInfo.class)), \"fail check\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestDIgnoreCompilerControls.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import compiler.lib.ir_framework.Scenario;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.driver.TestVMException;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true & vm.flagless\n+ * @summary Test -DScenarios property flag. Run with othervm which should not be done when writing tests using the framework.\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -DScenarios=1,5,10 ir_framework.tests.TestDScenarios test\n+ * @run main\/othervm -DScenarios=1,4 ir_framework.tests.TestDScenarios test\n+ * @run main\/othervm -DScenarios=3,4,9 ir_framework.tests.TestDScenarios test\n+ * @run driver ir_framework.tests.TestDScenarios test2\n+ * @run driver ir_framework.tests.TestDScenarios\n+ *\/\n+\n+public class TestDScenarios {\n+    public static void main(String[] args) throws Exception {\n+        if (args.length > 0) {\n+            switch (args[0]) {\n+                case \"test\" -> {\n+                    Scenario s1 = new Scenario(1);\n+                    Scenario s2 = new Scenario(5);\n+                    Scenario s3 = new Scenario(10);\n+                    Scenario bad = new Scenario(0, \"-Flagdoesnotexist\"); \/\/ not executed\n+                    new TestFramework().addScenarios(bad, s1, s2, s3).start();\n+                }\n+                case \"test2\" -> {\n+                    try {\n+                        TestFramework.run(DScenariosBad.class);\n+                        throw new RuntimeException(\"should not reach\");\n+                    } catch (TestVMException e) {\n+                        System.out.println(e.getExceptionInfo());\n+                        Asserts.assertTrue(e.getExceptionInfo().contains(\"Expected DScenariosBad exception\"));\n+                    }\n+                }\n+                default -> {\n+                    \/\/ Invalid -DScenarios set and thus exception thrown when Scenario class is statically initialized.\n+                    Scenario s = new Scenario(3);\n+                    throw new RuntimeException(\"should not reach\");\n+                }\n+            }\n+        } else {\n+            \/\/ Test invalid -DScenario flag.\n+            OutputAnalyzer oa;\n+            ProcessBuilder process = ProcessTools.createJavaProcessBuilder(\n+                    \"-Dtest.jdk=\" + Utils.TEST_JDK, \"-DScenarios=a,1,b,10\",\n+                    \"ir_framework.tests.TestDScenarios\", \" test3\");\n+            oa = ProcessTools.executeProcess(process);\n+            oa.shouldNotHaveExitValue(0);\n+            System.out.println(oa.getOutput());\n+            Asserts.assertTrue(oa.getOutput().contains(\"TestRunException: Provided a scenario index\"));\n+        }\n+    }\n+\n+    @Test\n+    public void test() {\n+    }\n+}\n+\n+class DScenariosBad {\n+    @Test\n+    public void test() {\n+        throw new RuntimeException(\"Expected DScenariosBad exception\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestDScenarios.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import compiler.lib.ir_framework.Check;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.driver.TestVMException;\n+import compiler.lib.ir_framework.shared.NoTestsRunException;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/*\n+ * @test\n+ * @requires vm.flagless\n+ * @summary Test -DTest and -DExclude property flag.\n+ * @library \/test\/lib \/\n+ * @run driver ir_framework.tests.TestDTestAndExclude\n+ *\/\n+\n+public class TestDTestAndExclude {\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            run(\"good1,good2\", \"\", \"good\");\n+            run(\"good1,good2\", \"bad1\", \"good\");\n+            run(\"good1,bad1\", \"bad1\", \"good\");\n+            run(\"good1,bad1\", \"bad1,good\", \"good\");\n+            run(\"good3,bad2\", \"bad1,bad2\", \"good\");\n+            run(\"goodMulti1,goodMulti2\", \"\", \"good\");\n+            run(\"bad1,good1\", \"\", \"bad1\");\n+            run(\"bad1,good1\", \"good1\", \"bad1\");\n+            run(\"bad1,good1\", \"asdf\", \"bad1\");\n+            run(\"bad2,good1\", \"\", \"runBadSingle\");\n+            run(\"bad2\", \"runBadSingle\", \"runBadSingle\");\n+            run(\"badMulti1,badMulti2\", \"\", \"runBadMulti\");\n+            run(\"badMulti1\", \"\", \"runBadMulti\");\n+            run(\"badMulti1\", \"badMulti2\", \"runBadMulti\");\n+            run(\"badMulti2\", \"badMulti1\", \"runBadMulti\");\n+            run(\"runBadSingle\", \"\", \"empty\");\n+            run(\"runBadMulti\", \"\", \"empty\");\n+            run(\"asdf\", \"\", \"empty\");\n+            run(\"\", \"good1,good2,good3,bad1,bad2,goodMulti1,goodMulti2,badMulti1,badMulti2\", \"empty\");\n+            run(\"asdf\", \"good1,good2,good3,bad1,bad2,goodMulti1,goodMulti2,badMulti1,badMulti2\", \"empty\");\n+            run(\"bad1\", \"bad1\", \"empty\");\n+            run(\"good1\", \"asdf,good,good1\", \"empty\");\n+        } else {\n+            switch (args[0]) {\n+                case \"good\" -> TestFramework.run();\n+                case \"bad1\", \"runBadMulti\", \"runBadSingle\" -> {\n+                    try {\n+                        TestFramework.run();\n+                        throw new RuntimeException(\"should not reach\");\n+                    } catch (TestVMException e) {\n+                        Asserts.assertTrue(e.getExceptionInfo().contains(\"expected \" + args[0] + \" exception\"));\n+                    }\n+                }\n+                case \"empty\" -> {\n+                    try {\n+                        TestFramework.run();\n+                        throw new RuntimeException(\"should not reach\");\n+                    } catch (NoTestsRunException e) {\n+                        \/\/ Expected\n+                    }\n+                }\n+                default -> throw new RuntimeException(\"should not reach\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Create a VM and simulate as if it was a driver VM spawned by JTreg that has -DTest\/DExclude set as VM or Javaopts\n+     *\/\n+    protected static void run(String dTest, String dExclude, String arg) throws Exception {\n+        System.out.println(\"Run -DTest=\" + dTest + \" -DExclude=\" + dExclude + \" arg=\" + arg);\n+        OutputAnalyzer oa;\n+        ProcessBuilder process = ProcessTools.createJavaProcessBuilder(\n+                \"-Dtest.class.path=\" + Utils.TEST_CLASS_PATH, \"-Dtest.jdk=\" + Utils.TEST_JDK,\n+                \"-Dtest.vm.opts=-DTest=\" + dTest + \" -DExclude=\" + dExclude,\n+                \"ir_framework.tests.TestDTestAndExclude\", arg);\n+        oa = ProcessTools.executeProcess(process);\n+        oa.shouldHaveExitValue(0);\n+    }\n+\n+    @Test\n+    public void good1() { }\n+\n+    @Test\n+    public void good2() { }\n+\n+    @Check(test = \"good2\")\n+    public void check2() {}\n+\n+    @Test\n+    public void bad1() {\n+        throw new RuntimeException(\"expected bad1 exception\");\n+    }\n+\n+    @Test\n+    public void good3() {}\n+\n+    @Test\n+    public void goodMulti1() {}\n+\n+    @Test\n+    public void goodMulti2() {}\n+\n+    @Run(test = \"good3\")\n+    public void runGoodSingle() {\n+        good3();\n+    }\n+\n+    @Run(test = {\"goodMulti1\", \"goodMulti2\"})\n+    public void runGoodMulti() {\n+        goodMulti1();\n+        goodMulti2();\n+    }\n+\n+    @Test\n+    public void bad2() {\n+    }\n+\n+    @Test\n+    public void badMulti1() {\n+    }\n+\n+    @Test\n+    public void badMulti2() {\n+    }\n+\n+    @Run(test = \"bad2\")\n+    public void runBadSingle() {\n+        throw new RuntimeException(\"expected runBadSingle exception\");\n+    }\n+\n+    @Run(test = {\"badMulti1\", \"badMulti2\"})\n+    public void runBadMulti() {\n+        throw new RuntimeException(\"expected runBadMulti exception\");\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestDTestAndExclude.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,1628 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.driver.IRViolationException;\n+import jdk.test.lib.Asserts;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true & vm.compMode != \"Xint\" & vm.compiler2.enabled & vm.flagless\n+ * @summary Test IR matcher with different default IR node regexes. Use -DPrintIREncoding.\n+ *          Normally, the framework should be called with driver.\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -DPrintIREncoding=true ir_framework.tests.TestIRMatching\n+ *\/\n+\n+public class TestIRMatching {\n+\n+    public static void main(String[] args) {\n+        runFailOnTestsArgs(BadFailOnConstraint.create(AndOr1.class, \"test1(int)\", 1, \"CallStaticJava\"), \"-XX:TLABRefillWasteFraction=50\", \"-XX:+UsePerfData\", \"-XX:+UseTLAB\");\n+        runFailOnTestsArgs(BadFailOnConstraint.create(AndOr1.class, \"test2()\", 1, \"CallStaticJava\"), \"-XX:TLABRefillWasteFraction=50\", \"-XX:-UsePerfData\", \"-XX:+UseTLAB\");\n+\n+        runWithArguments(AndOr1.class, \"-XX:TLABRefillWasteFraction=52\", \"-XX:+UsePerfData\", \"-XX:+UseTLAB\");\n+        runWithArguments(CountComparisons.class, \"-XX:TLABRefillWasteFraction=50\");\n+        runWithArguments(GoodCount.class, \"-XX:TLABRefillWasteFraction=50\");\n+        runWithArguments(MultipleFailOnGood.class, \"-XX:TLABRefillWasteFraction=50\");\n+\n+        String[] allocMatches = { \"MyClass\", \"call,static  wrapper for: _new_instance_Java\" };\n+        runCheck(BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail1()\", 1, 1, \"Store\"),\n+                 BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail1()\", 1,  3, \"Store\"),\n+                 GoodFailOnRegexConstraint.create(MultipleFailOnBad.class, \"fail1()\", 1,  2, 4),\n+                 GoodFailOnRegexConstraint.create(MultipleFailOnBad.class, \"fail2()\", 1,  1),\n+                 BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail2()\", 1,  2, \"CallStaticJava\"),\n+                 BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail3()\", 1,  2, \"Store\"),\n+                 GoodFailOnRegexConstraint.create(MultipleFailOnBad.class, \"fail3()\", 1,  1, 3),\n+                 BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail4()\", 1,  1, \"Store\"),\n+                 GoodFailOnRegexConstraint.create(MultipleFailOnBad.class, \"fail4()\", 1,  2, 3),\n+                 BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail5()\", 1,  1, \"Store\"),\n+                 GoodFailOnRegexConstraint.create(MultipleFailOnBad.class, \"fail5()\", 1,  2, 3),\n+                 GoodFailOnRegexConstraint.create(MultipleFailOnBad.class, \"fail6()\", 1,  1),\n+                 BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail6()\", 1,  2, allocMatches),\n+                 BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail6()\", 1,  3, \"CallStaticJava\"),\n+                 GoodFailOnRegexConstraint.create(MultipleFailOnBad.class, \"fail7()\", 1,  1),\n+                 BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail7()\", 1,  2, allocMatches),\n+                 GoodFailOnRegexConstraint.create(MultipleFailOnBad.class, \"fail8()\", 1,  1),\n+                 BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail8()\", 1,  2, allocMatches),\n+                 BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail9()\", 1,  1, \"Store\"),\n+                 BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail9()\", 1,  2, \"CallStaticJava\"),\n+                 BadFailOnConstraint.create(MultipleFailOnBad.class, \"fail10()\", 1,  1, \"Store\", \"iFld\"),\n+                 GoodFailOnRegexConstraint.create(MultipleFailOnBad.class, \"fail10()\", 1,  2, 3)\n+        );\n+\n+        runCheck(BadCountsConstraint.create(BadCount.class, \"bad1()\", 1, 1, \"Load\"),\n+                 GoodCountsConstraint.create(BadCount.class, \"bad1()\", 2),\n+                 GoodCountsConstraint.create(BadCount.class, \"bad2()\", 1),\n+                 BadCountsConstraint.create(BadCount.class, \"bad2()\", 2,  1, \"Store\"),\n+                 BadCountsConstraint.create(BadCount.class, \"bad3()\", 1,  1, \"Load\"),\n+                 BadCountsConstraint.create(BadCount.class, \"bad3()\", 2,  1, \"Store\")\n+        );\n+\n+        String[] allocArrayMatches = { \"MyClass\", \"call,static  wrapper for: _new_array_Java\"};\n+        runCheck(BadFailOnConstraint.create(AllocArray.class, \"allocArray()\", 1, allocArrayMatches),\n+                 BadFailOnConstraint.create(AllocArray.class, \"allocArray()\", 2,  allocArrayMatches),\n+                 GoodFailOnConstraint.create(AllocArray.class, \"allocArray()\", 3),\n+                 GoodFailOnConstraint.create(AllocArray.class, \"allocArray()\", 4),\n+                 BadFailOnConstraint.create(AllocArray.class, \"allocArray()\", 5,  allocArrayMatches)\n+        );\n+\n+        runCheck(GoodRuleConstraint.create(RunTests.class, \"good1()\", 1),\n+                 GoodRuleConstraint.create(RunTests.class, \"good1()\", 2),\n+                 GoodRuleConstraint.create(RunTests.class, \"good2()\", 1),\n+                 GoodRuleConstraint.create(RunTests.class, \"good2()\", 2),\n+                 GoodRuleConstraint.create(RunTests.class, \"good3(int)\", 1),\n+                 BadCountsConstraint.create(RunTests.class, \"bad1(int)\", 1, 0),\n+                 BadFailOnConstraint.create(RunTests.class, \"bad1(int)\", 2, \"Load\")\n+        );\n+\n+        runCheck(new String[] {\"-XX:-UseCompressedClassPointers\"},\n+                 BadFailOnConstraint.create(Loads.class, \"load()\", 1, 1, \"Load\"),\n+                 BadFailOnConstraint.create(Loads.class, \"load()\", 1, 3, \"LoadI\"),\n+                 BadCountsConstraint.create(Loads.class, \"load()\", 1, 1, 0),\n+                 BadCountsConstraint.create(Loads.class, \"load()\", 1, 2, 1,\"Load\"),\n+                 GoodRuleConstraint.create(Loads.class, \"load()\", 2),\n+                 GoodFailOnConstraint.create(Loads.class, \"load()\", 3),\n+                 BadCountsConstraint.create(Loads.class, \"load()\", 3, 2, 2,\"Store\"),\n+                 BadFailOnConstraint.create(Loads.class, \"load()\", 4, 2, \"Store\"),\n+                 BadFailOnConstraint.create(Loads.class, \"load()\", 5, \"Load\"),\n+                 BadFailOnConstraint.create(Loads.class, \"load()\", 6, \"Load\"),\n+                 BadFailOnConstraint.create(Loads.class, \"load()\", 7, \"Load\"),\n+                 GoodRuleConstraint.create(Loads.class, \"load()\", 8),\n+                 GoodRuleConstraint.create(Loads.class, \"load()\", 9),\n+                 GoodRuleConstraint.create(Loads.class, \"load()\", 10),\n+                 BadFailOnConstraint.create(Loads.class, \"loadKlass()\", 1),\n+                 BadCountsConstraint.create(Loads.class, \"loadKlass()\", 2, 2,\"Field\")\n+                 );\n+\n+        \/\/ Loops\n+        runCheck(BadFailOnConstraint.create(Loops.class, \"loop()\", 1, \"Loop\"),\n+                 GoodRuleConstraint.create(Loops.class, \"loop()\", 2),\n+                 GoodRuleConstraint.create(Loops.class, \"loop()\", 3),\n+                 GoodRuleConstraint.create(Loops.class, \"countedLoop()\", 1),\n+                 BadFailOnConstraint.create(Loops.class, \"countedLoop()\", 2, \"CountedLoop\"),\n+                 GoodRuleConstraint.create(Loops.class, \"countedLoop()\", 3),\n+                 BadFailOnConstraint.create(Loops.class, \"loopAndCountedLoop()\", 1, \"Loop\"),\n+                 BadFailOnConstraint.create(Loops.class, \"loopAndCountedLoop()\", 2, \"CountedLoop\"),\n+                 GoodRuleConstraint.create(Loops.class, \"loopAndCountedLoop()\", 3),\n+                 GoodRuleConstraint.create(Loops.class, \"countedLoopMain()\", 1),\n+                 BadFailOnConstraint.create(Loops.class, \"countedLoopMain()\", 2, \"CountedLoop\"),\n+                 BadFailOnConstraint.create(Loops.class, \"countedLoopMain()\", 3, \"CountedLoop\", \"main\"),\n+                 GoodRuleConstraint.create(Loops.class, \"countedLoopUnrolled()\", 1),\n+                 GoodRuleConstraint.create(Loops.class, \"countedLoopUnrolled()\", 2),\n+                 GoodRuleConstraint.create(Loops.class, \"countedLoopUnrolled()\", 3)\n+        );\n+\n+        \/\/ Traps\n+        runCheck(GoodRuleConstraint.create(Traps.class, \"noTraps()\", 1),\n+                 BadFailOnConstraint.create(Traps.class, \"noTraps()\", 2, \"Store\", \"iFld\"),\n+                 GoodRuleConstraint.create(Traps.class, \"noTraps()\", 3),\n+                 BadFailOnConstraint.create(Traps.class, \"predicateTrap()\", 1, \"CallStaticJava\", \"uncommon_trap\"),\n+                 BadFailOnConstraint.create(Traps.class, \"predicateTrap()\", 2, \"CallStaticJava\", \"uncommon_trap\", \"predicate\"),\n+                 GoodRuleConstraint.create(Traps.class, \"predicateTrap()\", 3),\n+                 GoodRuleConstraint.create(Traps.class, \"predicateTrap()\", 4),\n+                 BadFailOnConstraint.create(Traps.class, \"nullCheck()\", 1, \"CallStaticJava\", \"uncommon_trap\"),\n+                 BadFailOnConstraint.create(Traps.class, \"nullCheck()\", 2, \"CallStaticJava\", \"uncommon_trap\", \"null_check\"),\n+                 BadFailOnConstraint.create(Traps.class, \"nullCheck()\", 3, \"uncommon_trap\", \"unstable_if\"),\n+                 GoodRuleConstraint.create(Traps.class, \"nullCheck()\", 4),\n+                 BadFailOnConstraint.create(Traps.class, \"nullAssert()\", 1, \"CallStaticJava\", \"uncommon_trap\"),\n+                 BadFailOnConstraint.create(Traps.class, \"nullAssert()\", 2, \"CallStaticJava\", \"uncommon_trap\", \"null_assert\"),\n+                 BadFailOnConstraint.create(Traps.class, \"nullAssert()\", 3, \"CallStaticJava\", \"uncommon_trap\", \"null_check\"),\n+                 GoodRuleConstraint.create(Traps.class, \"nullAssert()\", 4),\n+                 BadFailOnConstraint.create(Traps.class, \"unstableIf(boolean)\", 1, \"CallStaticJava\", \"uncommon_trap\"),\n+                 BadFailOnConstraint.create(Traps.class, \"unstableIf(boolean)\",  2, \"CallStaticJava\", \"uncommon_trap\", \"unstable_if\"),\n+                 GoodRuleConstraint.create(Traps.class, \"unstableIf(boolean)\", 3),\n+                 BadFailOnConstraint.create(Traps.class, \"classCheck()\", 1, \"CallStaticJava\", \"uncommon_trap\"),\n+                 BadFailOnConstraint.create(Traps.class, \"classCheck()\", 2, \"CallStaticJava\", \"uncommon_trap\", \"class_check\"),\n+                 BadFailOnConstraint.create(Traps.class, \"classCheck()\", 3, \"CallStaticJava\", \"uncommon_trap\", \"null_check\"),\n+                 GoodRuleConstraint.create(Traps.class, \"classCheck()\", 4),\n+                 BadFailOnConstraint.create(Traps.class, \"rangeCheck()\", 1, \"CallStaticJava\", \"uncommon_trap\"),\n+                 BadFailOnConstraint.create(Traps.class, \"rangeCheck()\", 2, \"CallStaticJava\", \"uncommon_trap\", \"range_check\"),\n+                 BadFailOnConstraint.create(Traps.class, \"rangeCheck()\", 3, \"CallStaticJava\", \"uncommon_trap\", \"null_check\"),\n+                 GoodRuleConstraint.create(Traps.class, \"rangeCheck()\", 4),\n+                 BadFailOnConstraint.create(Traps.class, \"instrinsicOrTypeCheckedInlining()\", 1, \"CallStaticJava\", \"uncommon_trap\"),\n+                 BadFailOnConstraint.create(Traps.class, \"instrinsicOrTypeCheckedInlining()\", 2, \"CallStaticJava\", \"uncommon_trap\", \"intrinsic_or_type_checked_inlining\"),\n+                 BadFailOnConstraint.create(Traps.class, \"instrinsicOrTypeCheckedInlining()\", 3, \"CallStaticJava\", \"uncommon_trap\", \"null_check\"),\n+                 GoodRuleConstraint.create(Traps.class, \"instrinsicOrTypeCheckedInlining()\", 4)\n+        );\n+\n+\n+        runCheck(new String[] {\"-XX:+BailoutToInterpreterForThrows\"},\n+                 BadFailOnConstraint.create(UnhandledTrap.class, \"unhandled()\", 1, \"CallStaticJava\", \"uncommon_trap\"),\n+                 BadFailOnConstraint.create(UnhandledTrap.class, \"unhandled()\", 2, \"CallStaticJava\", \"uncommon_trap\", \"unhandled\"),\n+                 GoodRuleConstraint.create(UnhandledTrap.class, \"unhandled()\", 3)\n+        );\n+\n+        runCheck(BadFailOnConstraint.create(ScopeObj.class, \"scopeObject()\", 1, \"ScObj\"));\n+        runCheck(BadFailOnConstraint.create(Membar.class, \"membar()\", 1, \"MemBar\"));\n+        runCheck(BadFailOnConstraint.create(CheckCastArray.class, \"array()\", 1, \"cmp\", \"precise klass\"),\n+                 BadFailOnConstraint.create(CheckCastArray.class, \"array()\", 2, 1,\"cmp\", \"precise klass\", \"MyClass\"),\n+                 BadFailOnConstraint.create(CheckCastArray.class, \"array()\", 2, 2,\"cmp\", \"precise klass\", \"ir_framework\/tests\/MyClass\"),\n+                 GoodFailOnConstraint.create(CheckCastArray.class, \"array()\", 3),\n+                 BadFailOnConstraint.create(CheckCastArray.class, \"arrayCopy(java.lang.Object[],java.lang.Class)\", 1, \"checkcast_arraycopy\")\n+        );\n+\n+        \/\/ Redirect stdout to stream and then check if we find required IR encoding read from socket.\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintStream ps = new PrintStream(baos);\n+        PrintStream old = System.out;\n+        System.setOut(ps);\n+\n+        try {\n+            runWithArguments(CompilationOutputOfFails.class);\n+            shouldNotReach();\n+        } catch (IRViolationException e) {\n+            System.out.flush();\n+            String output = baos.toString();\n+            baos.reset();\n+            Pattern pattern = Pattern.compile(\">>> Compilation.*both\\\\d.*\\\\RPrintIdeal:(?:(?!PrintOpto|>>> Compilation)[\\\\S\\\\s])+PrintOptoAssembly\");\n+            Matcher matcher = pattern.matcher(output);\n+            Asserts.assertEQ(matcher.results().count(), (long)7, \"Could not find all both methods: \" + output);\n+            pattern = Pattern.compile(\">>> Compilation.*ideal\\\\d.*\\\\RPrintIdeal:(?:(?!>>> Compilation)[\\\\S\\\\s])+\");\n+            matcher = pattern.matcher(output);\n+            int count = 0;\n+            while (matcher.find()) {\n+                String match = matcher.group();\n+                Asserts.assertFalse(match.contains(\"PrintOptoAssembly\"), \"Cannot contain opto assembly: \" + output);\n+                count++;\n+            }\n+            Asserts.assertEQ(count, 7, \"Could not find all ideal methods: \" + output);\n+            pattern = Pattern.compile(\">>> Compilation.*opto\\\\d.*\\\\RPrintOptoAssembly:(?:(?!>>> Compilation)[\\\\S\\\\s])+\");\n+            matcher = pattern.matcher(output);\n+            count = 0;\n+            while (matcher.find()) {\n+                String match = matcher.group();\n+                Asserts.assertFalse(match.contains(\"PrintIdeal\"), \"Cannot contain opto assembly: \" + output);\n+                count++;\n+            }\n+            Asserts.assertEQ(count, 7, \"Could not find all opto methods\");\n+        }\n+\n+        runWithArguments(FlagComparisons.class, \"-XX:TLABRefillWasteFraction=50\");\n+        System.out.flush();\n+        String output = baos.toString();\n+        baos.reset();\n+        findIrIds(output, \"testMatchAllIf50\", 0, 21);\n+        findIrIds(output, \"testMatchNoneIf50\", -1, -1);\n+\n+        runWithArguments(FlagComparisons.class, \"-XX:TLABRefillWasteFraction=49\");\n+        System.out.flush();\n+        output = baos.toString();\n+        baos.reset();\n+        findIrIds(output, \"testMatchAllIf50\", 4, 6, 13, 18);\n+        findIrIds(output, \"testMatchNoneIf50\", 0, 3, 8, 10, 17, 22);\n+\n+        runWithArguments(FlagComparisons.class, \"-XX:TLABRefillWasteFraction=51\");\n+        System.out.flush();\n+        output = baos.toString();\n+        baos.reset();\n+        findIrIds(output, \"testMatchAllIf50\", 7, 12, 19, 21);\n+        findIrIds(output, \"testMatchNoneIf50\", 4, 7, 11, 16, 20, 22);\n+        System.setOut(old);\n+    }\n+\n+    private static void runWithArguments(Class<?> clazz, String... args) {\n+        new TestFramework(clazz).addFlags(args).start();\n+    }\n+\n+    private static void runCheck(String[] args , Constraint... constraints) {\n+        try {\n+            new TestFramework(constraints[0].getKlass()).addFlags(args).start(); \/\/ All constraints have the same class.\n+            shouldNotReach();\n+        } catch (IRViolationException e) {\n+            checkConstraints(e, constraints);\n+        }\n+    }\n+\n+    private static void runCheck(Constraint... constraints) {\n+        try {\n+            TestFramework.run(constraints[0].getKlass()); \/\/ All constraints have the same class.\n+            shouldNotReach();\n+        } catch (IRViolationException e) {\n+            checkConstraints(e, constraints);\n+        }\n+    }\n+\n+    private static void checkConstraints(IRViolationException e, Constraint[] constraints) {\n+        String message = e.getExceptionInfo();\n+        try {\n+            for (Constraint constraint : constraints) {\n+                constraint.checkConstraint(e);\n+            }\n+        } catch (Exception e1) {\n+            System.out.println(TestFramework.getLastTestVMOutput());\n+            System.out.println(message);\n+            throw e1;\n+        }\n+    }\n+\n+    \/\/ Single constraint\n+    private static void runFailOnTestsArgs(Constraint constraint, String... args) {\n+        try {\n+            new TestFramework(constraint.getKlass()).addFlags(args).start(); \/\/ All constraints have the same class.\n+            shouldNotReach();\n+        } catch (IRViolationException e) {\n+            constraint.checkConstraint(e);\n+        }\n+    }\n+\n+    public static void shouldNotReach() {\n+        throw new ShouldNotReachException(\"Framework did not fail but it should have!\");\n+    }\n+\n+    public static void findIrIds(String output, String method, int... numbers) {\n+        StringBuilder builder = new StringBuilder();\n+        builder.append(method);\n+        for (int i = 0; i < numbers.length; i+=2) {\n+            int start = numbers[i];\n+            int endIncluded = numbers[i + 1];\n+            for (int j = start; j <= endIncluded; j++) {\n+                builder.append(\",\");\n+                builder.append(j);\n+            }\n+        }\n+        Asserts.assertTrue(output.contains(builder.toString()), \"Could not find encoding: \\\"\" + builder.toString()\n+                                                                + System.lineSeparator());\n+    }\n+}\n+\n+class AndOr1 {\n+    @Test\n+    @Arguments(Argument.DEFAULT)\n+    @IR(applyIfAnd = {\"UsePerfData\", \"true\", \"TLABRefillWasteFraction\", \"50\", \"UseTLAB\", \"true\"}, failOn = {IRNode.CALL})\n+    public void test1(int i) {\n+        dontInline();\n+    }\n+\n+    @Test\n+    @IR(applyIfOr = {\"UsePerfData\", \"false\", \"TLABRefillWasteFraction\", \"51\", \"UseTLAB\", \"false\"}, failOn = {IRNode.CALL})\n+    public void test2() {\n+        dontInline();\n+    }\n+\n+    @DontInline\n+    private void dontInline() {\n+    }\n+}\n+\n+class MultipleFailOnGood {\n+    private int iFld;\n+    private MyClassSub myClassSub = new MyClassSub();\n+\n+    @Test\n+    @IR(applyIf = {\"TLABRefillWasteFraction\", \"50\"}, failOn = {IRNode.STORE, IRNode.CALL})\n+    @IR(failOn = {IRNode.STORE, IRNode.CALL})\n+    @IR(applyIfOr = {\"TLABRefillWasteFraction\", \"99\", \"TLABRefillWasteFraction\", \"100\"}, failOn = {IRNode.LOOP, IRNode.CALL}) \/\/ Not applied\n+    public void good1() {\n+        forceInline();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE, IRNode.CALL})\n+    @IR(applyIfNot = {\"TLABRefillWasteFraction\", \"20\"}, failOn = {IRNode.ALLOC})\n+    @IR(applyIfNot = {\"TLABRefillWasteFraction\", \"< 100\"}, failOn = {IRNode.ALLOC_OF, \"Test\"})\n+    public void good2() {\n+        forceInline();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_OF_CLASS, \"Test\", IRNode.CALL})\n+    @IR(applyIfNot = {\"TLABRefillWasteFraction\", \"20\"}, failOn = {IRNode.ALLOC})\n+    @IR(applyIfNot = {\"TLABRefillWasteFraction\", \"< 100\"}, failOn = {IRNode.ALLOC_OF, \"Test\"})\n+    public void good3() {\n+        forceInline();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.CALL, IRNode.STORE_OF_CLASS, \"UnknownClass\"})\n+    public void good4() {\n+        iFld = 42;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_OF_FIELD, \"xFld\", IRNode.CALL})\n+    public void good5() {\n+        iFld = 42;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_OF_CLASS, \"MyClass\"}) \/\/ Needs exact match to fail\n+    public void good6() {\n+        myClassSub.iFld = 42;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_OF_CLASS, \"MyClassSub\"}) \/\/ Static write is with Class and not MySubClass\n+    public void good7() {\n+        MyClassSub.iFldStatic = 42;\n+    }\n+\n+    @ForceInline\n+    private void forceInline() {}\n+}\n+\n+class MultipleFailOnBad {\n+    private int iFld;\n+    private int myInt;\n+    private MyClass myClass;\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE, IRNode.CALL, IRNode.STORE_I, IRNode.LOOP})\n+    public void fail1() {\n+        iFld = 42;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE, IRNode.CALL})\n+    public void fail2() {\n+        dontInline();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.CALL, IRNode.STORE_OF_CLASS, \"MultipleFailOnBad\", IRNode.ALLOC})\n+    public void fail3() {\n+        iFld = 42;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_OF_CLASS, \"ir_framework\/tests\/MultipleFailOnBad\", IRNode.CALL, IRNode.ALLOC})\n+    public void fail4() {\n+        iFld = 42;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_OF_FIELD, \"iFld\", IRNode.CALL, IRNode.ALLOC})\n+    public void fail5() {\n+        iFld = 42;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_OF_CLASS, \"MyClass\", IRNode.ALLOC, IRNode.CALL})\n+    public void fail6() {\n+        myClass = new MyClass();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_OF_CLASS, \"UnknownClass\", IRNode.ALLOC_OF, \"MyClass\"})\n+    public void fail7() {\n+        myClass = new MyClass();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_OF_CLASS, \"UnknownClass\", IRNode.ALLOC_OF, \"ir_framework\/tests\/MyClassSub\"})\n+    public void fail8() {\n+        myClass = new MyClassSub();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE, IRNode.CALL})\n+    public void fail9() {\n+        iFld = 42;\n+        dontInline();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_OF_FIELD, \"iFld\", IRNode.CALL, IRNode.ALLOC})\n+    public void fail10() {\n+        myInt = 34;\n+        iFld = 42;\n+    }\n+\n+    @DontInline\n+    private void dontInline() {}\n+}\n+\n+\/\/ Called with -XX:TLABRefillWasteFraction=X.\n+class FlagComparisons {\n+    \/\/ Applies all IR rules if TLABRefillWasteFraction=50\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"50\"}) \/\/ Index 0\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"=50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"= 50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" =   50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<=50\"}) \/\/ Index 4\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<= 50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" <=  50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \">=50\"}) \/\/ Index 7\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \">= 50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" >=  50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \">49\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"> 49\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" >  49\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<51\"}) \/\/ Index 13\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"< 51\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" <  51\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"!=51\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"!= 51\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" !=  51\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"!=49\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"!= 49\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" !=  49\"}) \/\/ Index 21\n+    public void testMatchAllIf50() {}\n+\n+    \/\/ Applies no IR rules if TLABRefillWasteFraction=50\n+    @Test\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"49\"}) \/\/ Index 0\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"=49\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"= 49\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" =  49\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"51\"}) \/\/ Index 4\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"=51\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"= 51\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" =  51\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<=49\"}) \/\/ Index 8\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<= 49\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" <=  49\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \">=51\"}) \/\/ Index 11\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \">= 51\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" >=  51\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \">50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"> 50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" >  50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<50\"}) \/\/ Index 17\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"< 50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" <  50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"!=50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"!= 50\"})\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" !=  50\"}) \/\/ Index 22\n+    public void testMatchNoneIf50() {}\n+}\n+\n+class CountComparisons {\n+    int iFld;\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"= 1\",\n+                  IRNode.STORE, \"=1\",\n+                  IRNode.STORE, \" = 1\",\n+                  IRNode.STORE, \"  =  1\",\n+                  IRNode.STORE, \">= 1\",\n+                  IRNode.STORE, \">=1\",\n+                  IRNode.STORE, \" >= 1\",\n+                  IRNode.STORE, \"  >=  1\",\n+                  IRNode.STORE, \"<= 1\",\n+                  IRNode.STORE, \"<=1\",\n+                  IRNode.STORE, \" <= 1\",\n+                  IRNode.STORE, \"  <=  1\",\n+                  IRNode.STORE, \"!= 0\",\n+                  IRNode.STORE, \"!=0\",\n+                  IRNode.STORE, \" != 0\",\n+                  IRNode.STORE, \"  !=  0\",\n+                  IRNode.STORE, \"> 0\",\n+                  IRNode.STORE, \">0\",\n+                  IRNode.STORE, \" > 0\",\n+                  IRNode.STORE, \"  >  0\",\n+                  IRNode.STORE, \"< 2\",\n+                  IRNode.STORE, \"<2\",\n+                  IRNode.STORE, \" < 2\",\n+                  IRNode.STORE, \"  <  2\",\n+    })\n+    public void countComparison() {\n+        iFld = 3;\n+    }\n+}\n+\n+class GoodCount {\n+    boolean flag;\n+    char cFld;\n+    byte bFld;\n+    short sFld;\n+    int iFld;\n+    long lFld;\n+    float fFld;\n+    double dFld;\n+    long x;\n+\n+    long result;\n+    MyClass myClass = new MyClass();\n+    MyClass myClassSubPoly = new MyClassSub();\n+    MyClassSub myClassSub = new MyClassSub();\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"1\", IRNode.STORE_I, \"1\"},\n+        failOn = {IRNode.STORE_B, IRNode.STORE_C, IRNode.STORE_D,\n+                  IRNode.STORE_F, IRNode.STORE_L})\n+    public void good1() {\n+        iFld = 3;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"8\",\n+                  IRNode.STORE_B, \"2\", \/\/ bFld + flag\n+                  IRNode.STORE_C, \"2\", \/\/ cFld + sFld\n+                  IRNode.STORE_I, \"1\",\n+                  IRNode.STORE_L, \"1\",\n+                  IRNode.STORE_F, \"1\",\n+                  IRNode.STORE_D, \"1\"})\n+    public void good2() {\n+        flag = true;\n+        cFld = 'a';\n+        bFld = 1;\n+        sFld = 2;\n+        iFld = 3;\n+        lFld = 4L;\n+        fFld = 5.0f;\n+        dFld = 6.0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"8\", IRNode.STORE_OF_CLASS, \"GoodCount\", \"8\",\n+                  IRNode.STORE_B, \"2\", IRNode.STORE_B_OF_CLASS, \"GoodCount\", \"2\",\n+                  IRNode.STORE_C, \"2\", IRNode.STORE_C_OF_CLASS, \"GoodCount\", \"2\",\n+                  IRNode.STORE_I, \"1\", IRNode.STORE_I_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.STORE_L, \"1\", IRNode.STORE_L_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.STORE_F, \"1\", IRNode.STORE_F_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.STORE_D, \"1\", IRNode.STORE_D_OF_CLASS, \"GoodCount\", \"1\"})\n+    public void good3() {\n+        flag = true;\n+        cFld = 'a';\n+        bFld = 1;\n+        sFld = 2;\n+        iFld = 3;\n+        lFld = 4L;\n+        fFld = 5.0f;\n+        dFld = 6.0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"8\", IRNode.STORE_OF_CLASS, \"GoodCount\", \"8\",\n+                  IRNode.STORE_B, \"2\", IRNode.STORE_B_OF_CLASS, \"GoodCount\", \"2\",\n+                  IRNode.STORE_C, \"2\", IRNode.STORE_C_OF_CLASS, \"GoodCount\", \"2\",\n+                  IRNode.STORE_I, \"1\", IRNode.STORE_I_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.STORE_L, \"1\", IRNode.STORE_L_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.STORE_F, \"1\", IRNode.STORE_F_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.STORE_D, \"1\", IRNode.STORE_D_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.STORE_OF_FIELD, \"lFld\", \"1\"})\n+    public void good4() {\n+        flag = true;\n+        cFld = 'a';\n+        bFld = 1;\n+        sFld = 2;\n+        iFld = 3;\n+        lFld = 4L;\n+        fFld = 5.0f;\n+        dFld = 6.0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"2\", IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\",\n+                  IRNode.STORE_OF_CLASS, \"GoodCount\", \"1\", IRNode.STORE_L_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.STORE_OF_CLASS, \"ir_framework\/tests\/MyClass\", \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"ir_framework\/tests\/MyClass\", \"1\",\n+                  IRNode.STORE_OF_CLASS, \"ir_framework\/tests\/GoodCount\", \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"ir_framework\/tests\/GoodCount\", \"1\",\n+                  IRNode.STORE_OF_FIELD, \"x\", \"2\"})\n+    public void good5() {\n+        x = 3; \/\/ long\n+        myClass.x = 4; \/\/ int\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_OF_FIELD, \"myClass\", \"1\", IRNode.STORE_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.STORE_OF_CLASS, \"\/GoodCount\", \"1\", IRNode.STORE_OF_CLASS, \"MyClass\", \"0\"},\n+        failOn = {IRNode.STORE_OF_CLASS, \"MyClass\"})\n+    public void good6() {\n+        myClass = new MyClass();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_OF_FIELD, \"iFld\", \"3\", IRNode.STORE_OF_CLASS, \"GoodCount\", \"0\",\n+                  IRNode.STORE_OF_CLASS, \"MyClass\", \"2\", IRNode.STORE_OF_CLASS, \"MyClassSub\", \"1\",\n+                  IRNode.STORE, \"3\"},\n+        failOn = {IRNode.STORE_OF_CLASS, \"GoodCount\"})\n+    public void good7() {\n+        myClass.iFld = 1;\n+        myClassSubPoly.iFld = 2;\n+        myClassSub.iFld = 3;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"1\", IRNode.STORE, \"1\"})\n+    public void good8() {\n+        result = iFld;\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"4\", IRNode.STORE, \"1\", IRNode.LOAD_OF_FIELD, \"iFld\", \"2\", IRNode.LOAD_OF_FIELD, \"iFld2\", \"0\",\n+                  IRNode.LOAD_OF_FIELD, \"lFldStatic\", \"1\", IRNode.LOAD_OF_CLASS, \"GoodCount\", \"2\", IRNode.LOAD_OF_CLASS, \"MyClass\", \"1\",\n+                  IRNode.STORE_OF_CLASS, \"GoodCount\", \"1\", IRNode.STORE_OF_FIELD, \"result\", \"1\",\n+                  IRNode.LOAD_OF_FIELD, \"myClass\", \"1\"})\n+    public void good9() {\n+        result = iFld + MyClass.lFldStatic + myClass.iFld; \/\/ 1 + 1 + 2 loads (myClass is LoadN of GoodCount and myClass.iFld a LoadI of MyClass)\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"8\",\n+                  IRNode.LOAD_B, \"1\",\n+                  IRNode.LOAD_UB, \"1\",\n+                  IRNode.LOAD_S, \"1\",\n+                  IRNode.LOAD_US, \"1\",\n+                  IRNode.LOAD_I, \"1\",\n+                  IRNode.LOAD_L, \"1\",\n+                  IRNode.LOAD_F, \"1\",\n+                  IRNode.LOAD_D, \"1\"})\n+    public void good10() {\n+        bFld++;\n+        cFld++;\n+        sFld++;\n+        iFld++;\n+        lFld++;\n+        fFld++;\n+        dFld++;\n+        flag = !flag;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"8\", IRNode.LOAD_OF_CLASS, \"GoodCount\", \"8\",\n+                  IRNode.LOAD_B, \"1\", IRNode.LOAD_B_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.LOAD_UB, \"1\", IRNode.LOAD_UB_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.LOAD_S, \"1\", IRNode.LOAD_S_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.LOAD_US, \"1\", IRNode.LOAD_US_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.LOAD_I, \"1\", IRNode.LOAD_I_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.LOAD_L, \"1\", IRNode.LOAD_L_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.LOAD_F, \"1\", IRNode.LOAD_F_OF_CLASS, \"GoodCount\", \"1\",\n+                  IRNode.LOAD_D, \"1\", IRNode.LOAD_D_OF_CLASS, \"GoodCount\", \"1\"})\n+    public void good11() {\n+        bFld++;\n+        cFld++;\n+        sFld++;\n+        iFld++;\n+        lFld++;\n+        fFld++;\n+        dFld++;\n+        flag = !flag;\n+    }\n+}\n+\n+class BadCount {\n+    int iFld;\n+    int result;\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"!= 1\"})\n+    @IR(counts = {IRNode.STORE, \"> 0\"})\n+    public void bad1() {\n+        result = iFld;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"1\"})\n+    @IR(counts = {IRNode.STORE, \"< 1\"})\n+    public void bad2() {\n+        result = iFld;\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"0\"})\n+    @IR(counts = {IRNode.STORE, \" <= 0\"})\n+    public void bad3() {\n+        result = iFld;\n+    }\n+}\n+\n+\n+class RunTests {\n+    public int iFld;\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"1\"})\n+    @IR(failOn = IRNode.LOAD)\n+    public void good1() {\n+        iFld = 42;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD, \"1\"})\n+    @IR(failOn = IRNode.STORE)\n+    public int good2() {\n+        return iFld;\n+    }\n+\n+    @Run(test = {\"good1\", \"good2\"})\n+    public void runGood1() {\n+        good1();\n+        good2();\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"1\"})\n+    @IR(failOn = IRNode.LOAD)\n+    public void good3(int x) {\n+        iFld = x;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"1\"})\n+    @IR(failOn = IRNode.LOAD)\n+    public int bad1(int x) {\n+        return iFld + x;\n+    }\n+\n+    @Run(test = {\"bad1\", \"good3\"})\n+    public void run() {\n+        bad1(2);\n+        good3(4);\n+    }\n+}\n+\n+\n+class AllocArray {\n+    MyClass[] myClassArray;\n+\n+    @Test\n+    @IR(failOn = {IRNode.ALLOC_ARRAY})\n+    @IR(failOn = {IRNode.ALLOC_ARRAY_OF, \"MyClass\"})\n+    @IR(failOn = {IRNode.ALLOC_ARRAY_OF, \"MyClasss\"}) \/\/ Does not fail\n+    @IR(failOn = {IRNode.ALLOC_ARRAY_OF, \"ir_framework\/tests\/MySubClass\"}) \/\/ Does not fail\n+    @IR(failOn = {IRNode.ALLOC_ARRAY_OF, \"ir_framework\/tests\/MyClass\"})\n+    public void allocArray() {\n+        myClassArray = new MyClass[2];\n+    }\n+}\n+\n+class Loads {\n+    int iFld = 34;\n+    int result = 0;\n+    Object myClass = new MyClass();\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD, IRNode.LOOP, IRNode.LOAD_I}, counts = {IRNode.LOOP, \"2\", IRNode.LOAD, \"2\", IRNode.STORE, \"2\"})\n+    @IR(failOn = {IRNode.LOOP, IRNode.LOOP}, counts = {IRNode.LOOP, \"0\", IRNode.LOAD, \"1\"}) \/\/ Does not fail\n+    @IR(failOn = {IRNode.LOOP, IRNode.LOOP}, counts = {IRNode.LOOP, \"0\", IRNode.STORE, \"1\"})\n+    @IR(failOn = {IRNode.LOOP, IRNode.STORE}, counts = {IRNode.LOOP, \"0\", IRNode.LOAD, \"1\"})\n+    @IR(failOn = {IRNode.LOAD_OF_CLASS, \"ir_framework\/tests\/Loads\"})\n+    @IR(failOn = {IRNode.LOAD_OF_CLASS, \"Loads\"})\n+    @IR(failOn = {IRNode.LOAD_OF_FIELD, \"iFld\"})\n+    @IR(failOn = {IRNode.LOAD_OF_FIELD, \"iFld2\", IRNode.LOAD_OF_CLASS, \"Load\"}) \/\/ Does not fail\n+    @IR(failOn = {IRNode.LOAD_KLASS}) \/\/ Does not fail\n+    @IR(counts = {IRNode.FIELD_ACCESS, \"3\"}) \/\/ Does not fail\n+    public void load() {\n+        result = iFld;\n+        iFld = 3;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD_KLASS})\n+    @IR(counts = {IRNode.FIELD_ACCESS, \"3\"})\n+    public void loadKlass() {\n+        if (myClass instanceof MyClass) {\n+            result = 3;\n+        }\n+    }\n+}\n+\n+class Loops {\n+    int limit = 1024;\n+    int[] iArr = new int[100];\n+\n+    @DontInline\n+    public void dontInline() {}\n+\n+    @Test\n+    @IR(failOn = IRNode.LOOP) \/\/ fails\n+    @IR(failOn = IRNode.COUNTEDLOOP)\n+    @IR(failOn = IRNode.COUNTEDLOOP_MAIN)\n+    public void loop() {\n+        for (int i = 0; i < limit; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.LOOP)\n+    @IR(failOn = IRNode.COUNTEDLOOP) \/\/ fails\n+    @IR(failOn = IRNode.COUNTEDLOOP_MAIN)\n+    public void countedLoop() {\n+        for (int i = 0; i < 2000; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.LOOP) \/\/ fails\n+    @IR(failOn = IRNode.COUNTEDLOOP) \/\/ fails\n+    @IR(failOn = IRNode.COUNTEDLOOP_MAIN)\n+    public void loopAndCountedLoop() {\n+        for (int i = 0; i < 2000; i++) {\n+            for (int j = 0; j < limit; j++) {\n+                dontInline();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.LOOP)\n+    @IR(failOn = IRNode.COUNTEDLOOP) \/\/ fails\n+    @IR(failOn = IRNode.COUNTEDLOOP_MAIN) \/\/ fails\n+    public void countedLoopMain() {\n+        \/\/ Cannot unroll completely -> create pre\/main\/post\n+        for (int i = 0; i < 100; i++) {\n+            iArr[i] = i;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.LOOP)\n+    @IR(failOn = IRNode.COUNTEDLOOP)\n+    @IR(failOn = IRNode.COUNTEDLOOP_MAIN)\n+    public void countedLoopUnrolled() {\n+        \/\/ Completely unrolled -> no pre\/main\/post\n+        for (int i = 0; i < 8; i++) {\n+            iArr[i] = i;\n+        }\n+    }\n+}\n+\n+class Traps {\n+    int number42 = 42;\n+    int iFld = 10;\n+    int[] iArr = new int[2];\n+    MyClass myClass = new MyClass();\n+    MyClassSub myClassSub = new MyClassSub();\n+    NotLoaded notLoaded = new NotLoaded();\n+    Object[] oArr = new Object[10];\n+    MyClass[] mArr = new MyClass[10];\n+\n+    @Test\n+    @IR(failOn = IRNode.TRAP)\n+    @IR(failOn = {IRNode.STORE_OF_FIELD, \"iFld\"}) \/\/ fails\n+    @IR(failOn = {IRNode.PREDICATE_TRAP,\n+                  IRNode.UNSTABLE_IF_TRAP,\n+                  IRNode.NULL_CHECK_TRAP,\n+                  IRNode.NULL_ASSERT_TRAP,\n+                  IRNode.RANGE_CHECK_TRAP,\n+                  IRNode.CLASS_CHECK_TRAP,\n+                  IRNode.INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP,\n+                  IRNode.UNHANDLED_TRAP})\n+    public void noTraps() {\n+        for (int i = 0; i < 100; i++) {\n+            if (i < 42) {\n+                \/\/ Reached, no uncommon trap\n+                iFld = i;\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.TRAP) \/\/ fails\n+    @IR(failOn = IRNode.PREDICATE_TRAP) \/\/ fails\n+    @IR(failOn = {IRNode.STORE_OF_FIELD, \"iFld\"})\n+    @IR(failOn = {IRNode.UNSTABLE_IF_TRAP,\n+                  IRNode.NULL_CHECK_TRAP,\n+                  IRNode.NULL_ASSERT_TRAP,\n+                  IRNode.RANGE_CHECK_TRAP,\n+                  IRNode.CLASS_CHECK_TRAP,\n+                  IRNode.INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP,\n+                  IRNode.UNHANDLED_TRAP})\n+    public void predicateTrap() {\n+        for (int i = 0; i < 100; i++) {\n+            if (number42 != 42) {\n+                \/\/ Never reached\n+                iFld = i;\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.TRAP) \/\/ fails\n+    @IR(failOn = IRNode.NULL_CHECK_TRAP) \/\/ fails\n+    @IR(failOn = IRNode.UNSTABLE_IF_TRAP) \/\/ fails\n+    @IR(failOn = {IRNode.PREDICATE_TRAP,\n+                  IRNode.NULL_ASSERT_TRAP,\n+                  IRNode.RANGE_CHECK_TRAP,\n+                  IRNode.CLASS_CHECK_TRAP,\n+                  IRNode.INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP,\n+                  IRNode.UNHANDLED_TRAP})\n+    public void nullCheck() {\n+        if (myClass instanceof MyClassSub) {\n+            iFld = 4;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.TRAP) \/\/ fails\n+    @IR(failOn = IRNode.NULL_ASSERT_TRAP) \/\/ fails\n+    @IR(failOn = IRNode.NULL_CHECK_TRAP) \/\/ fails\n+    @IR(failOn = {IRNode.PREDICATE_TRAP,\n+                  IRNode.UNSTABLE_IF_TRAP,\n+                  IRNode.RANGE_CHECK_TRAP,\n+                  IRNode.CLASS_CHECK_TRAP,\n+                  IRNode.INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP,\n+                  IRNode.UNHANDLED_TRAP})\n+    public Object nullAssert() {\n+        return notLoaded.notLoadedFld;\n+    }\n+\n+    @Test\n+    @Arguments(Argument.TRUE)\n+    @IR(failOn = IRNode.TRAP) \/\/ fails\n+    @IR(failOn = IRNode.UNSTABLE_IF_TRAP) \/\/ fails\n+    @IR(failOn = {IRNode.PREDICATE_TRAP,\n+                  IRNode.NULL_CHECK_TRAP,\n+                  IRNode.NULL_ASSERT_TRAP,\n+                  IRNode.RANGE_CHECK_TRAP,\n+                  IRNode.CLASS_CHECK_TRAP,\n+                  IRNode.INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP,\n+                  IRNode.UNHANDLED_TRAP})\n+    public void unstableIf(boolean flag) {\n+        if (flag) {\n+            iFld++;\n+        } else {\n+            iFld--;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.TRAP) \/\/ fails\n+    @IR(failOn = IRNode.CLASS_CHECK_TRAP) \/\/ fails\n+    @IR(failOn = IRNode.NULL_CHECK_TRAP) \/\/ fails\n+    @IR(failOn = {IRNode.PREDICATE_TRAP,\n+                  IRNode.UNSTABLE_IF_TRAP,\n+                  IRNode.NULL_ASSERT_TRAP,\n+                  IRNode.RANGE_CHECK_TRAP,\n+                  IRNode.INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP,\n+                  IRNode.UNHANDLED_TRAP})\n+    public void classCheck() {\n+        try {\n+            myClassSub = (MyClassSub) myClass;\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.TRAP) \/\/ fails\n+    @IR(failOn = IRNode.RANGE_CHECK_TRAP) \/\/ fails\n+    @IR(failOn = IRNode.NULL_CHECK_TRAP) \/\/ fails\n+    @IR(failOn = {IRNode.PREDICATE_TRAP,\n+                  IRNode.UNSTABLE_IF_TRAP,\n+                  IRNode.NULL_ASSERT_TRAP,\n+                  IRNode.CLASS_CHECK_TRAP,\n+                  IRNode.INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP,\n+                  IRNode.UNHANDLED_TRAP})\n+    public void rangeCheck() {\n+        iArr[1] = 3;\n+    }\n+\n+\n+    @Test\n+    @IR(failOn = IRNode.TRAP) \/\/ fails\n+    @IR(failOn = IRNode.INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP) \/\/ fails\n+    @IR(failOn = IRNode.NULL_CHECK_TRAP) \/\/ fails\n+    @IR(failOn = {IRNode.PREDICATE_TRAP,\n+                  IRNode.UNSTABLE_IF_TRAP,\n+                  IRNode.NULL_ASSERT_TRAP,\n+                  IRNode.CLASS_CHECK_TRAP,\n+                  IRNode.RANGE_CHECK_TRAP,\n+                  IRNode.UNHANDLED_TRAP})\n+    public void instrinsicOrTypeCheckedInlining() {\n+        System.arraycopy(oArr, 0, mArr, 0, 8);\n+    }\n+}\n+\n+class UnhandledTrap {\n+    int iFld = 34;\n+\n+    @Test\n+    @IR(failOn = IRNode.TRAP) \/\/ fails\n+    @IR(failOn = IRNode.UNHANDLED_TRAP) \/\/ fails\n+    @IR(failOn = {IRNode.PREDICATE_TRAP,\n+                  IRNode.UNSTABLE_IF_TRAP,\n+                  IRNode.NULL_CHECK_TRAP,\n+                  IRNode.NULL_ASSERT_TRAP,\n+                  IRNode.RANGE_CHECK_TRAP,\n+                  IRNode.CLASS_CHECK_TRAP})\n+    public void unhandled() {\n+        try {\n+            throw new RuntimeException();\n+        } catch (RuntimeException e) {\n+            \/\/ Expected\n+        }\n+    }\n+}\n+\n+class ScopeObj {\n+\n+    @DontInline\n+    public void dontInline(int i) {}\n+\n+    @Test\n+    @IR(failOn = IRNode.SCOPE_OBJECT) \/\/ fails\n+    public int scopeObject() {\n+        MyClass myClass = new MyClass();\n+        for (int i = 0; i < 100; i++) {\n+            dontInline(myClass.iFld);\n+        }\n+        return 3;\n+    }\n+}\n+\n+class Membar {\n+    volatile MyClass myClass;\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR) \/\/ fails\n+    public int membar() {\n+        myClass = new MyClass();\n+        return myClass.x;\n+    }\n+}\n+\n+class CheckCastArray {\n+    Object[] oArr = new Object[10];\n+    MyClass[] mArr = new MyClass[10];\n+\n+    @Test\n+    @IR(failOn = IRNode.CHECKCAST_ARRAY) \/\/ fails\n+    @IR(failOn = {IRNode.CHECKCAST_ARRAY_OF, \"MyClass\", \/\/ fails\n+                  IRNode.CHECKCAST_ARRAY_OF, \"ir_framework\/tests\/MyClass\"}) \/\/ fails\n+    @IR(failOn = {IRNode.CHECKCAST_ARRAY_OF, \"MyClasss\", IRNode.CHECKCAST_ARRAY_OF, \"Object\"})\n+    public boolean array() {\n+        return oArr instanceof MyClass[];\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.CHECKCAST_ARRAYCOPY) \/\/ fails\n+    public Object[] arrayCopy(Object[] src, Class klass) {\n+        return Arrays.copyOf(src, 8, klass);\n+    }\n+\n+    @Run(test = \"arrayCopy\")\n+    public void testArrayCopy() {\n+        arrayCopy(mArr, MyClass[].class);\n+        arrayCopy(mArr, Object[].class);\n+        arrayCopy(mArr, MyClass2[].class);\n+    }\n+}\n+\n+class CompilationOutputOfFails {\n+\n+    @Test\n+    @IR(failOn = IRNode.COUNTEDLOOP + \"[\\\\s\\\\S]*\" + \"call\")\n+    public void both1() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.COUNTEDLOOP + \"|\" + \"call\")\n+    public void both2() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.COUNTEDLOOP)\n+    @IR(failOn = \"call\")\n+    public void both3() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.COUNTEDLOOP + \"[\\\\s\\\\S]*\" + \"call\", \"0\"})\n+    public void both4() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.COUNTEDLOOP + \"|\" + \"call\", \"1\"})\n+    public void both5() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.COUNTEDLOOP, \"0\"})\n+    @IR(counts = {\"call\", \"1\"})\n+    public void both6() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.COUNTEDLOOP)\n+    @IR(counts = {\"call\", \"1\"})\n+    public void both7() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.COUNTEDLOOP)\n+    public void ideal1() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.COUNTEDLOOP)\n+    @IR(failOn = IRNode.ALLOC) \/\/ not fail\n+    public void ideal2() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.COUNTEDLOOP)\n+    @IR(counts = {IRNode.ALLOC, \"0\"}) \/\/ not fail\n+    public void ideal3() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.COUNTEDLOOP, \"2\"})\n+    public void ideal4() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ALLOC) \/\/ not fail\n+    @IR(counts = {IRNode.COUNTEDLOOP, \"2\"})\n+    public void ideal5() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ALLOC, \"0\"}) \/\/ not fail\n+    @IR(counts = {IRNode.COUNTEDLOOP, \"2\"})\n+    public void ideal6() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.COUNTEDLOOP, \"5\"})\n+    @IR(counts = {IRNode.COUNTEDLOOP, \"2\"})\n+    public void ideal7() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = \"call\")\n+    public void opto1() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = \"call\")\n+    @IR(failOn = IRNode.STORE) \/\/ not fail\n+    public void opto2() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = \"call\")\n+    @IR(counts = {IRNode.COUNTEDLOOP, \"1\"}) \/\/ not fail\n+    public void opto3() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"call\", \"1\"})\n+    public void opto4() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.STORE) \/\/ not fail\n+    @IR(counts = {\"call\", \"1\"})\n+    public void opto5() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"0\"}) \/\/ not fail\n+    @IR(counts = {\"call\", \"1\"})\n+    public void opto6() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"call\", \"10\"})\n+    @IR(counts = {\"call\", \"1\"})\n+    public void opto7() {\n+        for (int i = 0; i < 100; i++) {\n+            dontInline();\n+        }\n+    }\n+\n+    @DontInline\n+    private void dontInline() {}\n+}\n+\n+\n+\/\/ Used only by class Traps\n+class NotLoaded {\n+    NotLoadedHelper notLoadedFld;\n+}\n+\n+\/\/ Used only by class Traps\n+class NotLoadedHelper {}\n+\n+class MyClass {\n+    int iFld = 3;\n+    int x = 5;\n+    static long lFldStatic;\n+}\n+\n+class MyClass2 {}\n+\n+class MyClassSub extends MyClass {\n+    int iFld;\n+    static int iFldStatic;\n+}\n+\n+class ShouldNotReachException extends RuntimeException {\n+    ShouldNotReachException(String s) {\n+        super(s);\n+    }\n+}\n+\n+\n+\/\/ Base class for any kind of constraint that is used to verify if the framework reports the correct IR failures.\n+abstract class Constraint {\n+    private final Class<?> klass;\n+    protected final int ruleIdx;\n+    private final Pattern methodPattern;\n+    private final String classAndMethod;\n+    protected final Pattern irPattern;\n+    private final String methodName;\n+    protected boolean matched;\n+\n+    Constraint(Class<?> klass, String methodName, int ruleIdx, Pattern irPattern) {\n+        this.klass = klass;\n+        classAndMethod = klass.getSimpleName() + \".\" + methodName;\n+        this.ruleIdx = ruleIdx;\n+        this.methodPattern = Pattern.compile(Pattern.quote(classAndMethod));\n+        this.irPattern = irPattern;\n+        this.methodName = methodName;\n+        this.matched = false;\n+    }\n+\n+    \/\/ For good constraints only\n+    Constraint(Class<?> klass, String methodName, int ruleIdx) {\n+        this.klass = klass;\n+        classAndMethod = klass.getSimpleName() + \".\" + methodName;\n+        this.ruleIdx = ruleIdx;\n+        this.methodPattern = Pattern.compile(Pattern.quote(classAndMethod));\n+        this.irPattern = null;\n+        this.methodName = methodName;\n+        this.matched = false;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Constraint \" + getClass().getSimpleName() + \", method: \" + methodName + \", rule: \" + ruleIdx;\n+    }\n+\n+    public Class<?> getKlass() {\n+        return klass;\n+    }\n+\n+    protected String errorPrefix() {\n+        return \"Method \" + methodName + \", Rule \" + ruleIdx;\n+    }\n+\n+    public void checkConstraint(IRViolationException e) {\n+        String message = e.getExceptionInfo();\n+        String[] splitMethods = message.split(\"Method\");\n+        for (int i = 1; i < splitMethods.length; i++) {\n+            String method = splitMethods[i];\n+            if (methodPattern.matcher(method).find()) {\n+                String[] splitIrRules = method.split(\"@IR \");\n+                for (int j = 1; j < splitIrRules.length; j++) {\n+                    String irRule = splitIrRules[j];\n+                    if (irRule.startsWith(\"rule \" + ruleIdx)) {\n+                        checkIRRule(irRule);\n+                    }\n+                }\n+            }\n+        }\n+        Asserts.assertTrue(matched, toString() + \" should have been matched\");\n+    }\n+\n+    abstract protected void checkIRRule(String irRule);\n+\n+    protected void checkOnMethod(String method) {}\n+}\n+\n+\/\/ Constraint for rule that does not fail.\n+class GoodRuleConstraint extends Constraint {\n+\n+    GoodRuleConstraint(Class<?> klass, String methodName, int ruleIdx) {\n+        super(klass, methodName, ruleIdx);\n+        matched = true;\n+    }\n+\n+    public static GoodRuleConstraint create(Class<?> klass, String methodName, int ruleIdx) {\n+        return new GoodRuleConstraint(klass, methodName, ruleIdx);\n+    }\n+\n+    @Override\n+    protected void checkIRRule(String irRule) {\n+        Asserts.fail(errorPrefix() + \" should not fail:\" + System.lineSeparator() + irRule);\n+    }\n+}\n+\n+\/\/ Constraint for rule that might fail but not with \"failOn\".\n+class GoodFailOnConstraint extends GoodRuleConstraint {\n+\n+    private GoodFailOnConstraint(Class<?> klass, String methodName, int ruleIdx) {\n+        super(klass, methodName, ruleIdx);\n+    }\n+\n+    public static GoodFailOnConstraint create(Class<?> klass, String methodName, int ruleIdx) {\n+        return new GoodFailOnConstraint(klass, methodName, ruleIdx);\n+    }\n+\n+    @Override\n+    protected void checkIRRule(String irRule) {\n+        Asserts.assertFalse(irRule.contains(\"- failOn\"), errorPrefix() + \" should not have failed:\" + System.lineSeparator() + irRule);\n+    }\n+}\n+\n+\/\/ Constraint for rule that might fail but not with \"counts\".\n+class GoodCountsConstraint extends GoodRuleConstraint {\n+\n+    private GoodCountsConstraint(Class<?> klass, String methodName, int ruleIdx) {\n+        super(klass, methodName, ruleIdx);\n+    }\n+\n+    public static GoodCountsConstraint create(Class<?> klass, String methodName, int ruleIdx) {\n+        return new GoodCountsConstraint(klass, methodName, ruleIdx);\n+    }\n+\n+    @Override\n+    protected void checkIRRule(String irRule) {\n+        Asserts.assertFalse(irRule.contains(\"- counts\"), errorPrefix() + \" should not have failed with counts:\"\n+                                                         + System.lineSeparator() + irRule);\n+    }\n+}\n+\n+\/\/ Base class for all Regex based constraint.\n+abstract class RegexConstraint extends Constraint {\n+    final String category;\n+    final String otherCategory;\n+    final int[] regexIndexes;\n+    final boolean isGood;\n+    final List<String> matches;\n+\n+    RegexConstraint(Class<?> klass, String methodName, String category, boolean isGood, List<String> matches, int ruleIdx, int... regexIndexes) {\n+        super(klass, methodName, ruleIdx, initIRPattern(category, ruleIdx));\n+        this.category = category;\n+        this.regexIndexes = regexIndexes;\n+        if (category.equals(\"failOn\")) {\n+            this.otherCategory = \"counts\";\n+        } else {\n+            Asserts.assertTrue(category.equals(\"counts\"));\n+            this.otherCategory = \"failOn\";\n+        }\n+        this.isGood = isGood;\n+        this.matches = matches;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String msg = super.toString() + \", \";\n+        if (regexIndexes.length > 1) {\n+            msg += \"regexes: [\" + String.join(\", \", Arrays.stream(regexIndexes).mapToObj(String::valueOf).toArray(String[]::new)) + \"]\";\n+        } else {\n+            msg += \"regex: \" + regexIndexes[0];\n+        }\n+        return msg;\n+    }\n+\n+    @Override\n+    protected String errorPrefix() {\n+        return super.errorPrefix() + \" with \\\"\" + category + \"\\\"\";\n+    }\n+\n+    private static Pattern initIRPattern(String category, int ruleIdx) {\n+        if (category.equals(\"failOn\")) {\n+            return Pattern.compile(\"rule \" + ruleIdx + \":.*\\\\R.*- failOn: Graph contains forbidden nodes.*\\\\R\" +\n+                                   \".*Regex \\\\d+:.*\\\\R.*Matched forbidden node.*\");\n+        } else {\n+            return Pattern.compile(\"rule \" + ruleIdx + \":.*\\\\R.*- counts: Graph contains wrong number of nodes:\\\\R\" +\n+                                   \".*Regex \\\\d+:.*\\\\R.*Expected.*\");\n+        }\n+    }\n+\n+    @Override\n+    protected void checkIRRule(String irRule) {\n+        int categoryIndex = irRule.indexOf(\"- \" + category);\n+        Asserts.assertTrue(categoryIndex != -1, errorPrefix() + \" should have failed\");\n+\n+        int endIndex;\n+        int otherCategoryIndex = irRule.indexOf(\"- \" + otherCategory);\n+        if (otherCategoryIndex == -1 || categoryIndex > otherCategoryIndex) {\n+            endIndex = irRule.length();\n+        } else {\n+            endIndex = otherCategoryIndex;\n+        }\n+        String categoryString = irRule.substring(irRule.indexOf(\"- \" + category), endIndex);\n+        Pattern pattern;\n+        Matcher matcher;\n+        for (int regexIndex : this.regexIndexes) {\n+            pattern = Pattern.compile(\"Regex \" + regexIndex + \":.*\");\n+            matcher = pattern.matcher(categoryString);\n+            if (isGood) {\n+                Asserts.assertFalse(matcher.find(), errorPrefix() + \" failed with Regex \" + regexIndex);\n+                matched = true;\n+            } else {\n+                Asserts.assertTrue(matcher.find(), errorPrefix() + \" should have failed at Regex \" + regexIndex);\n+                String[] splitRegex = categoryString.split(\"Regex \");\n+                if (matches != null) {\n+                    for (int i = 1; i < splitRegex.length; i++) {\n+                        String regexString = splitRegex[i];\n+                        if (regexString.startsWith(String.valueOf(regexIndex))) {\n+                            Asserts.assertTrue(matches.stream().allMatch(regexString::contains),\n+                                               errorPrefix() + \" could not find all matches at Regex \" + regexIndex);\n+                            matched = true;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+\/\/ Base class for all good regex based constraints.\n+abstract class GoodRegexConstraint extends RegexConstraint {\n+\n+    GoodRegexConstraint(Class<?> klass, String methodName, String category, int ruleIdx, int... regexIndexes) {\n+        super(klass, methodName, category, true, null, ruleIdx, regexIndexes);\n+    }\n+}\n+\n+\/\/ Constraint for rule that might fail with \"counts\" or \"failOn\", but the specified regex in \"failOn\" does not fail.\n+class GoodFailOnRegexConstraint extends GoodRegexConstraint {\n+\n+    private GoodFailOnRegexConstraint(Class<?> klass, String methodName, int ruleIdx, int... regexIndexes) {\n+        super(klass, methodName, \"failOn\", ruleIdx, regexIndexes);\n+    }\n+\n+\n+    public static GoodFailOnRegexConstraint create(Class<?> klass, String methodName, int ruleIdx, int... regexIndexes) {\n+        return new GoodFailOnRegexConstraint(klass, methodName, ruleIdx, regexIndexes);\n+    }\n+}\n+\n+\n+\/\/ Constraint for rule that might fail with \"counts\" or \"failOn\", but the specified regex in \"counts\" does not fail.\n+class GoodCountsRegexConstraint extends GoodRegexConstraint {\n+\n+    private GoodCountsRegexConstraint(Class<?> klass, String methodName, int ruleIdx, int... regexIndexes) {\n+        super(klass, methodName, \"counts\", ruleIdx, regexIndexes);\n+    }\n+\n+\n+    public static GoodCountsRegexConstraint create(Class<?> klass, String methodName, int ruleIdx, int... regexIndexes) {\n+        return new GoodCountsRegexConstraint(klass, methodName, ruleIdx, regexIndexes);\n+    }\n+}\n+\n+\/\/ Constraint for rule that fails with \"failOn\" and the specified regex must also fail.\n+class BadFailOnConstraint extends RegexConstraint {\n+\n+    BadFailOnConstraint(Class<?> klass, String methodName, int ruleIdx, List<String> matches, int... regexIndexes) {\n+        super(klass, methodName, \"failOn\", false, matches, ruleIdx, regexIndexes);\n+    }\n+\n+    public static BadFailOnConstraint create(Class<?> klass, String methodName, int ruleIdx, int regexId, String... matches) {\n+        return new BadFailOnConstraint(klass, methodName, ruleIdx, new ArrayList<>(Arrays.asList(matches)), regexId);\n+    }\n+\n+    public static BadFailOnConstraint create(Class<?> klass, String methodName, int ruleIdx, String... matches) {\n+        return new BadFailOnConstraint(klass, methodName, ruleIdx, new ArrayList<>(Arrays.asList(matches)), 1);\n+    }\n+}\n+\n+\/\/ Constraint for rule that fails with \"counts\" and the specified regex must also fail.\n+class BadCountsConstraint extends RegexConstraint {\n+\n+    BadCountsConstraint(Class<?> klass, String methodName, int ruleIdx, List<String> matches, int... regexIndexes) {\n+        super(klass, methodName, \"counts\", false, matches, ruleIdx, regexIndexes);\n+    }\n+\n+    public static BadCountsConstraint create(Class<?> klass, String methodName, int ruleIdx, int regexId, int foundCount, String... matches) {\n+        List<String> matchesList = getMatchesList(foundCount, matches, Arrays.asList(matches));\n+        return new BadCountsConstraint(klass, methodName, ruleIdx, matchesList, regexId);\n+    }\n+\n+    public static BadCountsConstraint create(Class<?> klass, String methodName, int ruleIdx, int foundCount, String... matches) {\n+        List<String> matchesList = getMatchesList(foundCount, matches, Arrays.asList(matches));\n+        return new BadCountsConstraint(klass, methodName, ruleIdx, matchesList, 1);\n+    }\n+\n+    private static List<String> getMatchesList(int foundCount, String[] matches, List<String> strings) {\n+        List<String> matchesList = new ArrayList<>();\n+        matchesList.add(\"but found \" + foundCount);\n+        if (matches != null) {\n+            matchesList.addAll(strings);\n+        }\n+        return matchesList;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestIRMatching.java","additions":1628,"deletions":0,"binary":false,"changes":1628,"status":"added"},{"patch":"@@ -0,0 +1,405 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.driver.IRViolationException;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import jdk.test.lib.Asserts;\n+\n+import java.util.Arrays;\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true & vm.compMode != \"Xint\" & vm.compiler2.enabled & vm.flagless\n+ * @summary Test different custom run tests.\n+ * @library \/test\/lib \/\n+ * @run driver ir_framework.tests.TestRunTests\n+ *\/\n+\n+public class TestRunTests {\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+        try {\n+            TestFramework.run(BadStandalone.class);\n+            throw new RuntimeException(\"Should not reach\");\n+        } catch (IRViolationException e) {\n+            String[] matches = { \"test(int)\", \"test2(int)\", \"Failed IR Rules (2)\"};\n+            Arrays.stream(matches).forEach(m -> Asserts.assertTrue(e.getExceptionInfo().contains(m)));\n+            Asserts.assertEQ(e.getExceptionInfo().split(\"STANDALONE mode\", -1).length - 1, 2);\n+        }\n+        new TestFramework(SkipCompilation.class).addFlags(\"-XX:-UseCompiler\").start();\n+        new TestFramework(SkipCompilation.class).addFlags(\"-Xint\").start();\n+        new TestFramework(SkipC2Compilation.class).addFlags(\"-XX:TieredStopAtLevel=1\").start();\n+        new TestFramework(SkipC2Compilation.class).addFlags(\"-XX:TieredStopAtLevel=2\").start();\n+        new TestFramework(SkipC2Compilation.class).addFlags(\"-XX:TieredStopAtLevel=3\").start();\n+    }\n+    public int iFld;\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_I, \"1\"})\n+    public int test1(int x) {\n+        iFld = x;\n+        return x;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_I, \"1\"})\n+    public int test2(int y) {\n+        iFld = y;\n+        return y;\n+    }\n+\n+    @Run(test = {\"test1\", \"test2\"})\n+    public void run(RunInfo info) {\n+        test1(23);\n+        test2(42);\n+        Asserts.assertTrue(info.isC2CompilationEnabled());\n+        if (!info.isWarmUp()) {\n+            TestFramework.assertCompiledByC2(info.getTest(\"test1\"));\n+            TestFramework.assertCompiledByC2(info.getTest(\"test2\"));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_I, \"1\"})\n+    public int test3(int x) {\n+        iFld = x;\n+        return x;\n+    }\n+\n+    @Run(test = \"test3\")\n+    public void run2(RunInfo info) {\n+        Asserts.assertTrue(info.isC2CompilationEnabled());\n+        test3(42);\n+        if (!info.isWarmUp()) {\n+            TestFramework.assertCompiledByC2(info.getTest());\n+            try {\n+                info.getTest(\"test2\");\n+                throw new RuntimeException(\"should not reach\");\n+            } catch (TestRunException e) {\n+                \/\/ Excepted, do not call this method for single associated test.\n+            }\n+            try {\n+                info.isTestC1Compiled(\"test2\");\n+                throw new RuntimeException(\"should not reach\");\n+            } catch (TestRunException e) {\n+                \/\/ Excepted, do not call this method for single associated test.\n+            }\n+            try {\n+                info.isTestC2Compiled(\"test2\");\n+                throw new RuntimeException(\"should not reach\");\n+            } catch (TestRunException e) {\n+                \/\/ Excepted, do not call this method for single associated test.\n+            }\n+            try {\n+                info.isTestCompiledAtLevel(\"test2\", CompLevel.C2);\n+                throw new RuntimeException(\"should not reach\");\n+            } catch (TestRunException e) {\n+                \/\/ Excepted, do not call this method for single associated test.\n+            }\n+        }\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_I, \"1\"})\n+    public int test4(int x) {\n+        iFld = x;\n+        return x;\n+    }\n+\n+    @Run(test = \"test4\", mode = RunMode.STANDALONE)\n+    public void run3(RunInfo info) {\n+        for (int i = 0; i < 2000; i++) {\n+            test4(i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_I, \"1\"})\n+    public int test5(int x) {\n+        iFld = x;\n+        return x;\n+    }\n+\n+    @Test(compLevel = CompLevel.WAIT_FOR_COMPILATION)\n+    @IR(counts = {IRNode.STORE_I, \"1\"})\n+    public int test6(int y) {\n+        iFld = y;\n+        return y;\n+    }\n+\n+    @Run(test = {\"test5\", \"test6\"})\n+    public void run4(RunInfo info) {\n+        test5(23);\n+        test6(42);\n+        if (!info.isWarmUp()) {\n+            TestFramework.assertCompiledByC2(info.getTest(\"test5\"));\n+            TestFramework.assertCompiledByC2(info.getTest(\"test6\"));\n+            try {\n+                info.getTest();\n+                throw new RuntimeException(\"should not reach\");\n+            } catch (TestRunException e) {\n+                \/\/ Excepted, do not call this method for single associated test.\n+            }\n+            try {\n+                info.isTestC1Compiled();\n+                throw new RuntimeException(\"should not reach\");\n+            } catch (TestRunException e) {\n+                \/\/ Excepted, do not call this method for single associated test.\n+            }\n+            try {\n+                info.isTestC2Compiled();\n+                throw new RuntimeException(\"should not reach\");\n+            } catch (TestRunException e) {\n+                \/\/ Excepted, do not call this method for single associated test.\n+            }\n+            try {\n+                info.isTestCompiledAtLevel(CompLevel.C2);\n+                throw new RuntimeException(\"should not reach\");\n+            } catch (TestRunException e) {\n+                \/\/ Excepted, do not call this method for single associated test.\n+            }\n+        }\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_I, \"1\"})\n+    public int test7(int x) {\n+        for (int i = 0; i < 100; i++) {}\n+        iFld = x;\n+        return x;\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_I, \"1\"})\n+    public int test8(int x) {\n+        for (int i = 0; i < 100; i++) {}\n+        iFld = x;\n+        return x;\n+    }\n+\n+    @Run(test = {\"test7\", \"test8\"}, mode = RunMode.STANDALONE)\n+    public void run5() {\n+        for (int i = 0; i < 10000; i++) {\n+            test7(23);\n+            test8(42);\n+        }\n+    }\n+\n+    @Test(compLevel = CompLevel.WAIT_FOR_COMPILATION)\n+    @Warmup(0)\n+    public void test9() {\n+        TestClass tmp = new TestClass();\n+        for (int i = 0; i < 100; ++i) {\n+            tmp.test();\n+        }\n+    }\n+\n+    static class TestClass {\n+        public int test() {\n+            int res = 0;\n+            for (int i = 1; i < 20_000; ++i) {\n+                res -= i;\n+            }\n+            return res;\n+        }\n+    }\n+}\n+\n+class BadStandalone {\n+    int iFld;\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_I, \"1\"})\n+    public int test(int x) {\n+        iFld = x;\n+        return x;\n+    }\n+\n+    @Run(test = \"test\", mode = RunMode.STANDALONE)\n+    public void run(RunInfo info) {\n+        test(42);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_I, \"1\"})\n+    public int test2(int x) {\n+        iFld = x;\n+        return x;\n+    }\n+\n+    @Run(test = \"test2\", mode = RunMode.STANDALONE)\n+    public void run2(RunInfo info) {\n+    }\n+}\n+\n+\/\/ Run with TieredStopAt=[1,3]. IR verification is skipped.\n+class SkipC2Compilation {\n+\n+    int iFld;\n+    @Test(compLevel = CompLevel.C2)\n+    @IR(failOn = IRNode.STORE) \/\/ Would fail but not evaluated.\n+    public void testC2() {\n+        iFld = 34;\n+    }\n+\n+    @Check(test = \"testC2\")\n+    public void checkC2(TestInfo info) {\n+        Asserts.assertFalse(info.isC2CompilationEnabled());\n+        Asserts.assertTrue(info.isCompilationSkipped());\n+    }\n+\n+    @Test(compLevel = CompLevel.C2)\n+    @IR(failOn = IRNode.STORE) \/\/ Would fail but not evaluated.\n+    public void test2C2() {\n+        iFld = 34;\n+    }\n+\n+\n+    @Run(test = \"test2C2\")\n+    public void run2C2(RunInfo info) {\n+        Asserts.assertFalse(info.isC2CompilationEnabled());\n+        Asserts.assertTrue(info.isCompilationSkipped());\n+        test2C2();\n+        Asserts.assertTrue(info.isCompilationSkipped());\n+        try {\n+            info.isCompilationSkipped(\"test2C2\");\n+            throw new RuntimeException(\"should not reach\");\n+        } catch (TestRunException e) {\n+            \/\/ Excepted, do not call this method for single associated test.\n+        }\n+    }\n+\n+    @Test(compLevel = CompLevel.C2)\n+    @IR(failOn = IRNode.STORE) \/\/ Would fail but not evaluated.\n+    public void test3C2() {\n+        iFld = 34;\n+    }\n+\n+    @Test(compLevel = CompLevel.C2)\n+    @IR(failOn = IRNode.STORE) \/\/ Would fail but not evaluated.\n+    public void test4C2() {\n+        iFld = 34;\n+    }\n+\n+\n+    @Test \/\/ Level any\n+    @IR(failOn = IRNode.STORE) \/\/ Would fail but not evaluated.\n+    public void testAny() {\n+        iFld = 34;\n+    }\n+\n+    @Run(test = {\"test3C2\", \"test4C2\", \"testAny\"})\n+    public void runMulti(RunInfo info) {\n+        Asserts.assertFalse(info.isC2CompilationEnabled());\n+        if (!info.isWarmUp()) {\n+            TestFramework.assertCompiledByC1(info.getTest(\"testAny\"));\n+        }\n+        Asserts.assertTrue(info.isCompilationSkipped(\"test3C2\"));\n+        Asserts.assertTrue(info.isCompilationSkipped(\"test4C2\"));\n+        Asserts.assertFalse(info.isCompilationSkipped(\"testAny\"));\n+        test2C2();\n+        Asserts.assertTrue(info.isCompilationSkipped(\"test3C2\"));\n+        Asserts.assertTrue(info.isCompilationSkipped(\"test4C2\"));\n+        Asserts.assertFalse(info.isCompilationSkipped(\"testAny\"));\n+        try {\n+            info.isCompilationSkipped();\n+            throw new RuntimeException(\"should not reach\");\n+        } catch (TestRunException e) {\n+            \/\/ Excepted, do not call this method for multiple associated tests.\n+        }\n+    }\n+}\n+\n+\/\/ Run with -Xint and -XX:-Compiler. IR verification is skipped.\n+class SkipCompilation {\n+    int iFld;\n+    @Test(compLevel = CompLevel.C2)\n+    @IR(failOn = IRNode.STORE) \/\/ Would fail but not evaluated.\n+    public void testC2() {\n+        iFld = 34;\n+    }\n+\n+    @Check(test = \"testC2\")\n+    public void checkC2(TestInfo info) {\n+        Asserts.assertTrue(info.isCompilationSkipped());\n+        Asserts.assertFalse(info.isC2CompilationEnabled());\n+    }\n+\n+    @Test(compLevel = CompLevel.C2)\n+    @IR(failOn = IRNode.STORE) \/\/ Would fail but not evaluated.\n+    public void test2C2() {\n+        iFld = 34;\n+    }\n+\n+\n+    @Run(test = \"test2C2\")\n+    public void run2C2(RunInfo info) {\n+        Asserts.assertFalse(info.isC2CompilationEnabled());\n+        Asserts.assertTrue(info.isCompilationSkipped());\n+        test2C2();\n+        Asserts.assertTrue(info.isCompilationSkipped());\n+    }\n+\n+    @Test(compLevel = CompLevel.C2)\n+    @IR(failOn = IRNode.STORE) \/\/ Would fail but not evaluated.\n+    public void test3C2() {\n+        iFld = 34;\n+    }\n+\n+    @Test(compLevel = CompLevel.C2)\n+    @IR(failOn = IRNode.STORE) \/\/ Would fail but not evaluated.\n+    public void test4C2() {\n+        iFld = 34;\n+    }\n+\n+\n+    @Test \/\/ Level any\n+    @IR(failOn = IRNode.STORE) \/\/ Would fail but not evaluated.\n+    public void testAny() {\n+        iFld = 34;\n+    }\n+\n+    @Run(test = {\"test3C2\", \"test4C2\", \"testAny\"})\n+    public void runMulti(RunInfo info) {\n+        Asserts.assertFalse(info.isC2CompilationEnabled());\n+        if (!info.isWarmUp()) {\n+            TestFramework.assertNotCompiled(info.getTest(\"testAny\"));\n+            TestFramework.assertNotCompiled(info.getTest(\"test3C2\"));\n+            TestFramework.assertNotCompiled(info.getTest(\"test4C2\"));\n+        }\n+        Asserts.assertTrue(info.isCompilationSkipped(\"test3C2\"));\n+        Asserts.assertTrue(info.isCompilationSkipped(\"test4C2\"));\n+        Asserts.assertTrue(info.isCompilationSkipped(\"testAny\"));\n+        test2C2();\n+        Asserts.assertTrue(info.isCompilationSkipped(\"test3C2\"));\n+        Asserts.assertTrue(info.isCompilationSkipped(\"test4C2\"));\n+        Asserts.assertTrue(info.isCompilationSkipped(\"testAny\"));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestRunTests.java","additions":405,"deletions":0,"binary":false,"changes":405,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import compiler.lib.ir_framework.Scenario;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+\n+\/*\n+ * @test\n+ * @requires vm.flagless\n+ * @summary Sanity test the different ways to start the test framework.\n+ * @library \/test\/lib \/\n+ * @run driver ir_framework.tests.TestSanity\n+ *\/\n+\n+public class TestSanity {\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+        TestFramework.run(TestSanity.class);\n+        TestFramework.runWithFlags(\"-XX:+TieredCompilation\");\n+        new TestFramework().addFlags(\"-XX:TLABRefillWasteFraction=51\", \"-XX:+UseTLAB\").start();\n+        new TestFramework(TestSanity.class).addFlags(\"-XX:TLABRefillWasteFraction=51\", \"-XX:+UseTLAB\").start();\n+        new TestFramework().addHelperClasses(HelperA.class).start();\n+        new TestFramework(TestSanity.class).addHelperClasses(HelperA.class, HelperB.class).start();\n+        Scenario sDefault = new Scenario(0);\n+        Scenario s1 = new Scenario(1, \"-XX:TLABRefillWasteFraction=52\", \"-XX:+UseTLAB\");\n+        Scenario s2 = new Scenario(2, \"-XX:TLABRefillWasteFraction=53\", \"-XX:+UseTLAB\");\n+        new TestFramework(TestSanity.class).addScenarios(s1).start();\n+        new TestFramework().addScenarios(s1, s2).start();\n+        new TestFramework(TestSanity.class).addScenarios(s1, s2).start();\n+        new TestFramework().addScenarios(sDefault, s1).start();\n+        new TestFramework().addScenarios(sDefault, s1, s2).start();\n+        new TestFramework(TestSanity.class).addScenarios(sDefault, s1).start();\n+        new TestFramework(TestSanity.class).addScenarios(sDefault, s1, s2).start();\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.start();\n+        testFramework.addFlags(\"-XX:TLABRefillWasteFraction=54\").start();\n+        testFramework = new TestFramework();\n+        testFramework.addFlags(\"-XX:TLABRefillWasteFraction=55\").addFlags(\"-XX:+UseTLAB\").start();\n+        testFramework = new TestFramework();\n+        testFramework.addHelperClasses(HelperA.class, HelperB.class).start();\n+        testFramework = new TestFramework();\n+        testFramework.addHelperClasses(HelperA.class, HelperB.class).addHelperClasses(HelperC.class).start();\n+        testFramework = new TestFramework();\n+        testFramework.addScenarios(sDefault).addScenarios(s1, s2).start();\n+        testFramework = new TestFramework();\n+        testFramework.addHelperClasses(HelperA.class).addScenarios(sDefault).addFlags(\"-XX:+UseSuperWord\").start();\n+        testFramework = new TestFramework();\n+        testFramework.addHelperClasses(HelperA.class).addFlags(\"-XX:+UseSuperWord\", \"-XX:+UseCompiler\").addScenarios(sDefault)\n+                     .addHelperClasses(HelperB.class, HelperC.class).addScenarios(s1, s2).addFlags(\"-XX:+TieredCompilation\").start();\n+        testFramework = new TestFramework();\n+        testFramework.addHelperClasses(HelperA.class).addFlags(\"-XX:+UseSuperWord\", \"-XX:+UseCompiler\").addScenarios(sDefault)\n+                     .addHelperClasses(HelperB.class, HelperC.class).addScenarios(s1, s2).setDefaultWarmup(200)\n+                     .addFlags(\"-XX:+TieredCompilation\").start();\n+    }\n+\n+    @Test\n+    public void test() {}\n+}\n+\n+class HelperA { }\n+class HelperB { }\n+class HelperC { }\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestSanity.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true & vm.compMode != \"Xint\" & vm.compiler2.enabled & vm.flagless\n+ * @summary Test scenarios with the framework.\n+ * @library \/test\/lib \/\n+ * @run driver ir_framework.tests.TestScenarios\n+ *\/\n+\n+public class TestScenarios {\n+    public static void main(String[] args) {\n+        Scenario sDefault = new Scenario(0);\n+        Scenario s1 = new Scenario(1, \"-XX:TLABRefillWasteFraction=51\");\n+        Scenario s2 = new Scenario(2, \"-XX:TLABRefillWasteFraction=52\");\n+        Scenario s3 = new Scenario(3, \"-XX:TLABRefillWasteFraction=53\");\n+        Scenario s3dup = new Scenario(3, \"-XX:TLABRefillWasteFraction=53\");\n+        try {\n+            new TestFramework().addScenarios(sDefault, s1, s2, s3).start();\n+            Asserts.fail(\"Should not reach\");\n+        } catch (TestRunException e) {\n+            Asserts.assertTrue(e.getMessage().contains(\"The following scenarios have failed: #0, #1, #3\"), e.getMessage());\n+        }\n+        try {\n+            new TestFramework().addScenarios(s1, s2, s3).start();\n+            Asserts.fail(\"Should not reach\");\n+        } catch (TestRunException e) {\n+            Asserts.assertTrue(e.getMessage().contains(\"The following scenarios have failed: #1, #3\"), e.getMessage());\n+        }\n+        new TestFramework(ScenarioTest.class).addScenarios(s1, s2, s3).start();\n+        try {\n+            new TestFramework().addScenarios(s1, s3dup, s2, s3).start();\n+            Asserts.fail(\"Should not reach\");\n+        } catch (RuntimeException e) {\n+            Asserts.assertTrue(e.getMessage().contains(\"Cannot define two scenarios with the same index 3\"), e.getMessage());\n+        }\n+        try {\n+            new TestFramework(MyExceptionTest.class).addScenarios(s1, s2, s3).start();\n+            Asserts.fail(\"Should not reach\");\n+        } catch (TestRunException e) {\n+            Asserts.assertTrue(s1.getTestVMOutput().contains(\"Caused by: ir_framework.tests.MyScenarioException\"));\n+            Asserts.assertTrue(s2.getTestVMOutput().contains(\"Caused by: ir_framework.tests.MyScenarioException\"));\n+            Asserts.assertTrue(s3.getTestVMOutput().contains(\"Caused by: ir_framework.tests.MyScenarioException\"));\n+        } catch (Exception e) {\n+            Asserts.fail(\"Should not catch other exceptions\");\n+        }\n+\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"TLABRefillWasteFraction\", \"64\"}, counts = {IRNode.CALL, \"1\"})\n+    public void failDefault() {\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"TLABRefillWasteFraction\", \"51\"}, counts = {IRNode.CALL, \"1\"})\n+    @IR(applyIf = {\"TLABRefillWasteFraction\", \"53\"}, counts = {IRNode.CALL, \"1\"})\n+    public void failS3() {\n+    }\n+}\n+\n+class ScenarioTest {\n+    @Test\n+    @IR(applyIf = {\"TLABRefillWasteFraction\", \"54\"}, counts = {IRNode.CALL, \"1\"})\n+    public void doesNotFail() {\n+    }\n+}\n+\n+class MyExceptionTest {\n+    int iFld;\n+    @Test\n+    @IR(failOn = IRNode.STORE) \/\/ Not evaluated due to MyScenarioException\n+    public void test() {\n+        iFld = 42;\n+        throw new MyScenarioException();\n+    }\n+}\n+\n+class MyScenarioException extends RuntimeException {}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestScenarios.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.driver.TestVMException;\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @requires vm.flagless\n+ * @summary Test the framework with helper classes.\n+ * @library \/test\/lib \/\n+ * @run driver ir_framework.tests.TestWithHelperClasses\n+ *\/\n+\n+public class TestWithHelperClasses {\n+\n+    public static void main(String[] args) {\n+        new TestFramework().addHelperClasses(Helper1.class, Helper2.class).start();\n+        try {\n+            new TestFramework().addHelperClasses(Helper1.class).start();\n+            shouldNotReach();\n+        } catch (TestVMException e) {\n+            Asserts.assertFalse(e.getExceptionInfo().contains(\"public static void ir_framework.tests.Helper1.foo() should have been C2 compiled\"));\n+            Asserts.assertFalse(TestFramework.getLastTestVMOutput().contains(\"public static void ir_framework.tests.Helper1.foo() should have been C2 compiled\"));\n+            Asserts.assertTrue(TestFramework.getLastTestVMOutput().contains(\"public static void ir_framework.tests.Helper2.foo() should have been C2 compiled\"));\n+            Asserts.assertTrue(e.getExceptionInfo().contains(\"public static void ir_framework.tests.Helper2.foo() should have been C2 compiled\"));\n+            Asserts.assertFalse(TestFramework.getLastTestVMOutput().contains(\"Should not be executed\"));\n+            Asserts.assertFalse(e.getExceptionInfo().contains(\"Should not be executed\"));\n+        }\n+\n+        try {\n+            new TestFramework(BadHelperClass.class).addHelperClasses(BadHelper.class).start();\n+            shouldNotReach();\n+        } catch (TestFormatException e) {\n+            Asserts.assertTrue(e.getMessage().contains(\"Cannot use @Test annotation in helper class\"));\n+            Asserts.assertTrue(e.getMessage().contains(\"Cannot use @Check annotation in helper class\"));\n+            Asserts.assertTrue(e.getMessage().contains(\"Cannot use @Run annotation in helper class\"));\n+            Asserts.assertTrue(e.getMessage().contains(\"noTestInHelper\"));\n+            Asserts.assertTrue(e.getMessage().contains(\"test2\"));\n+            Asserts.assertTrue(e.getMessage().contains(\"check2\"));\n+            Asserts.assertTrue(e.getMessage().contains(\"test3\"));\n+            Asserts.assertTrue(e.getMessage().contains(\"run3\"));\n+        }\n+\n+        try {\n+            new TestFramework(TestAsHelper.class).addHelperClasses(TestAsHelper.class).start();\n+            shouldNotReach();\n+        } catch (TestFormatException e) {\n+            Asserts.assertTrue(e.getMessage().contains(\"Cannot specify test class ir_framework.tests.\" +\n+                                                       \"TestAsHelper as helper class, too\"));\n+        }\n+\n+        try {\n+            new TestFramework().addHelperClasses(NestedHelper.class).start();\n+            shouldNotReach();\n+        } catch (TestFormatException e) {\n+            Asserts.assertTrue(e.getMessage().contains(\"Nested class\"));\n+            Asserts.assertTrue(e.getMessage().contains(\"TestWithHelperClasses$NestedHelper inside test class\"));\n+        }\n+    }\n+\n+    public static void shouldNotReach() {\n+        throw new RuntimeException(\"should not reach\");\n+    }\n+\n+    @Test\n+    public void test() throws NoSuchMethodException {\n+        TestFramework.assertCompiledByC2(Helper1.class.getMethod(\"foo\"));\n+        TestFramework.assertCompiledByC2(Helper2.class.getMethod(\"foo\"));\n+        TestFramework.assertCompiledByC2(NestedHelper.class.getMethod(\"foo\"));\n+        TestFramework.assertCompiledByC2(StaticNestedHelper.class.getMethod(\"foo\"));\n+    }\n+\n+    class NestedHelper {\n+        @ForceCompile(CompLevel.C2)\n+        public void foo() {\n+            throw new RuntimeException(\"Should not be executed\");\n+        }\n+    }\n+\n+\n+    static class StaticNestedHelper {\n+        @ForceCompile(CompLevel.C2)\n+        public void foo() {\n+            throw new RuntimeException(\"Should not be executed\");\n+        }\n+    }\n+}\n+\n+class TestAsHelper {\n+\n+    @Test\n+    public void foo() {}\n+}\n+\n+class Helper1 {\n+\n+    @ForceCompile(CompLevel.C2)\n+    public static void foo() {\n+        throw new RuntimeException(\"Should not be executed\");\n+    }\n+}\n+\n+class Helper2 {\n+\n+    @ForceCompile(CompLevel.C2)\n+    public static void foo() {\n+        throw new RuntimeException(\"Should not be executed\");\n+    }\n+}\n+\n+class BadHelperClass {\n+    @Test\n+    public void test1() {}\n+ }\n+\n+\n+class BadHelper {\n+    @Test\n+    public void noTestInHelper() {}\n+\n+    @Test\n+    public void test2() {}\n+\n+    @Check(test = \"test2\")\n+    public void check2() {}\n+\n+    @Test\n+    public void test3() {}\n+\n+    @Run(test = \"test3\")\n+    public void run3() {}\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestWithHelperClasses.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+    private final static String AGENT_LIB = \"objmonusage006\";\n+    private final static int DEF_TIME_MAX = 30;  \/\/ default max # secs to test\n@@ -34,3 +36,0 @@\n-    final static int N_LATE_CHECKS = 1000;\n-    final static int N_THREADS = 10;\n-\n@@ -39,1 +38,1 @@\n-            System.loadLibrary(\"objmonusage006\");\n+            System.loadLibrary(AGENT_LIB);\n@@ -41,1 +40,1 @@\n-            System.err.println(\"Could not load objmonusage006 library\");\n+            System.err.println(\"Could not load \" + AGENT_LIB + \" library\");\n@@ -62,0 +61,15 @@\n+        int timeMax = 0;\n+        if (args.length == 0) {\n+            timeMax = DEF_TIME_MAX;\n+        } else {\n+            try {\n+                timeMax = Integer.parseUnsignedInt(args[0]);\n+            } catch (NumberFormatException nfe) {\n+                System.err.println(\"'\" + args[0] + \"': invalid timeMax value.\");\n+                usage();\n+            }\n+        }\n+\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long count = 0;\n@@ -63,2 +77,3 @@\n-        for (int i = 0; i < N_THREADS; i++) {\n-            System.out.println(\"Starting LockingThread #\" + i + \".\");\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n@@ -89,3 +104,1 @@\n-                System.out.println(\"LockingThread #\" + i + \" starting \"\n-                                   + N_LATE_CHECKS + \" late checks.\");\n-                for (int j = 0; j < N_LATE_CHECKS; j++) {\n+                while (true) {\n@@ -95,1 +108,7 @@\n-                        return res;\n+                        break;\n+                    }\n+\n+                    if (!thr.isAlive()) {\n+                        \/\/ Done with JVM\/TI GetObjectMonitorUsage() calls\n+                        \/\/ since thread is not alive.\n+                        break;\n@@ -98,2 +117,6 @@\n-                System.out.println(\"LockingThread #\" + i + \" ran \"\n-                                   + N_LATE_CHECKS + \" late checks.\");\n+            }\n+\n+            try {\n+                thr.join();\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected: \" + e);\n@@ -103,0 +126,3 @@\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n+\n@@ -106,0 +132,9 @@\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + AGENT_LIB + \" [time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    time_max  max looping time in seconds\");\n+        System.err.println(\"              (default is \" + DEF_TIME_MAX +\n+                           \" seconds)\");\n+        System.exit(1);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage006.java","additions":49,"deletions":14,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @bug 8167108 8266130\n@@ -39,0 +40,1 @@\n+ * @requires vm.jvmti\n@@ -42,1 +44,0 @@\n- *      -Xlog:thread+smr=debug\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage006\/TestDescription.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,0 +161,1 @@\n+            System.out.println(\"thrstat002a.run before runningBarrier unlock\");\n@@ -162,1 +163,3 @@\n-            System.out.println(\"thrstat002a.run after runningBarrier unlock\");\n+\n+            \/\/ Don't do println's from this point until we have exited the loop,\n+            \/\/ else we can suspend in the println in an unexpected state.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat002.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -358,0 +358,1 @@\n+    fflush(0);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat002\/thrstat002.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+    private final static String AGENT_LIB = \"intrpthrd003\";\n+    private final static int DEF_TIME_MAX = 30;  \/\/ default max # secs to test\n@@ -35,1 +37,1 @@\n-            System.loadLibrary(\"intrpthrd003\");\n+            System.loadLibrary(AGENT_LIB);\n@@ -37,1 +39,1 @@\n-            System.err.println(\"Could not load intrpthrd003 library\");\n+            System.err.println(\"Could not load \" + AGENT_LIB + \" library\");\n@@ -44,1 +46,1 @@\n-    native static int check(int ind, Thread thr);\n+    native static int check(long ind, Thread thr);\n@@ -54,34 +56,5 @@\n-    public static int run(String argv[], PrintStream ref) {\n-        intrpthrd003a runn[] = new intrpthrd003a[THREADS_NUMBER];\n-\n-        System.out.println(\"Case 1: JVM\/TI InterruptThread()\");\n-        for (int i = 0; i < THREADS_NUMBER; i++ ) {\n-            runn[i] = new intrpthrd003a();\n-            int late_count = 1;\n-            synchronized (runn[i].syncObject) {\n-                runn[i].start();\n-                try {\n-                    runn[i].syncObject.wait();\n-\n-                    for (; late_count <= N_LATE_CALLS; late_count++) {\n-                        if (check(i, runn[i]) == 2) break;\n-\n-                        if (isThreadNotAliveError()) {\n-                            \/\/ Done with InterruptThread() calls since\n-                            \/\/ thread is not alive.\n-                            break;\n-                        }\n-                    }\n-                } catch (InterruptedException e) {\n-                    throw new Error(\"Unexpected: \" + e);\n-                }\n-            }\n-\n-            System.out.println(\"INFO: thread #\" + i + \": made \" + late_count +\n-                               \" late calls to JVM\/TI InterruptThread()\");\n-            System.out.println(\"INFO: thread #\" + i + \": N_LATE_CALLS==\" +\n-                               N_LATE_CALLS + \" value is \" +\n-                               ((late_count >= N_LATE_CALLS) ? \"NOT \" : \"\") +\n-                               \"large enough to cause an InterruptThread() \" +\n-                               \"call after thread exit.\");\n-\n+    public static int run(String args[], PrintStream ref) {\n+        int timeMax = 0;\n+        if (args.length == 0) {\n+            timeMax = DEF_TIME_MAX;\n+        } else {\n@@ -89,8 +62,4 @@\n-                runn[i].join();\n-            } catch (InterruptedException e) {\n-                throw new Error(\"Unexpected: \" + e);\n-            }\n-            if (check(i, runn[i]) == 2) break;\n-            if (!isThreadNotAliveError()) {\n-                throw new Error(\"Expected JVMTI_ERROR_THREAD_NOT_ALIVE \" +\n-                                \"after thread #\" + i + \" has been join()'ed\");\n+                timeMax = Integer.parseUnsignedInt(args[0]);\n+            } catch (NumberFormatException nfe) {\n+                System.err.println(\"'\" + args[0] + \"': invalid timeMax value.\");\n+                usage();\n@@ -100,4 +69,6 @@\n-        int res = getResult();\n-        if (res != 0) {\n-            return res;\n-        }\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long count = 0;\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n@@ -105,6 +76,3 @@\n-        System.out.println(\"Case 2: java.lang.Thread.interrupt()\");\n-        for (int i = 0; i < THREADS_NUMBER; i++ ) {\n-            runn[i] = new intrpthrd003a();\n-            int late_count = 1;\n-            synchronized (runn[i].syncObject) {\n-                runn[i].start();\n+            intrpthrd003a thr = new intrpthrd003a();\n+            synchronized (thr.syncObject) {\n+                thr.start();\n@@ -112,1 +80,1 @@\n-                    runn[i].syncObject.wait();\n+                    thr.syncObject.wait();\n@@ -114,2 +82,2 @@\n-                    for (; late_count <= N_LATE_CALLS; late_count++) {\n-                        runn[i].interrupt();\n+                    while (true) {\n+                        if (check(count, thr) == 2) break;\n@@ -117,2 +85,2 @@\n-                        if (!runn[i].isAlive()) {\n-                            \/\/ Done with Thread.interrupt() calls since\n+                        if (isThreadNotAliveError()) {\n+                            \/\/ Done with InterruptThread() calls since\n@@ -128,8 +96,0 @@\n-            System.out.println(\"INFO: thread #\" + i + \": made \" + late_count +\n-                               \" late calls to java.lang.Thread.interrupt()\");\n-            System.out.println(\"INFO: thread #\" + i + \": N_LATE_CALLS==\" +\n-                               N_LATE_CALLS + \" value is \" +\n-                               ((late_count >= N_LATE_CALLS) ? \"NOT \" : \"\") +\n-                               \"large enough to cause a Thread.interrupt() \" +\n-                               \"call after thread exit.\");\n-\n@@ -137,1 +97,1 @@\n-                runn[i].join();\n+                thr.join();\n@@ -141,5 +101,1 @@\n-            runn[i].interrupt();\n-            if (runn[i].isAlive()) {\n-                throw new Error(\"Expected !Thread.isAlive() after thread #\" +\n-                                i + \" has been join()'ed\");\n-            }\n+            if (check(count, thr) == 2) break;\n@@ -148,1 +104,13 @@\n-        return res;\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n+\n+        return getResult();\n+    }\n+\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + AGENT_LIB + \" [time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    time_max  max looping time in seconds\");\n+        System.err.println(\"              (default is \" + DEF_TIME_MAX +\n+                           \" seconds)\");\n+        System.exit(1);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/InterruptThread\/intrpthrd003.java","additions":44,"deletions":76,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @bug 8167108 8266130\n@@ -44,0 +45,1 @@\n+ * @requires vm.jvmti\n@@ -47,1 +49,0 @@\n- *      -Xlog:thread+smr=debug\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/InterruptThread\/intrpthrd003\/TestDescription.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"jni_tools.h\"\n@@ -93,1 +94,1 @@\n-        jint ind, jthread thr) {\n+        jlong ind, jthread thr) {\n@@ -106,1 +107,1 @@\n-            printf(\"(thr#%d) error expected: JVMTI_ERROR_NONE or JVMTI_ERROR_THREAD_NOT_ALIVE,\", ind);\n+            printf(\"(thr#%\" LL \"d) error expected: JVMTI_ERROR_NONE or JVMTI_ERROR_THREAD_NOT_ALIVE,\", ind);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/InterruptThread\/intrpthrd003\/intrpthrd003.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,3 @@\n+    private final static String AGENT_LIB = \"popframe011\";\n+    private final static int DEF_TIME_MAX = 30;  \/\/ default max # secs to test\n+\n@@ -49,2 +52,0 @@\n-    static final int N_LATE_CALLS = 100;\n-\n@@ -61,1 +62,1 @@\n-            System.loadLibrary(\"popframe011\");\n+            System.loadLibrary(AGENT_LIB);\n@@ -63,1 +64,1 @@\n-            System.err.println(\"Could not load popframe011 library\");\n+            System.err.println(\"Could not load \" + AGENT_LIB + \" library\");\n@@ -84,0 +85,28 @@\n+        int timeMax = 0;\n+        if (argv.length == 0) {\n+            timeMax = DEF_TIME_MAX;\n+        } else {\n+            int argIndex = 0;\n+            int argvLeft = argv.length;\n+            if (argv[0].equals(\"-v\")) {\n+                DEBUG_MODE = true;\n+                argIndex = 1;\n+                argvLeft--;\n+            }\n+            if (argvLeft == 0) {\n+                timeMax = DEF_TIME_MAX;\n+            } else if (argvLeft == 1) {\n+                try {\n+                    timeMax = Integer.parseUnsignedInt(argv[argIndex]);\n+                } catch (NumberFormatException nfe) {\n+                    System.err.println(\"'\" + argv[argIndex] +\n+                                       \"': invalid timeMax value.\");\n+                    usage();\n+                }\n+            } else {\n+                usage();\n+            }\n+        }\n+\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n@@ -87,1 +116,0 @@\n-\n@@ -89,4 +117,0 @@\n-        for (int i = 0; i < argv.length; i++) {\n-            if (argv[i].equals(\"-v\")) \/\/ verbose mode\n-                DEBUG_MODE = true;\n-        }\n@@ -94,4 +118,10 @@\n-        popFrameClsThr = new popFrameCls();\n-        synchronized (barrier) { \/\/ force a child thread to pause\n-            synchronized(readi) {\n-                popFrameClsThr.start(); \/\/ start the child thread\n+        long count = 0;\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+            popFdone = false;\n+\n+            popFrameClsThr = new popFrameCls();\n+            synchronized (barrier) { \/\/ force a child thread to pause\n+                synchronized(readi) {\n+                    popFrameClsThr.start(); \/\/ start the child thread\n@@ -99,6 +129,7 @@\n-                try {\n-                    readi.wait(); \/\/ wait for the child readiness\n-                } catch (Exception e) {\n-                    out.println(\"TEST FAILURE: waiting for \" +\n-                        popFrameClsThr.toString() + \": caught \" + e);\n-                    return FAILED;\n+                    try {\n+                        readi.wait(); \/\/ wait for the child readiness\n+                    } catch (Exception e) {\n+                        out.println(\"TEST FAILURE: waiting for \" +\n+                            popFrameClsThr.toString() + \": caught \" + e);\n+                        return FAILED;\n+                    }\n@@ -106,1 +137,0 @@\n-            }\n@@ -110,9 +140,9 @@\n-            if (DEBUG_MODE)\n-                totRes = retValue = doPopFrame(1, popFrameClsThr);\n-            else\n-                totRes = retValue = doPopFrame(0, popFrameClsThr);\n-            if (DEBUG_MODE && retValue == PASSED)\n-                out.println(\"Check #1 PASSED:\\n\" +\n-                    \"\\tPopFrame(), being invoked with NULL pointer \" +\n-                    \"to the thread,\\n\" +\n-                    \"\\treturned the appropriate error JVMTI_ERROR_NULL_POINTER\");\n+                if (DEBUG_MODE)\n+                    totRes = retValue = doPopFrame(1, popFrameClsThr);\n+                else\n+                    totRes = retValue = doPopFrame(0, popFrameClsThr);\n+                if (DEBUG_MODE && retValue == PASSED)\n+                    out.println(\"Check #1 PASSED:\\n\" +\n+                        \"\\tPopFrame(), being invoked with NULL pointer \" +\n+                        \"to the thread,\\n\" +\n+                        \"\\treturned the appropriate error JVMTI_ERROR_NULL_POINTER\");\n@@ -123,14 +153,14 @@\n-            if (DEBUG_MODE)\n-                retValue = doPopFrame(3, popFrameClsThr);\n-            else\n-                retValue = doPopFrame(2, popFrameClsThr);\n-            if (retValue == FAILED) {\n-                popFdone = true;\n-                totRes = FAILED;\n-            } else\n-                if (DEBUG_MODE && retValue == PASSED)\n-                    out.println(\"Check #3 PASSED:\\n\" +\n-                        \"\\tPopFrame(), being invoked with \" +\n-                        \"the invalid thread,\\n\" +\n-                        \"\\treturned the appropriate error \" +\n-                        \"JVMTI_ERROR_INVALID_THREAD\");\n+                if (DEBUG_MODE)\n+                    retValue = doPopFrame(3, popFrameClsThr);\n+                else\n+                    retValue = doPopFrame(2, popFrameClsThr);\n+                if (retValue == FAILED) {\n+                    popFdone = true;\n+                    totRes = FAILED;\n+                } else\n+                    if (DEBUG_MODE && retValue == PASSED)\n+                        out.println(\"Check #3 PASSED:\\n\" +\n+                            \"\\tPopFrame(), being invoked with \" +\n+                            \"the invalid thread,\\n\" +\n+                            \"\\treturned the appropriate error \" +\n+                            \"JVMTI_ERROR_INVALID_THREAD\");\n@@ -141,17 +171,17 @@\n-            if (DEBUG_MODE)\n-                retValue = doPopFrame(5, popFrameClsThr);\n-            else\n-                retValue = doPopFrame(4, popFrameClsThr);\n-            if (retValue == FAILED) {\n-                popFdone = true;\n-                totRes = FAILED;\n-            } else\n-                if (DEBUG_MODE && retValue == PASSED)\n-                    out.println(\"Check #5 PASSED:\\n\" +\n-                        \"\\tPopFrame(), being invoked with \" +\n-                        \"the non suspended thread,\\n\" +\n-                        \"\\treturned the appropriate error \" +\n-                        \"JVMTI_ERROR_THREAD_NOT_SUSPENDED\");\n-        }\n-        \/\/\n-        \/\/ Original popframe002 test block ends here.\n+                if (DEBUG_MODE)\n+                    retValue = doPopFrame(5, popFrameClsThr);\n+                else\n+                    retValue = doPopFrame(4, popFrameClsThr);\n+                if (retValue == FAILED) {\n+                    popFdone = true;\n+                    totRes = FAILED;\n+                } else\n+                    if (DEBUG_MODE && retValue == PASSED)\n+                        out.println(\"Check #5 PASSED:\\n\" +\n+                            \"\\tPopFrame(), being invoked with \" +\n+                            \"the non suspended thread,\\n\" +\n+                            \"\\treturned the appropriate error \" +\n+                            \"JVMTI_ERROR_THREAD_NOT_SUSPENDED\");\n+            }\n+            \/\/\n+            \/\/ Original popframe002 test block ends here.\n@@ -159,2 +189,1 @@\n-        int late_count = 1;\n-        for (; late_count <= N_LATE_CALLS; late_count++) {\n+            while (true) {\n@@ -165,16 +194,27 @@\n-            if (DEBUG_MODE)\n-                retValue = doPopFrame(7, popFrameClsThr);\n-            else\n-                retValue = doPopFrame(6, popFrameClsThr);\n-            if (retValue == FAILED) {\n-                popFdone = true;\n-                totRes = FAILED;\n-            } else\n-                if (DEBUG_MODE && retValue == PASSED)\n-                    out.println(\"Check #7 PASSED:\\n\" +\n-                        \"\\tPopFrame(), being invoked with \" +\n-                        \"the non suspended and is exiting thread,\\n\" +\n-                        \"\\treturned the appropriate error \" +\n-                        \"JVMTI_ERROR_THREAD_NOT_SUSPENDED\");\n-            if (isThreadNotAliveError()) {\n-                \/\/ Done with PopFrame() calls since thread is not alive.\n+                if (DEBUG_MODE)\n+                    retValue = doPopFrame(7, popFrameClsThr);\n+                else\n+                    retValue = doPopFrame(6, popFrameClsThr);\n+                if (retValue == FAILED) {\n+                    popFdone = true;\n+                    totRes = FAILED;\n+                } else\n+                    if (DEBUG_MODE && retValue == PASSED)\n+                        out.println(\"Check #7 PASSED:\\n\" +\n+                            \"\\tPopFrame(), being invoked with \" +\n+                            \"the non suspended and is exiting thread,\\n\" +\n+                            \"\\treturned the appropriate error \" +\n+                            \"JVMTI_ERROR_THREAD_NOT_SUSPENDED\");\n+                if (isThreadNotAliveError()) {\n+                    \/\/ Done with PopFrame() calls since thread is not alive.\n+                    break;\n+                }\n+            }\n+\n+            try {\n+                popFrameClsThr.join();\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected: \" + e);\n+            }\n+\n+            if (totRes != PASSED) {\n@@ -185,6 +225,2 @@\n-        out.println(\"INFO: made \" + late_count +\n-                    \" late calls to JVM\/TI PopFrame()\");\n-        out.println(\"INFO: N_LATE_CALLS==\" + N_LATE_CALLS + \" value is \" +\n-                    ((late_count >= N_LATE_CALLS) ? \"NOT \" : \"\") +\n-                    \"large enough to cause a PopFrame() call after thread \" +\n-                    \"exit.\");\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n@@ -195,0 +231,10 @@\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + AGENT_LIB + \" [-v][time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    -v        verbose mode\");\n+        System.err.println(\"    time_max  max looping time in seconds\");\n+        System.err.println(\"              (default is \" + DEF_TIME_MAX +\n+                           \" seconds)\");\n+        System.exit(1);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/PopFrame\/popframe011.java","additions":131,"deletions":85,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @bug 8167108 8266130\n@@ -39,0 +40,1 @@\n+ * @requires vm.jvmti\n@@ -42,1 +44,0 @@\n- *      -Xlog:thread+smr=debug\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/PopFrame\/popframe011\/TestDescription.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+    private final static String AGENT_LIB = \"suspendthrd003\";\n+    private final static int DEF_TIME_MAX = 30;  \/\/ default max # secs to test\n@@ -33,1 +35,1 @@\n-    final static int N_THREADS = 10;\n+    public static Wicket mainEntrance;\n@@ -37,1 +39,1 @@\n-        System.loadLibrary(\"suspendthrd003\");\n+        System.loadLibrary(AGENT_LIB);\n@@ -70,2 +72,20 @@\n-        for (int i = 0; i < N_THREADS; i++) {\n-            System.out.println(\"Starting TestedThread #\" + i + \".\");\n+        String[] args = argHandler.getArguments();\n+        int timeMax = 0;\n+        if (args.length == 0) {\n+            timeMax = DEF_TIME_MAX;\n+        } else {\n+            try {\n+                timeMax = Integer.parseUnsignedInt(args[0]);\n+            } catch (NumberFormatException nfe) {\n+                System.err.println(\"'\" + args[0] + \"': invalid timeMax value.\");\n+                usage();\n+            }\n+        }\n+\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long count = 0;\n+        int res = -1;\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n@@ -79,0 +99,1 @@\n+            mainEntrance = new Wicket();\n@@ -85,3 +106,1 @@\n-                if (!thread.checkReady()) {\n-                    throw new Failure(\"Unable to prepare tested thread: \" + thread);\n-                }\n+                mainEntrance.waitFor();\n@@ -125,0 +144,3 @@\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n+\n@@ -127,0 +149,9 @@\n+\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + AGENT_LIB + \" [time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    time_max  max looping time in seconds\");\n+        System.err.println(\"              (default is \" + DEF_TIME_MAX +\n+                           \" seconds)\");\n+        System.exit(1);\n+    }\n@@ -133,1 +164,0 @@\n-    private volatile boolean threadReady = false;\n@@ -145,1 +175,1 @@\n-        threadReady = true;\n+        suspendthrd003.mainEntrance.unlock();\n@@ -160,12 +190,0 @@\n-    \/\/ check if thread is ready\n-    public boolean checkReady() {\n-        try {\n-            while (!threadReady) {\n-                sleep(1000);\n-            }\n-        } catch (InterruptedException e) {\n-            throw new Failure(\"Interruption while preparing tested thread: \\n\\t\" + e);\n-        }\n-        return threadReady;\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SuspendThread\/suspendthrd003.java","additions":40,"deletions":22,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @bug 8167108 8266130\n@@ -173,0 +174,1 @@\n+ * @requires vm.jvmti\n@@ -176,1 +178,0 @@\n- *      -Xlog:thread+smr=debug\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SuspendThread\/suspendthrd003\/TestDescription.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-#define N_LATE_CALLS    10000\n@@ -57,1 +56,0 @@\n-        int late_count;\n@@ -100,5 +98,1 @@\n-        \/*\n-         * Using printf() instead of NSK_DISPLAY1() in this loop\n-         * in order to slow down the rate of SuspendThread() calls.\n-         *\/\n-        for (late_count = 0; late_count < N_LATE_CALLS; late_count++) {\n+        while (true) {\n@@ -106,1 +100,1 @@\n-            printf(\"INFO: Late suspend thread: %p\\n\", (void*)testedThread);\n+            NSK_DISPLAY1(\"INFO: Late suspend thread: %p\\n\", (void*)testedThread);\n@@ -109,1 +103,4 @@\n-                printf(\"INFO: Late suspend thread err: %d\\n\", l_err);\n+                if (l_err != JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+                    NSK_DISPLAY1(\"INFO: Late suspend thread err: %d\\n\", l_err);\n+                    nsk_jvmti_setFailStatus();\n+                }\n@@ -119,0 +116,1 @@\n+                break;\n@@ -122,6 +120,0 @@\n-        printf(\"INFO: made %d late calls to JVM\/TI SuspendThread()\\n\",\n-               late_count);\n-        printf(\"INFO: N_LATE_CALLS == %d value is %slarge enough to cause a \"\n-               \"SuspendThread() call after thread exit.\\n\", N_LATE_CALLS,\n-               (late_count == N_LATE_CALLS) ? \"NOT \" : \"\");\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SuspendThread\/suspendthrd003\/suspendthrd003.cpp","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,4 @@\n-    private static Wicket mainEntrance = new Wicket();\n+    private final static int DEF_TIME_MAX = 30;  \/\/ default max # secs to test\n+    private final static String PROG_NAME = \"issuspended002\";\n+\n+    private static Wicket mainEntrance;\n@@ -33,0 +36,1 @@\n+    private static Object waiter = new Object();\n@@ -39,15 +43,10 @@\n-        ThreadMXBean mbean = ManagementFactory.getThreadMXBean();\n-        MyThread thread = new MyThread(out);\n-        thread.start();\n-\n-        \/\/ Wait for MyThread to start\n-        mainEntrance.waitFor();\n-\n-        long id = thread.getId();\n-        ThreadInfo info = mbean.getThreadInfo(id, Integer.MAX_VALUE);\n-        boolean isSuspended = info.isSuspended();\n-        if (isSuspended) {\n-            out.println(\"Failure 1.\");\n-            out.println(\"ThreadInfo.isSuspended() returned true, before \"\n-                      + \"Thread.suspend() was invoked.\");\n-            testFailed = true;\n+        int timeMax = 0;\n+        if (argv.length == 0) {\n+            timeMax = DEF_TIME_MAX;\n+        } else {\n+            try {\n+                timeMax = Integer.parseUnsignedInt(argv[0]);\n+            } catch (NumberFormatException nfe) {\n+                System.err.println(\"'\" + argv[0] + \"': invalid timeMax value.\");\n+                usage();\n+            }\n@@ -56,9 +55,1 @@\n-        thread.suspend();\n-        info = mbean.getThreadInfo(id, Integer.MAX_VALUE);\n-        isSuspended = info.isSuspended();\n-        if (!isSuspended) {\n-            out.println(\"Failure 2.\");\n-            out.println(\"ThreadInfo.isSuspended() returned false, after \"\n-                      + \"Thread.suspend() was invoked.\");\n-            testFailed = true;\n-        }\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n@@ -66,9 +57,12 @@\n-        thread.resume();\n-        info = mbean.getThreadInfo(id, Integer.MAX_VALUE);\n-        isSuspended = info.isSuspended();\n-        if (isSuspended) {\n-            out.println(\"Failure 3.\");\n-            out.println(\"ThreadInfo.isSuspended() returned true, after \"\n-                      + \"Thread.resume() was invoked.\");\n-            testFailed = true;\n-        }\n+        long count = 0;\n+        ThreadMXBean mbean = ManagementFactory.getThreadMXBean();\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+\n+            MyThread thread = new MyThread(out);\n+            mainEntrance = new Wicket();\n+            thread.start();\n+\n+            \/\/ Wait for MyThread to start\n+            mainEntrance.waitFor();\n@@ -76,1 +70,10 @@\n-        thread.die = true;\n+            long id = thread.getId();\n+            ThreadInfo info = mbean.getThreadInfo(id, Integer.MAX_VALUE);\n+            boolean isSuspended = info.isSuspended();\n+            if (isSuspended) {\n+                out.println(\"Failure 1.\");\n+                out.println(\"ThreadInfo.isSuspended() returned true, before \"\n+                            + \"Thread.suspend() was invoked.\");\n+                testFailed = true;\n+                break;\n+            }\n@@ -78,2 +81,1 @@\n-        int count = 0;\n-        while (true) {\n+            thread.suspend();\n@@ -81,2 +83,6 @@\n-            if (info == null) {\n-                \/\/ the thread has exited\n+            isSuspended = info.isSuspended();\n+            if (!isSuspended) {\n+                out.println(\"Failure 2.\");\n+                out.println(\"ThreadInfo.isSuspended() returned false, after \"\n+                            + \"Thread.suspend() was invoked.\");\n+                testFailed = true;\n@@ -85,1 +91,3 @@\n-            count++;\n+\n+            thread.resume();\n+            info = mbean.getThreadInfo(id, Integer.MAX_VALUE);\n@@ -88,1 +96,1 @@\n-                out.println(\"Failure 4.\");\n+                out.println(\"Failure 3.\");\n@@ -90,1 +98,1 @@\n-                          + \"thread.die was set to true.\");\n+                            + \"Thread.resume() was invoked.\");\n@@ -94,0 +102,21 @@\n+\n+            synchronized (waiter) {\n+                thread.die = true;\n+                waiter.notifyAll();\n+            }\n+\n+            while (true) {\n+                info = mbean.getThreadInfo(id, Integer.MAX_VALUE);\n+                if (info == null) {\n+                    \/\/ the thread has exited\n+                    break;\n+                }\n+                isSuspended = info.isSuspended();\n+                if (isSuspended) {\n+                    out.println(\"Failure 4.\");\n+                    out.println(\"ThreadInfo.isSuspended() returned true, after \"\n+                                + \"thread.die was set to true.\");\n+                    testFailed = true;\n+                    break;\n+                }\n+            }\n@@ -96,1 +125,2 @@\n-        out.println(\"INFO: made \" + count + \" late getThreadInfo() calls.\");\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n@@ -103,0 +133,9 @@\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + PROG_NAME + \" [time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    time_max  max looping time in seconds\");\n+        System.err.println(\"              (default is \" + DEF_TIME_MAX +\n+                           \" seconds)\");\n+        System.exit(1);\n+    }\n+\n@@ -104,2 +143,1 @@\n-        final static long WAIT_TIME = 500; \/\/ Milliseconds\n-        Object object = new Object();\n+        final static long WAIT_TIME = 10; \/\/ Milliseconds\n@@ -119,1 +157,1 @@\n-                synchronized(object) {\n+                synchronized(waiter) {\n@@ -121,1 +159,1 @@\n-                        object.wait(WAIT_TIME);\n+                        waiter.wait(WAIT_TIME);\n@@ -126,0 +164,1 @@\n+                        break;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended002.java","additions":87,"deletions":48,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @bug 8167108 8266130\n@@ -39,1 +40,1 @@\n- * @run main\/othervm -Xlog:thread+smr=debug nsk.monitoring.ThreadInfo.isSuspended.issuspended002\n+ * @run main\/othervm nsk.monitoring.ThreadInfo.isSuspended.issuspended002\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended002\/TestDescription.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,4 @@\n-    private static Wicket mainEntrance = new Wicket();\n+    private final static int DEF_TIME_MAX = 30;  \/\/ default max # secs to test\n+    private final static String PROG_NAME = \"find006\";\n+\n+    private static Wicket mainEntrance;\n@@ -34,0 +37,1 @@\n+    private static Object waiter = new Object();\n@@ -41,0 +45,14 @@\n+\n+        String[] args = argHandler.getArguments();\n+        int timeMax = 0;\n+        if (args.length == 0) {\n+            timeMax = DEF_TIME_MAX;\n+        } else {\n+            try {\n+                timeMax = Integer.parseUnsignedInt(args[0]);\n+            } catch (NumberFormatException nfe) {\n+                System.err.println(\"'\" + args[0] + \"': invalid timeMax value.\");\n+                usage();\n+            }\n+        }\n+\n@@ -63,0 +81,3 @@\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long count = 0;\n@@ -64,2 +85,3 @@\n-        MyThread thread = new MyThread(out);\n-        thread.start();\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n@@ -67,3 +89,3 @@\n-        \/\/ Wait for MyThread to start\n-        mainEntrance.waitFor();\n-        id = thread.getId();\n+            MyThread thread = new MyThread(out);\n+            mainEntrance = new Wicket();\n+            thread.start();\n@@ -71,1 +93,3 @@\n-        thread.die = true;\n+            \/\/ Wait for MyThread to start\n+            mainEntrance.waitFor();\n+            id = thread.getId();\n@@ -73,8 +97,18 @@\n-        int count = 0;\n-        while (true) {\n-            ids = monitor.findMonitorDeadlockedThreads();\n-            count++;\n-            ThreadInfo info = mbean.getThreadInfo(id, Integer.MAX_VALUE);\n-            if (info == null) {\n-                \/\/ the thread has exited\n-                break;\n+            synchronized (waiter) {\n+                thread.die = true;\n+                waiter.notifyAll();\n+            }\n+\n+            while (true) {\n+                ids = monitor.findMonitorDeadlockedThreads();\n+                ThreadInfo info = mbean.getThreadInfo(id, Integer.MAX_VALUE);\n+                if (info == null) {\n+                    \/\/ the thread has exited\n+                    break;\n+                }\n+            }\n+\n+            try {\n+                thread.join();\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected: \" + e);\n@@ -84,1 +118,2 @@\n-        out.println(\"INFO: made \" + count + \" late findMonitorDeadlockedThreads() calls.\");\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n@@ -89,0 +124,9 @@\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + PROG_NAME + \" [time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    time_max  max looping time in seconds\");\n+        System.err.println(\"              (default is \" + DEF_TIME_MAX +\n+                           \" seconds)\");\n+        System.exit(1);\n+    }\n+\n@@ -90,2 +134,1 @@\n-        final static long WAIT_TIME = 500; \/\/ Milliseconds\n-        Object object = new Object();\n+        final static long WAIT_TIME = 10; \/\/ Milliseconds\n@@ -105,1 +148,1 @@\n-                synchronized(object) {\n+                synchronized(waiter) {\n@@ -107,1 +150,1 @@\n-                        object.wait(WAIT_TIME);\n+                        waiter.wait(WAIT_TIME);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadMXBean\/findMonitorDeadlockedThreads\/find006.java","additions":64,"deletions":21,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @bug 8167108 8266130\n@@ -40,1 +41,0 @@\n- *      -Xlog:thread+smr=debug\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadMXBean\/findMonitorDeadlockedThreads\/find006\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import nsk.share.jdi.Binder;\n@@ -45,2 +46,0 @@\n-    private DebugeeProcess debugee;\n-\n@@ -64,1 +63,3 @@\n-      * @deprecated Use Debugee.createIOPipe() instead.\n+      * @deprecated Preferred way is to start IOPipe before launching debuggee process.\n+      *\n+      * @see #startDebuggerPipe\n@@ -73,2 +74,1 @@\n-\n-        this.debugee = debugee;\n+        setServerSocket(debugee.getPipeServerSocket());\n@@ -84,5 +84,13 @@\n-    protected void connect() {\n-        if (listening) {\n-            setServerSocket(debugee.getPipeServerSocket());\n-            setConnectingProcess(debugee.getProcess());\n-        }\n+    \/**\n+     * Creates and starts listening <code>IOPipe<\/code> at debugger side.\n+     *\/\n+    public static IOPipe startDebuggerPipe(Binder binder) {\n+        IOPipe ioPipe = new IOPipe(binder.getLog(),\n+                binder.getArgumentHandler().getDebugeeHost(),\n+                binder.getArgumentHandler().getPipePortNumber(),\n+                (long)binder.getArgumentHandler().getWaitTime() * 60 * 1000,\n+                true);\n+        ioPipe.setServerSocket(binder.getPipeServerSocket());\n+        ioPipe.startListening();\n+        return ioPipe;\n+    }\n@@ -90,0 +98,2 @@\n+\n+    protected void connect() {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/IOPipe.java","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,2 +56,0 @@\n-    protected Process connectingProcess = null;\n-\n@@ -260,5 +258,0 @@\n-                    \/\/ check if listening process still alive\n-                    if (!checkConnectingProcess()) {\n-                        shouldStop = true;\n-                        throw new Failure(\"Break attaching to \" + name + \" connection: \" + \"listening process exited\");\n-                    }\n@@ -313,25 +306,0 @@\n-    \/**\n-     * Return true if another connecting process is still alive.\n-     *\/\n-    public boolean checkConnectingProcess() {\n-        if (connectingProcess == null) {\n-            \/\/ no process to check\n-            return true;\n-        }\n-        try {\n-            int exitCode = connectingProcess.exitValue();\n-        } catch (IllegalThreadStateException e) {\n-            \/\/ process is still alive\n-            return true;\n-        }\n-        \/\/ process exited\n-        return false;\n-    }\n-\n-    \/**\n-     * Set another connecting process to control if it is still alive.\n-     *\/\n-    public void setConnectingProcess(Process process) {\n-        connectingProcess = process;\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/SocketConnection.java","additions":1,"deletions":33,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,2 +82,0 @@\n-    protected Process connectingProcess;\n-\n@@ -163,4 +161,0 @@\n-    protected void setConnectingProcess(Process connectingProcess) {\n-        this.connectingProcess = connectingProcess;\n-    }\n-\n@@ -210,0 +204,57 @@\n+    protected class ListenerThread extends Thread {\n+        private SocketConnection connection;\n+        private RuntimeException error;\n+\n+        ListenerThread() {\n+            super(\"PipeIO Listener Thread\");\n+            setDaemon(true);\n+\n+            connection = new SocketConnection(SocketIOPipe.this, getName());\n+\n+            if (serverSocket == null) {\n+                connection.bind(port, timeout);\n+            } else {\n+                connection.setServerSocket(serverSocket);\n+            }\n+        }\n+\n+        @Override\n+        public void run() {\n+            synchronized (this) {\n+                try {\n+                    connection.accept(timeout);\n+                } catch (Throwable th) {\n+                    error = th instanceof RuntimeException\n+                            ? (RuntimeException)th\n+                            : new RuntimeException(th);\n+                }\n+                notifyAll();\n+            }\n+        }\n+\n+        public SocketConnection getConnection() {\n+            synchronized (this) {\n+                while (!connection.isConnected() && error != null) {\n+                    try {\n+                        wait();\n+                    } catch (InterruptedException e) {\n+                    }\n+                }\n+                if (error != null) {\n+                    throw error;\n+                }\n+                return connection;\n+            }\n+        }\n+    }\n+\n+    private ListenerThread listenerThread;\n+\n+    protected void startListening() {\n+        if (listenerThread != null) {\n+            throw new TestBug(\"already listening\");\n+        }\n+        listenerThread = new ListenerThread();\n+        listenerThread.start();\n+    }\n+\n@@ -222,2 +273,0 @@\n-        connection = new SocketConnection(this, getName());\n-\n@@ -225,5 +274,6 @@\n-            connection.setConnectingProcess(connectingProcess);\n-            if (serverSocket == null) {\n-                connection.bind(port, timeout);\n-            } else {\n-                connection.setServerSocket(serverSocket);\n+            \/\/ listenerThread == null means the test is not updated yet\n+            \/\/ to start IOPipe listening before launching debuggee.\n+            if (listenerThread == null) {\n+                \/\/ start listening and accept connection on the current thread\n+                listenerThread = new ListenerThread();\n+                listenerThread.run();\n@@ -231,7 +281,1 @@\n-\n-            if (shouldStop)\n-                return;\n-\n-            \/\/ wait for connection from remote host\n-            connection.accept(timeout);\n-\n+            connection = listenerThread.getConnection();\n@@ -239,0 +283,1 @@\n+            connection = new SocketConnection(this, getName());\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/SocketIOPipe.java","additions":66,"deletions":21,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package transform;\n+\n+import java.io.StringReader;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.stream.StreamSource;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @bug 8264766\n+ * @run testng transform.SymbolTableTest\n+ * @summary Tests SymbolTable\n+ *\/\n+public class SymbolTableTest {\n+    \/**\n+     * Verifies that the SymbolTable processes (adds) variables and params\n+     * properly. The SymbolTable holds variables and params in a map, it shall\n+     * therefore perform a type check before cast, or else result in a\n+     * ClassCastException when variables and\/or params have the same name (in\n+     * which case the later ones shadow the previous ones).\n+     *\n+     * @throws Exception if the test fails\n+     *\/\n+    @Test\n+    public void test() throws Exception {\n+        TransformerFactory transformerFactory = TransformerFactory.newInstance();\n+        String stylesheet = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n+                \"<xsl:stylesheet xmlns:xsl=\\\"http:\/\/www.w3.org\/1999\/XSL\/Transform\\\" version=\\\"1.0\\\">\\n\" +\n+                \" <xsl:variable name=\\\"background-color\\\">#f4f4f4<\/xsl:variable>\\n\" +\n+                \" <xsl:param name=\\\"background-color\\\">pp<\/xsl:param>\\n\" +\n+                \" <xsl:template name=\\\"tName\\\"><xsl:param name=\\\"background-color\\\">black<\/xsl:param>\\n\" +\n+                \" OK <xsl:value-of select=\\\"$background-color\\\"\/>\\n\" +\n+                \" <\/xsl:template>\\n\" +\n+                \" <xsl:template match=\\\"\/root\\\">\\n\" +\n+                \" <xsl:call-template name=\\\"tName\\\">\\n\" +\n+                \" <xsl:with-param name=\\\"background-color\\\" select=\\\"$background-color\\\"\/>\\n\" +\n+                \" <\/xsl:call-template>\\n\" +\n+                \" <\/xsl:template>\\n\" +\n+                \"<\/xsl:stylesheet>\\n\";\n+        transformerFactory.newTransformer(new StreamSource(new StringReader(stylesheet)));\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/transform\/SymbolTableTest.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -545,4 +545,0 @@\n-java\/foreign\/StdLibTest.java 8263512 macosx-aarch64\n-java\/foreign\/TestVarArgs.java 8263512 macosx-aarch64\n-java\/foreign\/valist\/VaListTest.java 8263512 macosx-aarch64\n-\n@@ -807,0 +803,4 @@\n+sun\/tools\/jstat\/jstatLineCounts1.sh                             8268211 linux-aarch64\n+sun\/tools\/jstat\/jstatLineCounts2.sh                             8268211 linux-aarch64\n+sun\/tools\/jstat\/jstatLineCounts3.sh                             8268211 linux-aarch64\n+sun\/tools\/jstat\/jstatLineCounts4.sh                             8268211 linux-aarch64\n","filename":"test\/jdk\/ProblemList.txt","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.HexFormat;\n@@ -87,1 +88,1 @@\n-    private static final String ALGORITHMS[] = { \"AES\", \"Rijndael\" };\n+    private static final String ALGORITHMS[] = { \"AES\" };\n@@ -233,0 +234,1 @@\n+            HexFormat hex = HexFormat.of().withUpperCase();\n@@ -234,1 +236,4 @@\n-                throw new RuntimeException(\"Combination #\" + k + \" failed\");\n+                System.out.println(\"Combination #\" + (k + 1) + \"\\nresult    \" +\n+                    hex.formatHex(outputTexts.get(k)) +\n+                    \"\\nexpected: \" + hex.formatHex(output));\n+                throw new RuntimeException(\"Combination #\" + (k + 1) + \" failed\");\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/Encrypt.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import java.math.BigInteger;\n@@ -44,0 +43,1 @@\n+import java.util.HexFormat;\n@@ -68,0 +68,1 @@\n+    static HexFormat hex = HexFormat.of();\n@@ -111,2 +112,2 @@\n-                System.out.println(\"Error in generating data for length \" +\n-                    ptlen);\n+                throw new RuntimeException(\"Error in generating data for length \" +\n+                    ptlen, e);\n@@ -119,0 +120,7 @@\n+        private static final byte[] HexToBytes(String hexVal) {\n+            if (hexVal == null) {\n+                return new byte[0];\n+            }\n+            return hex.parseHex(hexVal);\n+        }\n+\n@@ -179,1 +187,1 @@\n-        throw new Exception(\"Unaeble to find dataSet id = \" + id);\n+        throw new Exception(\"Unable to find dataSet id = \" + id);\n@@ -247,1 +255,1 @@\n-        System.out.println(\"Algo: \" + algo + \" \\tOps: \" + ops.toString());\n+        System.err.println(\"Algo: \" + algo + \" \\tOps: \" + ops.toString());\n@@ -259,1 +267,1 @@\n-                    System.out.print(\"Encrypt:  Data Index: \" + i + \" \\tSizes[ \");\n+                    System.err.print(\"Encrypt:  Data Index: \" + i + \" \\tSizes[ \");\n@@ -261,1 +269,1 @@\n-                        System.out.print(v + \" \");\n+                        System.err.print(v + \" \");\n@@ -263,1 +271,1 @@\n-                    System.out.println(\"]\");\n+                    System.err.println(\"]\");\n@@ -269,1 +277,1 @@\n-                    System.out.print(\"Decrypt:  Data Index: \" + i + \" \\tSizes[ \");\n+                    System.err.print(\"Decrypt:  Data Index: \" + i + \" \\tSizes[ \");\n@@ -271,1 +279,1 @@\n-                        System.out.print(v + \" \");\n+                        System.err.print(v + \" \");\n@@ -273,1 +281,1 @@\n-                    System.out.println(\"]\");\n+                    System.err.println(\"]\");\n@@ -280,1 +288,1 @@\n-                System.out.println(\"Encrypt:  Data Index: \" + i);\n+                System.err.println(\"Encrypt:  Data Index: \" + i);\n@@ -283,1 +291,1 @@\n-                System.out.println(\"Decrypt:  Data Index: \" + i);\n+                System.err.println(\"Decrypt:  Data Index: \" + i);\n@@ -301,1 +309,1 @@\n-        System.out.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n+        System.err.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n@@ -307,1 +315,1 @@\n-            System.out.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n+            System.err.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n@@ -323,2 +331,2 @@\n-        System.out.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n-            inOfs + \"  outOfs \" + outOfs + \"  in-place: different\");\n+        System.err.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n+            inOfs + \"  outOfs \" + outOfs + \"  in\/out buffer: different\");\n@@ -329,1 +337,1 @@\n-            System.out.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n+            System.err.println(\"\\tinput len: \" + input.length + \"  inOfs \" +\n@@ -487,6 +495,4 @@\n-                        \"):\\nresult   (len=\" + ctresult.length + \"):\" +\n-                        String.format(\"%0\" + (ctresult.length << 1) + \"x\",\n-                            new BigInteger(1, ctresult)) +\n-                        \"\\nexpected (len=\" + output.length + \"):\" +\n-                    String.format(\"%0\" + (output.length << 1) + \"x\",\n-                        new BigInteger(1, output));\n+                        \"):\\nresult   (len=\" + ctresult.length + \"): \" +\n+                        hex.formatHex(ctresult) +\n+                        \"\\nexpected (len=\" + output.length + \"): \" +\n+                        hex.formatHex(output);\n@@ -608,1 +614,1 @@\n-                        byteToHex(out) +\n+                        hex.formatHex(out) +\n@@ -610,2 +616,1 @@\n-                        String.format(\"%0\" + (output.length << 1) + \"x\",\n-                            new BigInteger(1, output));\n+                        hex.formatHex(output);\n@@ -626,0 +631,2 @@\n+        GCMBufferTest t;\n+\n@@ -627,0 +634,1 @@\n+\n@@ -665,1 +673,1 @@\n-        GCMBufferTest t = new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+        t = new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n@@ -681,0 +689,1 @@\n+\n@@ -713,1 +722,0 @@\n-    }\n@@ -715,18 +723,3 @@\n-    private static byte[] HexToBytes(String hexVal) {\n-        if (hexVal == null) {\n-            return new byte[0];\n-        }\n-        byte[] result = new byte[hexVal.length()\/2];\n-        for (int i = 0; i < result.length; i++) {\n-            String byteVal = hexVal.substring(2*i, 2*i +2);\n-            result[i] = Integer.valueOf(byteVal, 16).byteValue();\n-        }\n-        return result;\n-    }\n-\n-    private static String byteToHex(byte[] barray) {\n-        StringBuilder s = new StringBuilder();\n-        for (byte b : barray) {\n-            s.append(String.format(\"%02x\", b));\n-        }\n-        return s.toString();\n+        new GCMBufferTest(\"AES\/GCM\/NoPadding\",\n+            List.of(dtype.DIRECT, dtype.DIRECT, dtype.DIRECT)).\n+            dataSegments(new int[] { 49, 0, 2 }).dataSet(0).test();\n@@ -765,2 +758,1 @@\n-                \"794ec588176c703d3d2a7a07\",\n-                new byte[256], null,\n+                \"794ec588176c703d3d2a7a07\", new byte[256], null,\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMBufferTest.java","additions":42,"deletions":50,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+\n+\/*\n+ * @test\n+ * @summary Call decrypt doFinal() with different output values to see if the\n+ * the operation can complete after a ShortBufferException\n+ *\/\n+public class GCMShortBuffer {\n+    static Cipher c;\n+    static final GCMParameterSpec iv = new GCMParameterSpec(128, new byte[16]);\n+    static final SecretKeySpec keySpec = new SecretKeySpec(new byte[16], \"AES\");\n+    static byte cipherText[], plaintext[] = new byte[51];\n+    boolean error = false;\n+\n+    GCMShortBuffer(byte[] out) throws Exception {\n+        int len = cipherText.length - 1;\n+\n+        c.init(Cipher.DECRYPT_MODE, keySpec, iv);\n+        byte[] pt = new byte[c.getOutputSize(cipherText.length)];\n+        c.update(cipherText, 0, 1);\n+        try {\n+            c.doFinal(cipherText, 1, len, out, 0);\n+        } catch (ShortBufferException e) {\n+            System.out.println(\"ShortBuffer caught\");\n+        } catch (Exception e) {\n+            throw e;\n+        }\n+        int r = c.doFinal(cipherText, 1, len, pt, 0);\n+        if (r != pt.length) {\n+            System.out.println(\n+                \"doFinal() return ( \" + r + \") is not the same\" +\n+                    \"as getOutputSize returned\" + pt.length);\n+            error = true;\n+        }\n+        if (Arrays.compare(pt, plaintext) != 0) {\n+            System.out.println(\"output  : \" + HexFormat.of().formatHex(pt));\n+            System.out.println(\"expected: \" +\n+                HexFormat.of().formatHex(plaintext));\n+            System.out.println(\"output and plaintext do not match\");\n+            error = true;\n+        }\n+        if (error) {\n+            throw new Exception(\"An error has occurred\");\n+        }\n+    }\n+\n+    GCMShortBuffer(ByteBuffer dst) throws Exception {\n+        int len = cipherText.length - 1;\n+        ByteBuffer out = ByteBuffer.allocate(plaintext.length);\n+\n+        c.init(Cipher.DECRYPT_MODE, keySpec, iv);\n+        c.update(cipherText, 0, 1);\n+        ByteBuffer ct = ByteBuffer.wrap(cipherText, 1, len);\n+        try {\n+            c.doFinal(ct , dst);\n+        } catch (ShortBufferException e) {\n+            System.out.println(\"ShortBuffer caught\");\n+        } catch (Exception e) {\n+            throw e;\n+        }\n+        int r = c.doFinal(ByteBuffer.wrap(cipherText, 1, len), out);\n+        out.flip();\n+        if (r != out.capacity()) {\n+            System.out.println(\n+                \"doFinal() return ( \" + r + \") is not the same\" +\n+                    \" as getOutputSize returned\" + out.capacity());\n+            error = true;\n+        }\n+        if (out.compareTo(ByteBuffer.wrap(plaintext)) != 0) {\n+            System.out.println(\"output and plaintext do not match\");\n+            System.out.println(\"output  : \" +\n+                HexFormat.of().formatHex(out.array()));\n+            System.out.println(\"expected: \" +\n+                HexFormat.of().formatHex(plaintext));\n+            error = true;\n+        }\n+        if (error) {\n+            throw new Exception(\"An error has occurred\");\n+        }\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        c = Cipher.getInstance(\"AES\/GCM\/NoPadding\");\n+        c.init(Cipher.ENCRYPT_MODE, keySpec, iv);\n+        cipherText = c.doFinal(plaintext);\n+\n+        new GCMShortBuffer(new byte[13]);\n+        new GCMShortBuffer(new byte[50]);\n+        new GCMShortBuffer(ByteBuffer.allocate(13));\n+        new GCMShortBuffer(ByteBuffer.allocate(50));\n+    }\n+\n+\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMShortBuffer.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -110,0 +110,3 @@\n+                System.out.println(\"inOfsInBuf  = \" + inOfsInBuf);\n+                System.out.println(\"outOfsInBuf = \" + outOfsInBuf);\n+\n@@ -135,2 +138,0 @@\n-                    System.out.println(\"inOfsInBuf  = \" + inOfsInBuf);\n-                    System.out.println(\"outOfsInBuf = \" + outOfsInBuf);\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/OverlapByteBuffer.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-import java.util.Random;\n+import java.util.HexFormat;\n@@ -33,1 +33,0 @@\n-import javax.crypto.KeyGenerator;\n@@ -37,0 +36,1 @@\n+import javax.crypto.spec.GCMParameterSpec;\n@@ -38,0 +38,1 @@\n+import javax.crypto.spec.SecretKeySpec;\n@@ -46,1 +47,0 @@\n- * @key randomness\n@@ -59,1 +59,3 @@\n-    private static final int KEY_LENGTH = 128;\n+    private static final int KEY_LENGTH = 16;\n+    static byte[] plainText = new byte[128];\n+    static byte[] key = new byte[KEY_LENGTH];\n@@ -76,0 +78,1 @@\n+\n@@ -77,4 +80,7 @@\n-        Cipher ci = null;\n-        byte[] iv = null;\n-        AlgorithmParameterSpec aps = null;\n-        SecretKey key = null;\n+        Cipher ci;\n+        System.out.println(\"Testing \" + algo + \"\/\" + mo + \"\/\" + pad);\n+\n+        byte[] iv = new byte[16];\n+        AlgorithmParameterSpec aps = new GCMParameterSpec(128, iv);\n+        SecretKey key = new SecretKeySpec(this.key, 0, KEY_LENGTH,\"AES\");\n+\n@@ -83,4 +89,0 @@\n-            Random rdm = new Random();\n-            byte[] plainText = new byte[128];\n-            rdm.nextBytes(plainText);\n-\n@@ -88,3 +90,0 @@\n-            KeyGenerator kg = KeyGenerator.getInstance(algo, PROVIDER);\n-            kg.init(KEY_LENGTH);\n-            key = kg.generateKey();\n@@ -93,1 +92,1 @@\n-            if (!mo.equalsIgnoreCase(\"GCM\")) {\n+            if (mo.equalsIgnoreCase(\"GCM\")) {\n@@ -95,0 +94,2 @@\n+            } else if (mo.equalsIgnoreCase(\"ECB\")) {\n+                ci.init(Cipher.ENCRYPT_MODE, key, (AlgorithmParameterSpec)null);\n@@ -96,1 +97,1 @@\n-                ci.init(Cipher.ENCRYPT_MODE, key);\n+                ci.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));\n@@ -101,1 +102,1 @@\n-                    0);\n+                0);\n@@ -120,2 +121,0 @@\n-            byte[] tmp = new byte[len];\n-            System.arraycopy(recoveredText, 0, tmp, 0, len);\n@@ -124,1 +123,2 @@\n-            if (!java.util.Arrays.equals(plainText, tmp)) {\n+            if (!java.util.Arrays.equals(plainText, 0 , plainText.length,\n+                recoveredText, 0, len)) {\n@@ -126,1 +126,1 @@\n-                dumpBytes(plainText);\n+                System.out.println(HexFormat.of().formatHex(plainText));\n@@ -128,4 +128,4 @@\n-                dumpBytes(tmp);\n-                throw new RuntimeException(\n-                        \"Original text is not equal with recovered text, with mode:\"\n-                                + mo);\n+                System.out.println(HexFormat.of().\n+                    formatHex(recoveredText, 0, len));\n+                throw new RuntimeException(\"Original text is not equal with \" +\n+                    \"recovered text, with mode:\" + mo);\n@@ -137,2 +137,2 @@\n-                System.out.println(\"Unexpected NoSuchAlgorithmException with mode: \"\n-                        + mo);\n+                System.out.println(\"Unexpected NoSuchAlgorithmException with\" +\n+                    \" mode: \" + mo);\n@@ -149,8 +149,0 @@\n-\n-    private void dumpBytes(byte[] bytes) {\n-        for (byte b : bytes) {\n-            System.out.print(Integer.toHexString(b));\n-        }\n-\n-        System.out.println();\n-    }\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AES\/TestAESCipher.java","additions":29,"deletions":37,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-    private static final String ALGORITHM = \"Rijndael\";\n+    private static final String ALGORITHM = \"AES\";\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AES\/TestSameBuffer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key headful\n+ * @bug 8266159\n+ * @summary Test to detect regression in pixel drawing.\n+ *          A small circle is drawn and boundary pixels are compared to expected pixels.\n+ *          Note : this test is specifically written for uiScale=1.0\n+ * @run main\/othervm -Dsun.java2d.uiScale=1.0 DrawOvalTest\n+ *\/\n+\n+import javax.imageio.ImageIO;\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Transparency;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.VolatileImage;\n+import java.io.File;\n+import java.io.IOException;\n+\n+public class DrawOvalTest {\n+    public static void main(String[] args) throws IOException {\n+        GraphicsConfiguration gc = GraphicsEnvironment.getLocalGraphicsEnvironment()\n+                .getDefaultScreenDevice().getDefaultConfiguration();\n+        VolatileImage vi = gc.createCompatibleVolatileImage(10, 10, Transparency.TRANSLUCENT);\n+\n+        \/\/ Draw test rendering sequence\n+        BufferedImage snapshot = null;\n+        Graphics2D g2 = vi.createGraphics();\n+\n+        do {\n+            vi.validate(gc);\n+            render(g2);\n+            snapshot = vi.getSnapshot();\n+        } while (vi.contentsLost());\n+\n+        \/\/ Pixel color sequence expected after test rendering is complete\n+        \/\/ Blue color = -16776961\n+        \/\/ Red color  = -65536\n+        int sequence[] = {\n+            -16776961,\n+            -16776961,\n+            -16776961,\n+            -65536,\n+            -65536,\n+            -65536,\n+            -65536,\n+            -16776961,\n+            -16776961,\n+            -16776961\n+        };\n+\n+        \/\/ Test the color of pixels at the image boundary\n+        for (int i = 0; i < snapshot.getWidth(); i++) {\n+\n+            \/\/ Test first row, last row, first column and last column\n+            if ( snapshot.getRGB(i, 0) != sequence[i] ||\n+                 snapshot.getRGB(i, 9) != sequence[i] ||\n+                 snapshot.getRGB(0, i) != sequence[i] ||\n+                 snapshot.getRGB(9, i) != sequence[i] ) {\n+                ImageIO.write(snapshot, \"png\", new File(\"DrawOvalTest_snapshot.png\"));\n+                throw new RuntimeException(\"Test failed.\");\n+            }\n+        }\n+    }\n+\n+    private static void render(Graphics2D g2) {\n+        g2.setColor(Color.BLUE);\n+        g2.fillRect(0, 0, 10, 10);\n+        g2.setColor(Color.RED);\n+        g2.drawOval(0, 0, 9, 9);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Graphics\/DrawOvalTest.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8267430\n+ * @key headful\n+ * @summary verify setting a display mode with unknow refresh rate works\n+ *\/\n+\n+import java.awt.DisplayMode;\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n+\n+public class UnknownRefrshRateTest {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+        GraphicsDevice[] devices = ge.getScreenDevices();\n+\n+        for (GraphicsDevice d : devices) {\n+\n+            if (!d.isDisplayChangeSupported()) {\n+                continue;\n+            }\n+            DisplayMode odm = d.getDisplayMode();\n+            System.out.println(\"device=\" + d + \" original mode=\" + odm);\n+\n+            DisplayMode[] modes = d.getDisplayModes();\n+            System.out.println(\"There are \" + modes.length + \" modes.\");\n+            try {\n+                for (int i=0; i<modes.length; i++) {\n+                    DisplayMode mode = modes[i];\n+                    System.out.println(\"copying from mode \" + i + \" : \" + mode);\n+                    int w = mode.getWidth();\n+                    int h = mode.getHeight();\n+                    int bpp = mode.getBitDepth();\n+                    int refRate = DisplayMode.REFRESH_RATE_UNKNOWN;\n+                    DisplayMode newMode = new DisplayMode(w, h, bpp, refRate);\n+                    d.setDisplayMode(newMode);\n+                    Thread.sleep(2000);\n+                    System.out.println(\"set \" + d.getDisplayMode());\n+                 }\n+             } finally {\n+                 System.out.println(\"restoring original mode\"+odm);\n+                 d.setDisplayMode(odm);\n+                 Thread.sleep(10000);\n+             }\n+       }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/GraphicsDevice\/DisplayModes\/UnknownRefrshRateTest.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -1,98 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import javax.swing.*;\n-\n-public class MyMacCanvas extends Canvas {\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"mylib\");\n-        } catch (Throwable t) {\n-            System.out.println(\"Test failed!!\");\n-            t.printStackTrace();\n-            System.exit(1);\n-        }\n-    }\n-\n-    public void addNotify() {\n-        super.addNotify();\n-        addNativeCoreAnimationLayer();\n-    }\n-\n-    public native void addNativeCoreAnimationLayer();\n-\n-    static JAWTFrame f;\n-    public static void main(String[] args) {\n-        try {\n-            Robot robot = new Robot();\n-            EventQueue.invokeLater(new Runnable() {\n-                public void run() {\n-                    f = new JAWTFrame(\"JAWTExample\");\n-                    f.setBackground(Color.white);\n-                    f.setLayout(new BorderLayout(10, 20));\n-                    f.setLocation(50, 50);\n-                    ((JComponent) f.getContentPane()).setBorder(BorderFactory.createMatteBorder(10, 10, 10, 10, Color.cyan));\n-                    f.addNotify();\n-                    f.pack();\n-                    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n-                    f.setVisible(true);\n-                }\n-            });\n-            robot.delay(5000);\n-            Color col1 = new Color(0, 0, 0);\n-            Color col2 = robot.getPixelColor(f.getX()+50, f.getY()+50);\n-            if (col1.equals(col2)) {\n-                System.out.println(\"Test passed!\");\n-            } else {\n-                System.out.println(\"col1 \" + col1 + \" col2 \" + col2);\n-                throw new RuntimeException(\"Color of JAWT canvas is wrong or \" +\n-                        \"it was not rendered. \" + \"Check that other windows \" +\n-                        \"do not block the test frame.\");\n-            }\n-            System.exit(0);\n-        } catch (Throwable t) {\n-            System.out.println(\"Test failed!\");\n-            t.printStackTrace();\n-            System.exit(1);\n-        }\n-    }\n-\n-    private static class JAWTFrame extends JFrame {\n-        public JAWTFrame(final String title) {\n-            super(title);\n-        }\n-\n-        public void addNotify() {\n-            super.addNotify(); \/\/ ensures native component hierarchy is setup\n-\n-            final Component layerBackedCanvas = new MyMacCanvas();\n-            layerBackedCanvas.setPreferredSize(new Dimension(400, 200));\n-            add(layerBackedCanvas, BorderLayout.CENTER);\n-\n-            invalidate();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/awt\/JAWT\/MyMacCanvas.java","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -1,13 +0,0 @@\n-#!\/bin\/sh\n-\n-set -e\n-\n-JAVA_HOME='\/export\/lanai\/build\/macosx-x64-debug\/jdk'\n-\n-$JAVA_HOME\/bin\/javac MyMacCanvas.java\n-\n-gcc -v myfile.m -I\"$JAVA_HOME\/include\" -c -o myfile.o\n-\n-gcc -v myfile.o -L$JAVA_HOME\/lib -ljawt -framework AppKit -framework OpenGL -framework Metal -framework Quartz -shared -o libmylib.jnilib\n-\n-$JAVA_HOME\/bin\/java -Djava.library.path=. -Dsun.java2d.metal=True MyMacCanvas\n","filename":"test\/jdk\/java\/awt\/JAWT\/jawt-mac-buildrun.sh","additions":0,"deletions":13,"binary":false,"changes":13,"status":"deleted"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#import \"JAVAVM\/jawt_md.h\"\n-#import <Quartz\/Quartz.h>\n-\n-\/*\n- * Pass the block to a selector of a class that extends NSObject\n- * There is no need to copy the block since this class always waits.\n- *\/\n-@interface BlockRunner : NSObject { }\n-\n-+ (void)invokeBlock:(void (^)())block;\n-@end\n-\n-@implementation BlockRunner\n-\n-+ (void)invokeBlock:(void (^)())block{\n-  block();\n-}\n-\n-+ (void)performBlock:(void (^)())block {\n-  [self performSelectorOnMainThread:@selector(invokeBlock:) withObject:block waitUntilDone:YES];\n-}\n-\n-@end\n-\n-\n-\/*\n- * Class:        MyMacCanvas\n- * Method:       paint\n- * SIgnature:    (Ljava\/awt\/Graphics;)V\n- *\/\n-JNIEXPORT void JNICALL Java_MyMacCanvas_addNativeCoreAnimationLayer\n-(JNIEnv* env, jobject canvas, jobject graphics)\n-{\n-    printf(\"paint called\\n\");\n-\n-    JAWT awt;\n-    awt.version = JAWT_VERSION_1_4 | JAWT_MACOSX_USE_CALAYER;\n-    if (JAWT_GetAWT(env, &awt) == JNI_FALSE) {\n-        printf(\"AWT Not found\\n\");\n-        return;\n-    }\n-\n-    printf(\"JAWT found\\n\");\n-\n-    \/* Get the drawing surface *\/\n-    JAWT_DrawingSurface* ds = awt.GetDrawingSurface(env, canvas);\n-    if (ds == NULL) {\n-        printf(\"NULL drawing surface\\n\");\n-        return;\n-    }\n-\n-    \/* Lock the drawing surface *\/\n-    jint lock = ds->Lock(ds);\n-    printf(\"Lock value %d\\n\", (int)lock);\n-    if((lock & JAWT_LOCK_ERROR) != 0) {\n-        printf(\"Error locking surface\");\n-        return;\n-    }\n-\n-    \/* Get the drawing surface info *\/\n-    JAWT_DrawingSurfaceInfo *dsi = ds->GetDrawingSurfaceInfo(ds);\n-    if (dsi == NULL) {\n-        printf(\"Error getting surface info\\n\");\n-        ds->Unlock(ds);\n-        return;\n-    }\n-\n-    \/\/ create and attach the layer on the AppKit thread\n-    void (^block)() = ^(){\n-        \/\/ attach the \"root layer\" to the AWT Canvas surface layers\n-        CALayer *layer = [[CALayer new] autorelease];\n-        id <JAWT_SurfaceLayers> surfaceLayers = (id <JAWT_SurfaceLayers>)dsi->platformInfo;\n-        CGColorSpaceRef colorspace = CGColorSpaceCreateDeviceRGB ();\n-        CGFloat rgba[4] = {0.0, 0.0, 0.0, 1.0};\n-        CGColorRef color = CGColorCreate (colorspace, rgba);\n-        layer.backgroundColor = color;\n-        surfaceLayers.layer = layer;\n-    };\n-\n-    if ([NSThread isMainThread]) {\n-        block();\n-    } else {\n-        [BlockRunner performBlock:block];\n-    }\n-\n-    \/* Free the drawing surface info *\/\n-    ds->FreeDrawingSurfaceInfo(dsi);\n-\n-    \/* Unlock the drawing surface *\/\n-    ds->Unlock(ds);\n-\n-    \/* Free the drawing surface *\/\n-    awt.FreeDrawingSurface(ds);\n-}\n","filename":"test\/jdk\/java\/awt\/JAWT\/myfile.m","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.swing.AbstractAction;\n+import javax.swing.JButton;\n+import javax.swing.JDialog;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.JTextArea;\n+import javax.swing.SwingUtilities;\n+import javax.swing.WindowConstants;\n+import java.awt.BorderLayout;\n+import java.awt.FlowLayout;\n+import java.awt.event.ActionEvent;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ *  @test\n+ *  @bug 8256465\n+ *  @requires (os.family == \"Mac\")\n+ *  @summary Application should not freeze when opening dialog\n+ *  @key headful\n+ *  @run main\/manual TestAppFreeze\n+ *\/\n+\n+public class TestAppFreeze {\n+    private static volatile CountDownLatch countDownLatch;\n+    private static JFrame instructionFrame;\n+    private static JFrame testFrame;\n+    private static volatile boolean testPassed = false;\n+\n+    private static boolean validatePlatform() {\n+        String osName = System.getProperty(\"os.name\");\n+        if (osName == null) {\n+            throw new RuntimeException(\"Name of the current OS could not be\" +\n+                    \" retrieved.\");\n+        }\n+        return osName.startsWith(\"Mac\");\n+    }\n+\n+    private static void createInstructionUI() {\n+        SwingUtilities.invokeLater(() -> {\n+            String instruction = \"1. This test is only for Mac OS Version 10.12 \" +\n+                    \"or later, on other Mac OS just press PASS\\n\" +\n+                    \"2. Go to System Preference -> General on Mac OS 11 or later\\n\" +\n+                    \"3. Go to System Preference -> Dock on Mac OS 10.12 to 10.15\\n\" +\n+                    \"4. Set Prefer tabs when opening documents to Always.\\n\" +\n+                    \"5. Then click on the click button of the test frame\\n\" +\n+                    \"6. The dialog should open in new window and Application \" +\n+                    \"should not freeze\\n\" +\n+                    \"7. IF the conditions are met then press PASS else \" +\n+                    \"press FAIL\";\n+            instructionFrame = new JFrame(\"Instruction Frame\");\n+            JTextArea  textArea = new JTextArea(instruction);\n+            textArea.setEditable(false);\n+            final JButton passButton = new JButton(\"PASS\");\n+            passButton.addActionListener((e -> {\n+                testPassed = true;\n+                instructionFrame.dispose();\n+                testFrame.dispose();\n+                countDownLatch.countDown();\n+            }));\n+            final JButton failButton = new JButton(\"FAIL\");\n+            failButton.addActionListener((e) -> {\n+                instructionFrame.dispose();\n+                testFrame.dispose();\n+                countDownLatch.countDown();\n+            });\n+\n+            JPanel mainPanel = new JPanel(new BorderLayout());\n+            mainPanel.add(textArea, BorderLayout.CENTER);\n+\n+            JPanel buttonPanel =  new JPanel(new FlowLayout());\n+            buttonPanel.add(passButton);\n+            buttonPanel.add(failButton);\n+            mainPanel.add(buttonPanel, BorderLayout.SOUTH);\n+            instructionFrame.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n+            instructionFrame.setBounds(0, 0, 500, 500);\n+            instructionFrame.add(mainPanel);\n+            instructionFrame.pack();\n+            instructionFrame.setVisible(true);\n+        });\n+    }\n+\n+    private static void testApp() {\n+        SwingUtilities.invokeLater(() ->{\n+            testFrame = new JFrame(\"TestFrame\");\n+            testFrame.setBounds(600, 0, 1000, 200);\n+            testFrame.getContentPane().add(new JButton(new AbstractAction(\"Click\") {\n+                @Override\n+                public void actionPerformed(ActionEvent e) {\n+                    JDialog dlg = new JDialog(testFrame, false);\n+                    dlg.setSize(500, 500);\n+                    dlg.getContentPane().add(new JTextArea());\n+                    dlg.setVisible(true);\n+                }\n+            }));\n+            testFrame.setVisible(true);\n+        });\n+    }\n+\n+    public static void main(String[] args) throws Exception{\n+        if (!validatePlatform()) {\n+            System.out.println(\"This test is only for Mac OS\");\n+            return;\n+        }\n+        countDownLatch = new CountDownLatch(1);\n+        TestAppFreeze testAppFreeze = new TestAppFreeze();\n+        testAppFreeze.createInstructionUI();\n+        testAppFreeze.testApp();\n+        countDownLatch.await(15, TimeUnit.MINUTES);\n+\n+        if(!testPassed) {\n+            throw new RuntimeException(\"Test failed!\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Window\/TestAppFreeze.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n- * @run testng\/othervm\/timeout=240\n+ * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -195,1 +195,0 @@\n-                lockCount.incrementAndGet();\n@@ -197,1 +196,2 @@\n-                    ResourceScope.Handle handle = scope.acquire();\n+                    ResourceScope.Handle handle = scope.acquire(); \/\/ this can throw if segment has been closed\n+                    lockCount.incrementAndGet();\n@@ -199,3 +199,4 @@\n-                    scope.release(handle);\n-                    scope.release(handle); \/\/ make sure it's idempotent\n-                    scope.release(handle); \/\/ make sure it's idempotent\n+                    lockCount.decrementAndGet();\n+                    scope.release(handle); \/\/ cannot throw (acquired segments cannot be closed)\n+                    scope.release(handle); \/\/ cannot throw (idempotent)\n+                    scope.release(handle); \/\/ cannot throw (idempotent)\n@@ -204,2 +205,0 @@\n-                } finally {\n-                    lockCount.decrementAndGet();\n@@ -210,1 +209,5 @@\n-        while (lockCount.get() > 0) {\n+        while (lockCount.get() == 0) {\n+            waitSomeTime(); \/\/ make sure some thread gets scheduled\n+        }\n+\n+        while (true) {\n","filename":"test\/jdk\/java\/foreign\/TestResourceScope.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run testng\/othervm\/timeout=240\n+ * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,8 +67,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class,\n-          expectedExceptionsMessageRegExp = \".*Target handle may throw exceptions.*\")\n-    public void testEagerExceptionBlocked() {\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            CLinker.getInstance().upcallStub(ThrowingUpcall.MH_throwException, FunctionDescriptor.ofVoid(), scope);\n-        }\n-    }\n-\n@@ -88,2 +80,0 @@\n-                \/\/ security manager to block normal System.exit\n-                \"-Djava.security.manager=allow\",\n@@ -104,6 +94,0 @@\n-\n-        \/\/ If the VM crashes with an uncaught IllegalStateException from the security manager\n-        \/\/ the crash log should include the exception message.\n-        \/\/ Make sure that is _not_ the case.\n-        String shouldNotInclude = \"Can not use exitVM\";\n-        assertFalse(linesContain(outLines, shouldNotInclude), \"Found '\" + shouldNotInclude + \"' in stdout\");\n","filename":"test\/jdk\/java\/foreign\/TestUpcallException.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -43,12 +43,0 @@\n-        System.setSecurityManager(new SecurityManager() {\n-            @Override\n-            public void checkExit(int status) {\n-                throw new IllegalStateException(\"Can not use exitVM\");\n-            }\n-\n-            @Override\n-            public void checkPermission(Permission perm) {\n-                \/\/ do nothing\n-            }\n-        });\n-\n","filename":"test\/jdk\/java\/foreign\/ThrowingUpcall.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,2 @@\n- *          jdk.incubator.foreign\/jdk.internal.foreign.abi.aarch64\n+ *          jdk.incubator.foreign\/jdk.internal.foreign.abi.aarch64.linux\n+ *          jdk.incubator.foreign\/jdk.internal.foreign.abi.aarch64.macos\n@@ -39,1 +40,2 @@\n-import jdk.internal.foreign.abi.aarch64.AArch64Linker;\n+import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64Linker;\n+import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64Linker;\n@@ -59,0 +61,1 @@\n+import static jdk.incubator.foreign.CLinker.C_LONG;\n@@ -116,2 +119,4 @@\n-    private static final Function<Consumer<VaList.Builder>, VaList> aarch64VaListFactory\n-            = actions -> AArch64Linker.newVaList(actions, ResourceScope.newConfinedScope());\n+    private static final Function<Consumer<VaList.Builder>, VaList> linuxAArch64VaListFactory\n+            = actions -> LinuxAArch64Linker.newVaList(actions, ResourceScope.newConfinedScope());\n+    private static final Function<Consumer<VaList.Builder>, VaList> macAArch64VaListFactory\n+            = actions -> MacOsAArch64Linker.newVaList(actions, ResourceScope.newConfinedScope());\n@@ -125,2 +130,4 @@\n-    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> aarch64VaListScopedFactory\n-            = (builder, scope) -> AArch64Linker.newVaList(builder, scope.scope());\n+    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> linuxAArch64VaListScopedFactory\n+            = (builder, scope) -> LinuxAArch64Linker.newVaList(builder, scope.scope());\n+    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> macAArch64VaListScopedFactory\n+            = (builder, scope) -> MacOsAArch64Linker.newVaList(builder, scope.scope());\n@@ -138,4 +145,5 @@\n-                { winVaListFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },\n-                { sysvVaListFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },\n-                { aarch64VaListFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n-                { platformVaListFactory, sumIntsNative,                        C_INT         },\n+                { winVaListFactory,          sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },\n+                { sysvVaListFactory,         sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },\n+                { linuxAArch64VaListFactory, sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n+                { macAArch64VaListFactory,   sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n+                { platformVaListFactory,     sumIntsNative,                        C_INT         },\n@@ -166,4 +174,5 @@\n-                { winVaListFactory,      sumDoublesJavaFact.apply(Win64.C_DOUBLE),   Win64.C_DOUBLE   },\n-                { sysvVaListFactory,     sumDoublesJavaFact.apply(SysV.C_DOUBLE),    SysV.C_DOUBLE    },\n-                { aarch64VaListFactory,  sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },\n-                { platformVaListFactory, sumDoublesNative,                           C_DOUBLE         },\n+                { winVaListFactory,          sumDoublesJavaFact.apply(Win64.C_DOUBLE),   Win64.C_DOUBLE   },\n+                { sysvVaListFactory,         sumDoublesJavaFact.apply(SysV.C_DOUBLE),    SysV.C_DOUBLE    },\n+                { linuxAArch64VaListFactory, sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },\n+                { macAArch64VaListFactory,   sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },\n+                { platformVaListFactory,     sumDoublesNative,                           C_DOUBLE         },\n@@ -196,4 +205,5 @@\n-                { winVaListFactory,      getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },\n-                { sysvVaListFactory,     getIntJavaFact.apply(SysV.C_POINTER),    SysV.C_POINTER    },\n-                { aarch64VaListFactory,  getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },\n-                { platformVaListFactory, getIntNative,                            C_POINTER         },\n+                { winVaListFactory,          getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },\n+                { sysvVaListFactory,         getIntJavaFact.apply(SysV.C_POINTER),    SysV.C_POINTER    },\n+                { linuxAArch64VaListFactory, getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },\n+                { macAArch64VaListFactory,   getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },\n+                { platformVaListFactory,     getIntNative,                            C_POINTER         },\n@@ -250,4 +260,5 @@\n-                argsFact.apply(winVaListFactory,      Win64.C_INT,   sumStructJavaFact),\n-                argsFact.apply(sysvVaListFactory,     SysV.C_INT,    sumStructJavaFact),\n-                argsFact.apply(aarch64VaListFactory,  AArch64.C_INT, sumStructJavaFact),\n-                argsFact.apply(platformVaListFactory, C_INT,         sumStructNativeFact),\n+                argsFact.apply(winVaListFactory,          Win64.C_INT,   sumStructJavaFact),\n+                argsFact.apply(sysvVaListFactory,         SysV.C_INT,    sumStructJavaFact),\n+                argsFact.apply(linuxAArch64VaListFactory, AArch64.C_INT, sumStructJavaFact),\n+                argsFact.apply(macAArch64VaListFactory,   AArch64.C_INT, sumStructJavaFact),\n+                argsFact.apply(platformVaListFactory,     C_INT,         sumStructNativeFact),\n@@ -302,4 +313,5 @@\n-                argsFact.apply(winVaListFactory,      Win64.C_LONG_LONG,   sumStructJavaFact),\n-                argsFact.apply(sysvVaListFactory,     SysV.C_LONG_LONG,    sumStructJavaFact),\n-                argsFact.apply(aarch64VaListFactory,  AArch64.C_LONG_LONG, sumStructJavaFact),\n-                argsFact.apply(platformVaListFactory, C_LONG_LONG,         sumStructNativeFact),\n+                argsFact.apply(winVaListFactory,          Win64.C_LONG_LONG,   sumStructJavaFact),\n+                argsFact.apply(sysvVaListFactory,         SysV.C_LONG_LONG,    sumStructJavaFact),\n+                argsFact.apply(linuxAArch64VaListFactory, AArch64.C_LONG_LONG, sumStructJavaFact),\n+                argsFact.apply(macAArch64VaListFactory,   AArch64.C_LONG_LONG, sumStructJavaFact),\n+                argsFact.apply(platformVaListFactory,     C_LONG_LONG,         sumStructNativeFact),\n@@ -354,4 +366,5 @@\n-                argsFact.apply(winVaListFactory,      Win64.C_FLOAT,   sumStructJavaFact),\n-                argsFact.apply(sysvVaListFactory,     SysV.C_FLOAT,    sumStructJavaFact),\n-                argsFact.apply(aarch64VaListFactory,  AArch64.C_FLOAT, sumStructJavaFact),\n-                argsFact.apply(platformVaListFactory, C_FLOAT,         sumStructNativeFact),\n+                argsFact.apply(winVaListFactory,          Win64.C_FLOAT,   sumStructJavaFact),\n+                argsFact.apply(sysvVaListFactory,         SysV.C_FLOAT,    sumStructJavaFact),\n+                argsFact.apply(linuxAArch64VaListFactory, AArch64.C_FLOAT, sumStructJavaFact),\n+                argsFact.apply(macAArch64VaListFactory,   AArch64.C_FLOAT, sumStructJavaFact),\n+                argsFact.apply(platformVaListFactory,     C_FLOAT,         sumStructNativeFact),\n@@ -415,4 +428,5 @@\n-                argsFact.apply(winVaListFactory,      Win64.C_LONG_LONG,   sumStructJavaFact),\n-                argsFact.apply(sysvVaListFactory,     SysV.C_LONG_LONG,    sumStructJavaFact),\n-                argsFact.apply(aarch64VaListFactory,  AArch64.C_LONG_LONG, sumStructJavaFact),\n-                argsFact.apply(platformVaListFactory, C_LONG_LONG,         sumStructNativeFact),\n+                argsFact.apply(winVaListFactory,          Win64.C_LONG_LONG,   sumStructJavaFact),\n+                argsFact.apply(sysvVaListFactory,         SysV.C_LONG_LONG,    sumStructJavaFact),\n+                argsFact.apply(linuxAArch64VaListFactory, AArch64.C_LONG_LONG, sumStructJavaFact),\n+                argsFact.apply(macAArch64VaListFactory,   AArch64.C_LONG_LONG, sumStructJavaFact),\n+                argsFact.apply(platformVaListFactory,     C_LONG_LONG,         sumStructNativeFact),\n@@ -469,4 +483,5 @@\n-                { winVaListFactory,      sumStackJavaFact.apply(Win64.C_LONG_LONG, Win64.C_DOUBLE),     Win64.C_LONG_LONG,   Win64.C_DOUBLE   },\n-                { sysvVaListFactory,     sumStackJavaFact.apply(SysV.C_LONG_LONG, SysV.C_DOUBLE),       SysV.C_LONG_LONG,    SysV.C_DOUBLE    },\n-                { aarch64VaListFactory,  sumStackJavaFact.apply(AArch64.C_LONG_LONG, AArch64.C_DOUBLE), AArch64.C_LONG_LONG, AArch64.C_DOUBLE },\n-                { platformVaListFactory, sumStackNative,                                                C_LONG_LONG,         C_DOUBLE         },\n+                { winVaListFactory,           sumStackJavaFact.apply(Win64.C_LONG_LONG, Win64.C_DOUBLE),     Win64.C_LONG_LONG,   Win64.C_DOUBLE   },\n+                { sysvVaListFactory,          sumStackJavaFact.apply(SysV.C_LONG_LONG, SysV.C_DOUBLE),       SysV.C_LONG_LONG,    SysV.C_DOUBLE    },\n+                { linuxAArch64VaListFactory,  sumStackJavaFact.apply(AArch64.C_LONG_LONG, AArch64.C_DOUBLE), AArch64.C_LONG_LONG, AArch64.C_DOUBLE },\n+                { macAArch64VaListFactory,    sumStackJavaFact.apply(AArch64.C_LONG_LONG, AArch64.C_DOUBLE), AArch64.C_LONG_LONG, AArch64.C_DOUBLE },\n+                { platformVaListFactory,      sumStackNative,                                                C_LONG_LONG,         C_DOUBLE         },\n@@ -522,6 +537,8 @@\n-                { Windowsx64Linker.emptyVaList()      },\n-                { winVaListFactory.apply(b -> {})     },\n-                { SysVx64Linker.emptyVaList()         },\n-                { sysvVaListFactory.apply(b -> {})    },\n-                { AArch64Linker.emptyVaList()         },\n-                { aarch64VaListFactory.apply(b -> {}) },\n+                { Windowsx64Linker.emptyVaList()           },\n+                { winVaListFactory.apply(b -> {})          },\n+                { SysVx64Linker.emptyVaList()              },\n+                { sysvVaListFactory.apply(b -> {})         },\n+                { LinuxAArch64Linker.emptyVaList()         },\n+                { linuxAArch64VaListFactory.apply(b -> {}) },\n+                { MacOsAArch64Linker.emptyVaList()         },\n+                { macAArch64VaListFactory.apply(b -> {})   },\n@@ -546,4 +563,5 @@\n-                { winVaListScopedFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },\n-                { sysvVaListScopedFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },\n-                { aarch64VaListScopedFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n-                { platformVaListScopedFactory, sumIntsNative,                        C_INT         },\n+                { winVaListScopedFactory,          sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },\n+                { sysvVaListScopedFactory,         sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },\n+                { linuxAArch64VaListScopedFactory, sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n+                { macAArch64VaListScopedFactory,   sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n+                { platformVaListScopedFactory,     sumIntsNative,                        C_INT         },\n@@ -594,3 +612,4 @@\n-                { winVaListFactory,      Win64.C_INT   },\n-                { sysvVaListFactory,     SysV.C_INT    },\n-                { aarch64VaListFactory,  AArch64.C_INT },\n+                { winVaListFactory,          Win64.C_INT   },\n+                { sysvVaListFactory,         SysV.C_INT    },\n+                { linuxAArch64VaListFactory, AArch64.C_INT },\n+                { macAArch64VaListFactory,   AArch64.C_INT },\n@@ -681,0 +700,11 @@\n+                { linkVaListCB(\"upcallBigStructPlusScalar\"), VaListConsumer.mh(vaList -> {\n+                    MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    assertEquals((long) VH_BigPoint_x.get(struct), 8);\n+                    assertEquals((long) VH_BigPoint_y.get(struct), 16);\n+\n+                    assertEquals(vaList.vargAsLong(C_LONG_LONG), 42);\n+                })},\n+                { linkVaListCB(\"upcallBigStructPlusScalar\"), VaListConsumer.mh(vaList -> {\n+                    vaList.skip(BigPoint_LAYOUT);\n+                    assertEquals(vaList.vargAsLong(C_LONG_LONG), 42);\n+                })},\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":82,"deletions":52,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -175,0 +175,7 @@\n+EXPORT void upcallBigStructPlusScalar(CB cb) {\n+    BigPoint point;\n+    point.x = 8;\n+    point.y = 16;\n+    passToUpcall(cb, 2, point, 42);\n+}\n+\n","filename":"test\/jdk\/java\/foreign\/valist\/libVaList.c","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,887 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InvalidClassException;\n+import java.io.ObjectInputFilter;\n+import java.io.ObjectInputFilter.Status;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.io.UncheckedIOException;\n+import java.util.ArrayDeque;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Predicate;\n+\n+import static java.io.ObjectInputFilter.Status.ALLOWED;\n+import static java.io.ObjectInputFilter.Status.REJECTED;\n+import static java.io.ObjectInputFilter.Status.UNDECIDED;\n+\n+\/* @test\n+ * @run testng\/othervm -Djdk.serialFilterTrace=true SerialFactoryExample\n+ * @run testng\/othervm -Djdk.serialFilterFactory=SerialFactoryExample$FilterInThread -Djdk.serialFilterTrace=true SerialFactoryExample\n+ * @summary Test SerialFactoryExample\n+ *\/\n+\n+\/*\n+ * Context-specific Deserialization Filter Example\n+ *\n+ * To protect deserialization of a thread or a call to an untrusted library function,\n+ * a filter is set that applies to every deserialization within the thread.\n+ *\n+ * The `doWithSerialFilter` method arguments are a serial filter and\n+ * a lambda to invoke with the filter in force.  Its implementation creates a stack of filters\n+ * using a `ThreadLocal`. The stack of filters is composed with the static JVM-wide filter,\n+ * and an optional stream-specific filter.\n+ *\n+ * The FilterInThread filter factory is set as the JVM-wide filter factory.\n+ * When the filter factory is invoked during the construction of each `ObjectInputStream`,\n+ * it retrieves the filter(s) from the thread local and combines it with the static JVM-wide filter,\n+ * and the stream-specific filter.\n+ *\n+ * If more than one filter is to be applied to the stream, two filters can be composed\n+ * using `ObjectInputFilter.merge`.  When invoked, each of the filters is invoked and the results\n+ * are combined such that if either filter rejects a class, the result is rejected.\n+ * If either filter allows the class, then it is allowed, otherwise it is undecided.\n+ * Hierarchies and chains of filters can be built using `ObjectInputFilter.merge`.\n+ *\n+ * The `doWithSerialFilter` calls can be nested. When nested, the filters are concatenated.\n+ *\/\n+@Test\n+public class SerialFactoryExample {\n+\n+    @DataProvider(name = \"Examples\")\n+    static Object[][] examples() {\n+        return new Object[][]{\n+                {new Point(1, 2), null,\n+                        ALLOWED},\n+                {new Point(1, 2), ObjectInputFilter.Config.createFilter(\"SerialFactoryExample$Point\"),\n+                        ALLOWED},\n+                {Integer.valueOf(10), Filters.allowPlatformClasses(),\n+                        ALLOWED},          \/\/ Integer is a platform class\n+                {new int[10], ObjectInputFilter.Config.createFilter(\"SerialFactoryExample$Point\"),\n+                        UNDECIDED},          \/\/ arrays of primitives are UNDECIDED -> allowed\n+                {int.class, ObjectInputFilter.Config.createFilter(\"SerialFactoryExample$Point\"),\n+                        UNDECIDED},          \/\/ primitive classes are UNDECIDED -> allowed\n+                {new Point[] {new Point(1, 1)}, ObjectInputFilter.Config.createFilter(\"SerialFactoryExample$Point\"),\n+                        ALLOWED},          \/\/ Arrays of allowed classes are allowed\n+                {new Integer[10], ObjectInputFilter.Config.createFilter(\"SerialFactoryExample$Point\"),\n+                        REJECTED},   \/\/ Base component type is checked -> REJECTED\n+                {new Point(1, 2), ObjectInputFilter.Config.createFilter(\"!SerialFactoryExample$Point\"),\n+                        REJECTED},   \/\/ Denied\n+                {new Point(1, 3), Filters.allowPlatformClasses(),\n+                        REJECTED},   \/\/ Not a platform class\n+                {new Point(1, 4), ObjectInputFilter.Config.createFilter(\"java.lang.Integer\"),\n+                        REJECTED},   \/\/ Only Integer is ALLOWED\n+                {new Point(1, 5), ObjectInputFilter.allowFilter(cl -> cl.getClassLoader() == ClassLoader.getPlatformClassLoader(), UNDECIDED),\n+                        REJECTED},   \/\/ Not platform loader is UNDECIDED -> a class that should not be undecided -> rejected\n+        };\n+    }\n+\n+\n+    @Test(dataProvider = \"Examples\")\n+    void examples(Serializable obj, ObjectInputFilter filter, Status expected) {\n+        \/\/ Establish FilterInThread as the application-wide filter factory\n+        FilterInThread filterInThread;\n+        if (ObjectInputFilter.Config.getSerialFilterFactory() instanceof FilterInThread fit) {\n+            \/\/ Filter factory selected on the command line with -Djdk.serialFilterFactory=<classname>\n+            filterInThread = fit;\n+        } else {\n+            \/\/ Create a FilterInThread filter factory and set\n+            \/\/ An IllegalStateException will be thrown if the filter factory was already\n+            \/\/ initialized to an incompatible filter factory.\n+            filterInThread = new FilterInThread();\n+            ObjectInputFilter.Config.setSerialFilterFactory(filterInThread);\n+        }\n+        try {\n+            filterInThread.doWithSerialFilter(filter, () -> {\n+                byte[] bytes = writeObject(obj);\n+                Object o = deserializeObject(bytes);\n+            });\n+            if (expected.equals(REJECTED))\n+                Assert.fail(\"IllegalClassException should have occurred\");\n+        } catch (UncheckedIOException uioe) {\n+            IOException ioe = uioe.getCause();\n+            Assert.assertEquals(ioe.getClass(), InvalidClassException.class, \"Wrong exception\");\n+            Assert.assertEquals(REJECTED, expected, \"Exception should not have occurred\");\n+        }\n+    }\n+\n+    \/**\n+     * Test various filters with various objects and the resulting status\n+     * @param obj an object\n+     * @param filter a filter\n+     * @param expected status\n+     *\/\n+    @Test(dataProvider = \"Examples\")\n+    void checkStatus(Serializable obj, ObjectInputFilter filter, Status expected) {\n+        \/\/ Establish FilterInThread as the application-wide filter factory\n+        FilterInThread filterInThread;\n+        if (ObjectInputFilter.Config.getSerialFilterFactory() instanceof FilterInThread fit) {\n+            \/\/ Filter factory selected on the command line with -Djdk.serialFilterFactory=<classname>\n+            filterInThread = fit;\n+        } else {\n+            \/\/ Create a FilterInThread filter factory and set\n+            \/\/ An IllegalStateException will be thrown if the filter factory was already\n+            \/\/ initialized to an incompatible filter factory.\n+            filterInThread = new FilterInThread();\n+            ObjectInputFilter.Config.setSerialFilterFactory(filterInThread);\n+        }\n+\n+        try {\n+            filterInThread.doWithSerialFilter(filter, () -> {\n+                \/\/ Classes are serialized as themselves, otherwise pass the object's class\n+                Class<?> clazz = (obj instanceof Class<?>) ? (Class<?>)obj : obj.getClass();\n+                ObjectInputFilter.FilterInfo info = new SerialInfo(clazz);\n+                var compositeFilter = filterInThread.apply(null, ObjectInputFilter.Config.getSerialFilter());\n+                System.out.println(\"    filter in effect: \" + filterInThread.currFilter);\n+                if (compositeFilter != null) {\n+                    Status actualStatus = compositeFilter.checkInput(info);\n+                    Assert.assertEquals(actualStatus, expected, \"Wrong Status\");\n+                }\n+            });\n+\n+        } catch (Exception ex) {\n+            Assert.fail(\"unexpected exception\", ex);\n+        }\n+    }\n+\n+    \/**\n+     * A Context-specific Deserialization Filter Factory to create filters that apply\n+     * a serial filter to all of the deserializations performed in a thread.\n+     * The purpose is to establish a deserialization filter that will reject all classes\n+     * that are not explicitly included.\n+     * <p>\n+     * The filter factory creates a composite filter of the stream-specific filter,\n+     * the thread-specific filter, the static JVM-wide filter, and a filter to reject all UNDECIDED cases.\n+     * The static JVM-wide filter is always included, if it is configured;\n+     * see ObjectInputFilter.Config.getSerialFilter().\n+     * <p>\n+     * To enable these protections the FilterInThread instance should be set as the\n+     * JVM-wide filter factory in ObjectInputFilter.Config.setSerialFilterFactory.\n+     *\n+     * The {@code doWithSerialFilter} is invoked with a serial filter and a lambda\n+     * to be invoked after the filter is applied.\n+     *\/\n+    public static final class FilterInThread\n+            implements BinaryOperator<ObjectInputFilter> {\n+\n+        \/\/ ThreadLocal holding the Deque of serial filters to be applied, not null\n+        private final ThreadLocal<ArrayDeque<ObjectInputFilter>> filterThreadLocal =\n+                ThreadLocal.withInitial(() -> new ArrayDeque<>());\n+\n+        private ObjectInputFilter currFilter;\n+\n+        \/**\n+         * Construct a FilterInThread deserialization filter factory.\n+         * The constructor is public so FilterInThread can be set on the command line\n+         * with {@code -Djdk.serialFilterFactory=SerialFactoryExample$FilterInThread}.\n+         *\/\n+        public FilterInThread() {\n+        }\n+\n+        \/**\n+         * Applies the filter to the thread and invokes the runnable.\n+         * The filter is pushed to a ThreadLocal, saving the old value.\n+         * If there was a previous thread filter, the new filter is appended\n+         * and made the active filter.\n+         * The runnable is invoked.\n+         * The previous filter is restored to the ThreadLocal.\n+         *\n+         * @param filter the serial filter to apply\n+         * @param runnable a runnable to invoke\n+         *\/\n+        public void doWithSerialFilter(ObjectInputFilter filter, Runnable runnable) {\n+            var prevFilters = filterThreadLocal.get();\n+            try {\n+                if (filter != null)\n+                    prevFilters.addLast(filter);\n+                runnable.run();\n+            } finally {\n+                if (filter != null) {\n+                    var lastFilter = prevFilters.removeLast();\n+                    assert lastFilter == filter : \"Filter removed out of order\";\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * Returns a composite filter of the stream-specific filter, the thread-specific filter,\n+         * the static JVM-wide filter, and a filter to reject all UNDECIDED cases.\n+         * The purpose is to establish a deserialization filter that will reject all classes\n+         * that are not explicitly included.\n+         * The static JVM-wide filter is always checked, if it is configured;\n+         * see ObjectInputFilter.Config.getSerialFilter().\n+         * Any or all of the filters are optional and if not supplied or configured are null.\n+         * <p>\n+         * This method is first called from the constructor with current == null and\n+         * next == static JVM-wide filter.\n+         * The filter returned is the static JVM-wide filter merged with the thread-specific filter\n+         * and followed by a filter to map all UNDECIDED status values to REJECTED.\n+         * This last step ensures that the collective group of filters covers every possible case,\n+         * any classes that are not ALLOWED will be REJECTED.\n+         * <p>\n+         * The method may be called a second time from {@code ObjectInputStream.setObjectInputFilter(next)}\n+         * to add a stream-specific filter.  The stream-specific filter is prepended to the\n+         * composite filter created above when called from the constructor.\n+         * <p>\n+         *\n+         * @param curr the current filter, may be null\n+         * @param next the next filter, may be null\n+         * @return a deserialization filter to use for the stream, may be null\n+         *\/\n+        public ObjectInputFilter apply(ObjectInputFilter curr, ObjectInputFilter next) {\n+            if (curr == null) {\n+                \/\/ Called from the OIS constructor or perhaps OIS.setObjectInputFilter with no current filter\n+                \/\/ no current filter, prepend next to threadFilter, both may be null or non-null\n+\n+                \/\/ Assemble the filters in sequence, most recently added first\n+                var filters = filterThreadLocal.get();\n+                ObjectInputFilter filter = null;\n+                for (ObjectInputFilter f : filters) {\n+                    filter = ObjectInputFilter.merge(f, filter);\n+                }\n+                if (next != null) {\n+                    \/\/ Prepend a filter to reject all UNDECIDED results\n+                    if (filter != null) {\n+                        filter = ObjectInputFilter.rejectUndecidedClass(filter);\n+                    }\n+\n+                    \/\/ Prepend the next filter to the thread filter, if any\n+                    \/\/ Initially this would be the static JVM-wide filter passed from the OIS constructor\n+                    \/\/ The static JVM-wide filter allow, reject, or leave classes undecided\n+                    filter = ObjectInputFilter.merge(next, filter);\n+                }\n+                \/\/ Check that the static JVM-wide filter did not leave any classes undecided\n+                if (filter != null) {\n+                    \/\/ Append the filter to reject all UNDECIDED results\n+                    filter = ObjectInputFilter.rejectUndecidedClass(filter);\n+                }\n+                \/\/ Return the filter, unless a stream-specific filter is set later\n+                \/\/ The filter may be null if no filters are configured\n+                currFilter = filter;\n+                return currFilter;\n+            } else {\n+                \/\/ Called from OIS.setObjectInputFilter with a previously set filter.\n+                \/\/ The curr filter already incorporates the thread filter and rejection of undecided status\n+                \/\/ Prepend the stream-specific filter or the current filter if no stream-specific filter\n+                currFilter = (next == null) ? curr : ObjectInputFilter.rejectUndecidedClass(ObjectInputFilter.merge(next, curr));\n+                return currFilter;\n+            }\n+        }\n+\n+        public String toString() {\n+            return Objects.toString(currFilter, \"none\");\n+        }\n+    }\n+\n+\n+    \/**\n+     * Simple example code from the ObjectInputFilter Class javadoc.\n+     *\/\n+    public static final class SimpleFilterInThread implements BinaryOperator<ObjectInputFilter> {\n+\n+        \/\/ ThreadLocal to hold the serial filter to be applied\n+        private final ThreadLocal<ObjectInputFilter> filterThreadLocal = new ThreadLocal<>();\n+\n+        \/\/ Construct a FilterInThread deserialization filter factory.\n+        public SimpleFilterInThread() {}\n+\n+        \/**\n+         * The filter factory, which is invoked every time a new ObjectInputStream\n+         * is created.  If a per-stream filter is already set then it returns a\n+         * filter that combines the results of invoking each filter.\n+         *\n+         * @param curr the current filter on the stream\n+         * @param next a per stream filter\n+         * @return the selected filter\n+         *\/\n+        public ObjectInputFilter apply(ObjectInputFilter curr, ObjectInputFilter next) {\n+            if (curr == null) {\n+                \/\/ Called from the OIS constructor or perhaps OIS.setObjectInputFilter with no current filter\n+                var filter = filterThreadLocal.get();\n+                if (filter != null) {\n+                    \/\/ Prepend a filter to reject all UNDECIDED results\n+                    filter = ObjectInputFilter.rejectUndecidedClass(filter);\n+                }\n+                if (next != null) {\n+                    \/\/ Prepend the next filter to the thread filter, if any\n+                    \/\/ Initially this is the static JVM-wide filter passed from the OIS constructor\n+                    \/\/ Append the filter to reject all UNDECIDED results\n+                    filter = ObjectInputFilter.merge(next, filter);\n+                    filter = ObjectInputFilter.rejectUndecidedClass(filter);\n+                }\n+                return filter;\n+            } else {\n+                \/\/ Called from OIS.setObjectInputFilter with a current filter and a stream-specific filter.\n+                \/\/ The curr filter already incorporates the thread filter and static JVM-wide filter\n+                \/\/ and rejection of undecided classes\n+                \/\/ If there is a stream-specific filter prepend it and a filter to recheck for undecided\n+                if (next != null) {\n+                    next = ObjectInputFilter.merge(next, curr);\n+                    next = ObjectInputFilter.rejectUndecidedClass(next);\n+                    return next;\n+                }\n+                return curr;\n+            }\n+        }\n+\n+        \/**\n+         * Applies the filter to the thread and invokes the runnable.\n+         *\n+         * @param filter the serial filter to apply to every deserialization in the thread\n+         * @param runnable a Runnable to invoke\n+         *\/\n+        public void doWithSerialFilter(ObjectInputFilter filter, Runnable runnable) {\n+            var prevFilter = filterThreadLocal.get();\n+            try {\n+                filterThreadLocal.set(filter);\n+                runnable.run();\n+            } finally {\n+                filterThreadLocal.set(prevFilter);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Write an object and return a byte array with the bytes.\n+     *\n+     * @param object object to serialize\n+     * @return the byte array of the serialized object\n+     * @throws UncheckedIOException if an exception occurs\n+     *\/\n+    private static byte[] writeObject(Object object) {\n+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+             ObjectOutputStream oos = new ObjectOutputStream(baos)) {\n+            oos.writeObject(object);\n+            return baos.toByteArray();\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n+        }\n+    }\n+\n+    \/**\n+     * Deserialize an object.\n+     *\n+     * @param bytes an object.\n+     * @throws UncheckedIOException for I\/O exceptions and ClassNotFoundException\n+     *\/\n+    private static Object deserializeObject(byte[] bytes) {\n+        try {\n+            InputStream is = new ByteArrayInputStream(bytes);\n+            ObjectInputStream ois = new ObjectInputStream(is);\n+            System.out.println(\"  filter in effect: \" + ois.getObjectInputFilter());\n+            return ois.readObject();\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n+        } catch (ClassNotFoundException cnfe) {\n+            throw new UncheckedIOException(new InvalidClassException(cnfe.getMessage()));\n+        }\n+    }\n+\n+\n+    \/**\n+     * ObjectInputFilter utilities to create filters that combine the results of other filters.\n+     *\/\n+    public static final class Filters {\n+        \/**\n+         * Returns a filter that returns {@code Status.ALLOWED} if the predicate\n+         * on the class is {@code true}.\n+         * The filter returns {@code ALLOWED} or the {@code otherStatus} based on the predicate\n+         * of the {@code non-null} class and {@code UNDECIDED} if the class is {@code null}.\n+         *\n+         * <p>When the filter's {@link ObjectInputFilter#checkInput checkInput(info)} method is invoked,\n+         * the predicate is applied to the {@link ObjectInputFilter.FilterInfo#serialClass() info.serialClass()},\n+         * the return Status is:\n+         * <ul>\n+         *     <li>{@link Status#UNDECIDED UNDECIDED}, if the {@code serialClass} is {@code null},<\/li>\n+         *     <li>{@link Status#ALLOWED ALLOWED}, if the predicate on the class returns {@code true},<\/li>\n+         *     <li>Otherwise, return {@code otherStatus}.<\/li>\n+         * <\/ul>\n+         * <p>\n+         * Example, to create a filter that will allow any class loaded from the platform classloader.\n+         * <pre><code>\n+         *     ObjectInputFilter f = allowFilter(cl -> cl.getClassLoader() == ClassLoader.getPlatformClassLoader()\n+         *                                          || cl.getClassLoader() == null, Status.UNDECIDED);\n+         * <\/code><\/pre>\n+         *\n+         * @param predicate a predicate to test a non-null Class, non-null\n+         * @param otherStatus a Status to use if the predicate is {@code false}\n+         * @return a filter than returns {@code ALLOWED} if the predicate on the class returns {@code true},\n+         *          otherwise the {@code otherStatus}\n+         * @since 17\n+         *\/\n+        public static ObjectInputFilter allowFilter(Predicate<Class<?>> predicate, Status otherStatus) {\n+            Objects.requireNonNull(predicate, \"predicate\");\n+            Objects.requireNonNull(otherStatus, \"otherStatus\");\n+            return new PredicateFilter(predicate, ALLOWED, otherStatus);\n+        }\n+\n+        \/**\n+         * Returns a filter that returns {@code Status.REJECTED} if the predicate\n+         * on the class is {@code true}.\n+         * The filter returns {@code ALLOWED} or the {@code otherStatus} based on the predicate\n+         * of the {@code non-null} class and {@code UNDECIDED} if the class is {@code null}.\n+         *\n+         * When the filter's {@link ObjectInputFilter#checkInput checkInput(info)} method is invoked,\n+         * the predicate is applied to the {@link ObjectInputFilter.FilterInfo#serialClass() serialClass()},\n+         * the return Status is:\n+         * <ul>\n+         *     <li>{@link Status#UNDECIDED UNDECIDED}, if the {@code serialClass} is {@code null},<\/li>\n+         *     <li>{@link Status#REJECTED REJECTED}, if the predicate on the class returns {@code true},<\/li>\n+         *     <li>Otherwise, return {@code otherStatus}.<\/li>\n+         * <\/ul>\n+         * <p>\n+         * Example, to create a filter that will reject any class loaded from the application classloader.\n+         * <pre><code>\n+         *     ObjectInputFilter f = rejectFilter(cl ->\n+         *          cl.getClassLoader() == ClassLoader.ClassLoader.getSystemClassLoader(), Status.UNDECIDED);\n+         * <\/code><\/pre>\n+         *\n+         * @param predicate a predicate to test a non-null Class, non-null\n+         * @param otherStatus a Status to use if the predicate is {@code false}\n+         * @return returns a filter that returns {@link Status#REJECTED REJECTED} if the predicate on the class\n+         *          returns {@code true}, otherwise {@link Status#UNDECIDED UNDECIDED}\n+         * @since 17\n+         *\/\n+        public static ObjectInputFilter rejectFilter(Predicate<Class<?>> predicate, Status otherStatus) {\n+            Objects.requireNonNull(predicate, \"predicate\");\n+            Objects.requireNonNull(otherStatus, \"otherStatus\");\n+            return new PredicateFilter(predicate, REJECTED, otherStatus);\n+        }\n+\n+        \/**\n+         * Returns a filter that returns {@code Status.ALLOWED} if the check is for limits\n+         * and not checking a class; otherwise {@code Status.UNDECIDED}.\n+         * If the {@link ObjectInputFilter.FilterInfo#serialClass() serialClass()} is {@code null}, the filter returns\n+         * {@code Status.ALLOWED}, otherwise return {@code Status.UNDECIDED}.\n+         * The limit values of {@link ObjectInputFilter.FilterInfo#arrayLength() arrayLength()},\n+         * {@link ObjectInputFilter.FilterInfo#depth() depth()}, {@link ObjectInputFilter.FilterInfo#references() references()},\n+         * and {@link ObjectInputFilter.FilterInfo#streamBytes() streamBytes()} are not checked.\n+         * To place a limit, create a separate filter with limits such as:\n+         * <pre>{@code\n+         * Config.createFilter(\"maxarray=10000,maxdepth=40\");\n+         * }<\/pre>\n+         *\n+         * When the filter's {@link ObjectInputFilter#checkInput} method is invoked,\n+         * the Status returned is:\n+         * <ul>\n+         *     <li>{@link Status#ALLOWED ALLOWED}, if the {@code serialClass} is {@code null},<\/li>\n+         *     <li>Otherwise, return {@link Status#UNDECIDED UNDECIDED}<\/li>\n+         * <\/ul>\n+         *\n+         * @return a filter that returns {@code Status.ALLOWED} if the check is for limits\n+         *          and not checking a class; otherwise {@code Status.UNDECIDED}\n+         * @since 17\n+         *\/\n+        public static ObjectInputFilter allowMaxLimits() {\n+            return new AllowMaxLimitsFilter(ALLOWED, UNDECIDED);\n+        }\n+\n+        \/**\n+         * Returns a filter that merges the status of a filter and another filter.\n+         * If the other filter is {@code null}, the filter is returned.\n+         * Otherwise, a filter is returned to merge the pair of {@code non-null} filters.\n+         *\n+         * The filter returned implements the {@link ObjectInputFilter#checkInput(ObjectInputFilter.FilterInfo)} method\n+         * as follows:\n+         * <ul>\n+         *     <li>Invoke {@code filter} on the {@code FilterInfo} to get its {@code status};\n+         *     <li>Return {@code REJECTED} if the {@code status} is {@code REJECTED};\n+         *     <li>Invoke the {@code otherFilter} to get the {@code otherStatus};\n+         *     <li>Return {@code REJECTED} if the {@code otherStatus} is {@code REJECTED};\n+         *     <li>Return {@code ALLOWED}, if either {@code status} or {@code otherStatus}\n+         *          is {@code ALLOWED}, <\/li>\n+         *     <li>Otherwise, return {@code UNDECIDED}<\/li>\n+         * <\/ul>\n+         *\n+         * @param filter a filter, non-null\n+         * @param anotherFilter a filter to be merged with the filter, may be {@code null}\n+         * @return an {@link ObjectInputFilter} that merges the status of the filter and another filter\n+         * @since 17\n+         *\/\n+        public static ObjectInputFilter merge(ObjectInputFilter filter, ObjectInputFilter anotherFilter) {\n+            Objects.requireNonNull(filter, \"filter\");\n+            return (anotherFilter == null) ? filter : new MergeFilter(filter, anotherFilter);\n+        }\n+\n+        \/**\n+         * Returns a filter that invokes a filter and maps {@code UNDECIDED} to {@code REJECTED}\n+         * for classes, with some exceptions, and otherwise returns the status.\n+         * The filter returned checks that classes not {@code ALLOWED} and not {@code REJECTED} by the filter\n+         * are {@code REJECTED}, if the class is an array and the base component type is not allowed,\n+         * otherwise the result is {@code UNDECIDED}.\n+         *\n+         * <p>\n+         * Object deserialization accepts a class if the filter returns {@code UNDECIDED}.\n+         * Adding a filter to reject undecided results for classes that have not been\n+         * either allowed or rejected can prevent classes from slipping through the filter.\n+         *\n+         * @implSpec\n+         * The filter returned implements the {@link ObjectInputFilter#checkInput(ObjectInputFilter.FilterInfo)} method\n+         * as follows:\n+         * <ul>\n+         *     <li>Invoke the filter on the {@code FilterInfo} to get its {@code status};\n+         *     <li>Return the {@code status} if the status is {@code REJECTED} or {@code ALLOWED};\n+         *     <li>Return {@code UNDECIDED} if the {@code filterInfo.getSerialClass() serialClass}\n+         *          is {@code null};\n+         *     <li>Determine the base component type if the {@code serialClass} is\n+         *          an {@linkplain Class#isArray() array};\n+         *     <li>Return {@code UNDECIDED} if the base component type is\n+         *          a {@linkplain Class#isPrimitive() primitive class};\n+         *     <li>Invoke the filter on the {@code base component type} to get its\n+         *          {@code component status};<\/li>\n+         *     <li>Return {@code ALLOWED} if the component status is {@code ALLOWED};\n+         *     <li>Otherwise, return {@code REJECTED}.<\/li>\n+         * <\/ul>\n+         *\n+         * @param filter a filter, non-null\n+         * @return an {@link ObjectInputFilter} that maps an {@link Status#UNDECIDED}\n+         *      status to {@link Status#REJECTED} for classes, otherwise returns the\n+         *      filter status\n+         * @since 17\n+         *\/\n+        public static ObjectInputFilter rejectUndecidedClass(ObjectInputFilter filter) {\n+            Objects.requireNonNull(filter, \"filter\");\n+            return new RejectUndecidedFilter(filter);\n+        }\n+\n+        \/**\n+         * Returns a filter that allows a class only if the class was loaded by the platform class loader.\n+         * Otherwise, it returns UNDECIDED; leaving the choice to another filter.\n+         * @return a filter that allows a class only if the class was loaded by the platform class loader\n+         *\/\n+        public static ObjectInputFilter allowPlatformClasses() {\n+            return new AllowPlatformClassFilter();\n+        }\n+\n+        \/**\n+         * An ObjectInputFilter to evaluate a predicate mapping a class to a boolean.\n+         *\/\n+        private static class PredicateFilter implements ObjectInputFilter {\n+            private final Predicate<Class<?>> predicate;\n+            private final Status ifTrueStatus;\n+            private final Status ifFalseStatus;\n+\n+            PredicateFilter(Predicate<Class<?>> predicate, Status ifTrueStatus, Status ifFalseStatus) {\n+                this.predicate = predicate;\n+                this.ifTrueStatus = ifTrueStatus;\n+                this.ifFalseStatus = ifFalseStatus;\n+            }\n+\n+            \/**\n+             * Apply the predicate to the class being deserialized, if the class is non-null\n+             * and if it returns {@code true}, return the requested status. Otherwise, return UNDECIDED.\n+             *\n+             * @param info the FilterInfo\n+             * @return the status of applying the predicate, otherwise {@code UNDECIDED}\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                Class<?> clazz = info.serialClass();\n+                return (clazz != null && predicate.test(clazz)) ? ifTrueStatus : ifFalseStatus;\n+            }\n+\n+            public String toString() {\n+                return \"predicate(\" + predicate + \")\";\n+            }\n+        }\n+\n+        \/**\n+         * An ObjectInputFilter to evaluate if a FilterInfo is checking only limits,\n+         * and not classes.\n+         *\/\n+        private static class AllowMaxLimitsFilter implements ObjectInputFilter {\n+            private final Status limitCheck;\n+            private final Status classCheck;\n+\n+            AllowMaxLimitsFilter(Status limitCheck, Status classCheck) {\n+                this.limitCheck = limitCheck;\n+                this.classCheck = classCheck;\n+            }\n+\n+            \/**\n+             * If the FilterInfo is only checking a limit, return the requested\n+             * status, otherwise the other status.\n+             *\n+             * @param info the FilterInfo\n+             * @return the status of corresponding to serialClass == null or not\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                return (info.serialClass() == null) ? limitCheck : classCheck;\n+            }\n+\n+            public String toString() {\n+                return \"allowMaxLimits()\";\n+            }\n+        }\n+\n+        \/**\n+         * An ObjectInputFilter that merges the status of two filters.\n+         *\/\n+        private static class MergeFilter implements ObjectInputFilter {\n+            private final ObjectInputFilter first;\n+            private final ObjectInputFilter second;\n+\n+            MergeFilter(ObjectInputFilter first, ObjectInputFilter second) {\n+                this.first = first;\n+                this.second = second;\n+            }\n+\n+            \/**\n+             * Returns REJECTED if either of the filters returns REJECTED,\n+             * and ALLOWED if either of the filters returns ALLOWED.\n+             * Returns {@code UNDECIDED} if either filter returns {@code UNDECIDED}.\n+             *\n+             * @param info the FilterInfo\n+             * @return Status.REJECTED if either of the filters returns REJECTED,\n+             * and ALLOWED if either filter returns ALLOWED; otherwise returns\n+             * {@code UNDECIDED} if both filters returned {@code UNDECIDED}\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                Status firstStatus = Objects.requireNonNull(first.checkInput(info), \"status\");\n+                if (REJECTED.equals(firstStatus)) {\n+                    return REJECTED;\n+                }\n+                Status secondStatus = Objects.requireNonNull(second.checkInput(info), \"other status\");\n+                if (REJECTED.equals(secondStatus)) {\n+                    return REJECTED;\n+                }\n+                if (ALLOWED.equals(firstStatus) || ALLOWED.equals(secondStatus)) {\n+                    return ALLOWED;\n+                }\n+                return UNDECIDED;\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return \"merge(\" + first + \", \" + second + \")\";\n+            }\n+        }\n+\n+        \/**\n+         * A filter that maps the status {@code UNDECIDED} to {@code REJECTED} when checking a class.\n+         *\/\n+        private static class RejectUndecidedFilter implements ObjectInputFilter {\n+            private final ObjectInputFilter filter;\n+\n+            private RejectUndecidedFilter(ObjectInputFilter filter) {\n+                this.filter = Objects.requireNonNull(filter, \"filter\");\n+            }\n+\n+            \/**\n+             * Apply the filter and return the status if not UNDECIDED and checking a class.\n+             * For array classes, re-check the final component type against the filter.\n+             * Make an exception for Primitive classes that are implicitly allowed by the pattern based filter.\n+             * @param info the FilterInfo\n+             * @return the status of applying the filter and checking the class\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                Status status = Objects.requireNonNull(filter.checkInput(info), \"status\");\n+                Class<?> clazz = info.serialClass();\n+                if (clazz == null || !UNDECIDED.equals(status))\n+                    return status;\n+                status = REJECTED;\n+                \/\/ Find the base component type\n+                while (clazz.isArray()) {\n+                    clazz = clazz.getComponentType();\n+                }\n+                if (clazz.isPrimitive()) {\n+                    status = UNDECIDED;\n+                } else {\n+                    \/\/ for non-primitive types;  re-filter the base component type\n+                    FilterInfo clazzInfo = new SerialInfo(info, clazz);\n+                    Status clazzStatus = filter.checkInput(clazzInfo);\n+                    status = (ALLOWED.equals(clazzStatus)) ? ALLOWED : REJECTED;\n+                }\n+                return status;\n+            }\n+\n+            public String toString() {\n+                return \"rejectUndecidedClass(\" + filter + \")\";\n+            }\n+\n+            \/**\n+             * FilterInfo instance with a specific class and delegating to an existing FilterInfo.\n+             * Nested in the rejectUndecided class.\n+             *\/\n+            static class SerialInfo implements ObjectInputFilter.FilterInfo {\n+                private final FilterInfo base;\n+                private final Class<?> clazz;\n+\n+                SerialInfo(FilterInfo base, Class<?> clazz) {\n+                    this.base = base;\n+                    this.clazz = clazz;\n+                }\n+\n+                @Override\n+                public Class<?> serialClass() {\n+                    return clazz;\n+                }\n+\n+                @Override\n+                public long arrayLength() {\n+                    return base.arrayLength();\n+                }\n+\n+                @Override\n+                public long depth() {\n+                    return base.depth();\n+                }\n+\n+                @Override\n+                public long references() {\n+                    return base.references();\n+                }\n+\n+                @Override\n+                public long streamBytes() {\n+                    return base.streamBytes();\n+                }\n+            }\n+\n+        }\n+\n+        \/**\n+         * An ObjectInputFilter that merges the results of two filters.\n+         *\/\n+        private static class MergeManyFilter implements ObjectInputFilter {\n+            private final List<ObjectInputFilter> filters;\n+            private final Status otherStatus;\n+\n+            MergeManyFilter(List<ObjectInputFilter> first, Status otherStatus) {\n+                this.filters = Objects.requireNonNull(first, \"filters\");\n+                this.otherStatus = Objects.requireNonNull(otherStatus, \"otherStatus\");\n+            }\n+\n+            \/**\n+             * Returns REJECTED if any of the filters returns REJECTED,\n+             * and ALLOWED if any of the filters returns ALLOWED.\n+             * Returns UNDECIDED if there is no class to be checked or all filters return UNDECIDED.\n+             *\n+             * @param info the FilterInfo\n+             * @return Status.UNDECIDED if there is no class to check,\n+             *      Status.REJECTED if any of the filters returns REJECTED,\n+             *      Status.ALLOWED if any filter returns ALLOWED;\n+             *      otherwise returns {@code otherStatus}\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo info) {\n+                if (info.serialClass() == null)\n+                    return UNDECIDED;\n+                Status status = otherStatus;\n+                for (ObjectInputFilter filter : filters) {\n+                    Status aStatus = filter.checkInput(info);\n+                    if (REJECTED.equals(aStatus)) {\n+                        return REJECTED;\n+                    }\n+                    if (ALLOWED.equals(aStatus)) {\n+                        status = ALLOWED;\n+                    }\n+                }\n+                return status;\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return \"mergeManyFilter(\" + filters + \")\";\n+            }\n+        }\n+\n+        \/**\n+         * An ObjectInputFilter that allows a class only if the class was loaded by the platform class loader.\n+         * Otherwise, it returns undecided; leaving the choice to another filter.\n+         *\/\n+        private static class AllowPlatformClassFilter implements ObjectInputFilter {\n+\n+            \/**\n+             * Returns ALLOWED only if the class, if non-null, was loaded by the platformClassLoader.\n+             *\n+             * @param filter the FilterInfo\n+             * @return Status.ALLOWED only if the class loader of the class was the PlatformClassLoader;\n+             * otherwise Status.UNDECIDED\n+             *\/\n+            public ObjectInputFilter.Status checkInput(FilterInfo filter) {\n+                final Class<?> serialClass = filter.serialClass();\n+                return (serialClass != null &&\n+                        (serialClass.getClassLoader() == null ||\n+                        ClassLoader.getPlatformClassLoader().equals(serialClass.getClassLoader())))\n+                        ? ObjectInputFilter.Status.ALLOWED\n+                        : ObjectInputFilter.Status.UNDECIDED;\n+            }\n+\n+            public String toString() {\n+                return \"allowPlatformClasses\";\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * FilterInfo instance with a specific class.\n+     *\/\n+    static class SerialInfo implements ObjectInputFilter.FilterInfo {\n+        private final Class<?> clazz;\n+\n+        SerialInfo(Class<?> clazz) {\n+            this.clazz = clazz;\n+        }\n+\n+        @Override\n+        public Class<?> serialClass() {\n+            return clazz;\n+        }\n+\n+        @Override\n+        public long arrayLength() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long depth() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long references() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long streamBytes() {\n+            return 0;\n+        }\n+    }\n+\n+    \/**\n+     * A test class.\n+     *\/\n+    static record Point(int x, int y) implements Serializable {\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFactoryExample.java","additions":887,"deletions":0,"binary":false,"changes":887,"status":"added"},{"patch":"@@ -0,0 +1,411 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputFilter;\n+import java.io.ObjectInputFilter.Config;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serial;\n+import java.io.Serializable;\n+import java.io.SerializablePermission;\n+import java.security.AccessControlException;\n+import java.security.Permission;\n+import java.util.function.BinaryOperator;\n+\n+\/* @test\n+ * @build SerialFilterFactoryTest\n+ * @run testng\/othervm  SerialFilterFactoryTest\n+ * @run testng\/othervm -Djdk.serialFilter=\"*\" -Djdk.serialFilterFactory=OVERRIDE SerialFilterFactoryTest\n+ * @run testng\/othervm -Djdk.serialFilterFactory=SerialFilterFactoryTest$PropertyFilterFactory SerialFilterFactoryTest\n+ * @run testng\/othervm -Djdk.serialFilterFactory=SerialFilterFactoryTest$NotMyFilterFactory SerialFilterFactoryTest\n+ * @run testng\/othervm\/policy=security.policy\n+ *        -Djava.security.properties=${test.src}\/java.security-extra-factory\n+ *        -Djava.security.debug=properties SerialFilterFactoryTest\n+ * @run testng\/othervm\/fail  -Djdk.serialFilterFactory=ForcedError_NoSuchClass SerialFilterFactoryTest\n+ * @run testng\/othervm\/policy=security.policy SerialFilterFactoryTest\n+ * @run testng\/othervm\/policy=security.policy.without.globalFilter SerialFilterFactoryTest\n+\n+ *\n+ * @summary Test Context-specific Deserialization Filters\n+ *\/\n+@Test\n+public class SerialFilterFactoryTest {\n+\n+    \/\/ A stream with just the header, enough to create a OIS\n+    private static final byte[] simpleStream = simpleStream();\n+    private static final Validator v1 = new Validator(\"v1\");\n+    private static final Validator v2 = new Validator(\"v2\");\n+    private static final BinaryOperator<ObjectInputFilter> jdkSerialFilterFactory\n+            = Config.getSerialFilterFactory();\n+    private static final MyFilterFactory contextFilterFactory = new MyFilterFactory(\"DynFF\");\n+    private static final String jdkSerialFilterFactoryProp = System.getProperty(\"jdk.serialFilterFactory\");\n+\n+    \/**\n+     * Return a byte array with a simple stream containing an Dummy object.\n+     * @return  a byte with a simple serialization object\n+     *\/\n+    private static byte[] simpleStream() {\n+        ByteArrayOutputStream boas = new ByteArrayOutputStream();\n+        try (ObjectOutputStream ois = new ObjectOutputStream(boas)) {\n+            ois.writeObject(new Dummy(\"Here\"));\n+            return boas.toByteArray();\n+        } catch (IOException ioe) {\n+            Assert.fail(\"unexpected IOE\", ioe);\n+        }\n+        throw new RuntimeException(\"should not reach here\");\n+    }\n+\n+    \/**\n+     * Initialize the filter factory, supplying one if not already set.\n+     * Does not\/can not replace any MyFilterFactory.\n+     *\n+     * @param dynFilterFactory a filter factory to use if not already set\n+     * @return the filter factory in effect\n+     *\/\n+    private static MyFilterFactory setupFilterFactory(MyFilterFactory dynFilterFactory) {\n+        if ((Config.getSerialFilterFactory() instanceof MyFilterFactory ff))\n+            return ff;\n+        Config.setSerialFilterFactory(dynFilterFactory);\n+        return dynFilterFactory;\n+    }\n+\n+    \/\/ If the configured filter has not been set, set it\n+    \/\/ It can only be set once for the process, so avoid setting it again\n+    private static ObjectInputFilter setupFilter(ObjectInputFilter serialFilter) {\n+\n+        var configFilter = Config.getSerialFilter();\n+        if (configFilter == serialFilter || configFilter instanceof Validator)\n+            return configFilter;        \/\/ if already set or a type we can use, no change\n+\n+        if (configFilter == null) {\n+            Config.setSerialFilter(serialFilter);\n+            return serialFilter;        \/\/ none set already, set it\n+        }\n+\n+        return configFilter;\n+    }\n+\n+    private static boolean isValidFilterFactory() {\n+        return !(ObjectInputFilter.Config.getSerialFilterFactory() instanceof NotMyFilterFactory);\n+    }\n+\n+    \/**\n+     * Returns true if serialFilter actions are ok, either no SM or SM has serialFilter Permission\n+     *\/\n+    private static boolean hasFilterPerm() {\n+        boolean hasSerialPerm = true;\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            try {\n+                Permission p = new SerializablePermission(\"serialFilter\");\n+                sm.checkPermission(p);\n+                hasSerialPerm = true;\n+            } catch (AccessControlException ace2) {\n+                hasSerialPerm = false;      \/\/ SM and serialFilter not allowed\n+            }\n+        }\n+        return hasSerialPerm;\n+    }\n+\n+    @DataProvider(name=\"FilterCases\")\n+    static Object[][] filterCases() {\n+        if (isValidFilterFactory()) {\n+            return new Object[][]{\n+                    {contextFilterFactory, null, null},  \/\/ no overrides\n+                    {contextFilterFactory, v1, null},    \/\/ context filter\n+                    {contextFilterFactory, v1, v2},      \/\/ per stream filter\n+            };\n+        } else {\n+            \/\/ There are zero cases to run with an unknown filter factory. (NotMyFilterFactory)\n+            return new Object[0][0];\n+        }\n+    }\n+\n+    \/\/ Setting the filter factory to null is not allowed.\n+    @Test(expectedExceptions=NullPointerException.class)\n+    void testNull() {\n+        Config.setSerialFilterFactory(null);\n+    }\n+\n+    \/**\n+     * Setting and resetting the filter factory is not allowed.\n+     * The filter factory may have been on the command line (depending on which @run this is).\n+     * If the jdk.SerialFilterFactory is the built-in filter factory, set it once.\n+     * Try to set it again, the second should throw.\n+     *\/\n+    @Test\n+    void testSecondSetShouldThrow() {\n+        if (System.getSecurityManager() != null) {\n+            \/\/ Skip test when running with SM\n+            return;\n+        }\n+        var currFF = Config.getSerialFilterFactory();\n+        if (currFF.getClass().getClassLoader() == null) {\n+            try {\n+                \/\/ Not already set, set it\n+                Config.setSerialFilterFactory(contextFilterFactory);\n+                currFF = contextFilterFactory;\n+            } catch (IllegalStateException ise) {\n+                Assert.fail(\"First setSerialFilterFactory should not throw\");\n+            }\n+        }\n+        \/\/ Setting it again will throw\n+        Assert.expectThrows(IllegalStateException.class,\n+                () -> Config.setSerialFilterFactory(new MyFilterFactory(\"f11\")));\n+        var resetFF = Config.getSerialFilterFactory();\n+        Assert.assertEquals(resetFF, currFF, \"Setting again should not change filter factory\");\n+    }\n+\n+    \/**\n+     * Test that the filter factory is set when expected and is called when expected.\n+     * This test only covers the cases when a filter factory is supplied\n+     * either via a command line property or via the API.\n+     * The cases where the builtin filter factory applies are tested in SerialFilterTest.\n+     *\n+     * @param dynFilterFactory a FilterFactory to set\n+     * @param dynFilter a serial filter to be used for the configured filter\n+     * @param streamFilter a serial filter to be used for the stream filter\n+     * @throws IOException if an I\/O error occurs (should not occur)\n+     * @throws ClassNotFoundException for class not found (should not occur)\n+     *\/\n+    @Test(dataProvider=\"FilterCases\")\n+    void testCase(MyFilterFactory dynFilterFactory, Validator dynFilter, Validator streamFilter)\n+                throws IOException, ClassNotFoundException {\n+\n+        \/\/ Set the Filter Factory and System-wide filter\n+        ObjectInputFilter configFilter;\n+        MyFilterFactory factory;\n+        try {\n+            configFilter = setupFilter(dynFilter);\n+            factory = setupFilterFactory(dynFilterFactory);\n+            Assert.assertTrue(hasFilterPerm(),\n+                    \"setSerialFilterFactory and setFilterFactory succeeded without serialFilter permission\");\n+        } catch (AccessControlException ace) {\n+            Assert.assertFalse(hasFilterPerm(),\n+                    \"setSerialFilterFactory failed even with serialFilter permission\");\n+            return;         \/\/ test complete\n+        }\n+        factory.reset();\n+\n+        InputStream is = new ByteArrayInputStream(simpleStream);\n+        ObjectInputStream ois = new ObjectInputStream(is);\n+\n+        Assert.assertNull(factory.current(), \"initially current should be null\");\n+        Assert.assertEquals(factory.next(), configFilter, \"initially next should be the configured filter\");\n+        var currFilter = ois.getObjectInputFilter();\n+        if (currFilter != null && currFilter.getClass().getClassLoader() == null) {\n+            \/\/ Builtin loader;  defaults to configured filter\n+            Assert.assertEquals(currFilter, configFilter, \"getObjectInputFilter should be configured filter\");\n+        } else {\n+            Assert.assertEquals(currFilter, configFilter, \"getObjectInputFilter should be null\");\n+        }\n+        if (streamFilter != null) {\n+            ois.setObjectInputFilter(streamFilter);\n+            \/\/ MyFilterFactory is called when the stream filter is changed; verify values passed it\n+            Assert.assertEquals(factory.current(), currFilter, \"when setObjectInputFilter, current should be current filter\");\n+            Assert.assertEquals(factory.next(), streamFilter, \"next should be stream specific filter\");\n+\n+            \/\/ Check the OIS filter after the factory has updated it.\n+            currFilter = ois.getObjectInputFilter();\n+            Assert.assertEquals(currFilter, streamFilter, \"getObjectInputFilter should be set\");\n+\n+            \/\/ Verify that it can not be set again\n+            Assert.assertThrows(IllegalStateException.class, () -> ois.setObjectInputFilter(streamFilter));\n+        }\n+        if (currFilter instanceof Validator validator) {\n+            validator.reset();\n+            Object o = ois.readObject();       \/\/ Invoke only for the side effect of calling the Filter\n+            Assert.assertEquals(validator.count, 1, \"Wrong number of calls to the stream filter\");\n+        } else {\n+            Object o = ois.readObject();       \/\/ Invoke only for the side effect of calling the filter\n+        }\n+    }\n+\n+    \/\/ Test that if the property jdk-serialFilterFactory is set, then initial factory has the same classname\n+    @Test\n+    void testPropertyFilterFactory() {\n+        if (jdkSerialFilterFactoryProp != null && !jdkSerialFilterFactoryProp.equals(\"OVERRIDE\")) {\n+            Assert.assertEquals(jdkSerialFilterFactory.getClass().getName(), jdkSerialFilterFactoryProp,\n+                    \"jdk.serialFilterFactory property classname mismatch\");\n+        }\n+    }\n+\n+    \/\/ Test that setting the filter factory after any deserialization (any testCase)\n+    \/\/ throws IllegalStateException with the specific message\n+    @Test(dependsOnMethods=\"testCase\")\n+    void testSetFactoryAfterDeserialization() {\n+        if (hasFilterPerm()) {\n+            \/\/ Only test if is allowed by SM.\n+            BinaryOperator<ObjectInputFilter> factory = Config.getSerialFilterFactory();\n+            IllegalStateException ise = Assert.expectThrows(IllegalStateException.class, () -> Config.setSerialFilterFactory(factory));\n+            Assert.assertTrue(ise.getMessage().startsWith(\"Cannot replace filter factory: \"));\n+        }\n+    }\n+\n+\n+    \/\/ Test that OIS.setObjectInputFilter does not allow a null filter to replace\n+    \/\/ a non-null filter.  And does allow a null filter to replace a null filter\n+    @Test\n+    void testDisableFailFilter() throws IOException {\n+        if (hasFilterPerm()) {\n+            \/\/ Only test if is allowed by SM.\n+            ObjectInputFilter curr = null;\n+            try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(simpleStream))) {\n+                curr = ois.getObjectInputFilter();\n+                \/\/ Try to set the filter to null\n+                ois.setObjectInputFilter(null);\n+                if (curr != null) {\n+                    Assert.fail(\"setting filter to null after a non-null filter should throw\");\n+                }\n+            } catch (IllegalStateException ise) {\n+                if (curr == null) {\n+                    Assert.fail(\"setting filter to null after a null filter should not throw\");\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A simple filter factory that retains its arguments.\n+     *\/\n+    private static class MyFilterFactory\n+            implements BinaryOperator<ObjectInputFilter> {\n+        private final String name;\n+        private ObjectInputFilter current;\n+        private ObjectInputFilter next;\n+\n+        MyFilterFactory(String name) {\n+            this.name = name;\n+            current = new Validator(\"UnsetCurrent\");\n+            next = new Validator(\"UnsetNext\");\n+        }\n+\n+        public ObjectInputFilter apply(ObjectInputFilter curr, ObjectInputFilter next) {\n+            this.current = curr;\n+            this.next = next;\n+            if (curr == null & next == null)\n+                return Config.getSerialFilter();    \/\/ Default to the configured filter\n+            return next;\n+        }\n+\n+        public void  reset() {\n+            current = new Validator(\"UnsetCurrent\");\n+            next = new Validator(\"UnsetNext\");\n+        }\n+\n+        public ObjectInputFilter current() {\n+            return current;\n+        }\n+\n+        public ObjectInputFilter next() {\n+            return next;\n+        }\n+\n+        public String toString() {\n+            return name + \":: curr: \" + current + \", next: \" + next;\n+        }\n+    }\n+\n+    \/**\n+     * A subclass of MyFilterFactory with a name, used when testing setting the factory using\n+     * -Djdk.setFilterFactory.\n+     *\/\n+    public static class PropertyFilterFactory extends MyFilterFactory {\n+        public PropertyFilterFactory() {\n+            super(\"UNNAMED\");\n+        }\n+    }\n+\n+    \/**\n+     * A filter factory that is not compatible with MyFilterFactory test.\n+     * Used for testing incorrect initialization.\n+     *\/\n+    public static class NotMyFilterFactory\n+            implements BinaryOperator<ObjectInputFilter> {\n+\n+        public NotMyFilterFactory() {}\n+\n+        \/**\n+         * Returns null as the filter to be used for an ObjectInputStream.\n+         *\n+         * @param curr the current filter, if any\n+         * @param next the next filter, if any\n+         * @return null\n+         *\/\n+        public ObjectInputFilter apply(ObjectInputFilter curr, ObjectInputFilter next) {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * A filter that accumulates information about the checkInput callbacks\n+     * that can be checked after readObject completes.\n+     *\/\n+    static class Validator implements ObjectInputFilter {\n+        private final String name;\n+        long count;          \/\/ Count of calls to checkInput\n+\n+        Validator(String name) {\n+            this.name = name;\n+            count = 0;\n+        }\n+\n+        void reset() {\n+            count = 0;\n+        }\n+\n+        @Override\n+        public Status checkInput(FilterInfo filter) {\n+            count++;\n+            return Status.ALLOWED;\n+        }\n+\n+        public String toString(){\n+            return name + \": count: \" + count;\n+        }\n+    }\n+\n+    \/**\n+     * A simple class to serialize.\n+     *\/\n+    private static final class Dummy implements Serializable {\n+        @Serial\n+        private static final long serialVersionUID = 1L;\n+        final String s;\n+        Dummy(String s) {\n+            this.s = s;\n+        }\n+        public String toString() {\n+            return this.getClass().getName() + \"::\" + s;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFilterFactoryTest.java","additions":411,"deletions":0,"binary":false,"changes":411,"status":"added"},{"patch":"@@ -0,0 +1,228 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.ObjectInputFilter;\n+import java.io.ObjectInputFilter.FilterInfo;\n+import java.util.function.Predicate;\n+\n+import static java.io.ObjectInputFilter.Status;\n+import static java.io.ObjectInputFilter.Status.ALLOWED;\n+import static java.io.ObjectInputFilter.Status.REJECTED;\n+import static java.io.ObjectInputFilter.Status.UNDECIDED;\n+\n+\/* @test\n+ * @run testng\/othervm -Djdk.serialFilterTrace=true SerialFilterFunctionTest\n+ * @summary ObjectInputFilter.Config Function Tests\n+ *\/\n+@Test\n+public class SerialFilterFunctionTest {\n+\n+    @Test\n+    void testMerge() {\n+        Status[] cases = Status.values();\n+        FilterInfo info = new SerialInfo(Object.class);\n+        for (Status st1 : cases) {\n+            ObjectInputFilter filter1 = getFilter(st1);\n+            for (Status st2 : cases) {\n+                ObjectInputFilter filter2 = getFilter(st2);\n+                ObjectInputFilter f = ObjectInputFilter.merge(filter1, filter2);\n+                Status r = f.checkInput(info);\n+                Assert.assertEquals(merge(st1, st2), r, \"merge\");\n+            }\n+            Assert.assertSame(ObjectInputFilter.merge(filter1, null), filter1, \"merge with null fail\");\n+            Assert.assertThrows(NullPointerException.class, () -> ObjectInputFilter.merge(null, filter1));\n+        }\n+    }\n+\n+    \/**\n+     * Return REJECTED if either is REJECTED; otherwise return ALLOWED if either is ALLOWED, else UNDECIDED.\n+     * @param status a status\n+     * @param otherStatus another status\n+     * @return REJECTED if either is REJECTED; otherwise return ALLOWED if either is ALLOWED, else UNDECIDED\n+     *\/\n+    private Status merge(Status status, Status otherStatus) {\n+        if (REJECTED.equals(status) || REJECTED.equals(otherStatus))\n+            return REJECTED;\n+\n+        if (ALLOWED.equals(status)  || ALLOWED.equals(otherStatus))\n+            return ALLOWED;\n+\n+        return UNDECIDED;\n+    }\n+\n+    \/**\n+     * Return a predicate mapping Class<?> to a boolean that returns true if the argument is Integer.class.\n+     * @return a predicate mapping Class<?> to a boolean that returns true if the argument is Integer.class\n+     *\/\n+    static Predicate<Class<?>> isInteger() {\n+        return (cl) -> cl.equals(Integer.class);\n+    }\n+\n+    @DataProvider(name = \"AllowPredicateCases\")\n+    static Object[][] allowPredicateCases() {\n+        return new Object[][]{\n+                { Integer.class, isInteger(), REJECTED, ALLOWED},\n+                { Double.class, isInteger(), REJECTED, REJECTED},\n+                { null, isInteger(), REJECTED, UNDECIDED},      \/\/ no class -> UNDECIDED\n+                { Double.class, isInteger(), null, null},       \/\/ NPE\n+                { Double.class, null, REJECTED, null},          \/\/ NPE\n+        };\n+    }\n+\n+    @Test(dataProvider = \"AllowPredicateCases\")\n+    void testAllowPredicates(Class<?> clazz, Predicate<Class<?>> predicate, Status otherStatus, Status expected) {\n+        ObjectInputFilter.FilterInfo info = new SerialInfo(clazz);\n+        if (predicate == null || expected == null) {\n+            Assert.assertThrows(NullPointerException.class, () -> ObjectInputFilter.allowFilter(predicate, expected));\n+        } else {\n+            Assert.assertEquals(ObjectInputFilter.allowFilter(predicate, otherStatus).checkInput(info),\n+                    expected, \"Predicate result\");\n+        }\n+    }\n+\n+    @DataProvider(name = \"RejectPredicateCases\")\n+    static Object[][] rejectPredicateCases() {\n+        return new Object[][]{\n+                { Integer.class, isInteger(), REJECTED, REJECTED},\n+                { Double.class, isInteger(), ALLOWED, ALLOWED},\n+                { null, isInteger(), REJECTED, UNDECIDED},      \/\/ no class -> UNDECIDED\n+                { Double.class, isInteger(), null, null},         \/\/ NPE\n+                { Double.class, null, UNDECIDED, null},    \/\/ NPE\n+        };\n+    }\n+\n+    @Test(dataProvider = \"RejectPredicateCases\")\n+    void testRejectPredicates(Class<?> clazz, Predicate<Class<?>> predicate, Status otherStatus, Status expected) {\n+        ObjectInputFilter.FilterInfo info = new SerialInfo(clazz);\n+        if (predicate == null || expected == null) {\n+            Assert.assertThrows(NullPointerException.class, () -> ObjectInputFilter.allowFilter(predicate, expected));\n+        } else {\n+            Assert.assertEquals(ObjectInputFilter.rejectFilter(predicate, otherStatus)\n+                    .checkInput(info), expected, \"Predicate result\");\n+        }\n+    }\n+\n+    @Test\n+    void testRejectUndecided() {\n+        FilterInfo info = new SerialInfo(Object.class); \/\/ an info structure, unused\n+\n+        ObjectInputFilter undecided = getFilter(UNDECIDED);\n+        Assert.assertEquals(ObjectInputFilter.rejectUndecidedClass(undecided).checkInput(info), REJECTED, \"undecided -> rejected\");\n+        ObjectInputFilter allowed = getFilter(ALLOWED);\n+        Assert.assertEquals(ObjectInputFilter.rejectUndecidedClass(allowed).checkInput(info), ALLOWED, \"allowed -> rejected\");\n+        ObjectInputFilter rejected = getFilter(REJECTED);\n+        Assert.assertEquals(ObjectInputFilter.rejectUndecidedClass(rejected).checkInput(info), REJECTED, \"rejected -> rejected\");\n+\n+        \/\/ Specific cases of Classes the result in allowed, rejected, and undecided status\n+        ObjectInputFilter numberFilter = ObjectInputFilter.Config.createFilter(\"java.lang.Integer;!java.lang.Double\");\n+        Object[] testObjs = {\n+                Integer.valueOf(1),         \/\/ Integer is allowed -> allowed\n+                new Integer[1],             \/\/ Integer is allowed -> allowed\n+                new Integer[0][0][0],       \/\/ Integer is allowed -> allowed\n+                Long.valueOf(2),            \/\/ Long is undecided -> rejected\n+                new Long[1],                \/\/ Long is undecided -> rejected\n+                new Long[0][0][0],          \/\/ Long is undecided -> rejected\n+                Double.valueOf(2.0d),       \/\/ Double is rejected -> rejected\n+                new Double[1],              \/\/ Double is rejected -> rejected\n+                new Double[0][0][0],        \/\/ Double is rejected -> rejected\n+                new int[1],                 \/\/ int is primitive undecided -> undecided\n+                new int[1][1][1],           \/\/ int is primitive undecided -> undecided\n+                };\n+\n+        for (Object obj : testObjs) {\n+            Class<?> clazz = obj.getClass();\n+            info = new SerialInfo(clazz);\n+            Status rawSt = numberFilter.checkInput(info);\n+            Status st = ObjectInputFilter.rejectUndecidedClass(numberFilter).checkInput(info);\n+            if (UNDECIDED.equals(rawSt)) {\n+                while (clazz.isArray())\n+                    clazz = clazz.getComponentType();\n+                Status expected = (clazz.isPrimitive()) ? UNDECIDED : REJECTED;\n+                Assert.assertEquals(st, expected, \"Wrong status for class: \" + obj.getClass());\n+            } else {\n+                Assert.assertEquals(rawSt, st, \"raw filter and rejectUndecided filter disagree\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns an ObjectInputFilter that returns the requested Status.\n+     * @param status a Status, may be null\n+     * @return  an ObjectInputFilter that returns the requested Status\n+     *\/\n+    private static ObjectInputFilter getFilter(ObjectInputFilter.Status status) {\n+        return (info) -> status;\n+    }\n+\n+    \/**\n+     * FilterInfo instance with a specific class.\n+     *\/\n+    static class SerialInfo implements ObjectInputFilter.FilterInfo {\n+        private final Class<?> clazz;\n+\n+        SerialInfo(Class<?> clazz) {\n+            this.clazz = clazz;\n+        }\n+\n+        @Override\n+        public Class<?> serialClass() {\n+            return clazz;\n+        }\n+\n+        @Override\n+        public long arrayLength() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long depth() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long references() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long streamBytes() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"serialClass: \" + serialClass());\n+            sb.append(\", arrayLength: \" + arrayLength());\n+            sb.append(\", depth: \" + depth());\n+            sb.append(\", references: \" + references());\n+            sb.append(\", streamBytes: \" + streamBytes());\n+            return sb.toString();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFilterFunctionTest.java","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.io.Serial;\n@@ -55,2 +56,2 @@\n- * @run testng\/othervm  SerialFilterTest\n- * @run testng\/othervm  -Djdk.serialSetFilterAfterRead=true SerialFilterTest\n+ * @run testng\/othervm -Djdk.serialFilterTrace=true SerialFilterTest\n+ * @run testng\/othervm -Djdk.serialSetFilterAfterRead=true -Djdk.serialFilterTrace=true SerialFilterTest\n@@ -58,1 +59,1 @@\n- * @summary Test ObjectInputFilters\n+ * @summary Test ObjectInputFilters using Builtin Filter Factory\n@@ -63,0 +64,1 @@\n+    @Serial\n@@ -245,1 +247,1 @@\n-    public static void t1(Object object,\n+    void t1(Object object,\n@@ -270,1 +272,1 @@\n-    static void testPatterns(String pattern) {\n+    void testPatterns(String pattern) {\n@@ -280,1 +282,1 @@\n-    static void nonResettableFilter() {\n+    void nonResettableFilter() {\n@@ -284,2 +286,4 @@\n-        try {\n-            byte[] bytes = writeObjects(\"text1\");    \/\/ an object\n+        Validator[] filterCases = {\n+                validator1,     \/\/ setting filter to a non-null filter\n+                null,           \/\/ setting stream-specific filter to null\n+        };\n@@ -287,19 +291,22 @@\n-            try (ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n-                 ObjectInputStream ois = new ObjectInputStream(bais)) {\n-                \/\/ Check the initial filter is the global filter; may be null\n-                ObjectInputFilter global = ObjectInputFilter.Config.getSerialFilter();\n-                ObjectInputFilter initial = ois.getObjectInputFilter();\n-                Assert.assertEquals(global, initial, \"initial filter should be the global filter\");\n-\n-                \/\/ Check if it can be set to null\n-                ois.setObjectInputFilter(null);\n-                ObjectInputFilter filter = ois.getObjectInputFilter();\n-                Assert.assertNull(filter, \"set to null should be null\");\n-\n-                ois.setObjectInputFilter(validator1);\n-                Object o = ois.readObject();\n-                try {\n-                    ois.setObjectInputFilter(validator2);\n-                    Assert.fail(\"Should not be able to set filter twice\");\n-                } catch (IllegalStateException ise) {\n-                    \/\/ success, the exception was expected\n+        for (Validator validator : filterCases) {\n+            try {\n+                byte[] bytes = writeObjects(\"text1\");    \/\/ an object\n+\n+                try (ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais)) {\n+                    \/\/ Check the initial filter is the global filter; may be null\n+                    ObjectInputFilter global = ObjectInputFilter.Config.getSerialFilter();\n+                    ObjectInputFilter initial = ois.getObjectInputFilter();\n+                    Assert.assertEquals(global, initial, \"initial filter should be the global filter\");\n+\n+                    ois.setObjectInputFilter(validator);\n+                    Object o = ois.readObject();\n+                    try {\n+                        ois.setObjectInputFilter(validator2);\n+                        Assert.fail(\"Should not be able to set filter twice\");\n+                    } catch (IllegalStateException ise) {\n+                        \/\/ success, the exception was expected\n+                    }\n+                } catch (EOFException eof) {\n+                    Assert.fail(\"Should not reach end-of-file\", eof);\n+                } catch (ClassNotFoundException cnf) {\n+                    Assert.fail(\"Deserializing\", cnf);\n@@ -307,4 +314,2 @@\n-            } catch (EOFException eof) {\n-                Assert.fail(\"Should not reach end-of-file\", eof);\n-            } catch (ClassNotFoundException cnf) {\n-                Assert.fail(\"Deserializing\", cnf);\n+            } catch (IOException ex) {\n+                Assert.fail(\"Unexpected IOException\", ex);\n@@ -312,2 +317,0 @@\n-        } catch (IOException ex) {\n-            Assert.fail(\"Unexpected IOException\", ex);\n@@ -326,1 +329,1 @@\n-    static void testNonSettableAfterReadObject() throws IOException, ClassNotFoundException {\n+    void testNonSettableAfterReadObject() throws IOException, ClassNotFoundException {\n@@ -362,1 +365,1 @@\n-    static void testReadResolveToArray(Object array, int length) throws IOException {\n+    void testReadResolveToArray(Object array, int length) throws IOException {\n@@ -379,1 +382,1 @@\n-    static void testLimits(String name, long value) {\n+    void testLimits(String name, long value) {\n@@ -399,1 +402,1 @@\n-    static void testInvalidLimits(String pattern) {\n+    void testInvalidLimits(String pattern) {\n@@ -412,1 +415,1 @@\n-    static void testNullStatus() throws IOException {\n+    void testNullStatus() throws IOException {\n@@ -431,1 +434,1 @@\n-    static void testInvalidPatterns(String pattern) {\n+    void testInvalidPatterns(String pattern) {\n@@ -444,1 +447,1 @@\n-    static void testEmptyPattern() {\n+    void testEmptyPattern() {\n@@ -776,0 +779,1 @@\n+        @Serial\n@@ -787,0 +791,1 @@\n+        @Serial\n@@ -847,0 +852,1 @@\n+        @Serial\n@@ -850,0 +856,1 @@\n+        @Serial\n@@ -853,0 +860,1 @@\n+        @Serial\n@@ -856,0 +864,1 @@\n+        @Serial\n@@ -859,0 +868,1 @@\n+        @Serial\n@@ -862,0 +872,1 @@\n+        @Serial\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFilterTest.java","additions":52,"deletions":41,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -0,0 +1,4 @@\n+# Deserialization Input Filter Factory\n+# See conf\/security\/java.security for pattern synatx\n+#\n+jdk.serialFilterFactory=SerialFilterFactoryTest$PropertyFilterFactory\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/java.security-extra-factory","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,394 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static org.testng.Assert.*;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+import jdk.test.lib.hexdump.HexPrinter;\n+import jdk.test.lib.hexdump.HexPrinter.Formatters;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.nio.file.Files;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.charset.UnsupportedCharsetException;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import jtreg.SkippedException;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.process.ProcessTools jdk.test.lib.hexdump.HexPrinter\n+ * @run testng ReaderWriterTest\n+ *\/\n+\n+@Test\n+public class ReaderWriterTest {\n+\n+    static final String ASCII = \"ASCII: \\u0000_A-Z_a-Z_\\u007C_\\u007D_\\u007E_\\u007F_;\";\n+    static final String ISO_8859_1 = \" Symbols: \\u00AB_\\u00BB_\\u00fc_\\u00fd_\\u00fe_\\u00ff;\";\n+    static final String FRACTIONS = \" Fractions: \\u00bc_\\u00bd_\\u00be_\\u00bf;\";\n+\n+    public static final String TESTCHARS = \"OneWay: \" + ASCII + ISO_8859_1 + FRACTIONS;\n+    public static final String ROUND_TRIP_TESTCHARS = \"RoundTrip: \" + ASCII + ISO_8859_1 + FRACTIONS;\n+\n+    @DataProvider(name=\"CharsetCases\")\n+    static Object[][] charsetCases() {\n+        return new Object[][] {\n+                {\"UTF-8\"},\n+                {\"ISO8859-1\"},\n+                {\"US-ASCII\"},\n+        };\n+    }\n+\n+    \/**\n+     * Test the defaults case of native.encoding.  No extra command line flags or switches.\n+     *\/\n+    @Test\n+    void testCaseNativeEncoding() throws IOException {\n+        String nativeEncoding = System.getProperty(\"native.encoding\");\n+        Charset cs = Charset.forName(nativeEncoding);\n+        System.out.println(\"Native.encoding Charset: \" + cs);\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"ReaderWriterTest$ChildWithCharset\");\n+        Process p = pb.start();\n+        writeTestChars(p.outputWriter());\n+        checkReader(p.inputReader(), cs, \"Out\");\n+        checkReader(p.errorReader(), cs, \"Err\");\n+        try {\n+            int exitValue = p.waitFor();\n+            if (exitValue != 0)\n+                System.out.println(\"exitValue: \" + exitValue);\n+        } catch (InterruptedException ie) {\n+            Assert.fail(\"waitFor interrupted\");\n+        }\n+    }\n+\n+    \/**\n+     * Test that redirects of input and error streams result in Readers that are empty.\n+     * Test that when the output to a process is redirected, the writer acts as\n+     * a null stream and throws an exception as expected for a null output stream\n+     * as specified by ProcessBuilder.\n+     *\/\n+    @Test\n+    void testRedirects() throws IOException {\n+        String nativeEncoding = System.getProperty(\"native.encoding\");\n+        Charset cs = Charset.forName(nativeEncoding);\n+        System.out.println(\"Native.encoding Charset: \" + cs);\n+\n+        Path inPath = Path.of(\"InFile.tmp\");\n+        BufferedWriter inWriter = Files.newBufferedWriter(inPath);\n+        inWriter.close();\n+\n+        Path outPath = Path.of(\"OutFile.tmp\");\n+        Path errorPath = Path.of(\"ErrFile.tmp\");\n+\n+        for (int errType = 1; errType < 4; errType++) {\n+            \/\/ Three cases to test for which the error stream is empty\n+            \/\/ 1: redirectErrorStream(false); redirect of errorOutput to a file\n+            \/\/ 2: redirectErrorStream(true); no redirect of errorOutput\n+            \/\/ 3: redirectErrorStream(true); redirect of errorOutput to a file\n+\n+            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"ReaderWriterTest$ChildWithCharset\");\n+            pb.redirectInput(inPath.toFile());\n+            pb.redirectOutput(outPath.toFile());\n+            if (errType == 1 || errType == 3) {\n+                pb.redirectError(errorPath.toFile());\n+            }\n+            if (errType == 2 || errType == 3) {\n+                pb.redirectErrorStream(true);\n+            }\n+            Process p = pb.start();\n+            \/\/ Output has been redirected to a null stream; success is IOException on the write\n+            try {\n+                BufferedWriter wr = p.outputWriter();\n+                wr.write(\"X\");\n+                wr.flush();\n+                Assert.fail(\"writing to null stream should throw IOException\");\n+            } catch (IOException ioe) {\n+                \/\/ Normal, A Null output stream is closed when created.\n+            }\n+\n+            \/\/ InputReader should be empty; and at EOF\n+            BufferedReader inputReader = p.inputReader();\n+            int ch = inputReader.read();\n+            Assert.assertEquals(ch, -1, \"inputReader not at EOF: ch: \" + (char)ch);\n+\n+            \/\/ InputReader should be empty; and at EOF\n+            BufferedReader errorReader = p.errorReader();\n+            ch = errorReader.read();\n+            Assert.assertEquals(ch, -1, \"errorReader not at EOF: ch: \" + (char)ch);\n+\n+            try {\n+                int exitValue = p.waitFor();\n+                if (exitValue != 0) System.out.println(\"exitValue: \" + exitValue);\n+            } catch (InterruptedException ie) {\n+                Assert.fail(\"waitFor interrupted\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Write the test characters to the child using the Process.outputWriter.\n+     * @param writer the Writer\n+     * @throws IOException if an I\/O error occurs\n+     *\/\n+    private static void writeTestChars(Writer writer) throws IOException {\n+        \/\/ Write the test data to the child\n+        try (writer) {\n+            writer.append(ROUND_TRIP_TESTCHARS);\n+            writer.append(System.lineSeparator());\n+        }\n+    }\n+\n+    \/**\n+     * Test a child with a character set.\n+     * A Process is spawned; characters are written to and read from the child\n+     * using the character set and compared.\n+     *\n+     * @param encoding a charset name\n+     *\/\n+    @Test(dataProvider = \"CharsetCases\", enabled = true)\n+    void testCase(String encoding) throws IOException {\n+        Charset cs = null;\n+        try {\n+            cs = Charset.forName(encoding);\n+            System.out.println(\"Charset: \" + cs);\n+        } catch (UnsupportedCharsetException use) {\n+            throw new SkippedException(\"Charset not supported: \" + encoding);\n+        }\n+        String cleanCSName = cleanCharsetName(cs);\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                \"-Dsun.stdout.encoding=\" + cleanCSName,     \/\/ Encode in the child using the charset\n+                \"-Dsun.stderr.encoding=\" + cleanCSName,\n+                \"ReaderWriterTest$ChildWithCharset\");\n+\n+        Process p = pb.start();\n+        \/\/ Write the test data to the child\n+        writeTestChars(p.outputWriter(cs));\n+        checkReader(p.inputReader(cs), cs, \"Out\");\n+        checkReader(p.errorReader(cs), cs, \"Err\");\n+        try {\n+            int exitValue = p.waitFor();\n+            if (exitValue != 0)\n+                System.out.println(\"exitValue: \" + exitValue);\n+        } catch (InterruptedException ie) {\n+\n+        }\n+    }\n+\n+    \/**\n+     * Test passing null when a charset is expected\n+     * @throws IOException if an I\/O error occurs; not expected\n+     *\/\n+    @Test\n+    void testNullCharsets()  throws IOException {\n+        \/\/ Launch a child; its behavior is not interesting and is ignored\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                \"ReaderWriterTest$ChildWithCharset\");\n+\n+        Process p = pb.start();\n+        try {\n+            writeTestChars(p.outputWriter(null));\n+            Assert.fail(\"Process.outputWriter(null) did not throw NPE\");\n+        } catch (NullPointerException npe) {\n+            \/\/ expected, ignore\n+        }\n+        try {\n+            checkReader(p.inputReader(null), null, \"Out\");\n+            Assert.fail(\"Process.inputReader(null) did not throw NPE\");\n+        } catch (NullPointerException npe) {\n+            \/\/ expected, ignore\n+        }\n+        try {\n+            checkReader(p.errorReader(null), null, \"Err\");\n+            Assert.fail(\"Process.errorReader(null) did not throw NPE\");\n+        } catch (NullPointerException npe) {\n+            \/\/ expected, ignore\n+        }\n+\n+        p.destroyForcibly();\n+        try {\n+            \/\/ Collect the exit status to cleanup after the process; but ignore it\n+            p.waitFor();\n+        } catch (InterruptedException ie) {\n+            \/\/ Ignored\n+        }\n+    }\n+\n+    \/**\n+     * Test passing different charset on multiple calls when the same charset is expected.\n+     * @throws IOException if an I\/O error occurs; not expected\n+     *\/\n+    @Test\n+    void testIllegalArgCharsets()  throws IOException {\n+        String nativeEncoding = System.getProperty(\"native.encoding\");\n+        Charset cs = Charset.forName(nativeEncoding);\n+        System.out.println(\"Native.encoding Charset: \" + cs);\n+        Charset otherCharset = cs.equals(StandardCharsets.UTF_8)\n+                ? StandardCharsets.ISO_8859_1\n+                : StandardCharsets.UTF_8;\n+\n+        \/\/ Launch a child; its behavior is not interesting and is ignored\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                \"ReaderWriterTest$ChildWithCharset\");\n+\n+        Process p = pb.start();\n+        try {\n+            var writer = p.outputWriter(cs);\n+            writer = p.outputWriter(cs);        \/\/ try again with same\n+            writer = p.outputWriter(otherCharset);  \/\/ this should throw\n+            Assert.fail(\"Process.outputWriter(otherCharset) did not throw IllegalStateException\");\n+        } catch (IllegalStateException ile) {\n+            \/\/ expected, ignore\n+            System.out.println(ile);\n+        }\n+        try {\n+            var reader = p.inputReader(cs);\n+            reader = p.inputReader(cs);             \/\/ try again with same\n+            reader = p.inputReader(otherCharset);   \/\/ this should throw\n+            Assert.fail(\"Process.inputReader(otherCharset) did not throw IllegalStateException\");\n+        } catch (IllegalStateException ile) {\n+            \/\/ expected, ignore\n+            System.out.println(ile);\n+        }\n+        try {\n+            var reader = p.errorReader(cs);\n+            reader = p.errorReader(cs);             \/\/ try again with same\n+            reader = p.errorReader(otherCharset);   \/\/ this should throw\n+            Assert.fail(\"Process.errorReader(otherCharset) did not throw IllegalStateException\");\n+        } catch (IllegalStateException ile) {\n+            \/\/ expected, ignore\n+            System.out.println(ile);\n+        }\n+\n+        p.destroyForcibly();\n+        try {\n+            \/\/ Collect the exit status to cleanup after the process; but ignore it\n+            p.waitFor();\n+        } catch (InterruptedException ie) {\n+            \/\/ Ignored\n+        }\n+    }\n+\n+    private static void checkReader(BufferedReader reader, Charset cs, String label) throws IOException {\n+        try (BufferedReader in = reader) {\n+            String prefix = \"    \" + label + \": \";\n+            String firstline = in.readLine();\n+            System.out.append(prefix).println(firstline);\n+            String secondline = in.readLine();\n+            System.out.append(prefix).println(secondline);\n+            for (String line = in.readLine(); line != null; line = in.readLine()) {\n+                System.out.append(prefix).append(line);\n+                System.out.println();\n+            }\n+            ByteBuffer bb = cs.encode(TESTCHARS);\n+            String reencoded = cs.decode(bb).toString();\n+            if (!firstline.equals(reencoded))\n+                diffStrings(firstline, reencoded);\n+            assertEquals(firstline, reencoded, label + \" Test Chars\");\n+\n+            bb = cs.encode(ROUND_TRIP_TESTCHARS);\n+            reencoded = cs.decode(bb).toString();\n+            if (!secondline.equals(reencoded))\n+                diffStrings(secondline, reencoded);\n+            assertEquals(secondline, reencoded, label + \" Round Trip Test Chars\");\n+        }\n+    }\n+\n+    \/**\n+     * A cleaned up Charset name that is suitable for Linux LANG environment variable.\n+     * If there are two '-'s the first one is removed.\n+     * @param cs a Charset\n+     * @return the cleanedup Charset name\n+     *\/\n+    private static String cleanCharsetName(Charset cs) {\n+        String name = cs.name();\n+        int ndx = name.indexOf('-');\n+        if (ndx >= 0 && name.indexOf('-', ndx + 1) >= 0) {\n+            name = name.substring(0, ndx) + name.substring(ndx + 1);\n+        }\n+        return name;\n+    }\n+\n+    private static void diffStrings(String actual, String expected) {\n+        if (actual.equals(expected))\n+            return;\n+        int lenDiff = expected.length() - actual.length();\n+        if (lenDiff != 0)\n+            System.out.println(\"String lengths:  \" + actual.length() + \" != \" + expected.length());\n+        int first;  \/\/ find first mismatched character\n+        for (first = 0; first < Math.min(actual.length(), expected.length()); first++) {\n+            if (actual.charAt(first) != expected.charAt(first))\n+                break;\n+        }\n+        int last;\n+        for (last = actual.length() - 1; last >= 0 && (last + lenDiff) >= 0; last--) {\n+            if (actual.charAt(last) != expected.charAt(last + lenDiff))\n+                break;      \/\/ last mismatched character\n+        }\n+        System.out.printf(\"actual vs expected[%3d]: 0x%04x != 0x%04x%n\", first, (int)actual.charAt(first), (int)expected.charAt(first));\n+        System.out.printf(\"actual vs expected[%3d]: 0x%04x != 0x%04x%n\", last, (int)actual.charAt(last), (int)expected.charAt(last));\n+        System.out.printf(\"actual  [%3d-%3d]: %s%n\", first, last, actual.substring(first, last+1));\n+        System.out.printf(\"expected[%3d-%3d]: %s%n\", first, last, expected.substring(first, last + lenDiff + 1));\n+    }\n+\n+    static class ChildWithCharset {\n+        public static void main(String[] args) {\n+            String nativeEncoding = System.getProperty(\"native.encoding\");\n+            System.out.println(TESTCHARS);\n+            byte[] bytes = null;\n+            try {\n+                bytes = System.in.readAllBytes();\n+                System.out.write(bytes);    \/\/ echo bytes back to parent on stdout\n+            } catch (IOException ioe) {\n+                ioe.printStackTrace();      \/\/ Seen by the parent\n+            }\n+            System.out.println(\"native.encoding: \" + nativeEncoding);\n+            System.out.println(\"sun.stdout.encoding: \" + System.getProperty(\"sun.stdout.encoding\"));\n+            System.out.println(\"LANG: \" + System.getenv().get(\"LANG\"));\n+\n+            System.err.println(TESTCHARS);\n+            try {\n+                System.err.write(bytes);    \/\/ echo bytes back to parent on stderr\n+            } catch (IOException ioe) {\n+                ioe.printStackTrace();      \/\/ Seen by the parent\n+            }\n+            System.err.println(\"native.encoding: \" + nativeEncoding);\n+            System.err.println(\"sun.stderr.encoding: \" + System.getProperty(\"sun.stderr.encoding\"));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/ReaderWriterTest.java","additions":394,"deletions":0,"binary":false,"changes":394,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8228988\n+ * @bug 8228988 8266598\n@@ -62,1 +62,5 @@\n-            \/\/ correct\n+            if (!e.element().getName().equals(\"value\")) {\n+                throw new IllegalStateException(\"Unexpected element: \" + e.element());\n+            } else if (!e.foundType().equals(AnEnum.class.getName() + \".\" + AnEnum.VALUE.name())) {\n+                throw new IllegalStateException(\"Unexpected type: \" + e.foundType());\n+            }\n","filename":"test\/jdk\/java\/lang\/annotation\/AnnotationTypeMismatchException\/AnnotationTypeMismatchTest.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266766\n+ * @summary An array property of a type that is no longer of a type that is a legal member of an\n+ *          annotation should throw an AnnotationTypeMismatchException.\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @run main ArrayTypeMismatchTest\n+ *\/\n+\n+import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.Type;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.annotation.AnnotationTypeMismatchException;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class ArrayTypeMismatchTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        \/*\n+         * This test creates an annotation where the annotation member's type is an array with\n+         * a component type that cannot be legally used for an annotation member. This can happen\n+         * if a class is recompiled independencly of the annotation type and linked at runtime\n+         * in this new version. For a test, a class is created as:\n+         *\n+         * package sample;\n+         * @Carrier(value = { @NoAnnotation })\n+         * class Host { }\n+         *\n+         * where NoAnnotation is defined as a regular interface and not as an annotation type.\n+         * The classes are created by using ASM to emulate this state.\n+         *\/\n+        ByteArrayClassLoader cl = new ByteArrayClassLoader(NoAnnotation.class.getClassLoader());\n+        cl.init(annotationType(), carrierType());\n+        @SuppressWarnings(\"unchecked\")\n+        Class<? extends Annotation> host = (Class<? extends Annotation>) cl.loadClass(\"sample.Host\");\n+        Annotation sample = cl.loadClass(\"sample.Carrier\").getAnnotation(host);\n+        try {\n+            Object value = host.getMethod(\"value\").invoke(sample);\n+            throw new IllegalStateException(\"Found value: \" + value);\n+        } catch (InvocationTargetException ite) {\n+            Throwable cause = ite.getCause();\n+            if (cause instanceof AnnotationTypeMismatchException) {\n+                AnnotationTypeMismatchException e = ((AnnotationTypeMismatchException) cause);\n+                if (!e.element().getName().equals(\"value\")) {\n+                    throw new IllegalStateException(\"Unexpected element: \" + e.element());\n+                } else if (!e.foundType().equals(\"Array with component tag: @\")) {\n+                    throw new IllegalStateException(\"Unexpected type: \" + e.foundType());\n+                }\n+            } else {\n+                throw new IllegalStateException(cause);\n+            }\n+        }\n+    }\n+\n+    private static byte[] carrierType() {\n+        ClassWriter writer = new ClassWriter(0);\n+        writer.visit(Opcodes.V1_8, 0, \"sample\/Carrier\", null, Type.getInternalName(Object.class), null);\n+        AnnotationVisitor v = writer.visitAnnotation(\"Lsample\/Host;\", true);\n+        AnnotationVisitor a = v.visitArray(\"value\");\n+        a.visitAnnotation(null, Type.getDescriptor(NoAnnotation.class)).visitEnd();\n+        a.visitEnd();\n+        v.visitEnd();\n+        writer.visitEnd();\n+        return writer.toByteArray();\n+    }\n+\n+    private static byte[] annotationType() {\n+        ClassWriter writer = new ClassWriter(0);\n+        writer.visit(Opcodes.V1_8,\n+                Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT | Opcodes.ACC_INTERFACE | Opcodes.ACC_ANNOTATION,\n+                \"sample\/Host\",\n+                null,\n+                Type.getInternalName(Object.class),\n+                new String[]{Type.getInternalName(Annotation.class)});\n+        AnnotationVisitor a = writer.visitAnnotation(Type.getDescriptor(Retention.class), true);\n+        a.visitEnum(\"value\", Type.getDescriptor(RetentionPolicy.class), RetentionPolicy.RUNTIME.name());\n+        writer.visitMethod(Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT,\n+                \"value\",\n+                Type.getMethodDescriptor(Type.getType(NoAnnotation[].class)),\n+                null,\n+                null).visitEnd();\n+        writer.visitEnd();\n+        return writer.toByteArray();\n+    }\n+\n+    public interface NoAnnotation { }\n+\n+    public static class ByteArrayClassLoader extends ClassLoader {\n+\n+        public ByteArrayClassLoader(ClassLoader parent) {\n+            super(parent);\n+        }\n+\n+        void init(byte[] annotationType, byte[] carrierType) {\n+            defineClass(\"sample.Host\", annotationType, 0, annotationType.length);\n+            defineClass(\"sample.Carrier\", carrierType, 0, carrierType.length);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/annotation\/AnnotationTypeMismatchException\/ArrayTypeMismatchTest.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8228988\n+ * @bug 8228988 8266598\n@@ -62,1 +62,5 @@\n-            \/\/ correct\n+            if (!e.element().getName().equals(\"value\")) {\n+                throw new IllegalStateException(\"Unexpected element: \" + e.element());\n+            } else if (!e.foundType().equals(\"@\" + AnAnnotation.class.getName() + \"(\" + AnEnum.VALUE.name() + \")\")) {\n+                throw new IllegalStateException(\"Unexpected type: \" + e.foundType());\n+            }\n","filename":"test\/jdk\/java\/lang\/annotation\/AnnotationTypeMismatchException\/EnumTypeMismatchTest.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,305 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8174222\n+ * @summary Validation of LambdaMetafactory arguments\n+ *\/\n+import java.lang.invoke.*;\n+import java.util.*;\n+\n+public class MetafactoryArgValidationTest {\n+\n+    public static void main(String... args) {\n+        testNPE();\n+        testIAE();\n+        testLCE();\n+    }\n+\n+    public static void testNPE() {\n+        MethodType toI = mt(I.class);\n+        MethodType toVoid = mt(void.class);\n+        MethodType toC = mt(C.class);\n+        MethodHandle impl = C.invokeStaticMH();\n+        MethodHandle impl2 = C.newInvokeSpecialMH();\n+        int flagSer = LambdaMetafactory.FLAG_SERIALIZABLE;\n+        int flagMark = LambdaMetafactory.FLAG_MARKERS;\n+        int flagBridge = LambdaMetafactory.FLAG_BRIDGES;\n+\n+        mfFail(NullPointerException.class, null, \"m\", toI, toVoid, impl, toVoid);\n+        mfFail(NullPointerException.class, C.lookup, null, toI, toVoid, impl, toVoid);\n+        mfFail(NullPointerException.class, C.lookup, \"m\", null, toVoid, impl, toVoid);\n+        mfFail(NullPointerException.class, C.lookup, \"m\", toI, null, impl, toVoid);\n+        mfFail(NullPointerException.class, C.lookup, \"m\", toI, toVoid, null, toVoid);\n+        mfFail(NullPointerException.class, C.lookup, \"m\", toI, toVoid, impl, null);\n+\n+        amfFail(NullPointerException.class, null, \"m\", toI, arr(toVoid, impl, toVoid, flagSer));\n+        amfFail(NullPointerException.class, C.lookup, null, toI, arr(toVoid, impl, toVoid, flagSer));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", null, arr(toVoid, impl, toVoid, flagSer));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, null);\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, arr(null, impl, toVoid, flagSer));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, arr(toVoid, null, toVoid, flagSer));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, arr(toVoid, impl, null, flagSer));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, null));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, flagMark, null));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, flagMark, 1, null));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, flagMark, 2, Runnable.class, null));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, arr(toC, impl2, toC, flagBridge, null));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, arr(toC, impl2, toC, flagBridge, 1, null));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, arr(toC, impl2, toC, flagBridge, 1, null));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, arr(toC, impl2, toC, flagBridge, 2, mt(Object.class), null));\n+        amfFail(NullPointerException.class, C.lookup, \"m\", toI, arr(toC, impl2, toC, flagBridge|flagMark|flagSer, 1, Runnable.class, 2, mt(Object.class), null));\n+    }\n+\n+    public static void testIAE() {\n+        MethodType toI = mt(I.class);\n+        MethodType toVoid = mt(void.class);\n+        MethodType toC = mt(C.class);\n+        MethodHandle impl = C.invokeStaticMH();\n+        MethodHandle impl2 = C.newInvokeSpecialMH();\n+        int flagSer = LambdaMetafactory.FLAG_SERIALIZABLE;\n+        int flagMark = LambdaMetafactory.FLAG_MARKERS;\n+        int flagBridge = LambdaMetafactory.FLAG_BRIDGES;\n+\n+        \/\/ missing arguments\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr());\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid));\n+        amfSucceed(C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, 0));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, flagMark));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, flagMark, 1));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, flagMark, 2, Runnable.class));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toC, impl2, toC, flagBridge));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toC, impl2, toC, flagBridge, 1));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toC, impl2, toC, flagBridge, 2, mt(Object.class)));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toC, impl2, toC, flagBridge|flagMark|flagSer, 1, Runnable.class, 2, mt(Object.class)));\n+\n+        \/\/ too many arguments\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, 0, 1));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toC, impl2, toC, flagMark|flagSer, 1, Runnable.class, 1, mt(Object.class)));\n+\n+        \/\/ wrong argument types\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(impl, impl, toVoid, flagSer));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toVoid, toVoid, toVoid, flagSer));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toVoid, impl, impl, flagSer));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, \"hi\"));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, flagMark, Runnable.class));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, flagBridge, 1, Runnable.class));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, flagMark, 1, toVoid));\n+\n+        \/\/ negative count\n+        amfSucceed(C.lookup, \"m\", toI, arr(toC, impl2, toC, flagBridge|flagMark|flagSer, 0, 0));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toC, impl2, toC, flagBridge|flagMark|flagSer, -1, 0));\n+        amfFail(IllegalArgumentException.class, C.lookup, \"m\", toI, arr(toC, impl2, toC, flagBridge|flagMark|flagSer, 0, -1));\n+    }\n+\n+    public static void testLCE() {\n+        MethodType toI = mt(I.class);\n+        MethodType toC = mt(C.class);\n+        MethodType toVoid = mt(void.class);\n+        MethodType cToVoid = mt(void.class, C.class);\n+        MethodType ccToVoid = mt(void.class, C.class, C.class);\n+        MethodType cToC = mt(C.class, C.class);\n+        MethodType cToString = mt(String.class, C.class);\n+        MethodHandle impl = C.invokeStaticMH();\n+        int flagSer = LambdaMetafactory.FLAG_SERIALIZABLE;\n+        int flagMark = LambdaMetafactory.FLAG_MARKERS;\n+\n+        \/\/ non-interface\n+        mfFail(LambdaConversionException.class, C.lookup, \"m\", mt(Object.class), toVoid, impl, toVoid);\n+        amfFail(LambdaConversionException.class, C.lookup, \"m\", mt(Object.class), arr(toVoid, impl, toVoid, flagSer));\n+        mfFail(LambdaConversionException.class, C.lookup, \"m\", mt(int.class), toVoid, impl, toVoid);\n+        amfFail(LambdaConversionException.class, C.lookup, \"m\", mt(int.class), arr(toVoid, impl, toVoid, flagSer));\n+        amfFail(LambdaConversionException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, flagMark, 1, Object.class));\n+        amfFail(LambdaConversionException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, flagMark, 1, int.class));\n+        amfFail(LambdaConversionException.class, C.lookup, \"m\", toI, arr(toVoid, impl, toVoid, flagMark, 2, Runnable.class, Object.class));\n+\n+        \/\/ lookup without private access\n+        mfFail(LambdaConversionException.class, MethodHandles.publicLookup(), \"m\", toI, toVoid, impl, toVoid);\n+        amfFail(LambdaConversionException.class, MethodHandles.publicLookup(), \"m\", toI, arr(toVoid, impl, toVoid, flagSer));\n+        mfFail(LambdaConversionException.class, C.lookup.dropLookupMode(MethodHandles.Lookup.PRIVATE), \"m\", toI, toVoid, impl, toVoid);\n+        amfFail(LambdaConversionException.class, C.lookup.dropLookupMode(MethodHandles.Lookup.PRIVATE), \"m\", toI, arr(toVoid, impl, toVoid, flagSer));\n+\n+        \/\/ unsupported MethodHandle\n+        mfFail(LambdaConversionException.class, C.lookup, \"m\", toI, cToC, C.getFieldMH(), cToC);\n+        amfFail(LambdaConversionException.class, C.lookup, \"m\", toI, arr(cToC, C.getFieldMH(), cToC, flagSer));\n+        mfFail(LambdaConversionException.class, C.lookup, \"m\", toI, toC, C.getStaticMH(), toC);\n+        amfFail(LambdaConversionException.class, C.lookup, \"m\", toI, arr(toC, C.getStaticMH(), toC, flagSer));\n+        mfFail(LambdaConversionException.class, C.lookup, \"m\", toI, ccToVoid, C.putFieldMH(), ccToVoid);\n+        amfFail(LambdaConversionException.class, C.lookup, \"m\", toI, arr(ccToVoid, C.putFieldMH(), ccToVoid, flagSer));\n+        mfFail(LambdaConversionException.class, C.lookup, \"m\", toI, cToVoid, C.putStaticMH(), cToVoid);\n+        amfFail(LambdaConversionException.class, C.lookup, \"m\", toI, arr(cToVoid, C.putStaticMH(), cToVoid, flagSer));\n+        mfSucceed(C.lookup, \"m\", toI, cToVoid, C.invokeVirtualMH(), cToVoid);\n+        amfSucceed(C.lookup, \"m\", toI, arr(cToVoid, C.invokeVirtualMH(), cToVoid, flagSer));\n+        mfSucceed(C.lookup, \"m\", toI, toVoid, C.invokeStaticMH(), toVoid);\n+        amfSucceed(C.lookup, \"m\", toI, arr(toVoid, C.invokeStaticMH(), toVoid, flagSer));\n+        mfSucceed(C.lookup, \"m\", toI, cToString, C.invokeSpecialMH(), cToString);\n+        amfSucceed(C.lookup, \"m\", toI, arr(cToString, C.invokeSpecialMH(), cToString, flagSer));\n+        mfSucceed(C.lookup, \"m\", toI, toC, C.newInvokeSpecialMH(), toC);\n+        amfSucceed(C.lookup, \"m\", toI, arr(toC, C.newInvokeSpecialMH(), toC, flagSer));\n+        mfSucceed(C.lookup, \"m\", toI, cToVoid, C.invokeInterfaceMH(), cToVoid);\n+        amfSucceed(C.lookup, \"m\", toI, arr(cToVoid, C.invokeInterfaceMH(), cToVoid, flagSer));\n+        mfFail(LambdaConversionException.class, C.lookup, \"m\", toI, toVoid, MethodHandles.empty(toVoid), toVoid);\n+        amfFail(LambdaConversionException.class, C.lookup, \"m\", toI, arr(toVoid, MethodHandles.empty(toVoid), toVoid, flagSer));\n+    }\n+\n+    static MethodType mt(Class<?> ret, Class<?>... params) {\n+        return MethodType.methodType(ret, params);\n+    }\n+\n+    static Object[] arr(Object... args) {\n+        return args;\n+    }\n+\n+    public static class C implements Runnable {\n+\n+        public static MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+        public static MethodHandle getFieldMH() {\n+            try { return lookup.findGetter(C.class, \"iv\", C.class); }\n+            catch (ReflectiveOperationException e) { throw new RuntimeException(e); }\n+        }\n+\n+        public static MethodHandle getStaticMH() {\n+            try { return lookup.findStaticGetter(C.class, \"sv\", C.class); }\n+            catch (ReflectiveOperationException e) { throw new RuntimeException(e); }\n+        }\n+\n+        public static MethodHandle putFieldMH() {\n+            try { return lookup.findSetter(C.class, \"iv\", C.class); }\n+            catch (ReflectiveOperationException e) { throw new RuntimeException(e); }\n+        }\n+\n+        public static MethodHandle putStaticMH() {\n+            try { return lookup.findStaticSetter(C.class, \"sv\", C.class); }\n+            catch (ReflectiveOperationException e) { throw new RuntimeException(e); }\n+        }\n+\n+        public static MethodHandle invokeVirtualMH() {\n+            try { return lookup.findVirtual(C.class, \"im\", mt(void.class)); }\n+            catch (ReflectiveOperationException e) { throw new RuntimeException(e); }\n+        }\n+\n+        public static MethodHandle invokeStaticMH() {\n+            try { return lookup.findStatic(C.class, \"sm\", mt(void.class)); }\n+            catch (ReflectiveOperationException e) { throw new RuntimeException(e); }\n+        }\n+\n+        public static MethodHandle invokeSpecialMH() {\n+            try { return lookup.findSpecial(Object.class, \"toString\", mt(String.class), C.class); }\n+            catch (ReflectiveOperationException e) { throw new RuntimeException(e); }\n+        }\n+\n+        public static MethodHandle newInvokeSpecialMH() {\n+            try { return lookup.findConstructor(C.class, mt(void.class)); }\n+            catch (ReflectiveOperationException e) { throw new RuntimeException(e); }\n+        }\n+\n+        public static MethodHandle invokeInterfaceMH() {\n+            try { return lookup.findVirtual(Runnable.class, \"run\", mt(void.class)); }\n+            catch (ReflectiveOperationException e) { throw new RuntimeException(e); }\n+        }\n+\n+        public static C sv;\n+        public C iv;\n+        public static void sm() {}\n+        public void im() {}\n+        public C() {}\n+        public void run() {}\n+    }\n+\n+    public interface I {}\n+\n+    static CallSite mfSucceed(MethodHandles.Lookup lookup,\n+                              String name,\n+                              MethodType capType,\n+                              MethodType desc,\n+                              MethodHandle impl,\n+                              MethodType checked) {\n+        try {\n+            return LambdaMetafactory.metafactory(lookup, name, capType, desc, impl, checked);\n+        } catch (Throwable t) {\n+            String msg = String.format(\"Unexpected exception during linkage for metafactory(%s, %s, %s, %s, %s, %s)\",\n+                    lookup, name, capType, desc, impl, checked);\n+            throw new AssertionError(msg, t);\n+        }\n+    }\n+\n+    static void mfFail(Class<?> exceptionType,\n+                       MethodHandles.Lookup lookup,\n+                       String name,\n+                       MethodType capType,\n+                       MethodType desc,\n+                       MethodHandle impl,\n+                       MethodType checked) {\n+        try {\n+            LambdaMetafactory.metafactory(lookup, name, capType, desc, impl, checked);\n+        } catch (Throwable t) {\n+            if (exceptionType.isInstance(t)) {\n+                return;\n+            } else {\n+                String msg = String.format(\"Unexpected exception: expected %s during linkage for metafactory(%s, %s, %s, %s, %s, %s)\",\n+                                           exceptionType.getName(), lookup, name, capType, desc, impl, checked);\n+                throw new AssertionError(msg, t);\n+            }\n+        }\n+        String msg = String.format(\"Unexpected success: expected %s during linkage for metafactory(%s, %s, %s, %s, %s, %s)\",\n+                                   exceptionType.getName(), lookup, name, capType, desc, impl, checked);\n+        throw new AssertionError(msg);\n+    }\n+\n+    static CallSite amfSucceed(MethodHandles.Lookup lookup,\n+                               String name,\n+                               MethodType capType,\n+                               Object[] args) {\n+        try {\n+            return LambdaMetafactory.altMetafactory(lookup, name, capType, args);\n+        } catch (Throwable t) {\n+            String msg = String.format(\"Unexpected exception during linkage for altMetafactory(%s, %s, %s, %s)\",\n+                                       lookup, name, capType, Arrays.asList(args));\n+            throw new AssertionError(msg, t);\n+        }\n+    }\n+\n+    static void amfFail(Class<?> exceptionType,\n+                        MethodHandles.Lookup lookup,\n+                        String name,\n+                        MethodType capType,\n+                        Object[] args) {\n+        try {\n+            LambdaMetafactory.altMetafactory(lookup, name, capType, args);\n+        } catch (Throwable t) {\n+            if (exceptionType.isInstance(t)) {\n+                return;\n+            } else {\n+                String msg = String.format(\"Unexpected exception: expected %s during linkage for altMetafactory(%s, %s, %s, %s)\",\n+                                           exceptionType.getName(), lookup, name, capType, Arrays.asList(args));\n+                throw new AssertionError(msg, t);\n+            }\n+        }\n+        String msg = String.format(\"Unexpected success: expected %s during linkage for altMetafactory(%s, %s, %s, %s)\",\n+                                   exceptionType.getName(), lookup, name, capType, Arrays.asList(args));\n+        throw new AssertionError(msg);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/MetafactoryArgValidationTest.java","additions":305,"deletions":0,"binary":false,"changes":305,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+                { 62,   0,  Set.of() },                      \/\/ JDK 18\n@@ -107,1 +108,5 @@\n-                { 62,   0,  Set.of()},                       \/\/ JDK 18\n+                { 62,   0,  Set.of(STATIC) },                \/\/ JDK 18\n+                { 62,   0,  Set.of(TRANSITIVE) },\n+                { 62,   0,  Set.of(STATIC, TRANSITIVE) },\n+\n+                { 63,   0,  Set.of()},                       \/\/ JDK 19\n","filename":"test\/jdk\/java\/lang\/module\/ClassFileVersionsTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.Serializable;\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.runtime.SwitchBootstraps;\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.fail;\n+\n+\/**\n+ * @test\n+ * @compile --enable-preview -source ${jdk.version} SwitchBootstrapsTest.java\n+ * @run testng\/othervm --enable-preview SwitchBootstrapsTest\n+ *\/\n+@Test\n+public class SwitchBootstrapsTest {\n+\n+    public static final MethodHandle BSM_TYPE_SWITCH;\n+\n+    static {\n+        try {\n+            BSM_TYPE_SWITCH = MethodHandles.lookup().findStatic(SwitchBootstraps.class, \"typeSwitch\",\n+                                                                MethodType.methodType(CallSite.class, MethodHandles.Lookup.class, String.class, MethodType.class, Object[].class));\n+        }\n+        catch (ReflectiveOperationException e) {\n+            throw new AssertionError(\"Should not happen\", e);\n+        }\n+    }\n+\n+    private void testType(Object target, int start, int result, Object... labels) throws Throwable {\n+        MethodType switchType = MethodType.methodType(int.class, Object.class, int.class);\n+        MethodHandle indy = ((CallSite) BSM_TYPE_SWITCH.invoke(MethodHandles.lookup(), \"\", switchType, labels)).dynamicInvoker();\n+        assertEquals((int) indy.invoke(target, start), result);\n+        assertEquals(-1, (int) indy.invoke(null, start));\n+    }\n+\n+    public enum E1 {\n+        A;\n+    }\n+\n+    public enum E2 {\n+        C;\n+    }\n+\n+    public void testTypes() throws Throwable {\n+        testType(\"\", 0, 0, String.class, Object.class);\n+        testType(\"\", 0, 0, Object.class);\n+        testType(\"\", 0, 1, Integer.class);\n+        testType(\"\", 0, 1, Integer.class, Serializable.class);\n+        testType(E1.A, 0, 0, E1.class, Object.class);\n+        testType(E2.C, 0, 1, E1.class, Object.class);\n+        testType(new Serializable() { }, 0, 1, Comparable.class, Serializable.class);\n+        testType(\"\", 0, 0, \"\", String.class);\n+        testType(\"\", 1, 1, \"\", String.class);\n+        testType(\"a\", 0, 1, \"\", String.class);\n+        testType(1, 0, 0, 1, Integer.class);\n+        testType(2, 0, 1, 1, Integer.class);\n+        testType(Byte.valueOf((byte) 1), 0, 0, 1, Integer.class);\n+        testType(Short.valueOf((short) 1), 0, 0, 1, Integer.class);\n+        testType(Character.valueOf((char) 1), 0, 0, 1, Integer.class);\n+        testType(Integer.valueOf((int) 1), 0, 0, 1, Integer.class);\n+        try {\n+            testType(1, 0, 1, 1.0, Integer.class);\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IllegalArgumentException ex) {\n+            \/\/OK\n+        }\n+        testType(\"\", 0, 0, String.class, String.class, String.class);\n+        testType(\"\", 1, 1, String.class, String.class, String.class);\n+        testType(\"\", 2, 2, String.class, String.class, String.class);\n+    }\n+\n+    public void testWrongSwitchTypes() throws Throwable {\n+        MethodType[] switchTypes = new MethodType[] {\n+            MethodType.methodType(int.class, Object.class),\n+            MethodType.methodType(int.class, double.class, int.class),\n+            MethodType.methodType(int.class, Object.class, Integer.class)\n+        };\n+        for (MethodType switchType : switchTypes) {\n+            try {\n+                BSM_TYPE_SWITCH.invoke(MethodHandles.lookup(), \"\", switchType);\n+                fail(\"Didn't get the expected exception.\");\n+            } catch (IllegalArgumentException ex) {\n+                \/\/OK, expected\n+            }\n+        }\n+    }\n+\n+    public void testNullLabels() throws Throwable {\n+        MethodType switchType = MethodType.methodType(int.class, Object.class, int.class);\n+        try {\n+            BSM_TYPE_SWITCH.invoke(MethodHandles.lookup(), \"\", switchType, (Object[]) null);\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (NullPointerException ex) {\n+            \/\/OK\n+        }\n+        try {\n+            BSM_TYPE_SWITCH.invoke(MethodHandles.lookup(), \"\", switchType,\n+                                   new Object[] {1, null, String.class});\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IllegalArgumentException ex) {\n+            \/\/OK\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -3,1 +3,1 @@\n-othervm.dirs = java\/time\/chrono java\/time\/format\n+othervm.dirs = java\/time\n","filename":"test\/jdk\/java\/time\/test\/TEST.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-import org.testng.annotations.Test;\n@@ -73,0 +72,1 @@\n+import org.testng.annotations.Test;\n@@ -277,1 +277,1 @@\n-                offsetField = Class.forName(\"java.time.Clock$SystemClock\").getDeclaredField(\"offset\");\n+                offsetField = Class.forName(\"java.time.Clock\").getDeclaredField(\"offset\");\n@@ -318,1 +318,1 @@\n-            offsetField.set(clock, offset);\n+            offsetField.set(null, offset);\n@@ -322,1 +322,1 @@\n-            long actualOffset = offsetField.getLong(clock);\n+            long actualOffset = offsetField.getLong(null);\n","filename":"test\/jdk\/java\/time\/test\/java\/time\/TestClock_System.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.java.time;\n+\n+import static java.time.temporal.ChronoUnit.SECONDS;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertSame;\n+import static org.testng.Assert.assertTrue;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.InstantSource;\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * Test instant source.\n+ *\/\n+@Test\n+public class TestInstantSource {\n+\n+    private static final ZoneId PARIS = ZoneId.of(\"Europe\/Paris\");\n+\n+    public void test_system() {\n+        \/\/ main tests for Clock.currentInstant() are in TestClock_System\n+        var test = InstantSource.system();\n+        assertSame(test.withZone(ZoneOffset.UTC), Clock.systemUTC());\n+        assertEquals(test.withZone(PARIS), Clock.system(PARIS));\n+        var millis = System.currentTimeMillis();\n+        var testMillis = test.millis();\n+        var testInstantMillis = test.instant().toEpochMilli();\n+        assertTrue(Math.abs(testMillis - millis) < 1000);\n+        assertTrue(Math.abs(testInstantMillis - millis) < 1000);\n+        assertSame(test, InstantSource.system());\n+        assertEquals(test.hashCode(), InstantSource.system().hashCode());\n+        assertEquals(test.toString(), \"SystemInstantSource\");\n+    }\n+\n+    public void test_tick() {\n+        var millis = 257265861691L;\n+        var instant = Instant.ofEpochMilli(millis);\n+        var duration = Duration.ofSeconds(1);\n+        var test = InstantSource.tick(InstantSource.fixed(instant), duration);\n+        assertEquals(test.withZone(ZoneOffset.UTC), Clock.tick(Clock.fixed(instant, ZoneOffset.UTC), duration));\n+        assertEquals(test.withZone(PARIS), Clock.tick(Clock.fixed(instant, PARIS), duration));\n+        assertEquals(test.millis(), (millis \/ 1000) * 1000);\n+        assertEquals(test.instant(), instant.truncatedTo(SECONDS));\n+        assertEquals(test, InstantSource.tick(InstantSource.fixed(instant), duration));\n+        assertEquals(test.hashCode(), InstantSource.tick(InstantSource.fixed(instant), duration).hashCode());\n+    }\n+\n+    public void test_fixed() {\n+        var millis = 257265861691L;\n+        var instant = Instant.ofEpochMilli(millis);\n+        var test = InstantSource.fixed(instant);\n+        assertEquals(test.withZone(ZoneOffset.UTC), Clock.fixed(instant, ZoneOffset.UTC));\n+        assertEquals(test.withZone(PARIS), Clock.fixed(instant, PARIS));\n+        assertEquals(test.millis(), millis);\n+        assertEquals(test.instant(), instant);\n+        assertEquals(test, InstantSource.fixed(instant));\n+        assertEquals(test.hashCode(), InstantSource.fixed(instant).hashCode());\n+    }\n+\n+    public void test_offset() {\n+        var millis = 257265861691L;\n+        var instant = Instant.ofEpochMilli(millis);\n+        var duration = Duration.ofSeconds(120);\n+        var test = InstantSource.offset(InstantSource.fixed(instant), duration);\n+        assertEquals(test.withZone(ZoneOffset.UTC), Clock.offset(Clock.fixed(instant, ZoneOffset.UTC), duration));\n+        assertEquals(test.withZone(PARIS), Clock.offset(Clock.fixed(instant, PARIS), duration));\n+        assertEquals(test.millis(), millis + 120_000);\n+        assertEquals(test.instant(), instant.plusSeconds(120));\n+        assertEquals(test, InstantSource.offset(InstantSource.fixed(instant), duration));\n+        assertEquals(test.hashCode(), InstantSource.offset(InstantSource.fixed(instant), duration).hashCode());\n+    }\n+\n+    static class MockInstantSource implements InstantSource {\n+        static final Instant FIXED = Instant.now();\n+\n+        @Override\n+        public Instant instant() {\n+            return FIXED;\n+        }\n+    }\n+\n+    public void test_mock() {\n+        var test = new MockInstantSource();\n+        assertEquals(test.withZone(ZoneOffset.UTC).getZone(), ZoneOffset.UTC);\n+        assertEquals(test.withZone(PARIS).getZone(), PARIS);\n+        assertEquals(test.withZone(ZoneOffset.UTC).withZone(PARIS).getZone(), PARIS);\n+        assertEquals(test.millis(), MockInstantSource.FIXED.toEpochMilli());\n+        assertEquals(test.instant(), MockInstantSource.FIXED);\n+        assertEquals(test.withZone(ZoneOffset.UTC), test.withZone(ZoneOffset.UTC));\n+        assertEquals(test.withZone(ZoneOffset.UTC).hashCode(), test.withZone(ZoneOffset.UTC).hashCode());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/time\/test\/java\/time\/TestInstantSource.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import java.util.stream.Collectors;\n@@ -48,0 +47,1 @@\n+import static org.testng.Assert.assertThrows;\n@@ -49,1 +49,0 @@\n-import static org.testng.Assert.fail;\n@@ -473,1 +472,1 @@\n-    \/\/ Map.entry() tests\n+    \/\/ Map::entry tests\n@@ -485,0 +484,6 @@\n+    @Test\n+    public void entrySetValueDisallowed() {\n+        var e = Map.entry(\"a\", \"b\");\n+        assertThrows(UnsupportedOperationException.class, () -> e.setValue(\"x\"));\n+    }\n+\n@@ -495,2 +500,48 @@\n-        assertEquals(sie.hashCode(), kvh1.hashCode());\n-        assertEquals(sie.toString(), kvh1.toString());\n+        assertEquals(kvh1.hashCode(), sie.hashCode());\n+        assertEquals(kvh1.toString(), sie.toString());\n+    }\n+\n+    \/\/ Map.Entry::copyOf tests\n+\n+    @Test(expectedExceptions=NullPointerException.class)\n+    public void entryCopyNullDisallowed() {\n+        Map.Entry.copyOf(null);\n+    }\n+\n+    @Test\n+    public void entryCopyWithNullKeyDisallowed() {\n+        var e = new AbstractMap.SimpleEntry<>(null, \"b\");\n+        assertThrows(NullPointerException.class, () -> Map.Entry.copyOf(e));\n+    }\n+\n+    @Test\n+    public void entryCopyWithNullValueDisallowed() {\n+        var e = new AbstractMap.SimpleEntry<>(\"a\", null);\n+        assertThrows(NullPointerException.class, () -> Map.Entry.copyOf(e));\n+    }\n+\n+    @Test\n+    public void entryCopySetValueDisallowed() {\n+        var e = new AbstractMap.SimpleEntry<>(\"a\", \"b\");\n+        var c = Map.Entry.copyOf(e);\n+        assertThrows(UnsupportedOperationException.class, () -> c.setValue(\"x\"));\n+    }\n+\n+    @Test\n+    public void entryCopyBasicTests() {\n+        Map.Entry<String,String> orig = new AbstractMap.SimpleImmutableEntry<>(\"xyzzy\", \"plugh\");\n+        Map.Entry<String,String> copy1 = Map.Entry.copyOf(orig);\n+        Map.Entry<String,String> copy2 = Map.Entry.copyOf(copy1);\n+\n+        assertEquals(orig, copy1);\n+        assertEquals(copy1, orig);\n+        assertEquals(orig, copy2);\n+        assertEquals(copy2, orig);\n+        assertEquals(copy1, copy2);\n+        assertEquals(copy2, copy1);\n+\n+        assertNotSame(orig, copy1);\n+        assertSame(copy1, copy2);\n+\n+        assertEquals(copy1.hashCode(), orig.hashCode());\n+        assertEquals(copy1.toString(), orig.toString());\n","filename":"test\/jdk\/java\/util\/Map\/MapFactories.java","additions":57,"deletions":6,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,6 @@\n+ \/*\n+ * @test\n+ * @bug 4399067 8179880\n+ * @summary Subject.doAs(null, action) does not clear the executing subject\n+ * @run main\/othervm\/policy=policy Test\n+ *\/\n@@ -30,0 +36,1 @@\n+\n@@ -31,0 +38,1 @@\n+\n@@ -32,3 +40,3 @@\n-                           Collections.singleton(new X500Principal(name)),\n-                           new HashSet(),\n-                           Collections.singleton(Boolean.TRUE));\n+                Collections.singleton(new X500Principal(name)),\n+                new HashSet(),\n+                Collections.singleton(Boolean.TRUE));\n@@ -38,0 +46,1 @@\n+\n@@ -44,1 +53,1 @@\n-                        return System.getProperty(\"foobar\");\n+                            return System.getProperty(\"foobar\");\n@@ -49,2 +58,2 @@\n-        throw new RuntimeException\n-                 (\"Access control exception should have occcured\");\n+            throw new RuntimeException(\n+                    \"AccessControlException should have occcured\");\n@@ -52,1 +61,3 @@\n-                \/\/ Expected exception occured\n+            \/\/ Expected exception occurred\n+            e.printStackTrace(System.out);\n+            System.out.println(\"Expected exception occurred\");\n","filename":"test\/jdk\/javax\/security\/auth\/Subject\/doAs\/Test.java","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1,80 +0,0 @@\n-#! \/bin\/sh\n-\n-#\n-# Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# @test 1.1, 02\/14\/01\n-# @author  Ram Marti\n-# @bug 4399067\n-# @summary Subject.doAs(null, action) does not clear the executing\n-#\n-# ${TESTJAVA} is pointing to the jre\n-#\n-# set platform-dependent variables\n-OS=`uname -s`\n-case \"$OS\" in\n-  Linux )\n-    PS=\":\"\n-    FS=\"\/\"\n-    RM=\"\/bin\/rm -f\"\n-    ;;\n-  Darwin )\n-    PS=\":\"\n-    FS=\"\/\"\n-    RM=\"\/bin\/rm -f\"\n-    ;;\n-  AIX )\n-    PS=\":\"\n-    FS=\"\/\"\n-    RM=\"\/bin\/rm -f\"\n-    ;;\n-  CYGWIN* )\n-    PS=\";\"\n-    FS=\"\/\"\n-    RM=\"rm\"\n-    ;;\n-  Windows* )\n-    PS=\";\"\n-    FS=\"\\\\\"\n-    RM=\"rm\"\n-    ;;\n-  * )\n-    echo \"Unrecognized system!\"\n-    exit 1;\n-    ;;\n-esac\n-# remove any leftover built class\n-cd ${TESTCLASSES}${FS}\n-${RM} Test.class\n-${COMPILEJAVA}${FS}bin${FS}javac ${TESTJAVACOPTS} ${TESTTOOLVMOPTS} -d ${TESTCLASSES}${FS} \\\n-    ${TESTSRC}${FS}Test.java\n-WD=`pwd`\n-cd ${TESTSRC}${FS}\n-cd $WD\n-echo $WD\n-${TESTJAVA}${FS}bin${FS}java ${TESTVMOPTS} -classpath \"${TESTCLASSES}${FS}\" \\\n--Djava.security.manager  \\\n--Djava.security.policy=${TESTSRC}${FS}policy \\\n-Test\n-\n-exit $?\n","filename":"test\/jdk\/javax\/security\/auth\/Subject\/doAs\/Test.sh","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.sound.sampled.AudioFormat;\n+import javax.sound.sampled.AudioSystem;\n+import javax.sound.sampled.Clip;\n+import javax.sound.sampled.LineUnavailableException;\n+\n+\/**\n+ * @test\n+ * @bug 8266421\n+ * @summary Tests that Clip.setFramePosition\/setMicrosecondPosition do not hang.\n+ *\/\n+public final class SetPositionHang implements Runnable {\n+\n+    private static volatile boolean testFramePosition;\n+    private final Clip clip;\n+    private final String thread;\n+\n+    private SetPositionHang(String thread, Clip clip) {\n+        this.thread = thread;\n+        this.clip = clip;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        testFramePosition = false;\n+        test();\n+        testFramePosition = true;\n+        test();\n+    }\n+\n+    private static void test() throws InterruptedException {\n+        try (Clip clip = AudioSystem.getClip()) {\n+            \/\/ prepare audio data\n+            int frameCount = 441000; \/\/ lets say 10 seconds\n+            AudioFormat format = new AudioFormat(44100.0f, 16, 2, true, false);\n+            byte[] bytes = new byte[frameCount * format.getFrameSize()];\n+\n+            clip.open(format, bytes, 0, frameCount);\n+            Thread t1 = new Thread(new SetPositionHang(\"1\", clip));\n+            Thread t2 = new Thread(new SetPositionHang(\"2\", clip));\n+            Thread t3 = new Thread(new SetPositionHang(\"3\", clip));\n+            Thread t4 = new Thread(new SetPositionHang(\"4\", clip));\n+            Thread t5 = new Thread(new SetPositionHang(\"5\", clip));\n+            t1.start();\n+            t2.start();\n+            t3.start();\n+            t4.start();\n+            t5.start();\n+            t1.join();\n+            t2.join();\n+            t3.join();\n+            t4.join();\n+            t5.join();\n+        } catch (LineUnavailableException | IllegalArgumentException ignored) {\n+            \/\/ the test is not applicable\n+        }\n+    }\n+\n+    public void run() {\n+        System.out.println(\"Thread \" + thread + \" Start\");\n+        for (int i = 0; i < 100; i++) {\n+\/\/            System.out.println(\"Thread \" + thread + \" Play \" +\n+\/\/                               System.currentTimeMillis() % 100000);\n+            playSound();\n+            try {\n+                Thread.sleep(i);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        System.out.println(\"Thread \" + thread + \" Finish\");\n+    }\n+\n+    private void playSound() {\n+        if (clip.isRunning()) {\n+            clip.stop();\n+        }\n+        if (testFramePosition) {\n+            clip.setFramePosition(0);\n+        } else {\n+            clip.setMicrosecondPosition(0);\n+        }\n+        clip.start();\n+    }\n+}\n","filename":"test\/jdk\/javax\/sound\/sampled\/Clip\/SetPositionHang.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-        String[] gcCauses = {\"G1 Evacuation Pause\", \"Allocation Failure\", \"System.gc()\"};\n+        String[] gcCauses = {\"G1 Evacuation Pause\", \"G1 Preventive Collection\", \"G1 Compaction Pause\", \"System.gc()\"};\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestGCCauseWithG1ConcurrentMark.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-        String[] gcCauses = {\"G1 Evacuation Pause\", \"Allocation Failure\", \"System.gc()\"};\n+        String[] gcCauses = {\"G1 Evacuation Pause\", \"G1 Preventive Collection\", \"G1 Compaction Pause\", \"System.gc()\"};\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestGCCauseWithG1FullCollection.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.gc.collection;\n+\n+import java.lang.management.ManagementFactory;\n+import java.util.List;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm -XX:+ExplicitGCInvokesConcurrent jdk.jfr.event.gc.collection.TestSystemGC true\n+ * @run main\/othervm -XX:-ExplicitGCInvokesConcurrent jdk.jfr.event.gc.collection.TestSystemGC false\n+ *\/\n+public class TestSystemGC {\n+    public static void main(String[] args) throws Exception {\n+        boolean concurrent = Boolean.valueOf(args[0]);\n+        try (Recording recording = new Recording()) {\n+            recording.enable(EventNames.SystemGC);\n+            recording.start();\n+\n+            \/\/ Trigger 3 System GC\n+            System.gc();\n+            ManagementFactory.getMemoryMXBean().gc();\n+            Runtime.getRuntime().gc();\n+\n+            recording.stop();\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            System.out.println(events);\n+\n+            Asserts.assertEquals(3, events.size(), \"Expected 3 SystemGC events\");\n+\n+            RecordedEvent event1 = events.get(0);\n+            Events.assertFrame(event1, System.class, \"gc\");\n+            Events.assertEventThread(event1, Thread.currentThread());\n+            Events.assertField(event1, \"invokedConcurrent\").isEqual(concurrent);\n+\n+            RecordedEvent event2 = events.get(1);\n+            Events.assertFrame(event2, Runtime.class, \"gc\");\n+            Events.assertEventThread(event2, Thread.currentThread());\n+            Events.assertField(event1, \"invokedConcurrent\").isEqual(concurrent);\n+\n+            RecordedEvent event3 = events.get(2);\n+            \/\/ MemoryMXBean.class is an interface so can't assertFrame on it\n+            Events.assertEventThread(event3, Thread.currentThread());\n+            Events.assertField(event1, \"invokedConcurrent\").isEqual(concurrent);\n+        }\n+     }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestSystemGc.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -96,2 +96,1 @@\n-            \"duration=2000mss\",\n-            \"maxage=-1000\");\n+            \"duration=2000mss\");\n@@ -100,1 +99,2 @@\n-            \"maxage=1\");\n+            \"maxage=1\",\n+            \"maxage=-1000\");\n@@ -171,6 +171,0 @@\n-\n-        \/\/ Not existing options\n-        test(START_FLIGHT_RECORDING, \"Unknown argument 'dumponexitt' in diagnostic command.\",\n-            \"dumponexitt=true\");\n-        test(FLIGHT_RECORDER_OPTIONS, \"Unknown argument 'notexistoption' in diagnostic command.\",\n-            \"notexistoption\");\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestBadOptionValues.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.startupargs;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.Recording;\n+\n+\/**\n+ * @test\n+ * @summary Start a recording with custom settings\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @modules jdk.jfr\/jdk.jfr.internal\n+ *\n+ * @run main\/othervm -XX:StartFlightRecording:jdk.JVMInformation#enabled=false\n+ *      jdk.jfr.startupargs.TestEventSettings knownSetting\n+ *\n+ * @run main\/othervm -XX:StartFlightRecording:com.example.Hello#stackTrace=true\n+ *      jdk.jfr.startupargs.TestEventSettings unknownSetting\n+ *\n+ * @run main\/othervm -XX:StartFlightRecording:+HelloWorld#enabled=true\n+ *      jdk.jfr.startupargs.TestEventSettings addedUnknownSetting\n+ *\n+ * @run main\/othervm\n+ *      -XX:StartFlightRecording:+A.B#enabled=true,+C.D#enabled=false\n+ *      jdk.jfr.startupargs.TestEventSettings multipleSettings\n+ *\n+ * @run main\/othervm\n+ *      -XX:StartFlightRecording:class-loading=true,socket-threshold=100ms\n+ *      jdk.jfr.startupargs.TestEventSettings jfcOptions\n+ *\/\n+public class TestEventSettings {\n+\n+    public static void main(String... args) throws Exception {\n+        String subTest = args[0];\n+        System.out.println(subTest);\n+\n+        switch (subTest) {\n+        case \"knownSetting\" -> assertSetting(\"jdk.JVMInformation#enabled\",\"false\");\n+        case \"unknownSetting\" -> assertSetting(\"com.example.Hello#stackTrace\", null);\n+        case \"addedUnknownSetting\" -> assertSetting(\"HelloWorld#enabled\", \"true\");\n+        case \"multipleSettings\" -> {\n+            assertSetting(\"A.B#enabled\", \"true\");\n+            assertSetting(\"C.D#enabled\", \"false\");\n+        }\n+        case \"jfcOptions\" -> {\n+            assertSetting(\"jdk.ClassDefine#enabled\",\"true\");\n+            assertSetting(\"jdk.SocketRead#threshold\", \"100 ms\");\n+        }\n+        default -> throw new Exception(\"Uknown tes \" + subTest);\n+        }\n+    }\n+\n+    private static void assertSetting(String key, String value) throws Exception {\n+        List<Recording> rs = FlightRecorder.getFlightRecorder().getRecordings();\n+        if (rs.isEmpty()) {\n+            throw new Exception(\"No recording started\");\n+        }\n+        if (rs.size() != 1) {\n+            throw new Exception(\"Expected only one recording\");\n+        }\n+        Map<String, String> currentSettings = rs.get(0).getSettings();\n+        String s = currentSettings.get(key);\n+        if (!Objects.equals(s, value)) {\n+            System.out.println(\"Key:\" + key);\n+            System.out.println(\"Value:\" + value);\n+            System.out.println(\"Result: \" + s);\n+            System.out.println(\"All Setting:\");\n+            for (var entry : currentSettings.entrySet()) {\n+                System.out.println(entry.getKey() + \"=\" + entry.getValue());\n+            }\n+            throw new Exception(\"Expected: \" + value + \" for \" + key + \" , got: \" + s);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestEventSettings.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.startupargs;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/**\n+ * @test\n+ * @summary Start a recording with custom settings\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @modules jdk.jfr\/jdk.jfr.internal\n+ *\n+ * @run main\/othervm jdk.jfr.startupargs.TestJFCWarnings\n+ *\/\n+public class TestJFCWarnings {\n+\n+    public static void main(String... args) throws Exception {\n+        testUnknownOption();\n+        testSpellingError();\n+    }\n+\n+    private static void testSpellingError() throws Exception {\n+        \/\/ One character spelling error\n+        launch(\"-XX:StartFlightRecording:disc=false\",\n+             \"Did you mean 'disk' instead of 'disc'?\");\n+        \/\/ One missing character\n+        launch(\"-XX:StartFlightRecording:setting=my.jfc\",\n+             \"Did you mean 'settings' instead of 'setting'?\");\n+        \/\/ One additional character\n+        launch(\"-XX:StartFlightRecording:disk=false,paths-to-gc-roots=true,name=test\",\n+             \"Did you mean 'path-to-gc-roots' instead of 'paths-to-gc-roots'?\");\n+        \/\/ Incorrect case\n+        launch(\"-XX:StartFlightRecording:fileName=recording.jfr,disk=false\",\n+             \"Did you mean 'filename' instead of 'fileName'?\");\n+        \/\/ Two character spelling error in option with more than 6 characters\n+        launch(\"-XX:StartFlightRecording:name=wrong,filenaim=recording.jfr\",\n+             \"Did you mean 'filename' instead of 'filenaim'?\");\n+    }\n+\n+    private static void testUnknownOption() throws Exception {\n+        \/\/ Unknown .jfc option\n+        launch(\"-XX:StartFlightRecording:zebra=high\",\n+               \"The .jfc option\/setting 'zebra' doesn't exist.\");\n+        \/\/ Unknown event setting\n+        launch(\"-XX:StartFlightRecording:com.example.Hello#enabled=true\",\n+               \"The .jfc option\/setting 'com.example.Hello#enabled' doesn't exist.\");\n+    }\n+\n+    private static void launch(String commandLine, String expectedOutput) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(commandLine, \"-version\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldContain(expectedOutput);\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestJFCWarnings.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8255148\n+ * @library \/test\/lib \/javax\/net\/ssl\/templates ..\/..\/\n+ * @summary Checks for clarified exception messages for non-fatal SSLSocketImpl exceptions which\n+ *          can be ignored by the user\n+ * @run main IgnorableExceptionMessages\n+ *\/\n+\n+\/*\n+ * This test runs in another process so we can monitor the debug\n+ * results. The OutputAnalyzer must see correct debug output to return a\n+ * success.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import javax.net.ssl.SSLHandshakeException;\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.net.URL;\n+import java.util.List;\n+\n+public class IgnorableExceptionMessages extends SSLSocketTemplate {\n+    public static void main(String[] args) throws Exception {\n+        if (args.length > 0) {\n+            \/\/ A non-empty set of arguments occurs when the \"runTest\" argument\n+            \/\/ is passed to the test via ProcessTools::executeTestJvm.\n+            \/\/\n+            \/\/ This is done because an OutputAnalyzer is unable to read\n+            \/\/ the output of the current running JVM, and must therefore create\n+            \/\/ a test JVM. When this case occurs, it will inherit all specified\n+            \/\/ properties passed to the test JVM - debug flags, tls version, etc.\n+            new IgnorableExceptionMessages().run();\n+        } else {\n+            String clientTLSVersion = \"-Djdk.tls.client.protocols=TLSv1.2\";\n+            String javaxDebugFlag = \"-Djavax.net.debug=all\";\n+            String className = \"IgnorableExceptionMessages\";\n+            String extraArgument = \"runTest\"; \/\/ Triggers the test JVM to execute when args.length > 0\n+            List<String> jvmArgs = List.of(\n+                    clientTLSVersion,\n+                    javaxDebugFlag,\n+                    className,\n+                    extraArgument);\n+\n+            OutputAnalyzer output = ProcessTools.executeTestJvm(jvmArgs);\n+\n+            if (output.getExitValue() != 0) {\n+                output.asLines().forEach(System.out::println); \/\/ No need to dump the output unless the test fails\n+                throw new RuntimeException(\"Test JVM process failed\");\n+            }\n+\n+            try {\n+                output.shouldContain(\"SSLSocket duplex close failed. Debug info only. Exception details:\");\n+            } catch (Exception ex) {\n+                output.asLines().forEach(System.out::println); \/\/ No need to dump the output unless the test fails\n+                throw ex;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void runClientApplication(int serverPort) throws Exception {\n+        String urlString = \"https:\/\/localhost:\" + serverPort + \"\/\";\n+        URL url = new URL(urlString);\n+\n+        try {\n+            new BufferedReader(new InputStreamReader(url.openStream()));\n+            for(int i = 0; i < 10; i++) {\n+                Thread.sleep(1000);\n+                System.gc();\n+            }\n+        } catch (SSLHandshakeException sslEx) {\n+            System.out.println(sslEx.getCause());\n+            System.out.println(sslEx.getMessage());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/IgnorableExceptionMessages.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -47,0 +47,1 @@\n+import java.io.IOException;\n@@ -48,0 +49,2 @@\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n@@ -51,0 +54,1 @@\n+import java.util.Map;\n@@ -53,0 +57,1 @@\n+import java.util.stream.Stream;\n@@ -88,7 +93,13 @@\n-        if (isAcceptable) {\n-            result.shouldHaveExitValue(SUCCESS)\n-                  .shouldBeEmptyIgnoreVMWarnings();\n-        } else {\n-            result.shouldNotHaveExitValue(SUCCESS)\n-                    .shouldContain(\"contains a class with different api from earlier version\");\n-        }\n+\n+        String failureMessage = \"contains a class with different api from earlier version\";\n+        checkResult(result, isAcceptable, failureMessage);\n+        if (isAcceptable) result.shouldBeEmptyIgnoreVMWarnings();\n+\n+\n+        Path malformed = root.resolve(\"zip\").resolve(\"test.jar\");\n+        zip(malformed,\n+            Map.entry(\"\", classes.resolve(\"base\")),\n+            Map.entry(\"META-INF\/versions\/10\", classes.resolve(\"v10\")));\n+\n+        result = validateJar(malformed.toString(), isAcceptable, failureMessage);\n+        if (isAcceptable) result.shouldBeEmptyIgnoreVMWarnings();\n@@ -130,0 +141,2 @@\n+        String failureMessage = \"contains a class with different api from earlier version\";\n+\n@@ -134,1 +147,8 @@\n-                .shouldContain(\"contains a class with different api from earlier version\");\n+                .shouldContain(failureMessage);\n+\n+        Path malformed = root.resolve(\"zip\").resolve(\"test.jar\");\n+        zip(malformed,\n+            Map.entry(\"\", classes.resolve(\"base\")),\n+            Map.entry(\"META-INF\/versions\/10\", classes.resolve(\"v10\")));\n+\n+        validateJar(malformed.toString(), false, failureMessage);\n@@ -166,0 +186,1 @@\n+        validateJar(jarfile);\n@@ -170,0 +191,1 @@\n+        validateJar(jarfile);\n@@ -174,0 +196,1 @@\n+        validateJar(jarfile);\n@@ -204,0 +227,2 @@\n+        String failureMessage = \"incorrect name\";\n+\n@@ -208,1 +233,8 @@\n-                .shouldContain(\"incorrect name\");\n+                .shouldContain(failureMessage);\n+\n+        Path malformed = root.resolve(\"zip\").resolve(\"test.jar\");\n+        zip(malformed,\n+            Map.entry(\"\", classes.resolve(\"base\")),\n+            Map.entry(\"META-INF\/versions\/10\", classes.resolve(\"v10\")));\n+\n+        validateJar(malformed.toString(), false, failureMessage);\n@@ -214,0 +246,2 @@\n+        validateJar(jarfile);\n+\n@@ -217,1 +251,1 @@\n-                .shouldContain(\"incorrect name\");\n+                .shouldContain(failureMessage);\n@@ -236,0 +270,1 @@\n+        validateJar(jarfile);\n@@ -381,6 +416,8 @@\n-        if (expectSuccess) {\n-            output.shouldHaveExitValue(SUCCESS);\n-        } else {\n-            output.shouldNotHaveExitValue(SUCCESS)\n-                    .shouldContain(expectedMessage);\n-        }\n+        checkResult(output, expectSuccess, expectedMessage);\n+\n+        Path malformed = root.resolve(\"zip\").resolve(\"test.jar\");\n+        zip(malformed,\n+            Map.entry(\"\", classes.resolve(\"base\")),\n+            Map.entry(\"META-INF\/versions\/10\", classes.resolve(\"v10\")));\n+\n+        validateJar(malformed.toString(), expectSuccess, expectedMessage);\n@@ -420,0 +457,48 @@\n+\n+    @SafeVarargs\n+    private void zip(Path file, Map.Entry<String, Path>... copies) throws IOException {\n+        Files.createDirectories(file.getParent());\n+        Files.deleteIfExists(file);\n+        try (FileSystem zipfs = FileSystems.newFileSystem(file, Map.of(\"create\", \"true\"))) {\n+            for (var entry : copies) {\n+                Path dstDir = zipfs.getPath(entry.getKey());\n+                Path srcDir = entry.getValue();\n+\n+                Files.createDirectories(dstDir);\n+\n+                try (Stream<Path> stream = Files.walk(srcDir)) {\n+                    stream.filter(Files::isRegularFile).forEach(srcFile -> {\n+                        try {\n+                            Path relativePath = srcDir.relativize(srcFile);\n+                            Path dst = dstDir.resolve(relativePath.toString());\n+                            Path dstParent = dst.getParent();\n+                            if (dstParent != null)\n+                                Files.createDirectories(dstParent);\n+                            Files.copy(srcFile, dst);\n+                        } catch (IOException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    });\n+                }\n+            }\n+        }\n+    }\n+\n+    private static OutputAnalyzer checkResult(OutputAnalyzer result, boolean isAcceptable, String failureMessage) {\n+        if (isAcceptable) {\n+            result.shouldHaveExitValue(SUCCESS);\n+        } else {\n+            result.shouldNotHaveExitValue(SUCCESS)\n+                    .shouldContain(failureMessage);\n+        }\n+\n+        return result;\n+    }\n+\n+    private OutputAnalyzer validateJar(String jarFile) throws Throwable {\n+        return validateJar(jarFile, true, \"\");\n+    }\n+\n+    private OutputAnalyzer validateJar(String jarFile, boolean shouldSucceed, String failureMessage) throws Throwable {\n+        return checkResult(jar(\"--validate\", \"--file\", jarFile), shouldSucceed, failureMessage);\n+    }\n","filename":"test\/jdk\/tools\/jar\/multiRelease\/ApiValidatorTest.java","additions":101,"deletions":16,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -133,0 +133,3 @@\n+        if (Files.notExists(image)) {\n+            throw new RuntimeException(\"output directory should not have been deleted\");\n+        }\n","filename":"test\/jdk\/tools\/jlink\/JLinkNegativeTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+ * @bug 8240349\n@@ -369,0 +370,13 @@\n+        {\n+            String imageDir = \"bug8240349\";\n+            Path imagePath = helper.createNewImageDir(imageDir);\n+            JImageGenerator.getJLinkTask()\n+                    .modulePath(helper.defaultModulePath())\n+                    .output(imagePath)\n+                    .addMods(\"java.base\")\n+                    .option(\"--vm=client\")\n+                    .call().assertFailure(\"Error: Selected VM client doesn't exist\");\n+            if (!Files.notExists(imagePath)) {\n+                throw new RuntimeException(\"bug8240349 directory not deleted\");\n+            }\n+        }\n","filename":"test\/jdk\/tools\/jlink\/JLinkTest.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Functional.ThrowingConsumer;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.PackageType;\n+\n+\n+\/**\n+ * Test --about-url parameter in Linux installers. Output of the test should be\n+ * appabouturltest_1.0-1_amd64.deb or appabouturltest-1.0-1.amd64.rpm package\n+ * bundle. The output package should provide the same functionality as the\n+ * default package.\n+ *\n+ * deb:\n+ * Homepage property of the package should be set to http:\/\/foo.com value.\n+ *\n+ * rpm:\n+ * URL property of the package should be set to http:\/\/foo.com value.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary jpackage with --about-url\n+ * @library ..\/helpers\n+ * @key jpackagePlatformPackage\n+ * @build jdk.jpackage.test.*\n+ * @build AppAboutUrlTest\n+ * @requires (os.family == \"linux\")\n+ * @requires (jpackage.test.SQETest == null)\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=AppAboutUrlTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary jpackage with --about-url\n+ * @library ..\/helpers\n+ * @key jpackagePlatformPackage\n+ * @build jdk.jpackage.test.*\n+ * @build AppAboutUrlTest\n+ * @requires (os.family == \"linux\")\n+ * @requires (jpackage.test.SQETest != null)\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=AppAboutUrlTest.test\n+ *\/\n+public class AppAboutUrlTest {\n+\n+    @Test\n+    public static void test() {\n+        final String ABOUT_URL = \"http:\/\/foo.com\";\n+\n+        runTest(cmd -> {\n+            cmd.addArguments(\"--about-url\", ABOUT_URL);\n+        }, ABOUT_URL, ABOUT_URL);\n+    }\n+\n+    @Test\n+    public static void testDefaults() {\n+        runTest(JPackageCommand::setFakeRuntime, \"\", \"(none)\");\n+    }\n+\n+    private static void runTest(ThrowingConsumer<JPackageCommand> initializer,\n+            String expectedDebHomepage, String expectedRpmUrl) {\n+        new PackageTest()\n+                .forTypes(PackageType.LINUX)\n+                .configureHelloApp()\n+                .addInitializer(initializer)\n+                .forTypes(PackageType.LINUX_DEB)\n+                .addBundlePropertyVerifier(\"Homepage\", expectedDebHomepage)\n+                .forTypes(PackageType.LINUX_RPM)\n+                .addBundlePropertyVerifier(\"URL\", expectedRpmUrl)\n+                .run();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/linux\/AppAboutUrlTest.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Files;\n+import jdk.jpackage.test.HelloApp;\n+import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.Functional.ThrowingConsumer;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.Annotations.Test;\n+\n+\/*\n+ * @test\n+ * @summary jpackage test app can run after changing executable's extension\n+ * @library ..\/helpers\n+ * @key jpackagePlatformPackage\n+ * @build jdk.jpackage.test.*\n+ * @build WinRenameTest\n+ * @requires (os.family == \"windows\")\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=WinRenameTest\n+ *\/\n+public class WinRenameTest {\n+\n+    @Test\n+    public static void test() throws IOException {\n+        String javaAppDesc = \"com.hello\/com.hello.Hello\";\n+        JPackageCommand cmd = JPackageCommand.helloAppImage(javaAppDesc);\n+\n+        cmd.executeAndAssertImageCreated();\n+\n+        Path launcherPath = cmd.appLauncherPath();\n+        HelloApp.assertApp(launcherPath).executeAndVerifyOutput();\n+\n+        String lp = launcherPath.toString();\n+        TKit.assertTrue(lp.endsWith(\".exe\"), \"UNexpected launcher path: \" + lp);\n+\n+        Path newLauncherPath = Path.of(lp.replaceAll(\".exe\", \".anything\"));\n+        Files.move(launcherPath, newLauncherPath);\n+\n+        HelloApp.assertApp(newLauncherPath).executeAndVerifyOutput();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinRenameTest.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -314,0 +314,1 @@\n+        vmOptFinalFlag(map, \"UseVectorizedMismatchIntrinsic\");\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,3 +51,0 @@\n-tools\/javac\/processing\/options\/XprintRepeatingAnnotations.java                  8265611    generic-all    @compile\/ref comparison fails when noSecurityManager=true\n-tools\/javac\/processing\/options\/XprintDocComments.java                           8265611    generic-all    @compile\/ref comparison fails when noSecurityManager=true\n-tools\/javac\/processing\/model\/util\/printing\/module-info.java                     8265611    generic-all    @compile\/ref comparison fails when noSecurityManager=true\n","filename":"test\/langtools\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -270,1 +270,1 @@\n-                    <li><a href=\"#for-removal\">For Removal<\/a><\/li>\n+                    <li><a href=\"#for-removal\">Terminally Deprecated<\/a><\/li>\n@@ -284,1 +284,1 @@\n-                    <div class=\"caption\"><span>For Removal<\/span><\/div>\n+                    <div class=\"caption\"><span>Terminally Deprecated Elements<\/span><\/div>\n@@ -290,1 +290,1 @@\n-                    <div class=\"caption\"><span>Enum Classes<\/span><\/div>\n+                    <div class=\"caption\"><span>Deprecated Enum Classes<\/span><\/div>\n@@ -300,1 +300,1 @@\n-                    <div class=\"caption\"><span>Exceptions<\/span><\/div>\n+                    <div class=\"caption\"><span>Deprecated Exceptions<\/span><\/div>\n@@ -310,1 +310,1 @@\n-                    <div class=\"caption\"><span>Fields<\/span><\/div>\n+                    <div class=\"caption\"><span>Deprecated Fields<\/span><\/div>\n@@ -340,1 +340,1 @@\n-                    <div class=\"caption\"><span>Methods<\/span><\/div>\n+                    <div class=\"caption\"><span>Deprecated Methods<\/span><\/div>\n@@ -368,1 +368,1 @@\n-                    <div class=\"caption\"><span>Constructors<\/span><\/div>\n+                    <div class=\"caption\"><span>Deprecated Constructors<\/span><\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDeprecatedDocs\/TestDeprecatedDocs.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-                    This is a note\n+                    Note: This is a note\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDiagsLineCaret\/TestDiagsLineCaret.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-                    <div class=\"caption\"><span>Methods<\/span><\/div>\n+                    <div class=\"caption\"><span>Deprecated Methods<\/span><\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlTableStyles\/TestHtmlTableStyles.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -426,1 +426,1 @@\n-                    <div class=\"caption\"><span>Fields<\/span><\/div>\"\"\",\n+                    <div class=\"caption\"><span>Deprecated Fields<\/span><\/div>\"\"\",\n@@ -428,1 +428,1 @@\n-                    <div class=\"caption\"><span>Methods<\/span><\/div>\"\"\");\n+                    <div class=\"caption\"><span>Deprecated Methods<\/span><\/div>\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlTableTags\/TestHtmlTableTags.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1114,1 +1114,1 @@\n-                    <li><a href=\"#for-removal\">For Removal<\/a><\/li>\n+                    <li><a href=\"#for-removal\">Terminally Deprecated<\/a><\/li>\n@@ -1442,1 +1442,1 @@\n-                    {\"l\":\"All Classes\",\"u\":\"allclasses-index.html\"}\"\"\");\n+                    {\"l\":\"All Classes and Interfaces\",\"u\":\"allclasses-index.html\"}\"\"\");\n@@ -1448,2 +1448,3 @@\n-                    <br><a href=\"allclasses-index.html\">All&nbsp;Classes<\/a><span class=\"vertical-se\\\n-                    parator\">|<\/span><a href=\"allpackages-index.html\">All&nbsp;Packages<\/a>\"\"\");\n+                    <br><a href=\"allclasses-index.html\">All&nbsp;Classes&nbsp;and&nbsp;Interfaces<\/a\\\n+                    ><span class=\"vertical-separator\">|<\/span><a href=\"allpackages-index.html\">All&n\\\n+                    bsp;Packages<\/a>\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testModules\/TestModules.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,884 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8263468\n+ * @summary  New page for \"recent\" new API\n+ * @library  ..\/..\/lib\n+ * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    javadoc.tester.*\n+ * @run main TestNewApiList\n+ *\/\n+\n+import javadoc.tester.JavadocTester;\n+\n+\/**\n+ * Test --since option and \"New API\" list.\n+ *\/\n+public class TestNewApiList extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        TestNewApiList test = new TestNewApiList();\n+        test.runTests();\n+    }\n+\n+    @Test\n+    public void testMultiRelease() throws Exception {\n+        javadoc(\"-d\", \"out-multi\",\n+                \"--no-platform-links\",\n+                \"--module-source-path\", testSrc,\n+                \"--since\", \"0.9,v1.0,1.2,2.0b,3.2,5\",\n+                \"--since-label\", \"New API in recent releases\",\n+                \"--module\", \"mdl\",\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkMultiReleaseContents();\n+        checkMultiReleaseNewElements();\n+        checkMultiReleaseDeprecatedElements();\n+    }\n+\n+    @Test\n+    public void testSingleRelease() throws Exception {\n+        javadoc(\"-d\", \"out-single\",\n+                \"--no-platform-links\",\n+                \"--module-source-path\", testSrc,\n+                \"--since\", \"5\",\n+                \"--module\", \"mdl\",\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkSingleReleaseContents();\n+        checkSingleReleaseNewElements();\n+        checkSingleReleaseDeprecatedElements();\n+    }\n+\n+    @Test\n+    public void testPackage() throws Exception {\n+        javadoc(\"-d\", \"out-package\",\n+                \"--no-platform-links\",\n+                \"-sourcepath\", testSrc,\n+                \"--since\", \"1.2,2.0b,3.2,5,6\",\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkPackageContents();\n+        checkPackageNewElements();\n+        checkPackageDeprecatedElements();\n+    }\n+\n+    @Test\n+    public void testNoList() throws Exception {\n+        javadoc(\"-d\", \"out-none\",\n+                \"--no-platform-links\",\n+                \"--module-source-path\", testSrc,\n+                \"--since\", \"foo,bar\",\n+                \"--since-label\", \"New API in foo and bar\",\n+                \"--module\", \"mdl\",\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkFiles(false, \"new-list.html\");\n+    }\n+\n+    private void checkMultiReleaseContents() {\n+        checkOutput(\"new-list.html\", true,\n+            \"\"\"\n+                <h1 title=\"New API in recent releases\" class=\"title\">New API in recent releases<\/h1>\n+                <h2 title=\"Contents\">Contents<\/h2>\n+                <ul>\n+                <li><a href=\"#module\">Modules<\/a><\/li>\n+                <li><a href=\"#package\">Packages<\/a><\/li>\n+                <li><a href=\"#interface\">Interfaces<\/a><\/li>\n+                <li><a href=\"#class\">Classes<\/a><\/li>\n+                <li><a href=\"#enum-class\">Enum Classes<\/a><\/li>\n+                <li><a href=\"#exception\">Exceptions<\/a><\/li>\n+                <li><a href=\"#error\">Errors<\/a><\/li>\n+                <li><a href=\"#record-class\">Record Classes<\/a><\/li>\n+                <li><a href=\"#annotation-interface\">Annotation Interfaces<\/a><\/li>\n+                <li><a href=\"#field\">Fields<\/a><\/li>\n+                <li><a href=\"#method\">Methods<\/a><\/li>\n+                <li><a href=\"#constructor\">Constructors<\/a><\/li>\n+                <li><a href=\"#enum-constant\">Enum Constants<\/a><\/li>\n+                <li><a href=\"#annotation-interface-member\">Annotation Interface Elements<\/a><\/li>\n+                <\/ul>\n+                <\/div>\n+                <span class=\"help-note\">(The leftmost tab \"New ...\" indicates all the new elements, \\\n+                regardless of the releases in which they were added. Each of the other tabs \"Added i\\\n+                n ...\" indicates the new elements added in a specific release. Any element shown und\\\n+                er the leftmost tab is also shown under one of the righthand tabs.)<\/span>\"\"\");\n+    }\n+\n+    private void checkMultiReleaseNewElements() {\n+        checkOutput(\"new-list.html\", true,\n+            \"\"\"\n+                <div id=\"module\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"mod\\\n+                ule-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"module.tabpanel\" tabindex=\"\\\n+                0\" onkeydown=\"switchTab(event)\" onclick=\"show('module', 'module', 2)\" class=\"active-\\\n+                table-tab\">New Modules<\/button><button id=\"module-tab2\" role=\"tab\" aria-selected=\"fa\\\n+                lse\" aria-controls=\"module.tabpanel\" tabindex=\"-1\" onkeydown=\"switchTab(event)\" oncl\\\n+                ick=\"show('module', 'module-tab2', 2)\" class=\"table-tab\">Added in 3.2<\/button><\/div>\n+                <div id=\"module.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"module-tab0\">\n+                <div class=\"table-header col-first\">Module<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color module module-tab2\"><a href=\"mdl\/module-summary.html\">mdl<\/a><\/div>\n+                <div class=\"col-last even-row-color module module-tab2\">\n+                <div class=\"block\">Module mdl.<\/div>\n+                <\/div>\"\"\",\n+            \"\"\"\n+                <div id=\"package\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"pac\\\n+                kage-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"package.tabpanel\" tabindex\\\n+                =\"0\" onkeydown=\"switchTab(event)\" onclick=\"show('package', 'package', 2)\" class=\"act\\\n+                ive-table-tab\">New Packages<\/button><button id=\"package-tab5\" role=\"tab\" aria-select\\\n+                ed=\"false\" aria-controls=\"package.tabpanel\" tabindex=\"-1\" onkeydown=\"switchTab(event\\\n+                )\" onclick=\"show('package', 'package-tab5', 2)\" class=\"table-tab\">Added in v1.0<\/but\\\n+                ton><\/div>\n+                <div id=\"package.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"package-tab0\">\n+                <div class=\"table-header col-first\">Package<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color package package-tab5\"><a href=\"mdl\/pkg\/package-summary.html\">pkg<\/a><\/div>\n+                <div class=\"col-last even-row-color package package-tab5\">\n+                <div class=\"block\">Package pkg.<\/div>\n+                <\/div>\"\"\",\n+            \"\"\"\n+                <div id=\"interface\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"int\\\n+                erface-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"interface.tabpanel\" tabi\\\n+                ndex=\"0\" onkeydown=\"switchTab(event)\" onclick=\"show('interface', 'interface', 2)\" cl\\\n+                ass=\"active-table-tab\">New Interfaces<\/button><button id=\"interface-tab6\" role=\"tab\"\\\n+                 aria-selected=\"false\" aria-controls=\"interface.tabpanel\" tabindex=\"-1\" onkeydown=\"s\\\n+                witchTab(event)\" onclick=\"show('interface', 'interface-tab6', 2)\" class=\"table-tab\">\\\n+                Added in 0.9<\/button><\/div>\n+                <div id=\"interface.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"interface-tab0\">\n+                <div class=\"table-header col-first\">Interface<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color interface interface-tab6\"><a href=\"\\\n+                mdl\/pkg\/TestInterface.html\" title=\"interface in pkg\">pkg.TestInterface<\/a><\/div>\n+                <div class=\"col-last even-row-color interface interface-tab6\">\n+                <div class=\"block\">Test interface.<\/div>\n+                <\/div>\"\"\",\n+            \"\"\"\n+                <div id=\"class\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"cla\\\n+                ss-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"class.tabpanel\" tabindex=\"0\"\\\n+                 onkeydown=\"switchTab(event)\" onclick=\"show('class', 'class', 2)\" class=\"active-tabl\\\n+                e-tab\">New Classes<\/button><button id=\"class-tab4\" role=\"tab\" aria-selected=\"false\" \\\n+                aria-controls=\"class.tabpanel\" tabindex=\"-1\" onkeydown=\"switchTab(event)\" onclick=\"s\\\n+                how('class', 'class-tab4', 2)\" class=\"table-tab\">Added in 1.2<\/button><\/div>\n+                <div id=\"class.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"class-tab0\">\n+                <div class=\"table-header col-first\">Class<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color class class-tab4\"><a href=\"mdl\/pkg\/\\\n+                TestClass.html\" title=\"class in pkg\">pkg.TestClass<\/a><\/div>\n+                <div class=\"col-last even-row-color class class-tab4\">\n+                <div class=\"block\">TestClass declaration.<\/div>\n+                <\/div>\"\"\",\n+            \"\"\"\n+                <div id=\"enum-class\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"enu\\\n+                m-class-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"enum-class.tabpanel\" ta\\\n+                bindex=\"0\" onkeydown=\"switchTab(event)\" onclick=\"show('enum-class', 'enum-class', 2)\\\n+                \" class=\"active-table-tab\">New Enum Classes<\/button><button id=\"enum-class-tab6\" rol\\\n+                e=\"tab\" aria-selected=\"false\" aria-controls=\"enum-class.tabpanel\" tabindex=\"-1\" onke\\\n+                ydown=\"switchTab(event)\" onclick=\"show('enum-class', 'enum-class-tab6', 2)\" class=\"t\\\n+                able-tab\">Added in 0.9<\/button><\/div>\n+                <div id=\"enum-class.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"enum-class-tab0\">\n+                <div class=\"table-header col-first\">Enum Class<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color enum-class enum-class-tab6\"><a href\\\n+                =\"mdl\/pkg\/TestEnum.html\" title=\"enum class in pkg\">pkg.TestEnum<\/a><\/div>\n+                <div class=\"col-last even-row-color enum-class enum-class-tab6\">\n+                <div class=\"block\">Test enum class.<\/div>\n+                <\/div>\"\"\",\n+            \"\"\"\n+                <div id=\"exception\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"exc\\\n+                eption-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"exception.tabpanel\" tabi\\\n+                ndex=\"0\" onkeydown=\"switchTab(event)\" onclick=\"show('exception', 'exception', 2)\" cl\\\n+                ass=\"active-table-tab\">New Exceptions<\/button><button id=\"exception-tab6\" role=\"tab\"\\\n+                 aria-selected=\"false\" aria-controls=\"exception.tabpanel\" tabindex=\"-1\" onkeydown=\"s\\\n+                witchTab(event)\" onclick=\"show('exception', 'exception-tab6', 2)\" class=\"table-tab\">\\\n+                Added in 0.9<\/button><\/div>\n+                <div id=\"exception.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"exception-tab0\">\n+                <div class=\"table-header col-first\">Exceptions<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color exception exception-tab6\"><a href=\"\\\n+                mdl\/pkg\/TestException.html\" title=\"class in pkg\">pkg.TestException<\/a><\/div>\n+                <div class=\"col-last even-row-color exception exception-tab6\">\n+                <div class=\"block\">Test exception class.<\/div>\n+                <\/div>\"\"\",\n+            \"\"\"\n+                <div id=\"error\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"err\\\n+                or-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"error.tabpanel\" tabindex=\"0\"\\\n+                 onkeydown=\"switchTab(event)\" onclick=\"show('error', 'error', 2)\" class=\"active-tabl\\\n+                e-tab\">New Errors<\/button><button id=\"error-tab3\" role=\"tab\" aria-selected=\"false\" a\\\n+                ria-controls=\"error.tabpanel\" tabindex=\"-1\" onkeydown=\"switchTab(event)\" onclick=\"sh\\\n+                ow('error', 'error-tab3', 2)\" class=\"table-tab\">Added in 2.0b<\/button><\/div>\n+                <div id=\"error.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"error-tab0\">\n+                <div class=\"table-header col-first\">Errors<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color error error-tab3\"><a href=\"mdl\/pkg\/\\\n+                TestError.html\" title=\"class in pkg\">pkg.TestError<\/a><\/div>\n+                <div class=\"col-last even-row-color error error-tab3\">\n+                <div class=\"block\">Test error class.<\/div>\n+                <\/div>\"\"\",\n+            \"\"\"\n+                <div id=\"record-class\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"rec\\\n+                ord-class-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"record-class.tabpanel\\\n+                \" tabindex=\"0\" onkeydown=\"switchTab(event)\" onclick=\"show('record-class', 'record-cl\\\n+                ass', 2)\" class=\"active-table-tab\">New Record Classes<\/button><button id=\"record-cla\\\n+                ss-tab2\" role=\"tab\" aria-selected=\"false\" aria-controls=\"record-class.tabpanel\" tabi\\\n+                ndex=\"-1\" onkeydown=\"switchTab(event)\" onclick=\"show('record-class', 'record-class-t\\\n+                ab2', 2)\" class=\"table-tab\">Added in 3.2<\/button><\/div>\n+                <div id=\"record-class.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"record-class-tab0\">\n+                <div class=\"table-header col-first\">Record Class<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color record-class record-class-tab2\"><a \\\n+                href=\"mdl\/pkg\/TestRecord.html\" title=\"class in pkg\">pkg.TestRecord<\/a><\/div>\n+                <div class=\"col-last even-row-color record-class record-class-tab2\">\n+                <div class=\"block\">Test record.<\/div>\n+                <\/div>\"\"\",\n+            \"\"\"\n+                <div id=\"annotation-interface\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"ann\\\n+                otation-interface-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"annotation-in\\\n+                terface.tabpanel\" tabindex=\"0\" onkeydown=\"switchTab(event)\" onclick=\"show('annotatio\\\n+                n-interface', 'annotation-interface', 2)\" class=\"active-table-tab\">New Annotation In\\\n+                terfaces<\/button><button id=\"annotation-interface-tab3\" role=\"tab\" aria-selected=\"fa\\\n+                lse\" aria-controls=\"annotation-interface.tabpanel\" tabindex=\"-1\" onkeydown=\"switchTa\\\n+                b(event)\" onclick=\"show('annotation-interface', 'annotation-interface-tab3', 2)\" cla\\\n+                ss=\"table-tab\">Added in 2.0b<\/button><\/div>\n+                <div id=\"annotation-interface.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"annotation-interface-tab0\">\n+                <div class=\"table-header col-first\">Annotation Interface<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color annotation-interface annotation-int\\\n+                erface-tab3\"><a href=\"mdl\/pkg\/TestAnnotation.html\" title=\"annotation interface in pk\\\n+                g\">pkg.TestAnnotation<\/a><\/div>\n+                <div class=\"col-last even-row-color annotation-interface annotation-interface-tab3\">\n+                <div class=\"block\">An annotation interface.<\/div>\n+                <\/div>\"\"\",\n+            \"\"\"\n+                <div id=\"field\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"fie\\\n+                ld-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"field.tabpanel\" tabindex=\"0\"\\\n+                 onkeydown=\"switchTab(event)\" onclick=\"show('field', 'field', 2)\" class=\"active-tabl\\\n+                e-tab\">New Fields<\/button><button id=\"field-tab2\" role=\"tab\" aria-selected=\"false\" a\\\n+                ria-controls=\"field.tabpanel\" tabindex=\"-1\" onkeydown=\"switchTab(event)\" onclick=\"sh\\\n+                ow('field', 'field-tab2', 2)\" class=\"table-tab\">Added in 3.2<\/button><button id=\"fie\\\n+                ld-tab3\" role=\"tab\" aria-selected=\"false\" aria-controls=\"field.tabpanel\" tabindex=\"-\\\n+                1\" onkeydown=\"switchTab(event)\" onclick=\"show('field', 'field-tab3', 2)\" class=\"tabl\\\n+                e-tab\">Added in 2.0b<\/button><button id=\"field-tab4\" role=\"tab\" aria-selected=\"false\\\n+                \" aria-controls=\"field.tabpanel\" tabindex=\"-1\" onkeydown=\"switchTab(event)\" onclick=\\\n+                \"show('field', 'field-tab4', 2)\" class=\"table-tab\">Added in 1.2<\/button><button id=\"\\\n+                field-tab5\" role=\"tab\" aria-selected=\"false\" aria-controls=\"field.tabpanel\" tabindex\\\n+                =\"-1\" onkeydown=\"switchTab(event)\" onclick=\"show('field', 'field-tab5', 2)\" class=\"t\\\n+                able-tab\">Added in v1.0<\/button><\/div>\n+                <div id=\"field.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"field-tab0\">\n+                <div class=\"table-header col-first\">Field<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color field field-tab4\"><a href=\"mdl\/pkg\/\\\n+                TestClass.html#field\">pkg.TestClass.field<\/a><\/div>\n+                <div class=\"col-last even-row-color field field-tab4\">\n+                <div class=\"block\">TestClass field.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name odd-row-color field field-tab5\"><a href=\"mdl\/pkg\/T\\\n+                estError.html#field\">pkg.TestError.field<\/a><\/div>\n+                <div class=\"col-last odd-row-color field field-tab5\">\n+                <div class=\"block\">Test error field.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name even-row-color field field-tab2\"><a href=\"mdl\/pkg\/\\\n+                TestException.html#field\">pkg.TestException.field<\/a><\/div>\n+                <div class=\"col-last even-row-color field field-tab2\">\n+                <div class=\"block\">Exception field.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name odd-row-color field field-tab3\"><a href=\"mdl\/pkg\/T\\\n+                estInterface.html#field\">pkg.TestInterface.field<\/a><\/div>\n+                <div class=\"col-last odd-row-color field field-tab3\">\n+                <div class=\"block\">Test interface field.<\/div>\n+                <\/div>\"\"\",\n+            \"\"\"\n+                <div id=\"method\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"met\\\n+                hod-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"method.tabpanel\" tabindex=\"\\\n+                0\" onkeydown=\"switchTab(event)\" onclick=\"show('method', 'method', 2)\" class=\"active-\\\n+                table-tab\">New Methods<\/button><button id=\"method-tab1\" role=\"tab\" aria-selected=\"fa\\\n+                lse\" aria-controls=\"method.tabpanel\" tabindex=\"-1\" onkeydown=\"switchTab(event)\" oncl\\\n+                ick=\"show('method', 'method-tab1', 2)\" class=\"table-tab\">Added in 5<\/button><button \\\n+                id=\"method-tab2\" role=\"tab\" aria-selected=\"false\" aria-controls=\"method.tabpanel\" ta\\\n+                bindex=\"-1\" onkeydown=\"switchTab(event)\" onclick=\"show('method', 'method-tab2', 2)\" \\\n+                class=\"table-tab\">Added in 3.2<\/button><button id=\"method-tab3\" role=\"tab\" aria-sele\\\n+                cted=\"false\" aria-controls=\"method.tabpanel\" tabindex=\"-1\" onkeydown=\"switchTab(even\\\n+                t)\" onclick=\"show('method', 'method-tab3', 2)\" class=\"table-tab\">Added in 2.0b<\/butt\\\n+                on><button id=\"method-tab4\" role=\"tab\" aria-selected=\"false\" aria-controls=\"method.t\\\n+                abpanel\" tabindex=\"-1\" onkeydown=\"switchTab(event)\" onclick=\"show('method', 'method-\\\n+                tab4', 2)\" class=\"table-tab\">Added in 1.2<\/button><button id=\"method-tab5\" role=\"tab\\\n+                \" aria-selected=\"false\" aria-controls=\"method.tabpanel\" tabindex=\"-1\" onkeydown=\"swi\\\n+                tchTab(event)\" onclick=\"show('method', 'method-tab5', 2)\" class=\"table-tab\">Added in\\\n+                 v1.0<\/button><\/div>\n+                <div id=\"method.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"method-tab0\">\n+                <div class=\"table-header col-first\">Method<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color method method-tab2\"><a href=\"mdl\/pk\\\n+                g\/TestAnnotation.html#optional()\">pkg.TestAnnotation.optional()<\/a><\/div>\n+                <div class=\"col-last even-row-color method method-tab2\">\n+                <div class=\"block\">Optional annotation interface element.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name odd-row-color method method-tab3\"><a href=\"mdl\/pkg\\\n+                \/TestAnnotation.html#required()\">pkg.TestAnnotation.required()<\/a><\/div>\n+                <div class=\"col-last odd-row-color method method-tab3\">\n+                <div class=\"block\">Required annotation interface element.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name even-row-color method method-tab3\"><a href=\"mdl\/pk\\\n+                g\/TestClass.html#method()\">pkg.TestClass.method()<\/a><\/div>\n+                <div class=\"col-last even-row-color method method-tab3\">\n+                <div class=\"block\">TestClass method.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name odd-row-color method method-tab1\"><a href=\"mdl\/pkg\\\n+                \/TestClass.html#overloadedMethod(java.lang.String)\">pkg.TestClass.overloadedMethod<w\\\n+                br>(String)<\/a><\/div>\n+                <div class=\"col-last odd-row-color method method-tab1\">\n+                <div class=\"block\">TestClass overloaded method.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name even-row-color method method-tab2\"><a href=\"mdl\/pk\\\n+                g\/TestError.html#method()\">pkg.TestError.method()<\/a><\/div>\n+                <div class=\"col-last even-row-color method method-tab2\">\n+                <div class=\"block\">Test error method.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name odd-row-color method method-tab4\"><a href=\"mdl\/pkg\\\n+                \/TestException.html#method()\">pkg.TestException.method()<\/a><\/div>\n+                <div class=\"col-last odd-row-color method method-tab4\">\n+                <div class=\"block\">Exception method.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name even-row-color method method-tab5\"><a href=\"mdl\/pk\\\n+                g\/TestInterface.html#method1()\">pkg.TestInterface.method1()<\/a><\/div>\n+                <div class=\"col-last even-row-color method method-tab5\">\n+                <div class=\"block\">Interface method.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name odd-row-color method method-tab2\"><a href=\"mdl\/pkg\\\n+                \/TestInterface.html#method2(java.lang.Class)\">pkg.TestInterface.method2<wbr>(Class&l\\\n+                t;?&gt;)<\/a><\/div>\n+                <div class=\"col-last odd-row-color method method-tab2\">\n+                <div class=\"block\">Interface method.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name even-row-color method method-tab1\"><a href=\"mdl\/pk\\\n+                g\/TestRecord.html#x()\">pkg.TestRecord.x()<\/a><\/div>\n+                <div class=\"col-last even-row-color method method-tab1\">\n+                <div class=\"block\">Test record getter.<\/div>\n+                <\/div>\"\"\",\n+            \"\"\"\n+                <div id=\"constructor\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"con\\\n+                structor-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"constructor.tabpanel\" \\\n+                tabindex=\"0\" onkeydown=\"switchTab(event)\" onclick=\"show('constructor', 'constructor'\\\n+                , 2)\" class=\"active-table-tab\">New Constructors<\/button><button id=\"constructor-tab1\\\n+                \" role=\"tab\" aria-selected=\"false\" aria-controls=\"constructor.tabpanel\" tabindex=\"-1\\\n+                \" onkeydown=\"switchTab(event)\" onclick=\"show('constructor', 'constructor-tab1', 2)\" \\\n+                class=\"table-tab\">Added in 5<\/button><button id=\"constructor-tab2\" role=\"tab\" aria-s\\\n+                elected=\"false\" aria-controls=\"constructor.tabpanel\" tabindex=\"-1\" onkeydown=\"switch\\\n+                Tab(event)\" onclick=\"show('constructor', 'constructor-tab2', 2)\" class=\"table-tab\">A\\\n+                dded in 3.2<\/button><button id=\"constructor-tab3\" role=\"tab\" aria-selected=\"false\" a\\\n+                ria-controls=\"constructor.tabpanel\" tabindex=\"-1\" onkeydown=\"switchTab(event)\" oncli\\\n+                ck=\"show('constructor', 'constructor-tab3', 2)\" class=\"table-tab\">Added in 2.0b<\/but\\\n+                ton><\/div>\n+                <div id=\"constructor.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"constructor-tab0\">\n+                <div class=\"table-header col-first\">Constructor<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color constructor constructor-tab3\"><a hr\\\n+                ef=\"mdl\/pkg\/TestClass.html#%3Cinit%3E()\">pkg.TestClass()<\/a><\/div>\n+                <div class=\"col-last even-row-color constructor constructor-tab3\">\n+                <div class=\"block\">TestClass constructor.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name odd-row-color constructor constructor-tab2\"><a hre\\\n+                f=\"mdl\/pkg\/TestClass.html#%3Cinit%3E(java.lang.String)\">pkg.TestClass<wbr>(String)<\/\\\n+                a><\/div>\n+                <div class=\"col-last odd-row-color constructor constructor-tab2\">\n+                <div class=\"block\">TestClass constructor.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name even-row-color constructor constructor-tab1\"><a hr\\\n+                ef=\"mdl\/pkg\/TestError.html#%3Cinit%3E()\">pkg.TestError()<\/a><\/div>\n+                <div class=\"col-last even-row-color constructor constructor-tab1\">\n+                <div class=\"block\">Test error constructor.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name odd-row-color constructor constructor-tab1\"><a hre\\\n+                f=\"mdl\/pkg\/TestException.html#%3Cinit%3E()\">pkg.TestException()<\/a><\/div>\n+                <div class=\"col-last odd-row-color constructor constructor-tab1\">\n+                <div class=\"block\">Exception constructor.<\/div>\n+                <\/div>\"\"\",\n+            \"\"\"\n+                <div id=\"enum-constant\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"enu\\\n+                m-constant-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"enum-constant.tabpan\\\n+                el\" tabindex=\"0\" onkeydown=\"switchTab(event)\" onclick=\"show('enum-constant', 'enum-c\\\n+                onstant', 2)\" class=\"active-table-tab\">New Enum Constants<\/button><button id=\"enum-c\\\n+                onstant-tab2\" role=\"tab\" aria-selected=\"false\" aria-controls=\"enum-constant.tabpanel\\\n+                \" tabindex=\"-1\" onkeydown=\"switchTab(event)\" onclick=\"show('enum-constant', 'enum-co\\\n+                nstant-tab2', 2)\" class=\"table-tab\">Added in 3.2<\/button><button id=\"enum-constant-t\\\n+                ab4\" role=\"tab\" aria-selected=\"false\" aria-controls=\"enum-constant.tabpanel\" tabinde\\\n+                x=\"-1\" onkeydown=\"switchTab(event)\" onclick=\"show('enum-constant', 'enum-constant-ta\\\n+                b4', 2)\" class=\"table-tab\">Added in 1.2<\/button><button id=\"enum-constant-tab5\" role\\\n+                =\"tab\" aria-selected=\"false\" aria-controls=\"enum-constant.tabpanel\" tabindex=\"-1\" on\\\n+                keydown=\"switchTab(event)\" onclick=\"show('enum-constant', 'enum-constant-tab5', 2)\" \\\n+                class=\"table-tab\">Added in v1.0<\/button><button id=\"enum-constant-tab6\" role=\"tab\" a\\\n+                ria-selected=\"false\" aria-controls=\"enum-constant.tabpanel\" tabindex=\"-1\" onkeydown=\\\n+                \"switchTab(event)\" onclick=\"show('enum-constant', 'enum-constant-tab6', 2)\" class=\"t\\\n+                able-tab\">Added in 0.9<\/button><\/div>\n+                <div id=\"enum-constant.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"enum-constant-tab0\">\n+                <div class=\"table-header col-first\">Enum Constant<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color enum-constant enum-constant-tab2\"><\\\n+                a href=\"mdl\/pkg\/TestEnum.html#DEPRECATED\">pkg.TestEnum.DEPRECATED<\/a><\/div>\n+                <div class=\"col-last even-row-color enum-constant enum-constant-tab2\">\n+                <div class=\"block\">Deprecated.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name odd-row-color enum-constant enum-constant-tab6\"><a\\\n+                 href=\"mdl\/pkg\/TestEnum.html#ONE\">pkg.TestEnum.ONE<\/a><\/div>\n+                <div class=\"col-last odd-row-color enum-constant enum-constant-tab6\">\n+                <div class=\"block\">One.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name even-row-color enum-constant enum-constant-tab4\"><\\\n+                a href=\"mdl\/pkg\/TestEnum.html#THREE\">pkg.TestEnum.THREE<\/a><\/div>\n+                <div class=\"col-last even-row-color enum-constant enum-constant-tab4\">\n+                <div class=\"block\">Three.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name odd-row-color enum-constant enum-constant-tab5\"><a\\\n+                 href=\"mdl\/pkg\/TestEnum.html#TWO\">pkg.TestEnum.TWO<\/a><\/div>\n+                <div class=\"col-last odd-row-color enum-constant enum-constant-tab5\">\n+                <div class=\"block\">Two.<\/div>\n+                <\/div>\"\"\",\n+            \"\"\"\n+                <div id=\"annotation-interface-member\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"ann\\\n+                otation-interface-member-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"annota\\\n+                tion-interface-member.tabpanel\" tabindex=\"0\" onkeydown=\"switchTab(event)\" onclick=\"s\\\n+                how('annotation-interface-member', 'annotation-interface-member', 2)\" class=\"active-\\\n+                table-tab\">New Annotation Interface Elements<\/button><button id=\"annotation-interfac\\\n+                e-member-tab2\" role=\"tab\" aria-selected=\"false\" aria-controls=\"annotation-interface-\\\n+                member.tabpanel\" tabindex=\"-1\" onkeydown=\"switchTab(event)\" onclick=\"show('annotatio\\\n+                n-interface-member', 'annotation-interface-member-tab2', 2)\" class=\"table-tab\">Added\\\n+                 in 3.2<\/button><button id=\"annotation-interface-member-tab3\" role=\"tab\" aria-select\\\n+                ed=\"false\" aria-controls=\"annotation-interface-member.tabpanel\" tabindex=\"-1\" onkeyd\\\n+                own=\"switchTab(event)\" onclick=\"show('annotation-interface-member', 'annotation-inte\\\n+                rface-member-tab3', 2)\" class=\"table-tab\">Added in 2.0b<\/button><\/div>\n+                <div id=\"annotation-interface-member.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"annotation-interface-member-tab0\">\n+                <div class=\"table-header col-first\">Annotation Interface Element<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color annotation-interface-member annotat\\\n+                ion-interface-member-tab2\"><a href=\"mdl\/pkg\/TestAnnotation.html#optional()\">pkg.Test\\\n+                Annotation.optional()<\/a><\/div>\n+                <div class=\"col-last even-row-color annotation-interface-member annotation-interface-member-tab2\">\n+                <div class=\"block\">Optional annotation interface element.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name odd-row-color annotation-interface-member annotati\\\n+                on-interface-member-tab3\"><a href=\"mdl\/pkg\/TestAnnotation.html#required()\">pkg.TestA\\\n+                nnotation.required()<\/a><\/div>\n+                <div class=\"col-last odd-row-color annotation-interface-member annotation-interface-member-tab3\">\n+                <div class=\"block\">Required annotation interface element.<\/div>\n+                <\/div>\"\"\");\n+    }\n+\n+    private void checkMultiReleaseDeprecatedElements() {\n+        checkOutput(\"deprecated-list.html\", true,\n+            \"\"\"\n+                <div id=\"for-removal\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"for\\\n+                -removal-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"for-removal.tabpanel\" \\\n+                tabindex=\"0\" onkeydown=\"switchTab(event)\" onclick=\"show('for-removal', 'for-removal'\\\n+                , 2)\" class=\"active-table-tab\">Terminally Deprecated Elements<\/button><button id=\"fo\\\n+                r-removal-tab1\" role=\"tab\" aria-selected=\"false\" aria-controls=\"for-removal.tabpanel\\\n+                \" tabindex=\"-1\" onkeydown=\"switchTab(event)\" onclick=\"show('for-removal', 'for-remov\\\n+                al-tab1', 2)\" class=\"table-tab\">Terminally Deprecated in 5<\/button><\/div>\n+                <div id=\"for-removal.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"for-removal-tab0\">\n+                <div class=\"table-header col-first\">Element<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color for-removal for-removal-tab1\"><a hr\\\n+                ef=\"mdl\/pkg\/TestAnnotation.html#required()\">pkg.TestAnnotation.required()<\/a><\/div>\n+                <div class=\"col-last even-row-color for-removal for-removal-tab1\"><\/div>\n+                <\/div>\"\"\",\n+            \"\"\"\n+                <div id=\"method\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"met\\\n+                hod-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"method.tabpanel\" tabindex=\"\\\n+                0\" onkeydown=\"switchTab(event)\" onclick=\"show('method', 'method', 2)\" class=\"active-\\\n+                table-tab\">Deprecated Methods<\/button><button id=\"method-tab1\" role=\"tab\" aria-selec\\\n+                ted=\"false\" aria-controls=\"method.tabpanel\" tabindex=\"-1\" onkeydown=\"switchTab(event\\\n+                )\" onclick=\"show('method', 'method-tab1', 2)\" class=\"table-tab\">Deprecated in 5<\/but\\\n+                ton><\/div>\n+                <div id=\"method.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"method-tab0\">\n+                <div class=\"table-header col-first\">Method<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color method method-tab1\"><a href=\"mdl\/pk\\\n+                g\/TestAnnotation.html#required()\">pkg.TestAnnotation.required()<\/a><\/div>\n+                <div class=\"col-last even-row-color method method-tab1\"><\/div>\n+                <\/div>\"\"\",\n+            \"\"\"\n+                <div id=\"constructor\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"con\\\n+                structor-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"constructor.tabpanel\" \\\n+                tabindex=\"0\" onkeydown=\"switchTab(event)\" onclick=\"show('constructor', 'constructor'\\\n+                , 2)\" class=\"active-table-tab\">Deprecated Constructors<\/button><button id=\"construct\\\n+                or-tab1\" role=\"tab\" aria-selected=\"false\" aria-controls=\"constructor.tabpanel\" tabin\\\n+                dex=\"-1\" onkeydown=\"switchTab(event)\" onclick=\"show('constructor', 'constructor-tab1\\\n+                ', 2)\" class=\"table-tab\">Deprecated in 5<\/button><\/div>\n+                <div id=\"constructor.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"constructor-tab0\">\n+                <div class=\"table-header col-first\">Constructor<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color constructor constructor-tab1\"><a hr\\\n+                ef=\"mdl\/pkg\/TestClass.html#%3Cinit%3E()\">pkg.TestClass()<\/a><\/div>\n+                <div class=\"col-last even-row-color constructor constructor-tab1\"><\/div>\n+                <\/div>\"\"\",\n+            \"\"\"\n+                <div id=\"enum-constant\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"enu\\\n+                m-constant-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"enum-constant.tabpan\\\n+                el\" tabindex=\"0\" onkeydown=\"switchTab(event)\" onclick=\"show('enum-constant', 'enum-c\\\n+                onstant', 2)\" class=\"active-table-tab\">Deprecated Enum Constants<\/button><button id=\\\n+                \"enum-constant-tab1\" role=\"tab\" aria-selected=\"false\" aria-controls=\"enum-constant.t\\\n+                abpanel\" tabindex=\"-1\" onkeydown=\"switchTab(event)\" onclick=\"show('enum-constant', '\\\n+                enum-constant-tab1', 2)\" class=\"table-tab\">Deprecated in 5<\/button><\/div>\n+                <div id=\"enum-constant.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"enum-constant-tab0\">\n+                <div class=\"table-header col-first\">Enum Constant<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color enum-constant enum-constant-tab1\"><\\\n+                a href=\"mdl\/pkg\/TestEnum.html#DEPRECATED\">pkg.TestEnum.DEPRECATED<\/a><\/div>\n+                <div class=\"col-last even-row-color enum-constant enum-constant-tab1\"><\/div>\n+                <\/div>\"\"\",\n+            \"\"\"\n+                <div id=\"annotation-interface-member\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"ann\\\n+                otation-interface-member-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"annota\\\n+                tion-interface-member.tabpanel\" tabindex=\"0\" onkeydown=\"switchTab(event)\" onclick=\"s\\\n+                how('annotation-interface-member', 'annotation-interface-member', 2)\" class=\"active-\\\n+                table-tab\">Deprecated Annotation Interface Elements<\/button><button id=\"annotation-i\\\n+                nterface-member-tab1\" role=\"tab\" aria-selected=\"false\" aria-controls=\"annotation-int\\\n+                erface-member.tabpanel\" tabindex=\"-1\" onkeydown=\"switchTab(event)\" onclick=\"show('an\\\n+                notation-interface-member', 'annotation-interface-member-tab1', 2)\" class=\"table-tab\\\n+                \">Deprecated in 5<\/button><\/div>\n+                <div id=\"annotation-interface-member.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"annotation-interface-member-tab0\">\n+                <div class=\"table-header col-first\">Annotation Interface Element<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color annotation-interface-member annotat\\\n+                ion-interface-member-tab1\"><a href=\"mdl\/pkg\/TestAnnotation.html#required()\">pkg.Test\\\n+                Annotation.required()<\/a><\/div>\n+                <div class=\"col-last even-row-color annotation-interface-member annotation-interface-member-tab1\"><\/div>\n+                <\/div>\"\"\");\n+    }\n+\n+    private void checkSingleReleaseContents() {\n+        checkOutput(\"new-list.html\", true,\n+            \"\"\"\n+                <h1 title=\"New API\" class=\"title\">New API<\/h1>\n+                <h2 title=\"Contents\">Contents<\/h2>\n+                <ul>\n+                <li><a href=\"#method\">Methods<\/a><\/li>\n+                <li><a href=\"#constructor\">Constructors<\/a><\/li>\n+                <\/ul>\n+                <\/div>\n+                <ul class=\"block-list\">\"\"\");\n+    }\n+\n+    private void checkSingleReleaseNewElements() {\n+        checkOutput(\"new-list.html\", true,\n+            \"\"\"\n+                <div id=\"method\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"met\\\n+                hod-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"method.tabpanel\" tabindex=\"\\\n+                0\" onkeydown=\"switchTab(event)\" onclick=\"show('method', 'method', 2)\" class=\"active-\\\n+                table-tab\">New Methods<\/button><button id=\"method-tab1\" role=\"tab\" aria-selected=\"fa\\\n+                lse\" aria-controls=\"method.tabpanel\" tabindex=\"-1\" onkeydown=\"switchTab(event)\" oncl\\\n+                ick=\"show('method', 'method-tab1', 2)\" class=\"table-tab\">New Methods<\/button><\/div>\n+                <div id=\"method.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"method-tab0\">\n+                <div class=\"table-header col-first\">Method<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color method method-tab1\"><a href=\"mdl\/pk\\\n+                g\/TestClass.html#overloadedMethod(java.lang.String)\">pkg.TestClass.overloadedMethod<\\\n+                wbr>(String)<\/a><\/div>\n+                <div class=\"col-last even-row-color method method-tab1\">\n+                <div class=\"block\">TestClass overloaded method.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name odd-row-color method method-tab1\"><a href=\"mdl\/pkg\\\n+                \/TestRecord.html#x()\">pkg.TestRecord.x()<\/a><\/div>\n+                <div class=\"col-last odd-row-color method method-tab1\">\n+                <div class=\"block\">Test record getter.<\/div>\n+                <\/div>\"\"\",\n+            \"\"\"\n+                <div id=\"constructor\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"con\\\n+                structor-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"constructor.tabpanel\" \\\n+                tabindex=\"0\" onkeydown=\"switchTab(event)\" onclick=\"show('constructor', 'constructor'\\\n+                , 2)\" class=\"active-table-tab\">New Constructors<\/button><button id=\"constructor-tab1\\\n+                \" role=\"tab\" aria-selected=\"false\" aria-controls=\"constructor.tabpanel\" tabindex=\"-1\\\n+                \" onkeydown=\"switchTab(event)\" onclick=\"show('constructor', 'constructor-tab1', 2)\" \\\n+                class=\"table-tab\">New Constructors<\/button><\/div>\n+                <div id=\"constructor.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"constructor-tab0\">\n+                <div class=\"table-header col-first\">Constructor<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color constructor constructor-tab1\"><a hr\\\n+                ef=\"mdl\/pkg\/TestError.html#%3Cinit%3E()\">pkg.TestError()<\/a><\/div>\n+                <div class=\"col-last even-row-color constructor constructor-tab1\">\n+                <div class=\"block\">Test error constructor.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name odd-row-color constructor constructor-tab1\"><a hre\\\n+                f=\"mdl\/pkg\/TestException.html#%3Cinit%3E()\">pkg.TestException()<\/a><\/div>\n+                <div class=\"col-last odd-row-color constructor constructor-tab1\">\n+                <div class=\"block\">Exception constructor.<\/div>\n+                <\/div>\"\"\");\n+    }\n+\n+    private void checkSingleReleaseDeprecatedElements() {\n+        checkOutput(\"deprecated-list.html\", true,\n+            \"\"\"\n+                <h1 title=\"Deprecated API\" class=\"title\">Deprecated API<\/h1>\n+                <h2 title=\"Contents\">Contents<\/h2>\n+                <ul>\n+                <li><a href=\"#for-removal\">Terminally Deprecated<\/a><\/li>\n+                <li><a href=\"#method\">Methods<\/a><\/li>\n+                <li><a href=\"#constructor\">Constructors<\/a><\/li>\n+                <li><a href=\"#enum-constant\">Enum Constants<\/a><\/li>\n+                <li><a href=\"#annotation-interface-member\">Annotation Interface Elements<\/a><\/li>\n+                <\/ul>\n+                <\/div>\n+                <ul class=\"block-list\">\"\"\",\n+            \"\"\"\n+                <div id=\"for-removal\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"for\\\n+                -removal-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"for-removal.tabpanel\" \\\n+                tabindex=\"0\" onkeydown=\"switchTab(event)\" onclick=\"show('for-removal', 'for-removal'\\\n+                , 2)\" class=\"active-table-tab\">Terminally Deprecated Elements<\/button><button id=\"fo\\\n+                r-removal-tab1\" role=\"tab\" aria-selected=\"false\" aria-controls=\"for-removal.tabpanel\\\n+                \" tabindex=\"-1\" onkeydown=\"switchTab(event)\" onclick=\"show('for-removal', 'for-remov\\\n+                al-tab1', 2)\" class=\"table-tab\">Terminally Deprecated in 5<\/button><\/div>\n+                <div id=\"for-removal.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"for-removal-tab0\">\n+                <div class=\"table-header col-first\">Element<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color for-removal for-removal-tab1\"><a hr\\\n+                ef=\"mdl\/pkg\/TestAnnotation.html#required()\">pkg.TestAnnotation.required()<\/a><\/div>\n+                <div class=\"col-last even-row-color for-removal for-removal-tab1\"><\/div>\n+                <\/div>\"\"\",\n+            \"\"\"\n+                <div id=\"method\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"met\\\n+                hod-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"method.tabpanel\" tabindex=\"\\\n+                0\" onkeydown=\"switchTab(event)\" onclick=\"show('method', 'method', 2)\" class=\"active-\\\n+                table-tab\">Deprecated Methods<\/button><button id=\"method-tab1\" role=\"tab\" aria-selec\\\n+                ted=\"false\" aria-controls=\"method.tabpanel\" tabindex=\"-1\" onkeydown=\"switchTab(event\\\n+                )\" onclick=\"show('method', 'method-tab1', 2)\" class=\"table-tab\">Deprecated in 5<\/but\\\n+                ton><\/div>\n+                <div id=\"method.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"method-tab0\">\n+                <div class=\"table-header col-first\">Method<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color method method-tab1\"><a href=\"mdl\/pk\\\n+                g\/TestAnnotation.html#required()\">pkg.TestAnnotation.required()<\/a><\/div>\n+                <div class=\"col-last even-row-color method method-tab1\"><\/div>\n+                <\/div>\"\"\",\n+            \"\"\"\n+                <div id=\"constructor\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"con\\\n+                structor-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"constructor.tabpanel\" \\\n+                tabindex=\"0\" onkeydown=\"switchTab(event)\" onclick=\"show('constructor', 'constructor'\\\n+                , 2)\" class=\"active-table-tab\">Deprecated Constructors<\/button><button id=\"construct\\\n+                or-tab1\" role=\"tab\" aria-selected=\"false\" aria-controls=\"constructor.tabpanel\" tabin\\\n+                dex=\"-1\" onkeydown=\"switchTab(event)\" onclick=\"show('constructor', 'constructor-tab1\\\n+                ', 2)\" class=\"table-tab\">Deprecated in 5<\/button><\/div>\n+                <div id=\"constructor.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"constructor-tab0\">\n+                <div class=\"table-header col-first\">Constructor<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color constructor constructor-tab1\"><a hr\\\n+                ef=\"mdl\/pkg\/TestClass.html#%3Cinit%3E()\">pkg.TestClass()<\/a><\/div>\n+                <div class=\"col-last even-row-color constructor constructor-tab1\"><\/div>\n+                <\/div>\"\"\");\n+    }\n+\n+    private void checkPackageContents() {\n+        checkOutput(\"new-list.html\", true,\n+            \"\"\"\n+                <h1 title=\"New API\" class=\"title\">New API<\/h1>\n+                <h2 title=\"Contents\">Contents<\/h2>\n+                <ul>\n+                <li><a href=\"#class\">Classes<\/a><\/li>\n+                <li><a href=\"#field\">Fields<\/a><\/li>\n+                <li><a href=\"#method\">Methods<\/a><\/li>\n+                <li><a href=\"#constructor\">Constructors<\/a><\/li>\n+                <\/ul>\n+                <\/div>\n+                <span class=\"help-note\">(The leftmost tab \"New ...\" indicates all the new elements, \\\n+                regardless of the releases in which they were added. Each of the other tabs \"Added i\\\n+                n ...\" indicates the new elements added in a specific release. Any element shown und\\\n+                er the leftmost tab is also shown under one of the righthand tabs.)<\/span>\"\"\");\n+    }\n+\n+    private void checkPackageNewElements() {\n+        checkOutput(\"new-list.html\", true,\n+            \"\"\"\n+                <div id=\"class\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"cla\\\n+                ss-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"class.tabpanel\" tabindex=\"0\"\\\n+                 onkeydown=\"switchTab(event)\" onclick=\"show('class', 'class', 2)\" class=\"active-tabl\\\n+                e-tab\">New Classes<\/button><button id=\"class-tab5\" role=\"tab\" aria-selected=\"false\" \\\n+                aria-controls=\"class.tabpanel\" tabindex=\"-1\" onkeydown=\"switchTab(event)\" onclick=\"s\\\n+                how('class', 'class-tab5', 2)\" class=\"table-tab\">Added in 1.2<\/button><\/div>\n+                <div id=\"class.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"class-tab0\">\n+                <div class=\"table-header col-first\">Class<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color class class-tab5\"><a href=\"pkg\/Test\\\n+                Class.html\" title=\"class in pkg\">pkg.TestClass<\/a><\/div>\n+                <div class=\"col-last even-row-color class class-tab5\">\n+                <div class=\"block\">TestClass declaration.<\/div>\n+                <\/div>\"\"\",\n+            \"\"\"\n+                <div id=\"field\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"fie\\\n+                ld-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"field.tabpanel\" tabindex=\"0\"\\\n+                 onkeydown=\"switchTab(event)\" onclick=\"show('field', 'field', 2)\" class=\"active-tabl\\\n+                e-tab\">New Fields<\/button><button id=\"field-tab5\" role=\"tab\" aria-selected=\"false\" a\\\n+                ria-controls=\"field.tabpanel\" tabindex=\"-1\" onkeydown=\"switchTab(event)\" onclick=\"sh\\\n+                ow('field', 'field-tab5', 2)\" class=\"table-tab\">Added in 1.2<\/button><\/div>\n+                <div id=\"field.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"field-tab0\">\n+                <div class=\"table-header col-first\">Field<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color field field-tab5\"><a href=\"pkg\/Test\\\n+                Class.html#field\">pkg.TestClass.field<\/a><\/div>\n+                <div class=\"col-last even-row-color field field-tab5\">\n+                <div class=\"block\">TestClass field.<\/div>\n+                <\/div>\"\"\",\n+            \"\"\"\n+                <div id=\"method\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"met\\\n+                hod-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"method.tabpanel\" tabindex=\"\\\n+                0\" onkeydown=\"switchTab(event)\" onclick=\"show('method', 'method', 2)\" class=\"active-\\\n+                table-tab\">New Methods<\/button><button id=\"method-tab1\" role=\"tab\" aria-selected=\"fa\\\n+                lse\" aria-controls=\"method.tabpanel\" tabindex=\"-1\" onkeydown=\"switchTab(event)\" oncl\\\n+                ick=\"show('method', 'method-tab1', 2)\" class=\"table-tab\">Added in 6<\/button><button \\\n+                id=\"method-tab2\" role=\"tab\" aria-selected=\"false\" aria-controls=\"method.tabpanel\" ta\\\n+                bindex=\"-1\" onkeydown=\"switchTab(event)\" onclick=\"show('method', 'method-tab2', 2)\" \\\n+                class=\"table-tab\">Added in 5<\/button><button id=\"method-tab4\" role=\"tab\" aria-select\\\n+                ed=\"false\" aria-controls=\"method.tabpanel\" tabindex=\"-1\" onkeydown=\"switchTab(event)\\\n+                \" onclick=\"show('method', 'method-tab4', 2)\" class=\"table-tab\">Added in 2.0b<\/button\\\n+                ><\/div>\n+                <div id=\"method.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"method-tab0\">\n+                <div class=\"table-header col-first\">Method<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color method method-tab4\"><a href=\"pkg\/Te\\\n+                stClass.html#method()\">pkg.TestClass.method()<\/a><\/div>\n+                <div class=\"col-last even-row-color method method-tab4\">\n+                <div class=\"block\">TestClass method.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name odd-row-color method method-tab1\"><a href=\"pkg\/Tes\\\n+                tClass.html#overloadedMethod(int)\">pkg.TestClass.overloadedMethod<wbr>(int)<\/a><\/div>\n+                <div class=\"col-last odd-row-color method method-tab1\">\n+                <div class=\"block\">TestClass overloaded method.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name even-row-color method method-tab2\"><a href=\"pkg\/Te\\\n+                stClass.html#overloadedMethod(java.lang.String)\">pkg.TestClass.overloadedMethod<wbr>\\\n+                (String)<\/a><\/div>\n+                <div class=\"col-last even-row-color method method-tab2\">\n+                <div class=\"block\">TestClass overloaded method.<\/div>\n+                <\/div>\"\"\",\n+            \"\"\"\n+                <div id=\"constructor\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"con\\\n+                structor-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"constructor.tabpanel\" \\\n+                tabindex=\"0\" onkeydown=\"switchTab(event)\" onclick=\"show('constructor', 'constructor'\\\n+                , 2)\" class=\"active-table-tab\">New Constructors<\/button><button id=\"constructor-tab3\\\n+                \" role=\"tab\" aria-selected=\"false\" aria-controls=\"constructor.tabpanel\" tabindex=\"-1\\\n+                \" onkeydown=\"switchTab(event)\" onclick=\"show('constructor', 'constructor-tab3', 2)\" \\\n+                class=\"table-tab\">Added in 3.2<\/button><button id=\"constructor-tab4\" role=\"tab\" aria\\\n+                -selected=\"false\" aria-controls=\"constructor.tabpanel\" tabindex=\"-1\" onkeydown=\"swit\\\n+                chTab(event)\" onclick=\"show('constructor', 'constructor-tab4', 2)\" class=\"table-tab\"\\\n+                >Added in 2.0b<\/button><\/div>\n+                <div id=\"constructor.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"constructor-tab0\">\n+                <div class=\"table-header col-first\">Constructor<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color constructor constructor-tab4\"><a hr\\\n+                ef=\"pkg\/TestClass.html#%3Cinit%3E()\">pkg.TestClass()<\/a><\/div>\n+                <div class=\"col-last even-row-color constructor constructor-tab4\">\n+                <div class=\"block\">TestClass constructor.<\/div>\n+                <\/div>\n+                <div class=\"col-summary-item-name odd-row-color constructor constructor-tab3\"><a hre\\\n+                f=\"pkg\/TestClass.html#%3Cinit%3E(java.lang.String)\">pkg.TestClass<wbr>(String)<\/a><\/div>\n+                <div class=\"col-last odd-row-color constructor constructor-tab3\">\n+                <div class=\"block\">TestClass constructor.<\/div>\n+                <\/div>\"\"\");\n+    }\n+\n+    private void checkPackageDeprecatedElements() {\n+        checkOutput(\"deprecated-list.html\", true,\n+            \"\"\"\n+                <h1 title=\"Deprecated API\" class=\"title\">Deprecated API<\/h1>\n+                <h2 title=\"Contents\">Contents<\/h2>\n+                <ul>\n+                <li><a href=\"#constructor\">Constructors<\/a><\/li>\n+                <\/ul>\n+                <\/div>\n+                <span class=\"help-note\">(The leftmost tab \"Deprecated ...\" indicates all the depreca\\\n+                ted elements, regardless of the releases in which they were deprecated. Each of the \\\n+                other tabs \"Deprecated in ...\" indicates the elements deprecated in a specific relea\\\n+                se.)<\/span>\n+                \"\"\",\n+            \"\"\"\n+                <div id=\"constructor\">\n+                <div class=\"table-tabs\" role=\"tablist\" aria-orientation=\"horizontal\"><button id=\"con\\\n+                structor-tab0\" role=\"tab\" aria-selected=\"true\" aria-controls=\"constructor.tabpanel\" \\\n+                tabindex=\"0\" onkeydown=\"switchTab(event)\" onclick=\"show('constructor', 'constructor'\\\n+                , 2)\" class=\"active-table-tab\">Deprecated Constructors<\/button><button id=\"construct\\\n+                or-tab2\" role=\"tab\" aria-selected=\"false\" aria-controls=\"constructor.tabpanel\" tabin\\\n+                dex=\"-1\" onkeydown=\"switchTab(event)\" onclick=\"show('constructor', 'constructor-tab2\\\n+                ', 2)\" class=\"table-tab\">Deprecated in 5<\/button><\/div>\n+                <div id=\"constructor.tabpanel\" role=\"tabpanel\">\n+                <div class=\"summary-table two-column-summary\" aria-labelledby=\"constructor-tab0\">\n+                <div class=\"table-header col-first\">Constructor<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-summary-item-name even-row-color constructor constructor-tab2\"><a hr\\\n+                ef=\"pkg\/TestClass.html#%3Cinit%3E()\">pkg.TestClass()<\/a><\/div>\n+                <div class=\"col-last even-row-color constructor constructor-tab2\"><\/div>\n+                <\/div>\"\"\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNewApiList\/TestNewApiList.java","additions":884,"deletions":0,"binary":false,"changes":884,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Module mdl.\n+ * @since 3.2\n+ *\/\n+module mdl {\n+    exports pkg;\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNewApiList\/mdl\/module-info.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package pkg;\n+\n+import java.lang.annotation.Documented;\n+\n+\/**\n+ * An annotation interface.\n+ * @since 2.0b\n+ *\/\n+@Documented public @interface TestAnnotation {\n+\n+    \/**\n+     * Optional annotation interface element.\n+     * @since 3.2\n+     *\/\n+    String optional() default \"unknown\";\n+\n+    \/**\n+     *  Required annotation interface element.\n+     * @since 2.0b\n+     *\/\n+    @Deprecated(forRemoval=true,since=\"5\")\n+    int required();\n+\n+    \/**\n+     * @since 6\n+     *\/\n+    int field = 0;\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNewApiList\/mdl\/pkg\/TestAnnotation.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package pkg;\n+\n+\/**\n+ * TestClass declaration.\n+ * @since 1.2\n+ *\/\n+public class TestClass {\n+\n+    \/**\n+     * TestClass field.\n+     * @since 1.2\n+     *\/\n+    public int field;\n+\n+    \/**\n+     * TestClass constructor.\n+     * @since 2.0b\n+     *\/\n+    @Deprecated(since=\"5\")\n+    public TestClass() {}\n+\n+    \/**\n+     * TestClass constructor.\n+     * @since 3.2\n+     *\/\n+    public TestClass(String s) {}\n+\n+    \/**\n+     * TestClass method.\n+     * @since 2.0b\n+     *\/\n+    public void method() {}\n+\n+    \/**\n+     * TestClass overloaded method.\n+     * @since 5\n+     *\/\n+    public void overloadedMethod(String s) {}\n+\n+    \/**\n+     * TestClass overloaded method.\n+     * @since 6\n+     *\/\n+    public void overloadedMethod(int i) {}\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNewApiList\/mdl\/pkg\/TestClass.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package pkg;\n+\n+\/**\n+ * Test enum class.\n+ * @since 0.9\n+ *\/\n+public enum TestEnum {\n+\n+    \/**\n+     * One.\n+     * @since 0.9\n+     *\/\n+    ONE,\n+    \/**\n+     * Two.\n+     * @since v1.0\n+     *\/\n+    TWO,\n+    \/**\n+     * Three.\n+     * @since 1.2\n+     *\/\n+    THREE,\n+    \/**\n+     * Deprecated.\n+     * @since 3.2\n+     *\/\n+    @Deprecated(since=\"5\")\n+    DEPRECATED;\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNewApiList\/mdl\/pkg\/TestEnum.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package pkg;\n+\n+\/**\n+ * Test error class.\n+ * @since 2.0b\n+ *\/\n+public class TestError extends Error {\n+\n+    \/**\n+     * Test error field.\n+     * @since v1.0\n+     *\/\n+    public int field;\n+\n+    \/**\n+     * Test error constructor.\n+     * @since 5\n+     *\/\n+    public TestError() {}\n+\n+    \/**\n+     * Test error method.\n+     * @since 3.2\n+     *\/\n+    public void method() {}\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNewApiList\/mdl\/pkg\/TestError.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package pkg;\n+\n+\/**\n+ * Test exception class.\n+ *       @since    0.9\n+ *\/\n+public class TestException extends Exception {\n+\n+    \/**\n+     * Exception field.\n+     * @since   3.2\n+     *\/\n+    public int field;\n+\n+    \/**\n+     * Exception constructor.\n+     * @since 5\n+     *\/\n+    public TestException() {}\n+\n+    \/**\n+     * Exception method.\n+     * @since 1.2\n+     *\/\n+    public void method() {}\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNewApiList\/mdl\/pkg\/TestException.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package pkg;\n+\n+\/**\n+ * Test interface.\n+ * @since 0.9\n+ *\/\n+public interface TestInterface {\n+\n+    \/**\n+     * Test interface field.\n+     * @since 2.0b\n+     *\/\n+    int field = 1;\n+\n+    \/**\n+     * Interface method.\n+     * @since v1.0\n+     *\/\n+    void method1();\n+\n+    \/**\n+     * Interface method.\n+     * @since 3.2\n+     *\/\n+    void method2(Class<?> c);\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNewApiList\/mdl\/pkg\/TestInterface.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package pkg;\n+\n+\/**\n+ * Test record.\n+ * @since 3.2\n+ *\/\n+public record TestRecord(int x, int y) {\n+\n+    \/**\n+     * Test record getter.\n+     * @return x\n+     * @since 5\n+     *\/\n+    @Override\n+    public int x() {\n+        return x;\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNewApiList\/mdl\/pkg\/TestRecord.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Package pkg.\n+ * @since v1.0\n+ *\/\n+package pkg;\n\\ No newline at end of file\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNewApiList\/mdl\/pkg\/package-info.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package pkg;\n+\n+\/**\n+ * TestClass declaration.\n+ * @since 1.2\n+ *\/\n+public class TestClass {\n+\n+    \/**\n+     * TestClass field.\n+     * @since 1.2\n+     *\/\n+    public int field;\n+\n+    \/**\n+     * TestClass constructor.\n+     * @since 2.0b\n+     *\/\n+    @Deprecated(since=\"5\")\n+    public TestClass() {}\n+\n+    \/**\n+     * TestClass constructor.\n+     * @since 3.2\n+     *\/\n+    public TestClass(String s) {}\n+\n+    \/**\n+     * TestClass method.\n+     * @since 2.0b\n+     *\/\n+    public void method() {}\n+\n+    \/**\n+     * TestClass overloaded method.\n+     * @since 5\n+     *\/\n+    public void overloadedMethod(String s) {}\n+\n+    \/**\n+     * TestClass overloaded method.\n+     * @since 6\n+     *\/\n+    public void overloadedMethod(int i) {}\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNewApiList\/pkg\/TestClass.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -104,1 +104,1 @@\n-                    {\"l\":\"All Classes\",\"u\":\"allclasses-index.html\"}\"\"\");\n+                    {\"l\":\"All Classes and Interfaces\",\"u\":\"allclasses-index.html\"}\"\"\");\n@@ -110,2 +110,3 @@\n-                    <br><a href=\"allclasses-index.html\">All&nbsp;Classes<\/a><span class=\"vertical-se\\\n-                    parator\">|<\/span><a href=\"allpackages-index.html\">All&nbsp;Packages<\/a>\"\"\");\n+                    <br><a href=\"allclasses-index.html\">All&nbsp;Classes&nbsp;and&nbsp;Interfaces<\/a\\\n+                    ><span class=\"vertical-separator\">|<\/span><a href=\"allpackages-index.html\">All&n\\\n+                    bsp;Packages<\/a>\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPackagePage\/TestPackagePage.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -523,1 +523,1 @@\n-                    <div class=\"caption\"><span>Record Classes<\/span><\/div>\n+                    <div class=\"caption\"><span>Deprecated Record Classes<\/span><\/div>\n@@ -555,1 +555,1 @@\n-                    <div class=\"caption\"><span>Methods<\/span><\/div>\n+                    <div class=\"caption\"><span>Deprecated Methods<\/span><\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testRecordTypes\/TestRecordTypes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+  * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+  *\n+  * This code is free software; you can redistribute it and\/or modify it\n+  * under the terms of the GNU General Public License version 2 only, as\n+  * published by the Free Software Foundation.\n+  *\n+  * This code is distributed in the hope that it will be useful, but WITHOUT\n+  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+  * version 2 for more details (a copy is included in the LICENSE file that\n+  * accompanied this code).\n+  *\n+  * You should have received a copy of the GNU General Public License version\n+  * 2 along with this work; if not, write to the Free Software Foundation,\n+  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+  *\n+  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+  * or visit www.oracle.com if you need additional information or have any\n+  * questions.\n+  *\/\n+\n+ \/*\n+  * @test\n+  * @bug      8267204\n+  * @summary  Expose access to underlying streams in Reporter\n+  * @library  \/tools\/lib ..\/..\/lib\n+  * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n+  * @build    toolbox.ToolBox javadoc.tester.*\n+  * @run main TestReporterStreams\n+  *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.Element;\n+import javax.tools.Diagnostic;\n+import javax.tools.JavaFileObject;\n+\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.doctree.SinceTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.util.DocSourcePositions;\n+import com.sun.source.util.DocTreePath;\n+import com.sun.source.util.DocTrees;\n+import com.sun.source.util.TreePath;\n+import javadoc.tester.JavadocTester;\n+import jdk.javadoc.doclet.Doclet;\n+import jdk.javadoc.doclet.DocletEnvironment;\n+import jdk.javadoc.doclet.Reporter;\n+import toolbox.ToolBox;\n+\n+public class TestReporterStreams extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        TestReporterStreams tester = new TestReporterStreams();\n+        tester.runTests(m -> new Object[]{Path.of(m.getName())});\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    TestReporterStreams() throws IOException {\n+        tb.writeJavaFiles(Path.of(\".\"), \"\"\"\n+                    \/**\n+                     * Comment.\n+                     * @since 0\n+                     *\/\n+                    public class C { }\"\"\");\n+    }\n+\n+    \/**\n+     * Tests the entry point used by the DocumentationTool API and JavadocTester, in which\n+     * all output is written to a single specified writer.\n+     *\/\n+    @Test\n+    public void testSingleStream(Path base) throws IOException {\n+        test(base, false, Output.OUT, Output.OUT);\n+    }\n+\n+    \/**\n+     * Tests the entry point used by the launcher, in which output is written to\n+     * writers that wrap {@code System.out} and {@code System.err}.\n+     *\/\n+    @Test\n+    public void testStandardStreams(Path base) throws IOException {\n+        test(base, true, Output.STDOUT, Output.STDERR);\n+    }\n+\n+    void test(Path base, boolean useStdStreams, Output stdOut, Output stdErr) throws IOException {\n+        String testClasses = System.getProperty(\"test.classes\");\n+\n+        setOutputDirectoryCheck(DirectoryCheck.NONE);\n+        setUseStandardStreams(useStdStreams);\n+        javadoc(\"-docletpath\", testClasses,\n+                \"-doclet\", MyDoclet.class.getName(),\n+                \"C.java\" \/\/ avoid using a directory, to avoid path separator issues in expected output\n+        );\n+        checkExit(Exit.ERROR);\n+        checkOutput(stdOut, true,\n+                \"Writing to the standard writer\");\n+        checkOutput(stdErr, true,\n+                \"Writing to the diagnostic writer\");\n+        checkOutput(stdErr, true,\n+                \"\"\"\n+                    error: This is a ERROR with no position\n+                    C.java:5: error: This is a ERROR for an element\n+                    public class C { }\n+                           ^\n+                    C.java:2: error: This is a ERROR for a doc tree path\n+                     * Comment.\n+                       ^\n+                    C.java:3: error: This is a ERROR for a file position\n+                     * @since 0\n+                              ^\n+                    warning: This is a WARNING with no position\n+                    C.java:5: warning: This is a WARNING for an element\n+                    public class C { }\n+                           ^\n+                    C.java:2: warning: This is a WARNING for a doc tree path\n+                     * Comment.\n+                       ^\n+                    C.java:3: warning: This is a WARNING for a file position\n+                     * @since 0\n+                              ^\n+                    warning: This is a MANDATORY_WARNING with no position\n+                    C.java:5: warning: This is a MANDATORY_WARNING for an element\n+                    public class C { }\n+                           ^\n+                    C.java:2: warning: This is a MANDATORY_WARNING for a doc tree path\n+                     * Comment.\n+                       ^\n+                    C.java:3: warning: This is a MANDATORY_WARNING for a file position\n+                     * @since 0\n+                              ^\n+                    Note: This is a NOTE with no position\n+                    C.java:5: Note: This is a NOTE for an element\n+                    public class C { }\n+                           ^\n+                    C.java:2: Note: This is a NOTE for a doc tree path\n+                     * Comment.\n+                       ^\n+                    C.java:3: Note: This is a NOTE for a file position\n+                     * @since 0\n+                              ^\n+                    \"\"\");\n+    }\n+\n+    public static class MyDoclet implements Doclet {\n+        private Locale locale;\n+        private Reporter reporter;\n+\n+        @Override\n+        public void init(Locale locale, Reporter reporter) {\n+            this.locale = locale;\n+            this.reporter = reporter;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return \"MyDoclet\";\n+        }\n+\n+        @Override\n+        public Set<? extends Option> getSupportedOptions() {\n+            return Collections.emptySet();\n+        }\n+\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latestSupported();\n+        }\n+\n+        @Override\n+        public boolean run(DocletEnvironment environment) {\n+            \/\/ Write directly to the given streams\n+            reporter.getStandardWriter().println(\"Writing to the standard writer\");\n+            reporter.getDiagnosticWriter().println(\"Writing to the diagnostic writer\");\n+\n+            \/\/ the following is little more than a null check for the locale\n+            reporter.print(Diagnostic.Kind.NOTE, \"The locale is \" + locale.getDisplayName());\n+\n+            \/\/ Write different kinds of diagnostics using the different overloads\n+            \/\/ for printing diagnostics\n+            Set<? extends Element> specElems = environment.getSpecifiedElements();\n+            Element e = specElems.iterator().next();\n+\n+            DocTrees trees = environment.getDocTrees();\n+            TreePath tp = trees.getPath(e);\n+            DocCommentTree dct = trees.getDocCommentTree(e);\n+            DocTreePath dtp = new DocTreePath(tp, dct);\n+\n+            CompilationUnitTree cut = tp.getCompilationUnit();\n+            JavaFileObject fo = cut.getSourceFile();\n+            SinceTree st = (SinceTree) dct.getBlockTags().get(0);\n+            DocSourcePositions sp = trees.getSourcePositions();\n+            int start = (int) sp.getStartPosition(cut, dct, st);\n+            int pos = (int) sp.getStartPosition(cut, dct, st.getBody().get(0));\n+            int end = (int) sp.getEndPosition(cut, dct, st);\n+\n+            for (Diagnostic.Kind k : Diagnostic.Kind.values()) {\n+                if (k == Diagnostic.Kind.OTHER) {\n+                    continue;\n+                }\n+\n+                reporter.print(k, \"This is a \" + k + \" with no position\");\n+                reporter.print(k, e, \"This is a \" + k + \" for an element\");\n+                reporter.print(k, dtp, \"This is a \" + k + \" for a doc tree path\");\n+                reporter.print(k, fo, start, pos, end, \"This is a \" + k + \" for a file position\");\n+            }\n+\n+            return true;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testReporterStreams\/TestReporterStreams.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -543,2 +543,3 @@\n-                    <br><a href=\"..\/allclasses-index.html\">All&nbsp;Classes<\/a><span class=\"vertical\\\n-                    -separator\">|<\/span><a href=\"..\/allpackages-index.html\">All&nbsp;Packages<\/a>\"\"\");\n+                    <br><a href=\"..\/allclasses-index.html\">All&nbsp;Classes&nbsp;and&nbsp;Interfaces\\\n+                    <\/a><span class=\"vertical-separator\">|<\/span><a href=\"..\/allpackages-index.html\"\\\n+                    >All&nbsp;Packages<\/a>\"\"\");\n@@ -849,1 +850,1 @@\n-                    {\"l\":\"All Classes\",\"u\":\"allclasses-index.html\"}\"\"\");\n+                    {\"l\":\"All Classes and Interfaces\",\"u\":\"allclasses-index.html\"}\"\"\");\n@@ -854,3 +855,4 @@\n-                    \"\"\"\n-                        <br><a href=\"allclasses-index.html\">All&nbsp;Classes<\/a><span class=\"vertical-se\\\n-                        parator\">|<\/span><a href=\"allpackages-index.html\">All&nbsp;Packages<\/a>\"\"\");\n+                \"\"\"\n+                    <br><a href=\"allclasses-index.html\">All&nbsp;Classes&nbsp;and&nbsp;Interface\\\n+                    s<\/a><span class=\"vertical-separator\">|<\/span><a href=\"allpackages-index.htm\\\n+                    l\">All&nbsp;Packages<\/a>\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSearch\/TestSearch.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,3 @@\n+     * @serialField i int an int\n+     * @serialField  m double[][] the doubles\n+     * @serialField next SerializedForm a linked reference\n@@ -40,0 +43,1 @@\n+        new ObjectStreamField(\"m\", double[][].class),\n@@ -42,1 +46,2 @@\n-        new ObjectStreamField(\"longs\", Long[].class)\n+        new ObjectStreamField(\"longs\", Long[].class),\n+        new ObjectStreamField(\"next\", SerializedForm.class)\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSerializedForm\/SerializedForm.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -111,0 +111,5 @@\n+                    <h5>i<\/h5>\n+                    <pre>int i<\/pre>\n+                    <div class=\"block\">an int<\/div>\n+                    <\/li>\n+                    <li class=\"block-list\">\n@@ -112,1 +117,1 @@\n-                    <pre>Long[] longs<\/pre>\n+                    <pre>java.lang.Long[] longs<\/pre>\n@@ -116,0 +121,5 @@\n+                    <h5>m<\/h5>\n+                    <pre>double[][] m<\/pre>\n+                    <div class=\"block\">the doubles<\/div>\n+                    <\/li>\n+                    <li class=\"block-list\">\n@@ -118,1 +128,6 @@\n-                    <div class=\"block\">a test<\/div>\"\"\");\n+                    <div class=\"block\">a test<\/div>\n+                    <\/li>\n+                    <li class=\"block-list\">\n+                    <h5>next<\/h5>\n+                    <pre><a href=\"SerializedForm.html\" title=\"class in Unnamed Package\">SerializedForm<\/a> next<\/pre>\n+                    <div class=\"block\">a linked reference<\/div>\"\"\");\n@@ -163,0 +178,5 @@\n+                    <h5>i<\/h5>\n+                    <pre>int i<\/pre>\n+                    <div class=\"block\">an int<\/div>\n+                    <\/li>\n+                    <li class=\"block-list\">\n@@ -164,1 +184,1 @@\n-                    <pre>Long[] longs<\/pre>\n+                    <pre>java.lang.Long[] longs<\/pre>\n@@ -168,0 +188,5 @@\n+                    <h5>m<\/h5>\n+                    <pre>double[][] m<\/pre>\n+                    <div class=\"block\">the doubles<\/div>\n+                    <\/li>\n+                    <li class=\"block-list\">\n@@ -170,1 +195,6 @@\n-                    <div class=\"block\">a test<\/div>\"\"\");\n+                    <div class=\"block\">a test<\/div>\n+                    <\/li>\n+                    <li class=\"block-list\">\n+                    <h5>next<\/h5>\n+                    <pre><a href=\"SerializedForm.html\" title=\"class in Unnamed Package\">SerializedForm<\/a> next<\/pre>\n+                    <div class=\"block\">a linked reference<\/div>\"\"\");\n@@ -183,2 +213,4 @@\n-                \"int[] a1\",\n-                \"int[][] a2\",\n+                \"\"\"\n+                    int[] a1\"\"\",\n+                \"\"\"\n+                    int[][] a2\"\"\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSerializedForm\/TestSerializedForm.java","additions":38,"deletions":6,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-                    {\"l\":\"All Classes\",\"u\":\"allclasses-index.html\"}\"\"\");\n+                    {\"l\":\"All Classes and Interfaces\",\"u\":\"allclasses-index.html\"}\"\"\");\n@@ -107,2 +107,3 @@\n-                    <br><a href=\"allclasses-index.html\">All&nbsp;Classes<\/a><span class=\"vertical-se\\\n-                    parator\">|<\/span><a href=\"allpackages-index.html\">All&nbsp;Packages<\/a>\"\"\");\n+                    <br><a href=\"allclasses-index.html\">All&nbsp;Classes&nbsp;and&nbsp;Interfaces<\/a\\\n+                    ><span class=\"vertical-separator\">|<\/span><a href=\"allpackages-index.html\">All&n\\\n+                    bsp;Packages<\/a>\"\"\");\n@@ -112,1 +113,1 @@\n-                    {\"l\":\"All Classes\",\"u\":\"allclasses-index.html\"}\"\"\",\n+                    {\"l\":\"All Classes and Interfaces\",\"u\":\"allclasses-index.html\"}\"\"\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testUnnamedPackage\/TestUnnamedPackage.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,0 +239,1 @@\n+    private boolean useStandardStreams = false;\n@@ -341,1 +342,1 @@\n-           cs = docencodingArg;\n+            cs = docencodingArg;\n@@ -354,1 +355,1 @@\n-        \/\/ This is the sole stream used by javadoc\n+        \/\/ This is the sole stream normally used by javadoc\n@@ -363,1 +364,3 @@\n-            exitCode = jdk.javadoc.internal.tool.Main.execute(args, outOut.pw);\n+            exitCode = useStandardStreams\n+                    ? jdk.javadoc.internal.tool.Main.execute(args)              \/\/ use sysOut, sysErr\n+                    : jdk.javadoc.internal.tool.Main.execute(args, outOut.pw);  \/\/ default\n@@ -421,0 +424,10 @@\n+    \/**\n+     * Sets whether to use standard output streams (stdout and stderr)\n+     * instead of a single temporary stream.\n+     * Tests using standard streams should generally take care to avoid\n+     * conflicting use of stdout and stderr.\n+     *\/\n+    public void setUseStandardStreams(boolean b) {\n+        useStandardStreams = b;\n+    }\n+\n@@ -1108,1 +1121,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/jdk\/javadoc\/lib\/javadoc\/tester\/JavadocTester.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-            \/\/ jdk.javadoc.internal.tool.Messager\n+            \/\/ jdk.javadoc.internal.tool.JavadocLog\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/CheckResourceKeys.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,2 +112,2 @@\n-        List<String> out = tr.getOutputLines(Task.OutputKind.STDOUT);\n-        checkOutput(testName, out, NEW_HEADER);\n+        List<String> err = tr.getOutputLines(Task.OutputKind.STDERR);\n+        checkOutput(testName, err, NEW_HEADER);\n@@ -131,2 +131,2 @@\n-        checkOutput(testName, out, NEW_HEADER);\n-        checkOutput(testName, out, NEW_TAGLET_MARKER);\n+        checkOutput(testName, err, NEW_HEADER);\n+        checkOutput(testName, err, NEW_TAGLET_MARKER);\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/EnsureNewOldDoclet.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,3 +57,2 @@\n-     * because the DocErrorReporter API works in terms of localized strings\n-     * and file:line positions. Therefore, messages reported via DocErrorReporter\n-     * and simply wrapped and passed through.\n+     * because the Reporter API works in terms of localized strings.\n+     * Therefore, messages reported via Reporter are simply wrapped and passed through.\n@@ -80,1 +79,0 @@\n-                        \"javadoc.note.message\",     \/\/ Loading source file\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/api\/basic\/GetTask_DiagListenerTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-import jdk.javadoc.internal.tool.Messager;\n+import jdk.javadoc.internal.tool.JavadocLog;\n@@ -84,1 +84,1 @@\n-        Messager.preRegister(c, \"javadoc\");\n+        JavadocLog.preRegister(c, \"javadoc\");\n@@ -102,1 +102,1 @@\n-        Messager.preRegister(c, \"javadoc\");\n+        JavadocLog.preRegister(c, \"javadoc\");\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/api\/basic\/JavadocTaskImplTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -66,6 +66,0 @@\n-\n-    @BeforeMethod\n-    public void setUp() {\n-        setUp(b -> b.compilerOptions(\"--enable-preview\", \"-source\", String.valueOf(SourceVersion.latest().ordinal()))\n-                    .remoteVMOptions(\"--enable-preview\"));\n-    }\n","filename":"test\/langtools\/jdk\/jshell\/SealedClassesTest.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @compile --enable-preview -source ${jdk.version} NoTargetOnContainer.java\n+ * @compile NoTargetOnContainer.java\n","filename":"test\/langtools\/tools\/javac\/annotations\/repeatingAnnotations\/NoTargetOnContainer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @compile --enable-preview -source ${jdk.version} NoTargetOnContainer2.java\n+ * @compile NoTargetOnContainer2.java\n","filename":"test\/langtools\/tools\/javac\/annotations\/repeatingAnnotations\/NoTargetOnContainer2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -413,2 +413,0 @@\n-                extraOptions = List.of(\"--enable-preview\",\n-                                       \"-source\", JDK_VERSION);\n@@ -467,2 +465,0 @@\n-                extraOptions = List.of(\"--enable-preview\",\n-                                       \"-source\", JDK_VERSION);\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/CombinationsTargetTest2.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n- * @compile --enable-preview -source ${jdk.version} Patterns.java\n- * @run main\/othervm --enable-preview Patterns\n+ * @run main Patterns\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/Patterns.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -73,3 +73,1 @@\n-            List<String> options = List.of(\"-Xjcov\",\n-                                           \"--enable-preview\",\n-                                           \"-source\", JDK_VERSION);\n+            List<String> options = List.of(\"-Xjcov\");\n","filename":"test\/langtools\/tools\/javac\/api\/TestGetElementReference.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -707,3 +707,1 @@\n-            List<String> options = List.of(\"--enable-preview\",\n-                                           \"-source\", System.getProperty(\"java.specification.version\"));\n-            JavacTask t = (JavacTask) c.getTask(null, fm, null, options, null,\n+            JavacTask t = (JavacTask) c.getTask(null, fm, null, null, null,\n","filename":"test\/langtools\/tools\/javac\/api\/TestGetScopeResult.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+ *                                      RELEASE_18\n","filename":"test\/langtools\/tools\/javac\/api\/TestGetSourceVersions.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,2 +29,1 @@\n- * @compile --enable-preview -source ${jdk.version} TestGetTypeMirrorReference.java\n- * @run main\/othervm --enable-preview TestGetTypeMirrorReference\n+ * @run main TestGetTypeMirrorReference\n","filename":"test\/langtools\/tools\/javac\/api\/lambdaErrorRecovery\/TestGetTypeMirrorReference.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,2 @@\n-        SEVENTEEN(\"17\", 61);\n+        SEVENTEEN(\"17\", 61),\n+        EIGHTEEN(\"18\", 62);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/ClassVersionChecker.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-                for (JavaFileObject file : compile(testCase.src).getClasses().values()) {\n+                for (JavaFileObject file : compile(testCase.extraCompilerOptions, testCase.src).getClasses().values()) {\n@@ -87,4 +87,11 @@\n-                assertTrue(coveredLines.containsAll(testCase.expectedLines),\n-                        format(\"All significant lines are not covered.%n\" +\n-                                \"Covered: %s%n\" +\n-                                \"Expected: %s%n\", coveredLines, testCase.expectedLines));\n+                if (testCase.exactLines) {\n+                    assertTrue(coveredLines.equals(testCase.expectedLines),\n+                            format(\"Incorrect covered lines.%n\" +\n+                                    \"Covered: %s%n\" +\n+                                    \"Expected: %s%n\", coveredLines, testCase.expectedLines));\n+                } else {\n+                    assertTrue(coveredLines.containsAll(testCase.expectedLines),\n+                            format(\"All significant lines are not covered.%n\" +\n+                                    \"Covered: %s%n\" +\n+                                    \"Expected: %s%n\", coveredLines, testCase.expectedLines));\n+                }\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/LineNumberTable\/LineNumberTestBase.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262891\n+ * @summary Verify correct LineNumberTable for rule switches.\n+ * @library \/tools\/lib \/tools\/javac\/lib ..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.jdeps\/com.sun.tools.classfile\n+ * @build toolbox.ToolBox InMemoryFileManager TestBase\n+ * @build LineNumberTestBase TestCase\n+ * @run main RuleSwitchBreaks\n+ *\/\n+\n+import java.util.List;\n+\n+public class RuleSwitchBreaks extends LineNumberTestBase {\n+    public static void main(String[] args) throws Exception {\n+        new RuleSwitchBreaks().test();\n+    }\n+\n+    public void test() throws Exception {\n+        test(List.of(TEST_CASE));\n+    }\n+\n+    private static final TestCase[] TEST_CASE = new TestCase[] {\n+        new TestCase(\"\"\"\n+                     public class Test {                                   \/\/ 1\n+                         private void test(int i) {                        \/\/ 2\n+                             switch (i) {                                  \/\/ 3\n+                                 case 0 ->                                 \/\/ 4\n+                                     System.out.println(\"a\");              \/\/ 5\n+                                 case 1 ->                                 \/\/ 6\n+                                     System.out.println(\"a\");              \/\/ 7\n+                                 default ->                                \/\/ 8\n+                                     System.out.println(\"default\");        \/\/ 9\n+                             }                                             \/\/10\n+                         }                                                 \/\/11\n+                     }                                                     \/\/12\n+                     \"\"\",\n+                     List.of(1, 3, 5, 7, 9, 11),\n+                     true,\n+                     List.of(),\n+                     \"Test\"),\n+        new TestCase(\"\"\"\n+                     public class TestGuards {                             \/\/ 1\n+                         private void test(Object o) {                     \/\/ 2\n+                             switch (o) {                                  \/\/ 3\n+                                 case String s && s.isEmpty() ->           \/\/ 4\n+                                     System.out.println(\"a\");              \/\/ 5\n+                                 case String s ->                          \/\/ 6\n+                                     System.out.println(\"a\");              \/\/ 7\n+                                 default ->                                \/\/ 8\n+                                     System.out.println(\"default\");        \/\/ 9\n+                             }                                             \/\/10\n+                         }                                                 \/\/11\n+                     }                                                     \/\/12\n+                     \"\"\",\n+                     List.of(1, 3, 4, 5, 6, 7, 9, 11),\n+                     true,\n+                     List.of(\"--enable-preview\", \"-source\", System.getProperty(\"java.specification.version\")),\n+                     \"TestGuards\")\n+    };\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/LineNumberTable\/RuleSwitchBreaks.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+import java.util.List;\n@@ -35,0 +36,2 @@\n+    public final boolean exactLines;\n+    public final List<String> extraCompilerOptions;\n@@ -44,0 +47,6 @@\n+        this(src, expectedLines, false, List.of(), name);\n+    }\n+\n+    public TestCase(String src, Collection<Integer> expectedLines,\n+                    boolean exactLines, List<String> extraCompilerOptions,\n+                    String name) {\n@@ -46,0 +55,2 @@\n+        this.exactLines = exactLines;\n+        this.extraCompilerOptions = extraCompilerOptions;\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/LineNumberTable\/TestCase.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,0 +27,4 @@\n+\/\/ key: compiler.misc.guard\n+\/\/ key: compiler.misc.feature.pattern.switch\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n@@ -44,0 +48,7 @@\n+\n+    void test3(Object o, int i) {\n+        switch (o) {\n+            case String s && s.length() == i++: break;\n+            default: break;\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantRefNonEffectivelyFinalVar.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.misc.feature.case.null\n+\/\/ key: compiler.warn.preview.feature.use\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class CaseNull {\n+    private void doSwitch(String s) {\n+        switch (s) {\n+            case null: break;\n+            default: break;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CaseNull.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.constant.label.not.compatible\n+\/\/ key: compiler.misc.feature.pattern.switch\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class ConstantLabelNotCompatible {\n+    private void doSwitch(Object o) {\n+        switch (o) {\n+            case 0:\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ConstantLabelNotCompatible.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.duplicate.total.pattern\n+\/\/ key: compiler.misc.feature.pattern.switch\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class DuplicateTotalPattern {\n+    private void doSwitch(Object o) {\n+        switch (o) {\n+            case Object obj: break;\n+            case Object obj: break;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/DuplicateTotalPattern.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.flows.through.from.pattern\n+\/\/ key: compiler.misc.feature.pattern.switch\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class FlowsThroughToPattern {\n+    private void doSwitch(Object o) {\n+        switch (o) {\n+            case String str:\n+            default: break;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FlowsThroughFromPattern.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.flows.through.to.pattern\n+\/\/ key: compiler.misc.feature.pattern.switch\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class FlowsThroughToPattern {\n+    private void doSwitch(Object o) {\n+        switch (o) {\n+            case String str:\n+            case Object obj: break;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FlowsThroughToPattern.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -26,1 +26,0 @@\n-\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/IllegalStartOfStmt.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.not.exhaustive.statement\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview --source ${jdk.version}\n+\n+class NotExhaustive {\n+    void t(Object o) {\n+        switch (o) {\n+            case String s -> System.err.println(\"String of length: \" + s.length());\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NotExhaustiveStatement.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.pattern.dominated\n+\/\/ key: compiler.misc.feature.pattern.switch\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class PatternDominated {\n+    private void doSwitch(Object o) {\n+        switch (o) {\n+            case CharSequence cs: break;\n+            case String str: break;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PatternDominated.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.misc.feature.pattern.switch\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class PatternSwitch {\n+    private void doSwitch(Object o) {\n+        switch (o) {\n+            case String str: break;\n+            default: break;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PatternSwitch.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.switch.null.not.allowed\n-\n-class SwitchNullNotAllowed {\n-\n-    void test(Integer i) {\n-        switch (i) {\n-            case null: break;\n-            case 0: break;\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/SwitchNullNotAllowed.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.total.pattern.and.default\n+\/\/ key: compiler.misc.feature.pattern.switch\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class TotalPatternAndDefault {\n+    private void doSwitch(Object o) {\n+        switch (o) {\n+            case Object obj: break;\n+            default: break;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/TotalPatternAndDefault.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -97,2 +97,1 @@\n-                                \"-XDdebug.dumpLambdaToMethodStats\",\n-                                \"--enable-preview\", \"-source\", sourceVersion),\n+                                \"-XDdebug.dumpLambdaToMethodStats\"),\n","filename":"test\/langtools\/tools\/javac\/lambda\/deduplication\/DeduplicationTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -741,1 +741,1 @@\n-            printList(\"pat\", tree.pats);\n+            printList(\"labels\", tree.labels);\n","filename":"test\/langtools\/tools\/javac\/lib\/DPrinter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -124,1 +124,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -134,1 +134,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -144,1 +144,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -165,1 +165,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -184,1 +184,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -205,1 +205,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -226,1 +226,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -247,1 +247,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n","filename":"test\/langtools\/tools\/javac\/lib\/JavacTestingAbstractProcessor.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8232948\n+ * @summary Make sure inner classes are correctly encoded\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ * @modules jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.JavacTask toolbox.TestRunner toolbox.ToolBox\n+ * @run main EncodeInnerClassNameTest\n+ *\/\n+\n+import toolbox.JavacTask;\n+import toolbox.ToolBox;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class EncodeInnerClassNameTest {\n+    private final ToolBox toolBox = new ToolBox();\n+    private final String source = \"\"\"\n+            package p.q;\n+            public class Outer {\n+                public class Inner {\n+                    native Inner aMethod();\n+                    native void aMethod(Inner i);\n+                    native void aMethod(Inner i, Inner j);\n+                }\n+            }\n+            \"\"\";\n+\n+    private final String expected = \"\"\"\n+            \/* DO NOT EDIT THIS FILE - it is machine generated *\/\n+            #include <jni.h>\n+            \/* Header for class p_q_Outer_Inner *\/\n+\n+            #ifndef _Included_p_q_Outer_Inner\n+            #define _Included_p_q_Outer_Inner\n+            #ifdef __cplusplus\n+            extern \"C\" {\n+            #endif\n+            \/*\n+             * Class:     p_q_Outer_Inner\n+             * Method:    aMethod\n+             * Signature: ()Lp\/q\/Outer\/Inner;\n+             *\/\n+            JNIEXPORT jobject JNICALL Java_p_q_Outer_00024Inner_aMethod__\n+              (JNIEnv *, jobject);\n+\n+            \/*\n+             * Class:     p_q_Outer_Inner\n+             * Method:    aMethod\n+             * Signature: (Lp\/q\/Outer\/Inner;)V\n+             *\/\n+            JNIEXPORT void JNICALL Java_p_q_Outer_00024Inner_aMethod__Lp_q_Outer_00024Inner_2\n+              (JNIEnv *, jobject, jobject);\n+\n+            \/*\n+             * Class:     p_q_Outer_Inner\n+             * Method:    aMethod\n+             * Signature: (Lp\/q\/Outer\/Inner;Lp\/q\/Outer\/Inner;)V\n+             *\/\n+            JNIEXPORT void JNICALL Java_p_q_Outer_00024Inner_aMethod__Lp_q_Outer_00024Inner_2Lp_q_Outer_00024Inner_2\n+              (JNIEnv *, jobject, jobject, jobject);\n+\n+            #ifdef __cplusplus\n+            }\n+            #endif\n+            #endif\n+            \"\"\";\n+\n+    public static void main(String... args) throws Exception {\n+        new EncodeInnerClassNameTest().runTest();\n+    }\n+\n+    public void runTest() throws Exception {\n+        JavacTask task = new JavacTask(toolBox);\n+        task.outdir(\".\")\n+                .sources(source)\n+                .options(\"-h\", \".\")\n+                .run()\n+                .writeAll();\n+\n+        List<String> expected = Arrays.asList(this.expected.split(\"\\\\R\"));\n+        List<String> res = toolBox.readAllLines(Path.of(\".\", \"p_q_Outer_Inner.h\"));\n+\n+        toolBox.checkEqual(expected, res);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nativeHeaders\/EncodeInnerClassNameTest.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -1500,2 +1500,1 @@\n-                List.of(\"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature())),\n-                null, Arrays.asList(new MyFileObject(code)));\n+                null, null, Arrays.asList(new MyFileObject(code)));\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8262891\n+ * @summary Check null handling for non-pattern switches.\n+ * @compile\/fail\/ref=CaseDefault.out -source 16 -Xlint:-options -XDrawDiagnostics CaseDefault.java\n+ * @compile --enable-preview -source ${jdk.version} CaseDefault.java\n+ * @run main\/othervm --enable-preview CaseDefault\n+ *\/\n+\n+public class CaseDefault {\n+\n+    public static void main(String[] args) {\n+        new CaseDefault().run();\n+    }\n+\n+    void run() {\n+        String str = \"other\";\n+        switch (str) {\n+            case \"a\": throw new AssertionError(\"Wrong branch.\");\n+            case default: break; \/\/OK\n+        }\n+        switch (str) {\n+            case \"a\" -> throw new AssertionError(\"Wrong branch.\");\n+            case default -> {} \/\/OK\n+        }\n+        int i;\n+        i = switch (str) {\n+            case \"a\": throw new AssertionError(\"Wrong branch.\");\n+            case default: yield 0; \/\/OK\n+        };\n+        i = switch (str) {\n+            case \"a\" -> throw new AssertionError(\"Wrong branch.\");\n+            case default -> 0; \/\/OK\n+        };\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/CaseDefault.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CaseDefault.java:20:18: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\n+1 error\n","filename":"test\/langtools\/tools\/javac\/patterns\/CaseDefault.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/**\n+ * @test\n+ * @modules jdk.compiler\/com.sun.tools.javac.file\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.parser\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @compile --enable-preview -source ${jdk.version} DisambiguateParenthesizedPattern.java\n+ * @run main\/othervm --enable-preview DisambiguateParenthesizedPattern\n+ *\/\n+\n+import com.sun.source.tree.CaseLabelTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.PatternTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.tools.javac.file.JavacFileManager;\n+import com.sun.tools.javac.parser.JavacParser;\n+import com.sun.tools.javac.parser.ParserFactory;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.main.Option;\n+import com.sun.tools.javac.util.Options;\n+import java.nio.charset.Charset;\n+\n+public class DisambiguateParenthesizedPattern {\n+\n+    public static void main(String... args) throws Throwable {\n+        DisambiguateParenthesizedPattern test = new DisambiguateParenthesizedPattern();\n+        test.disambiguationTest(\"String s\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"String s && s.isEmpty()\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"(String s)\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"((String s))\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"(String) s\",\n+                                 ExpressionType.EXPRESSION);\n+        test.disambiguationTest(\"((String) s)\",\n+                                 ExpressionType.EXPRESSION);\n+        test.disambiguationTest(\"((0x1))\",\n+                                 ExpressionType.EXPRESSION);\n+    }\n+\n+    private final ParserFactory factory;\n+\n+    public DisambiguateParenthesizedPattern() {\n+        Context context = new Context();\n+        JavacFileManager jfm = new JavacFileManager(context, true, Charset.defaultCharset());\n+        Options.instance(context).put(Option.PREVIEW, \"\");\n+        factory = ParserFactory.instance(context);\n+    }\n+\n+    void disambiguationTest(String snippet, ExpressionType expectedType) {\n+        String code = \"\"\"\n+                      public class Test {\n+                          private void test() {\n+                              switch (null) {\n+                                  case SNIPPET -> {}\n+                              }\n+                          }\n+                      }\n+                      \"\"\".replace(\"SNIPPET\", snippet);\n+        JavacParser parser = factory.newParser(code, false, false, false);\n+        CompilationUnitTree result = parser.parseCompilationUnit();\n+        ClassTree clazz = (ClassTree) result.getTypeDecls().get(0);\n+        MethodTree method = (MethodTree) clazz.getMembers().get(0);\n+        SwitchTree st = (SwitchTree) method.getBody().getStatements().get(0);\n+        CaseLabelTree label = st.getCases().get(0).getLabels().get(0);\n+        ExpressionType actualType = switch (label) {\n+            case ExpressionTree et -> ExpressionType.EXPRESSION;\n+            case PatternTree pt -> ExpressionType.PATTERN;\n+            default -> throw new AssertionError(\"Unexpected result: \" + result);\n+        };\n+        if (expectedType != actualType) {\n+            throw new AssertionError(\"Expected: \" + expectedType + \", actual: \" + actualType +\n+                                      \", for: \" + code + \", parsed: \" + result);\n+        }\n+    }\n+\n+    enum ExpressionType {\n+        PATTERN,\n+        EXPRESSION;\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/DisambiguateParenthesizedPattern.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262891\n+ * @summary Check the pattern domination error are reported correctly.\n+ * @compile\/fail\/ref=Domination.out -XDrawDiagnostics --enable-preview -source ${jdk.version} Domination.java\n+ *\/\n+public class Domination {\n+\n+    int testDominatesError1(Object o) {\n+        switch (o) {\n+            case CharSequence cs: return 0;\n+            case String s: return 1;\n+            case Object x: return -1;\n+        }\n+    }\n+\n+    int testDominatesError2(Object o) {\n+        switch (o) {\n+            case CharSequence cs: return 0;\n+            case String s && s.isEmpty(): return 1;\n+            case Object x: return -1;\n+        }\n+    }\n+\n+    int testDominatesError3(Object o) {\n+        switch (o) {\n+            case CharSequence cs && true: return 0;\n+            case String s && s.isEmpty(): return 1;\n+            case Object x: return -1;\n+        }\n+    }\n+\n+    int testNotDominates1(Object o) {\n+        switch (o) {\n+            case CharSequence cs && cs.length() == 0: return 0;\n+            case String s: return 1;\n+            case Object x: return -1;\n+        }\n+    }\n+\n+    int testDominatesStringConstant(String str) {\n+        switch (str) {\n+            case String s: return 1;\n+            case \"\": return -1;\n+        }\n+    }\n+\n+    int testDominatesIntegerConstant(Integer i) {\n+        switch (i) {\n+            case Integer j: return 1;\n+            case 0: return -1;\n+        }\n+    }\n+\n+    int testDominatesEnumConstant() {\n+        enum E {\n+            A, B;\n+        }\n+        E e = E.A;\n+        switch (e) {\n+            case E d: return 1;\n+            case A: return -1;\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/Domination.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+Domination.java:35:18: compiler.err.pattern.dominated\n+Domination.java:43:18: compiler.err.pattern.dominated\n+Domination.java:51:18: compiler.err.pattern.dominated\n+Domination.java:67:18: compiler.err.pattern.dominated\n+Domination.java:74:18: compiler.err.pattern.dominated\n+Domination.java:85:18: compiler.err.pattern.dominated\n+- compiler.note.preview.filename: Domination.java, DEFAULT\n+- compiler.note.preview.recompile\n+6 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/Domination.out","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,643 @@\n+\/*\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8262891\n+ * @summary Check exhaustiveness of switches over sealed types.\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main Exhaustiveness\n+*\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class Exhaustiveness extends TestRunner {\n+\n+    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new Exhaustiveness().runTests();\n+    }\n+\n+    Exhaustiveness() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testExhaustiveSealedClasses(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case B b -> 1;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testNonExhaustiveSealedClasses(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:5:16: compiler.err.not.exhaustive\",\n+               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+               \"- compiler.note.preview.recompile\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testAbstractSealedClasses(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed abstract class S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A extends S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B extends S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case B b -> 1;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testConcreteSealedClasses(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed class S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A extends S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B extends S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case B b -> 1;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:5:16: compiler.err.not.exhaustive\",\n+               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+               \"- compiler.note.preview.recompile\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testGuards1(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a && a.toString().isEmpty() -> 0;\n+                           case B b -> 1;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:5:16: compiler.err.not.exhaustive\",\n+               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+               \"- compiler.note.preview.recompile\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testGuards2(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private static final boolean TEST = true;\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a && !(!(TEST)) -> 0;\n+                           case B b -> 1;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testGuards3(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a && false -> 0;\n+                           case B b -> 1;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:5:16: compiler.err.not.exhaustive\",\n+               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+               \"- compiler.note.preview.recompile\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testCoversType1(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case S s -> 1;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testCoversType2(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public interface S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case S s -> 1;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testCoversType3(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public interface S<T> {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S<A> {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S<B> {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case S<?> s -> 1;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    private void doTest(Path base, String[] libraryCode, String testCode, String... expectedErrors) throws IOException {\n+        Path current = base.resolve(\".\");\n+        Path libSrc = current.resolve(\"lib-src\");\n+        for (String code : libraryCode) {\n+            tb.writeJavaFiles(libSrc, code);\n+        }\n+\n+        Path libClasses = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        new JavacTask(tb)\n+                .options(\"--enable-preview\",\n+                         \"-source\", JAVA_VERSION)\n+                .outdir(libClasses)\n+                .files(tb.findJavaFiles(libSrc))\n+                .run();\n+\n+        Path src = current.resolve(\"src\");\n+        tb.writeJavaFiles(src, testCode);\n+\n+        Path classes = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        var log =\n+                new JavacTask(tb)\n+                    .options(\"--enable-preview\",\n+                             \"-source\", JAVA_VERSION,\n+                             \"-XDrawDiagnostics\",\n+                             \"-Xlint:-preview\",\n+                             \"--class-path\", libClasses.toString())\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(expectedErrors.length > 0 ? Task.Expect.FAIL : Task.Expect.SUCCESS)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+        if (expectedErrors.length > 0 && !List.of(expectedErrors).equals(log)) {\n+            throw new AssertionError(\"Incorrect errors, expected: \" + List.of(expectedErrors) +\n+                                      \", actual: \" + log);\n+        }\n+    }\n+\n+    @Test\n+    public void testInaccessiblePermitted(Path base) throws IOException {\n+        Path current = base.resolve(\".\");\n+        Path libSrc = current.resolve(\"lib-src\");\n+\n+        tb.writeJavaFiles(libSrc,\n+                           \"\"\"\n+                           package lib;\n+                           public sealed interface S permits A, B {}\n+                           \"\"\",\n+                           \"\"\"\n+                           package lib;\n+                           public final class A implements S {}\n+                           \"\"\",\n+                           \"\"\"\n+                           package lib;\n+                           final class B implements S {}\n+                           \"\"\");\n+\n+        Path libClasses = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        new JavacTask(tb)\n+                .options(\"--enable-preview\",\n+                         \"-source\", JAVA_VERSION)\n+                .outdir(libClasses)\n+                .files(tb.findJavaFiles(libSrc))\n+                .run();\n+\n+        Path src = current.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                           \"\"\"\n+                           package test;\n+                           import lib.*;\n+                           public class Test {\n+                               private int test(S obj) {\n+                                   return switch (obj) {\n+                                       case A a -> 0;\n+                                   };\n+                               }\n+                           }\n+                           \"\"\");\n+\n+        Path classes = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        var log =\n+                new JavacTask(tb)\n+                    .options(\"--enable-preview\",\n+                             \"-source\", JAVA_VERSION,\n+                             \"-XDrawDiagnostics\",\n+                             \"-Xlint:-preview\",\n+                             \"--class-path\", libClasses.toString())\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expectedErrors = List.of(\n+               \"Test.java:5:16: compiler.err.not.exhaustive\",\n+               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+               \"- compiler.note.preview.recompile\",\n+               \"1 error\");\n+\n+        if (!expectedErrors.equals(log)) {\n+            throw new AssertionError(\"Incorrect errors, expected: \" + expectedErrors +\n+                                      \", actual: \" + log);\n+        }\n+\n+        Path bClass = libClasses.resolve(\"lib\").resolve(\"B.class\");\n+\n+        Files.delete(bClass);\n+\n+        var log2 =\n+                new JavacTask(tb)\n+                    .options(\"--enable-preview\",\n+                             \"-source\", JAVA_VERSION,\n+                             \"-XDrawDiagnostics\",\n+                             \"-Xlint:-preview\",\n+                             \"--class-path\", libClasses.toString())\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        if (!expectedErrors.equals(log2)) {\n+            throw new AssertionError(\"Incorrect errors, expected: \" + expectedErrors +\n+                                      \", actual: \" + log2);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testExhaustiveStatement1(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public interface Lib {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Object obj) {\n+                       switch (obj) {\n+                           case Object o: return 0;\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testExhaustiveStatement2(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public interface Lib {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(Object obj) {\n+                       switch (obj) {\n+                           case String s: return;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:4:9: compiler.err.not.exhaustive.statement\",\n+               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+               \"- compiler.note.preview.recompile\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testExhaustiveStatement3(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case S s -> 1;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testExhaustiveStatement4(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:5:16: compiler.err.not.exhaustive\",\n+               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+               \"- compiler.note.preview.recompile\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testExhaustiveStatement5(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case B b -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":643,"deletions":0,"binary":false,"changes":643,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262891\n+ * @summary Check guards implementation.\n+ * @compile --enable-preview -source ${jdk.version} Guards.java\n+ * @run main\/othervm --enable-preview Guards\n+ *\/\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+public class Guards {\n+    public static void main(String... args) {\n+        new Guards().run();\n+    }\n+\n+    void run() {\n+        run(this::typeTestPatternSwitchTest);\n+        run(this::typeTestPatternSwitchExpressionTest);\n+        run(this::testBooleanSwitchExpression);\n+        assertEquals(\"a\", testPatternInGuard(\"a\"));\n+        assertEquals(null, testPatternInGuard(1));\n+    }\n+\n+    void run(Function<Object, String> convert) {\n+        assertEquals(\"zero\", convert.apply(0));\n+        assertEquals(\"one\", convert.apply(1));\n+        assertEquals(\"other\", convert.apply(-1));\n+        assertEquals(\"any\", convert.apply(\"\"));\n+    }\n+\n+    String typeTestPatternSwitchTest(Object o) {\n+        switch (o) {\n+            case Integer i && i == 0: return \"zero\";\n+            case Integer i && i == 1: return \"one\";\n+            case Integer i: return \"other\";\n+            case Object x: return \"any\";\n+        }\n+    }\n+\n+    String typeTestPatternSwitchExpressionTest(Object o) {\n+        return switch (o) {\n+            case Integer i && i == 0 -> \"zero\";\n+            case Integer i && i == 1 -> { yield \"one\"; }\n+            case Integer i -> \"other\";\n+            case Object x -> \"any\";\n+        };\n+    }\n+\n+    String testBooleanSwitchExpression(Object o) {\n+        String x;\n+        if (switch (o) {\n+            case Integer i && i == 0 -> (x = \"zero\") != null;\n+            case Integer i && i == 1 -> { x = \"one\"; yield true; }\n+            case Integer i -> { x = \"other\"; yield true; }\n+            case Object other -> (x = \"any\") != null;\n+        }) {\n+            return x;\n+        } else {\n+            throw new IllegalStateException(\"TODO - needed?\");\n+        }\n+    }\n+\n+    String testPatternInGuard(Object o) {\n+        if (o instanceof (CharSequence cs && cs instanceof String s)) {\n+            return s;\n+        }\n+        return null;\n+    }\n+\n+    void assertEquals(String expected, String actual) {\n+        if (!Objects.equals(expected, actual)) {\n+            throw new AssertionError(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/Guards.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262891\n+ * @summary Check errors reported for guarded patterns.\n+ * @compile\/fail\/ref=GuardsErrors.out -XDrawDiagnostics --enable-preview -source ${jdk.version} GuardsErrors.java\n+ *\/\n+\n+public class GuardsErrors {\n+\n+    void typeTestPatternSwitchTest(Object o, int check) {\n+        switch (o) {\n+            case Integer i && i == check -> System.err.println(); \/\/error: check is not effectivelly final\n+            default -> {}\n+        }\n+        check = 0;\n+\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/GuardsErrors.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+GuardsErrors.java:35:36: compiler.err.cant.ref.non.effectively.final.var: check, (compiler.misc.guard)\n+- compiler.note.preview.filename: GuardsErrors.java, DEFAULT\n+- compiler.note.preview.recompile\n+1 error\n","filename":"test\/langtools\/tools\/javac\/patterns\/GuardsErrors.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8262891\n+ * @summary Check null handling for non-pattern switches.\n+ * @compile --enable-preview -source ${jdk.version} NullSwitch.java\n+ * @run main\/othervm --enable-preview NullSwitch\n+ *\/\n+\n+public class NullSwitch {\n+\n+    public static void main(String[] args) {\n+        new NullSwitch().switchTest();\n+    }\n+\n+    void switchTest() {\n+        assertEquals(0, matchingSwitch1(\"\"));\n+        assertEquals(1, matchingSwitch1(\"a\"));\n+        assertEquals(100, matchingSwitch1(0));\n+        assertEquals(-1, matchingSwitch1(null));\n+        assertEquals(-2, matchingSwitch1(0.0));\n+        assertEquals(0, matchingSwitch2(\"\"));\n+        assertEquals(1, matchingSwitch2(null));\n+        assertEquals(1, matchingSwitch2(0.0));\n+        assertEquals(0, matchingSwitch3(\"\"));\n+        assertEquals(1, matchingSwitch3(\"a\"));\n+        assertEquals(100, matchingSwitch3(0));\n+        assertEquals(-1, matchingSwitch3(null));\n+        assertEquals(-2, matchingSwitch3(0.0));\n+        assertEquals(0, matchingSwitch4(\"\"));\n+        assertEquals(1, matchingSwitch4(null));\n+        assertEquals(1, matchingSwitch4(0.0));\n+        assertEquals(0, matchingSwitch5(\"\"));\n+        assertEquals(1, matchingSwitch5(\"a\"));\n+        assertEquals(100, matchingSwitch5(0));\n+        assertEquals(-1, matchingSwitch5(null));\n+        assertEquals(-2, matchingSwitch5(0.0));\n+        assertEquals(0, matchingSwitch6(\"\"));\n+        assertEquals(1, matchingSwitch6(null));\n+        assertEquals(1, matchingSwitch6(0.0));\n+        assertEquals(0, matchingSwitch7(\"\"));\n+        assertEquals(1, matchingSwitch7(\"a\"));\n+        assertEquals(100, matchingSwitch7(0));\n+        assertEquals(-1, matchingSwitch7(null));\n+        assertEquals(-2, matchingSwitch7(0.0));\n+        assertEquals(0, matchingSwitch8(\"\"));\n+        assertEquals(1, matchingSwitch8(null));\n+        assertEquals(1, matchingSwitch8(0.0));\n+        assertEquals(0, matchingSwitch9(\"\"));\n+        assertEquals(1, matchingSwitch9(null));\n+        assertEquals(1, matchingSwitch9(0.0));\n+        assertEquals(0, matchingSwitch10(\"\"));\n+        assertEquals(1, matchingSwitch10(null));\n+        assertEquals(1, matchingSwitch10(0.0));\n+        assertEquals(0, matchingSwitch11(\"\"));\n+        assertEquals(2, matchingSwitch11(null));\n+        assertEquals(1, matchingSwitch11(0.0));\n+        assertEquals(0, matchingSwitch12(\"\"));\n+        assertEquals(2, matchingSwitch12(null));\n+        assertEquals(1, matchingSwitch12(0.0));\n+    }\n+\n+    private int matchingSwitch1(Object obj) {\n+        return switch (obj) {\n+            case String s -> s.length();\n+            case null, Integer i -> i == null ? -1 : 100 + i;\n+            default -> -2;\n+        };\n+    }\n+\n+    private int matchingSwitch2(Object obj) {\n+        return switch (obj) {\n+            case String s -> 0;\n+            case null, default -> 1;\n+        };\n+    }\n+\n+    private int matchingSwitch3(Object obj) {\n+        return switch (obj) {\n+            case String s -> s.length();\n+            case Integer i, null -> i == null ? -1 : 100 + i;\n+            default -> -2;\n+        };\n+    }\n+\n+    private int matchingSwitch4(Object obj) {\n+        return switch (obj) {\n+            case String s -> 0;\n+            case default, null -> 1;\n+        };\n+    }\n+\n+    private int matchingSwitch5(Object obj) {\n+        return switch (obj) {\n+            case String s: yield s.length();\n+            case null:\n+            case Integer i: yield i == null ? -1 : 100 + i;\n+            default: yield -2;\n+        };\n+    }\n+\n+    private int matchingSwitch6(Object obj) {\n+        return switch (obj) {\n+            case String s: yield 0;\n+            case null:\n+            default: yield 1;\n+        };\n+    }\n+\n+    private int matchingSwitch7(Object obj) {\n+        return switch (obj) {\n+            case String s: yield s.length();\n+            case Integer i:\n+            case null: yield i == null ? -1 : 100 + i;\n+            default: yield -2;\n+        };\n+    }\n+\n+    private int matchingSwitch8(Object obj) {\n+        return switch (obj) {\n+            case String s: yield 0;\n+            default:\n+            case null: yield 1;\n+        };\n+    }\n+\n+    private int matchingSwitch9(Object obj) {\n+        return switch (obj) {\n+            case String s: yield 0;\n+            case Object o: yield 1;\n+        };\n+    }\n+\n+    private int matchingSwitch10(Object obj) {\n+        switch (obj) {\n+            case String s: return 0;\n+            case Object o: return 1;\n+        }\n+    }\n+\n+    private int matchingSwitch11(Object obj) {\n+        try {\n+            return switch (obj) {\n+                case String s: yield 0;\n+                default: yield 1;\n+            };\n+        } catch (NullPointerException ex) {\n+            return 2;\n+        }\n+    }\n+\n+    private int matchingSwitch12(Object obj) {\n+        try {\n+            switch (obj) {\n+                case String s: return 0;\n+                default: return 1;\n+            }\n+        } catch (NullPointerException ex) {\n+            return 2;\n+        }\n+    }\n+\n+    static void assertEquals(int expected, int actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", actual: \" + actual);\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/NullSwitch.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262891\n+ * @summary Test parenthesized pattern\n+ * @compile --enable-preview -source ${jdk.version} Parenthesized.java\n+ * @run main\/othervm --enable-preview Parenthesized\n+ *\/\n+public class Parenthesized {\n+    public static void main(String... args) {\n+        new Parenthesized().run();\n+    }\n+\n+    void run() {\n+        Object o = \"\";\n+        switch (o) {\n+            case (String s && s.isEmpty()) -> System.err.println(\"OK: \" + s);\n+            default -> throw new AssertionError();\n+        }\n+        System.err.println(switch (o) {\n+            case (String s && s.isEmpty()) -> \"OK: \" + s;\n+            default -> throw new AssertionError();\n+        });\n+        if (o instanceof (String s && s.isEmpty())) {\n+            System.err.println(\"OK: \" + s);\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/Parenthesized.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262891\n+ * @summary Verify pattern switches work properly when the set of sealed types changes.\n+ * @compile --enable-preview -source ${jdk.version} SealedTypeChanges.java\n+ * @compile --enable-preview -source ${jdk.version} SealedTypeChanges2.java\n+ * @run main\/othervm --enable-preview SealedTypeChanges\n+ *\/\n+\n+import java.util.function.Consumer;\n+\n+public class SealedTypeChanges {\n+\n+    public static void main(String... args) throws Exception {\n+        new SealedTypeChanges().run();\n+    }\n+\n+    void run() throws Exception {\n+        doRun(this::expressionIntf, this::validateIncompatibleClassChangeError);\n+        doRun(this::statementIntf, this::validateIncompatibleClassChangeError);\n+        doRun(this::expressionCls, this::validateIncompatibleClassChangeError);\n+        doRun(this::statementCls, this::validateIncompatibleClassChangeError);\n+        doRun(this::expressionCoveredIntf, this::validateTestException);\n+        doRun(this::statementCoveredIntf, this::validateTestException);\n+        doRun(this::expressionCoveredCls, this::validateTestException);\n+        doRun(this::statementCoveredCls, this::validateTestException);\n+    }\n+\n+    <T> void doRun(Consumer<T> t, Consumer<Throwable> validateException) throws Exception {\n+        t.accept((T) new A());\n+        try {\n+            t.accept((T) Class.forName(\"SealedTypeChangesClass\").newInstance());\n+            throw new AssertionError(\"Expected an exception, but none thrown.\");\n+        } catch (Throwable ex) {\n+            validateException.accept(ex);\n+        }\n+    }\n+\n+    void validateIncompatibleClassChangeError(Throwable t) {\n+        if (!(t instanceof IncompatibleClassChangeError)) {\n+            throw new AssertionError(\"Unexpected exception\", t);\n+        }\n+    }\n+\n+    void validateTestException(Throwable t) {\n+        if (!(t instanceof TestException)) {\n+            throw new AssertionError(\"Unexpected exception\", t);\n+        }\n+    }\n+\n+    void statementIntf(SealedTypeChangesIntf obj) {\n+        switch (obj) {\n+            case A a -> System.err.println(1);\n+        }\n+    }\n+\n+    int expressionIntf(SealedTypeChangesIntf obj) {\n+        return switch (obj) {\n+            case A a -> 0;\n+        };\n+    }\n+\n+    void statementCls(SealedTypeChangesCls obj) {\n+        switch (obj) {\n+            case A a -> System.err.println(1);\n+        }\n+    }\n+\n+    int expressionCls(SealedTypeChangesCls obj) {\n+        return switch (obj) {\n+            case A a -> 0;\n+        };\n+    }\n+\n+    void statementCoveredIntf(SealedTypeChangesIntf obj) {\n+        switch (obj) {\n+            case A a -> System.err.println(1);\n+            case SealedTypeChangesIntf o -> throw new TestException();\n+        }\n+    }\n+\n+    int expressionCoveredIntf(SealedTypeChangesIntf obj) {\n+        return switch (obj) {\n+            case A a -> 0;\n+            case SealedTypeChangesIntf o -> throw new TestException();\n+        };\n+    }\n+\n+    void statementCoveredCls(SealedTypeChangesCls obj) {\n+        switch (obj) {\n+            case A a -> System.err.println(1);\n+            case SealedTypeChangesCls o -> throw new TestException();\n+        }\n+    }\n+\n+    int expressionCoveredCls(SealedTypeChangesCls obj) {\n+        return switch (obj) {\n+            case A a -> 0;\n+            case SealedTypeChangesCls o -> throw new TestException();\n+        };\n+    }\n+\n+    final static class A extends SealedTypeChangesCls implements SealedTypeChangesIntf {}\n+    class TestException extends RuntimeException {}\n+}\n+\n+sealed interface SealedTypeChangesIntf permits SealedTypeChanges.A {}\n+sealed abstract class SealedTypeChangesCls permits SealedTypeChanges.A {}\n","filename":"test\/langtools\/tools\/javac\/patterns\/SealedTypeChanges.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+sealed interface SealedTypeChangesIntf permits SealedTypeChanges.A, SealedTypeChangesClass {}\n+sealed abstract class SealedTypeChangesCls permits SealedTypeChanges.A, SealedTypeChangesClass {}\n+final class SealedTypeChangesClass extends SealedTypeChangesCls implements SealedTypeChangesIntf {}\n","filename":"test\/langtools\/tools\/javac\/patterns\/SealedTypeChanges2.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/**\n+ * @test\n+ * @compile --enable-preview -source ${jdk.version} -doe SimpleAndGuardPattern.java\n+ * @run main\/othervm --enable-preview SimpleAndGuardPattern\n+ *\/\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class SimpleAndGuardPattern {\n+\n+    public static void main(String... args) throws Throwable {\n+        if (!Objects.equals(4, simple(\"test\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!Objects.equals(4, simple(\"TEST\"))) {\n+            throw new IllegalStateException();\n+        }\n+        if (!Objects.equals(-1, simple(\"other\"))) {\n+            throw new IllegalStateException();\n+        }\n+    }\n+\n+    private static int simple(Object o) throws Throwable {\n+        return switch (o) {\n+            case String s && s.equalsIgnoreCase(\"test\") -> s.length();\n+            default -> -1;\n+        };\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/SimpleAndGuardPattern.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262891\n+ * @summary Verify errors related to pattern switches.\n+ * @compile\/fail\/ref=SwitchErrors.out --enable-preview -source ${jdk.version} -XDrawDiagnostics -XDshould-stop.at=FLOW SwitchErrors.java\n+ *\/\n+public class SwitchErrors {\n+    void incompatibleSelectorObjectString(Object o) {\n+        switch (o) {\n+            case \"A\": break;\n+            case CharSequence cs: break;\n+        }\n+    }\n+    void incompatibleSelectorObjectInteger(Object o) {\n+        switch (o) {\n+            case 1: break;\n+            case CharSequence cs: break;\n+        }\n+    }\n+    void incompatibleSelectorIntegerString(Integer i) {\n+        switch (i) {\n+            case \"A\": break;\n+            case CharSequence cs: break;\n+        }\n+    }\n+    void incompatibleSelectorPrimitive(int i) {\n+        switch (i) {\n+            case null: break;\n+            case \"A\": break;\n+            case CharSequence cs: break;\n+        }\n+    }\n+    void totalAndDefault1(Object o) {\n+        switch (o) {\n+            case Object obj: break;\n+            default: break;\n+        }\n+    }\n+    void totalAndDefault2(Object o) {\n+        switch (o) {\n+            case Object obj: break;\n+            case null, default: break;\n+        }\n+    }\n+    void totalAndDefault3(Object o) {\n+        switch (o) {\n+            default: break;\n+            case Object obj: break;\n+        }\n+    }\n+    void duplicatedTotal(Object o) {\n+        switch (o) {\n+            case Object obj: break;\n+            case Object obj: break;\n+        }\n+    }\n+    void duplicatedDefault1(Object o) {\n+        switch (o) {\n+            case null, default: break;\n+            default: break;\n+        }\n+    }\n+    void duplicatedDefault2(Object o) {\n+        switch (o) {\n+            case default: break;\n+            default: break;\n+        }\n+    }\n+    void duplicatedDefault3(Object o) {\n+        switch (o) {\n+            case default, default: break;\n+        }\n+    }\n+    void duplicatedNullCase1(Object o) {\n+        switch (o) {\n+            case null: break;\n+            case null: break;\n+        }\n+    }\n+    void duplicatedNullCase2(Object o) {\n+        switch (o) {\n+            case null, null: break;\n+        }\n+    }\n+    void duplicatedTypePatterns1(Object o) {\n+        switch (o) {\n+            case String s, Integer i: break;\n+        }\n+    }\n+    void duplicatedTypePatterns2(Object o) {\n+        switch (o) {\n+            case String s:\n+            case Integer i: break;\n+        }\n+    }\n+    void duplicatedTypePatterns3(Object o) {\n+        switch (o) {\n+            case String s:\n+                System.err.println(1);\n+            case Integer i: break;\n+        }\n+    }\n+    void flowIntoTypePatterns(Object o) {\n+        switch (o) {\n+            case null:\n+                System.err.println(1);\n+            case Integer i: break;\n+        }\n+    }\n+    void incompatible1(String str) {\n+        switch (str) {\n+            case Integer i: break;\n+            default: break;\n+        }\n+    }\n+    void incompatible2(java.util.List l) {\n+        switch (l) {\n+            case java.util.List<Integer> l2: break;\n+        }\n+    }\n+    void erroneous(Object o) {\n+        switch (o) {\n+            case String s: break;\n+            case Undefined u: break;\n+            case Integer i: break;\n+            default: break;\n+        }\n+    }\n+    void primitivePattern(Object o) {\n+        switch (o) {\n+            case int i: break;\n+            default: break;\n+        }\n+    }\n+    void patternAndDefault1(Object o) {\n+        switch (o) {\n+            case String s, default: break;\n+        }\n+    }\n+    void patternAndDefault2(Object o) {\n+        switch (o) {\n+            case String s:\n+            case default: break;\n+        }\n+    }\n+    void patternAndDefault3(Object o) {\n+        switch (o) {\n+            case default, String s: break;\n+        }\n+    }\n+    void patternAndDefault4(Object o) {\n+        switch (o) {\n+            case default:\n+            case String s: break;\n+        }\n+    }\n+    void nullAfterTotal(Object o) {\n+        switch (o) {\n+            case Object obj: break;\n+            case null: break;\n+        }\n+    }\n+    void sealedNonAbstract(SealedNonAbstract obj) {\n+        switch (obj) {\/\/does not cover SealedNonAbstract\n+            case A a -> {}\n+        }\n+    }\n+    sealed class SealedNonAbstract permits A {}\n+    final class A extends SealedNonAbstract {}\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+SwitchErrors.java:33:18: compiler.err.constant.label.not.compatible: java.lang.String, java.lang.Object\n+SwitchErrors.java:39:18: compiler.err.constant.label.not.compatible: int, java.lang.Object\n+SwitchErrors.java:45:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, java.lang.Integer)\n+SwitchErrors.java:46:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Integer, java.lang.CharSequence)\n+SwitchErrors.java:51:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, int)\n+SwitchErrors.java:52:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, int)\n+SwitchErrors.java:53:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.CharSequence)\n+SwitchErrors.java:59:20: compiler.err.total.pattern.and.default\n+SwitchErrors.java:65:13: compiler.err.pattern.dominated\n+SwitchErrors.java:65:24: compiler.err.total.pattern.and.default\n+SwitchErrors.java:71:18: compiler.err.total.pattern.and.default\n+SwitchErrors.java:77:18: compiler.err.duplicate.total.pattern\n+SwitchErrors.java:83:20: compiler.err.duplicate.default.label\n+SwitchErrors.java:89:20: compiler.err.duplicate.default.label\n+SwitchErrors.java:94:27: compiler.err.duplicate.default.label\n+SwitchErrors.java:100:13: compiler.err.duplicate.case.label\n+SwitchErrors.java:105:13: compiler.err.duplicate.case.label\n+SwitchErrors.java:110:28: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:116:18: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:123:18: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:130:18: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:135:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, java.lang.Integer)\n+SwitchErrors.java:141:18: compiler.err.instanceof.reifiable.not.safe: java.util.List, java.util.List<java.lang.Integer>\n+SwitchErrors.java:147:18: compiler.err.cant.resolve.location: kindname.class, Undefined, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n+SwitchErrors.java:154:18: compiler.err.type.found.req: int, (compiler.misc.type.req.class.array)\n+SwitchErrors.java:160:28: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:166:18: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:171:27: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:177:18: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:183:13: compiler.err.pattern.dominated\n+SwitchErrors.java:32:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:38:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:44:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:50:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:98:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:104:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:109:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:114:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:120:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:127:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:187:9: compiler.err.not.exhaustive.statement\n+- compiler.note.preview.filename: SwitchErrors.java, DEFAULT\n+- compiler.note.preview.recompile\n+41 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.out","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,344 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+\/*\n+ * @test\n+ * @bug 8262891\n+ * @summary Check behavior of pattern switches.\n+ * @compile --enable-preview -source ${jdk.version} Switches.java\n+ * @run main\/othervm --enable-preview Switches\n+ *\/\n+public class Switches {\n+\n+    public static void main(String... args) {\n+        new Switches().run();\n+    }\n+\n+    void run() {\n+        run(this::typeTestPatternSwitchTest);\n+        run(this::typeTestPatternSwitchExpressionTest);\n+        run(this::testBooleanSwitchExpression);\n+        assertFalse(testNullSwitch(null));\n+        assertTrue(testNullSwitch(\"\"));\n+        runArrayTypeTest(this::testArrayTypeStatement);\n+        runArrayTypeTest(this::testArrayTypeExpression);\n+        runEnumTest(this::testEnumExpression1);\n+        runEnumTest(this::testEnumExpression2);\n+        runEnumTest(this::testEnumWithGuards1);\n+        runEnumTest(this::testEnumWithGuards2);\n+        runEnumTest(this::testEnumWithGuardsExpression1);\n+        runEnumTest(this::testEnumWithGuardsExpression2);\n+        runEnumTest(this::testStringWithGuards1);\n+        runEnumTest(this::testStringWithGuardsExpression1);\n+        runEnumTest(this::testIntegerWithGuards1);\n+        runEnumTest(this::testIntegerWithGuardsExpression1);\n+        runStringWithConstant(this::testStringWithConstant);\n+        runStringWithConstant(this::testStringWithConstantExpression);\n+        npeTest(this::npeTestStatement);\n+        npeTest(this::npeTestExpression);\n+        exhaustiveStatementSane(\"\");\n+        exhaustiveStatementSane(null);\n+    }\n+\n+    void run(Function<Object, Integer> mapper) {\n+        assertEquals(2, mapper.apply(\"2\"));\n+        assertEquals(3, mapper.apply(\"3\"));\n+        assertEquals(8, mapper.apply(new StringBuilder(\"4\")));\n+        assertEquals(2, mapper.apply(2));\n+        assertEquals(3, mapper.apply(3));\n+        assertEquals(-1, mapper.apply(2.0));\n+        assertEquals(-1, mapper.apply(new Object()));\n+    }\n+\n+    void runArrayTypeTest(Function<Object, String> mapper) {\n+        assertEquals(\"arr0\", mapper.apply(new int[0]));\n+        assertEquals(\"str6\", mapper.apply(\"string\"));\n+        assertEquals(\"i1\", mapper.apply(1));\n+        assertEquals(\"\", mapper.apply(1.0));\n+    }\n+\n+    void runEnumTest(Function<E, String> mapper) {\n+        assertEquals(\"a\", mapper.apply(E.A));\n+        assertEquals(\"b\", mapper.apply(E.B));\n+        assertEquals(\"C\", mapper.apply(E.C));\n+        assertEquals(\"null\", mapper.apply(null));\n+    }\n+\n+    void runStringWithConstant(Function<String, Integer> mapper) {\n+        assertEquals(1, mapper.apply(\"A\"));\n+        assertEquals(2, mapper.apply(\"AA\"));\n+        assertEquals(0, mapper.apply(\"\"));\n+        assertEquals(-1, mapper.apply(null));\n+    }\n+\n+    void npeTest(Consumer<I> testCase) {\n+        try {\n+            testCase.accept(null);\n+            throw new AssertionError(\"Expected a NullPointerException, but got nothing.\");\n+        } catch (NullPointerException ex) {\n+            \/\/OK\n+        }\n+    }\n+\n+    int typeTestPatternSwitchTest(Object o) {\n+        switch (o) {\n+            case String s: return Integer.parseInt(s.toString());\n+            case CharSequence s: return 2 * Integer.parseInt(s.toString());\n+            case Integer i: return i;\n+            case Object x: return -1;\n+        }\n+    }\n+\n+    int typeTestPatternSwitchExpressionTest(Object o) {\n+        return switch (o) {\n+            case String s -> Integer.parseInt(s.toString());\n+            case @Deprecated CharSequence s -> { yield 2 * Integer.parseInt(s.toString()); }\n+            case final Integer i -> i;\n+            case Object x -> -1;\n+        };\n+    }\n+\n+    int testBooleanSwitchExpression(Object o) {\n+        Object x;\n+        if (switch (o) {\n+            default -> false;\n+        }) {\n+            return -3;\n+        } else if (switch (o) {\n+            case String s -> (x = s) != null;\n+            default -> false;\n+        }) {\n+            return Integer.parseInt(x.toString());\n+        } else if (switch (o) {\n+            case CharSequence s -> {\n+                x = s;\n+                yield true;\n+            }\n+            default -> false;\n+        }) {\n+            return 2 * Integer.parseInt(x.toString());\n+        }\n+        return typeTestPatternSwitchTest(o);\n+    }\n+\n+    boolean testNullSwitch(Object o) {\n+        return switch (o) {\n+            case null -> false;\n+            default -> true;\n+        };\n+    }\n+\n+    String testArrayTypeStatement(Object o) {\n+        String res;\n+        switch (o) {\n+            case Integer i -> res = \"i\" + i;\n+            case int[] arr -> res = \"arr\" + arr.length;\n+            case String str -> res = \"str\" + str.length();\n+            default -> res = \"\";\n+        }\n+        return res;\n+    }\n+\n+    String testArrayTypeExpression(Object o) {\n+        return switch (o) {\n+            case Integer i -> \"i\" + i;\n+            case int[] arr -> \"arr\" + arr.length;\n+            case String str -> \"str\" + str.length();\n+            default -> \"\";\n+        };\n+    }\n+\n+    int testStringWithConstant(String str) {\n+        switch (str) {\n+            case \"A\": return 1;\n+            case null: return -1;\n+            case String s:  return s.length();\n+        }\n+    }\n+\n+    int testStringWithConstantExpression(String str) {\n+        return switch (str) {\n+            case \"A\" -> 1;\n+            case null -> -1;\n+            case String s -> s.length();\n+        };\n+    }\n+\n+    String testEnumExpression1(E e) {\n+        return switch (e) {\n+            case A -> \"a\";\n+            case B -> \"b\";\n+            case null, E x -> String.valueOf(x);\n+        };\n+    }\n+\n+    String testEnumExpression2(E e) {\n+        return switch (e) {\n+            case A -> \"a\";\n+            case B -> \"b\";\n+            case E x, null -> String.valueOf(x);\n+        };\n+    }\n+\n+    String testEnumWithGuards1(E e) {\n+        switch (e) {\n+            case A: return \"a\";\n+            case B: return \"b\";\n+            case E x && \"A\".equals(x.name()): return \"broken\";\n+            case C: return String.valueOf(e);\n+            case null, E x: return String.valueOf(x);\n+        }\n+    }\n+\n+    String testEnumWithGuardsExpression1(E e) {\n+        return switch (e) {\n+            case A -> \"a\";\n+            case B -> \"b\";\n+            case E x && \"A\".equals(x.name()) -> \"broken\";\n+            case C -> String.valueOf(e);\n+            case null, E x -> String.valueOf(x);\n+        };\n+    }\n+\n+    String testEnumWithGuards2(E e) {\n+        switch (e) {\n+            case A: return \"a\";\n+            case B: return \"b\";\n+            case E x && \"C\".equals(x.name()): return \"C\";\n+            case C: return \"broken\";\n+            case null, E x: return String.valueOf(x);\n+        }\n+    }\n+\n+    String testEnumWithGuardsExpression2(E e) {\n+        return switch (e) {\n+            case A -> \"a\";\n+            case B -> \"b\";\n+            case E x && \"C\".equals(x.name()) -> \"C\";\n+            case C -> \"broken\";\n+            case null, E x -> String.valueOf(x);\n+        };\n+    }\n+\n+    String testStringWithGuards1(E e) {\n+        switch (e != null ? e.name() : null) {\n+            case \"A\": return \"a\";\n+            case \"B\": return \"b\";\n+            case String x && \"C\".equals(x): return \"C\";\n+            case \"C\": return \"broken\";\n+            case null, String x: return String.valueOf(x);\n+        }\n+    }\n+\n+    String testStringWithGuardsExpression1(E e) {\n+        return switch (e != null ? e.name() : null) {\n+            case \"A\" -> \"a\";\n+            case \"B\" -> \"b\";\n+            case String x && \"C\".equals(x) -> \"C\";\n+            case \"C\" -> \"broken\";\n+            case null, String x -> String.valueOf(x);\n+        };\n+    }\n+\n+    String testIntegerWithGuards1(E e) {\n+        switch (e != null ? e.ordinal() : null) {\n+            case 0: return \"a\";\n+            case 1: return \"b\";\n+            case Integer x && x.equals(2): return \"C\";\n+            case 2: return \"broken\";\n+            case null, Integer x: return String.valueOf(x);\n+        }\n+    }\n+\n+    String testIntegerWithGuardsExpression1(E e) {\n+        return switch (e != null ? e.ordinal() : null) {\n+            case 0 -> \"a\";\n+            case 1 -> \"b\";\n+            case Integer x && x.equals(2) -> \"C\";\n+            case 2 -> \"broken\";\n+            case null, Integer x -> String.valueOf(x);\n+        };\n+    }\n+\n+    void npeTestStatement(I i) {\n+        switch (i) {\n+            case A a -> {}\n+            case B b -> {}\n+        }\n+    }\n+\n+    void npeTestExpression(I i) {\n+        int j = switch (i) {\n+            case A a -> 0;\n+            case B b -> 1;\n+        };\n+    }\n+\n+    void exhaustiveStatementSane(Object o) {\n+        switch (o) {\n+            case Object obj:; \/\/no break intentionally - should not fall through to any possible default\n+        }\n+        switch (o) {\n+            case null, Object obj:; \/\/no break intentionally - should not fall through to any possible default\n+        }\n+        switch (o) {\n+            case Object obj, null:; \/\/no break intentionally - should not fall through to any possible default\n+        }\n+    }\n+\n+    sealed interface I {}\n+    final class A implements I {}\n+    final class B implements I {}\n+\n+    void assertEquals(int expected, int actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n+    void assertEquals(String expected, String actual) {\n+        if (!Objects.equals(expected, actual)) {\n+            throw new AssertionError(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n+    void assertTrue(boolean actual) {\n+        if (!actual) {\n+            throw new AssertionError(\"Expected: true, but got false\");\n+        }\n+    }\n+\n+    void assertFalse(boolean actual) {\n+        if (actual) {\n+            throw new AssertionError(\"Expected: false, but got true\");\n+        }\n+    }\n+\n+    public enum E {\n+        A, B, C;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/Switches.java","additions":344,"deletions":0,"binary":false,"changes":344,"status":"added"},{"patch":"@@ -1,1 +1,1 @@\n-- compiler.err.preview.feature.disabled.classfile: Bar.class, 17\n+- compiler.err.preview.feature.disabled.classfile: Bar.class, 18\n","filename":"test\/langtools\/tools\/javac\/preview\/classReaderTest\/Client.nopreview.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-- compiler.warn.preview.feature.use.classfile: Bar.class, 17\n+- compiler.warn.preview.feature.use.classfile: Bar.class, 18\n","filename":"test\/langtools\/tools\/javac\/preview\/classReaderTest\/Client.preview.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,2 +35,1 @@\n- * @compile --enable-preview -source ${jdk.version} AnnoProcessorOnRecordsTest.java\n- * @run main\/othervm --enable-preview AnnoProcessorOnRecordsTest\n+ * @run main\/othervm AnnoProcessorOnRecordsTest\n@@ -152,4 +151,1 @@\n-                    .options(\"-nowarn\",\n-                            \"-processor\", Processor.class.getName(),\n-                            \"--enable-preview\",\n-                            \"-source\", Integer.toString(Runtime.version().feature()))\n+                    .options(\"-nowarn\", \"-processor\", Processor.class.getName())\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/AnnoProcessorOnRecordsTest.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,2 +35,1 @@\n- * @compile --enable-preview -source ${jdk.version} CheckingTypeAnnotationsOnRecords.java\n- * @run main\/othervm --enable-preview CheckingTypeAnnotationsOnRecords\n+ * @run main\/othervm CheckingTypeAnnotationsOnRecords\n@@ -147,4 +146,1 @@\n-                    .options(\"-nowarn\",\n-                            \"-processor\", Processor.class.getName(),\n-                            \"--enable-preview\",\n-                            \"-source\", Integer.toString(Runtime.version().feature()))\n+                    .options(\"-nowarn\", \"-processor\", Processor.class.getName())\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/CheckingTypeAnnotationsOnRecords.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,2 +36,1 @@\n- * @compile --enable-preview -source ${jdk.version} ErrorOnAnnoWithTargetMethod.java\n- * @run main\/othervm --enable-preview ErrorOnAnnoWithTargetMethod\n+ * @run main\/othervm ErrorOnAnnoWithTargetMethod\n@@ -160,4 +159,1 @@\n-                    .options(\"-nowarn\",\n-                            \"-processor\", Processor.class.getName(),\n-                            \"--enable-preview\",\n-                            \"-source\", Integer.toString(Runtime.version().feature()))\n+                    .options(\"-nowarn\", \"-processor\", Processor.class.getName())\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/ErrorOnAnnoWithTargetMethod.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,4 +27,1 @@\n- * @modules\n- *      jdk.compiler\/com.sun.tools.javac.util\n- * @compile --enable-preview -source ${jdk.version} RecordNotPreservingNestedTypeAnnotationsTest.java\n- * @run main\/othervm --enable-preview RecordNotPreservingNestedTypeAnnotationsTest\n+ * @modules jdk.compiler\/com.sun.tools.javac.util\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/RecordNotPreservingNestedTypeAnnotationsTest.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @compile --enable-preview -source ${jdk.version} -processor TestBindingVariable -proc:only TestBindingVariableData.java\n+ * @compile -processor TestBindingVariable -proc:only TestBindingVariableData.java\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestBindingVariable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,2 +35,1 @@\n- * @compile --enable-preview -source ${jdk.version} TestRecord.java\n- * @run main\/othervm --enable-preview TestRecord\n+ * @run main\/othervm TestRecord\n@@ -146,4 +145,1 @@\n-                    .options(\"-nowarn\",\n-                        \"-processor\", Processor.class.getName(),\n-                        \"--enable-preview\",\n-                        \"-source\", Integer.toString(Runtime.version().feature()))\n+                    .options(\"-nowarn\", \"-processor\", Processor.class.getName())\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestRecord.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n- * @compile --enable-preview -source ${jdk.version} TestRecordDesugar.java\n- * @run main\/othervm --enable-preview TestRecordDesugar\n+ * @run main TestRecordDesugar\n@@ -53,2 +52,0 @@\n-                \"--enable-preview\",\n-                \"-source\", Integer.toString(Runtime.version().feature()),\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestRecordDesugar.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,2 +36,1 @@\n- * @compile --enable-preview -source ${jdk.version} RepeatingAnnotationsOnRecords.java\n- * @run main\/othervm --enable-preview RepeatingAnnotationsOnRecords\n+ * @run main\/othervm RepeatingAnnotationsOnRecords\n@@ -178,4 +177,1 @@\n-                    .options(\"-nowarn\",\n-                            \"-processor\", Processor.class.getName(),\n-                            \"--enable-preview\",\n-                            \"-source\", Integer.toString(Runtime.version().feature()))\n+                    .options(\"-nowarn\", \"-processor\", Processor.class.getName())\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/repeatingAnnotations\/RepeatingAnnotationsOnRecords.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -171,2 +171,0 @@\n-                .options(\"--enable-preview\",\n-                        \"-source\", Integer.toString(Runtime.version().feature()))\n@@ -179,1 +177,0 @@\n-                .vmOptions(\"--enable-preview\")\n@@ -195,2 +192,0 @@\n-                .options(\"--enable-preview\",\n-                        \"-source\", Integer.toString(Runtime.version().feature()))\n@@ -205,1 +200,0 @@\n-                    .vmOptions(\"--enable-preview\")\n@@ -216,1 +210,0 @@\n-                    .vmOptions(\"--enable-preview\")\n@@ -417,2 +410,0 @@\n-                .options(\"--enable-preview\",\n-                        \"-source\", Integer.toString(Runtime.version().feature()))\n@@ -425,1 +416,0 @@\n-                .vmOptions(\"--enable-preview\")\n@@ -440,2 +430,0 @@\n-                .options(\"--enable-preview\",\n-                        \"-source\", Integer.toString(Runtime.version().feature()))\n@@ -449,1 +437,0 @@\n-                .vmOptions(\"--enable-preview\")\n@@ -591,2 +578,0 @@\n-                .options(\"--enable-preview\",\n-                        \"-source\", Integer.toString(Runtime.version().feature()))\n@@ -599,1 +584,0 @@\n-                .vmOptions(\"--enable-preview\")\n@@ -617,2 +601,0 @@\n-                .options(\"--enable-preview\",\n-                        \"-source\", Integer.toString(Runtime.version().feature()))\n@@ -625,1 +607,0 @@\n-                .vmOptions(\"--enable-preview\")\n","filename":"test\/langtools\/tools\/javac\/sealed\/BinaryCompatibilityTests.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -63,2 +63,1 @@\n-        InMemoryFileManager fileManager = compile(List.of(\"--enable-preview\", \"-source\",\n-                Integer.toString(Runtime.version().feature())), testSource);\n+        InMemoryFileManager fileManager = compile(testSource);\n","filename":"test\/langtools\/tools\/javac\/sealed\/CheckSubtypesOfSealedTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -651,1 +651,1 @@\n-            .options(\"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature()), \"-Xprint\")\n+            .options(\"-Xprint\")\n","filename":"test\/langtools\/tools\/javac\/sealed\/SealedCompilationTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,3 +68,1 @@\n-                .options(\"--enable-preview\", \"-source\",  Integer.toString(Runtime.version().feature()))\n-                .run()\n-                .writeAll();\n+                .run();\n","filename":"test\/langtools\/tools\/javac\/sealed\/T8258662\/T8258662.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262891\n+ * @summary Verify StackMapTable is sensible for simple ordinary switches\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.jdeps\/com.sun.tools.javap\n+ * @build toolbox.ToolBox toolbox.JavapTask\n+ * @run compile OrdinarySwitchStackMapTest.java\n+ * @run main OrdinarySwitchStackMapTest\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import toolbox.JavapTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class OrdinarySwitchStackMapTest {\n+\n+    class Test {\n+        void method0(int i) throws Exception {\n+            switch (i) {\n+                case 0: System.err.println(0); break;\n+                case 1: System.err.println(1); break;\n+                default: System.err.println(2); break;\n+            }\n+        }\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        ToolBox tb = new ToolBox();\n+        Path pathToClass = Paths.get(ToolBox.testClasses, \"OrdinarySwitchStackMapTest$Test.class\");\n+        String javapOut = new JavapTask(tb)\n+                .options(\"-v\")\n+                .classes(pathToClass.toString())\n+                .run()\n+                .getOutput(Task.OutputKind.DIRECT);\n+\n+        if (!javapOut.contains(\"StackMapTable: number_of_entries = 4\"))\n+            throw new AssertionError(\"The number of entries of the stack map \"\n+                    + \"table should be equal to 4\");\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/stackmap\/OrdinarySwitchStackMapTest.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8238213\n+ * @summary Method resolution should stop on static error\n+ * @compile\/fail\/ref=ShouldStopOnStaticError.out -XDrawDiagnostics ShouldStopOnStaticError.java\n+ *\/\n+\n+public class ShouldStopOnStaticError {\n+    static void foo() {\n+        test1(5.0);\n+        test2((Double)5.0);\n+    }\n+\n+    void test1(double d) {}\n+    void test1(Double d) {}\n+\n+    void test2(Number n) {}\n+    static void test2(Double... d) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/static_error\/ShouldStopOnStaticError.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+ShouldStopOnStaticError.java:10:9: compiler.err.non-static.cant.be.ref: kindname.method, test1(double)\n+ShouldStopOnStaticError.java:11:9: compiler.err.non-static.cant.be.ref: kindname.method, test2(java.lang.Number)\n+2 errors\n","filename":"test\/langtools\/tools\/javac\/static_error\/ShouldStopOnStaticError.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -1,5 +1,6 @@\n-SwitchNoExtraTypes.java:11:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: boolean, int)\n-SwitchNoExtraTypes.java:17:16: compiler.err.prob.found.req: (compiler.misc.possible.loss.of.precision: long, int)\n-SwitchNoExtraTypes.java:23:16: compiler.err.prob.found.req: (compiler.misc.possible.loss.of.precision: float, int)\n-SwitchNoExtraTypes.java:29:16: compiler.err.prob.found.req: (compiler.misc.possible.loss.of.precision: double, int)\n-4 errors\n+SwitchNoExtraTypes.java:11:16: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\n+SwitchNoExtraTypes.java:12:18: compiler.err.constant.label.not.compatible: boolean, boolean\n+SwitchNoExtraTypes.java:18:18: compiler.err.constant.label.not.compatible: int, long\n+SwitchNoExtraTypes.java:24:18: compiler.err.constant.label.not.compatible: int, float\n+SwitchNoExtraTypes.java:30:18: compiler.err.constant.label.not.compatible: int, double\n+5 errors\n","filename":"test\/langtools\/tools\/javac\/switchextra\/SwitchNoExtraTypes.out","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,2 +1,4 @@\n-SwitchObject.java:10:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object, int)\n-1 error\n+SwitchObject.java:10:16: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\n+SwitchObject.java:11:18: compiler.err.constant.label.not.compatible: int, java.lang.Object\n+SwitchObject.java:12:18: compiler.err.constant.label.not.compatible: java.lang.String, java.lang.Object\n+3 errors\n","filename":"test\/langtools\/tools\/javac\/switchextra\/SwitchObject.out","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262891\n+ * @summary Verify \"case null\" behavior.\n+ * @compile --enable-preview -source ${jdk.version} SwitchNull.java\n+ * @run main\/othervm --enable-preview SwitchNull\n+ *\/\n+\n+public class SwitchNull {\n+    public static void main(String... args) {\n+        SwitchNull instance = new SwitchNull();\n+\n+        instance.run();\n+    }\n+\n+    private void run() {\n+        assertEquals(0, switchIntegerBox(Integer.MIN_VALUE));\n+        assertEquals(1, switchIntegerBox(-2));\n+        assertEquals(2, switchIntegerBox(-1));\n+        assertEquals(3, switchIntegerBox(0));\n+        assertEquals(4, switchIntegerBox(1));\n+        assertEquals(5, switchIntegerBox(2));\n+        assertEquals(6, switchIntegerBox(Integer.MAX_VALUE));\n+        assertEquals(-1, switchIntegerBox(null));\n+        assertEquals(-2, switchIntegerBox(3));\n+        assertEquals(0, switchString(\"\"));\n+        assertEquals(1, switchString(\"a\"));\n+        assertEquals(2, switchString(\"A\"));\n+        assertEquals(-1, switchString(null));\n+        assertEquals(-2, switchString(\"c\"));\n+        assertEquals(0, switchEnum(E.A));\n+        assertEquals(1, switchEnum(E.B));\n+        assertEquals(2, switchEnum(E.C));\n+        assertEquals(-1, switchEnum(null));\n+        assertEquals(0, switchEnumWithDefault(E.A));\n+        assertEquals(1, switchEnumWithDefault(E.B));\n+        assertEquals(1, switchEnumWithDefault(E.C));\n+        assertEquals(-1, switchEnumWithDefault(null));\n+        testSwitchIntegerBoxExhaustive();\n+    }\n+\n+    private int switchIntegerBox(Integer i) {\n+        switch (i) {\n+            case Integer.MIN_VALUE: return 0;\n+            case -2: return 1;\n+            case -1: return 2;\n+            case 0: return 3;\n+            case 1: return 4;\n+            case 2: return 5;\n+            case Integer.MAX_VALUE: return 6;\n+            case null: return -1;\n+            default: return -2;\n+        }\n+    }\n+\n+    private int switchString(String s) {\n+        switch (s) {\n+            case \"\": return 0;\n+            case \"a\": return 1;\n+            case \"A\": return 2;\n+            case null: return -1;\n+            default: return -2;\n+        }\n+    }\n+\n+    private int switchEnum(E e) {\n+        switch (e) {\n+            case A: return 0;\n+            case B: return 1;\n+            case C: return 2;\n+            case null: return -1;\n+        }\n+        throw new AssertionError(String.valueOf(e));\n+    }\n+\n+    private int switchEnumWithDefault(E e) {\n+        switch (e) {\n+            case A: return 0;\n+            default: return 1;\n+            case null: return -1;\n+        }\n+    }\n+\n+    private void testSwitchIntegerBoxExhaustive() {\n+        int i = Integer.MIN_VALUE;\n+\n+        do {\n+            int result = switchIntegerBoxExhaustive(i);\n+            int expected = i == 0 ? 0 : 1;\n+            assertEquals(expected, result);\n+        } while (i++ < Integer.MAX_VALUE);\n+\n+        int result = switchIntegerBoxExhaustive(null);\n+        assertEquals(-1, result);\n+    }\n+\n+    private int switchIntegerBoxExhaustive(Integer i) {\n+        return switch (i) {\n+            case null -> -1;\n+            case 0 -> 0;\n+            default -> 1;\n+        };\n+    }\n+\n+    enum E {\n+        A,\n+        B,\n+        C;\n+    }\n+\n+    private void assertEquals(int expected, int actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", actual: \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/switchnull\/SwitchNull.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+SwitchNullDisabled.java:13:18: compiler.err.preview.feature.disabled: (compiler.misc.feature.case.null)\n+1 error\n","filename":"test\/langtools\/tools\/javac\/switchnull\/SwitchNullDisabled-preview.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -4,2 +4,4 @@\n- * @summary Verify \"case null\" is not allowed.\n- * @compile\/fail\/ref=SwitchNullDisabled.out -XDrawDiagnostics SwitchNullDisabled.java\n+ * @summary Verify \"case null\" is not allowed for -source 16\n+ * @compile\/fail\/ref=SwitchNullDisabled.out -XDrawDiagnostics -source 16 -Xlint:-options SwitchNullDisabled.java\n+ * @compile\/fail\/ref=SwitchNullDisabled-preview.out -XDrawDiagnostics SwitchNullDisabled.java\n+ * @compile --enable-preview -source ${jdk.version} SwitchNullDisabled.java\n","filename":"test\/langtools\/tools\/javac\/switchnull\/SwitchNullDisabled.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-SwitchNullDisabled.java:11:18: compiler.err.switch.null.not.allowed\n+SwitchNullDisabled.java:13:18: compiler.err.preview.feature.disabled: (compiler.misc.feature.case.null)\n","filename":"test\/langtools\/tools\/javac\/switchnull\/SwitchNullDisabled.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,0 +98,2 @@\n+            if (!tree.sourcefile.toString().contains(\"EmptyBreak.java\"))\n+                return 0;\n@@ -146,19 +148,23 @@\n-                expect.add(tree);\n-                for (Field f: getFields(tree)) {\n-                    if (TypeBoundKind.class.isAssignableFrom(f.getType())) {\n-                        \/\/ not part of public API\n-                        continue;\n-                    }\n-                    try {\n-                        \/\/System.err.println(\"FIELD: \" + f.getName());\n-                        if (tree instanceof JCModuleDecl && f.getName().equals(\"mods\")) {\n-                            \/\/ The modifiers will not found by TreeScanner,\n-                            \/\/ but the embedded annotations will be.\n-                            reflectiveScan(((JCModuleDecl) tree).mods.annotations);\n-                        } else if (tree instanceof JCCase &&\n-                                   ((JCCase) tree).getCaseKind() == CaseKind.RULE &&\n-                                   f.getName().equals(\"stats\")) {\n-                            \/\/value case, visit value:\n-                            reflectiveScan(((JCCase) tree).getBody());\n-                        } else {\n-                            reflectiveScan(f.get(tree));\n+                if (!tree.hasTag(JCTree.Tag.DEFAULTCASELABEL)) {\n+                    expect.add(tree);\n+                    for (Field f: getFields(tree)) {\n+                        if (TypeBoundKind.class.isAssignableFrom(f.getType())) {\n+                            \/\/ not part of public API\n+                            continue;\n+                        }\n+                        try {\n+                            \/\/System.err.println(\"FIELD: \" + f.getName());\n+                            if (tree instanceof JCModuleDecl && f.getName().equals(\"mods\")) {\n+                                \/\/ The modifiers will not found by TreeScanner,\n+                                \/\/ but the embedded annotations will be.\n+                                reflectiveScan(((JCModuleDecl) tree).mods.annotations);\n+                            } else if (tree instanceof JCCase &&\n+                                       ((JCCase) tree).getCaseKind() == CaseKind.RULE &&\n+                                       f.getName().equals(\"stats\")) {\n+                                \/\/value case, visit value:\n+                                reflectiveScan(((JCCase) tree).getBody());\n+                            } else {\n+                                reflectiveScan(f.get(tree));\n+                            }\n+                        } catch (IllegalAccessException e) {\n+                            error(e.toString());\n@@ -166,2 +172,0 @@\n-                    } catch (IllegalAccessException e) {\n-                        error(e.toString());\n","filename":"test\/langtools\/tools\/javac\/tree\/SourceTreeScannerTest.java","additions":25,"deletions":21,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,2 @@\n-        Set.of(\"1.7\", \"1.8\", \"1.9\", \"1.10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\");\n+        Set.of(\"1.7\", \"1.8\", \"1.9\", \"1.10\", \"11\", \"12\", \"13\", \"14\",\n+               \"15\", \"16\", \"17\", \"18\");\n@@ -75,1 +76,1 @@\n-    public static final String LATEST_MAJOR_VERSION = \"61.0\";\n+    public static final String LATEST_MAJOR_VERSION = \"62.0\";\n@@ -88,1 +89,2 @@\n-        SEVENTEEN(false,  \"61.0\", \"17\", Versions::checksrc17);\n+        SEVENTEEN(false, \"61.0\", \"17\", Versions::checksrc17),\n+        EIGHTEEN(false,  \"62.0\", \"18\", Versions::checksrc18);\n@@ -304,1 +306,1 @@\n-       \/\/ Add expectedFail after new language features added in a later release.\n+        expectedFail(args, List.of(\"New17.java\"));\n@@ -310,1 +312,8 @@\n-                                  \"New14.java\", \"New15.java\", \"New16.java\"));\n+                                  \"New14.java\", \"New15.java\", \"New16.java\", \"New17.java\"));\n+       \/\/ Add expectedFail after new language features added in a later release.\n+    }\n+\n+   protected void checksrc18(List<String> args) {\n+       printargs(\"checksrc18\", args);\n+       expectedPass(args, List.of(\"New7.java\", \"New8.java\", \"New10.java\", \"New11.java\",\n+                                  \"New14.java\", \"New15.java\", \"New16.java\", \"New17.java\"));\n@@ -538,0 +547,15 @@\n+\n+        \/*\n+         * Create a file with a new feature in 17, not in 16 : sealed classes\n+         *\/\n+        writeSourceFile(\"New17.java\",\n+            \"\"\"\n+            public class New17 {\n+                public static sealed class Seal {}\n+\n+                public static final class Pinniped extends Seal {}\n+                public static final class TaperedThread extends Seal {}\n+                public static final class Wax extends Seal {}\n+            }\n+            \"\"\"\n+        );\n","filename":"test\/langtools\/tools\/javac\/versions\/Versions.java","additions":30,"deletions":6,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -27,2 +27,1 @@\n- * @compile -Xlint:missing-explicit-ctor -Werror\n- *          --enable-preview -source ${jdk.version} NoWarningRecord.java\n+ * @compile -Xlint:missing-explicit-ctor -Werror NoWarningRecord.java\n","filename":"test\/langtools\/tools\/javac\/warnings\/DefaultCtor\/NoWarningRecord.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+                                \"java.base\/jdk.internal.javac\",\n","filename":"test\/langtools\/tools\/jdeps\/listdeps\/ListModuleDeps.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -153,0 +153,1 @@\n+    public static final String SystemGC = PREFIX + \"SystemGC\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -347,9 +347,0 @@\n-################################################################################\n-# DirToDotDot\n-\n-$(call AssertEquals, \\\n-    $(call DirToDotDot, foo\/bar\/baz\/), \\\n-    ..\/..\/.., \\\n-    DirToDotDot, \\\n-)\n-\n@@ -357,3 +348,3 @@\n-    $(call DirToDotDot, foo\/bar), \\\n-    ..\/.., \\\n-    DirToDotDot, \\\n+    $(call FindCommonPathPrefix, \/foo\/bar\/, \/foo\/bar), \\\n+    \/foo\/bar, \\\n+    FindCommonPathPrefix, \\\n@@ -363,3 +354,3 @@\n-    $(call DirToDotDot, \/foo), \\\n-    .., \\\n-    DirToDotDot, \\\n+    $(call FindCommonPathPrefix, \/fo oo\/bar1\/, \/fo oo\/bar2), \\\n+    \/fo oo, \\\n+    FindCommonPathPrefix, \\\n@@ -391,1 +382,1 @@\n-    .\/banan\/kung, \\\n+    banan\/kung, \\\n@@ -397,1 +388,31 @@\n-    .\/banan\/kung, \\\n+    banan\/kung, \\\n+    RelativePath, \\\n+)\n+\n+$(call AssertEquals, \\\n+    $(call RelativePath, \/foo\/bar, \/foo\/bar\/baz), \\\n+    .., \\\n+    RelativePath, \\\n+)\n+\n+$(call AssertEquals, \\\n+    $(call RelativePath, \/foo\/bar\/baz\/, \/foo\/bar\/baz), \\\n+    ., \\\n+    RelativePath, \\\n+)\n+\n+$(call AssertEquals, \\\n+    $(call RelativePath, \/fo oo\/bar\/baz\/ban an, \/fo oo\/bar\/), \\\n+    baz\/ban an, \\\n+    RelativePath, \\\n+)\n+\n+$(call AssertEquals, \\\n+    $(call RelativePath, \/foo\/ba rr\/ba zz, \/foo\/ba rr\/banan), \\\n+    ..\/ba zz, \\\n+    RelativePath, \\\n+)\n+\n+$(call AssertEquals, \\\n+    $(call RelativePath, \/foo, \/bar), \\\n+    ..\/foo, \\\n","filename":"test\/make\/TestMakeBase.gmk","additions":38,"deletions":17,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+public class ArraysMismatchPartialInlining {\n+\n+    @Param({\"3\", \"4\", \"5\", \"6\", \"7\", \"15\", \"31\", \"63\", \"95\", \"800\"})\n+    private static int size;\n+\n+    byte [] barray1;\n+    char [] carray1;\n+    short [] sarray1;\n+    int [] iarray1;\n+    long [] larray1;\n+    float [] farray1;\n+    double [] darray1;\n+\n+    byte [] barray2;\n+    char [] carray2;\n+    short [] sarray2;\n+    int [] iarray2;\n+    long [] larray2;\n+    float [] farray2;\n+    double [] darray2;\n+\n+    @Setup\n+    public void setup() {\n+      barray1 = new byte[size];\n+      carray1 = new char[size];\n+      sarray1 = new short[size];\n+      iarray1 = new int[size];\n+      larray1 = new long[size];\n+      farray1 = new float[size];\n+      darray1 = new double[size];\n+\n+      barray2 = new byte[size];\n+      carray2 = new char[size];\n+      sarray2 = new short[size];\n+      iarray2 = new int[size];\n+      larray2 = new long[size];\n+      farray2 = new float[size];\n+      darray2 = new double[size];\n+\n+      Arrays.fill(barray1 , (byte)0xF);\n+      Arrays.fill(carray1 , (char)0xFF);\n+      Arrays.fill(sarray1 , (short)0xFF);\n+      Arrays.fill(iarray1 , -1);\n+      Arrays.fill(larray1 , -1L);\n+      Arrays.fill(farray1 , -1.0f);\n+      Arrays.fill(darray1, -1.0);\n+\n+      Arrays.fill(barray2 , (byte)0xF);\n+      Arrays.fill(carray2 , (char)0xFF);\n+      Arrays.fill(sarray2 , (short)0xFF);\n+      Arrays.fill(iarray2 , -1);\n+      Arrays.fill(larray2 , -1L);\n+      Arrays.fill(farray2 , -1.0F);\n+      Arrays.fill(darray2, -1.0);\n+\n+      barray2[size-1] = (byte)1;\n+      carray2[size-1] = (char)1;\n+      sarray2[size-1] = (short)1;\n+      iarray2[size-1] = 1;\n+      larray2[size-1] = 1L;\n+      farray2[size-1] = 1.0f;\n+      darray2[size-1] = 1.0;\n+    }\n+\n+    @Benchmark\n+    public int testByteMatch() {\n+      return Arrays.mismatch(barray1, barray2);\n+    }\n+\n+    @Benchmark\n+    public int testCharMatch() {\n+      return Arrays.mismatch(carray1, carray2);\n+    }\n+\n+    @Benchmark\n+    public int testShortMatch() {\n+      return Arrays.mismatch(sarray1, sarray2);\n+    }\n+\n+    @Benchmark\n+    public int testIntMatch() {\n+      return Arrays.mismatch(iarray1, iarray2);\n+    }\n+\n+    @Benchmark\n+    public int testLongMatch() {\n+      return Arrays.mismatch(larray1, larray2);\n+    }\n+\n+    @Benchmark\n+    public int testFloatMatch() {\n+      return Arrays.mismatch(farray1, farray2);\n+    }\n+\n+    @Benchmark\n+    public int testDoubleMatch() {\n+      return Arrays.mismatch(darray1, darray2);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/ArraysMismatchPartialInlining.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Test for x % 2^n (n is constant)\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class ModPowerOf2 {\n+    @Benchmark\n+    public int testPositivePowerOf2() {\n+        int sum = 0;\n+        for (int i = 0; i < 1000; i++) {\n+            sum += i % 1;\n+            sum += i % 2;\n+            sum += i % 4;\n+            sum += i % 8;\n+            sum += i % 16;\n+            sum += i % 32;\n+            sum += i % 64;\n+            sum += i % 128;\n+            sum += i % 256;\n+            sum += i % 512;\n+            sum += i % 1024;\n+            sum += i % 2048;\n+            sum += i % 4096;\n+            sum += i % 8192;\n+            sum += i % 16384;\n+            sum += i % 32768;\n+            sum += i % 65536;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int testNegativePowerOf2() {\n+        int sum = 0;\n+        for (int i = 0; i < 1000; i++) {\n+            sum += i % -1;\n+            sum += i % -2;\n+            sum += i % -4;\n+            sum += i % -8;\n+            sum += i % -16;\n+            sum += i % -32;\n+            sum += i % -64;\n+            sum += i % -128;\n+            sum += i % -256;\n+            sum += i % -512;\n+            sum += i % -1024;\n+            sum += i % -2048;\n+            sum += i % -4096;\n+            sum += i % -8192;\n+            sum += i % -16384;\n+            sum += i % -32768;\n+            sum += i % -65536;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int testMixedPowerOf2() {\n+        int sum = 0;\n+        for (int i = 0; i < 1000; i++) {\n+            sum += i % -1;\n+            sum += i % 1;\n+            sum += i % -2;\n+            sum += i % 2;\n+            sum += i % -4;\n+            sum += i % 4;\n+            sum += i % -8;\n+            sum += i % 8;\n+            sum += i % -16;\n+            sum += i % 16;\n+            sum += i % -32;\n+            sum += i % 32;\n+            sum += i % -64;\n+            sum += i % 64;\n+            sum += i % -128;\n+            sum += i % 128;\n+            sum += i % -256;\n+            sum += i % 256;\n+            sum += i % -512;\n+            sum += i % 512;\n+            sum += i % -1024;\n+            sum += i % 1024;\n+            sum += i % -2048;\n+            sum += i % 2048;\n+            sum += i % -4096;\n+            sum += i % 4096;\n+            sum += i % -8192;\n+            sum += i % 8192;\n+            sum += i % -16384;\n+            sum += i % 16384;\n+            sum += i % -32768;\n+            sum += i % 32768;\n+            sum += i % -65536;\n+            sum += i % 65536;\n+        }\n+        return sum;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/ModPowerOf2.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"}]}