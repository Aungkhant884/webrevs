{"files":[{"patch":"@@ -773,0 +773,2 @@\n+  # test.boot.jdk is used by some test cases that want to execute a previous\n+  # version of the JDK.\n@@ -777,0 +779,1 @@\n+      -vmoption:-Dtest.boot.jdk=\"$$(BOOT_JDK)\" \\\n","filename":"make\/RunTests.gmk","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-JTREG_MINIMUM_VERSION=7\n+JTREG_MINIMUM_VERSION=7.1\n","filename":"make\/autoconf\/lib-tests.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -222,2 +222,0 @@\n-      $1_JAVAC := $$(INTERIM_LANGTOOLS_ARGS) -cp $(BUILDTOOLS_OUTPUTDIR)\/langtools_javacserver_classes javacserver.Main\n-\n@@ -226,1 +224,6 @@\n-      $1_JAVAC_SERVER_CONFIG := $$($1_BIN)$$($1_MODULE_SUBDIR)\/_the.$$($1_SAFE_NAME)-server.conf\n+      $1_JAVAC_SERVER_CONFIG := $$($1_BIN)$$($1_MODULE_SUBDIR)\/_the.$$($1_SAFE_NAME)-javacserver.conf\n+\n+      # Arguments needed to launch the javacserver client, as well as for the\n+      # client to launch the server.\n+      $1_JAVAC_SERVER_ARGS := $$(INTERIM_LANGTOOLS_ARGS) \\\n+          -cp $(BUILDTOOLS_OUTPUTDIR)\/langtools_javacserver_classes\n@@ -232,3 +235,3 @@\n-      # The servercmd specifies how to launch the server. This will be executed\n-      # by the client, if needed.\n-      $1_JAVAC_SERVER_CMD := $$(call FixPath, $$(JAVA) $$($1_JAVA_FLAGS) $$($1_JAVAC))\n+      # The javacmd tells the client how to run java to launch the server.\n+      $1_JAVAC_SERVER_JAVA_CMD := $$(call FixPath, $$(JAVA) $$($1_JAVA_FLAGS) \\\n+          $$($1_JAVAC_SERVER_ARGS))\n@@ -236,1 +239,1 @@\n-      $1_CONFIG_VARDEPS := $$($1_JAVAC_PORT_FILE) $$($1_JAVAC_SERVER_CMD)\n+      $1_CONFIG_VARDEPS := $$($1_JAVAC_PORT_FILE) $$($1_JAVAC_SERVER_JAVA_CMD)\n@@ -240,0 +243,1 @@\n+      # Write these values to a config file\n@@ -242,1 +246,1 @@\n-\t$(ECHO) servercmd=$$($1_JAVAC_SERVER_CMD) >> $$@\n+\t$(ECHO) javacmd=$$($1_JAVAC_SERVER_JAVA_CMD) >> $$@\n@@ -245,2 +249,2 @@\n-      $1_JAVAC_CMD := $$(JAVA_SMALL) $$($1_JAVA_FLAGS) $$($1_JAVAC) \\\n-          --server:conf=$$($1_JAVAC_SERVER_CONFIG)\n+      $1_JAVAC_CMD := $$(JAVA_SMALL) $$($1_JAVA_FLAGS) $$($1_JAVAC_SERVER_ARGS) \\\n+          javacserver.Main --conf=$$($1_JAVAC_SERVER_CONFIG)\n","filename":"make\/common\/JavaCompilation.gmk","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-JTREG_VERSION=7+1\n+JTREG_VERSION=7.1+1\n","filename":"make\/conf\/github-actions.conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1138,1 +1138,1 @@\n-            version: \"7\",\n+            version: \"7.1\",\n@@ -1140,1 +1140,1 @@\n-            file: \"bundles\/jtreg-7+1.zip\",\n+            file: \"bundles\/jtreg-7.1+1.zip\",\n","filename":"make\/conf\/jib-profiles.js","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,144 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver;\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.io.Writer;\n-import java.util.Locale;\n-\n-\/**\n- * Utility class only for sjavac logging.\n- *\n- * Logging in sjavac has special requirements when running in server\/client\n- * mode. Most of the log messages is generated server-side, but the server\n- * is typically spawned by the client in the background, so the user usually\n- * does not see the server stdout\/stderr. For this reason log messages needs\n- * to relayed back to the client that performed the request that generated the\n- * log message. To support this use case this class maintains a per-thread log\n- * instance so that each connected client can have its own instance that\n- * relays messages back to the requesting client.\n- *\n- * On the client-side (or when running sjavac without server-mode) there will\n- * typically just be one Log instance.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Log {\n-\n-    public enum Level {\n-        ERROR,\n-        WARN,\n-        INFO,\n-        DEBUG,\n-        TRACE;\n-    }\n-\n-    private static Log stdOutErr = new Log(new PrintWriter(System.out), new PrintWriter(System.err));\n-    private static ThreadLocal<Log> loggers = new ThreadLocal<>();\n-\n-    protected PrintWriter err; \/\/ Used for error and warning messages\n-    protected PrintWriter out; \/\/ Used for other messages\n-    protected Level level = Level.INFO;\n-\n-    public Log(Writer out, Writer err) {\n-        this.out = out == null ? null : new PrintWriter(out, true);\n-        this.err = err == null ? null : new PrintWriter(err, true);\n-    }\n-\n-    public static void setLogForCurrentThread(Log log) {\n-        loggers.set(log);\n-    }\n-\n-    public static void setLogLevel(String l) {\n-        setLogLevel(Level.valueOf(l.toUpperCase(Locale.US)));\n-    }\n-\n-    public static void setLogLevel(Level l) {\n-        get().level = l;\n-    }\n-\n-    public static void trace(String msg) {\n-        log(Level.TRACE, msg);\n-    }\n-\n-    public static void debug(String msg) {\n-        log(Level.DEBUG, msg);\n-    }\n-\n-    public static void info(String msg) {\n-        log(Level.INFO, msg);\n-    }\n-\n-    public static void warn(String msg) {\n-        log(Level.WARN, msg);\n-    }\n-\n-    public static void error(String msg) {\n-        log(Level.ERROR, msg);\n-    }\n-\n-    public static void error(Throwable t) {\n-        log(Level.ERROR, t);\n-    }\n-\n-    public static void log(Level l, String msg) {\n-        get().printLogMsg(l, msg);\n-    }\n-\n-    public static void debug(Throwable t) {\n-        log(Level.DEBUG, t);\n-    }\n-\n-    public static void log(Level l, Throwable t) {\n-        StringWriter sw = new StringWriter();\n-        t.printStackTrace(new PrintWriter(sw, true));\n-        log(l, sw.toString());\n-    }\n-\n-    public static boolean isDebugging() {\n-        return get().isLevelLogged(Level.DEBUG);\n-    }\n-\n-    protected boolean isLevelLogged(Level l) {\n-        return l.ordinal() <= level.ordinal();\n-    }\n-\n-    public static Log get() {\n-        Log log = loggers.get();\n-        return log != null ? log : stdOutErr;\n-    }\n-\n-    protected void printLogMsg(Level msgLevel, String msg) {\n-        if (isLevelLogged(msgLevel)) {\n-            PrintWriter pw = msgLevel.ordinal() <= Level.WARN.ordinal() ? err : out;\n-            pw.println(msg);\n-        }\n-    }\n-}\n","filename":"make\/langtools\/tools\/javacserver\/Log.java","additions":0,"deletions":144,"binary":false,"changes":144,"status":"deleted"},{"patch":"@@ -28,6 +28,1 @@\n-import java.util.Arrays;\n-\n-import javacserver.client.ClientMain;\n-import javacserver.server.ServerMain;\n-\n-import static javacserver.options.Option.STARTSERVER;\n+import javacserver.client.Client;\n@@ -36,6 +31,1 @@\n- * The application entry point of the smart javac wrapper tool.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n+ * The application entry point of the javacserver build tool.\n@@ -44,13 +34,2 @@\n-\n-    public static void main(String... args)  {\n-        System.exit(go(args));\n-    }\n-\n-    public static int go(String[] args) {\n-\n-        \/\/ Server or client mode?\n-        boolean serverMode = Arrays.asList(args)\n-                                   .stream()\n-                                   .anyMatch(arg -> arg.startsWith(STARTSERVER.arg));\n-\n-        return serverMode ? ServerMain.run(args) : ClientMain.run(args);\n+    public static void main(String... args) {\n+        Client.main(args);\n","filename":"make\/langtools\/tools\/javacserver\/Main.java","additions":4,"deletions":25,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver;\n-\n-\/** Result codes.\n- *\/\n-public enum Result {\n-    OK(0),        \/\/ Compilation completed with no errors.\n-    ERROR(1),     \/\/ Completed but reported errors.\n-    CMDERR(2),    \/\/ Bad command-line arguments\n-    SYSERR(3),    \/\/ System error or resource exhaustion.\n-    ABNORMAL(4);  \/\/ Compiler terminated abnormally\n-\n-    Result(int exitCode) {\n-        this.exitCode = exitCode;\n-    }\n-\n-    public static Result of(int exitcode) {\n-        for (Result result : values()) {\n-            if (result.exitCode == exitcode) {\n-                return result;\n-            }\n-        }\n-\n-        return ABNORMAL;\n-    }\n-\n-    public boolean isOK() {\n-        return (exitCode == 0);\n-    }\n-\n-    public final int exitCode;\n-}\n","filename":"make\/langtools\/tools\/javacserver\/Result.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,148 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver;\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Set;\n-import java.util.regex.Pattern;\n-import java.util.stream.Stream;\n-\n-\/**\n- * Utilities.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Util {\n-\n-\n-\n-    public static String extractStringOption(String opName, String s) {\n-        return extractStringOption(opName, s, null);\n-    }\n-\n-    private static String extractStringOptionWithDelimiter(String opName, String s, String deflt, char delimiter) {\n-        int p = s.indexOf(opName+\"=\");\n-        if (p == -1) return deflt;\n-        p+=opName.length()+1;\n-        int pe = s.indexOf(delimiter, p);\n-        if (pe == -1) pe = s.length();\n-        return s.substring(p, pe);\n-    }\n-\n-    public static String extractStringOption(String opName, String s, String deflt) {\n-        return extractStringOptionWithDelimiter(opName, s, deflt, ',');\n-    }\n-\n-    public static String extractStringOptionLine(String opName, String s, String deflt) {\n-        return extractStringOptionWithDelimiter(opName, s, deflt, '\\n').strip();\n-    }\n-\n-    public static int extractIntOption(String opName, String s, int deflt) {\n-        int p = s.indexOf(opName+\"=\");\n-        if (p == -1) return deflt;\n-        p+=opName.length()+1;\n-        int pe = s.indexOf(',', p);\n-        if (pe == -1) pe = s.length();\n-        int v = 0;\n-        try {\n-            v = Integer.parseInt(s.substring(p, pe));\n-        } catch (Exception e) {}\n-        return v;\n-    }\n-\n-\n-    \/**\n-     * Convenience method to create a set with strings.\n-     *\/\n-    public static Set<String> set(String... ss) {\n-        Set<String> set = new HashSet<>();\n-        set.addAll(Arrays.asList(ss));\n-        return set;\n-    }\n-\n-    \/**\n-     * Normalize windows drive letter paths to upper case to enable string\n-     * comparison.\n-     *\n-     * @param file File name to normalize\n-     * @return The normalized string if file has a drive letter at the beginning,\n-     *         otherwise the original string.\n-     *\/\n-    public static String normalizeDriveLetter(String file) {\n-        if (file.length() > 2 && file.charAt(1) == ':') {\n-            return Character.toUpperCase(file.charAt(0)) + file.substring(1);\n-        } else if (file.length() > 3 && file.charAt(0) == '*'\n-                   && file.charAt(2) == ':') {\n-            \/\/ Handle a wildcard * at the beginning of the string.\n-            return file.substring(0, 1) + Character.toUpperCase(file.charAt(1))\n-                   + file.substring(2);\n-        }\n-        return file;\n-    }\n-\n-\n-    public static <E> Set<E> union(Set<? extends E> s1,\n-                                   Set<? extends E> s2) {\n-        Set<E> union = new HashSet<>();\n-        union.addAll(s1);\n-        union.addAll(s2);\n-        return union;\n-    }\n-\n-    public static <E> Set<E> subtract(Set<? extends E> orig,\n-                                      Set<? extends E> toSubtract) {\n-        Set<E> difference = new HashSet<>(orig);\n-        difference.removeAll(toSubtract);\n-        return difference;\n-    }\n-\n-    public static String getStackTrace(Throwable t) {\n-        StringWriter sw = new StringWriter();\n-        t.printStackTrace(new PrintWriter(sw));\n-        return sw.toString();\n-    }\n-\n-    public static <E> Set<E> intersection(Collection<? extends E> c1,\n-                                          Collection<? extends E> c2) {\n-        Set<E> intersection = new HashSet<E>(c1);\n-        intersection.retainAll(c2);\n-        return intersection;\n-    }\n-\n-\n-    public static Stream<String> getLines(String str) {\n-        return str.isEmpty()\n-                ? Stream.empty()\n-                : Stream.of(str.split(Pattern.quote(System.lineSeparator())));\n-    }\n-}\n","filename":"make\/langtools\/tools\/javacserver\/Util.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"deleted"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.client;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.io.Reader;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import javacserver.server.Server;\n+import javacserver.shared.PortFileInaccessibleException;\n+import javacserver.shared.Protocol;\n+import javacserver.shared.Result;\n+import javacserver.util.AutoFlushWriter;\n+import javacserver.util.Log;\n+\n+\/**\n+ * The javacserver client. This is called from the makefiles, and is responsible for passing the command\n+ * line on to a server instance running javac, starting a new server if needed.\n+ *\/\n+public class Client {\n+    private static final Log.Level LOG_LEVEL = Log.Level.INFO;\n+\n+    \/\/ Wait 2 seconds for response, before giving up on javac server.\n+    private static final int CONNECTION_TIMEOUT = 2000;\n+    private static final int MAX_CONNECT_ATTEMPTS = 3;\n+    private static final int WAIT_BETWEEN_CONNECT_ATTEMPTS = 2000;\n+\n+    private final ClientConfiguration conf;\n+\n+    public Client(ClientConfiguration conf) {\n+        this.conf = conf;\n+    }\n+\n+    public static void main(String... args) {\n+        Log.setLogForCurrentThread(new Log(\n+                new AutoFlushWriter(new OutputStreamWriter(System.out)),\n+                new AutoFlushWriter(new OutputStreamWriter(System.err))));\n+        Log.setLogLevel(LOG_LEVEL);\n+\n+        ClientConfiguration conf = ClientConfiguration.fromCommandLineArguments(args);\n+        if (conf == null) {\n+            System.exit(Result.CMDERR.exitCode);\n+        }\n+\n+        Client client = new Client(conf);\n+        int exitCode = client.dispatchToServer();\n+\n+        System.exit(exitCode);\n+    }\n+\n+    private int dispatchToServer() {\n+        try {\n+            \/\/ Check if server seems to be already running\n+            if (!conf.portFile().hasValidValues()) {\n+                \/\/ Fork a new server and wait for it to start\n+                startNewServer();\n+            }\n+\n+            try (Socket socket = tryConnect()) {\n+                BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                PrintWriter out = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()));\n+\n+                Protocol.sendCommand(out, conf.javacArgs());\n+                int exitCode = Protocol.readResponse(in);\n+\n+                return exitCode;\n+            }\n+        } catch (PortFileInaccessibleException e) {\n+            Log.error(\"Port file inaccessible.\");\n+            return Result.ERROR.exitCode;\n+        } catch (IOException ioe) {\n+            Log.error(\"IOException caught during compilation: \" + ioe.getMessage());\n+            Log.debug(ioe);\n+            return Result.ERROR.exitCode;\n+        } catch (InterruptedException ie) {\n+            Thread.currentThread().interrupt(); \/\/ Restore interrupt\n+            Log.error(\"Compilation interrupted.\");\n+            Log.debug(ie);\n+            return Result.ERROR.exitCode;\n+        }\n+    }\n+\n+    \/*\n+     * Makes MAX_CONNECT_ATTEMPTS attempts to connect to server.\n+     *\/\n+    private Socket tryConnect() throws IOException, InterruptedException {\n+        int attempt = 0;\n+\n+        while (true) {\n+            Log.debug(\"Trying to connect. Attempt \" + (++attempt) + \" of \" + MAX_CONNECT_ATTEMPTS);\n+            try {\n+                Socket socket = new Socket();\n+                InetAddress localhost = InetAddress.getByName(null);\n+                InetSocketAddress address = new InetSocketAddress(localhost, conf.portFile().getPort());\n+                socket.connect(address, CONNECTION_TIMEOUT);\n+                Log.debug(\"Connected\");\n+                return socket;\n+            } catch (IOException ex) {\n+                Log.error(\"Connection attempt failed: \" + ex.getMessage());\n+                if (attempt >= MAX_CONNECT_ATTEMPTS) {\n+                    Log.error(\"Giving up\");\n+                    throw new IOException(\"Could not connect to server\", ex);\n+                }\n+            }\n+            Thread.sleep(WAIT_BETWEEN_CONNECT_ATTEMPTS);\n+        }\n+    }\n+\n+    \/*\n+     * Fork a server process and wait for server to come around\n+     *\/\n+    private void startNewServer() throws IOException, InterruptedException {\n+        List<String> cmd = new ArrayList<>();\n+        \/\/ conf.javaCommand() is how to start java in the way we want to run\n+        \/\/ the server\n+        cmd.addAll(Arrays.asList(conf.javaCommand().split(\" \")));\n+        \/\/ javacserver.server.Server is the server main class\n+        cmd.add(Server.class.getName());\n+        \/\/ and it expects a port file path\n+        cmd.add(conf.portFile().getFilename());\n+\n+        Process serverProcess;\n+        Log.debug(\"Starting server. Command: \" + String.join(\" \", cmd));\n+        try {\n+            \/\/ If the cmd for some reason can't be executed (file is not found,\n+            \/\/ or is not executable for instance) this will throw an\n+            \/\/ IOException\n+            serverProcess = new ProcessBuilder(cmd).redirectErrorStream(true).start();\n+        } catch (IOException ex) {\n+            \/\/ Message is typically something like:\n+            \/\/ Cannot run program \"xyz\": error=2, No such file or directory\n+            Log.error(\"Failed to create server process: \" + ex.getMessage());\n+            Log.debug(ex);\n+            throw new IOException(ex);\n+        }\n+\n+        \/\/ serverProcess != null at this point.\n+        try {\n+            \/\/ Throws an IOException if no valid values materialize\n+            conf.portFile().waitForValidValues();\n+        } catch (IOException ex) {\n+            \/\/ Process was started, but server failed to initialize. This could\n+            \/\/ for instance be due to the JVM not finding the server class,\n+            \/\/ or the server running in to some exception early on.\n+            Log.error(\"javacserver server process failed to initialize: \" + ex.getMessage());\n+            Log.error(\"Process output:\");\n+            Reader serverStdoutStderr = new InputStreamReader(serverProcess.getInputStream());\n+            try (BufferedReader br = new BufferedReader(serverStdoutStderr)) {\n+                br.lines().forEach(Log::error);\n+            }\n+            Log.error(\"<End of process output>\");\n+            try {\n+                Log.error(\"Process exit code: \" + serverProcess.exitValue());\n+            } catch (IllegalThreadStateException e) {\n+                \/\/ Server is presumably still running.\n+            }\n+            throw new IOException(\"Server failed to initialize: \" + ex.getMessage(), ex);\n+        }\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/client\/Client.java","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.client;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import javacserver.shared.PortFile;\n+import javacserver.util.Log;\n+\n+\/**\n+ * Description of the arguments needed to start a javacserver client, as extracted from\n+ * the command line and configuration file.\n+ *\/\n+public record ClientConfiguration(PortFile portFile, String javaCommand, String[] javacArgs) {\n+    static ClientConfiguration fromCommandLineArguments(String... args) {\n+        String confFileName = getConfFileName(args);\n+        if (confFileName == null) {\n+            return null;\n+        }\n+\n+        String confFileContent = getConfFileContent(confFileName);\n+        if (confFileContent == null) {\n+            return null;\n+        }\n+\n+        String portFileName = getPortFileName(confFileContent);\n+        if (portFileName == null) {\n+            return null;\n+        }\n+        String javaCommand = getJavaCommandString(confFileContent);\n+        if (javaCommand == null) {\n+            return null;\n+        }\n+\n+        PortFile portFile = new PortFile(portFileName);\n+        String[] javacArgs = Arrays.copyOfRange(args, 1, args.length);\n+\n+        ClientConfiguration conf = new ClientConfiguration(portFile, javaCommand, javacArgs);\n+        return conf;\n+    }\n+\n+    private static String getConfFileName(String[] args) {\n+        if (args.length < 1) {\n+            Log.error(\"Error: javacserver client: missing --conf=<conf file> argument\");\n+            return null;\n+        }\n+        String[] conf = args[0].split(\"=\", 2);\n+        if (conf.length != 2 || !conf[0].equalsIgnoreCase(\"--conf\")) {\n+            Log.error(\"Error: javacserver client: first argument must be --conf=<conf file>\");\n+            return null;\n+        }\n+        String confFileName = conf[1];\n+        if (!Files.exists(Path.of(confFileName))) {\n+            Log.error(\"Error: javacserver client: specified conf file does not exist\");\n+            return null;\n+        }\n+        return confFileName;\n+    }\n+\n+    private static String getConfFileContent(String confFile) {\n+        try {\n+            List<String> confFileLines = Files.readAllLines(Path.of(confFile));\n+            String confFileContent = String.join(\"\\n\", confFileLines);\n+            return confFileContent;\n+        } catch (IOException e) {\n+            Log.error(\"Cannot read configuration file \" + confFile);\n+            Log.debug(e);\n+            return null;\n+        }\n+    }\n+\n+    private static String getJavaCommandString(String confFileContent) {\n+        String serverCommandString = getConfValue(\"javacmd\", confFileContent);\n+        if (serverCommandString.isEmpty()) {\n+            Log.error(\"Configuration file missing value for 'javacmd'\");\n+            return null;\n+        } else {\n+            return serverCommandString;\n+        }\n+    }\n+\n+    private static String getPortFileName(String confFileContent) {\n+        String portfileName = getConfValue(\"portfile\", confFileContent);\n+        if (portfileName.isEmpty()) {\n+            Log.error(\"Configuration file missing value for 'portfile'\");\n+            return null;\n+        } else {\n+            return portfileName;\n+        }\n+    }\n+\n+    private static String getConfValue(String optionName, String content) {\n+        String result;\n+        int p = content.indexOf(optionName + \"=\");\n+        if (p == -1) {\n+            result = \"\";\n+        } else {\n+            p += optionName.length() + 1;\n+            int pe = content.indexOf('\\n', p);\n+            if (pe == -1) pe = content.length();\n+            result = content.substring(p, pe);\n+        }\n+        return result.strip();\n+    }\n+}\n\\ No newline at end of file\n","filename":"make\/langtools\/tools\/javacserver\/client\/ClientConfiguration.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.client;\n-\n-import java.io.OutputStreamWriter;\n-import java.io.Writer;\n-\n-import javacserver.AutoFlushWriter;\n-import javacserver.Log;\n-import javacserver.Result;\n-import javacserver.comp.SjavacImpl;\n-import javacserver.options.Options;\n-import javacserver.server.Sjavac;\n-\n-\/**\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class ClientMain {\n-\n-    public static int run(String[] args) {\n-        return run(args,\n-                   new AutoFlushWriter(new OutputStreamWriter(System.out)),\n-                   new AutoFlushWriter(new OutputStreamWriter(System.err)));\n-    }\n-\n-    public static int run(String[] args, Writer out, Writer err) {\n-\n-        Log.setLogForCurrentThread(new Log(out, err));\n-\n-        Options options;\n-        try {\n-            options = Options.parseArgs(args);\n-        } catch (IllegalArgumentException e) {\n-            Log.error(e.getMessage());\n-            return Result.CMDERR.exitCode;\n-        }\n-\n-        Log.setLogLevel(options.getLogLevel());\n-\n-        \/\/ Prepare sjavac object\n-        boolean useServer = options.getServerConf() != null;\n-        Sjavac sjavac = useServer ? new SjavacClient(options) : new SjavacImpl();\n-\n-        \/\/ Perform compilation\n-        Result result = sjavac.compile(args);\n-\n-        \/\/ If sjavac is running in the foreground we should shut it down at this point\n-        if (!useServer) {\n-            sjavac.shutdown();\n-        }\n-\n-        return result.exitCode;\n-    }\n-}\n","filename":"make\/langtools\/tools\/javacserver\/client\/ClientMain.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -1,280 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.client;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.OutputStreamWriter;\n-import java.io.PrintWriter;\n-import java.io.Reader;\n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n-import java.net.Socket;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-import javacserver.Log;\n-import javacserver.Result;\n-import javacserver.Util;\n-import javacserver.options.Options;\n-import javacserver.server.PortFile;\n-import javacserver.server.Sjavac;\n-import javacserver.server.SjavacServer;\n-\n-\/**\n- * Sjavac implementation that delegates requests to a SjavacServer.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class SjavacClient implements Sjavac {\n-\n-    private PortFile portFile;\n-\n-    \/\/ The servercmd option specifies how the server part of sjavac is spawned.\n-    \/\/ It should point to a javacserver.Main that supports --startserver\n-    private String serverCommand;\n-\n-    \/\/ Accept 120 seconds of inactivity before quitting.\n-    private static final int KEEPALIVE = 120;\n-    private static final int POOLSIZE = Runtime.getRuntime().availableProcessors();\n-    \/\/ Wait 2 seconds for response, before giving up on javac server.\n-    private static final int CONNECTION_TIMEOUT = 2000;\n-    private static final int MAX_CONNECT_ATTEMPTS = 3;\n-    private static final int WAIT_BETWEEN_CONNECT_ATTEMPTS = 2000;\n-\n-    public SjavacClient(Options options) {\n-        String serverConf = options.getServerConf();\n-        String configFile = Util.extractStringOption(\"conf\", serverConf, \"\");\n-\n-        try {\n-            List<String> configFileLines = Files.readAllLines(Path.of(configFile));\n-            String configFileContent = String.join(\"\\n\", configFileLines);\n-\n-            String portfileName = Util.extractStringOptionLine(\"portfile\", configFileContent, \"\");\n-            if (portfileName.isEmpty()) {\n-                Log.error(\"Configuration file missing value for 'portfile'\");\n-                portFile = null;\n-            } else  {\n-                portFile = SjavacServer.getPortFile(portfileName);\n-            }\n-\n-            String serverCommandString = Util.extractStringOptionLine(\"servercmd\", configFileContent, \"\");\n-            if (serverCommandString.isEmpty()) {\n-                Log.error(\"Configuration file missing value for 'servercmd'\");\n-                serverCommand = null;\n-            } else  {\n-                serverCommand = serverCommandString;\n-            }\n-        } catch (IOException e) {\n-            Log.error(\"Cannot read configuration file \" + configFile);\n-            Log.debug(e);\n-            portFile = null;\n-            serverCommand = null;\n-        }\n-    }\n-\n-    @Override\n-    public Result compile(String[] args) {\n-        if (portFile == null || serverCommand == null) {\n-            Log.error(\"Incorrect configuration, portfile and\/or servercmd missing\");\n-            return Result.ERROR;\n-        }\n-\n-        Result result = null;\n-        try (Socket socket = tryConnect()) {\n-            PrintWriter out = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()));\n-            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n-\n-            \/\/ Send args array to server\n-            out.println(args.length);\n-            for (String arg : args)\n-                out.println(arg);\n-            out.flush();\n-\n-            \/\/ Read server response line by line\n-            String line;\n-            while (null != (line = in.readLine())) {\n-                if (!line.contains(\":\")) {\n-                    throw new AssertionError(\"Could not parse protocol line: >>\\\"\" + line + \"\\\"<<\");\n-                }\n-                String[] typeAndContent = line.split(\":\", 2);\n-                String type = typeAndContent[0];\n-                String content = typeAndContent[1];\n-\n-                try {\n-                    if (Log.isDebugging()) {\n-                        \/\/ Distinguish server generated output if debugging.\n-                        content = \"[sjavac-server] \" + content;\n-                    }\n-                    Log.log(Log.Level.valueOf(type), content);\n-                    continue;\n-                } catch (IllegalArgumentException e) {\n-                    \/\/ Parsing of 'type' as log level failed.\n-                }\n-\n-                if (type.equals(SjavacServer.LINE_TYPE_RC)) {\n-                    result = Result.valueOf(content);\n-                }\n-            }\n-        } catch (PortFileInaccessibleException e) {\n-            Log.error(\"Port file inaccessible.\");\n-            result = Result.ERROR;\n-        } catch (IOException ioe) {\n-            Log.error(\"IOException caught during compilation: \" + ioe.getMessage());\n-            Log.debug(ioe);\n-            result = Result.ERROR;\n-        } catch (InterruptedException ie) {\n-            Thread.currentThread().interrupt(); \/\/ Restore interrupt\n-            Log.error(\"Compilation interrupted.\");\n-            Log.debug(ie);\n-            result = Result.ERROR;\n-        }\n-\n-        if (result == null) {\n-            \/\/ No LINE_TYPE_RC was found.\n-            result = Result.ERROR;\n-        }\n-\n-        return result;\n-    }\n-\n-    \/*\n-     * Makes MAX_CONNECT_ATTEMPTS attempts to connect to server.\n-     *\/\n-    private Socket tryConnect() throws IOException, InterruptedException {\n-        makeSureServerIsRunning();\n-        int attempt = 0;\n-        while (true) {\n-            Log.debug(\"Trying to connect. Attempt \" + (++attempt) + \" of \" + MAX_CONNECT_ATTEMPTS);\n-            try {\n-                return makeConnectionAttempt();\n-            } catch (IOException ex) {\n-                Log.error(\"Connection attempt failed: \" + ex.getMessage());\n-                if (attempt >= MAX_CONNECT_ATTEMPTS) {\n-                    Log.error(\"Giving up\");\n-                    throw new IOException(\"Could not connect to server\", ex);\n-                }\n-            }\n-            Thread.sleep(WAIT_BETWEEN_CONNECT_ATTEMPTS);\n-        }\n-    }\n-\n-    private Socket makeConnectionAttempt() throws IOException {\n-        Socket socket = new Socket();\n-        InetAddress localhost = InetAddress.getByName(null);\n-        InetSocketAddress address = new InetSocketAddress(localhost, portFile.getPort());\n-        socket.connect(address, CONNECTION_TIMEOUT);\n-        Log.debug(\"Connected\");\n-        return socket;\n-    }\n-\n-    \/*\n-     * Will return immediately if a server already seems to be running,\n-     * otherwise fork a new server and block until it seems to be running.\n-     *\/\n-    private void makeSureServerIsRunning()\n-            throws IOException, InterruptedException {\n-\n-        if (portFile.exists()) {\n-            portFile.lock();\n-            portFile.getValues();\n-            portFile.unlock();\n-\n-            if (portFile.containsPortInfo()) {\n-                \/\/ Server seems to already be running\n-                return;\n-            }\n-        }\n-\n-        \/\/ Fork a new server and wait for it to start\n-        startNewServer();\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-        \/\/ Nothing to clean up\n-    }\n-\n-    \/*\n-     * Fork a server process process and wait for server to come around\n-     *\/\n-    public void startNewServer()\n-            throws IOException, InterruptedException {\n-        List<String> cmd = new ArrayList<>();\n-        cmd.addAll(Arrays.asList(serverCommand.split(\" \")));\n-        cmd.add(\"--startserver:\"\n-              + \"portfile=\" + portFile.getFilename()\n-              + \",poolsize=\" + POOLSIZE\n-              + \",keepalive=\"+ KEEPALIVE);\n-\n-        Process serverProcess;\n-        Log.debug(\"Starting server. Command: \" + String.join(\" \", cmd));\n-        try {\n-            \/\/ If the cmd for some reason can't be executed (file is not found,\n-            \/\/ or is not executable for instance) this will throw an\n-            \/\/ IOException and p == null.\n-            serverProcess = new ProcessBuilder(cmd)\n-                    .redirectErrorStream(true)\n-                    .start();\n-        } catch (IOException ex) {\n-            \/\/ Message is typically something like:\n-            \/\/ Cannot run program \"xyz\": error=2, No such file or directory\n-            Log.error(\"Failed to create server process: \" + ex.getMessage());\n-            Log.debug(ex);\n-            throw new IOException(ex);\n-        }\n-\n-        \/\/ serverProcess != null at this point.\n-        try {\n-            \/\/ Throws an IOException if no valid values materialize\n-            portFile.waitForValidValues();\n-        } catch (IOException ex) {\n-            \/\/ Process was started, but server failed to initialize. This could\n-            \/\/ for instance be due to the JVM not finding the server class,\n-            \/\/ or the server running in to some exception early on.\n-            Log.error(\"Sjavac server failed to initialize: \" + ex.getMessage());\n-            Log.error(\"Process output:\");\n-            Reader serverStdoutStderr = new InputStreamReader(serverProcess.getInputStream());\n-            try (BufferedReader br = new BufferedReader(serverStdoutStderr)) {\n-                br.lines().forEach(Log::error);\n-            }\n-            Log.error(\"<End of process output>\");\n-            try {\n-                Log.error(\"Process exit code: \" + serverProcess.exitValue());\n-            } catch (IllegalThreadStateException e) {\n-                \/\/ Server is presumably still running.\n-            }\n-            throw new IOException(\"Server failed to initialize: \" + ex.getMessage(), ex);\n-        }\n-    }\n-}\n","filename":"make\/langtools\/tools\/javacserver\/client\/SjavacClient.java","additions":0,"deletions":280,"binary":false,"changes":280,"status":"deleted"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.comp;\n-\n-import java.util.Objects;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.TimeUnit;\n-\n-import javacserver.Log;\n-import javacserver.Result;\n-import javacserver.server.Sjavac;\n-\n-\/**\n- * An sjavac implementation that limits the number of concurrent calls by\n- * wrapping invocations in Callables and delegating them to a FixedThreadPool.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class PooledSjavac implements Sjavac {\n-\n-    final Sjavac delegate;\n-    final ExecutorService pool;\n-\n-    public PooledSjavac(Sjavac delegate, int poolsize) {\n-        Objects.requireNonNull(delegate);\n-        this.delegate = delegate;\n-        pool = Executors.newFixedThreadPool(poolsize);\n-    }\n-\n-    @Override\n-    public Result compile(String[] args) {\n-        Log log = Log.get();\n-        try {\n-            return pool.submit(() -> {\n-                Log.setLogForCurrentThread(log);\n-                return delegate.compile(args);\n-            }).get();\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-            throw new RuntimeException(\"Error during compile\", e);\n-        }\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-        Log.debug(\"Shutting down PooledSjavac\");\n-        pool.shutdown(); \/\/ Disable new tasks from being submitted\n-        try {\n-            \/\/ Wait a while for existing tasks to terminate\n-            if (!pool.awaitTermination(60, TimeUnit.SECONDS)) {\n-                pool.shutdownNow(); \/\/ Cancel currently executing tasks\n-                \/\/ Wait a while for tasks to respond to being cancelled\n-                if (!pool.awaitTermination(60, TimeUnit.SECONDS))\n-                    Log.error(\"ThreadPool did not terminate\");\n-            }\n-        } catch (InterruptedException ie) {\n-          \/\/ (Re-)Cancel if current thread also interrupted\n-          pool.shutdownNow();\n-          \/\/ Preserve interrupt status\n-          Thread.currentThread().interrupt();\n-        }\n-\n-        delegate.shutdown();\n-    }\n-\n-}\n","filename":"make\/langtools\/tools\/javacserver\/comp\/PooledSjavac.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.comp;\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.util.stream.Stream;\n-\n-import com.sun.tools.javac.Main;\n-\n-import javacserver.Log;\n-import javacserver.Result;\n-import javacserver.Util;\n-import javacserver.options.Option;\n-import javacserver.server.Sjavac;\n-\n-\/**\n- * The sjavac implementation that interacts with javac and performs the actual\n- * compilation.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class SjavacImpl implements Sjavac {\n-\n-    @Override\n-    @SuppressWarnings(\"deprecated\")\n-    public Result compile(String[] args) {\n-        \/\/ Direct logging to our byte array stream.\n-        StringWriter strWriter = new StringWriter();\n-        PrintWriter printWriter = new PrintWriter(strWriter);\n-\n-        \/\/ Prepare arguments\n-        String[] passThroughArgs = Stream.of(args)\n-                                         .filter(arg -> !arg.startsWith(Option.SERVER.arg))\n-                                         .toArray(String[]::new);\n-        \/\/ Compile\n-        int exitcode = Main.compile(passThroughArgs, printWriter);\n-        Result result = Result.of(exitcode);\n-\n-        \/\/ Process compiler output (which is always errors)\n-        printWriter.flush();\n-        Util.getLines(strWriter.toString()).forEach(Log::error);\n-\n-        return result;\n-\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-        \/\/ Nothing to clean up\n-    }\n-}\n","filename":"make\/langtools\/tools\/javacserver\/comp\/SjavacImpl.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -1,89 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.options;\n-\n-import java.util.Iterator;\n-\n-\/**\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class ArgumentIterator implements Iterator<String> {\n-\n-    \/** The underlying argument iterator *\/\n-    private Iterator<String> iter;\n-\n-    \/** Extra state used to implement peek and current *\/\n-    private String current;\n-    private String buffered;\n-\n-    public ArgumentIterator(Iterable<String> iter) {\n-        this.iter = iter.iterator();\n-    }\n-\n-    @Override\n-    public boolean hasNext() {\n-        return buffered != null || iter.hasNext();\n-    }\n-\n-    @Override\n-    public String next() {\n-        fillBuffer();\n-        current = buffered;\n-        buffered = null;\n-        return current;\n-    }\n-\n-    \/**\n-     * @return the last element returned by next() (or {@code null} if next has\n-     * never been invoked on this iterator).\n-     *\/\n-    public String current() {\n-        return current;\n-    }\n-\n-    \/** Can't remove current element, since we may have buffered it. *\/\n-    @Override\n-    public void remove() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    \/**\n-     * @return Returns the next element without advancing the iterator\n-     *\/\n-    public String peek() {\n-        fillBuffer();\n-        return buffered;\n-    }\n-\n-    private void fillBuffer() {\n-        if (buffered == null && iter.hasNext())\n-            buffered = iter.next();\n-    }\n-\n-}\n","filename":"make\/langtools\/tools\/javacserver\/options\/ArgumentIterator.java","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"},{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.options;\n-\n-\/**\n- * Sjavac options can be classified as:\n- *\n- *  (1) relevant only for sjavac, such as --server\n- *  (2) relevant for sjavac and javac, such as -d, or\n- *  (3) relevant only for javac, such as -g.\n- *\n- * This enum represents all options from (1) and (2). Note that instances of\n- * this enum only entail static information about the option. For storage of\n- * option values, refer to Options.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public enum Option {\n-    SERVER(\"--server:\", \"Specify server configuration file of running server\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, Options.ArgDecoderOptionHelper helper) {\n-            helper.serverConf(iter.current().substring(arg.length()));\n-        }\n-    },\n-    STARTSERVER(\"--startserver:\", \"Start server and use the given configuration file\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, Options.ArgDecoderOptionHelper helper) {\n-            helper.startServerConf(iter.current().substring(arg.length()));\n-        }\n-    };\n-\n-\n-    public final String arg;\n-\n-    final String description;\n-\n-    private Option(String arg, String description) {\n-        this.arg = arg;\n-        this.description = description;\n-    }\n-\n-    \/\/ Future cleanup: Change the \"=\" syntax to \":\" syntax to be consistent and\n-    \/\/ to follow the javac-option style.\n-\n-    public boolean hasOption() {\n-        return arg.endsWith(\":\") || arg.endsWith(\"=\");\n-    }\n-\n-\n-    \/**\n-     * Process current argument of argIter.\n-     *\n-     * It's final, since the option customization is typically done in\n-     * processMatching.\n-     *\n-     * @param argIter Iterator to read current and succeeding arguments from.\n-     * @param helper The helper to report back to.\n-     * @return true iff the argument was processed by this option.\n-     *\/\n-    public final boolean processCurrent(ArgumentIterator argIter,\n-                                        Options.ArgDecoderOptionHelper helper) {\n-        String fullArg = argIter.current(); \/\/ \"-tr\" or \"-log=level\"\n-        if (hasOption() ? fullArg.startsWith(arg) : fullArg.equals(arg)) {\n-            processMatching(argIter, helper);\n-            return true;\n-        }\n-        \/\/ Did not match\n-        return false;\n-    }\n-\n-    \/** Called by process if the current argument matches this option. *\/\n-    protected abstract void processMatching(ArgumentIterator argIter,\n-                                            Options.ArgDecoderOptionHelper helper);\n-}\n","filename":"make\/langtools\/tools\/javacserver\/options\/Option.java","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -1,121 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.options;\n-\n-import java.util.List;\n-\n-\/**\n- * Instances of this class represent values for sjavac command line options.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Options {\n-    private String logLevel = \"info\";\n-\n-    private boolean startServer = false;\n-\n-    \/\/ Server configuration string\n-    private String serverConf;\n-\n-    \/** Get the log level. *\/\n-    public String getLogLevel() {\n-        return logLevel;\n-    }\n-\n-    \/** Return true iff a new server should be started *\/\n-    public boolean startServerFlag() {\n-        return startServer;\n-    }\n-\n-    \/** Return the server configuration string. *\/\n-    public String getServerConf() {\n-        return serverConf;\n-    }\n-\n-    \/**\n-     * Parses the given argument array and returns a corresponding Options\n-     * instance.\n-     *\/\n-    public static Options parseArgs(String... args) {\n-        Options options = new Options();\n-        options.new ArgDecoderOptionHelper().traverse(args);\n-        return options;\n-    }\n-\n-    \/\/ OptionHelper that records the traversed options in this Options instance.\n-    public class ArgDecoderOptionHelper {\n-        public void reportError(String msg) {\n-            throw new IllegalArgumentException(msg);\n-        }\n-\n-        public void serverConf(String conf) {\n-            if (serverConf != null)\n-                reportError(\"Can not specify more than one server configuration.\");\n-            else\n-                serverConf = conf;\n-        }\n-\n-        public void startServerConf(String conf) {\n-            if (serverConf != null)\n-                reportError(\"Can not specify more than one server configuration.\");\n-            else {\n-                startServer = true;\n-                serverConf = conf;\n-            }\n-        }\n-\n-        \/**\n-         * Traverses an array of arguments and performs the appropriate callbacks.\n-         *\n-         * @param args the arguments to traverse.\n-         *\/\n-        void traverse(String[] args) {\n-            Iterable<String> allArgs;\n-            try {\n-                allArgs = CommandLine.parse(List.of(args)); \/\/ Detect @file and load it as a command line.\n-            } catch (java.io.IOException e) {\n-                throw new IllegalArgumentException(\"Problem reading @\"+e.getMessage());\n-            }\n-            ArgumentIterator argIter = new ArgumentIterator(allArgs);\n-\n-            nextArg:\n-            while (argIter.hasNext()) {\n-\n-                String arg = argIter.next();\n-\n-                if (arg.startsWith(\"-\")) {\n-                    for (Option opt : Option.values()) {\n-                        if (opt.processCurrent(argIter, this))\n-                            continue nextArg;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"make\/langtools\/tools\/javacserver\/options\/Options.java","additions":0,"deletions":121,"binary":false,"changes":121,"status":"deleted"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.server;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import javacserver.util.Log;\n+\n+\/**\n+ * Use a fixed thread pool to limit the amount of concurrent javac compilation\n+ * that can happen.\n+ *\/\n+public class CompilerThreadPool {\n+    private static final int POOLSIZE = Runtime.getRuntime().availableProcessors();\n+\n+    private final ExecutorService pool;\n+\n+    public CompilerThreadPool() {\n+        this.pool = Executors.newFixedThreadPool(POOLSIZE);\n+    }\n+\n+    public int dispatchCompilation(String[] args) {\n+        Log log = Log.get();\n+        try {\n+            return pool.submit(() -> Server.runCompiler(log, args)).get();\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(\"Error during compile\", e);\n+        }\n+    }\n+\n+    public void shutdown() {\n+        Log.debug(\"Shutting down javacserver thread pool\");\n+        pool.shutdown(); \/\/ Disable new tasks from being submitted\n+        try {\n+            \/\/ Wait a while for existing tasks to terminate\n+            if (!pool.awaitTermination(60, TimeUnit.SECONDS)) {\n+                pool.shutdownNow(); \/\/ Cancel currently executing tasks\n+                \/\/ Wait a while for tasks to respond to being cancelled\n+                if (!pool.awaitTermination(60, TimeUnit.SECONDS))\n+                    Log.error(\"Thread pool did not terminate\");\n+            }\n+        } catch (InterruptedException ie) {\n+            \/\/ (Re-)Cancel if current thread also interrupted\n+            pool.shutdownNow();\n+            \/\/ Preserve interrupt status\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+\n+    public int poolSize() {\n+        return POOLSIZE;\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/server\/CompilerThreadPool.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.server;\n+\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.function.Consumer;\n+import javacserver.util.RunnableTimerTask;\n+\n+\/**\n+ * Monitors the javacserver daemon, shutting it down if it recieves no new requests\n+ * after a certain amount of time.\n+ *\/\n+public class IdleMonitor {\n+    \/\/ Accept 120 seconds of inactivity before quitting.\n+    private static final int KEEPALIVE = 120;\n+\n+    private final Consumer<String> onShutdown;\n+    private final Timer idlenessTimer = new Timer();\n+    private int outstandingCalls = 0;\n+\n+    \/\/ Class invariant: idlenessTimerTask != null <-> idlenessTimerTask is scheduled\n+    private TimerTask idlenessTimerTask;\n+\n+    public IdleMonitor(Consumer<String> onShutdown) {\n+        this.onShutdown = onShutdown;\n+        scheduleTimeout();\n+    }\n+\n+    public synchronized void startCall() {\n+        \/\/ Was there no outstanding calls before this call?\n+        if (++outstandingCalls == 1) {\n+            \/\/ Then the timer task must have been scheduled\n+            if (idlenessTimerTask == null)\n+                throw new IllegalStateException(\"Idle timeout already cancelled\");\n+            \/\/ Cancel timeout task\n+            idlenessTimerTask.cancel();\n+            idlenessTimerTask = null;\n+        }\n+    }\n+\n+    public synchronized void endCall() {\n+        if (--outstandingCalls == 0) {\n+            \/\/ No more outstanding calls. Schedule timeout.\n+            scheduleTimeout();\n+        }\n+    }\n+\n+    private void scheduleTimeout() {\n+        if (idlenessTimerTask != null)\n+            throw new IllegalStateException(\"Idle timeout already scheduled\");\n+        idlenessTimerTask = new RunnableTimerTask(() -> {\n+            Server.restoreServerErrorLog();\n+            onShutdown.accept(\"Server has been idle for \" + KEEPALIVE + \" seconds.\");\n+        });\n+        idlenessTimer.schedule(idlenessTimerTask, KEEPALIVE * 1000);\n+    }\n+\n+    public void shutdown() {\n+        idlenessTimer.cancel();\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/server\/IdleMonitor.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.server;\n-\n-import java.util.Timer;\n-import java.util.TimerTask;\n-\n-import javacserver.Log;\n-import javacserver.Result;\n-\n-\/**\n- * An sjavac implementation that keeps track of idleness and shuts down the\n- * given Terminable upon idleness timeout.\n- *\n- * An idleness timeout kicks in {@code idleTimeout} milliseconds after the last\n- * request is completed.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class IdleResetSjavac implements Sjavac {\n-\n-    private final Sjavac delegate;\n-    private final Terminable toShutdown;\n-    private final Timer idlenessTimer = new Timer();\n-    private final long idleTimeout;\n-    private int outstandingCalls = 0;\n-\n-    \/\/ Class invariant: idlenessTimerTask != null <-> idlenessTimerTask is scheduled\n-    private TimerTask idlenessTimerTask;\n-\n-    public IdleResetSjavac(Sjavac delegate,\n-                           Terminable toShutdown,\n-                           long idleTimeout) {\n-        this.delegate = delegate;\n-        this.toShutdown = toShutdown;\n-        this.idleTimeout = idleTimeout;\n-        scheduleTimeout();\n-    }\n-\n-    @Override\n-    public Result compile(String[] args) {\n-        startCall();\n-        try {\n-            return delegate.compile(args);\n-        } finally {\n-            endCall();\n-        }\n-    }\n-\n-    private synchronized void startCall() {\n-        \/\/ Was there no outstanding calls before this call?\n-        if (++outstandingCalls == 1) {\n-            \/\/ Then the timer task must have been scheduled\n-            if (idlenessTimerTask == null)\n-                throw new IllegalStateException(\"Idle timeout already cancelled\");\n-            \/\/ Cancel timeout task\n-            idlenessTimerTask.cancel();\n-            idlenessTimerTask = null;\n-        }\n-    }\n-\n-    private synchronized void endCall() {\n-        if (--outstandingCalls == 0) {\n-            \/\/ No more outstanding calls. Schedule timeout.\n-            scheduleTimeout();\n-        }\n-    }\n-\n-    private void scheduleTimeout() {\n-        if (idlenessTimerTask != null)\n-            throw new IllegalStateException(\"Idle timeout already scheduled\");\n-        idlenessTimerTask = new TimerTask() {\n-            public void run() {\n-                Log.setLogForCurrentThread(ServerMain.getErrorLog());\n-                toShutdown.shutdown(\"Server has been idle for \" + (idleTimeout \/ 1000) + \" seconds.\");\n-            }\n-        };\n-        idlenessTimer.schedule(idlenessTimerTask, idleTimeout);\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-        idlenessTimer.cancel();\n-        delegate.shutdown();\n-    }\n-\n-}\n","filename":"make\/langtools\/tools\/javacserver\/server\/IdleResetSjavac.java","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -30,3 +30,4 @@\n-import java.util.TimerTask;\n-\n-import javacserver.Log;\n+import java.util.function.Consumer;\n+import javacserver.shared.PortFile;\n+import javacserver.util.Log;\n+import javacserver.util.RunnableTimerTask;\n@@ -35,1 +36,1 @@\n- * Monitors the presence of a port file and shuts down the given SjavacServer\n+ * Monitors the presence of a port file and shuts down the server\n@@ -39,5 +40,0 @@\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n@@ -46,1 +42,0 @@\n-\n@@ -52,1 +47,1 @@\n-    private final SjavacServer server;\n+    private final Consumer<String> onShutdown;\n@@ -55,1 +50,1 @@\n-                           SjavacServer server) {\n+                           Consumer<String> onShutdown) {\n@@ -57,1 +52,1 @@\n-        this.server = server;\n+        this.onShutdown = onShutdown;\n@@ -62,28 +57,2 @@\n-        TimerTask shutdownCheck = new TimerTask() {\n-            public void run() {\n-                Log.setLogForCurrentThread(log);\n-                Log.debug(\"Checking port file status...\");\n-                try {\n-                    if (!portFile.exists()) {\n-                        \/\/ Time to quit because the portfile was deleted by another\n-                        \/\/ process, probably by the makefile that is done building.\n-                        server.shutdown(\"Quitting because portfile was deleted!\");\n-                    } else if (portFile.markedForStop()) {\n-                        \/\/ Time to quit because another process touched the file\n-                        \/\/ server.port.stop to signal that the server should stop.\n-                        \/\/ This is necessary on some operating systems that lock\n-                        \/\/ the port file hard!\n-                        server.shutdown(\"Quitting because a portfile.stop file was found!\");\n-                    } else if (!portFile.stillMyValues()) {\n-                        \/\/ Time to quit because another build has started.\n-                        server.shutdown(\"Quitting because portfile is now owned by another javac server!\");\n-                    }\n-                } catch (IOException e) {\n-                    Log.error(\"IOException caught in PortFileMonitor.\");\n-                    Log.debug(e);\n-                } catch (InterruptedException e) {\n-                    Thread.currentThread().interrupt();\n-                    Log.error(e);\n-                }\n-            }\n-        };\n+        timer.schedule(new RunnableTimerTask(() -> checkPortFile(log)), 0, CHECK_PORTFILE_INTERVAL);\n+    }\n@@ -91,1 +60,25 @@\n-        timer.schedule(shutdownCheck, 0, CHECK_PORTFILE_INTERVAL);\n+    private void checkPortFile(Log log) {\n+        Log.setLogForCurrentThread(log);\n+        Log.debug(\"Checking port file status...\");\n+        try {\n+            if (!portFile.exists()) {\n+                \/\/ Time to quit because the portfile was deleted by another\n+                \/\/ process, probably by the makefile that is done building.\n+                onShutdown.accept(\"Quitting because portfile was deleted!\");\n+            } else if (portFile.markedForStop()) {\n+                \/\/ Time to quit because another process touched the file\n+                \/\/ server.port.stop to signal that the server should stop.\n+                \/\/ This is necessary on some operating systems that lock\n+                \/\/ the port file hard!\n+                onShutdown.accept(\"Quitting because a portfile.stop file was found!\");\n+            } else if (!portFile.stillMyValues()) {\n+                \/\/ Time to quit because another build has started.\n+                onShutdown.accept(\"Quitting because portfile is now owned by another javac server!\");\n+            }\n+        } catch (IOException e) {\n+            Log.error(\"IOException caught in PortFileMonitor.\");\n+            Log.debug(e);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            Log.error(e);\n+        }\n","filename":"make\/langtools\/tools\/javacserver\/server\/PortFileMonitor.java","additions":35,"deletions":42,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -1,128 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.server;\n-\n-import java.io.BufferedReader;\n-import java.io.InputStreamReader;\n-import java.io.PrintWriter;\n-import java.net.Socket;\n-import java.nio.file.Path;\n-\n-import javacserver.Log;\n-import javacserver.Result;\n-import javacserver.Util;\n-\n-import static javacserver.server.SjavacServer.LINE_TYPE_RC;\n-\n-\n-\/**\n- * A RequestHandler handles requests performed over a socket. Specifically it\n- *  - Reads the command string specifying which method is to be invoked\n- *  - Reads the appropriate arguments\n- *  - Delegates the actual invocation to the given sjavac implementation\n- *  - Writes the result back to the socket output stream\n- *\n- * None of the work performed by this class is really bound by the CPU. It\n- * should be completely fine to have a large number of RequestHandlers active.\n- * To limit the number of concurrent compilations, use PooledSjavac.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class RequestHandler extends Thread {\n-\n-    private final Socket socket;\n-    private final Sjavac sjavac;\n-\n-    public RequestHandler(Socket socket, Sjavac sjavac) {\n-        this.socket = socket;\n-        this.sjavac = sjavac;\n-    }\n-\n-    @Override\n-    public void run() {\n-\n-        try (BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n-             PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {\n-\n-            \/\/ Set up logging for this thread. Stream back logging messages to\n-            \/\/ client on the format format \"level:msg\".\n-            Log.setLogForCurrentThread(new Log(out, out) {\n-                @Override\n-                protected boolean isLevelLogged(Level l) {\n-                    \/\/ Make sure it is up to the client to decide whether or\n-                    \/\/ not this message should be displayed.\n-                    return true;\n-                }\n-\n-                @Override\n-                protected void printLogMsg(Level msgLevel, String msg) {\n-                    \/\/ Follow sjavac server\/client protocol: Send one line\n-                    \/\/ at a time and prefix with message with \"level:\".\n-                    Util.getLines(msg)\n-                        .map(line -> msgLevel + \":\" + line)\n-                        .forEach(line -> super.printLogMsg(msgLevel, line));\n-                }\n-            });\n-\n-            \/\/ Read argument array\n-            int n = Integer.parseInt(in.readLine());\n-            String[] args = new String[n];\n-            for (int i = 0; i < n; i++) {\n-                args[i] = in.readLine();\n-            }\n-\n-            \/\/ If there has been any internal errors, notify client\n-            checkInternalErrorLog();\n-\n-            \/\/ Perform compilation\n-            Result rc = sjavac.compile(args);\n-\n-            \/\/ Send return code back to client\n-            out.println(LINE_TYPE_RC + \":\" + rc.name());\n-\n-            \/\/ Check for internal errors again.\n-            checkInternalErrorLog();\n-        } catch (Exception ex) {\n-            \/\/ Not much to be done at this point. The client side request\n-            \/\/ code will most likely throw an IOException and the\n-            \/\/ compilation will fail.\n-            Log.error(ex);\n-        } finally {\n-            Log.setLogForCurrentThread(null);\n-        }\n-    }\n-\n-    private void checkInternalErrorLog() {\n-        Path errorLog = ServerMain.getErrorLog().getLogDestination();\n-        if (errorLog != null) {\n-            Log.error(\"Server has encountered an internal error. See \" + errorLog.toAbsolutePath()\n-                    + \" for details.\");\n-        }\n-    }\n-}\n","filename":"make\/langtools\/tools\/javacserver\/server\/RequestHandler.java","additions":0,"deletions":128,"binary":false,"changes":128,"status":"deleted"},{"patch":"@@ -0,0 +1,286 @@\n+\/*\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.server;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.nio.file.Path;\n+import java.util.Optional;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.spi.ToolProvider;\n+import javacserver.shared.PortFile;\n+import javacserver.shared.Protocol;\n+import javacserver.shared.Result;\n+import javacserver.util.LazyInitFileLog;\n+import javacserver.util.Log;\n+import javacserver.util.LoggingOutputStream;\n+import javacserver.util.Util;\n+\n+\/**\n+ * Start a new server main thread, that will listen to incoming connection requests from the client,\n+ * and dispatch these on to worker threads in a thread pool, running javac.\n+ *\/\n+public class Server {\n+    private ServerSocket serverSocket;\n+    private PortFile portFile;\n+    private PortFileMonitor portFileMonitor;\n+    private IdleMonitor idleMonitor;\n+    private CompilerThreadPool compilerThreadPool;\n+\n+    \/\/ Set to false break accept loop\n+    final AtomicBoolean keepAcceptingRequests = new AtomicBoolean();\n+\n+    \/\/ For logging server internal (non request specific) errors.\n+    private static LazyInitFileLog errorLog;\n+\n+    public static void main(String... args) {\n+        initLogging();\n+\n+        try {\n+            PortFile portFile = getPortFileFromArguments(args);\n+            if (portFile == null) {\n+                System.exit(Result.CMDERR.exitCode);\n+                return;\n+            }\n+\n+            Server server = new Server(portFile);\n+            if (!server.start()) {\n+                System.exit(Result.ERROR.exitCode);\n+            } else {\n+                System.exit(Result.OK.exitCode);\n+            }\n+        } catch (IOException | InterruptedException ex) {\n+            ex.printStackTrace();\n+            System.exit(Result.ERROR.exitCode);\n+        }\n+    }\n+\n+    private static void initLogging() {\n+        \/\/ Under normal operation, all logging messages generated server-side\n+        \/\/ are due to compilation requests. These logging messages should\n+        \/\/ be relayed back to the requesting client rather than written to the\n+        \/\/ server log. The only messages that should be written to the server\n+        \/\/ log (in production mode) should be errors,\n+        errorLog = new LazyInitFileLog(\"server.log\");\n+        Log.setLogForCurrentThread(errorLog);\n+        Log.setLogLevel(Log.Level.ERROR); \/\/ should be set to ERROR.\n+\n+        \/\/ Make sure no exceptions go under the radar\n+        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {\n+            restoreServerErrorLog();\n+            Log.error(e);\n+        });\n+\n+        \/\/ Inevitably someone will try to print messages using System.{out,err}.\n+        \/\/ Make sure this output also ends up in the log.\n+        System.setOut(new PrintStream(new LoggingOutputStream(System.out, Log.Level.INFO, \"[stdout] \")));\n+        System.setErr(new PrintStream(new LoggingOutputStream(System.err, Log.Level.ERROR, \"[stderr] \")));\n+    }\n+\n+    private static PortFile getPortFileFromArguments(String[] args) {\n+        if (args.length != 1) {\n+            Log.error(\"javacserver daemon incorrectly called\");\n+            return null;\n+        }\n+        String portfilename = args[0];\n+        PortFile portFile = new PortFile(portfilename);\n+        return portFile;\n+    }\n+\n+    public Server(PortFile portFile) throws FileNotFoundException {\n+        this.portFile = portFile;\n+    }\n+\n+    \/**\n+     * Start the daemon, unless another one is already running, in which it returns\n+     * false and exits immediately.\n+     *\/\n+    private boolean start() throws IOException, InterruptedException {\n+        \/\/ The port file is locked and the server port and cookie is written into it.\n+        portFile.lock();\n+        portFile.getValues();\n+        if (portFile.containsPortInfo()) {\n+            Log.debug(\"javacserver daemon not started because portfile exists!\");\n+            portFile.unlock();\n+            return false;\n+        }\n+\n+        serverSocket = new ServerSocket();\n+        InetAddress localhost = InetAddress.getByName(null);\n+        serverSocket.bind(new InetSocketAddress(localhost, 0));\n+\n+        \/\/ At this point the server accepts connections, so it is  now safe\n+        \/\/ to publish the port \/ cookie information\n+\n+        \/\/ The secret cookie shared between server and client through the port file.\n+        \/\/ Used to prevent clients from believing that they are communicating with\n+        \/\/ an old server when a new server has started and reused the same port as\n+        \/\/ an old server.\n+        long myCookie = new Random().nextLong();\n+        portFile.setValues(serverSocket.getLocalPort(), myCookie);\n+        portFile.unlock();\n+\n+        portFileMonitor = new PortFileMonitor(portFile, this::shutdownServer);\n+        portFileMonitor.start();\n+        compilerThreadPool = new CompilerThreadPool();\n+        idleMonitor = new IdleMonitor(this::shutdownServer);\n+\n+        Log.debug(\"javacserver daemon started. Accepting connections...\");\n+        Log.debug(\"    port: \" + serverSocket.getLocalPort());\n+        Log.debug(\"    time: \" + new java.util.Date());\n+        Log.debug(\"    poolsize: \" + compilerThreadPool.poolSize());\n+\n+        keepAcceptingRequests.set(true);\n+        do {\n+            try {\n+                Socket socket = serverSocket.accept();\n+                 \/\/ Handle each incoming request in a separate thread. This is just for socket communication,\n+                 \/\/ the actual compilation will be done by the threadpool.\n+                Thread requestHandler = new Thread(() -> handleRequest(socket));\n+                requestHandler.start();\n+            } catch (SocketException se) {\n+                \/\/ Caused by serverSocket.close() and indicates shutdown\n+            }\n+        } while (keepAcceptingRequests.get());\n+\n+        Log.debug(\"Shutting down.\");\n+\n+        \/\/ No more connections accepted. If any client managed to connect after\n+        \/\/ the accept() was interrupted but before the server socket is closed\n+        \/\/ here, any attempt to read or write to the socket will result in an\n+        \/\/ IOException on the client side.\n+\n+        \/\/ Shut down\n+        idleMonitor.shutdown();\n+        compilerThreadPool.shutdown();\n+\n+        return true;\n+    }\n+\n+    private void handleRequest(Socket socket) {\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+             PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {\n+            try {\n+                idleMonitor.startCall();\n+\n+                \/\/ Set up logging for this thread. Stream back logging messages to\n+                \/\/ client on the format \"level:msg\".\n+                Log.setLogForCurrentThread(new Protocol.ProtocolLog(out));\n+\n+                String[] args = Protocol.readCommand(in);\n+\n+                \/\/ If there has been any internal errors, notify client\n+                checkInternalErrorLog();\n+\n+                \/\/ Perform compilation. This will call runCompiler() on a\n+                \/\/ thread in the thread pool\n+                int exitCode = compilerThreadPool.dispatchCompilation(args);\n+                Protocol.sendExitCode(out, exitCode);\n+\n+                \/\/ Check for internal errors again.\n+                checkInternalErrorLog();\n+            } finally {\n+                idleMonitor.endCall();\n+            }\n+        } catch (Exception ex) {\n+            \/\/ Not much to be done at this point. The client side request\n+            \/\/ code will most likely throw an IOException and the\n+            \/\/ compilation will fail.\n+            Log.error(ex);\n+        } finally {\n+            Log.setLogForCurrentThread(null);\n+        }\n+    }\n+\n+    public static int runCompiler(Log log, String[] args) {\n+        Log.setLogForCurrentThread(log);\n+\n+        \/\/ Direct logging to our byte array stream.\n+        StringWriter strWriter = new StringWriter();\n+        PrintWriter printWriter = new PrintWriter(strWriter);\n+\n+        \/\/ Compile\n+        Optional<ToolProvider> tool = ToolProvider.findFirst(\"javac\");\n+        if (tool.isEmpty()) {\n+            Log.error(\"Can't find tool javac\");\n+            return Result.ERROR.exitCode;\n+        }\n+        int exitcode = tool.get().run(printWriter, printWriter, args);\n+\n+        \/\/ Process compiler output (which is always errors)\n+        printWriter.flush();\n+        Util.getLines(strWriter.toString()).forEach(Log::error);\n+\n+        return exitcode;\n+    }\n+\n+    private void checkInternalErrorLog() {\n+        Path errorLogPath = errorLog.getLogDestination();\n+        if (errorLogPath != null) {\n+            Log.error(\"Server has encountered an internal error. See \" + errorLogPath.toAbsolutePath()\n+                    + \" for details.\");\n+        }\n+    }\n+\n+    public static void restoreServerErrorLog() {\n+        Log.setLogForCurrentThread(errorLog);\n+    }\n+\n+    public void shutdownServer(String quitMsg) {\n+        if (!keepAcceptingRequests.compareAndSet(true, false)) {\n+            \/\/ Already stopped, no need to shut down again\n+            return;\n+        }\n+\n+        Log.debug(\"Quitting: \" + quitMsg);\n+\n+        portFileMonitor.shutdown(); \/\/ No longer any need to monitor port file\n+\n+        \/\/ Unpublish port before shutting down socket to minimize the number of\n+        \/\/ failed connection attempts\n+        try {\n+            portFile.delete();\n+        } catch (IOException | InterruptedException e) {\n+            Log.error(e);\n+        }\n+        try {\n+            serverSocket.close();\n+        } catch (IOException e) {\n+            Log.error(e);\n+        }\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/server\/Server.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"added"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.server;\n-\n-import java.io.IOException;\n-import java.io.PrintStream;\n-\n-import javacserver.Log;\n-import javacserver.Result;\n-import javacserver.server.log.LazyInitFileLog;\n-import javacserver.server.log.LoggingOutputStream;\n-\n-import static javacserver.Log.Level.ERROR;\n-import static javacserver.Log.Level.INFO;\n-\n-\/**\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class ServerMain {\n-\n-    \/\/ For logging server internal (non request specific) errors.\n-    private static LazyInitFileLog errorLog;\n-\n-    public static int run(String[] args) {\n-\n-        \/\/ Under normal operation, all logging messages generated server-side\n-        \/\/ are due to compilation requests. These logging messages should\n-        \/\/ be relayed back to the requesting client rather than written to the\n-        \/\/ server log. The only messages that should be written to the server\n-        \/\/ log (in production mode) should be errors,\n-        Log.setLogForCurrentThread(errorLog = new LazyInitFileLog(\"server.log\"));\n-        Log.setLogLevel(ERROR); \/\/ should be set to ERROR.\n-\n-        \/\/ Make sure no exceptions go under the radar\n-        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {\n-            Log.setLogForCurrentThread(errorLog);\n-            Log.error(e);\n-        });\n-\n-        \/\/ Inevitably someone will try to print messages using System.{out,err}.\n-        \/\/ Make sure this output also ends up in the log.\n-        System.setOut(new PrintStream(new LoggingOutputStream(System.out, INFO, \"[stdout] \")));\n-        System.setErr(new PrintStream(new LoggingOutputStream(System.err, ERROR, \"[stderr] \")));\n-\n-        \/\/ Any options other than --startserver?\n-        if (args.length > 1) {\n-            Log.error(\"When spawning a background server, only a single --startserver argument is allowed.\");\n-            return Result.CMDERR.exitCode;\n-        }\n-\n-        int exitCode;\n-        try {\n-            SjavacServer server = new SjavacServer(args[0]);\n-            exitCode = server.startServer();\n-        } catch (IOException | InterruptedException ex) {\n-            ex.printStackTrace();\n-            exitCode = Result.ERROR.exitCode;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    public static LazyInitFileLog getErrorLog() {\n-        return errorLog;\n-    }\n-}\n","filename":"make\/langtools\/tools\/javacserver\/server\/ServerMain.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.server;\n-\n-import javacserver.Result;\n-\n-\/**\n- * Interface of the SjavacImpl, the sjavac client and all wrappers such as\n- * PooledSjavac etc.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public interface Sjavac {\n-    Result compile(String[] args);\n-    void shutdown();\n-}\n","filename":"make\/langtools\/tools\/javacserver\/server\/Sjavac.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,248 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.server;\n-\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n-import java.net.SocketException;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Random;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-import javacserver.Log;\n-import javacserver.Result;\n-import javacserver.Util;\n-import javacserver.comp.PooledSjavac;\n-import javacserver.comp.SjavacImpl;\n-\n-\/**\n- * The JavacServer class contains methods both to setup a server that responds to requests and methods to connect to this server.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class SjavacServer implements Terminable {\n-\n-    \/\/ Prefix of line containing return code.\n-    public static final String LINE_TYPE_RC = \"RC\";\n-\n-    private final String portfilename;\n-    private final int poolsize;\n-    private final int keepalive;\n-\n-    \/\/ The secret cookie shared between server and client through the port file.\n-    \/\/ Used to prevent clients from believing that they are communicating with\n-    \/\/ an old server when a new server has started and reused the same port as\n-    \/\/ an old server.\n-    private final long myCookie;\n-\n-    \/\/ Accumulated build time, not counting idle time, used for logging purposes\n-    private long totalBuildTime;\n-\n-    \/\/ The sjavac implementation to delegate requests to\n-    Sjavac sjavac;\n-\n-    private ServerSocket serverSocket;\n-\n-    private PortFile portFile;\n-    private PortFileMonitor portFileMonitor;\n-\n-    \/\/ Set to false break accept loop\n-    final AtomicBoolean keepAcceptingRequests = new AtomicBoolean();\n-\n-    \/\/ For the client, all port files fetched, one per started javac server.\n-    \/\/ Though usually only one javac server is started by a client.\n-    private static Map<String, PortFile> allPortFiles;\n-\n-    public SjavacServer(String settings) throws FileNotFoundException {\n-        this(Util.extractStringOption(\"portfile\", settings),\n-             Util.extractIntOption(\"poolsize\", settings, Runtime.getRuntime().availableProcessors()),\n-             Util.extractIntOption(\"keepalive\", settings, 120));\n-    }\n-\n-    public SjavacServer(String portfilename,\n-                        int poolsize,\n-                        int keepalive)\n-                                throws FileNotFoundException {\n-        this.portfilename = portfilename;\n-        this.poolsize = poolsize;\n-        this.keepalive = keepalive;\n-        this.myCookie = new Random().nextLong();\n-    }\n-\n-\n-    \/**\n-     * Acquire the port file. Synchronized since several threads inside an smart javac wrapper client acquires the same port file at the same time.\n-     *\/\n-    public static synchronized PortFile getPortFile(String filename) {\n-        if (allPortFiles == null) {\n-            allPortFiles = new HashMap<>();\n-        }\n-        PortFile pf = allPortFiles.get(filename);\n-\n-        \/\/ Port file known. Does it still exist?\n-        if (pf != null) {\n-            try {\n-                if (!pf.exists())\n-                    pf = null;\n-            } catch (IOException ioex) {\n-                ioex.printStackTrace();\n-            }\n-        }\n-\n-        if (pf == null) {\n-            pf = new PortFile(filename);\n-            allPortFiles.put(filename, pf);\n-        }\n-        return pf;\n-    }\n-\n-    \/**\n-     * Get the cookie used for this server.\n-     *\/\n-    long getCookie() {\n-        return myCookie;\n-    }\n-\n-    \/**\n-     * Get the port used for this server.\n-     *\/\n-    int getPort() {\n-        return serverSocket.getLocalPort();\n-    }\n-\n-    \/**\n-     * Sum up the total build time for this javac server.\n-     *\/\n-    public void addBuildTime(long inc) {\n-        totalBuildTime += inc;\n-    }\n-\n-    \/**\n-     * Start a server using a settings string. Typically: \"--startserver:portfile=\/tmp\/myserver,poolsize=3\" and the string \"portfile=\/tmp\/myserver,poolsize=3\"\n-     * is sent as the settings parameter. Returns 0 on success, -1 on failure.\n-     *\/\n-    public int startServer() throws IOException, InterruptedException {\n-        long serverStart = System.currentTimeMillis();\n-\n-        \/\/ The port file is locked and the server port and cookie is written into it.\n-        portFile = getPortFile(portfilename);\n-\n-        synchronized (portFile) {\n-            portFile.lock();\n-            portFile.getValues();\n-            if (portFile.containsPortInfo()) {\n-                Log.debug(\"Javac server not started because portfile exists!\");\n-                portFile.unlock();\n-                return Result.ERROR.exitCode;\n-            }\n-\n-            \/\/           .-----------.   .--------.   .------.\n-            \/\/ socket -->| IdleReset |-->| Pooled |-->| Impl |--> javac\n-            \/\/           '-----------'   '--------'   '------'\n-            sjavac = new SjavacImpl();\n-            sjavac = new PooledSjavac(sjavac, poolsize);\n-            sjavac = new IdleResetSjavac(sjavac,\n-                                         this,\n-                                         keepalive * 1000);\n-\n-            serverSocket = new ServerSocket();\n-            InetAddress localhost = InetAddress.getByName(null);\n-            serverSocket.bind(new InetSocketAddress(localhost, 0));\n-\n-            \/\/ At this point the server accepts connections, so it is  now safe\n-            \/\/ to publish the port \/ cookie information\n-            portFile.setValues(getPort(), getCookie());\n-            portFile.unlock();\n-        }\n-\n-        portFileMonitor = new PortFileMonitor(portFile, this);\n-        portFileMonitor.start();\n-\n-        Log.debug(\"Sjavac server started. Accepting connections...\");\n-        Log.debug(\"    port: \" + getPort());\n-        Log.debug(\"    time: \" + new java.util.Date());\n-        Log.debug(\"    poolsize: \" + poolsize);\n-\n-\n-        keepAcceptingRequests.set(true);\n-        do {\n-            try {\n-                Socket socket = serverSocket.accept();\n-                new RequestHandler(socket, sjavac).start();\n-            } catch (SocketException se) {\n-                \/\/ Caused by serverSocket.close() and indicates shutdown\n-            }\n-        } while (keepAcceptingRequests.get());\n-\n-        Log.debug(\"Shutting down.\");\n-\n-        \/\/ No more connections accepted. If any client managed to connect after\n-        \/\/ the accept() was interrupted but before the server socket is closed\n-        \/\/ here, any attempt to read or write to the socket will result in an\n-        \/\/ IOException on the client side.\n-\n-        long realTime = System.currentTimeMillis() - serverStart;\n-        Log.debug(\"Total wall clock time \" + realTime + \"ms build time \" + totalBuildTime + \"ms\");\n-\n-        \/\/ Shut down\n-        sjavac.shutdown();\n-\n-        return Result.OK.exitCode;\n-    }\n-\n-    @Override\n-    public void shutdown(String quitMsg) {\n-        if (!keepAcceptingRequests.compareAndSet(true, false)) {\n-            \/\/ Already stopped, no need to shut down again\n-            return;\n-        }\n-\n-        Log.debug(\"Quitting: \" + quitMsg);\n-\n-        portFileMonitor.shutdown(); \/\/ No longer any need to monitor port file\n-\n-        \/\/ Unpublish port before shutting down socket to minimize the number of\n-        \/\/ failed connection attempts\n-        try {\n-            portFile.delete();\n-        } catch (IOException | InterruptedException e) {\n-            Log.error(e);\n-        }\n-        try {\n-            serverSocket.close();\n-        } catch (IOException e) {\n-            Log.error(e);\n-        }\n-    }\n-}\n","filename":"make\/langtools\/tools\/javacserver\/server\/SjavacServer.java","additions":0,"deletions":248,"binary":false,"changes":248,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javacserver.server;\n-\n-\/**\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public interface Terminable {\n-    void shutdown(String quitMsg);\n-}\n","filename":"make\/langtools\/tools\/javacserver\/server\/Terminable.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -26,1 +26,1 @@\n-package javacserver.server;\n+package javacserver.shared;\n@@ -37,3 +37,1 @@\n-\n-import javacserver.Log;\n-import javacserver.client.PortFileInaccessibleException;\n+import javacserver.util.Log;\n@@ -45,6 +43,1 @@\n- * system locking is not always supported on a all operating systems and\/or file systems.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n+ * system locking is not always supported on all operating systems and\/or file systems.\n@@ -53,1 +46,0 @@\n-\n@@ -228,0 +220,13 @@\n+    public boolean hasValidValues() throws IOException, InterruptedException {\n+        if (exists()) {\n+            lock();\n+            getValues();\n+            unlock();\n+\n+            if (containsPortInfo()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n@@ -280,1 +285,1 @@\n-                \/\/ The channel has been closed since sjavac is exiting.\n+                \/\/ The channel has been closed since the server is exiting.\n","filename":"make\/langtools\/tools\/javacserver\/shared\/PortFile.java","additions":17,"deletions":12,"binary":false,"changes":29,"previous_filename":"make\/langtools\/tools\/javacserver\/server\/PortFile.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package javacserver.client;\n+package javacserver.shared;\n","filename":"make\/langtools\/tools\/javacserver\/shared\/PortFileInaccessibleException.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"make\/langtools\/tools\/javacserver\/client\/PortFileInaccessibleException.java","status":"renamed"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.shared;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import javacserver.util.Log;\n+import javacserver.util.Util;\n+\n+\/**\n+ * Implementation of the wire protocol used by the javacserver client and daemon to communicate.\n+ * Basically, the client sends the argument to javac, one line per string. The server responds\n+ * with log lines (if there is any output), and the exit code from javac.\n+ *\/\n+public class Protocol {\n+    \/\/ Prefix of line containing return code.\n+    private static final String LINE_TYPE_RC = \"RC\";\n+\n+    public static void sendCommand(PrintWriter out, String[] args) throws IOException {\n+        \/\/ Send args array to server\n+        out.println(args.length);\n+        for (String arg : args)\n+            out.println(arg);\n+        out.flush();\n+    }\n+\n+    public static String[] readCommand(BufferedReader in) throws IOException {\n+        \/\/ Read argument array\n+        int n = Integer.parseInt(in.readLine());\n+        String[] args = new String[n];\n+        for (int i = 0; i < n; i++) {\n+            args[i] = in.readLine();\n+        }\n+        return args;\n+    }\n+\n+    public static void sendExitCode(PrintWriter out, int exitCode) {\n+        \/\/ Send return code back to client\n+        out.println(LINE_TYPE_RC + \":\" + exitCode);\n+    }\n+\n+    public static int readResponse(BufferedReader in) throws IOException {\n+        \/\/ Read server response line by line\n+        String line;\n+        while (null != (line = in.readLine())) {\n+            Line parsedLine = new Line(line);\n+\n+            try {\n+                String content = parsedLine.getContent();\n+                if (Log.isDebugging()) {\n+                    \/\/ Distinguish server generated output if debugging.\n+                    content = \"[javacserver] \" + content;\n+                }\n+                Log.log(Log.Level.valueOf(parsedLine.getType()), content);\n+                continue;\n+            } catch (IllegalArgumentException e) {\n+                \/\/ Parsing of 'type' as log level failed.\n+            }\n+\n+            if (parsedLine.isExitCode()) {\n+                return parsedLine.getExitCode();\n+            }\n+        }\n+        \/\/ No exit code was found.\n+        return Result.ERROR.exitCode;\n+    }\n+\n+    public static class Line {\n+        private final String type;\n+\n+        public String getType() {\n+            return type;\n+        }\n+\n+        public String getContent() {\n+            return content;\n+        }\n+\n+        public boolean isExitCode() {\n+            return type.equals(LINE_TYPE_RC);\n+        }\n+\n+        public int getExitCode() {\n+            return Integer.parseInt(content);\n+        }\n+\n+        private final String content;\n+\n+        public Line(String line) {\n+            if (!line.contains(\":\")) {\n+                throw new AssertionError(\"Could not parse protocol line: >>\\\"\" + line + \"\\\"<<\");\n+            }\n+            String[] typeAndContent = line.split(\":\", 2);\n+            type = typeAndContent[0];\n+            content = typeAndContent[1];\n+        }\n+    }\n+\n+    public static class ProtocolLog extends Log {\n+        public ProtocolLog(PrintWriter out) {\n+            super(out, out);\n+        }\n+\n+        @Override\n+        protected boolean isLevelLogged(Level l) {\n+            \/\/ Make sure it is up to the client to decide whether or\n+            \/\/ not this message should be displayed.\n+            return true;\n+        }\n+\n+        @Override\n+        protected void printLogMsg(Level msgLevel, String msg) {\n+            \/\/ Follow the server\/client protocol: Send one line\n+            \/\/ at a time and prefix with message with \"level:\".\n+            Util.getLines(msg)\n+                .map(line -> msgLevel + \":\" + line)\n+                .forEach(line -> super.printLogMsg(msgLevel, line));\n+        }\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/shared\/Protocol.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.shared;\n+\n+\/**\n+ * Result codes.\n+ *\/\n+public enum Result {\n+    OK(0),        \/\/ Compilation completed with no errors.\n+    ERROR(1),     \/\/ Completed but reported errors.\n+    CMDERR(2);    \/\/ Bad command-line arguments\n+\n+    public final int exitCode;\n+\n+    Result(int exitCode) {\n+        this.exitCode = exitCode;\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/shared\/Result.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package javacserver;\n+package javacserver.util;\n@@ -33,1 +33,0 @@\n-\n","filename":"make\/langtools\/tools\/javacserver\/util\/AutoFlushWriter.java","additions":1,"deletions":2,"binary":false,"changes":3,"previous_filename":"make\/langtools\/tools\/javacserver\/AutoFlushWriter.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package javacserver.server.log;\n+package javacserver.util;\n@@ -35,2 +35,0 @@\n-import javacserver.Log;\n-\n@@ -38,1 +36,0 @@\n-\n","filename":"make\/langtools\/tools\/javacserver\/util\/LazyInitFileLog.java","additions":1,"deletions":4,"binary":false,"changes":5,"previous_filename":"make\/langtools\/tools\/javacserver\/server\/log\/LazyInitFileLog.java","status":"renamed"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.util;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+\n+\/**\n+ * Utility class only for javacserver logging.\n+ *\n+ * Logging in javacserver has special requirements when running in server\/client\n+ * mode. Most of the log messages is generated server-side, but the server\n+ * is typically spawned by the client in the background, so the user usually\n+ * does not see the server stdout\/stderr. For this reason log messages needs\n+ * to relayed back to the client that performed the request that generated the\n+ * log message. To support this use case this class maintains a per-thread log\n+ * instance so that each connected client can have its own instance that\n+ * relays messages back to the requesting client.\n+ *\n+ * On the client-side there will typically just be one Log instance.\n+ *\/\n+public class Log {\n+    public enum Level {\n+        ERROR,\n+        WARN,\n+        INFO,\n+        DEBUG,\n+        TRACE;\n+    }\n+\n+    private static Log stdOutErr = new Log(new PrintWriter(System.out), new PrintWriter(System.err));\n+    private static ThreadLocal<Log> logger = new ThreadLocal<>();\n+\n+    protected PrintWriter err; \/\/ Used for error and warning messages\n+    protected PrintWriter out; \/\/ Used for other messages\n+    protected Level level = Level.INFO;\n+\n+    public Log(Writer out, Writer err) {\n+        this.out = out == null ? null : new PrintWriter(out, true);\n+        this.err = err == null ? null : new PrintWriter(err, true);\n+    }\n+\n+    public static void setLogForCurrentThread(Log log) {\n+        logger.set(log);\n+    }\n+\n+    public static void setLogLevel(Level l) {\n+        get().level = l;\n+    }\n+\n+    public static void debug(String msg) {\n+        log(Level.DEBUG, msg);\n+    }\n+\n+    public static void debug(Throwable t) {\n+        log(Level.DEBUG, t);\n+    }\n+\n+    public static void error(String msg) {\n+        log(Level.ERROR, msg);\n+    }\n+\n+    public static void error(Throwable t) {\n+        log(Level.ERROR, t);\n+    }\n+\n+    public static void log(Level l, String msg) {\n+        get().printLogMsg(l, msg);\n+    }\n+\n+    public static void log(Level l, Throwable t) {\n+        StringWriter sw = new StringWriter();\n+        t.printStackTrace(new PrintWriter(sw, true));\n+        log(l, sw.toString());\n+    }\n+\n+    public static boolean isDebugging() {\n+        return get().isLevelLogged(Level.DEBUG);\n+    }\n+\n+    protected boolean isLevelLogged(Level l) {\n+        return l.ordinal() <= level.ordinal();\n+    }\n+\n+    public static Log get() {\n+        Log log = logger.get();\n+        return log != null ? log : stdOutErr;\n+    }\n+\n+    protected void printLogMsg(Level msgLevel, String msg) {\n+        if (isLevelLogged(msgLevel)) {\n+            PrintWriter pw = msgLevel.ordinal() <= Level.WARN.ordinal() ? err : out;\n+            pw.println(msg);\n+        }\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/util\/Log.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package javacserver.server.log;\n+package javacserver.util;\n@@ -33,2 +33,0 @@\n-import javacserver.Log;\n-\n@@ -36,1 +34,0 @@\n-\n","filename":"make\/langtools\/tools\/javacserver\/util\/LoggingOutputStream.java","additions":1,"deletions":4,"binary":false,"changes":5,"previous_filename":"make\/langtools\/tools\/javacserver\/server\/log\/LoggingOutputStream.java","status":"renamed"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.util;\n+\n+import java.util.TimerTask;\n+\n+\/**\n+ * Wrapper class since TimerTask is not up to modern standards\n+ *\/\n+public class RunnableTimerTask extends TimerTask {\n+    private final Runnable task;\n+\n+    public RunnableTimerTask(Runnable task) {\n+        this.task = task;\n+    }\n+\n+    @Override\n+    public void run() {\n+        task.run();\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/util\/RunnableTimerTask.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.util;\n+\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+public class Util {\n+    \/**\n+     * Return a stream of strings, where the input string is split at line separators.\n+     *\/\n+    public static Stream<String> getLines(String str) {\n+        return str.isEmpty()\n+                ? Stream.empty()\n+                : Stream.of(str.split(Pattern.quote(System.lineSeparator())));\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/util\/Util.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -3380,1 +3380,2 @@\n-        if (con < (address)(uintptr_t)os::vm_page_size()) {\n+        if (! __ is_valid_AArch64_address(con) ||\n+            con < (address)(uintptr_t)os::vm_page_size()) {\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1371,0 +1371,24 @@\n+\/\/ vector eor3 (unpredicated)\n+\n+instruct veor3_neon(vReg dst, vReg src1, vReg src2, vReg src3) %{\n+  predicate(VM_Version::supports_sha3() &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (XorV src1 (XorV src2 src3)));\n+  format %{ \"veor3_neon $dst, $src1, $src2, $src3\" %}\n+  ins_encode %{\n+    __ eor3($dst$$FloatRegister, __ T16B, $src1$$FloatRegister,\n+            $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct veor3_sve(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseSVE == 2 && !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (XorV dst_src1 (XorV src2 src3)));\n+  format %{ \"veor3_sve $dst_src1, $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    __ sve_eor3($dst_src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -698,0 +698,24 @@\n+\/\/ vector eor3 (unpredicated)\n+\n+instruct veor3_neon(vReg dst, vReg src1, vReg src2, vReg src3) %{\n+  predicate(VM_Version::supports_sha3() &&\n+            VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (XorV src1 (XorV src2 src3)));\n+  format %{ \"veor3_neon $dst, $src1, $src2, $src3\" %}\n+  ins_encode %{\n+    __ eor3($dst$$FloatRegister, __ T16B, $src1$$FloatRegister,\n+            $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct veor3_sve(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseSVE == 2 && !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (XorV dst_src1 (XorV src2 src3)));\n+  format %{ \"veor3_sve $dst_src1, $dst_src1, $src2, $src3\" %}\n+  ins_encode %{\n+    __ sve_eor3($dst_src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -129,3 +129,0 @@\n-  Relocation* reloc = _rspec.reloc();\n-  relocInfo::relocType rtype = (relocInfo::relocType) reloc->type();\n-\n@@ -134,1 +131,1 @@\n-    if (_offset == 0 && _base == r) \/\/ it's a nop\n+    if (offset() == 0 && base() == r) \/\/ it's a nop\n@@ -136,2 +133,2 @@\n-    if (_offset > 0)\n-      __ add(r, _base, _offset);\n+    if (offset() > 0)\n+      __ add(r, base(), offset());\n@@ -139,1 +136,1 @@\n-      __ sub(r, _base, -_offset);\n+      __ sub(r, base(), -offset());\n@@ -143,1 +140,1 @@\n-    __ add(r, _base, _index, _ext.op(), MAX2(_ext.shift(), 0));\n+    __ add(r, base(), index(), ext().op(), MAX2(ext().shift(), 0));\n@@ -147,1 +144,2 @@\n-    if (rtype == relocInfo::none)\n+    as->code_section()->relocate(as->inst_mark(), rspec());\n+    if (rspec().type() == relocInfo::none)\n@@ -240,2 +238,14 @@\n-Address::Address(address target, relocInfo::relocType rtype) : _mode(literal){\n-  _target = target;\n+#ifdef ASSERT\n+\n+void Address::assert_is_literal() const {\n+  assert(_mode == literal, \"addressing mode is non-literal: %d\", _mode);\n+}\n+\n+void Address::assert_is_nonliteral() const {\n+  assert(_mode != literal, \"unexpected literal addressing mode\");\n+  assert(_mode != no_mode, \"unexpected no_mode addressing mode\");\n+}\n+\n+#endif \/\/ ASSERT\n+\n+static RelocationHolder address_relocation(address target, relocInfo::relocType rtype) {\n@@ -249,1 +259,1 @@\n-    break;\n+    return RelocationHolder::none;\n@@ -251,2 +261,1 @@\n-    _rspec = external_word_Relocation::spec(target);\n-    break;\n+    return external_word_Relocation::spec(target);\n@@ -254,2 +263,1 @@\n-    _rspec = internal_word_Relocation::spec(target);\n-    break;\n+    return internal_word_Relocation::spec(target);\n@@ -257,2 +265,1 @@\n-    _rspec = opt_virtual_call_Relocation::spec();\n-    break;\n+    return opt_virtual_call_Relocation::spec();\n@@ -260,2 +267,1 @@\n-    _rspec = static_call_Relocation::spec();\n-    break;\n+    return static_call_Relocation::spec();\n@@ -263,2 +269,1 @@\n-    _rspec = runtime_call_Relocation::spec();\n-    break;\n+    return runtime_call_Relocation::spec();\n@@ -267,2 +272,1 @@\n-    _rspec = Relocation::spec_simple(rtype);\n-    break;\n+    return Relocation::spec_simple(rtype);\n@@ -270,2 +274,1 @@\n-    _rspec = RelocationHolder::none;\n-    break;\n+    return RelocationHolder::none;\n@@ -274,1 +277,1 @@\n-    break;\n+    return RelocationHolder::none;\n@@ -278,0 +281,5 @@\n+Address::Address(address target, relocInfo::relocType rtype) :\n+  _mode(literal),\n+  _literal(target, address_relocation(target, rtype))\n+{}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":35,"deletions":27,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include <type_traits>\n@@ -361,5 +365,12 @@\n-  Register _base;\n-  Register _index;\n-  int64_t _offset;\n-  enum mode _mode;\n-  extend _ext;\n+  struct Nonliteral {\n+    Nonliteral(Register base, Register index, int64_t offset, extend ext = extend())\n+      : _base(base), _index(index), _offset(offset), _ext(ext) {}\n+    Register _base;\n+    Register _index;\n+    int64_t _offset;\n+    extend _ext;\n+  };\n+\n+  struct Literal {\n+    Literal(address target, const RelocationHolder& rspec)\n+      : _target(target), _rspec(rspec) {}\n@@ -367,1 +378,4 @@\n-  RelocationHolder _rspec;\n+    \/\/ If the target is far we'll need to load the ea of this to a\n+    \/\/ register to reach it. Otherwise if near we can do PC-relative\n+    \/\/ addressing.\n+    address _target;\n@@ -369,4 +383,27 @@\n-  \/\/ If the target is far we'll need to load the ea of this to a\n-  \/\/ register to reach it. Otherwise if near we can do PC-relative\n-  \/\/ addressing.\n-  address          _target;\n+    RelocationHolder _rspec;\n+  };\n+\n+  void assert_is_nonliteral() const NOT_DEBUG_RETURN;\n+  void assert_is_literal() const NOT_DEBUG_RETURN;\n+\n+  \/\/ Discriminated union, based on _mode.\n+  \/\/ - no_mode: uses dummy _nonliteral, for ease of copying.\n+  \/\/ - literal: only _literal is used.\n+  \/\/ - others: only _nonliteral is used.\n+  enum mode _mode;\n+  union {\n+    Nonliteral _nonliteral;\n+    Literal _literal;\n+  };\n+\n+  \/\/ Helper for copy constructor and assignment operator.\n+  \/\/ Copy mode-relevant part of a into this.\n+  void copy_data(const Address& a) {\n+    assert(_mode == a._mode, \"precondition\");\n+    if (_mode == literal) {\n+      new (&_literal) Literal(a._literal);\n+    } else {\n+      \/\/ non-literal mode or no_mode.\n+      new (&_nonliteral) Nonliteral(a._nonliteral);\n+    }\n+  }\n@@ -375,4 +412,10 @@\n-  Address()\n-    : _mode(no_mode) { }\n-  Address(Register r)\n-    : _base(r), _index(noreg), _offset(0), _mode(base_plus_offset), _target(0) { }\n+  \/\/ no_mode initializes _nonliteral for ease of copying.\n+  Address() :\n+    _mode(no_mode),\n+    _nonliteral(noreg, noreg, 0)\n+  {}\n+\n+  Address(Register r) :\n+    _mode(base_plus_offset),\n+    _nonliteral(r, noreg, 0)\n+  {}\n@@ -381,17 +424,27 @@\n-  Address(Register r, T o)\n-    : _base(r), _index(noreg), _offset(o), _mode(base_plus_offset), _target(0) {}\n-\n-  Address(Register r, ByteSize disp)\n-    : Address(r, in_bytes(disp)) { }\n-  Address(Register r, Register r1, extend ext = lsl())\n-    : _base(r), _index(r1), _offset(0), _mode(base_plus_offset_reg),\n-      _ext(ext), _target(0) { }\n-  Address(Pre p)\n-    : _base(p.reg()), _offset(p.offset()), _mode(pre) { }\n-  Address(Post p)\n-    : _base(p.reg()),  _index(p.idx_reg()), _offset(p.offset()),\n-      _mode(p.is_postreg() ? post_reg : post), _target(0) { }\n-  Address(address target, RelocationHolder const& rspec)\n-    : _mode(literal),\n-      _rspec(rspec),\n-      _target(target)  { }\n+  Address(Register r, T o) :\n+    _mode(base_plus_offset),\n+    _nonliteral(r, noreg, o)\n+  {}\n+\n+  Address(Register r, ByteSize disp) : Address(r, in_bytes(disp)) {}\n+\n+  Address(Register r, Register r1, extend ext = lsl()) :\n+    _mode(base_plus_offset_reg),\n+    _nonliteral(r, r1, 0, ext)\n+  {}\n+\n+  Address(Pre p) :\n+    _mode(pre),\n+    _nonliteral(p.reg(), noreg, p.offset())\n+  {}\n+\n+  Address(Post p) :\n+    _mode(p.is_postreg() ? post_reg : post),\n+    _nonliteral(p.reg(), p.idx_reg(), p.offset())\n+  {}\n+\n+  Address(address target, const RelocationHolder& rspec) :\n+    _mode(literal),\n+    _literal(target, rspec)\n+  {}\n+\n@@ -399,3 +452,2 @@\n-  Address(Register base, RegisterOrConstant index, extend ext = lsl())\n-    : _base (base),\n-      _offset(0), _ext(ext), _target(0) {\n+\n+  Address(Register base, RegisterOrConstant index, extend ext = lsl()) {\n@@ -404,1 +456,1 @@\n-      _index = index.as_register();\n+      new (&_nonliteral) Nonliteral(base, index.as_register(), 0, ext);\n@@ -409,1 +461,3 @@\n-      _offset = index.as_constant() << ext.shift();\n+      new (&_nonliteral) Nonliteral(base,\n+                                    noreg,\n+                                    index.as_constant() << ext.shift());\n@@ -413,0 +467,16 @@\n+  Address(const Address& a) : _mode(a._mode) { copy_data(a); }\n+\n+  \/\/ Verify the value is trivially destructible regardless of mode, so our\n+  \/\/ destructor can also be trivial, and so our assignment operator doesn't\n+  \/\/ need to destruct the old value before copying over it.\n+  static_assert(std::is_trivially_destructible<Literal>::value, \"must be\");\n+  static_assert(std::is_trivially_destructible<Nonliteral>::value, \"must be\");\n+\n+  Address& operator=(const Address& a) {\n+    _mode = a._mode;\n+    copy_data(a);\n+    return *this;\n+  }\n+\n+  ~Address() = default;\n+\n@@ -414,4 +484,2 @@\n-    guarantee((_mode == base_plus_offset || _mode == base_plus_offset_reg\n-               || _mode == post || _mode == post_reg),\n-              \"wrong mode\");\n-    return _base;\n+    assert_is_nonliteral();\n+    return _nonliteral._base;\n@@ -419,0 +487,1 @@\n+\n@@ -420,1 +489,2 @@\n-    return _offset;\n+    assert_is_nonliteral();\n+    return _nonliteral._offset;\n@@ -422,0 +492,1 @@\n+\n@@ -423,1 +494,7 @@\n-    return _index;\n+    assert_is_nonliteral();\n+    return _nonliteral._index;\n+  }\n+\n+  extend ext() const {\n+    assert_is_nonliteral();\n+    return _nonliteral._ext;\n@@ -425,0 +502,1 @@\n+\n@@ -428,3 +506,14 @@\n-  bool uses(Register reg) const { return _base == reg || _index == reg; }\n-  address target() const { return _target; }\n-  const RelocationHolder& rspec() const { return _rspec; }\n+\n+  bool uses(Register reg) const {\n+    return base() == reg || index() == reg;\n+  }\n+\n+  address target() const {\n+    assert_is_literal();\n+    return _literal._target;\n+  }\n+\n+  const RelocationHolder& rspec() const {\n+    assert_is_literal();\n+    return _literal._rspec;\n+  }\n@@ -434,1 +523,1 @@\n-    i->srf(_base, 5);\n+    i->srf(base(), 5);\n@@ -445,2 +534,2 @@\n-        assert(offset_ok_for_immed(_offset, size),\n-               \"must be, was: \" INT64_FORMAT \", %d\", _offset, size);\n+        assert(offset_ok_for_immed(offset(), size),\n+               \"must be, was: \" INT64_FORMAT \", %d\", offset(), size);\n@@ -448,1 +537,1 @@\n-        if (_offset < 0 || _offset & mask) {\n+        if (offset() < 0 || offset() & mask) {\n@@ -451,1 +540,1 @@\n-          i->sf(_offset, 20, 12);\n+          i->sf(offset(), 20, 12);\n@@ -454,1 +543,1 @@\n-          i->f(_offset >> size, 21, 10);\n+          i->f(offset() >> size, 21, 10);\n@@ -463,2 +552,2 @@\n-        i->rf(_index, 16);\n-        i->f(_ext.option(), 15, 13);\n+        i->rf(index(), 16);\n+        i->f(ext().option(), 15, 13);\n@@ -472,1 +561,1 @@\n-          i->f(_ext.shift() >= 0, 12);\n+          i->f(ext().shift() >= 0, 12);\n@@ -474,2 +563,2 @@\n-          assert(_ext.shift() <= 0 || _ext.shift() == (int)size, \"bad shift\");\n-          i->f(_ext.shift() > 0, 12);\n+          assert(ext().shift() <= 0 || ext().shift() == (int)size, \"bad shift\");\n+          i->f(ext().shift() > 0, 12);\n@@ -484,1 +573,1 @@\n-      i->sf(_offset, 20, 12);\n+      i->sf(offset(), 20, 12);\n@@ -490,1 +579,1 @@\n-      i->sf(_offset, 20, 12);\n+      i->sf(offset(), 20, 12);\n@@ -532,3 +621,3 @@\n-    guarantee(_offset % size == 0, \"bad offset\");\n-    i->sf(_offset \/ size, 21, 15);\n-    i->srf(_base, 5);\n+    guarantee(offset() % size == 0, \"bad offset\");\n+    i->sf(offset() \/ size, 21, 15);\n+    i->srf(base(), 5);\n@@ -538,1 +627,1 @@\n-    \/\/ Only base + offset is allowed\n+    guarantee(_mode == base_plus_offset, \"Bad addressing mode for nontemporal op\");\n@@ -542,5 +631,3 @@\n-    guarantee(_offset % size == 0, \"bad offset\");\n-    i->sf(_offset \/ size, 21, 15);\n-    i->srf(_base, 5);\n-    guarantee(_mode == Address::base_plus_offset,\n-              \"Bad addressing mode for non-temporal op\");\n+    guarantee(offset() % size == 0, \"bad offset\");\n+    i->sf(offset() \/ size, 21, 15);\n+    i->srf(base(), 5);\n@@ -2325,0 +2412,34 @@\n+  \/\/ Single-structure load\/store method (all addressing variants)\n+  void ld_st(FloatRegister Vt, SIMD_RegVariant T, int index, Address a,\n+             int op1, int op2, int regs) {\n+    int expectedImmediate = (regVariant_to_elemBits(T) >> 3) * regs;\n+    int sVal = (T < D) ? (index >> (2 - T)) & 0x01 : 0;\n+    int opcode = (T < D) ? (T << 2) : ((T & 0x02) << 2);\n+    int size = (T < D) ? (index & (0x3 << T)) : 1;  \/\/ only care about low 2b\n+    Register Xn = a.base();\n+    int Rm;\n+\n+    switch (a.getMode()) {\n+    case Address::base_plus_offset:\n+      guarantee(a.offset() == 0, \"no offset allowed here\");\n+      Rm = 0;\n+      break;\n+    case Address::post:\n+      guarantee(a.offset() == expectedImmediate, \"bad offset\");\n+      op1 |= 0b100;\n+      Rm = 0b11111;\n+      break;\n+    case Address::post_reg:\n+      op1 |= 0b100;\n+      Rm = a.index()->encoding();\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    starti;\n+    f(0,31), f((index >> (3 - T)), 30);\n+    f(op1, 29, 21), f(Rm, 20, 16), f(op2 | opcode | sVal, 15, 12);\n+    f(size, 11, 10), srf(Xn, 5), rf(Vt, 0);\n+  }\n+\n@@ -2382,0 +2503,60 @@\n+\/\/ Handle common single-structure ld\/st parameter sanity checks\n+\/\/ for all variations (1 to 4) of SIMD reigster inputs.  This\n+\/\/ method will call the routine that generates the opcode.\n+template<typename R, typename... Rx>\n+  void ldst_sstr(SIMD_RegVariant T, int index, const Address &a,\n+            int op1, int op2, R firstReg, Rx... otherRegs) {\n+    const FloatRegister vtSet[] = { firstReg, otherRegs... };\n+    const int regCount = sizeof...(otherRegs) + 1;\n+    assert(index >= 0 && (T <= D) && ((T == B && index <= 15) ||\n+              (T == H && index <= 7) || (T == S && index <= 3) ||\n+              (T == D && index <= 1)), \"invalid index\");\n+    assert(regCount >= 1 && regCount <= 4, \"illegal register count\");\n+\n+    \/\/ Check to make sure when multiple SIMD registers are used\n+    \/\/ that they are in successive order.\n+    for (int i = 0; i < regCount - 1; i++) {\n+      assert(vtSet[i]->successor() == vtSet[i + 1],\n+             \"Registers must be ordered\");\n+    }\n+\n+    ld_st(firstReg, T, index, a, op1, op2, regCount);\n+  }\n+\n+\/\/ Define a set of INSN1\/2\/3\/4 macros to handle single-structure\n+\/\/ load\/store instructions.\n+#define INSN1(NAME, op1, op2)                                           \\\n+  void NAME(FloatRegister Vt, SIMD_RegVariant T, int index,             \\\n+            const Address &a) {                                         \\\n+    ldst_sstr(T, index, a, op1, op2, Vt);                               \\\n+ }\n+\n+#define INSN2(NAME, op1, op2)                                           \\\n+  void NAME(FloatRegister Vt, FloatRegister Vt2, SIMD_RegVariant T,     \\\n+            int index, const Address &a) {                              \\\n+    ldst_sstr(T, index, a, op1, op2, Vt, Vt2);                          \\\n+  }\n+\n+#define INSN3(NAME, op1, op2)                                           \\\n+  void NAME(FloatRegister Vt, FloatRegister Vt2, FloatRegister Vt3,     \\\n+            SIMD_RegVariant T, int index, const Address &a) {           \\\n+    ldst_sstr(T, index, a, op1, op2, Vt, Vt2, Vt3);                     \\\n+  }\n+\n+#define INSN4(NAME, op1, op2)                                           \\\n+  void NAME(FloatRegister Vt, FloatRegister Vt2, FloatRegister Vt3,     \\\n+            FloatRegister Vt4, SIMD_RegVariant T, int index,            \\\n+            const Address &a) {                                         \\\n+    ldst_sstr(T, index, a, op1, op2, Vt, Vt2, Vt3, Vt4);                \\\n+  }\n+\n+  INSN1(st1, 0b001101000, 0b0000);\n+  INSN2(st2, 0b001101001, 0b0000);\n+  INSN3(st3, 0b001101000, 0b0010);\n+  INSN4(st4, 0b001101001, 0b0010);\n+\n+#undef INSN1\n+#undef INSN2\n+#undef INSN3\n+#undef INSN4\n+\n@@ -2752,0 +2933,1 @@\n+  INSN(sli,  1, 0b010101, \/* isSHR = *\/ false);\n@@ -3851,0 +4033,11 @@\n+\/\/ SVE2 bitwise ternary operations\n+#define INSN(NAME, opc)                                               \\\n+  void NAME(FloatRegister Zdn, FloatRegister Zm, FloatRegister Zk) {  \\\n+    starti;                                                           \\\n+    f(0b00000100, 31, 24), f(opc, 23, 21), rf(Zm, 16);                \\\n+    f(0b001110, 15, 10), rf(Zk, 5), rf(Zdn, 0);                       \\\n+  }\n+\n+  INSN(sve_eor3, 0b001); \/\/ Bitwise exclusive OR of three vectors\n+#undef INSN\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":260,"deletions":67,"binary":false,"changes":327,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_AARCH64_CONTINUATIONENTRY_AARCH64_HPP\n+#define CPU_AARCH64_CONTINUATIONENTRY_AARCH64_HPP\n+\n+class ContinuationEntryPD {\n+  \/\/ empty\n+};\n+\n+#endif \/\/ CPU_AARCH64_CONTINUATIONENTRY_AARCH64_HPP\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationEntry_aarch64.hpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -204,0 +204,6 @@\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::patch_caller_links(intptr_t* sp, intptr_t* bottom) {\n+  \/\/ Fast path depends on !PreserveFramePointer. See can_thaw_fast().\n+  assert(!PreserveFramePointer, \"Frame pointers need to be fixed\");\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -104,1 +104,2 @@\n-inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, intptr_t* sp) {\n+inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, const frame& caller) {\n+  intptr_t* sp = caller.unextended_sp();\n@@ -140,0 +141,4 @@\n+inline intptr_t* ContinuationHelper::InterpretedFrame::callers_sp(const frame& f) {\n+  return f.fp() + frame::metadata_words;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationHelper_aarch64.inline.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -104,0 +104,7 @@\n+    \/\/ size, in words, of metadata at frame bottom, i.e. it is not part of the\n+    \/\/ caller\/callee overlap\n+    metadata_words_at_bottom                         = metadata_words,\n+    \/\/ size, in words, of frame metadata at the frame top, i.e. it is located\n+    \/\/ between a callee frame and its stack arguments, where it is part\n+    \/\/ of the caller\/callee overlap\n+    metadata_words_at_top                            = 0,\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -116,1 +116,0 @@\n-    code_section()->relocate(inst_mark(), a.rspec());\n@@ -1181,1 +1180,1 @@\n-  \/\/ Check if branches to the the non nmethod section require a far jump\n+  \/\/ Check if branches to the non nmethod section require a far jump\n@@ -1453,0 +1452,7 @@\n+  \/\/ ChaCha20 functions support block\n+  void cc20_quarter_round(FloatRegister aVec, FloatRegister bVec,\n+          FloatRegister cVec, FloatRegister dVec, FloatRegister scratch,\n+          FloatRegister tbl);\n+  void cc20_shift_lane_org(FloatRegister bVec, FloatRegister cVec,\n+          FloatRegister dVec, bool colToDiag);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"asm\/assembler.hpp\"\n+#include \"asm\/assembler.inline.hpp\"\n+#include \"macroAssembler_aarch64.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+\n+\/**\n+ * Perform the quarter round calculations on values contained within\n+ * four SIMD registers.\n+ *\n+ * @param aVec the SIMD register containing only the \"a\" values\n+ * @param bVec the SIMD register containing only the \"b\" values\n+ * @param cVec the SIMD register containing only the \"c\" values\n+ * @param dVec the SIMD register containing only the \"d\" values\n+ * @param scratch scratch SIMD register used for 12 and 7 bit left rotations\n+ * @param table the SIMD register used as a table for 8 bit left rotations\n+ *\/\n+void MacroAssembler::cc20_quarter_round(FloatRegister aVec, FloatRegister bVec,\n+    FloatRegister cVec, FloatRegister dVec, FloatRegister scratch,\n+     FloatRegister table) {\n+\n+  \/\/ a += b, d ^= a, d <<<= 16\n+  addv(aVec, T4S, aVec, bVec);\n+  eor(dVec, T16B, dVec, aVec);\n+  rev32(dVec, T8H, dVec);\n+\n+  \/\/ c += d, b ^= c, b <<<= 12\n+  addv(cVec, T4S, cVec, dVec);\n+  eor(scratch, T16B, bVec, cVec);\n+  ushr(bVec, T4S, scratch, 20);\n+  sli(bVec, T4S, scratch, 12);\n+\n+  \/\/ a += b, d ^= a, d <<<= 8\n+  addv(aVec, T4S, aVec, bVec);\n+  eor(dVec, T16B, dVec, aVec);\n+  tbl(dVec, T16B, dVec,  1, table);\n+\n+  \/\/ c += d, b ^= c, b <<<= 7\n+  addv(cVec, T4S, cVec, dVec);\n+  eor(scratch, T16B, bVec, cVec);\n+  ushr(bVec, T4S, scratch, 25);\n+  sli(bVec, T4S, scratch, 7);\n+}\n+\n+\/**\n+ * Shift the b, c, and d vectors between columnar and diagonal representations.\n+ * Note that the \"a\" vector does not shift.\n+ *\n+ * @param bVec the SIMD register containing only the \"b\" values\n+ * @param cVec the SIMD register containing only the \"c\" values\n+ * @param dVec the SIMD register containing only the \"d\" values\n+ * @param colToDiag true if moving columnar to diagonal, false if\n+ *                  moving diagonal back to columnar.\n+ *\/\n+void MacroAssembler::cc20_shift_lane_org(FloatRegister bVec, FloatRegister cVec,\n+    FloatRegister dVec, bool colToDiag) {\n+  int bShift = colToDiag ? 4 : 12;\n+  int cShift = 8;\n+  int dShift = colToDiag ? 12 : 4;\n+\n+  ext(bVec, T16B, bVec, bVec, bShift);\n+  ext(cVec, T16B, cVec, cVec, cShift);\n+  ext(dVec, T16B, dVec, dVec, dShift);\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64_chacha.cpp","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -1001,1 +1001,0 @@\n-  ContinuationEntry::setup_oopmap(map);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4084,0 +4084,126 @@\n+  \/\/ ChaCha20 block function.  This version parallelizes by loading\n+  \/\/ individual 32-bit state elements into vectors for four blocks\n+  \/\/ (e.g. all four blocks' worth of state[0] in one register, etc.)\n+  \/\/\n+  \/\/ state (int[16]) = c_rarg0\n+  \/\/ keystream (byte[1024]) = c_rarg1\n+  \/\/ return - number of bytes of keystream (always 256)\n+  address generate_chacha20Block_blockpar() {\n+    Label L_twoRounds, L_cc20_const;\n+    \/\/ The constant data is broken into two 128-bit segments to be loaded\n+    \/\/ onto FloatRegisters.  The first 128 bits are a counter add overlay\n+    \/\/ that adds +0\/+1\/+2\/+3 to the vector holding replicated state[12].\n+    \/\/ The second 128-bits is a table constant used for 8-bit left rotations.\n+    __ BIND(L_cc20_const);\n+    __ emit_int64(0x0000000100000000UL);\n+    __ emit_int64(0x0000000300000002UL);\n+    __ emit_int64(0x0605040702010003UL);\n+    __ emit_int64(0x0E0D0C0F0A09080BUL);\n+\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"chacha20Block\");\n+    address start = __ pc();\n+    __ enter();\n+\n+    int i, j;\n+    const Register state = c_rarg0;\n+    const Register keystream = c_rarg1;\n+    const Register loopCtr = r10;\n+    const Register tmpAddr = r11;\n+\n+    const FloatRegister stateFirst = v0;\n+    const FloatRegister stateSecond = v1;\n+    const FloatRegister stateThird = v2;\n+    const FloatRegister stateFourth = v3;\n+    const FloatRegister origCtrState = v28;\n+    const FloatRegister scratch = v29;\n+    const FloatRegister lrot8Tbl = v30;\n+\n+    \/\/ Organize SIMD registers in an array that facilitates\n+    \/\/ putting repetitive opcodes into loop structures.  It is\n+    \/\/ important that each grouping of 4 registers is monotonically\n+    \/\/ increasing to support the requirements of multi-register\n+    \/\/ instructions (e.g. ld4r, st4, etc.)\n+    const FloatRegister workSt[16] = {\n+         v4,  v5,  v6,  v7, v16, v17, v18, v19,\n+        v20, v21, v22, v23, v24, v25, v26, v27\n+    };\n+\n+    \/\/ Load from memory and interlace across 16 SIMD registers,\n+    \/\/ With each word from memory being broadcast to all lanes of\n+    \/\/ each successive SIMD register.\n+    \/\/      Addr(0) -> All lanes in workSt[i]\n+    \/\/      Addr(4) -> All lanes workSt[i + 1], etc.\n+    __ mov(tmpAddr, state);\n+    for (i = 0; i < 16; i += 4) {\n+      __ ld4r(workSt[i], workSt[i + 1], workSt[i + 2], workSt[i + 3], __ T4S,\n+          __ post(tmpAddr, 16));\n+    }\n+\n+    \/\/ Pull in constant data.  The first 16 bytes are the add overlay\n+    \/\/ which is applied to the vector holding the counter (state[12]).\n+    \/\/ The second 16 bytes is the index register for the 8-bit left\n+    \/\/ rotation tbl instruction.\n+    __ adr(tmpAddr, L_cc20_const);\n+    __ ldpq(origCtrState, lrot8Tbl, Address(tmpAddr));\n+    __ addv(workSt[12], __ T4S, workSt[12], origCtrState);\n+\n+    \/\/ Set up the 10 iteration loop and perform all 8 quarter round ops\n+    __ mov(loopCtr, 10);\n+    __ BIND(L_twoRounds);\n+\n+    __ cc20_quarter_round(workSt[0], workSt[4], workSt[8], workSt[12],\n+        scratch, lrot8Tbl);\n+    __ cc20_quarter_round(workSt[1], workSt[5], workSt[9], workSt[13],\n+        scratch, lrot8Tbl);\n+    __ cc20_quarter_round(workSt[2], workSt[6], workSt[10], workSt[14],\n+        scratch, lrot8Tbl);\n+    __ cc20_quarter_round(workSt[3], workSt[7], workSt[11], workSt[15],\n+        scratch, lrot8Tbl);\n+\n+    __ cc20_quarter_round(workSt[0], workSt[5], workSt[10], workSt[15],\n+        scratch, lrot8Tbl);\n+    __ cc20_quarter_round(workSt[1], workSt[6], workSt[11], workSt[12],\n+        scratch, lrot8Tbl);\n+    __ cc20_quarter_round(workSt[2], workSt[7], workSt[8], workSt[13],\n+        scratch, lrot8Tbl);\n+    __ cc20_quarter_round(workSt[3], workSt[4], workSt[9], workSt[14],\n+        scratch, lrot8Tbl);\n+\n+    \/\/ Decrement and iterate\n+    __ sub(loopCtr, loopCtr, 1);\n+    __ cbnz(loopCtr, L_twoRounds);\n+\n+    __ mov(tmpAddr, state);\n+\n+    \/\/ Add the starting state back to the post-loop keystream\n+    \/\/ state.  We read\/interlace the state array from memory into\n+    \/\/ 4 registers similar to what we did in the beginning.  Then\n+    \/\/ add the counter overlay onto workSt[12] at the end.\n+    for (i = 0; i < 16; i += 4) {\n+      __ ld4r(stateFirst, stateSecond, stateThird, stateFourth, __ T4S,\n+          __ post(tmpAddr, 16));\n+      __ addv(workSt[i], __ T4S, workSt[i], stateFirst);\n+      __ addv(workSt[i + 1], __ T4S, workSt[i + 1], stateSecond);\n+      __ addv(workSt[i + 2], __ T4S, workSt[i + 2], stateThird);\n+      __ addv(workSt[i + 3], __ T4S, workSt[i + 3], stateFourth);\n+    }\n+    __ addv(workSt[12], __ T4S, workSt[12], origCtrState);    \/\/ Add ctr mask\n+\n+    \/\/ Write to key stream, storing the same element out of workSt[0..15]\n+    \/\/ to consecutive 4-byte offsets in the key stream buffer, then repeating\n+    \/\/ for the next element position.\n+    for (i = 0; i < 4; i++) {\n+      for (j = 0; j < 16; j += 4) {\n+        __ st4(workSt[j], workSt[j + 1], workSt[j + 2], workSt[j + 3], __ S, i,\n+            __ post(keystream, 16));\n+      }\n+    }\n+\n+    __ mov(r0, 256);             \/\/ Return length of output keystream\n+    __ leave();\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -7922,0 +8048,4 @@\n+    if (UseChaCha20Intrinsics) {\n+      StubRoutines::_chacha20Block = generate_chacha20Block_blockpar();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":130,"deletions":0,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -369,0 +369,11 @@\n+  if (_features & CPU_ASIMD) {\n+      if (FLAG_IS_DEFAULT(UseChaCha20Intrinsics)) {\n+          UseChaCha20Intrinsics = true;\n+      }\n+  } else if (UseChaCha20Intrinsics) {\n+      if (!FLAG_IS_DEFAULT(UseChaCha20Intrinsics)) {\n+          warning(\"ChaCha20 intrinsic requires ASIMD instructions\");\n+      }\n+      FLAG_SET_DEFAULT(UseChaCha20Intrinsics, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_ARM_CONTINUATIONENTRY_ARM_HPP\n+#define CPU_ARM_CONTINUATIONENTRY_ARM_HPP\n+\n+class ContinuationEntryPD {\n+  \/\/ empty\n+};\n+\n+#endif \/\/ CPU_ARM_CONTINUATIONENTRY_ARM_HPP\n","filename":"src\/hotspot\/cpu\/arm\/continuationEntry_arm.hpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -94,0 +94,5 @@\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::patch_caller_links(intptr_t* sp, intptr_t* bottom) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/continuationFreezeThaw_arm.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, intptr_t* sp) {\n+inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, const frame& caller) {\n@@ -125,0 +125,5 @@\n+inline intptr_t* ContinuationHelper::InterpretedFrame::callers_sp(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/continuationHelper_arm.inline.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -57,0 +57,7 @@\n+    \/\/ size, in words, of metadata at frame bottom, i.e. it is not part of the\n+    \/\/ caller\/callee overlap\n+    metadata_words_at_bottom                         = metadata_words,\n+    \/\/ size, in words, of frame metadata at the frame top, i.e. it is located\n+    \/\/ between a callee frame and its stack arguments, where it is part\n+    \/\/ of the caller\/callee overlap\n+    metadata_words_at_top                            = 0,\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -144,2 +144,2 @@\n-    n_int_register_parameters_j = 8,\n-    n_float_register_parameters_j = 13\n+    n_int_register_parameters_j   = 8,  \/\/ duplicates num_java_iarg_registers\n+    n_float_register_parameters_j = 13, \/\/ num_java_farg_registers\n@@ -1375,1 +1375,1 @@\n-  static inline bool is_illtrap(int x);\n+  static inline bool is_illtrap(address instr_addr);\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-inline bool Assembler::is_illtrap(int x) { return x == 0; }\n+inline bool Assembler::is_illtrap(address instr_addr) { return *(uint32_t*)instr_addr == 0u; }\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -668,0 +668,1 @@\n+  __ post_call_nop();\n@@ -695,0 +696,1 @@\n+  __ post_call_nop();\n@@ -2879,0 +2881,1 @@\n+    __ post_call_nop();\n@@ -2886,0 +2889,1 @@\n+  __ post_call_nop();\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -152,0 +152,2 @@\n+\n+  inc_held_monitor_count(Rmark \/*tmp*\/);\n@@ -163,1 +165,1 @@\n-  \/\/ Test first it it is a fast recursive unlock.\n+  \/\/ Test first if it is a fast recursive unlock.\n@@ -189,0 +191,2 @@\n+\n+  dec_held_monitor_count(Rmark \/*tmp*\/);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_PPC_CONTINUATIONENTRY_PPC_HPP\n+#define CPU_PPC_CONTINUATIONENTRY_PPC_HPP\n+\n+#include \"runtime\/frame.hpp\"\n+\n+class ContinuationEntryPD {\n+  \/\/ This is needed to position the ContinuationEntry at the unextended sp of the entry frame\n+  frame::abi_reg_args _abi;\n+};\n+\n+#endif \/\/ CPU_PPC_CONTINUATIONENTRY_PPC_HPP\n","filename":"src\/hotspot\/cpu\/ppc\/continuationEntry_ppc.hpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -30,1 +30,4 @@\n-\/\/ TODO: Implement\n+#include \"oops\/method.inline.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+#include \"utilities\/macros.hpp\"\n@@ -33,2 +36,4 @@\n-  Unimplemented();\n-  return frame();\n+  static CodeBlob* cb = CodeCache::find_blob_fast(entry_pc());\n+  assert(cb != nullptr, \"\");\n+  assert(cb->as_compiled_method()->method()->is_continuation_enter_intrinsic(), \"\");\n+  return frame(entry_sp(), entry_pc(), entry_sp(), entry_fp(), cb);\n@@ -38,2 +43,1 @@\n-  Unimplemented();\n-  return nullptr;\n+  return (intptr_t*)((address)this + size());\n@@ -43,1 +47,1 @@\n-  Unimplemented();\n+\/\/ Nothing to do (no non-volatile registers in java calling convention)\n","filename":"src\/hotspot\/cpu\/ppc\/continuationEntry_ppc.inline.hpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,0 +32,3 @@\n+inline void patch_callee_link(const frame& f, intptr_t* fp) {\n+  *ContinuationHelper::Frame::callee_link_address(f) = fp;\n+}\n@@ -33,2 +36,12 @@\n-inline void FreezeBase::set_top_frame_metadata_pd(const frame& hf) {\n-  Unimplemented();\n+inline void patch_callee_link_relative(const frame& f, intptr_t* fp) {\n+  intptr_t* la = (intptr_t*)ContinuationHelper::Frame::callee_link_address(f);\n+  intptr_t new_value = fp - la;\n+  *la = new_value;\n+}\n+\n+\/\/\/\/\/\/ Freeze\n+\n+\/\/ Fast path\n+\n+inline void FreezeBase::patch_stack_pd(intptr_t* frame_sp, intptr_t* heap_sp) {\n+  \/\/ Nothing to do. The backchain is reconstructed when thawing (see Thaw<ConfigT>::patch_caller_links())\n@@ -37,0 +50,2 @@\n+\/\/ Slow path\n+\n@@ -39,3 +54,8 @@\n-  Unimplemented();\n-  return frame();\n-}\n+  assert(FKind::is_instance(f), \"\");\n+  if (FKind::interpreted) {\n+    return frame(f.sender_sp(), f.sender_pc(), f.interpreter_frame_sender_sp());\n+  }\n+\n+  intptr_t* sender_sp = f.sender_sp();\n+  address sender_pc = f.sender_pc();\n+  assert(sender_sp != f.sp(), \"must have changed\");\n@@ -43,3 +63,5 @@\n-template<typename FKind> frame FreezeBase::new_heap_frame(frame& f, frame& caller) {\n-  Unimplemented();\n-  return frame();\n+  int slot = 0;\n+  CodeBlob* sender_cb = CodeCache::find_blob_and_oopmap(sender_pc, slot);\n+  return sender_cb != nullptr\n+    ? frame(sender_sp, sender_sp, nullptr, sender_pc, sender_cb, slot == -1 ? nullptr : sender_cb->oop_map_for_slot(slot, sender_pc))\n+    : frame(sender_sp, sender_pc, sender_sp);\n@@ -49,1 +71,8 @@\n-  Unimplemented();\n+  \/\/ nothing to do\n+}\n+\n+static inline void relativize_one(intptr_t* const vfp, intptr_t* const hfp, int offset) {\n+  assert(*(hfp + offset) == *(vfp + offset), \"\");\n+  intptr_t* addr = hfp + offset;\n+  intptr_t value = *(intptr_t**)addr - vfp;\n+  *addr = value;\n@@ -53,1 +82,225 @@\n-  Unimplemented();\n+  intptr_t* vfp = f.fp();\n+  intptr_t* hfp = hf.fp();\n+  assert(f.fp() > (intptr_t*)f.interpreter_frame_esp(), \"\");\n+\n+  \/\/ There is alignment padding between vfp and f's locals array in the original\n+  \/\/ frame, therefore we cannot use it to relativize the locals pointer.\n+  *hf.addr_at(ijava_idx(locals)) = frame::metadata_words + f.interpreter_frame_method()->max_locals() - 1;\n+  relativize_one(vfp, hfp, ijava_idx(monitors));\n+  relativize_one(vfp, hfp, ijava_idx(esp));\n+  relativize_one(vfp, hfp, ijava_idx(top_frame_sp));\n+\n+  \/\/ hfp == hf.sp() + (f.fp() - f.sp()) is not true on ppc because the stack frame has room for\n+  \/\/ the maximal expression stack and the expression stack in the heap frame is trimmed.\n+  assert(hf.fp() == hf.interpreter_frame_esp() + (f.fp() - f.interpreter_frame_esp()), \"\");\n+  assert(hf.fp()                 <= (intptr_t*)hf.at(ijava_idx(locals)), \"\");\n+}\n+\n+inline void FreezeBase::set_top_frame_metadata_pd(const frame& hf) {\n+  stackChunkOop chunk = _cont.tail();\n+  assert(chunk->is_in_chunk(hf.sp()), \"hf.sp()=\" PTR_FORMAT, p2i(hf.sp()));\n+\n+  hf.own_abi()->lr = (uint64_t)hf.pc();\n+  if (hf.is_interpreted_frame()) {\n+    patch_callee_link_relative(hf, hf.fp());\n+  }\n+#ifdef ASSERT\n+  else {\n+    \/\/ See also FreezeBase::patch_pd()\n+    patch_callee_link(hf, (intptr_t*)badAddress);\n+  }\n+#endif\n+}\n+\n+\/\/\n+\/\/ Heap frames differ from stack frames in the following aspects\n+\/\/\n+\/\/ - they are just word aligned\n+\/\/ - the unextended sp of interpreted frames is set such that\n+\/\/   unextended sp + frame::metadata_words_at_top + 1 points to the last call parameter\n+\/\/   (the comment at the file end explains the unextended sp for interpreted frames on the stack)\n+\/\/\n+\/\/ The difference in respect to the unextended sp is required to comply with shared code.\n+\/\/ Furthermore fast frozen and compiled frames have invalid back links (see\n+\/\/ Thaw<ConfigT>::patch_caller_links() and FreezeBase::patch_pd())\n+\/\/\n+\/\/ === New Interpreted Frame ==========================================================================================\n+\/\/\n+\/\/ ### Interpreted Caller: Overlap new frame with Caller\n+\/\/\n+\/\/     Caller on entry                                     New frame with resized Caller\n+\/\/\n+\/\/     | frame::abi_minframe    |                          |                        |\n+\/\/     |                        |<- FP of caller           | Caller's SP            |<- FP of caller\n+\/\/     ==========================                          ==========================\n+\/\/     | ijava_state            |                          | ijava_state            |\n+\/\/     |                        |                          |                        |\n+\/\/     |------------------------|                  -----   |------------------------|\n+\/\/     | P0                     |                    ^     | L0 aka P0              |\n+\/\/     | :                      |                    |     | :      :               |\n+\/\/     | Pn                     |<- unext. SP        |     | :      Pn              |<- unext. SP\n+\/\/     |------------------------|   + metadata     overlap | :                      |   + metadata\n+\/\/     | frame::abi_minframe    |                    |     | Lm                     |\n+\/\/     | (metadata_words_at_top)|<- SP == unext. SP  v     |------------------------|<- unextended SP of caller (1)\n+\/\/     ==========================   of caller      -----   | frame::abi_minframe    |\n+\/\/                                                         | (metadata_words_at_top)|<- new SP of caller \/ FP of new frame\n+\/\/      overlap = stack_argsize(f)                         ==========================       ^\n+\/\/                + frame::metadata_words_at_top           | ijava_state            |       |\n+\/\/                                                         |                        |       |\n+\/\/      Where f is the frame to be relocated on the heap.  |------------------------|       |\n+\/\/      See also StackChunkFrameStream::frame_size().      | Expressions            |   FP - esp of f\n+\/\/                                                         | P0                     |       |\n+\/\/                                                         | :                      |       |\n+\/\/                            |  Growth  |                 | Pi                     |       v\n+\/\/                            v          v                 |------------------------|      ---\n+\/\/                                                         | frame::abi_minframe    |\n+\/\/                                                         | (metadata_words_at_top)|<- unextended SP \/\n+\/\/                                                         ==========================   SP of new frame\n+\/\/ ### Compiled Caller: No Overlap\n+\/\/\n+\/\/     The caller is resized to accomodate the callee's locals and abi but there is _no_ overlap with\n+\/\/     the original caller frame.\n+\/\/\n+\/\/     Caller on entry                                     New frame with resized Caller\n+\/\/\n+\/\/     | frame::abi_minframe    |                          |                        |\n+\/\/     | (metadata_words_at_top)|<- FP of caller           | Caller's SP            |<- FP of caller\n+\/\/     ==========================                          ==========================\n+\/\/     |                        |                          |                        |\n+\/\/     |                        |                          |                        |\n+\/\/     |------------------------|                          |------------------------|\n+\/\/     | frame::abi_minframe    |                          | frame::abi_minframe    |\n+\/\/     | (metadata_words_at_top)|<- SP == unext. SP        | (metadata_words_at_top)|<- unext. SP of caller\n+\/\/     ==========================   of caller              |------------------------|\n+\/\/                                                         | L0 aka P0              |\n+\/\/                                                         | :      :               |\n+\/\/                                                         | :      Pn              |\n+\/\/      overlap = 0                                        | Lm                     |\n+\/\/                                                         |------------------------|\n+\/\/      f is the frame to be relocated on the heap         | frame::abi_minframe    |\n+\/\/                                                         | (metadata_words_at_top)|<- new SP of caller \/ FP of new frame\n+\/\/                                                         ==========================       ^\n+\/\/                                                         | ijava_state            |       |\n+\/\/                             |  Growth  |                |                        |       |\n+\/\/                             v          v                |------------------------|       |\n+\/\/                                                         | Expressions            |   FP - esp of f\n+\/\/                                                         | P0                     |       |\n+\/\/                                                         | :                      |       |\n+\/\/                                                         | Pi                     |       v\n+\/\/                                                         |------------------------|      ---\n+\/\/                                                         | frame::abi_minframe    |\n+\/\/                                                         | (metadata_words_at_top)|<- unextended SP \/\n+\/\/                                                         ==========================   SP of new frame\n+\/\/\n+\/\/ (1) Caller's unextended SP is preserved in callee's frame::ijava_state::sender_sp\n+\/\/     (See ContinuationHelper::InterpretedFrame::patch_sender_sp). This is required\n+\/\/     by StackChunkFrameStream<frame_kind>::next_for_interpreter_frame().\n+\/\/\n+\/\/ === New Compiled Frame =============================================================================================\n+\/\/\n+\/\/ ### Interpreted Caller: No Overlap\n+\/\/\n+\/\/     The caller is resized to accomodate the callee's stack arguments and abi but there is _no_ overlap with\n+\/\/     the original caller frame.\n+\/\/\n+\/\/     Note: a new ABI is added to the caller even if there are no stackargs.\n+\/\/     This is necessary to comply with shared code.\n+\/\/\n+\/\/     Caller on entry                                     New frame with resized Caller\n+\/\/\n+\/\/     | frame::abi_minframe    |                          | frame::abi_minframe    |\n+\/\/     | (metadata_words_at_top)|<- FP of caller           | (metadata_words_at_top)|<- FP of caller\n+\/\/     ==========================                          ==========================\n+\/\/     | ijava_state            |                          | ijava_state            |\n+\/\/     |                        |                          |                        |\n+\/\/     |------------------------|                          |------------------------|\n+\/\/     | P0                     |                          | P0                     |\n+\/\/     | :                      |                          | :                      |\n+\/\/     | Pn                     |<- unext. SP              | Pn                     |<- unext. SP\n+\/\/     |------------------------|   + metadata             |------------------------|   + metadata\n+\/\/     | frame::abi_minframe    |                          | frame::abi_minframe    |\n+\/\/     | (metadata_words_at_top)|<- SP == unext. SP        | (metadata_words_at_top)|<- unextended SP of caller (1)\n+\/\/     ==========================   of caller              |------------------------|\n+\/\/                                                         | Stack Args             |\n+\/\/      overlap = 0                                        | (if any)               |\n+\/\/                                                         |------------------------|\n+\/\/      f is the frame to be relocated on the heap         | frame::abi_minframe    |\n+\/\/                                                         | (metadata_words_at_top)|<- new SP of caller \/ FP of new frame\n+\/\/                                                         ==========================\n+\/\/                                                         |                        |\n+\/\/                             |  Growth  |                |                        |\n+\/\/                             v          v                |------------------------|\n+\/\/                                                         | frame::abi_minframe    |\n+\/\/                                                         | (metadata_words_at_top)|<- SP == unext. SP of new frame\n+\/\/                                                         ==========================\n+\/\/\n+\/\/ ### Compiled Caller: Stackargs + ABI Overlap\n+\/\/\n+\/\/     Caller on entry                                     New frame with resized Caller\n+\/\/\n+\/\/     | frame::abi_minframe    |                          | frame::abi_minframe    |\n+\/\/     | (metadata_words_at_top)|<- FP of caller           | (metadata_words_at_top)|<- FP of caller\n+\/\/     ==========================                          ==========================\n+\/\/     |                        |                          |                        |\n+\/\/     |                        |                          |                        |\n+\/\/     |------------------------|                   -----  |------------------------|\n+\/\/     | Stack Args             |                     ^    | Stack Args             |\n+\/\/     | (if any)               |                     |    | (if any)               |\n+\/\/     |------------------------|                  overlap |------------------------|\n+\/\/     | frame::abi_minframe    |                     |    | frame::abi_minframe    |\n+\/\/     | (metadata_words_at_top)|<- SP == unext. SP   v    | (metadata_words_at_top)|<- SP == unext. SP of caller\n+\/\/     ==========================   of caller       -----  ==========================   \/ FP of new frame\n+\/\/                                                         |                        |\n+\/\/      overlap = stack_argsize(f)                         |                        |\n+\/\/                + frame::metadata_words_at_top           |------------------------|\n+\/\/                                                         | frame::abi_minframe    |\n+\/\/      Where f is the frame to be relocated on the heap.  | (metadata_words_at_top)|<- SP == unext. SP of new frame\n+\/\/      See also StackChunkFrameStream::frame_size().      ==========================\n+\/\/\n+template<typename FKind>\n+frame FreezeBase::new_heap_frame(frame& f, frame& caller) {\n+  assert(FKind::is_instance(f), \"\");\n+\n+  intptr_t *sp, *fp;\n+  if (FKind::interpreted) {\n+    int locals = f.interpreter_frame_method()->max_locals();\n+    \/\/ If the caller.is_empty(), i.e. we're freezing into an empty chunk, then we set\n+    \/\/ the chunk's argsize in finalize_freeze and make room for it above the unextended_sp\n+    \/\/ See also comment on StackChunkFrameStream<frame_kind>::interpreter_frame_size()\n+    int overlap =\n+        (caller.is_interpreted_frame() || caller.is_empty())\n+        ? ContinuationHelper::InterpretedFrame::stack_argsize(f) + frame::metadata_words_at_top\n+        : 0;\n+    fp = caller.unextended_sp() + overlap - locals - frame::metadata_words_at_top;\n+    \/\/ esp points one slot below the last argument\n+    intptr_t* x86_64_like_unextended_sp = f.interpreter_frame_esp() + 1 - frame::metadata_words_at_top;\n+    sp = fp - (f.fp() - x86_64_like_unextended_sp);\n+\n+    assert (sp <= fp && (fp <= caller.unextended_sp() || caller.is_interpreted_frame()),\n+            \"sp=\" PTR_FORMAT \" fp=\" PTR_FORMAT \" caller.unextended_sp()=\" PTR_FORMAT \" caller.is_interpreted_frame()=%d\",\n+            p2i(sp), p2i(fp), p2i(caller.unextended_sp()), caller.is_interpreted_frame());\n+    caller.set_sp(fp);\n+\n+    assert(_cont.tail()->is_in_chunk(sp), \"\");\n+\n+    frame hf(sp, sp, fp, f.pc(), nullptr, nullptr, true \/* on_heap *\/);\n+    \/\/ frame_top() and frame_bottom() read these before relativize_interpreted_frame_metadata() is called\n+    *hf.addr_at(ijava_idx(locals)) = frame::metadata_words + locals - 1;\n+    *hf.addr_at(ijava_idx(esp))    = f.interpreter_frame_esp() - f.fp();\n+    return hf;\n+  } else {\n+    int fsize = FKind::size(f);\n+    sp = caller.unextended_sp() - fsize;\n+    if (caller.is_interpreted_frame()) {\n+      \/\/ If the caller is interpreted, our stackargs are not supposed to overlap with it\n+      \/\/ so we make more room by moving sp down by argsize\n+      int argsize = FKind::stack_argsize(f);\n+      sp -= argsize + frame::metadata_words_at_top;\n+    }\n+    fp = sp + fsize;\n+    caller.set_sp(fp);\n+\n+    assert(_cont.tail()->is_in_chunk(sp), \"\");\n+\n+    return frame(sp, sp, fp, f.pc(), nullptr, nullptr, true \/* on_heap *\/);\n+  }\n@@ -57,1 +310,21 @@\n-  Unimplemented();\n+  if (caller.is_interpreted_frame()) {\n+    assert(!caller.is_empty(), \"\");\n+    patch_callee_link_relative(caller, caller.fp());\n+  }\n+#ifdef ASSERT\n+  else {\n+    \/\/ For compiled frames the back link is actually redundant. It gets computed\n+    \/\/ as unextended_sp + frame_size.\n+\n+    \/\/ Note the difference on x86_64: the link is not made relative if the caller\n+    \/\/ is a compiled frame because there rbp is used as a non-volatile register by\n+    \/\/ c1\/c2 so it could be a computed value local to the caller.\n+\n+    \/\/ See also:\n+    \/\/ - FreezeBase::set_top_frame_metadata_pd\n+    \/\/ - StackChunkFrameStream<frame_kind>::fp()\n+    \/\/ - UseContinuationFastPath: compiled frames are copied in a batch w\/o patching the back link.\n+    \/\/   The backlinks are restored when thawing (see Thaw<ConfigT>::patch_caller_links())\n+    patch_callee_link(hf, (intptr_t*)badAddress);\n+  }\n+#endif\n@@ -60,2 +333,8 @@\n-inline void FreezeBase::patch_stack_pd(intptr_t* frame_sp, intptr_t* heap_sp) {\n-  Unimplemented();\n+\/\/\/\/\/\/\/\/ Thaw\n+\n+\/\/ Fast path\n+\n+inline void ThawBase::prefetch_chunk_pd(void* start, int size) {\n+  size <<= LogBytesPerWord;\n+  Prefetch::read(start, size);\n+  Prefetch::read(start, size - 64);\n@@ -64,0 +343,22 @@\n+\/\/ Set back chain links of fast thawed frames such that *sp == callers_sp.\n+\/\/ See https:\/\/refspecs.linuxfoundation.org\/ELF\/ppc64\/PPC-elf64abi.html#STACK\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::patch_caller_links(intptr_t* sp, intptr_t* bottom) {\n+  for (intptr_t* callers_sp; sp < bottom; sp = callers_sp) {\n+    address pc = (address)((frame::abi_minframe*) sp)->lr;\n+    assert(pc != nullptr, \"\");\n+    \/\/ see ThawBase::patch_return() which gets called just before\n+    bool is_entry_frame = pc == StubRoutines::cont_returnBarrier() || pc == _cont.entryPC();\n+    if (is_entry_frame) {\n+      callers_sp = _cont.entryFP();\n+    } else {\n+      CodeBlob* cb = CodeCache::find_blob(pc);\n+      callers_sp = sp + cb->frame_size();\n+    }\n+    \/\/ set the back link\n+    ((frame::abi_minframe*) sp)->callers_sp = (intptr_t) callers_sp;\n+  }\n+}\n+\n+\/\/ Slow path\n+\n@@ -65,2 +366,2 @@\n-  Unimplemented();\n-  return frame();\n+  intptr_t* sp = _cont.entrySP();\n+  return frame(sp, _cont.entryPC(), sp, _cont.entryFP());\n@@ -69,0 +370,112 @@\n+\/\/ === New Interpreted Frame ================================================================================================================\n+\/\/\n+\/\/ ### Non-Interpreted Caller (compiled, enterSpecial): No Overlap\n+\/\/\n+\/\/     Heap Frame `hf`                                   `hf` gets copied to stack _without_ overlapping the caller\n+\/\/\n+\/\/     |                      |                            Non-Interpreted |                      |\n+\/\/     |                      |<- bottom                   Caller          |----------------------|\n+\/\/     |----------------------|    ^                                       | frame::abi_minframe  |<- unextended SP\n+\/\/     | L0 aka P0            |    |                                   --- ========================\n+\/\/     | :      :             |    |                                    ^  | L0 aka P0            |\n+\/\/     | :      Pn            |    |                                    |  | :      :             | Parameters do\n+\/\/     | :                    |    |                                    |  | :      Pn            | not overlap with\n+\/\/     | Lm                   |    |                                    |  | :                    | caller!\n+\/\/     |----------------------| `fsize`                                 |  | :                    |\n+\/\/     | frame::abi_minframe  |    |                                       | :                    |\n+\/\/     ========================    |                     `fsize` + padding | Lm                   |\n+\/\/     |                      |    |                                       |----------------------|\n+\/\/     | ijava_state          |    |                                    |  | Opt. Align. Padding  |\n+\/\/     |                      |    |                                    |  |----------------------|\n+\/\/     |----------------------|    |                                    |  | frame::abi_minframe  |<- new SP of caller\n+\/\/     | L0 aka P0            |    |                                    |  ========================   \/ FP of new frame\n+\/\/     | :      :             |    |                                    |  |                      |   (aligned)\n+\/\/     | :      Pn            |<- unext. SP + metadata                  |  | ijava_state          |\n+\/\/     | :                    |    |                                    |  |                      |\n+\/\/     | Lm                   |    |                                    |  |----------------------|\n+\/\/     |----------------------|    v                                    |  | P0                   |\n+\/\/     | frame::abi_minframe  |<- SP \/ unextended SP                    |  | :                    |\n+\/\/     ========================                                         |  | Pi                   |<- unextended SP + metadata\n+\/\/                                                                      |  |----------------------|\n+\/\/                                           | Growth |                 v  | frame::abi_minframe  |<- unextended SP \/ SP of new frame\n+\/\/                                           v        v                --- ========================   (not yet aligned(1))\n+\/\/\n+\/\/\n+\/\/ ### Interpreted Caller: Overlap with Caller\n+\/\/\n+\/\/     Caller                                                              New frame with resized\/aligned Caller\n+\/\/\n+\/\/     |                      |                                            |                      |\n+\/\/     | ijava_state          |                                            | ijava_state          |\n+\/\/     |----------------------|                                            |----------------------|\n+\/\/     | non param. expr.     |                                     bottom | non param. expr.     |\n+\/\/     | - - - - - - - - - -  |                           ---           ^  | - - - - - - - - - -  |\n+\/\/     | P0                   |                            ^            |  | L0 aka P0            |\n+\/\/     | :                    |                            |            |  | :      :             |\n+\/\/     | Pn                   |<- unextended SP           overlap       |  | :      Pn            |<- unextended SP\n+\/\/     |----------------------|   + metadata_words_at_top  |            |  | :                    |   + metadata_words_at_top\n+\/\/     | frame::abi_minframe  |<- unextended SP            v            |  | :                    |   (unaligned)\n+\/\/     ========================   \/ SP of new frame       ---           |  | :                    |   of caller\n+\/\/                                (not yet aligned(1))                  |  | Lm                   |\n+\/\/                                                                `fsize`  |----------------------|\n+\/\/       overlap = stack_argsize(hf)                              + padding| Opt. Align. Padding  |\n+\/\/                 + frame::metadata_words_at_top                       |  |----------------------|\n+\/\/                                                                      |  | frame::abi_minframe  |<- new SP of caller\n+\/\/                                                                      |  ========================   \/ FP of new frame\n+\/\/                                                                      |  |                      |   (aligned)\n+\/\/                                  | Growth |                          |  | ijava_state          |\n+\/\/                                  v        v                          |  |                      |\n+\/\/                                                                      |  |----------------------|\n+\/\/                                                                      |  | P0                   |\n+\/\/                                                                      |  | :                    |\n+\/\/                                                                      |  | Pi                   |<- unextended SP\n+\/\/                                                                      |  |----------------------|    + metadata_words_at_top\n+\/\/                                                                      v  | frame::abi_minframe  |<- unextended SP \/ SP of new frame\n+\/\/                                                                     --- ========================   (not yet aligned(1))\n+\/\/\n+\/\/\n+\/\/  (1) The SP \/ unextended SP of the new interpreted frame is not aligned. It\n+\/\/      gets aligned when its callee is pushed on stack or in finish_thaw() if\n+\/\/      it is the top frame. This allows addressing parameters: unextended SP + metadata_words_at_top\n+\/\/\n+\/\/  (2) If caller is interpreted then its ijava_state::top_frame_sp will be used as sender sp\n+\/\/      of the new frame (see ContinuationHelper::InterpretedFrame::patch_sender_sp() and diagram at the end of this file)\n+\/\/\n+\/\/  (3) The size of alignment padding required when thawing frames is accounted for\n+\/\/      in FreezeBase::_align_size.\n+\/\/\n+\/\/ === New Compiled Frame ===================================================================================================================\n+\/\/\n+\/\/        Compiled Caller                              Interpreted Caller\n+\/\/\n+\/\/        - stackargs+abi overlap with caller          - gets resized for stackargs\n+\/\/        - no alignment padding                       - SP gets aligned\n+\/\/                                                     - no overlap with orig.\n+\/\/                                                       caller\n+\/\/   O C\n+\/\/   r a  |                      |                     |                      |\n+\/\/   i l  |                      |                     |                      |\n+\/\/   g l  |----------------------|                     |                      |\n+\/\/   i e  | Stack Args           |                     |                      |\n+\/\/   n r  | (if any)             |                     |----------------------|\n+\/\/   a    |----------------------|                     | frame::abi_minframe  |\n+\/\/   l    | frame::abi_minframe  |<- unext. SP \/ SP    | (unused)             |<- unal.unext.SP\n+\/\/  - - - ======================== - - - - - - - - - - |----------------------|- - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+\/\/    N   |                      |                     | Opt. Align. Padding  |\n+\/\/    e   |                      |                     |----------------------|\n+\/\/    w   |----------------------|                     | Stack Args           |\n+\/\/        | frame::abi_minframe  |<- unext. SP \/ SP    | (if any)             |\n+\/\/    F   ========================                     |----------------------|\n+\/\/    r                                                | frame::abi_minframe  |<- caller's SP\n+\/\/    a                                                ======================== \/ new frame's FP\n+\/\/    m                                                |                      |   (aligned)\n+\/\/    e                                                |                      |\n+\/\/                                                     |----------------------|\n+\/\/                                                     | frame::abi_minframe  |<- unext. SP \/ SP\n+\/\/                                                     ========================\n+\/\/\n+\/\/  If the new frame is at the bottom just above the ContinuationEntry frame then the stackargs\n+\/\/  don't overlap the caller either even though it is compiled because the size is not\n+\/\/  limited\/known. In contrast to the interpreted caller case the abi overlaps with the caller\n+\/\/  if there are no stackargs. This is to comply with shared code (see e.g. StackChunkFrameStream::frame_size())\n+\/\/\n@@ -70,3 +483,1 @@\n-  Unimplemented();\n-  return frame();\n-}\n+  assert(FKind::is_instance(hf), \"\");\n@@ -74,3 +485,16 @@\n-inline void ThawBase::set_interpreter_frame_bottom(const frame& f, intptr_t* bottom) {\n-  Unimplemented();\n-}\n+  assert(is_aligned(caller.fp(), frame::frame_alignment), \"\");\n+  assert(is_aligned(caller.sp(), frame::frame_alignment), \"\");\n+  if (FKind::interpreted) {\n+    \/\/ Note: we have to overlap with the caller, at least if it is interpreted, to match the\n+    \/\/ max_thawing_size calculation during freeze. See also comment above.\n+    intptr_t* heap_sp = hf.unextended_sp();\n+    const int fsize = ContinuationHelper::InterpretedFrame::frame_bottom(hf) - hf.unextended_sp();\n+    const int overlap = !caller.is_interpreted_frame() ? 0\n+                        : ContinuationHelper::InterpretedFrame::stack_argsize(hf) + frame::metadata_words_at_top;\n+    intptr_t* frame_sp = caller.unextended_sp() + overlap - fsize;\n+    intptr_t* fp = frame_sp + (hf.fp() - heap_sp);\n+    \/\/ align fp\n+    int padding = fp - align_down(fp, frame::frame_alignment);\n+    fp -= padding;\n+    \/\/ alignment of sp is done by callee or in finish_thaw()\n+    frame_sp -= padding;\n@@ -78,2 +502,28 @@\n-inline void ThawBase::derelativize_interpreted_frame_metadata(const frame& hf, const frame& f) {\n-  Unimplemented();\n+    \/\/ On ppc esp points to the next free slot on the expression stack and sp + metadata points to the last parameter\n+    DEBUG_ONLY(intptr_t* esp = fp + *hf.addr_at(ijava_idx(esp));)\n+    assert(frame_sp + frame::metadata_words_at_top == esp+1, \" frame_sp=\" PTR_FORMAT \" esp=\" PTR_FORMAT, p2i(frame_sp), p2i(esp));\n+    caller.set_sp(fp);\n+    frame f(frame_sp, hf.pc(), frame_sp, fp);\n+    \/\/ it's set again later in set_interpreter_frame_bottom, but we need to set the locals now so that\n+    \/\/ we could call ContinuationHelper::InterpretedFrame::frame_bottom\n+    intptr_t offset = *hf.addr_at(ijava_idx(locals)) + padding;\n+    assert((int)offset == hf.interpreter_frame_method()->max_locals() + frame::metadata_words_at_top + padding - 1, \"\");\n+    *(intptr_t**)f.addr_at(ijava_idx(locals)) = fp + offset;\n+\n+    return f;\n+  } else {\n+    int fsize = FKind::size(hf);\n+    int argsize = hf.compiled_frame_stack_argsize();\n+    intptr_t* frame_sp = caller.sp() - fsize;\n+\n+    if ((bottom && argsize > 0) || caller.is_interpreted_frame()) {\n+      frame_sp -= argsize + frame::metadata_words_at_top;\n+      frame_sp = align_down(frame_sp, frame::alignment_in_bytes);\n+      caller.set_sp(frame_sp + fsize);\n+    }\n+\n+    assert(hf.cb() != nullptr, \"\");\n+    assert(hf.oop_map() != nullptr, \"\");\n+    intptr_t* fp = frame_sp + fsize;\n+    return frame(frame_sp, frame_sp, fp, hf.pc(), hf.cb(), hf.oop_map(), false);\n+  }\n@@ -83,1 +533,1 @@\n-  Unimplemented();\n+  \/\/ Unused. Alignment is done directly in new_stack_frame() \/ finish_thaw().\n@@ -87,2 +537,11 @@\n-inline void ThawBase::patch_pd(frame& f, const frame& caller) {\n-  Unimplemented();\n+static inline void derelativize_one(intptr_t* const fp, int offset) {\n+  intptr_t* addr = fp + offset;\n+  *addr = (intptr_t)(fp + *addr);\n+}\n+\n+inline void ThawBase::derelativize_interpreted_frame_metadata(const frame& hf, const frame& f) {\n+  intptr_t* vfp = f.fp();\n+\n+  derelativize_one(vfp, ijava_idx(monitors));\n+  derelativize_one(vfp, ijava_idx(esp));\n+  derelativize_one(vfp, ijava_idx(top_frame_sp));\n@@ -91,2 +550,2 @@\n-void ThawBase::patch_chunk_pd(intptr_t* sp) {\n-  Unimplemented();\n+inline void ThawBase::set_interpreter_frame_bottom(const frame& f, intptr_t* bottom) {\n+  *(intptr_t**)f.addr_at(ijava_idx(locals)) = bottom - 1;\n@@ -95,2 +554,2 @@\n-inline void ThawBase::prefetch_chunk_pd(void* start, int size) {\n-  Unimplemented();\n+inline void ThawBase::patch_pd(frame& f, const frame& caller) {\n+  patch_callee_link(caller, caller.fp());\n@@ -99,0 +558,69 @@\n+\/\/\n+\/\/ Interpreter Calling Procedure on PPC\n+\/\/\n+\/\/ Caller                                   Resized Caller before the Call                New Callee Frame\n+\/\/\n+\/\/   - SP\/FP are 16 byte aligned.           - The unused part of the expression stack     - The caller's original SP is passed as\n+\/\/     Padding is added as necessary.         is removed                                    sender SP (in R21_sender_SP) also by\n+\/\/   - SP is _not_ used as esp              - Slots for the callee's nonparameter locals    compiled callers. It is saved in the\n+\/\/     (expression stack pointer)             are added.                                    ijava_state::sender_sp slot and\n+\/\/   - Has reserved slots for the           - The large ABI is replaced with a minimal      restored when returning.\n+\/\/     maximal expression stack               ABI.                                          This removes a c2i extension if there\n+\/\/   - Has a larger ABI section on          - The original SP was saved in                  is one.\n+\/\/     top that is required to call           ijava_state::top_frame_sp slot.             - ijava_state::sender_sp will be set\n+\/\/     C++ code                               From there it is restored as SP _after_       as the caller's unextended sp when\n+\/\/                                            returning from a call. This reverts the       iterating stack frames\n+\/\/                                            resizing described above. It is also          (see frame::unextended_sp() and\n+\/\/                                            required to undo potential i2c extensions     frame::sender_for_interpreter_frame())\n+\/\/                                            if the calle should be compiled.\n+\/\/                                          - Note that unextended SP < SP\n+\/\/                                            is possible on ppc.\n+\/\/\n+\/\/ | Minimal ABI          |                 | Minimal ABI          |                      | Minimal ABI          |\n+\/\/ | (frame::abi_minframe)|                 | (frame::abi_minframe)|                      | (frame::abi_minframe)|\n+\/\/ | 4 words              |                 | 4 words              |                      | 4 words              |\n+\/\/ | Caller's SP          |<- FP of caller  | Caller's SP          |<- FP of caller       | Caller's SP          |<- FP of caller\n+\/\/ ========================   (aligned)     ========================                      ========================\n+\/\/ | frame::              |                 | frame::              |                      | frame::              |\n+\/\/ | ijava_state          |                 | ijava_state          |                      | ijava_state          |\n+\/\/ |                      |                 |                      |                      |                      |\n+\/\/ |----------------------|                 |----------------------|                      |----------------------|\n+\/\/ | P0                   |                 | L0 aka P0            |                      | L0 aka P0            |\n+\/\/ |                      |                 | :                    |                      | :                    |\n+\/\/ | Pn                   |                 | :      Pn            |                      | :      Pn            |\n+\/\/ |----------------------|                 | :                    |                      | :                    |\n+\/\/ |                      |                 | Lm                   |                      | Lm                   |\n+\/\/ | Reserved Expr. Stack |                 |----------------------|                      |----------------------|\n+\/\/ |                      |                 | Opt. Alignm. Padding |                      | Opt. Alignm. Padding |\n+\/\/ |                      |<- ConstMethod   |----------------------|                      |----------------------|\n+\/\/ |----------------------|   ::_max_stack  | Minimal ABI          |                      | Minimal ABI          |\n+\/\/ | Opt. Alignm. Padding |                 | (frame::abi_minframe)|                      | (frame::abi_minframe)|\n+\/\/ |----------------------|                 | 4 words              |                      | 4 words              |\n+\/\/ | Large ABI            |                 | Caller's SP          |<- new SP of caller   | Caller's SP          |<- SP of caller \/\n+\/\/ | for C++ calls        |                 ========================   (aligned)          ========================   FP of callee\n+\/\/ | (frame::abi_reg_args)|                                                               | frame::              |   (aligned)\n+\/\/ |                      |                                                               | ijava_state          |\n+\/\/ |                      |                                                               |                      |\n+\/\/ |                      |                                                               |----------------------|\n+\/\/ |                      |                                                               |                      |\n+\/\/ | Caller's SP          |<- SP of caller                          <- unextended SP      | Reserved Expr. Stack |<- unextended SP\n+\/\/ ========================   (aligned)                                of caller          |                      |   of caller\n+\/\/                                                                     (aligned)          |                      |\n+\/\/                                                                                        |                      |\n+\/\/                                                                                        |                      |\n+\/\/                                                                                        |                      |\n+\/\/                                                                                        |                      |<- ConstMethod\n+\/\/                                                                                        |----------------------|   ::_max_stack\n+\/\/                         Resize Caller                    Push new Callee Frame         | Opt. Alignm. Padding |\n+\/\/                     -------------------->              ------------------------>       |----------------------|\n+\/\/                     (ABI, expressions, locals)                                         | Large ABI            |\n+\/\/                                                                                        | for C++ calls        |\n+\/\/                                                                                        | (frame::abi_reg_args)|\n+\/\/                                                                                        |                      |\n+\/\/                                                |  Growth  |                            |                      |\n+\/\/                                                v          v                            |                      |\n+\/\/                                                                                        |                      |\n+\/\/                                                                                        | Caller's SP          |<- SP of callee\n+\/\/                                                                                        ========================   (aligned)\n+\/\/\n+\/\/\n","filename":"src\/hotspot\/cpu\/ppc\/continuationFreezeThaw_ppc.inline.hpp","additions":558,"deletions":30,"binary":false,"changes":588,"status":"modified"},{"patch":"@@ -37,2 +37,1 @@\n-  Unimplemented();\n-  return 0;\n+  return size & 1;\n@@ -41,3 +40,2 @@\n-inline intptr_t* ContinuationHelper::frame_align_pointer(intptr_t* sp) {\n-  Unimplemented();\n-  return NULL;\n+inline intptr_t* ContinuationHelper::frame_align_pointer(intptr_t* p) {\n+  return align_down(p, frame::frame_alignment);\n@@ -56,1 +54,1 @@\n-  Unimplemented();\n+  f.own_abi()->callers_sp = (uint64_t)f.fp();\n@@ -61,1 +59,1 @@\n-  Unimplemented();\n+  \/\/ nothing to do\n@@ -66,1 +64,1 @@\n-  Unimplemented();\n+  \/\/ nothing to do\n@@ -70,2 +68,6 @@\n-  Unimplemented();\n-  return false;\n+  intptr_t* sp = f.sp();\n+  address pc = *(address*)(sp - frame::sender_sp_ret_address_offset());\n+  intptr_t* fp = (intptr_t*)f.own_abi()->callers_sp;\n+  assert(f.raw_pc() == pc, \"f.ra_pc: \" INTPTR_FORMAT \" actual: \" INTPTR_FORMAT, p2i(f.raw_pc()), p2i(pc));\n+  assert(f.fp() == fp, \"f.fp: \" INTPTR_FORMAT \" actual: \" INTPTR_FORMAT, p2i(f.fp()), p2i(fp));\n+  return f.raw_pc() == pc && f.fp() == fp;\n@@ -76,8 +78,1 @@\n-  Unimplemented();\n-  return NULL;\n-}\n-\n-template<typename FKind>\n-static inline intptr_t* real_fp(const frame& f) {\n-  Unimplemented();\n-  return NULL;\n+  return (intptr_t**)&f.own_abi()->callers_sp;\n@@ -87,2 +82,1 @@\n-  Unimplemented();\n-  return NULL;\n+  return (address*)&f.callers_abi()->lr;\n@@ -91,2 +85,10 @@\n-inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, intptr_t* sp) {\n-  Unimplemented();\n+inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, const frame& caller) {\n+  intptr_t* sp = caller.unextended_sp();\n+  if (!f.is_heap_frame() && caller.is_interpreted_frame()) {\n+    \/\/ See diagram \"Interpreter Calling Procedure on PPC\" at the end of continuationFreezeThaw_ppc.inline.hpp\n+    sp = (intptr_t*)caller.at(ijava_idx(top_frame_sp));\n+  }\n+  assert(f.is_interpreted_frame(), \"\");\n+  assert(f.is_heap_frame() || is_aligned(sp, frame::alignment_in_bytes), \"\");\n+  intptr_t* la = f.addr_at(ijava_idx(sender_sp));\n+  *la = f.is_heap_frame() ? (intptr_t)(sp - f.fp()) : (intptr_t)sp;\n@@ -96,2 +98,1 @@\n-  Unimplemented();\n-  return NULL;\n+  return (address*)&f.callers_abi()->lr;\n@@ -101,2 +102,1 @@\n-  Unimplemented();\n-  return NULL;\n+  return (address)f.own_abi()->lr;\n@@ -106,1 +106,64 @@\n-  Unimplemented();\n+  f.own_abi()->lr = (uint64_t)pc;\n+}\n+\n+\/\/                     | Minimal ABI          |\n+\/\/                     | (frame::abi_minframe)|\n+\/\/                     | 4 words              |\n+\/\/                     | Caller's SP          |<- FP of f's caller\n+\/\/                     |======================|\n+\/\/                     |                      |                                 Frame of f's caller\n+\/\/                     |                      |\n+\/\/ frame_bottom of f ->|                      |\n+\/\/                     |----------------------|\n+\/\/                     | L0 aka P0            |\n+\/\/                     | :                    |\n+\/\/                     | :      Pn            |\n+\/\/                     | :                    |\n+\/\/                     | Lm                   |\n+\/\/                     |----------------------|\n+\/\/                     | SP alignment (opt.)  |\n+\/\/                     |----------------------|\n+\/\/                     | Minimal ABI          |\n+\/\/                     | (frame::abi_minframe)|\n+\/\/                     | 4 words              |\n+\/\/                     | Caller's SP          |<- SP of f's caller \/ FP of f\n+\/\/                     |======================|\n+\/\/                     |ijava_state (metadata)|                                 Frame of f\n+\/\/                     |                      |\n+\/\/                     |                      |\n+\/\/                     |----------------------|\n+\/\/                     | Expression stack     |\n+\/\/                     |                      |\n+\/\/    frame_top of f ->|                      |\n+\/\/   if callee interp. |......................|\n+\/\/                     | L0 aka P0            |<- ijava_state.esp + callee_argsize\n+\/\/                     | :                    |\n+\/\/    frame_top of f ->| :      Pn            |\n+\/\/  + metadata_words   | :                    |<- ijava_state.esp (1 slot below Pn)\n+\/\/    if callee comp.  | Lm                   |\n+\/\/                     |----------------------|\n+\/\/                     | SP alignment (opt.)  |\n+\/\/                     |----------------------|\n+\/\/                     | Minimal ABI          |\n+\/\/                     | (frame::abi_minframe)|\n+\/\/                     | 4 words              |\n+\/\/                     | Caller's SP          |<- SP of f \/ FP of f's callee\n+\/\/                     |======================|\n+\/\/                     |ijava_state (metadata)|                                 Frame of f's callee\n+\/\/                     |                      |\n+\/\/\n+\/\/                           |  Growth  |\n+\/\/                           v          v\n+\/\/\n+\/\/ See also diagram at the end of continuation_ppc.inline.hpp\n+\/\/\n+inline intptr_t* ContinuationHelper::InterpretedFrame::frame_top(const frame& f, InterpreterOopMap* mask) { \/\/ inclusive; this will be copied with the frame\n+  int expression_stack_sz = expression_stack_size(f, mask);\n+  intptr_t* res = (intptr_t*)f.interpreter_frame_monitor_end() - expression_stack_sz;\n+  assert(res <= (intptr_t*)f.get_ijava_state() - expression_stack_sz,\n+         \"res=\" PTR_FORMAT \" f.get_ijava_state()=\" PTR_FORMAT \" expression_stack_sz=%d\",\n+         p2i(res), p2i(f.get_ijava_state()), expression_stack_sz);\n+  assert(res >= f.unextended_sp(),\n+         \"res: \" INTPTR_FORMAT \" ijava_state: \" INTPTR_FORMAT \" esp: \" INTPTR_FORMAT \" unextended_sp: \" INTPTR_FORMAT \" expression_stack_size: %d\",\n+         p2i(res), p2i(f.get_ijava_state()), f.get_ijava_state()->esp, p2i(f.unextended_sp()), expression_stack_sz);\n+  return res;\n@@ -109,3 +172,2 @@\n-inline intptr_t* ContinuationHelper::InterpretedFrame::frame_top(const frame& f, InterpreterOopMap* mask) { \/\/ inclusive; this will be copied with the frame\n-  Unimplemented();\n-  return NULL;\n+inline intptr_t* ContinuationHelper::InterpretedFrame::frame_bottom(const frame& f) {\n+  return (intptr_t*)f.at(ijava_idx(locals)) + 1; \/\/ exclusive (will not be copied), so we add 1 word\n@@ -114,3 +176,3 @@\n-inline intptr_t* ContinuationHelper::InterpretedFrame::frame_bottom(const frame& f) { \/\/ exclusive; this will not be copied with the frame\n-  Unimplemented();\n-  return NULL;\n+inline intptr_t* ContinuationHelper::InterpretedFrame::frame_top(const frame& f, int callee_argsize_incl_metadata, bool callee_interpreted) {\n+  intptr_t* pseudo_unextended_sp = f.interpreter_frame_esp() + 1 - frame::metadata_words_at_top;\n+  return pseudo_unextended_sp + (callee_interpreted ? callee_argsize_incl_metadata : 0);\n@@ -119,3 +181,2 @@\n-inline intptr_t* ContinuationHelper::InterpretedFrame::frame_top(const frame& f, int callee_argsize, bool callee_interpreted) {\n-  Unimplemented();\n-  return NULL;\n+inline intptr_t* ContinuationHelper::InterpretedFrame::callers_sp(const frame& f) {\n+  return f.fp();\n","filename":"src\/hotspot\/cpu\/ppc\/continuationHelper_ppc.inline.hpp","additions":97,"deletions":36,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -55,0 +55,3 @@\n+  if (is_heap_frame()) {\n+    return true;\n+  }\n@@ -82,1 +85,1 @@\n-  if (_cb != NULL ){\n+  if (_cb != NULL) {\n@@ -121,0 +124,7 @@\n+    if (Continuation::is_return_barrier_entry(sender_pc)) {\n+      \/\/ If our sender_pc is the return barrier, then our \"real\" sender is the continuation entry\n+      frame s = Continuation::continuation_bottom_sender(thread, *this, sender_sp);\n+      sender_sp = s.sp();\n+      sender_pc = s.pc();\n+    }\n+\n@@ -178,4 +188,0 @@\n-bool frame::is_interpreted_frame() const  {\n-  return Interpreter::contains(pc());\n-}\n-\n@@ -213,2 +219,17 @@\n-  \/\/ Pass callers initial_caller_sp as unextended_sp.\n-  return frame(sender_sp(), sender_pc(), (intptr_t*)get_ijava_state()->sender_sp);\n+  \/\/ This is the sp before any possible extension (adapter\/locals).\n+  intptr_t* unextended_sp = interpreter_frame_sender_sp();\n+  address sender_pc = this->sender_pc();\n+  if (Continuation::is_return_barrier_entry(sender_pc)) {\n+    if (map->walk_cont()) { \/\/ about to walk into an h-stack\n+      return Continuation::top_frame(*this, map);\n+    } else {\n+      return Continuation::continuation_bottom_sender(map->thread(), *this, sender_sp());\n+    }\n+  }\n+\n+  return frame(sender_sp(), sender_pc, unextended_sp);\n+}\n+\n+intptr_t* frame::interpreter_frame_sender_sp() const {\n+  assert(is_interpreted_frame(), \"interpreted frame expected\");\n+  return (intptr_t*)at(ijava_idx(sender_sp));\n@@ -382,0 +403,7 @@\n+\n+  if (is_java_frame() || Continuation::is_continuation_enterSpecial(*this)) {\n+    intptr_t* ret_pc_loc = (intptr_t*)&own_abi()->lr;\n+    address ret_pc = *(address*)ret_pc_loc;\n+    values.describe(frame_no, ret_pc_loc,\n+      Continuation::is_return_barrier_entry(ret_pc) ? \"return address (return barrier)\" : \"return address\");\n+  }\n@@ -398,1 +426,5 @@\n-  return (BasicObjectLock*) get_ijava_state()->monitors;\n+  BasicObjectLock* result = (BasicObjectLock*) at(ijava_idx(monitors));\n+  \/\/ make sure the pointer points inside the frame\n+  assert(sp() <= (intptr_t*) result, \"monitor end should be above the stack pointer\");\n+  assert((intptr_t*) result < fp(),  \"monitor end should be strictly below the frame pointer: result: \" INTPTR_FORMAT \" fp: \" INTPTR_FORMAT, p2i(result), p2i(fp()));\n+  return result;\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":40,"deletions":8,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -271,0 +271,1 @@\n+\/\/ Byte offset relative to fp\n@@ -274,0 +275,4 @@\n+\/\/ Frame slot index relative to fp\n+#define ijava_idx(_component) \\\n+        (_ijava_state_neg(_component) >> LogBytesPerWord)\n+\n@@ -359,1 +364,4 @@\n-  intptr_t* _unextended_sp;\n+  union {\n+    intptr_t* _unextended_sp;\n+    int _offset_unextended_sp; \/\/ for use in stack-chunk frames\n+  };\n@@ -361,2 +369,4 @@\n-  \/\/ frame pointer for this frame\n-  intptr_t* _fp;\n+  union {\n+    intptr_t* _fp;  \/\/ frame pointer\n+    int _offset_fp; \/\/ relative frame pointer for use in stack-chunk frames\n+  };\n@@ -367,1 +377,4 @@\n-  intptr_t* fp() const { return _fp; }\n+  intptr_t* fp() const { assert_absolute(); return _fp; }\n+  void set_fp(intptr_t* newfp)  { _fp = newfp; }\n+  int offset_fp() const         { assert_offset();  return _offset_fp; }\n+  void set_offset_fp(int value) { assert_on_heap(); _offset_fp = value; }\n@@ -383,0 +396,1 @@\n+  inline frame(intptr_t* sp, intptr_t* fp, address pc);\n@@ -384,0 +398,2 @@\n+  inline frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map);\n+  inline frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map, bool on_heap);\n@@ -414,3 +430,14 @@\n-    pc_return_offset = 0,\n-    metadata_words   = 0,\n-    frame_alignment  = 16,\n+    pc_return_offset                       = 0,\n+    \/\/ size, in words, of frame metadata (e.g. pc and link)\n+    metadata_words                         = sizeof(abi_minframe) >> LogBytesPerWord,\n+    \/\/ size, in words, of metadata at frame bottom, i.e. it is not part of the\n+    \/\/ caller\/callee overlap\n+    metadata_words_at_bottom               = 0,\n+    \/\/ size, in words, of frame metadata at the frame top, i.e. it is located\n+    \/\/ between a callee frame and its stack arguments, where it is part\n+    \/\/ of the caller\/callee overlap\n+    metadata_words_at_top                  = sizeof(abi_minframe) >> LogBytesPerWord,\n+    \/\/ size, in words, of frame metadata at the frame top that needs\n+    \/\/ to be reserved for callee functions in the runtime\n+    frame_alignment                        = 16,\n+    frame_alignment_in_words               = frame_alignment >> LogBytesPerWord,\n@@ -418,1 +445,1 @@\n-    align_wiggle     =  1\n+    align_wiggle                           =  1\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.hpp","additions":35,"deletions":8,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -29,1 +29,2 @@\n-#include \"code\/codeCache.hpp\"\n+#include \"code\/codeBlob.inline.hpp\"\n+#include \"code\/codeCache.inline.hpp\"\n@@ -47,4 +48,0 @@\n-  if (_fp == nullptr) {\n-    _fp = (intptr_t*)own_abi()->callers_sp;\n-  }\n-\n@@ -55,3 +52,11 @@\n-  \/\/ When thawing continuation frames the _unextended_sp passed to the constructor is not aligend\n-  assert(_on_heap || (is_aligned(_sp, alignment_in_bytes) && is_aligned(_fp, alignment_in_bytes)),\n-         \"invalid alignment sp:\" PTR_FORMAT \" unextended_sp:\" PTR_FORMAT \" fp:\" PTR_FORMAT, p2i(_sp), p2i(_unextended_sp), p2i(_fp));\n+  if (_fp == nullptr) {\n+    \/\/ The back link for compiled frames on the heap is not valid\n+    if (is_heap_frame()) {\n+      \/\/ fp for interpreted frames should have been derelativized and passed to the constructor\n+      assert(is_compiled_frame(), \"\");\n+      \/\/ The back link for compiled frames on the heap is invalid.\n+      _fp = _unextended_sp + _cb->frame_size();\n+    } else {\n+      _fp = (intptr_t*)own_abi()->callers_sp;\n+    }\n+  }\n@@ -64,1 +69,1 @@\n-           \"original PC must be in the main code section of the the compiled method (or must be immediately following it)\");\n+           \"original PC must be in the main code section of the compiled method (or must be immediately following it)\");\n@@ -73,1 +78,4 @@\n-  assert(_on_heap || is_aligned(_sp, frame::frame_alignment), \"SP must be 16-byte aligned\");\n+  \/\/ Continuation frames on the java heap are not aligned.\n+  \/\/ When thawing interpreted frames the sp can be unaligned (see new_stack_frame()).\n+  assert(_on_heap || (is_aligned(_sp, alignment_in_bytes) || is_interpreted_frame()) && is_aligned(_fp, alignment_in_bytes),\n+         \"invalid alignment sp:\" PTR_FORMAT \" unextended_sp:\" PTR_FORMAT \" fp:\" PTR_FORMAT, p2i(_sp), p2i(_unextended_sp), p2i(_fp));\n@@ -82,0 +90,4 @@\n+inline frame::frame(intptr_t* sp) : frame(sp, nullptr) {}\n+\n+inline frame::frame(intptr_t* sp, intptr_t* fp, address pc) : frame(sp, pc, nullptr, fp, nullptr) {}\n+\n@@ -88,1 +100,24 @@\n-inline frame::frame(intptr_t* sp) : frame(sp, nullptr) {}\n+inline frame::frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map)\n+  : _sp(sp), _pc(pc), _cb(cb), _oop_map(oop_map),\n+    _on_heap(false), DEBUG_ONLY(_frame_index(-1) COMMA) _unextended_sp(unextended_sp), _fp(fp) {\n+  assert(_cb != nullptr, \"pc: \" INTPTR_FORMAT, p2i(pc));\n+  setup();\n+}\n+\n+inline frame::frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb,\n+                    const ImmutableOopMap* oop_map, bool on_heap)\n+                    : _sp(sp), _pc(pc), _cb(cb), _oop_map(oop_map), _deopt_state(not_deoptimized),\n+                      _on_heap(on_heap), DEBUG_ONLY(_frame_index(-1) COMMA) _unextended_sp(unextended_sp), _fp(fp) {\n+  \/\/ In thaw, non-heap frames use this constructor to pass oop_map.  I don't know why.\n+  assert(_on_heap || _cb != nullptr, \"these frames are always heap frames\");\n+  if (cb != nullptr) {\n+    setup();\n+  }\n+#ifdef ASSERT\n+  \/\/ The following assertion has been disabled because it would sometime trap for Continuation.run,\n+  \/\/ which is not *in* a continuation and therefore does not clear the _cont_fastpath flag, but this\n+  \/\/ is benign even in fast mode (see Freeze::setup_jump)\n+  \/\/ We might freeze deoptimized frame in slow mode\n+  \/\/ assert(_pc == pc && _deopt_state == not_deoptimized, \"\");\n+#endif\n+}\n@@ -114,5 +149,8 @@\n-\/\/ c2i adapter. This is needed by deoptimization for ignoring c2i adapter\n-\/\/ frames.\n-inline intptr_t* frame::unextended_sp() const {\n-  return _unextended_sp;\n-}\n+\/\/ c2i adapter.\n+\/\/ i2c adapters also modify the frame they are applied on but shared code\n+\/\/ must never use an interpreted frames unextended sp directly as the value\n+\/\/ is platform dependent.\n+inline intptr_t* frame::unextended_sp() const          { assert_absolute(); return _unextended_sp; }\n+inline void frame::set_unextended_sp(intptr_t* value)  { _unextended_sp = value; }\n+inline int  frame::offset_unextended_sp() const        { assert_offset();   return _offset_unextended_sp; }\n+inline void frame::set_offset_unextended_sp(int value) { assert_on_heap();  _offset_unextended_sp = value; }\n@@ -153,1 +191,1 @@\n-  return (intptr_t**) &(get_ijava_state()->locals);\n+  return (intptr_t**)addr_at(ijava_idx(locals));\n@@ -186,1 +224,1 @@\n-  return (intptr_t*) get_ijava_state()->esp;\n+  return (intptr_t*) at(ijava_idx(esp));\n@@ -197,1 +235,2 @@\n-  return (intptr_t*)interpreter_frame_monitor_end() - 1;\n+  intptr_t* monitor_end = (intptr_t*) interpreter_frame_monitor_end();\n+  return monitor_end-1;\n@@ -202,1 +241,1 @@\n-  return ((intptr_t*) get_ijava_state()->esp) + Interpreter::stackElementWords;\n+  return (intptr_t*)at(ijava_idx(esp)) + Interpreter::stackElementWords;\n@@ -229,2 +268,2 @@\n-inline oop frame::saved_oop_result(RegisterMap* map) const {\n-  return *((oop*)map->location(R3->as_VMReg(), nullptr));\n+inline bool frame::is_interpreted_frame() const  {\n+  return Interpreter::contains(pc());\n@@ -233,3 +272,4 @@\n-inline void frame::set_saved_oop_result(RegisterMap* map, oop obj) {\n-  *((oop*)map->location(R3->as_VMReg(), nullptr)) = obj;\n-}\n+inline frame frame::sender_raw(RegisterMap* map) const {\n+  \/\/ Default is we do have to follow them. The sender_for_xxx will\n+  \/\/ update it accordingly.\n+  map->set_include_argument_oops(false);\n@@ -237,10 +277,2 @@\n-inline const ImmutableOopMap* frame::get_oop_map() const {\n-  if (_cb == NULL) return NULL;\n-  if (_cb->oop_maps() != NULL) {\n-    NativePostCallNop* nop = nativePostCallNop_at(_pc);\n-    if (nop != NULL && nop->displacement() != 0) {\n-      int slot = ((nop->displacement() >> 24) & 0xff);\n-      return _cb->oop_map_for_slot(slot, _pc);\n-    }\n-    const ImmutableOopMap* oop_map = OopMapSet::find_map(this);\n-    return oop_map;\n+  if (map->in_cont()) { \/\/ already in an h-stack\n+    return map->stack_chunk()->sender(*this, map);\n@@ -248,2 +280,0 @@\n-  return NULL;\n-}\n@@ -251,4 +281,2 @@\n-inline int frame::compiled_frame_stack_argsize() const {\n-  Unimplemented();\n-  return 0;\n-}\n+  if (is_entry_frame())           return sender_for_entry_frame(map);\n+  if (is_interpreted_frame())     return sender_for_interpreter_frame(map);\n@@ -256,17 +284,2 @@\n-inline void frame::interpreted_frame_oop_map(InterpreterOopMap* mask) const {\n-  Unimplemented();\n-}\n-\n-inline int frame::sender_sp_ret_address_offset() {\n-  Unimplemented();\n-  return 0;\n-}\n-\n-inline void frame::set_unextended_sp(intptr_t* value) {\n-  Unimplemented();\n-}\n-\n-inline int frame::offset_unextended_sp() const {\n-  Unimplemented();\n-  return 0;\n-}\n+  assert(_cb == CodeCache::find_blob(pc()), \"Must be the same\");\n+  if (_cb != nullptr) return sender_for_compiled_frame(map);\n@@ -274,2 +287,3 @@\n-inline void frame::set_offset_unextended_sp(int value) {\n-  Unimplemented();\n+  \/\/ Must be native-compiled frame, i.e. the marshaling code for native\n+  \/\/ methods that exists in the core system.\n+  return frame(sender_sp(), sender_pc());\n@@ -278,4 +292,1 @@\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::sender\n-\n-frame frame::sender(RegisterMap* map) const {\n+inline frame frame::sender(RegisterMap* map) const {\n@@ -284,1 +295,1 @@\n-  if (map->process_frames()) {\n+  if (map->process_frames() && !map->in_cont()) {\n@@ -291,16 +302,0 @@\n-inline frame frame::sender_raw(RegisterMap* map) const {\n-  \/\/ Default is we do have to follow them. The sender_for_xxx will\n-  \/\/ update it accordingly.\n-  map->set_include_argument_oops(false);\n-\n-  if (is_entry_frame())       return sender_for_entry_frame(map);\n-  if (is_interpreted_frame()) return sender_for_interpreter_frame(map);\n-  assert(_cb == CodeCache::find_blob(pc()),\"Must be the same\");\n-\n-  if (_cb != nullptr) return sender_for_compiled_frame(map);\n-\n-  \/\/ Must be native-compiled frame, i.e. the marshaling code for native\n-  \/\/ methods that exists in the core system.\n-  return frame(sender_sp(), sender_pc());\n-}\n-\n@@ -313,1 +308,0 @@\n-  \/\/ Now adjust the map.\n@@ -316,3 +310,21 @@\n-    map->set_include_argument_oops(_cb->caller_must_gc_arguments(map->thread()));\n-    if (_cb->oop_maps() != nullptr) {\n-      OopMapSet::update_register_map(this, map);\n+    \/\/ For C1, the runtime stub might not have oop maps, so set this flag\n+    \/\/ outside of update_register_map.\n+    if (!_cb->is_compiled()) { \/\/ compiled frames do not use callee-saved registers\n+      map->set_include_argument_oops(_cb->caller_must_gc_arguments(map->thread()));\n+      if (oop_map() != nullptr) {\n+        _oop_map->update_register_map(this, map);\n+      }\n+    } else {\n+      assert(!_cb->caller_must_gc_arguments(map->thread()), \"\");\n+      assert(!map->include_argument_oops(), \"\");\n+      assert(oop_map() == NULL || !oop_map()->has_any(OopMapValue::callee_saved_value), \"callee-saved value in compiled frame\");\n+    }\n+  }\n+\n+  assert(sender_sp != sp(), \"must have changed\");\n+\n+  if (Continuation::is_return_barrier_entry(sender_pc)) {\n+    if (map->walk_cont()) { \/\/ about to walk into an h-stack\n+      return Continuation::top_frame(*this, map);\n+    } else {\n+      return Continuation::continuation_bottom_sender(map->thread(), *this, sender_sp);\n@@ -325,0 +337,43 @@\n+inline oop frame::saved_oop_result(RegisterMap* map) const {\n+  oop* result_adr = (oop *)map->location(R3->as_VMReg(), sp());\n+  guarantee(result_adr != NULL, \"bad register save location\");\n+  return *result_adr;\n+}\n+\n+inline void frame::set_saved_oop_result(RegisterMap* map, oop obj) {\n+  oop* result_adr = (oop *)map->location(R3->as_VMReg(), sp());\n+  guarantee(result_adr != NULL, \"bad register save location\");\n+\n+  *result_adr = obj;\n+}\n+\n+inline const ImmutableOopMap* frame::get_oop_map() const {\n+  if (_cb == NULL) return NULL;\n+  if (_cb->oop_maps() != NULL) {\n+    NativePostCallNop* nop = nativePostCallNop_at(_pc);\n+    if (nop != NULL && nop->displacement() != 0) {\n+      int slot = ((nop->displacement() >> 24) & 0xff);\n+      return _cb->oop_map_for_slot(slot, _pc);\n+    }\n+    const ImmutableOopMap* oop_map = OopMapSet::find_map(this);\n+    return oop_map;\n+  }\n+  return NULL;\n+}\n+\n+inline int frame::compiled_frame_stack_argsize() const {\n+  assert(cb()->is_compiled(), \"\");\n+  return (cb()->as_compiled_method()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n+}\n+\n+inline void frame::interpreted_frame_oop_map(InterpreterOopMap* mask) const {\n+  assert(mask != NULL, \"\");\n+  Method* m = interpreter_frame_method();\n+  int   bci = interpreter_frame_bci();\n+  m->mask_for(bci, mask); \/\/ OopMapCache::compute_one_oop_map(m, bci, mask);\n+}\n+\n+inline int frame::sender_sp_ret_address_offset() {\n+  return -(int)(_abi0(lr) >> LogBytesPerWord); \/\/ offset in words\n+}\n+\n@@ -327,1 +382,1 @@\n-  Unimplemented();\n+  \/\/ Nothing to do.\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.inline.hpp","additions":141,"deletions":86,"binary":false,"changes":227,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+#define SUPPORT_MONITOR_COUNT\n+\n","filename":"src\/hotspot\/cpu\/ppc\/globalDefinitions_ppc.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-define_pd_global(bool,  VMContinuations, false);\n+define_pd_global(bool,  VMContinuations, true);\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-  void restore_interpreter_state(Register scratch, bool bcp_and_mdx_only = false);\n+  void restore_interpreter_state(Register scratch, bool bcp_and_mdx_only = false, bool restore_top_frame_sp = false);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -897,0 +897,1 @@\n+  pop_cont_fastpath();\n@@ -930,1 +931,1 @@\n-    Label done;\n+    Label count_locking, done;\n@@ -975,1 +976,1 @@\n-    b(done);\n+    b(count_locking);\n@@ -997,1 +998,1 @@\n-    b(done);\n+    b(count_locking);\n@@ -1007,0 +1008,1 @@\n+    b(done);\n@@ -1009,0 +1011,2 @@\n+    bind(count_locking);\n+    inc_held_monitor_count(current_header \/*tmp*\/);\n@@ -1098,0 +1102,1 @@\n+    dec_held_monitor_count(current_header \/*tmp*\/);\n@@ -2167,1 +2172,1 @@\n-void InterpreterMacroAssembler::restore_interpreter_state(Register scratch, bool bcp_and_mdx_only) {\n+void InterpreterMacroAssembler::restore_interpreter_state(Register scratch, bool bcp_and_mdx_only, bool restore_top_frame_sp) {\n@@ -2169,0 +2174,9 @@\n+  if (restore_top_frame_sp) {\n+    \/\/ After thawing the top frame of a continuation we reach here with frame::abi_minframe.\n+    \/\/ therefore we have to restore top_frame_sp before the assertion below.\n+    assert(!bcp_and_mdx_only, \"chose other registers\");\n+    Register tfsp = R18_locals;\n+    Register scratch2 = R26_monitor;\n+    ld(tfsp, _ijava_state_neg(top_frame_sp), scratch);\n+    resize_frame_absolute(tfsp, scratch2, R0);\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1183,0 +1183,8 @@\n+void MacroAssembler::post_call_nop() {\n+  \/\/ Make inline again when loom is always enabled.\n+  if (!Continuations::enabled()) {\n+    return;\n+  }\n+  nop();\n+}\n+\n@@ -2627,0 +2635,1 @@\n+  Label success, failure;\n@@ -2635,1 +2644,1 @@\n-    bne(flag, cont);\n+    bne(flag, failure);\n@@ -2673,0 +2682,3 @@\n+    \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n+    \/\/ object and we have now locked it.\n+    b(success);\n@@ -2676,0 +2688,1 @@\n+    b(failure);\n@@ -2678,4 +2691,0 @@\n-  \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-  \/\/ object and we have now locked it.\n-  b(cont);\n-\n@@ -2696,1 +2705,0 @@\n-  \/\/ Handle existing monitor.\n@@ -2699,0 +2707,1 @@\n+  \/\/ Handle existing monitor.\n@@ -2723,1 +2732,1 @@\n-  beq(flag, cont);\n+  beq(flag, success);\n@@ -2727,1 +2736,1 @@\n-  bne(flag, cont);\n+  bne(flag, failure);\n@@ -2740,1 +2749,1 @@\n-  \/\/ flag == EQ indicates success\n+  \/\/ flag == EQ indicates success, increment held monitor count\n@@ -2742,0 +2751,4 @@\n+  bne(flag, failure);\n+  bind(success);\n+  inc_held_monitor_count(temp);\n+  bind(failure);\n@@ -2749,1 +2762,2 @@\n-  Label cont, object_has_monitor, notRecursive;\n+  Label object_has_monitor, notRecursive;\n+  Label success, failure;\n@@ -2759,1 +2773,1 @@\n-    b(cont);                                                    \/\/ ... and we're done\n+    b(success);                                                 \/\/ ... and we're done\n@@ -2770,1 +2784,1 @@\n-    beq(flag, cont);\n+    beq(flag, success);\n@@ -2792,1 +2806,1 @@\n-             &cont);\n+             &failure);\n@@ -2794,0 +2808,1 @@\n+    b(success);\n@@ -2797,0 +2812,1 @@\n+    b(failure);\n@@ -2800,2 +2816,0 @@\n-  b(cont);\n-\n@@ -2815,1 +2829,1 @@\n-    b(cont);\n+    b(success);\n@@ -2823,1 +2837,1 @@\n-  bne(flag, cont);\n+  bne(flag, failure);\n@@ -2828,1 +2842,1 @@\n-  b(cont); \/\/ flag is already EQ here.\n+  b(success); \/\/ flag is already EQ here.\n@@ -2835,1 +2849,1 @@\n-  bne(flag, cont);\n+  bne(flag, failure);\n@@ -2839,2 +2853,1 @@\n-  bind(cont);\n-  \/\/ flag == EQ indicates success\n+  \/\/ flag == EQ indicates success, decrement held monitor count\n@@ -2842,0 +2855,3 @@\n+  bind(success);\n+  dec_held_monitor_count(temp);\n+  bind(failure);\n@@ -4373,0 +4389,45 @@\n+\n+void MacroAssembler::push_cont_fastpath() {\n+  Label done;\n+  ld_ptr(R0, JavaThread::cont_fastpath_offset(), R16_thread);\n+  cmpld(CCR0, R1_SP, R0);\n+  ble(CCR0, done);\n+  st_ptr(R1_SP, JavaThread::cont_fastpath_offset(), R16_thread);\n+  bind(done);\n+}\n+\n+void MacroAssembler::pop_cont_fastpath() {\n+  Label done;\n+  ld_ptr(R0, JavaThread::cont_fastpath_offset(), R16_thread);\n+  cmpld(CCR0, R1_SP, R0);\n+  ble(CCR0, done);\n+  li(R0, 0);\n+  st_ptr(R0, JavaThread::cont_fastpath_offset(), R16_thread);\n+  bind(done);\n+}\n+\n+void MacroAssembler::inc_held_monitor_count(Register tmp) {\n+  ld(tmp, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n+#ifdef ASSERT\n+  Label ok;\n+  cmpdi(CCR0, tmp, 0);\n+  bge_predict_taken(CCR0, ok);\n+  stop(\"held monitor count is negativ at increment\");\n+  bind(ok);\n+#endif\n+  addi(tmp, tmp, 1);\n+  std(tmp, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n+}\n+\n+void MacroAssembler::dec_held_monitor_count(Register tmp) {\n+  ld(tmp, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n+#ifdef ASSERT\n+  Label ok;\n+  cmpdi(CCR0, tmp, 0);\n+  bgt_predict_taken(CCR0, ok);\n+  stop(\"held monitor count is <= 0 at decrement\");\n+  bind(ok);\n+#endif\n+  addi(tmp, tmp, -1);\n+  std(tmp, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":82,"deletions":21,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+class OopMap;\n@@ -419,0 +420,2 @@\n+  void post_call_nop();\n+\n@@ -602,0 +605,5 @@\n+  void push_cont_fastpath();\n+  void pop_cont_fastpath();\n+  void inc_held_monitor_count(Register tmp);\n+  void dec_held_monitor_count(Register tmp);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  if (*(int*)addr != 0 \/*illtrap*\/) return false;\n+  if (!Assembler::is_illtrap(addr)) return false;\n@@ -427,0 +427,30 @@\n+\n+void NativePostCallNop::make_deopt() {\n+  NativeDeoptInstruction::insert(addr_at(0));\n+}\n+\n+void NativePostCallNop::patch(jint diff) {\n+  \/\/ unsupported for now\n+}\n+\n+void NativeDeoptInstruction::verify() {\n+}\n+\n+bool NativeDeoptInstruction::is_deopt_at(address code_pos) {\n+  if (!Assembler::is_illtrap(code_pos)) return false;\n+  CodeBlob* cb = CodeCache::find_blob(code_pos);\n+  if (cb == NULL || !cb->is_compiled()) return false;\n+  nmethod *nm = (nmethod *)cb;\n+  \/\/ see NativeInstruction::is_sigill_not_entrant_at()\n+  return nm->verified_entry_point() != code_pos;\n+}\n+\n+\/\/ Inserts an instruction which is specified to cause a SIGILL at a given pc\n+void NativeDeoptInstruction::insert(address code_pos) {\n+  ResourceMark rm;\n+  int code_size = 1 * BytesPerInstWord;\n+  CodeBuffer cb(code_pos, code_size + 1);\n+  MacroAssembler* a = new MacroAssembler(&cb);\n+  a->illtrap();\n+  ICache::ppc64_flush_icache_bytes(code_pos, code_size);\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.cpp","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -54,1 +54,3 @@\n-  bool is_jump() { return Assembler::is_b(long_at(0)); } \/\/ See NativeGeneralJump.\n+  bool is_nop() const { return Assembler::is_nop(long_at(0)); }\n+\n+  bool is_jump() const { return Assembler::is_b(long_at(0)); } \/\/ See NativeGeneralJump.\n@@ -508,1 +510,1 @@\n-  bool check() const { Unimplemented(); return false; }\n+  bool check() const { return is_nop(); }\n@@ -510,2 +512,2 @@\n-  void patch(jint diff) { Unimplemented(); }\n-  void make_deopt() { Unimplemented(); }\n+  void patch(jint diff);\n+  void make_deopt();\n@@ -515,1 +517,4 @@\n-  \/\/ Unimplemented();\n+  NativePostCallNop* nop = (NativePostCallNop*) address;\n+  if (nop->check()) {\n+    return nop;\n+  }\n@@ -520,3 +525,5 @@\n-public:\n-  address instruction_address() const       { Unimplemented(); return NULL; }\n-  address next_instruction_address() const  { Unimplemented(); return NULL; }\n+ public:\n+  enum {\n+    instruction_size            =    4,\n+    instruction_offset          =    0,\n+  };\n@@ -524,1 +531,2 @@\n-  void  verify() { Unimplemented(); }\n+  address instruction_address() const       { return addr_at(instruction_offset); }\n+  address next_instruction_address() const  { return addr_at(instruction_size); }\n@@ -526,4 +534,3 @@\n-  static bool is_deopt_at(address instr) {\n-    \/\/ Unimplemented();\n-    return false;\n-  }\n+  void  verify();\n+\n+  static bool is_deopt_at(address code_pos);\n@@ -532,3 +539,1 @@\n-  static void insert(address code_pos) {\n-    Unimplemented();\n-  }\n+  static void insert(address code_pos);\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.hpp","additions":21,"deletions":16,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -3450,0 +3450,1 @@\n+    __ post_call_nop();\n@@ -3490,0 +3491,1 @@\n+    __ post_call_nop();\n@@ -3604,0 +3606,1 @@\n+    __ post_call_nop();\n@@ -3615,0 +3618,1 @@\n+    __ post_call_nop();\n@@ -3630,0 +3634,1 @@\n+    __ post_call_nop();\n@@ -14381,1 +14386,1 @@\n-  size(4);\n+  size(Continuations::enabled() ? 8 : 4);\n@@ -14402,1 +14407,1 @@\n-  size(4);\n+  size(Continuations::enabled() ? 8 : 4);\n@@ -14480,1 +14485,1 @@\n-  size(4);\n+  size(Continuations::enabled() ? 8 : 4);\n@@ -14483,0 +14488,1 @@\n+    __ post_call_nop();\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -524,1 +524,1 @@\n-constexpr Register R15_esp       = R15;\n+constexpr Register R15_esp       = R15;      \/\/ slot below top of expression stack for ld\/st with update\n@@ -527,1 +527,1 @@\n-constexpr Register R17_tos       = R17;      \/\/ address of Java tos (prepushed).\n+constexpr Register R17_tos       = R17;      \/\/ The interpreter's top of (expression) stack cache register\n","filename":"src\/hotspot\/cpu\/ppc\/register_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"code\/compiledIC.hpp\"\n@@ -40,0 +41,2 @@\n+#include \"runtime\/continuation.hpp\"\n+#include \"runtime\/continuationEntry.inline.hpp\"\n@@ -629,0 +632,3 @@\n+STATIC_ASSERT(num_java_iarg_registers == Argument::n_int_register_parameters_j);\n+STATIC_ASSERT(num_java_farg_registers == Argument::n_float_register_parameters_j);\n+\n@@ -1177,0 +1183,2 @@\n+  __ push_cont_fastpath(); \/\/ Set JavaThread::_cont_fastpath to the sp of the oldest interpreted frame we know about\n+\n@@ -1621,0 +1629,371 @@\n+\/\/---------------------------- continuation_enter_setup ---------------------------\n+\/\/\n+\/\/ Frame setup.\n+\/\/\n+\/\/ Arguments:\n+\/\/   None.\n+\/\/\n+\/\/ Results:\n+\/\/   R1_SP: pointer to blank ContinuationEntry in the pushed frame.\n+\/\/\n+\/\/ Kills:\n+\/\/   R0, R20\n+\/\/\n+static OopMap* continuation_enter_setup(MacroAssembler* masm, int& framesize_words) {\n+  assert(ContinuationEntry::size() % VMRegImpl::stack_slot_size == 0, \"\");\n+  assert(in_bytes(ContinuationEntry::cont_offset())  % VMRegImpl::stack_slot_size == 0, \"\");\n+  assert(in_bytes(ContinuationEntry::chunk_offset()) % VMRegImpl::stack_slot_size == 0, \"\");\n+\n+  const int frame_size_in_bytes = (int)ContinuationEntry::size();\n+  assert(is_aligned(frame_size_in_bytes, frame::alignment_in_bytes), \"alignment error\");\n+\n+  framesize_words = frame_size_in_bytes \/ wordSize;\n+\n+  DEBUG_ONLY(__ block_comment(\"setup {\"));\n+  \/\/ Save return pc and push entry frame\n+  const Register return_pc = R20;\n+  __ mflr(return_pc);\n+  __ std(return_pc, _abi0(lr), R1_SP);     \/\/ SP->lr = return_pc\n+  __ push_frame(frame_size_in_bytes , R0); \/\/ SP -= frame_size_in_bytes\n+\n+  OopMap* map = new OopMap((int)frame_size_in_bytes \/ VMRegImpl::stack_slot_size, 0 \/* arg_slots*\/);\n+\n+  __ ld_ptr(R0, JavaThread::cont_entry_offset(), R16_thread);\n+  __ st_ptr(R1_SP, JavaThread::cont_entry_offset(), R16_thread);\n+  __ st_ptr(R0, ContinuationEntry::parent_offset(), R1_SP);\n+  DEBUG_ONLY(__ block_comment(\"} setup\"));\n+\n+  return map;\n+}\n+\n+\/\/---------------------------- fill_continuation_entry ---------------------------\n+\/\/\n+\/\/ Initialize the new ContinuationEntry.\n+\/\/\n+\/\/ Arguments:\n+\/\/   R1_SP: pointer to blank Continuation entry\n+\/\/   reg_cont_obj: pointer to the continuation\n+\/\/   reg_flags: flags\n+\/\/\n+\/\/ Results:\n+\/\/   R1_SP: pointer to filled out ContinuationEntry\n+\/\/\n+\/\/ Kills:\n+\/\/   R8_ARG6, R9_ARG7, R10_ARG8\n+\/\/\n+static void fill_continuation_entry(MacroAssembler* masm, Register reg_cont_obj, Register reg_flags) {\n+  assert_different_registers(reg_cont_obj, reg_flags);\n+  Register zero = R8_ARG6;\n+  Register tmp2 = R9_ARG7;\n+  Register tmp3 = R10_ARG8;\n+\n+  DEBUG_ONLY(__ block_comment(\"fill {\"));\n+#ifdef ASSERT\n+  __ load_const_optimized(tmp2, ContinuationEntry::cookie_value());\n+  __ stw(tmp2, in_bytes(ContinuationEntry::cookie_offset()), R1_SP);\n+#endif \/\/ASSERT\n+\n+  __ li(zero, 0);\n+  __ st_ptr(reg_cont_obj, ContinuationEntry::cont_offset(), R1_SP);\n+  __ stw(reg_flags, in_bytes(ContinuationEntry::flags_offset()), R1_SP);\n+  __ st_ptr(zero, ContinuationEntry::chunk_offset(), R1_SP);\n+  __ stw(zero, in_bytes(ContinuationEntry::argsize_offset()), R1_SP);\n+  __ stw(zero, in_bytes(ContinuationEntry::pin_count_offset()), R1_SP);\n+\n+  __ ld_ptr(tmp2, JavaThread::cont_fastpath_offset(), R16_thread);\n+  __ ld(tmp3, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n+  __ st_ptr(tmp2, ContinuationEntry::parent_cont_fastpath_offset(), R1_SP);\n+  __ std(tmp3, in_bytes(ContinuationEntry::parent_held_monitor_count_offset()), R1_SP);\n+\n+  __ st_ptr(zero, JavaThread::cont_fastpath_offset(), R16_thread);\n+  __ std(zero, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n+  DEBUG_ONLY(__ block_comment(\"} fill\"));\n+}\n+\n+\/\/---------------------------- continuation_enter_cleanup ---------------------------\n+\/\/\n+\/\/ Copy corresponding attributes from the top ContinuationEntry to the JavaThread\n+\/\/ before deleting it.\n+\/\/\n+\/\/ Arguments:\n+\/\/   R1_SP: pointer to the ContinuationEntry\n+\/\/\n+\/\/ Results:\n+\/\/   None.\n+\/\/\n+\/\/ Kills:\n+\/\/   R8_ARG6, R9_ARG7, R10_ARG8\n+\/\/\n+static void continuation_enter_cleanup(MacroAssembler* masm) {\n+  Register tmp1 = R8_ARG6;\n+  Register tmp2 = R9_ARG7;\n+  Register tmp3 = R10_ARG8;\n+\n+#ifdef ASSERT\n+  __ block_comment(\"clean {\");\n+  __ ld_ptr(tmp1, JavaThread::cont_entry_offset(), R16_thread);\n+  __ cmpd(CCR0, R1_SP, tmp1);\n+  __ asm_assert_eq(FILE_AND_LINE \": incorrect R1_SP\");\n+#endif\n+\n+  __ ld_ptr(tmp1, ContinuationEntry::parent_cont_fastpath_offset(), R1_SP);\n+  __ ld(tmp2, in_bytes(ContinuationEntry::parent_held_monitor_count_offset()), R1_SP);\n+  __ ld_ptr(tmp3, ContinuationEntry::parent_offset(), R1_SP);\n+  __ st_ptr(tmp1, JavaThread::cont_fastpath_offset(), R16_thread);\n+  __ std(tmp2, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n+  __ st_ptr(tmp3, JavaThread::cont_entry_offset(), R16_thread);\n+  DEBUG_ONLY(__ block_comment(\"} clean\"));\n+}\n+\n+static void check_continuation_enter_argument(VMReg actual_vmreg,\n+                                              Register expected_reg,\n+                                              const char* name) {\n+  assert(!actual_vmreg->is_stack(), \"%s cannot be on stack\", name);\n+  assert(actual_vmreg->as_Register() == expected_reg,\n+         \"%s is in unexpected register: %s instead of %s\",\n+         name, actual_vmreg->as_Register()->name(), expected_reg->name());\n+}\n+\n+static void gen_continuation_enter(MacroAssembler* masm,\n+                                   const VMRegPair* regs,\n+                                   int& exception_offset,\n+                                   OopMapSet* oop_maps,\n+                                   int& frame_complete,\n+                                   int& framesize_words,\n+                                   int& interpreted_entry_offset,\n+                                   int& compiled_entry_offset) {\n+\n+  \/\/ enterSpecial(Continuation c, boolean isContinue, boolean isVirtualThread)\n+  int pos_cont_obj   = 0;\n+  int pos_is_cont    = 1;\n+  int pos_is_virtual = 2;\n+\n+  \/\/ The platform-specific calling convention may present the arguments in various registers.\n+  \/\/ To simplify the rest of the code, we expect the arguments to reside at these known\n+  \/\/ registers, and we additionally check the placement here in case calling convention ever\n+  \/\/ changes.\n+  Register reg_cont_obj   = R3_ARG1;\n+  Register reg_is_cont    = R4_ARG2;\n+  Register reg_is_virtual = R5_ARG3;\n+\n+  check_continuation_enter_argument(regs[pos_cont_obj].first(),   reg_cont_obj,   \"Continuation object\");\n+  check_continuation_enter_argument(regs[pos_is_cont].first(),    reg_is_cont,    \"isContinue\");\n+  check_continuation_enter_argument(regs[pos_is_virtual].first(), reg_is_virtual, \"isVirtualThread\");\n+\n+  address resolve_static_call = SharedRuntime::get_resolve_static_call_stub();\n+\n+  address start = __ pc();\n+\n+  Label L_thaw, L_exit;\n+\n+  \/\/ i2i entry used at interp_only_mode only\n+  interpreted_entry_offset = __ pc() - start;\n+  {\n+#ifdef ASSERT\n+    Label is_interp_only;\n+    __ lwz(R0, in_bytes(JavaThread::interp_only_mode_offset()), R16_thread);\n+    __ cmpwi(CCR0, R0, 0);\n+    __ bne(CCR0, is_interp_only);\n+    __ stop(\"enterSpecial interpreter entry called when not in interp_only_mode\");\n+    __ bind(is_interp_only);\n+#endif\n+\n+    \/\/ Read interpreter arguments into registers (this is an ad-hoc i2c adapter)\n+    __ ld(reg_cont_obj,    Interpreter::stackElementSize*3, R15_esp);\n+    __ lwz(reg_is_cont,    Interpreter::stackElementSize*2, R15_esp);\n+    __ lwz(reg_is_virtual, Interpreter::stackElementSize*1, R15_esp);\n+\n+    __ push_cont_fastpath();\n+\n+    OopMap* map = continuation_enter_setup(masm, framesize_words);\n+\n+    \/\/ The frame is complete here, but we only record it for the compiled entry, so the frame would appear unsafe,\n+    \/\/ but that's okay because at the very worst we'll miss an async sample, but we're in interp_only_mode anyway.\n+\n+    fill_continuation_entry(masm, reg_cont_obj, reg_is_virtual);\n+\n+    \/\/ If isContinue, call to thaw. Otherwise, call Continuation.enter(Continuation c, boolean isContinue)\n+    __ cmpwi(CCR0, reg_is_cont, 0);\n+    __ bne(CCR0, L_thaw);\n+\n+    \/\/ --- call Continuation.enter(Continuation c, boolean isContinue)\n+\n+    \/\/ Emit compiled static call. The call will be always resolved to the c2i\n+    \/\/ entry of Continuation.enter(Continuation c, boolean isContinue).\n+    \/\/ There are special cases in SharedRuntime::resolve_static_call_C() and\n+    \/\/ SharedRuntime::resolve_sub_helper_internal() to achieve this\n+    \/\/ See also corresponding call below.\n+    address c2i_call_pc = __ pc();\n+    int start_offset = __ offset();\n+    \/\/ Put the entry point as a constant into the constant pool.\n+    const address entry_point_toc_addr   = __ address_constant(resolve_static_call, RelocationHolder::none);\n+    const int     entry_point_toc_offset = __ offset_to_method_toc(entry_point_toc_addr);\n+    guarantee(entry_point_toc_addr != nullptr, \"const section overflow\");\n+\n+    \/\/ Emit the trampoline stub which will be related to the branch-and-link below.\n+    address stub = __ emit_trampoline_stub(entry_point_toc_offset, start_offset);\n+    guarantee(stub != nullptr, \"no space for trampoline stub\");\n+\n+    __ relocate(relocInfo::static_call_type);\n+    \/\/ Note: At this point we do not have the address of the trampoline\n+    \/\/ stub, and the entry point might be too far away for bl, so __ pc()\n+    \/\/ serves as dummy and the bl will be patched later.\n+    __ bl(__ pc());\n+    oop_maps->add_gc_map(__ pc() - start, map);\n+    __ post_call_nop();\n+\n+    __ b(L_exit);\n+\n+    \/\/ static stub for the call above\n+    CodeBuffer* cbuf = masm->code_section()->outer();\n+    stub = CompiledStaticCall::emit_to_interp_stub(*cbuf, c2i_call_pc);\n+    guarantee(stub != nullptr, \"no space for static stub\");\n+  }\n+\n+  \/\/ compiled entry\n+  __ align(CodeEntryAlignment);\n+  compiled_entry_offset = __ pc() - start;\n+\n+  OopMap* map = continuation_enter_setup(masm, framesize_words);\n+\n+  \/\/ Frame is now completed as far as size and linkage.\n+  frame_complete =__ pc() - start;\n+\n+  fill_continuation_entry(masm, reg_cont_obj, reg_is_virtual);\n+\n+  \/\/ If isContinue, call to thaw. Otherwise, call Continuation.enter(Continuation c, boolean isContinue)\n+  __ cmpwi(CCR0, reg_is_cont, 0);\n+  __ bne(CCR0, L_thaw);\n+\n+  \/\/ --- call Continuation.enter(Continuation c, boolean isContinue)\n+\n+  \/\/ Emit compiled static call\n+  \/\/ The call needs to be resolved. There's a special case for this in\n+  \/\/ SharedRuntime::find_callee_info_helper() which calls\n+  \/\/ LinkResolver::resolve_continuation_enter() which resolves the call to\n+  \/\/ Continuation.enter(Continuation c, boolean isContinue).\n+  address call_pc = __ pc();\n+  int start_offset = __ offset();\n+  \/\/ Put the entry point as a constant into the constant pool.\n+  const address entry_point_toc_addr   = __ address_constant(resolve_static_call, RelocationHolder::none);\n+  const int     entry_point_toc_offset = __ offset_to_method_toc(entry_point_toc_addr);\n+  guarantee(entry_point_toc_addr != nullptr, \"const section overflow\");\n+\n+  \/\/ Emit the trampoline stub which will be related to the branch-and-link below.\n+  address stub = __ emit_trampoline_stub(entry_point_toc_offset, start_offset);\n+  guarantee(stub != nullptr, \"no space for trampoline stub\");\n+\n+  __ relocate(relocInfo::static_call_type);\n+  \/\/ Note: At this point we do not have the address of the trampoline\n+  \/\/ stub, and the entry point might be too far away for bl, so __ pc()\n+  \/\/ serves as dummy and the bl will be patched later.\n+  __ bl(__ pc());\n+  oop_maps->add_gc_map(__ pc() - start, map);\n+  __ post_call_nop();\n+\n+  __ b(L_exit);\n+\n+  \/\/ --- Thawing path\n+\n+  __ bind(L_thaw);\n+  __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(StubRoutines::cont_thaw()));\n+  __ mtctr(R0);\n+  __ bctrl();\n+  oop_maps->add_gc_map(__ pc() - start, map->deep_copy());\n+  ContinuationEntry::_return_pc_offset = __ pc() - start;\n+  __ post_call_nop();\n+\n+  \/\/ --- Normal exit (resolve\/thawing)\n+\n+  __ bind(L_exit);\n+  continuation_enter_cleanup(masm);\n+\n+  \/\/ Pop frame and return\n+  DEBUG_ONLY(__ ld_ptr(R0, 0, R1_SP));\n+  __ addi(R1_SP, R1_SP, framesize_words*wordSize);\n+  DEBUG_ONLY(__ cmpd(CCR0, R0, R1_SP));\n+  __ asm_assert_eq(FILE_AND_LINE \": inconsistent frame size\");\n+  __ ld(R0, _abi0(lr), R1_SP); \/\/ Return pc\n+  __ mtlr(R0);\n+  __ blr();\n+\n+  \/\/ --- Exception handling path\n+\n+  exception_offset = __ pc() - start;\n+\n+  continuation_enter_cleanup(masm);\n+  Register ex_pc  = R17_tos;   \/\/ nonvolatile register\n+  Register ex_oop = R15_esp;   \/\/ nonvolatile register\n+  __ ld(ex_pc, _abi0(callers_sp), R1_SP); \/\/ Load caller's return pc\n+  __ ld(ex_pc, _abi0(lr), ex_pc);\n+  __ mr(ex_oop, R3_RET);                  \/\/ save return value containing the exception oop\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::exception_handler_for_return_address), R16_thread, ex_pc);\n+  __ mtlr(R3_RET);                        \/\/ the exception handler\n+  __ ld(R1_SP, _abi0(callers_sp), R1_SP); \/\/ remove enterSpecial frame\n+\n+  \/\/ Continue at exception handler\n+  \/\/ See OptoRuntime::generate_exception_blob for register arguments\n+  __ mr(R3_ARG1, ex_oop); \/\/ pass exception oop\n+  __ mr(R4_ARG2, ex_pc);  \/\/ pass exception pc\n+  __ blr();\n+\n+  \/\/ static stub for the call above\n+  CodeBuffer* cbuf = masm->code_section()->outer();\n+  stub = CompiledStaticCall::emit_to_interp_stub(*cbuf, call_pc);\n+  guarantee(stub != nullptr, \"no space for static stub\");\n+}\n+\n+static void gen_continuation_yield(MacroAssembler* masm,\n+                                   const VMRegPair* regs,\n+                                   OopMapSet* oop_maps,\n+                                   int& frame_complete,\n+                                   int& framesize_words,\n+                                   int& compiled_entry_offset) {\n+  Register tmp = R10_ARG8;\n+\n+  const int framesize_bytes = (int)align_up((int)frame::abi_reg_args_size, frame::alignment_in_bytes);\n+  framesize_words = framesize_bytes \/ wordSize;\n+\n+  address start = __ pc();\n+  compiled_entry_offset = __ pc() - start;\n+\n+  \/\/ Save return pc and push entry frame\n+  __ mflr(tmp);\n+  __ std(tmp, _abi0(lr), R1_SP);       \/\/ SP->lr = return_pc\n+  __ push_frame(framesize_bytes , R0); \/\/ SP -= frame_size_in_bytes\n+\n+  DEBUG_ONLY(__ block_comment(\"Frame Complete\"));\n+  frame_complete = __ pc() - start;\n+  address last_java_pc = __ pc();\n+\n+  \/\/ This nop must be exactly at the PC we push into the frame info.\n+  \/\/ We use this nop for fast CodeBlob lookup, associate the OopMap\n+  \/\/ with it right away.\n+  __ post_call_nop();\n+  OopMap* map = new OopMap(framesize_bytes \/ VMRegImpl::stack_slot_size, 1);\n+  oop_maps->add_gc_map(last_java_pc - start, map);\n+\n+  __ calculate_address_from_global_toc(tmp, last_java_pc); \/\/ will be relocated\n+  __ set_last_Java_frame(R1_SP, tmp);\n+  __ call_VM_leaf(Continuation::freeze_entry(), R16_thread, R1_SP);\n+  __ reset_last_Java_frame();\n+\n+  Label L_pinned;\n+\n+  __ cmpdi(CCR0, R3_RET, 0);\n+  __ bne(CCR0, L_pinned);\n+\n+  \/\/ Pop frames of continuation including this stub's frame\n+  __ ld_ptr(R1_SP, JavaThread::cont_entry_offset(), R16_thread);\n+  \/\/ The frame pushed by gen_continuation_enter is on top now again\n+  continuation_enter_cleanup(masm);\n+\n+  __ bind(L_pinned); \/\/ pinned -- return to caller\n+\n+  \/\/ Pop frame and return\n+  __ pop_frame();\n+  __ ld(R0, _abi0(lr), R1_SP); \/\/ Return pc\n+  __ mtlr(R0);\n+  __ blr();\n+}\n+\n@@ -1643,0 +2022,59 @@\n+  if (method->is_continuation_native_intrinsic()) {\n+    int exception_offset = -1;\n+    OopMapSet* oop_maps = new OopMapSet();\n+    int frame_complete = -1;\n+    int stack_slots = -1;\n+    int interpreted_entry_offset = -1;\n+    int vep_offset = -1;\n+    if (method->is_continuation_enter_intrinsic()) {\n+      gen_continuation_enter(masm,\n+                             in_regs,\n+                             exception_offset,\n+                             oop_maps,\n+                             frame_complete,\n+                             stack_slots,\n+                             interpreted_entry_offset,\n+                             vep_offset);\n+    } else if (method->is_continuation_yield_intrinsic()) {\n+      gen_continuation_yield(masm,\n+                             in_regs,\n+                             oop_maps,\n+                             frame_complete,\n+                             stack_slots,\n+                             vep_offset);\n+    } else {\n+      guarantee(false, \"Unknown Continuation native intrinsic\");\n+    }\n+\n+#ifdef ASSERT\n+    if (method->is_continuation_enter_intrinsic()) {\n+      assert(interpreted_entry_offset != -1, \"Must be set\");\n+      assert(exception_offset != -1,         \"Must be set\");\n+    } else {\n+      assert(interpreted_entry_offset == -1, \"Must be unset\");\n+      assert(exception_offset == -1,         \"Must be unset\");\n+    }\n+    assert(frame_complete != -1,    \"Must be set\");\n+    assert(stack_slots != -1,       \"Must be set\");\n+    assert(vep_offset != -1,        \"Must be set\");\n+#endif\n+\n+    __ flush();\n+    nmethod* nm = nmethod::new_native_nmethod(method,\n+                                              compile_id,\n+                                              masm->code(),\n+                                              vep_offset,\n+                                              frame_complete,\n+                                              stack_slots,\n+                                              in_ByteSize(-1),\n+                                              in_ByteSize(-1),\n+                                              oop_maps,\n+                                              exception_offset);\n+    if (method->is_continuation_enter_intrinsic()) {\n+      ContinuationEntry::set_enter_code(nm, interpreted_entry_offset);\n+    } else if (method->is_continuation_yield_intrinsic()) {\n+      _cont_doYield_stub = nm;\n+    }\n+    return nm;\n+  }\n+\n@@ -2354,1 +2792,1 @@\n-  return align_up((callee_locals - callee_parameters) * Interpreter::stackElementWords, frame::alignment_in_bytes);\n+  return align_up((callee_locals - callee_parameters) * Interpreter::stackElementWords, frame::frame_alignment_in_words);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":439,"deletions":1,"binary":false,"changes":440,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-\/\/ Java frames don't have callee saved registers (except for rfp), so we can use a smaller RegisterMap\n+\/\/ Java frames don't have callee saved registers, so we can use a smaller RegisterMap\n@@ -35,3 +35,0 @@\n-private:\n-  static void assert_is_rfp(VMReg r) NOT_DEBUG_RETURN\n-                                     DEBUG_ONLY({ Unimplemented(); })\n@@ -45,1 +42,2 @@\n-    Unimplemented();\n+    map->clear();\n+    map->set_include_argument_oops(this->include_argument_oops());\n@@ -52,1 +50,8 @@\n-    Unimplemented();\n+#ifdef ASSERT\n+  for(int i = 0; i < RegisterMap::reg_count; i++) {\n+    VMReg r = VMRegImpl::as_VMReg(i);\n+    if (map->location(r, (intptr_t*)nullptr) != nullptr) {\n+      assert(false, \"Reg: %s\", r->name()); \/\/ Should not reach here\n+    }\n+  }\n+#endif\n@@ -56,2 +61,2 @@\n-    Unimplemented();\n-    return NULL;\n+    assert(false, \"Reg: %s\", reg->name());\n+    return nullptr;\n@@ -60,1 +65,2 @@\n-  inline void set_location(VMReg reg, address loc) { assert_is_rfp(reg); }\n+  \/\/ Should not reach here\n+  inline void set_location(VMReg reg, address loc) { assert(false, \"Reg: %s\", reg->name()); }\n","filename":"src\/hotspot\/cpu\/ppc\/smallRegisterMap_ppc.inline.hpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -35,2 +35,6 @@\n-  Unimplemented();\n-  return true;\n+  assert(!is_done(), \"\");\n+  assert(is_compiled(), \"\");\n+  intptr_t* p = (intptr_t*)p0;\n+  int argsize = (_cb->as_compiled_method()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n+  int frame_size = _cb->frame_size() + (argsize > 0 ? argsize + frame::metadata_words_at_top : 0);\n+  return (p - unextended_sp()) >= 0 && (p - unextended_sp()) < frame_size;\n@@ -42,2 +46,6 @@\n-  Unimplemented();\n-  return frame();\n+  if (is_done()) {\n+    return frame(_sp, _sp, nullptr, nullptr, nullptr, nullptr, true);\n+  } else {\n+    \/\/ Compiled frames on heap don't have back links. See FreezeBase::patch_pd() and frame::setup().\n+    return frame(sp(), unextended_sp(), Interpreter::contains(pc()) ? fp() : nullptr, pc(), cb(), _oopmap, true);\n+  }\n@@ -48,2 +56,2 @@\n-  Unimplemented();\n-  return NULL;\n+  assert(!is_done(), \"\");\n+  return (address)((frame::abi_minframe*) _sp)->lr;\n@@ -54,2 +62,6 @@\n-  Unimplemented();\n-  return NULL;\n+  \/\/ See FreezeBase::patch_pd() and frame::setup()\n+  assert((frame_kind == ChunkFrames::Mixed && is_interpreted()), \"\");\n+  intptr_t* fp_addr = (intptr_t*)&((frame::abi_minframe*)_sp)->callers_sp;\n+  assert(*(intptr_t**)fp_addr != nullptr, \"\");\n+  \/\/ derelativize\n+  return fp_addr + *fp_addr;\n@@ -60,2 +72,3 @@\n-  Unimplemented();\n-  return NULL;\n+  intptr_t* fp = this->fp();\n+  assert(fp != nullptr, \"\");\n+  return fp + fp[offset];\n@@ -66,2 +79,2 @@\n-  Unimplemented();\n-  return NULL;\n+  assert_is_interpreted_and_frame_type_mixed();\n+  return derelativize(ijava_idx(esp)) + 1 - frame::metadata_words; \/\/ On PPC esp points to the next free slot\n@@ -78,1 +91,8 @@\n-  Unimplemented();\n+  assert_is_interpreted_and_frame_type_mixed();\n+  if (derelativize(ijava_idx(locals)) + 1 >= _end) {\n+    _unextended_sp = _end;\n+    _sp = _end;\n+  } else {\n+    _unextended_sp = derelativize(ijava_idx(sender_sp));\n+    _sp = this->fp();\n+  }\n@@ -81,0 +101,60 @@\n+\/\/ Details for the comment on StackChunkFrameStream<frame_kind>::frame_size()\n+\/\/\n+\/\/ Interpreted caller frames get extended even if the callee is also\n+\/\/ interpreted. This is done to accomodate non-parameter locals.\n+\/\/\n+\/\/ The size of a single frame is from the unextended sp to the bottom of the\n+\/\/ locals array. The combined size of caller\/callee is the single size with the\n+\/\/ overlap deducted. The overlap is the size of the call parameters plus the\n+\/\/ size of the metadata at the sp (frame::metadata_words_at_top).\n+\/\/\n+\/\/\n+\/\/ Case 1: no metadata between a frame                      Case 2: metadata is located between\n+\/\/         and its locals                                           a frame and its locals as on ppc64\n+\/\/\n+\/\/       |  | L0 aka P0            |                    |  | L0 aka P0            |\n+\/\/       |  | :      :             |                    |  | :      :             |\n+\/\/       |  | :      Pn            |                    |  | :      Pn            |\n+\/\/       |  | :                    |                    |  | :                    |\n+\/\/       |  | Lm                   |                    |  | Lm                   |\n+\/\/       |  ========================                    |  |----------------------|\n+\/\/    S0 |  | Frame F0             |                    |  | Metadata@top         |\n+\/\/       |  |                      |                 S0 |  |                      |\n+\/\/       |  |                      |                    |  |                      |\n+\/\/       |  |----------------------|                    |  |                      |\n+\/\/       || | L0 aka P0            |                    |  ========================\n+\/\/ over- || | :      :             |                    |  | Frame F0             |\n+\/\/ lap   || | :      Pn            |<- unext. SP        |  |                      |\n+\/\/        | | :                    |                    |  |                      |<- bottom_of_locals\n+\/\/        | | Lm                   |<- SP               |  |----------------------|\n+\/\/        | ========================                    || | L0 aka P0            |\n+\/\/        | | Frame F1             |                    || | :      :             |\n+\/\/     S1 | |                      |              over- || | :      Pn            |<- unext. SP\n+\/\/        | |                      |              lap   || | :                    |   + metadata_words_at_top\n+\/\/        | |----------------------|                    || | Lm                   |\n+\/\/        | | L0 aka P0            |                    || |----------------------|\n+\/\/        | | :      :             |                    || | Metadata@top         |\n+\/\/        | | :      Pn            |<- unext. SP        || |                      |<- unextended SP\n+\/\/          | :                    |                     | |                      |\n+\/\/          | Lm                   |<- SP                | |                      |<- SP\n+\/\/          ========================                     | ========================\n+\/\/                                                       | | Frame F1             |\n+\/\/                                                       | |                      |\n+\/\/                                                       | |                      |\n+\/\/                                                       | |----------------------|\n+\/\/    overlap = size of stackargs                     S1 | | L0 aka P0            |\n+\/\/                                                       | | :      :             |\n+\/\/                                                       | | :      Pn            |<- unext. SP\n+\/\/                                                       | | :                    |   + metadata_words_at_top\n+\/\/                                                       | | Lm                   |\n+\/\/                                                       | |----------------------|\n+\/\/                                                       | | Metadata@top         |\n+\/\/                                                       | |                      |<- unextended SP\n+\/\/                                                         |                      |\n+\/\/                                                         |                      |<- SP\n+\/\/                                                         ========================\n+\/\/\n+\/\/                                           sizeof(Metadata@top) = frame::metadata_words_at_top\n+\/\/                                           bottom_of_locals = unext. sp + sizeof(Metadata@top) + stackargs\n+\/\/                                           overlap = bottom_of_locals - unext. sp\n+\/\/                                                   = stackargs + sizeof(Metadata@top)\n@@ -83,2 +163,4 @@\n-  Unimplemented();\n-  return 0;\n+  assert_is_interpreted_and_frame_type_mixed();\n+  intptr_t* top = unextended_sp(); \/\/ later subtract argsize if callee is interpreted\n+  intptr_t* bottom = derelativize(ijava_idx(locals)) + 1;\n+  return (int)(bottom - top);\n@@ -87,0 +169,4 @@\n+\/\/ Size of stack args in words (P0..Pn above). Only valid if the caller is also\n+\/\/ interpreted. The function is also called if the caller is compiled but the\n+\/\/ result is not used in that case (same on x86).\n+\/\/ See also setting of sender_sp in ContinuationHelper::InterpretedFrame::patch_sender_sp()\n@@ -89,2 +175,7 @@\n-  Unimplemented();\n-  return 0;\n+  assert_is_interpreted_and_frame_type_mixed();\n+  frame::ijava_state* state = (frame::ijava_state*)((uintptr_t)fp() - frame::ijava_state_size);\n+  int diff = (int)(state->locals - (state->sender_sp + frame::metadata_words_at_top) + 1);\n+  assert(diff == -frame::metadata_words_at_top || ((Method*)state->method)->size_of_parameters() == diff,\n+         \"size_of_parameters(): %d diff: %d sp: \" PTR_FORMAT \" fp:\" PTR_FORMAT,\n+         ((Method*)state->method)->size_of_parameters(), diff, p2i(sp()), p2i(fp()));\n+  return diff;\n@@ -95,2 +186,9 @@\n-  Unimplemented();\n-  return 0;\n+  assert_is_interpreted_and_frame_type_mixed();\n+  ResourceMark rm;\n+  InterpreterOopMap mask;\n+  frame f = to_frame();\n+  f.interpreted_frame_oop_map(&mask);\n+  return  mask.num_oops()\n+          + 1 \/\/ for the mirror oop\n+          + ((intptr_t*)f.interpreter_frame_monitor_begin()\n+             - (intptr_t*)f.interpreter_frame_monitor_end())\/BasicObjectLock::size();\n@@ -102,1 +200,1 @@\n-  Unimplemented();\n+  \/\/ Nothing to do (no non-volatile registers in java calling convention)\n@@ -108,1 +206,1 @@\n-  Unimplemented();\n+  \/\/ Nothing to do (no non-volatile registers in java calling convention)\n","filename":"src\/hotspot\/cpu\/ppc\/stackChunkFrameStream_ppc.inline.hpp","additions":119,"deletions":21,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"runtime\/frame.inline.hpp\"\n+\n@@ -29,1 +31,3 @@\n-  Unimplemented();\n+  if (fr.is_interpreted_frame()) {\n+    fr.set_offset_fp(relativize_address(fr.fp()));\n+  }\n@@ -33,1 +37,3 @@\n-  Unimplemented();\n+  if (fr.is_interpreted_frame()) {\n+    fr.set_fp(derelativize_address(fr.offset_fp()));\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/stackChunkOop_ppc.inline.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+#include \"runtime\/continuation.hpp\"\n+#include \"runtime\/continuationEntry.inline.hpp\"\n@@ -326,0 +328,1 @@\n+      __ pop_cont_fastpath();\n@@ -4504,1 +4507,1 @@\n-  address generate_cont_thaw() {\n+  address generate_cont_thaw(const char* label, Continuation::thaw_kind kind) {\n@@ -4506,2 +4509,83 @@\n-    Unimplemented();\n-    return nullptr;\n+\n+    bool return_barrier = Continuation::is_thaw_return_barrier(kind);\n+    bool return_barrier_exception = Continuation::is_thaw_return_barrier_exception(kind);\n+\n+    StubCodeMark mark(this, \"StubRoutines\", label);\n+\n+    Register tmp1 = R10_ARG8;\n+    Register tmp2 = R9_ARG7;\n+    Register tmp3 = R8_ARG6;\n+    Register nvtmp = R15_esp;   \/\/ nonvolatile tmp register\n+    FloatRegister nvftmp = F20; \/\/ nonvolatile fp tmp register\n+\n+    address start = __ pc();\n+\n+    if (return_barrier) {\n+      __ mr(nvtmp, R3_RET); __ fmr(nvftmp, F1_RET); \/\/ preserve possible return value from a method returning to the return barrier\n+      DEBUG_ONLY(__ ld_ptr(tmp1, _abi0(callers_sp), R1_SP);)\n+      __ ld_ptr(R1_SP, JavaThread::cont_entry_offset(), R16_thread);\n+#ifdef ASSERT\n+      __ ld_ptr(tmp2, _abi0(callers_sp), R1_SP);\n+      __ cmpd(CCR0, tmp1, tmp2);\n+      __ asm_assert_eq(FILE_AND_LINE \": callers sp is corrupt\");\n+#endif\n+    }\n+#ifdef ASSERT\n+    __ ld_ptr(tmp1, JavaThread::cont_entry_offset(), R16_thread);\n+    __ cmpd(CCR0, R1_SP, tmp1);\n+    __ asm_assert_eq(FILE_AND_LINE \": incorrect R1_SP\");\n+#endif\n+\n+    __ li(R4_ARG2, return_barrier ? 1 : 0);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, Continuation::prepare_thaw), R16_thread, R4_ARG2);\n+\n+#ifdef ASSERT\n+    DEBUG_ONLY(__ ld_ptr(tmp1, JavaThread::cont_entry_offset(), R16_thread));\n+    DEBUG_ONLY(__ cmpd(CCR0, R1_SP, tmp1));\n+    __ asm_assert_eq(FILE_AND_LINE \": incorrect R1_SP\");\n+#endif\n+\n+    \/\/ R3_RET contains the size of the frames to thaw, 0 if overflow or no more frames\n+    Label thaw_success;\n+    __ cmpdi(CCR0, R3_RET, 0);\n+    __ bne(CCR0, thaw_success);\n+    __ load_const_optimized(tmp1, (StubRoutines::throw_StackOverflowError_entry()), R0);\n+    __ mtctr(tmp1); __ bctr();\n+    __ bind(thaw_success);\n+\n+    __ addi(R3_RET, R3_RET, frame::abi_reg_args_size); \/\/ Large abi required for C++ calls.\n+    __ neg(R3_RET, R3_RET);\n+    \/\/ align down resulting in a smaller negative offset\n+    __ clrrdi(R3_RET, R3_RET, exact_log2(frame::alignment_in_bytes));\n+    DEBUG_ONLY(__ mr(tmp1, R1_SP);)\n+    __ resize_frame(R3_RET, tmp2);  \/\/ make room for the thawed frames\n+\n+    __ li(R4_ARG2, kind);\n+    __ call_VM_leaf(Continuation::thaw_entry(), R16_thread, R4_ARG2);\n+    __ mr(R1_SP, R3_RET); \/\/ R3_RET contains the SP of the thawed top frame\n+\n+    if (return_barrier) {\n+      \/\/ we're now in the caller of the frame that returned to the barrier\n+      __ mr(R3_RET, nvtmp); __ fmr(F1_RET, nvftmp); \/\/ restore return value (no safepoint in the call to thaw, so even an oop return value should be OK)\n+    } else {\n+      \/\/ we're now on the yield frame (which is in an address above us b\/c rsp has been pushed down)\n+      __ li(R3_RET, 0); \/\/ return 0 (success) from doYield\n+    }\n+\n+    if (return_barrier_exception) {\n+      Register ex_pc = R17_tos;   \/\/ nonvolatile register\n+      __ ld(ex_pc, _abi0(lr), R1_SP); \/\/ LR\n+      __ mr(nvtmp, R3_RET); \/\/ save return value containing the exception oop\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::exception_handler_for_return_address), R16_thread, ex_pc);\n+      __ mtlr(R3_RET); \/\/ the exception handler\n+      \/\/ See OptoRuntime::generate_exception_blob for register arguments\n+      __ mr(R3_ARG1, nvtmp); \/\/ exception oop\n+      __ mr(R4_ARG2, ex_pc); \/\/ exception pc\n+    } else {\n+      \/\/ We're \"returning\" into the topmost thawed frame; see Thaw::push_return_frame\n+      __ ld(R0, _abi0(lr), R1_SP); \/\/ LR\n+      __ mtlr(R0);\n+    }\n+    __ blr();\n+\n+    return start;\n@@ -4510,0 +4594,6 @@\n+  address generate_cont_thaw() {\n+    return generate_cont_thaw(\"Cont thaw\", Continuation::thaw_top);\n+  }\n+\n+  \/\/ TODO: will probably need multiple return barriers depending on return type\n+\n@@ -4511,3 +4601,1 @@\n-    if (!Continuations::enabled()) return nullptr;\n-    Unimplemented();\n-    return nullptr;\n+    return generate_cont_thaw(\"Cont thaw return barrier\", Continuation::thaw_return_barrier);\n@@ -4517,3 +4605,1 @@\n-    if (!Continuations::enabled()) return nullptr;\n-    Unimplemented();\n-    return nullptr;\n+    return generate_cont_thaw(\"Cont thaw return barrier exception\", Continuation::thaw_return_barrier_exception);\n@@ -4528,0 +4614,3 @@\n+    CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n+    MacroAssembler* _masm = new MacroAssembler(&code);\n+\n@@ -4530,6 +4619,0 @@\n-    int insts_size = 512;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n@@ -4560,0 +4643,1 @@\n+    OopMapSet* oop_maps = new OopMapSet();\n@@ -4564,1 +4648,2 @@\n-      RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n+      RuntimeStub::new_runtime_stub(code.name(),\n+                                    &code, frame_complete,\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":101,"deletions":16,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -634,3 +634,1 @@\n-  __ restore_interpreter_state(R11_scratch1); \/\/ Sets R11_scratch1 = fp.\n-  __ ld(R12_scratch2, _ijava_state_neg(top_frame_sp), R11_scratch1);\n-  __ resize_frame_absolute(R12_scratch2, R11_scratch1, R0);\n+  __ restore_interpreter_state(R11_scratch1, false \/*bcp_and_mdx_only*\/, true \/*restore_top_frame_sp*\/);\n@@ -705,0 +703,1 @@\n+  __ push_cont_fastpath();\n@@ -706,0 +705,1 @@\n+  __ pop_cont_fastpath();\n@@ -1946,3 +1946,1 @@\n-    __ restore_interpreter_state(R11_scratch1); \/\/ Sets R11_scratch1 = fp.\n-    __ ld(R12_scratch2, _ijava_state_neg(top_frame_sp), R11_scratch1);\n-    __ resize_frame_absolute(R12_scratch2, R11_scratch1, R0);\n+    __ restore_interpreter_state(R11_scratch1, false \/*bcp_and_mdx_only*\/, true \/*restore_top_frame_sp*\/);\n@@ -2039,0 +2037,1 @@\n+    __ pop_cont_fastpath();\n@@ -2050,3 +2049,2 @@\n-    __ restore_interpreter_state(R11_scratch1);\n-    __ ld(R12_scratch2, _ijava_state_neg(top_frame_sp), R11_scratch1);\n-    __ resize_frame_absolute(R12_scratch2, R11_scratch1, R0);\n+    __ pop_cont_fastpath();\n+    __ restore_interpreter_state(R11_scratch1, false \/*bcp_and_mdx_only*\/, true \/*restore_top_frame_sp*\/);\n@@ -2111,0 +2109,1 @@\n+    __ pop_cont_fastpath();\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2149,0 +2149,1 @@\n+    __ push_cont_fastpath();\n@@ -2150,0 +2151,1 @@\n+    __ pop_cont_fastpath();\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1673,1 +1673,1 @@\n-\/\/ Currently only support Zba and Zbb bitmanip extensions.\n+\/\/ Currently only support Zba, Zbb and Zbs bitmanip extensions.\n@@ -1748,0 +1748,1 @@\n+  INSN(bexti,   0b0010011, 0b101, 0b010010);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1332,2 +1332,14 @@\n-  Label Done;\n-  fsflags(zr);\n+  Label Done, Compare;\n+\n+  is_double ? fclass_d(t0, src1)\n+            : fclass_s(t0, src1);\n+  is_double ? fclass_d(t1, src2)\n+            : fclass_s(t1, src2);\n+  orr(t0, t0, t1);\n+  andi(t0, t0, 0b1100000000); \/\/if src1 or src2 is quiet or signaling NaN then return NaN\n+  beqz(t0, Compare);\n+  is_double ? fadd_d(dst, src1, src2)\n+            : fadd_s(dst, src1, src2);\n+  j(Done);\n+\n+  bind(Compare);\n@@ -1337,2 +1349,0 @@\n-    \/\/ Checking NaNs\n-    flt_d(zr, src1, src2);\n@@ -1342,2 +1352,0 @@\n-    \/\/ Checking NaNs\n-    flt_s(zr, src1, src2);\n@@ -1346,7 +1354,0 @@\n-  frflags(t0);\n-  beqz(t0, Done);\n-\n-  \/\/ In case of NaNs\n-  is_double ? fadd_d(dst, src1, src2)\n-            : fadd_s(dst, src1, src2);\n-\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_RISCV_CONTINUATIONENTRY_RISCV_HPP\n+#define CPU_RISCV_CONTINUATIONENTRY_RISCV_HPP\n+\n+class ContinuationEntryPD {\n+  \/\/ empty\n+};\n+\n+#endif \/\/ CPU_RISCV_CONTINUATIONENTRY_RISCV_HPP\n","filename":"src\/hotspot\/cpu\/riscv\/continuationEntry_riscv.hpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -207,0 +207,6 @@\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::patch_caller_links(intptr_t* sp, intptr_t* bottom) {\n+  \/\/ Fast path depends on !PreserveFramePointer. See can_thaw_fast().\n+  assert(!PreserveFramePointer, \"Frame pointers need to be fixed\");\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/continuationFreezeThaw_riscv.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -103,1 +103,2 @@\n-inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, intptr_t* sp) {\n+inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, const frame& caller) {\n+  intptr_t* sp = caller.unextended_sp();\n@@ -139,0 +140,4 @@\n+inline intptr_t* ContinuationHelper::InterpretedFrame::callers_sp(const frame& f) {\n+  return f.fp();\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/continuationHelper_riscv.inline.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -142,0 +142,7 @@\n+    \/\/ size, in words, of metadata at frame bottom, i.e. it is not part of the\n+    \/\/ caller\/callee overlap\n+    metadata_words_at_bottom                         = metadata_words,\n+    \/\/ size, in words, of frame metadata at the frame top, i.e. it is located\n+    \/\/ between a callee frame and its stack arguments, where it is part\n+    \/\/ of the caller\/callee overlap\n+    metadata_words_at_top                            = 0,\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+  product(bool, UseZbs, false, EXPERIMENTAL, \"Use Zbs instructions\")             \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -963,0 +963,1 @@\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -968,0 +969,1 @@\n+#include \"runtime\/objectMonitor.hpp\"\n@@ -2985,0 +2987,8 @@\n+operand immIpowerOf2() %{\n+  predicate(is_power_of_2((juint)(n->get_int())));\n+  match(ConI);\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -7229,1 +7239,1 @@\n-instruct maxF_reg_reg(fRegF dst, fRegF src1, fRegF src2) %{\n+instruct maxF_reg_reg(fRegF dst, fRegF src1, fRegF src2, rFlagsReg cr) %{\n@@ -7231,1 +7241,1 @@\n-  effect(TEMP_DEF dst);\n+  effect(TEMP_DEF dst, KILL cr);\n@@ -7245,1 +7255,1 @@\n-instruct minF_reg_reg(fRegF dst, fRegF src1, fRegF src2) %{\n+instruct minF_reg_reg(fRegF dst, fRegF src1, fRegF src2, rFlagsReg cr) %{\n@@ -7247,1 +7257,1 @@\n-  effect(TEMP_DEF dst);\n+  effect(TEMP_DEF dst, KILL cr);\n@@ -7261,1 +7271,1 @@\n-instruct maxD_reg_reg(fRegD dst, fRegD src1, fRegD src2) %{\n+instruct maxD_reg_reg(fRegD dst, fRegD src1, fRegD src2, rFlagsReg cr) %{\n@@ -7263,1 +7273,1 @@\n-  effect(TEMP_DEF dst);\n+  effect(TEMP_DEF dst, KILL cr);\n@@ -7277,1 +7287,1 @@\n-instruct minD_reg_reg(fRegD dst, fRegD src1, fRegD src2) %{\n+instruct minD_reg_reg(fRegD dst, fRegD src1, fRegD src2, rFlagsReg cr) %{\n@@ -7279,1 +7289,1 @@\n-  effect(TEMP_DEF dst);\n+  effect(TEMP_DEF dst, KILL cr);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -527,1 +527,15 @@\n-%}\n\\ No newline at end of file\n+%}\n+\n+\/\/ AndI 0b0..010..0 + ConvI2B\n+instruct convI2Bool_andI_reg_immIpowerOf2(iRegINoSp dst, iRegIorL2I src, immIpowerOf2 mask) %{\n+  predicate(UseZbs);\n+  match(Set dst (Conv2B (AndI src mask)));\n+  ins_cost(ALU_COST);\n+\n+  format %{ \"bexti  $dst, $src, $mask\\t#@convI2Bool_andI_reg_immIpowerOf2\" %}\n+  ins_encode %{\n+    __ bexti($dst$$Register, $src$$Register, exact_log2((juint)($mask$$constant)));\n+  %}\n+\n+  ins_pipe(ialu_reg_reg);\n+%}\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_b.ad","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-      case Op_VectorLoadConst:\n@@ -2080,0 +2079,17 @@\n+\n+\/\/ Vector Load Const\n+instruct vloadcon(vReg dst, immI0 src) %{\n+  match(Set dst (VectorLoadConst src));\n+  ins_cost(VEC_COST);\n+  format %{ \"vloadcon $dst\\t# generate iota indices\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SEW sew = Assembler::elemtype_to_sew(bt);\n+    __ vsetvli(t0, x0, sew);\n+    __ vid_v(as_VectorRegister($dst$$reg));\n+    if (is_floating_point_type(bt)) {\n+      __ vfcvt_f_x_v(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -876,1 +876,0 @@\n-  ContinuationEntry::setup_oopmap(map);\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+const char* VM_Version::_vm_mode = \"\";\n@@ -39,0 +40,5 @@\n+  \/\/ check if satp.mode is supported, currently supports up to SV48(RV64)\n+  if (get_satp_mode() > VM_SV48) {\n+    vm_exit_during_initialization(err_msg(\"Unsupported satp mode: %s\", _vm_mode));\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,0 +41,9 @@\n+\/\/ VM modes (satp.mode) privileged ISA 1.10\n+enum VM_MODE {\n+  VM_MBARE = 0,\n+  VM_SV39  = 8,\n+  VM_SV48  = 9,\n+  VM_SV57  = 10,\n+  VM_SV64  = 11\n+};\n+\n@@ -43,0 +52,1 @@\n+  static const char* _vm_mode;\n@@ -46,0 +56,1 @@\n+  static VM_MODE get_satp_mode();\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_S390_CONTINUATIONENTRY_S390_HPP\n+#define CPU_S390_CONTINUATIONENTRY_S390_HPP\n+\n+class ContinuationEntryPD {\n+  \/\/ empty\n+};\n+\n+#endif \/\/ CPU_S390_CONTINUATIONENTRY_S390_HPP\n","filename":"src\/hotspot\/cpu\/s390\/continuationEntry_s390.hpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -94,0 +94,5 @@\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::patch_caller_links(intptr_t* sp, intptr_t* bottom) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/continuationFreezeThaw_s390.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, intptr_t* sp) {\n+inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, const frame& caller) {\n@@ -125,0 +125,5 @@\n+inline intptr_t* ContinuationHelper::InterpretedFrame::callers_sp(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/continuationHelper_s390.inline.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -548,3 +548,5 @@\n-    pc_return_offset =  0,\n-    metadata_words   = 0,\n-    frame_alignment  = 16,\n+    pc_return_offset         = 0,\n+    metadata_words           = 0,\n+    metadata_words_at_bottom = 0,\n+    metadata_words_at_top    = 0,\n+    frame_alignment          = 16,\n@@ -552,1 +554,1 @@\n-    align_wiggle     =  1\n+    align_wiggle             =  1\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-           \"original PC must be in the main code section of the the compiled method (or must be immediately following it)\");\n+           \"original PC must be in the main code section of the compiled method (or must be immediately following it)\");\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5272,0 +5272,10 @@\n+void Assembler::vpshufhw(XMMRegister dst, XMMRegister src, int mode, int vector_len) {\n+    assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+            (vector_len == AVX_256bit ? VM_Version::supports_avx2() :\n+            (vector_len == AVX_512bit ? VM_Version::supports_avx512bw() : false)), \"\");\n+    NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+    InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &attributes);\n+    emit_int24(0x70, (0xC0 | encode), mode & 0xFF);\n+}\n+\n@@ -5293,0 +5303,10 @@\n+void Assembler::vpshuflw(XMMRegister dst, XMMRegister src, int mode, int vector_len) {\n+    assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+            (vector_len == AVX_256bit ? VM_Version::supports_avx2() :\n+            (vector_len == AVX_512bit ? VM_Version::supports_avx512bw() : false)), \"\");\n+    NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n+    InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &attributes);\n+    emit_int24(0x70, (0xC0 | encode), mode & 0xFF);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1949,0 +1949,2 @@\n+  void vpshufhw(XMMRegister dst, XMMRegister src, int mode, int vector_len);\n+  void vpshuflw(XMMRegister dst, XMMRegister src, int mode, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -179,1 +179,0 @@\n-  jcc(Assembler::zero, done);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_X86_CONTINUATIONENTRY_X86_HPP\n+#define CPU_X86_CONTINUATIONENTRY_X86_HPP\n+\n+class ContinuationEntryPD {\n+  \/\/ empty\n+};\n+\n+#endif \/\/ CPU_X86_CONTINUATIONENTRY_X86_HPP\n","filename":"src\/hotspot\/cpu\/x86\/continuationEntry_x86.hpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -196,0 +196,6 @@\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::patch_caller_links(intptr_t* sp, intptr_t* bottom) {\n+  \/\/ Fast path depends on !PreserveFramePointer. See can_thaw_fast().\n+  assert(!PreserveFramePointer, \"Frame pointers need to be fixed\");\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/continuationFreezeThaw_x86.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -103,1 +103,2 @@\n-inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, intptr_t* sp) {\n+inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, const frame& caller) {\n+  intptr_t* sp = caller.unextended_sp();\n@@ -139,0 +140,4 @@\n+inline intptr_t* ContinuationHelper::InterpretedFrame::callers_sp(const frame& f) {\n+  return f.fp() + frame::metadata_words;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/continuationHelper_x86.inline.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -100,1 +100,9 @@\n-    \/\/ compiled frame alignment, in bytes\n+    \/\/ size, in words, of metadata at frame bottom, i.e. it is not part of the\n+    \/\/ caller\/callee overlap\n+    metadata_words_at_bottom                         = metadata_words,\n+    \/\/ size, in words, of frame metadata at the frame top, i.e. it is located\n+    \/\/ between a callee frame and its stack arguments, where it is part\n+    \/\/ of the caller\/callee overlap\n+    metadata_words_at_top                            = 0,\n+    \/\/ size, in words, of frame metadata at the frame top that needs\n+    \/\/ to be reserved for callee functions in the runtime\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1296,1 +1296,0 @@\n-  ContinuationEntry::setup_oopmap(map);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3812,0 +3812,2 @@\n+  generate_chacha_stubs();\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -390,0 +390,12 @@\n+  \/\/ ChaCha20 stubs and helper functions\n+  void generate_chacha_stubs();\n+  address generate_chacha20Block_avx();\n+  address generate_chacha20Block_avx512();\n+  void cc20_quarter_round_avx(XMMRegister aVec, XMMRegister bVec,\n+    XMMRegister cVec, XMMRegister dVec, XMMRegister scratch,\n+    XMMRegister lrot8, XMMRegister lrot16, int vector_len);\n+  void cc20_shift_lane_org(XMMRegister bVec, XMMRegister cVec,\n+    XMMRegister dVec, int vector_len, bool colToDiag);\n+  void cc20_keystream_collate_avx512(XMMRegister aVec, XMMRegister bVec,\n+    XMMRegister cVec, XMMRegister dVec, Register baseAddr, int baseOffset);\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,582 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/assembler.hpp\"\n+#include \"asm\/assembler.inline.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+\n+#define __ _masm->\n+\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#else\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+#endif \/\/ PRODUCT\n+\n+#define BIND(label) bind(label); BLOCK_COMMENT(#label \":\")\n+\n+\/\/ Constants\n+\n+\/**\n+ * This AVX\/AVX2 add mask generation can be used for multiple duties:\n+ *      1.) Provide +0\/+1 counter increments by loading 256 bits\n+ *          at offset 0\n+ *      2.) Provide +2\/+2 counter increments for the second set\n+ *          of 4 AVX2 registers at offset 32 (256-bit load)\n+ *      3.) Provide a +1 increment for the second set of 4 AVX\n+ *          registers at offset 16 (128-bit load)\n+ *\/\n+ATTRIBUTE_ALIGNED(64) uint64_t CC20_COUNTER_ADD_AVX[] = {\n+    0x0000000000000000UL, 0x0000000000000000UL,\n+    0x0000000000000001UL, 0x0000000000000000UL,\n+    0x0000000000000002UL, 0x0000000000000000UL,\n+    0x0000000000000002UL, 0x0000000000000000UL,\n+};\n+static address chacha20_ctradd_avx() {\n+  return (address)CC20_COUNTER_ADD_AVX;\n+}\n+\n+\/**\n+ * Add masks for 4-block ChaCha20 Block calculations\n+ * The first 512 bits creates a +0\/+1\/+2\/+3 add overlay.\n+ * The second 512 bits is a +4\/+4\/+4\/+4 add overlay.  This\n+ * can be used to increment the counter fields for the next 4 blocks.\n+ *\/\n+ATTRIBUTE_ALIGNED(64) uint64_t CC20_COUNTER_ADD_AVX512[] = {\n+    0x0000000000000000UL, 0x0000000000000000UL,\n+    0x0000000000000001UL, 0x0000000000000000UL,\n+    0x0000000000000002UL, 0x0000000000000000UL,\n+    0x0000000000000003UL, 0x0000000000000000UL,\n+\n+    0x0000000000000004UL, 0x0000000000000000UL,\n+    0x0000000000000004UL, 0x0000000000000000UL,\n+    0x0000000000000004UL, 0x0000000000000000UL,\n+    0x0000000000000004UL, 0x0000000000000000UL\n+};\n+static address chacha20_ctradd_avx512() {\n+  return (address)CC20_COUNTER_ADD_AVX512;\n+}\n+\n+\/**\n+ * The first 256 bits represents a byte-wise permutation\n+ * for an 8-bit left-rotation on 32-bit lanes.\n+ * The second 256 bits is a 16-bit rotation on 32-bit lanes.\n+ *\/\n+ATTRIBUTE_ALIGNED(64) uint64_t CC20_LROT_CONSTS[] = {\n+    0x0605040702010003UL, 0x0E0D0C0F0A09080BUL,\n+    0x0605040702010003UL, 0x0E0D0C0F0A09080BUL,\n+\n+    0x0504070601000302UL, 0x0D0C0F0E09080B0AUL,\n+    0x0504070601000302UL, 0x0D0C0F0E09080B0AUL\n+};\n+static address chacha20_lrot_consts() {\n+  return (address)CC20_LROT_CONSTS;\n+}\n+\n+\n+\n+void StubGenerator::generate_chacha_stubs() {\n+  \/\/ Generate ChaCha20 intrinsics code\n+  if (UseChaCha20Intrinsics) {\n+    if (VM_Version::supports_evex()) {\n+      StubRoutines::_chacha20Block = generate_chacha20Block_avx512();\n+    } else {    \/\/ Either AVX or AVX2 is supported\n+      assert(VM_Version::supports_avx() == true, \"Must at least support AVX instructions\");\n+      StubRoutines::_chacha20Block = generate_chacha20Block_avx();\n+    }\n+  }\n+}\n+\n+\/* The 2-block AVX\/AVX2-enabled ChaCha20 block function implementation *\/\n+address StubGenerator::generate_chacha20Block_avx() {\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", \"chacha20Block\");\n+  address start = __ pc();\n+\n+  Label L_twoRounds;\n+  const Register state        = c_rarg0;\n+  const Register result       = c_rarg1;\n+  const Register loopCounter  = r8;\n+  const Register rotAddr      = r9;\n+\n+  const XMMRegister aState = xmm0;\n+  const XMMRegister bState = xmm1;\n+  const XMMRegister cState = xmm2;\n+  const XMMRegister dState = xmm3;\n+  const XMMRegister a1Vec = xmm4;\n+  const XMMRegister b1Vec = xmm5;\n+  const XMMRegister c1Vec = xmm6;\n+  const XMMRegister d1Vec = xmm7;\n+  const XMMRegister a2Vec = xmm8;\n+  const XMMRegister b2Vec = xmm9;\n+  const XMMRegister c2Vec = xmm10;\n+  const XMMRegister d2Vec = xmm11;\n+  const XMMRegister scratch = xmm12;\n+  const XMMRegister d2State = xmm13;\n+  const XMMRegister lrot8 = xmm14;\n+  const XMMRegister lrot16 = xmm15;\n+\n+  int vector_len;\n+  int outlen;\n+\n+  \/\/ This function will only be called if AVX2 or AVX are supported\n+  \/\/ AVX512 uses a different function.\n+  if (VM_Version::supports_avx2()) {\n+    vector_len = Assembler::AVX_256bit;\n+    outlen = 256;\n+  } else if (VM_Version::supports_avx()) {\n+    vector_len = Assembler::AVX_128bit;\n+    outlen = 128;\n+  }\n+\n+  __ enter();\n+\n+  \/\/ Load the initial state in columnar orientation and then copy\n+  \/\/ that starting state to the working register set.\n+  \/\/ Also load the address of the add mask for later use in handling\n+  \/\/ multi-block counter increments.\n+  __ lea(rotAddr, ExternalAddress(chacha20_lrot_consts()));\n+  __ lea(rax, ExternalAddress(chacha20_ctradd_avx()));\n+  if (vector_len == Assembler::AVX_128bit) {\n+    __ movdqu(aState, Address(state, 0));       \/\/ Bytes 0 - 15 -> a1Vec\n+    __ movdqu(bState, Address(state, 16));      \/\/ Bytes 16 - 31 -> b1Vec\n+    __ movdqu(cState, Address(state, 32));      \/\/ Bytes 32 - 47 -> c1Vec\n+    __ movdqu(dState, Address(state, 48));      \/\/ Bytes 48 - 63 -> d1Vec\n+\n+    __ movdqu(a1Vec, aState);\n+    __ movdqu(b1Vec, bState);\n+    __ movdqu(c1Vec, cState);\n+    __ movdqu(d1Vec, dState);\n+\n+    __ movdqu(a2Vec, aState);\n+    __ movdqu(b2Vec, bState);\n+    __ movdqu(c2Vec, cState);\n+    __ vpaddd(d2State, dState, Address(rax, 16), vector_len);\n+    __ movdqu(d2Vec, d2State);\n+    __ movdqu(lrot8, Address(rotAddr, 0));      \/\/ Load 8-bit lrot const\n+    __ movdqu(lrot16, Address(rotAddr, 32));    \/\/ Load 16-bit lrot const\n+  } else {\n+    \/\/ We will broadcast each 128-bit segment of the state array into\n+    \/\/ the high and low halves of ymm state registers.  Then apply the add\n+    \/\/ mask to the dState register.  These will then be copied into the\n+    \/\/ a\/b\/c\/d1Vec working registers.\n+    __ vbroadcastf128(aState, Address(state, 0), vector_len);\n+    __ vbroadcastf128(bState, Address(state, 16), vector_len);\n+    __ vbroadcastf128(cState, Address(state, 32), vector_len);\n+    __ vbroadcastf128(dState, Address(state, 48), vector_len);\n+    __ vpaddd(dState, dState, Address(rax, 0), vector_len);\n+    __ vpaddd(d2State, dState, Address(rax, 32), vector_len);\n+\n+    __ vmovdqu(a1Vec, aState);\n+    __ vmovdqu(b1Vec, bState);\n+    __ vmovdqu(c1Vec, cState);\n+    __ vmovdqu(d1Vec, dState);\n+\n+    __ vmovdqu(a2Vec, aState);\n+    __ vmovdqu(b2Vec, bState);\n+    __ vmovdqu(c2Vec, cState);\n+    __ vmovdqu(d2Vec, d2State);\n+    __ vmovdqu(lrot8, Address(rotAddr, 0));      \/\/ Load 8-bit lrot const\n+    __ vmovdqu(lrot16, Address(rotAddr, 32));    \/\/ Load 16-bit lrot const\n+  }\n+\n+  __ movl(loopCounter, 10);                   \/\/ Set 10 2-round iterations\n+  __ BIND(L_twoRounds);\n+\n+  \/\/ The first quarter round macro call covers the first 4 QR operations:\n+  \/\/  Qround(state, 0, 4, 8,12)\n+  \/\/  Qround(state, 1, 5, 9,13)\n+  \/\/  Qround(state, 2, 6,10,14)\n+  \/\/  Qround(state, 3, 7,11,15)\n+  cc20_quarter_round_avx(a1Vec, b1Vec, c1Vec, d1Vec, scratch,\n+      lrot8, lrot16, vector_len);\n+  cc20_quarter_round_avx(a2Vec, b2Vec, c2Vec, d2Vec, scratch,\n+      lrot8, lrot16, vector_len);\n+\n+  \/\/ Shuffle the b1Vec\/c1Vec\/d1Vec to reorganize the state vectors\n+  \/\/ to diagonals.  The a1Vec does not need to change orientation.\n+  cc20_shift_lane_org(b1Vec, c1Vec, d1Vec, vector_len, true);\n+  cc20_shift_lane_org(b2Vec, c2Vec, d2Vec, vector_len, true);\n+\n+  \/\/ The second set of operations on the vectors covers the second 4 quarter\n+  \/\/ round operations, now acting on the diagonals:\n+  \/\/  Qround(state, 0, 5,10,15)\n+  \/\/  Qround(state, 1, 6,11,12)\n+  \/\/  Qround(state, 2, 7, 8,13)\n+  \/\/  Qround(state, 3, 4, 9,14)\n+  cc20_quarter_round_avx(a1Vec, b1Vec, c1Vec, d1Vec, scratch,\n+      lrot8, lrot16, vector_len);\n+  cc20_quarter_round_avx(a2Vec, b2Vec, c2Vec, d2Vec, scratch,\n+      lrot8, lrot16, vector_len);\n+\n+  \/\/ Before we start the next iteration, we need to perform shuffles\n+  \/\/ on the b\/c\/d vectors to move them back to columnar organizations\n+  \/\/ from their current diagonal orientation.\n+  cc20_shift_lane_org(b1Vec, c1Vec, d1Vec, vector_len, false);\n+  cc20_shift_lane_org(b2Vec, c2Vec, d2Vec, vector_len, false);\n+\n+  __ decrement(loopCounter);\n+  __ jcc(Assembler::notZero, L_twoRounds);\n+\n+  \/\/ Add the original start state back into the current state.\n+  __ vpaddd(a1Vec, a1Vec, aState, vector_len);\n+  __ vpaddd(b1Vec, b1Vec, bState, vector_len);\n+  __ vpaddd(c1Vec, c1Vec, cState, vector_len);\n+  __ vpaddd(d1Vec, d1Vec, dState, vector_len);\n+\n+  __ vpaddd(a2Vec, a2Vec, aState, vector_len);\n+  __ vpaddd(b2Vec, b2Vec, bState, vector_len);\n+  __ vpaddd(c2Vec, c2Vec, cState, vector_len);\n+  __ vpaddd(d2Vec, d2Vec, d2State, vector_len);\n+\n+  \/\/ Write the data to the keystream array\n+  if (vector_len == Assembler::AVX_128bit) {\n+    __ movdqu(Address(result, 0), a1Vec);\n+    __ movdqu(Address(result, 16), b1Vec);\n+    __ movdqu(Address(result, 32), c1Vec);\n+    __ movdqu(Address(result, 48), d1Vec);\n+    __ movdqu(Address(result, 64), a2Vec);\n+    __ movdqu(Address(result, 80), b2Vec);\n+    __ movdqu(Address(result, 96), c2Vec);\n+    __ movdqu(Address(result, 112), d2Vec);\n+  } else {\n+    \/\/ Each half of the YMM has to be written 64 bytes apart from\n+    \/\/ each other in memory so the final keystream buffer holds\n+    \/\/ two consecutive keystream blocks.\n+    __ vextracti128(Address(result, 0), a1Vec, 0);\n+    __ vextracti128(Address(result, 64), a1Vec, 1);\n+    __ vextracti128(Address(result, 16), b1Vec, 0);\n+    __ vextracti128(Address(result, 80), b1Vec, 1);\n+    __ vextracti128(Address(result, 32), c1Vec, 0);\n+    __ vextracti128(Address(result, 96), c1Vec, 1);\n+    __ vextracti128(Address(result, 48), d1Vec, 0);\n+    __ vextracti128(Address(result, 112), d1Vec, 1);\n+\n+    __ vextracti128(Address(result, 128), a2Vec, 0);\n+    __ vextracti128(Address(result, 192), a2Vec, 1);\n+    __ vextracti128(Address(result, 144), b2Vec, 0);\n+    __ vextracti128(Address(result, 208), b2Vec, 1);\n+    __ vextracti128(Address(result, 160), c2Vec, 0);\n+    __ vextracti128(Address(result, 224), c2Vec, 1);\n+    __ vextracti128(Address(result, 176), d2Vec, 0);\n+    __ vextracti128(Address(result, 240), d2Vec, 1);\n+  }\n+\n+  \/\/ This function will always write 128 or 256 bytes into the\n+  \/\/ key stream buffer, depending on the length of the SIMD\n+  \/\/ registers.  That length should be returned through %rax.\n+  __ mov64(rax, outlen);\n+\n+  __ leave();\n+  __ ret(0);\n+  return start;\n+}\n+\n+\/* The 4-block AVX512-enabled ChaCha20 block function implementation *\/\n+address StubGenerator::generate_chacha20Block_avx512() {\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", \"chacha20Block\");\n+  address start = __ pc();\n+\n+  Label L_twoRounds;\n+  const Register state        = c_rarg0;\n+  const Register result       = c_rarg1;\n+  const Register loopCounter  = r8;\n+\n+  const XMMRegister aState = xmm0;\n+  const XMMRegister bState = xmm1;\n+  const XMMRegister cState = xmm2;\n+  const XMMRegister dState = xmm3;\n+  const XMMRegister a1Vec = xmm4;\n+  const XMMRegister b1Vec = xmm5;\n+  const XMMRegister c1Vec = xmm6;\n+  const XMMRegister d1Vec = xmm7;\n+  const XMMRegister a2Vec = xmm8;\n+  const XMMRegister b2Vec = xmm9;\n+  const XMMRegister c2Vec = xmm10;\n+  const XMMRegister d2Vec = xmm11;\n+  const XMMRegister a3Vec = xmm12;\n+  const XMMRegister b3Vec = xmm13;\n+  const XMMRegister c3Vec = xmm14;\n+  const XMMRegister d3Vec = xmm15;\n+  const XMMRegister a4Vec = xmm16;\n+  const XMMRegister b4Vec = xmm17;\n+  const XMMRegister c4Vec = xmm18;\n+  const XMMRegister d4Vec = xmm19;\n+  const XMMRegister d2State = xmm20;\n+  const XMMRegister d3State = xmm21;\n+  const XMMRegister d4State = xmm22;\n+  const XMMRegister scratch = xmm23;\n+\n+  __ enter();\n+\n+  \/\/ Load the initial state in columnar orientation.\n+  \/\/ We will broadcast each 128-bit segment of the state array into\n+  \/\/ all four double-quadword slots on ZMM State registers.  They will\n+  \/\/ be copied into the working ZMM registers and then added back in\n+  \/\/ at the very end of the block function.  The add mask should be\n+  \/\/ applied to the dState register so it does not need to be fetched\n+  \/\/ when adding the start state back into the final working state.\n+  __ lea(rax, ExternalAddress(chacha20_ctradd_avx512()));\n+  __ evbroadcasti32x4(aState, Address(state, 0), Assembler::AVX_512bit);\n+  __ evbroadcasti32x4(bState, Address(state, 16), Assembler::AVX_512bit);\n+  __ evbroadcasti32x4(cState, Address(state, 32), Assembler::AVX_512bit);\n+  __ evbroadcasti32x4(dState, Address(state, 48), Assembler::AVX_512bit);\n+  __ vpaddd(dState, dState, Address(rax, 0), Assembler::AVX_512bit);\n+  __ evmovdqul(scratch, Address(rax, 64), Assembler::AVX_512bit);\n+  __ vpaddd(d2State, dState, scratch, Assembler::AVX_512bit);\n+  __ vpaddd(d3State, d2State, scratch, Assembler::AVX_512bit);\n+  __ vpaddd(d4State, d3State, scratch, Assembler::AVX_512bit);\n+\n+  __ evmovdqul(a1Vec, aState, Assembler::AVX_512bit);\n+  __ evmovdqul(b1Vec, bState, Assembler::AVX_512bit);\n+  __ evmovdqul(c1Vec, cState, Assembler::AVX_512bit);\n+  __ evmovdqul(d1Vec, dState, Assembler::AVX_512bit);\n+\n+  __ evmovdqul(a2Vec, aState, Assembler::AVX_512bit);\n+  __ evmovdqul(b2Vec, bState, Assembler::AVX_512bit);\n+  __ evmovdqul(c2Vec, cState, Assembler::AVX_512bit);\n+  __ evmovdqul(d2Vec, d2State, Assembler::AVX_512bit);\n+\n+  __ evmovdqul(a3Vec, aState, Assembler::AVX_512bit);\n+  __ evmovdqul(b3Vec, bState, Assembler::AVX_512bit);\n+  __ evmovdqul(c3Vec, cState, Assembler::AVX_512bit);\n+  __ evmovdqul(d3Vec, d3State, Assembler::AVX_512bit);\n+\n+  __ evmovdqul(a4Vec, aState, Assembler::AVX_512bit);\n+  __ evmovdqul(b4Vec, bState, Assembler::AVX_512bit);\n+  __ evmovdqul(c4Vec, cState, Assembler::AVX_512bit);\n+  __ evmovdqul(d4Vec, d4State, Assembler::AVX_512bit);\n+\n+  __ movl(loopCounter, 10);                       \/\/ Set 10 2-round iterations\n+  __ BIND(L_twoRounds);\n+\n+  \/\/ The first set of operations on the vectors covers the first 4 quarter\n+  \/\/ round operations:\n+  \/\/  Qround(state, 0, 4, 8,12)\n+  \/\/  Qround(state, 1, 5, 9,13)\n+  \/\/  Qround(state, 2, 6,10,14)\n+  \/\/  Qround(state, 3, 7,11,15)\n+  cc20_quarter_round_avx(a1Vec, b1Vec, c1Vec, d1Vec, scratch,\n+      xnoreg, xnoreg, Assembler::AVX_512bit);\n+  cc20_quarter_round_avx(a2Vec, b2Vec, c2Vec, d2Vec, scratch,\n+      xnoreg, xnoreg, Assembler::AVX_512bit);\n+  cc20_quarter_round_avx(a3Vec, b3Vec, c3Vec, d3Vec, scratch,\n+      xnoreg, xnoreg, Assembler::AVX_512bit);\n+  cc20_quarter_round_avx(a4Vec, b4Vec, c4Vec, d4Vec, scratch,\n+      xnoreg, xnoreg, Assembler::AVX_512bit);\n+\n+  \/\/ Shuffle the b1Vec\/c1Vec\/d1Vec to reorganize the state vectors\n+  \/\/ to diagonals.  The a1Vec does not need to change orientation.\n+  cc20_shift_lane_org(b1Vec, c1Vec, d1Vec, Assembler::AVX_512bit, true);\n+  cc20_shift_lane_org(b2Vec, c2Vec, d2Vec, Assembler::AVX_512bit, true);\n+  cc20_shift_lane_org(b3Vec, c3Vec, d3Vec, Assembler::AVX_512bit, true);\n+  cc20_shift_lane_org(b4Vec, c4Vec, d4Vec, Assembler::AVX_512bit, true);\n+\n+  \/\/ The second set of operations on the vectors covers the second 4 quarter\n+  \/\/ round operations, now acting on the diagonals:\n+  \/\/  Qround(state, 0, 5,10,15)\n+  \/\/  Qround(state, 1, 6,11,12)\n+  \/\/  Qround(state, 2, 7, 8,13)\n+  \/\/  Qround(state, 3, 4, 9,14)\n+  cc20_quarter_round_avx(a1Vec, b1Vec, c1Vec, d1Vec, scratch,\n+      xnoreg, xnoreg, Assembler::AVX_512bit);\n+  cc20_quarter_round_avx(a2Vec, b2Vec, c2Vec, d2Vec, scratch,\n+      xnoreg, xnoreg, Assembler::AVX_512bit);\n+  cc20_quarter_round_avx(a3Vec, b3Vec, c3Vec, d3Vec, scratch,\n+      xnoreg, xnoreg, Assembler::AVX_512bit);\n+  cc20_quarter_round_avx(a4Vec, b4Vec, c4Vec, d4Vec, scratch,\n+      xnoreg, xnoreg, Assembler::AVX_512bit);\n+\n+  \/\/ Before we start the next iteration, we need to perform shuffles\n+  \/\/ on the b\/c\/d vectors to move them back to columnar organizations\n+  \/\/ from their current diagonal orientation.\n+  cc20_shift_lane_org(b1Vec, c1Vec, d1Vec, Assembler::AVX_512bit, false);\n+  cc20_shift_lane_org(b2Vec, c2Vec, d2Vec, Assembler::AVX_512bit, false);\n+  cc20_shift_lane_org(b3Vec, c3Vec, d3Vec, Assembler::AVX_512bit, false);\n+  cc20_shift_lane_org(b4Vec, c4Vec, d4Vec, Assembler::AVX_512bit, false);\n+\n+  __ decrement(loopCounter);\n+  __ jcc(Assembler::notZero, L_twoRounds);\n+\n+  \/\/ Add the initial state now held on the a\/b\/c\/dState registers to the\n+  \/\/ final working register values.  We will also add in the counter add\n+  \/\/ mask onto zmm3 after adding in the start state.\n+  __ vpaddd(a1Vec, a1Vec, aState, Assembler::AVX_512bit);\n+  __ vpaddd(b1Vec, b1Vec, bState, Assembler::AVX_512bit);\n+  __ vpaddd(c1Vec, c1Vec, cState, Assembler::AVX_512bit);\n+  __ vpaddd(d1Vec, d1Vec, dState, Assembler::AVX_512bit);\n+\n+  __ vpaddd(a2Vec, a2Vec, aState, Assembler::AVX_512bit);\n+  __ vpaddd(b2Vec, b2Vec, bState, Assembler::AVX_512bit);\n+  __ vpaddd(c2Vec, c2Vec, cState, Assembler::AVX_512bit);\n+  __ vpaddd(d2Vec, d2Vec, d2State, Assembler::AVX_512bit);\n+\n+  __ vpaddd(a3Vec, a3Vec, aState, Assembler::AVX_512bit);\n+  __ vpaddd(b3Vec, b3Vec, bState, Assembler::AVX_512bit);\n+  __ vpaddd(c3Vec, c3Vec, cState, Assembler::AVX_512bit);\n+  __ vpaddd(d3Vec, d3Vec, d3State, Assembler::AVX_512bit);\n+\n+  __ vpaddd(a4Vec, a4Vec, aState, Assembler::AVX_512bit);\n+  __ vpaddd(b4Vec, b4Vec, bState, Assembler::AVX_512bit);\n+  __ vpaddd(c4Vec, c4Vec, cState, Assembler::AVX_512bit);\n+  __ vpaddd(d4Vec, d4Vec, d4State, Assembler::AVX_512bit);\n+\n+  \/\/ Write the ZMM state registers out to the key stream buffer\n+  \/\/ Each ZMM is divided into 4 128-bit segments.  Each segment\n+  \/\/ is written to memory at 64-byte displacements from one\n+  \/\/ another.  The result is that all 4 blocks will be in their\n+  \/\/ proper order when serialized.\n+  cc20_keystream_collate_avx512(a1Vec, b1Vec, c1Vec, d1Vec, result, 0);\n+  cc20_keystream_collate_avx512(a2Vec, b2Vec, c2Vec, d2Vec, result, 256);\n+  cc20_keystream_collate_avx512(a3Vec, b3Vec, c3Vec, d3Vec, result, 512);\n+  cc20_keystream_collate_avx512(a4Vec, b4Vec, c4Vec, d4Vec, result, 768);\n+\n+  \/\/ This function will always write 1024 bytes into the key stream buffer\n+  \/\/ and that length should be returned through %rax.\n+  __ mov64(rax, 1024);\n+\n+  __ leave();\n+  __ ret(0);\n+  return start;\n+}\n+\n+\/**\n+ * Provide a function that implements the ChaCha20 quarter round function.\n+ *\n+ * @param aVec the SIMD register containing only the \"a\" values\n+ * @param bVec the SIMD register containing only the \"b\" values\n+ * @param cVec the SIMD register containing only the \"c\" values\n+ * @param dVec the SIMD register containing only the \"d\" values\n+ * @param scratch SIMD register used for non-byte-aligned left rotations\n+ * @param lrot8 shuffle control mask for an 8-byte left rotation (32-bit lane)\n+ * @param lrot16 shuffle control mask for a 16-byte left rotation (32-bit lane)\n+ * @param vector_len the length of the vector\n+ *\/\n+void StubGenerator::cc20_quarter_round_avx(XMMRegister aVec, XMMRegister bVec,\n+    XMMRegister cVec, XMMRegister dVec, XMMRegister scratch,\n+    XMMRegister lrot8, XMMRegister lrot16, int vector_len) {\n+\n+  \/\/ a += b; d ^= a; d <<<= 16\n+  __ vpaddd(aVec, aVec, bVec, vector_len);\n+  __ vpxor(dVec, dVec, aVec, vector_len);\n+  if (vector_len == Assembler::AVX_512bit) {\n+    __ evprold(dVec, dVec, 16, vector_len);\n+  } else {\n+    __ vpshufb(dVec, dVec, lrot16, vector_len);\n+  }\n+\n+  \/\/ c += d; b ^= c; b <<<= 12 (b << 12 | scratch >>> 20)\n+  __ vpaddd(cVec, cVec, dVec, vector_len);\n+  __ vpxor(bVec, bVec, cVec, vector_len);\n+  if (vector_len == Assembler::AVX_512bit) {\n+    __ evprold(bVec, bVec, 12, vector_len);\n+  } else {\n+    __ vpsrld(scratch, bVec, 20, vector_len);\n+    __ vpslld(bVec, bVec, 12, vector_len);\n+    __ vpor(bVec, bVec, scratch, vector_len);\n+  }\n+\n+  \/\/ a += b; d ^= a; d <<<= 8 (d << 8 | scratch >>> 24)\n+  __ vpaddd(aVec, aVec, bVec, vector_len);\n+  __ vpxor(dVec, dVec, aVec, vector_len);\n+  if (vector_len == Assembler::AVX_512bit) {\n+    __ evprold(dVec, dVec, 8, vector_len);\n+  } else {\n+    __ vpshufb(dVec, dVec, lrot8, vector_len);\n+  }\n+\n+  \/\/ c += d; b ^= c; b <<<= 7 (b << 7 | scratch >>> 25)\n+  __ vpaddd(cVec, cVec, dVec, vector_len);\n+  __ vpxor(bVec, bVec, cVec, vector_len);\n+  if (vector_len == Assembler::AVX_512bit) {\n+    __ evprold(bVec, bVec, 7, vector_len);\n+  } else {\n+    __ vpsrld(scratch, bVec, 25, vector_len);\n+    __ vpslld(bVec, bVec, 7, vector_len);\n+    __ vpor(bVec, bVec, scratch, vector_len);\n+  }\n+}\n+\n+\/**\n+ * Shift the b, c, and d vectors between columnar and diagonal representations.\n+ * Note that the \"a\" vector does not shift.\n+ *\n+ * @param bVec the SIMD register containing only the \"b\" values\n+ * @param cVec the SIMD register containing only the \"c\" values\n+ * @param dVec the SIMD register containing only the \"d\" values\n+ * @param vector_len the size of the SIMD register to operate upon\n+ * @param colToDiag true if moving columnar to diagonal, false if\n+ *                  moving diagonal back to columnar.\n+ *\/\n+void StubGenerator::cc20_shift_lane_org(XMMRegister bVec, XMMRegister cVec,\n+    XMMRegister dVec, int vector_len, bool colToDiag) {\n+  int bShift = colToDiag ? 0x39 : 0x93;\n+  int cShift = 0x4E;\n+  int dShift = colToDiag ? 0x93 : 0x39;\n+\n+  __ vpshufd(bVec, bVec, bShift, vector_len);\n+  __ vpshufd(cVec, cVec, cShift, vector_len);\n+  __ vpshufd(dVec, dVec, dShift, vector_len);\n+}\n+\n+\/**\n+ * Write 256 bytes of keystream output held in 4 AVX512 SIMD registers\n+ * in a quarter round parallel organization.\n+ *\n+ * @param aVec the SIMD register containing only the \"a\" values\n+ * @param bVec the SIMD register containing only the \"b\" values\n+ * @param cVec the SIMD register containing only the \"c\" values\n+ * @param dVec the SIMD register containing only the \"d\" values\n+ * @param baseAddr the register holding the base output address\n+ * @param baseOffset the offset from baseAddr for writes\n+ *\/\n+void StubGenerator::cc20_keystream_collate_avx512(XMMRegister aVec, XMMRegister\n+bVec,\n+    XMMRegister cVec, XMMRegister dVec, Register baseAddr, int baseOffset) {\n+  __ vextracti32x4(Address(baseAddr, baseOffset + 0), aVec, 0);\n+  __ vextracti32x4(Address(baseAddr, baseOffset + 64), aVec, 1);\n+  __ vextracti32x4(Address(baseAddr, baseOffset + 128), aVec, 2);\n+  __ vextracti32x4(Address(baseAddr, baseOffset + 192), aVec, 3);\n+\n+  __ vextracti32x4(Address(baseAddr, baseOffset + 16), bVec, 0);\n+  __ vextracti32x4(Address(baseAddr, baseOffset + 80), bVec, 1);\n+  __ vextracti32x4(Address(baseAddr, baseOffset + 144), bVec, 2);\n+  __ vextracti32x4(Address(baseAddr, baseOffset + 208), bVec, 3);\n+\n+  __ vextracti32x4(Address(baseAddr, baseOffset + 32), cVec, 0);\n+  __ vextracti32x4(Address(baseAddr, baseOffset + 96), cVec, 1);\n+  __ vextracti32x4(Address(baseAddr, baseOffset + 160), cVec, 2);\n+  __ vextracti32x4(Address(baseAddr, baseOffset + 224), cVec, 3);\n+\n+  __ vextracti32x4(Address(baseAddr, baseOffset + 48), dVec, 0);\n+  __ vextracti32x4(Address(baseAddr, baseOffset + 112), dVec, 1);\n+  __ vextracti32x4(Address(baseAddr, baseOffset + 176), dVec, 2);\n+  __ vextracti32x4(Address(baseAddr, baseOffset + 240), dVec, 3);\n+}\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_chacha.cpp","additions":582,"deletions":0,"binary":false,"changes":582,"status":"added"},{"patch":"@@ -992,1 +992,1 @@\n-  char buf[512];\n+  char buf[1024];\n@@ -1125,0 +1125,16 @@\n+  \/\/ ChaCha20 Intrinsics\n+  \/\/ As long as the system supports AVX as a baseline we can do a\n+  \/\/ SIMD-enabled block function.  StubGenerator makes the determination\n+  \/\/ based on the VM capabilities whether to use an AVX2 or AVX512-enabled\n+  \/\/ version.\n+  if (UseAVX >= 1) {\n+      if (FLAG_IS_DEFAULT(UseChaCha20Intrinsics)) {\n+          UseChaCha20Intrinsics = true;\n+      }\n+  } else if (UseChaCha20Intrinsics) {\n+      if (!FLAG_IS_DEFAULT(UseChaCha20Intrinsics)) {\n+          warning(\"ChaCha20 intrinsic requires AVX instructions\");\n+      }\n+      FLAG_SET_DEFAULT(UseChaCha20Intrinsics, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_ZERO_CONTINUATIONENTRY_ZERO_HPP\n+#define CPU_ZERO_CONTINUATIONENTRY_ZERO_HPP\n+\n+class ContinuationEntryPD {\n+  \/\/ empty\n+};\n+\n+#endif \/\/ CPU_ZERO_CONTINUATIONENTRY_ZERO_HPP\n","filename":"src\/hotspot\/cpu\/zero\/continuationEntry_zero.hpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -94,0 +94,5 @@\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::patch_caller_links(intptr_t* sp, intptr_t* bottom) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/continuationFreezeThaw_zero.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, intptr_t* sp) {\n+inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, const frame& caller) {\n@@ -123,0 +123,5 @@\n+inline intptr_t* ContinuationHelper::InterpretedFrame::callers_sp(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/continuationHelper_zero.inline.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,0 +35,7 @@\n+    \/\/ size, in words, of metadata at frame bottom, i.e. it is not part of the\n+    \/\/ caller\/callee overlap\n+    metadata_words_at_bottom                         = metadata_words,\n+    \/\/ size, in words, of frame metadata at the frame top, i.e. it is located\n+    \/\/ between a callee frame and its stack arguments, where it is part\n+    \/\/ of the caller\/callee overlap\n+    metadata_words_at_top                            = 0,\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -719,3 +719,14 @@\n-  const char* l_path = LINUX_ONLY(os::Linux::dll_path(lib))\n-                       NOT_LINUX(\"<not available>\");\n-  if (l_path == NULL) l_path = \"<not available>\";\n+  \/\/ os::Linux::dll_path returns a pointer to a string that is owned by the dynamic loader. Upon\n+  \/\/ calling dlclose the dynamic loader may free the memory containing the string, thus we need to\n+  \/\/ copy the string to be able to reference it after dlclose.\n+  const char* l_path = NULL;\n+#ifdef LINUX\n+  char* l_pathdup = NULL;\n+  l_path = os::Linux::dll_path(lib);\n+  if (l_path != NULL) {\n+    l_path = l_pathdup = os::strdup(l_path);\n+  }\n+#endif  \/\/ LINUX\n+  if (l_path == NULL) {\n+    l_path = \"<not available>\";\n+  }\n@@ -739,0 +750,1 @@\n+  LINUX_ONLY(os::free(l_pathdup));\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -78,0 +78,14 @@\n+VM_Version::VM_MODE VM_Version::get_satp_mode() {\n+  if (!strcmp(_vm_mode, \"sv39\")) {\n+    return VM_SV39;\n+  } else if (!strcmp(_vm_mode, \"sv48\")) {\n+    return VM_SV48;\n+  } else if (!strcmp(_vm_mode, \"sv57\")) {\n+    return VM_SV57;\n+  } else if (!strcmp(_vm_mode, \"sv64\")) {\n+    return VM_SV64;\n+  } else {\n+    return VM_MBARE;\n+  }\n+}\n+\n@@ -106,1 +120,8 @@\n-        if (strncmp(buf, \"uarch\", sizeof \"uarch\" - 1) == 0) {\n+        if (strncmp(buf, \"mmu\", sizeof \"mmu\" - 1) == 0) {\n+          if (_vm_mode[0] != '\\0') {\n+            continue;\n+          }\n+          char* vm_mode = os::strdup(p + 2);\n+          vm_mode[strcspn(vm_mode, \"\\n\")] = '\\0';\n+          _vm_mode = vm_mode;\n+        } else if (strncmp(buf, \"uarch\", sizeof \"uarch\" - 1) == 0) {\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -766,0 +766,1 @@\n+  assert(current == JavaThread::current(), \"pre-condition\");\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+\n+bool    ArchiveHeapLoader::_narrow_oop_base_initialized = false;\n@@ -62,2 +64,16 @@\n-\/\/ Support for mapped heap (!UseCompressedOops only)\n-ptrdiff_t ArchiveHeapLoader::_runtime_delta = 0;\n+\/\/ Support for mapped heap.\n+bool      ArchiveHeapLoader::_mapped_heap_relocation_initialized = false;\n+ptrdiff_t ArchiveHeapLoader::_mapped_heap_delta = 0;\n+\n+\/\/ Every mapped region is offset by _mapped_heap_delta from its requested address.\n+\/\/ See FileMapInfo::heap_region_requested_address().\n+void ArchiveHeapLoader::init_mapped_heap_relocation(ptrdiff_t delta, int dumptime_oop_shift) {\n+  assert(!_mapped_heap_relocation_initialized, \"only once\");\n+  if (!UseCompressedOops) {\n+    assert(dumptime_oop_shift == 0, \"sanity\");\n+  }\n+  assert(can_map(), \"sanity\");\n+  init_narrow_oop_decoding(CompressedOops::base() + delta, dumptime_oop_shift);\n+  _mapped_heap_delta = delta;\n+  _mapped_heap_relocation_initialized = true;\n+}\n@@ -66,0 +82,2 @@\n+  assert(!_narrow_oop_base_initialized, \"only once\");\n+  _narrow_oop_base_initialized = true;\n@@ -115,1 +133,1 @@\n-    intptr_t runtime_oop = dumptime_oop + ArchiveHeapLoader::runtime_delta();\n+    intptr_t runtime_oop = dumptime_oop + ArchiveHeapLoader::mapped_heap_delta();\n@@ -195,0 +213,4 @@\n+  if (!UseCompressedOops) {\n+    \/\/ Pointer relocation for uncompressed oops is unimplemented.\n+    return false;\n+  }\n@@ -230,0 +252,1 @@\n+    assert(UseCompressedOops, \"PatchLoadedRegionPointers for uncompressed oops is unimplemented\");\n@@ -236,1 +259,0 @@\n-\n@@ -267,1 +289,1 @@\n-      ri->_dumptime_base = (uintptr_t)mapinfo->start_address_as_decoded_from_archive(r);\n+      ri->_dumptime_base = (uintptr_t)mapinfo->heap_region_dumptime_address(r);\n@@ -349,0 +371,1 @@\n+  assert(UseCompressedOops, \"loaded heap for !UseCompressedOops is unimplemented\");\n@@ -389,1 +412,2 @@\n-    ShouldNotReachHere();\n+    \/\/ Uncompressed oops are not supported by loaded heaps.\n+    Unimplemented();\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.cpp","additions":30,"deletions":6,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -76,3 +76,4 @@\n-  static ptrdiff_t runtime_delta() {\n-    assert(!UseCompressedOops, \"must be\");\n-    CDS_JAVA_HEAP_ONLY(return _runtime_delta;)\n+  static ptrdiff_t mapped_heap_delta() {\n+    CDS_JAVA_HEAP_ONLY(assert(!is_loaded(), \"must be\"));\n+    CDS_JAVA_HEAP_ONLY(assert(_mapped_heap_relocation_initialized, \"must be\"));\n+    CDS_JAVA_HEAP_ONLY(return _mapped_heap_delta;)\n@@ -105,2 +106,0 @@\n-  static void init_narrow_oop_decoding(address base, int shift) NOT_CDS_JAVA_HEAP_RETURN;\n-\n@@ -113,0 +112,1 @@\n+  static void init_mapped_heap_relocation(ptrdiff_t delta, int dumptime_oop_shift);\n@@ -135,0 +135,1 @@\n+  static bool    _narrow_oop_base_initialized;\n@@ -138,2 +139,4 @@\n-  \/\/ !UseCompressedOops only: used to relocate pointers to the archived objects\n-  static ptrdiff_t _runtime_delta;\n+  \/\/ is_mapped() only: the mapped address of each region is offset by this amount from\n+  \/\/ their requested address.\n+  static ptrdiff_t _mapped_heap_delta;\n+  static bool      _mapped_heap_relocation_initialized;\n@@ -141,0 +144,1 @@\n+  static void init_narrow_oop_decoding(address base, int shift);\n@@ -164,5 +168,0 @@\n-\n-  static void set_runtime_delta(ptrdiff_t delta) {\n-    assert(!UseCompressedOops, \"must be\");\n-    _runtime_delta = delta;\n-  }\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.hpp","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+  assert(_narrow_oop_base_initialized, \"relocation information must have been initialized\");\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -331,1 +331,2 @@\n-      intptr_t runtime_oop = dumptime_oop + ArchiveHeapLoader::runtime_delta();\n+      assert(!ArchiveHeapLoader::is_loaded(), \"ArchiveHeapLoader::can_load() is not supported for uncompessed oops\");\n+      intptr_t runtime_oop = dumptime_oop + ArchiveHeapLoader::mapped_heap_delta();\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,12 +33,12 @@\n-  { \"GenericCDSFileMapHeader::_magic\",                     offset_of(GenericCDSFileMapHeader, _magic)          },\n-  { \"GenericCDSFileMapHeader::_crc\",                       offset_of(GenericCDSFileMapHeader, _crc)            },\n-  { \"GenericCDSFileMapHeader::_version\",                   offset_of(GenericCDSFileMapHeader, _version)        },\n-  { \"GenericCDSFileMapHeader::_header_size\",               offset_of(GenericCDSFileMapHeader, _header_size)    },\n-  { \"GenericCDSFileMapHeader::_common_app_classpath_prefix_size\", offset_of(GenericCDSFileMapHeader, _common_app_classpath_prefix_size) },\n-  { \"GenericCDSFileMapHeader::_base_archive_name_offset\",  offset_of(GenericCDSFileMapHeader, _base_archive_name_offset) },\n-  { \"GenericCDSFileMapHeader::_base_archive_name_size\",    offset_of(GenericCDSFileMapHeader, _base_archive_name_size)   },\n-  { \"CDSFileMapHeaderBase::_regions[0]\",                   offset_of(CDSFileMapHeaderBase, _regions)           },\n-  { \"FileMapHeader::_jvm_ident\",                           offset_of(FileMapHeader, _jvm_ident)                },\n-  { \"CDSFileMapRegion::_crc\",                              offset_of(CDSFileMapRegion, _crc)                   },\n-  { \"CDSFileMapRegion::_used\",                             offset_of(CDSFileMapRegion, _used)                  },\n-  { \"DynamicArchiveHeader::_base_region_crc\",              offset_of(DynamicArchiveHeader, _base_region_crc)   }\n+  { \"GenericCDSFileMapHeader::_magic\",                    offset_of(GenericCDSFileMapHeader, _magic)                    },\n+  { \"GenericCDSFileMapHeader::_crc\",                      offset_of(GenericCDSFileMapHeader, _crc)                      },\n+  { \"GenericCDSFileMapHeader::_version\",                  offset_of(GenericCDSFileMapHeader, _version)                  },\n+  { \"GenericCDSFileMapHeader::_header_size\",              offset_of(GenericCDSFileMapHeader, _header_size)              },\n+  { \"GenericCDSFileMapHeader::_base_archive_name_offset\", offset_of(GenericCDSFileMapHeader, _base_archive_name_offset) },\n+  { \"GenericCDSFileMapHeader::_base_archive_name_size\",   offset_of(GenericCDSFileMapHeader, _base_archive_name_size)   },\n+  { \"CDSFileMapHeaderBase::_regions[0]\",                  offset_of(CDSFileMapHeaderBase, _regions)                     },\n+  { \"FileMapHeader::_jvm_ident\",                          offset_of(FileMapHeader, _jvm_ident)                          },\n+  { \"FileMapHeader::_common_app_classpath_prefix_size\",   offset_of(FileMapHeader, _common_app_classpath_prefix_size)   },\n+  { \"CDSFileMapRegion::_crc\",                             offset_of(CDSFileMapRegion, _crc)                             },\n+  { \"CDSFileMapRegion::_used\",                            offset_of(CDSFileMapRegion, _used)                            },\n+  { \"DynamicArchiveHeader::_base_region_crc\",             offset_of(DynamicArchiveHeader, _base_region_crc)             }\n","filename":"src\/hotspot\/share\/cds\/cdsConstants.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1270,4 +1270,0 @@\n-    if (!check_common_app_classpath_prefix_len()) {\n-      return false;\n-    }\n-\n@@ -1354,9 +1350,0 @@\n-\n-  bool check_common_app_classpath_prefix_len() {\n-    int common_path_size = _header->_common_app_classpath_prefix_size;\n-    if (common_path_size < 0) {\n-      FileMapInfo::fail_continue(\"common app classpath prefix len < 0\");\n-      return false;\n-    }\n-    return true;\n-  }\n@@ -1437,0 +1424,6 @@\n+  int common_path_size = header()->common_app_classpath_prefix_size();\n+  if (common_path_size < 0) {\n+      FileMapInfo::fail_continue(\"common app classpath prefix len < 0\");\n+      return false;\n+  }\n+\n@@ -1639,1 +1632,2 @@\n-      mapping_offset = (size_t)CompressedOops::encode_not_null(cast_to_oop(base));\n+      mapping_offset = (size_t)((address)base - CompressedOops::base());\n+      assert((mapping_offset >> CompressedOops::shift()) << CompressedOops::shift() == mapping_offset, \"must be\");\n@@ -1645,1 +1639,0 @@\n-    assert(mapping_offset == (size_t)(uint32_t)mapping_offset, \"must be 32-bit only\");\n@@ -2070,10 +2063,0 @@\n-address FileMapInfo::decode_start_address(FileMapRegion* spc, bool with_current_oop_encoding_mode) {\n-  size_t offset = spc->mapping_offset();\n-  narrowOop n = CompressedOops::narrow_oop_cast(offset);\n-  if (with_current_oop_encoding_mode) {\n-    return cast_from_oop<address>(CompressedOops::decode_raw_not_null(n));\n-  } else {\n-    return cast_from_oop<address>(ArchiveHeapLoader::decode_from_archive(n));\n-  }\n-}\n-\n@@ -2094,1 +2077,1 @@\n-MemRegion FileMapInfo::get_heap_regions_range_with_current_oop_encoding_mode() {\n+MemRegion FileMapInfo::get_heap_regions_requested_range() {\n@@ -2104,1 +2087,1 @@\n-      address s = start_address_as_decoded_with_current_oop_encoding_mode(r);\n+      address s = heap_region_requested_address(r);\n@@ -2106,0 +2089,2 @@\n+      log_info(cds)(\"Heap region %s = \" INTPTR_FORMAT \" - \" INTPTR_FORMAT \" = \"  SIZE_FORMAT_W(8) \" bytes\",\n+                    region_name(i), p2i(s), p2i(e), size);\n@@ -2115,0 +2100,4 @@\n+\n+  start = align_down(start, HeapRegion::GrainBytes);\n+  end = align_up(end, HeapRegion::GrainBytes);\n+\n@@ -2127,1 +2116,6 @@\n-      log_info(cds)(\"Cannot use CDS heap data. UseEpsilonGC, UseG1GC, UseSerialGC or UseParallelGC are required.\");\n+      if (!UseCompressedOops && !ArchiveHeapLoader::can_map()) {\n+        \/\/ TODO - remove implicit knowledge of G1\n+        log_info(cds)(\"Cannot use CDS heap data. UseG1GC is required for -XX:-UseCompressedOops\");\n+      } else {\n+        log_info(cds)(\"Cannot use CDS heap data. UseEpsilonGC, UseG1GC, UseSerialGC or UseParallelGC are required.\");\n+      }\n@@ -2182,3 +2176,2 @@\n-\/\/ The address where the bottom of this shared heap region should be mapped\n-\/\/ at runtime\n-address FileMapInfo::heap_region_runtime_start_address(FileMapRegion* spc) {\n+\/\/ The actual address of this region during dump time.\n+address FileMapInfo::heap_region_dumptime_address(FileMapRegion* r) {\n@@ -2186,1 +2179,2 @@\n-  spc->assert_is_heap_region();\n+  r->assert_is_heap_region();\n+  assert(is_aligned(r->mapping_offset(), sizeof(HeapWord)), \"must be\");\n@@ -2188,1 +2182,1 @@\n-    return start_address_as_decoded_from_archive(spc);\n+    return \/*dumptime*\/ narrow_oop_base() + r->mapping_offset();\n@@ -2190,2 +2184,1 @@\n-    assert(is_aligned(spc->mapping_offset(), sizeof(HeapWord)), \"must be\");\n-    return header()->heap_begin() + spc->mapping_offset() + ArchiveHeapLoader::runtime_delta();\n+    return heap_region_requested_address(r);\n@@ -2195,1 +2188,7 @@\n-void FileMapInfo::set_shared_heap_runtime_delta(ptrdiff_t delta) {\n+\/\/ The address where this region can be mapped into the runtime heap without\n+\/\/ patching any of the pointers that are embedded in this region.\n+address FileMapInfo::heap_region_requested_address(FileMapRegion* r) {\n+  assert(UseSharedSpaces, \"runtime only\");\n+  r->assert_is_heap_region();\n+  assert(is_aligned(r->mapping_offset(), sizeof(HeapWord)), \"must be\");\n+  assert(ArchiveHeapLoader::can_map(), \"cannot be used by ArchiveHeapLoader::can_load() mode\");\n@@ -2197,1 +2196,13 @@\n-    ArchiveHeapLoader::init_narrow_oop_decoding(narrow_oop_base() + delta, narrow_oop_shift());\n+    \/\/ We can avoid relocation if each region's offset from the runtime CompressedOops::base()\n+    \/\/ is the same as its offset from the CompressedOops::base() during dumptime.\n+    \/\/ Note that CompressedOops::base() may be different between dumptime and runtime.\n+    \/\/\n+    \/\/ Example:\n+    \/\/ Dumptime base = 0x1000 and shift is 0. We have a region at address 0x2000. There's a\n+    \/\/ narrowOop P stored in this region that points to an object at address 0x2200.\n+    \/\/ P's encoded value is 0x1200.\n+    \/\/\n+    \/\/ Runtime base = 0x4000 and shift is also 0. If we map this region at 0x5000, then\n+    \/\/ the value P can remain 0x1200. The decoded address = (0x4000 + (0x1200 << 0)) = 0x5200,\n+    \/\/ which is the runtime location of the referenced object.\n+    return \/*runtime*\/ CompressedOops::base() + r->mapping_offset();\n@@ -2199,1 +2210,3 @@\n-    ArchiveHeapLoader::set_runtime_delta(delta);\n+    \/\/ We can avoid relocation if each region is mapped into the exact same address\n+    \/\/ where it was at dump time.\n+    return \/*dumptime*\/header()->heap_begin() + r->mapping_offset();\n@@ -2203,0 +2216,9 @@\n+\/\/ The address where this shared heap region is actually mapped at runtime. This function\n+\/\/ can be called only after we have determined the value for ArchiveHeapLoader::mapped_heap_delta().\n+address FileMapInfo::heap_region_mapped_address(FileMapRegion* r) {\n+  assert(UseSharedSpaces, \"runtime only\");\n+  r->assert_is_heap_region();\n+  assert(ArchiveHeapLoader::can_map(), \"cannot be used by ArchiveHeapLoader::can_load() mode\");\n+  return heap_region_requested_address(r) + ArchiveHeapLoader::mapped_heap_delta();\n+}\n+\n@@ -2218,3 +2240,16 @@\n-  if (narrow_oop_mode() != CompressedOops::mode() ||\n-      narrow_oop_base() != CompressedOops::base() ||\n-      narrow_oop_shift() != CompressedOops::shift()) {\n+  \/\/ G1 -- always map at the very top of the heap to avoid fragmentation.\n+  assert(UseG1GC, \"the following code assumes G1\");\n+  _heap_pointers_need_patching = false;\n+\n+  MemRegion heap_range = G1CollectedHeap::heap()->reserved();\n+  MemRegion archive_range = get_heap_regions_requested_range();\n+\n+  address heap_end = (address)heap_range.end();\n+  address archive_end = (address)archive_range.end();\n+\n+  assert(is_aligned(heap_end, HeapRegion::GrainBytes), \"must be\");\n+  assert(is_aligned(archive_end, HeapRegion::GrainBytes), \"must be\");\n+\n+  if (UseCompressedOops &&\n+      (narrow_oop_mode() != CompressedOops::mode() ||\n+       narrow_oop_shift() != CompressedOops::shift())) {\n@@ -2223,0 +2258,5 @@\n+  } else if (!heap_range.contains(archive_range)) {\n+    log_info(cds)(\"CDS heap data needs to be relocated because\");\n+    log_info(cds)(\"the desired range \" PTR_FORMAT \" - \"  PTR_FORMAT, p2i(archive_range.start()), p2i(archive_range.end()));\n+    log_info(cds)(\"is outside of the heap \" PTR_FORMAT \" - \"  PTR_FORMAT, p2i(heap_range.start()), p2i(heap_range.end()));\n+    _heap_pointers_need_patching = true;\n@@ -2224,23 +2264,4 @@\n-    if (UseCompressedOops) {\n-      MemRegion range = get_heap_regions_range_with_current_oop_encoding_mode();\n-      if (!CompressedOops::is_in(range)) {\n-        log_info(cds)(\"CDS heap data needs to be relocated because\");\n-        log_info(cds)(\"the desired range \" PTR_FORMAT \" - \"  PTR_FORMAT, p2i(range.start()), p2i(range.end()));\n-        log_info(cds)(\"is outside of the heap \" PTR_FORMAT \" - \"  PTR_FORMAT, p2i(CompressedOops::begin()), p2i(CompressedOops::end()));\n-        _heap_pointers_need_patching = true;\n-      } else if (header()->heap_end() != CompressedOops::end()) {\n-        log_info(cds)(\"CDS heap data needs to be relocated to the end of the runtime heap to reduce fragmentation\");\n-        _heap_pointers_need_patching = true;\n-      }\n-    } else {\n-      MemRegion range((HeapWord*)header()->heap_begin(), (HeapWord*)header()->heap_end());\n-      if (!G1CollectedHeap::heap()->reserved().contains(range)) {\n-        log_info(cds)(\"CDS heap data needs to be relocated because\");\n-        log_info(cds)(\"the desired range \" PTR_FORMAT \" - \"  PTR_FORMAT, p2i(range.start()), p2i(range.end()));\n-        log_info(cds)(\"is outside of the heap \" PTR_FORMAT \" - \"  PTR_FORMAT,\n-            p2i((address)G1CollectedHeap::heap()->reserved().start()), p2i((address)G1CollectedHeap::heap()->reserved().end()));\n-        _heap_pointers_need_patching = true;\n-      } else if (header()->heap_end() != (address)G1CollectedHeap::heap()->reserved().end()) {\n-        log_info(cds)(\"CDS heap data needs to be relocated to the end of the runtime heap to reduce fragmentation\");\n-        _heap_pointers_need_patching = true;\n-      }\n+    assert(heap_end >= archive_end, \"must be\");\n+    if (heap_end != archive_end) {\n+      log_info(cds)(\"CDS heap data needs to be relocated to the end of the runtime heap to reduce fragmentation\");\n+      _heap_pointers_need_patching = true;\n@@ -2252,23 +2273,1 @@\n-    \/\/   dumptime heap end  ------------v\n-    \/\/   [      |archived heap regions| ]         run time heap end -----v\n-    \/\/                                       [   |archived heap regions| ]\n-    \/\/          ^\n-    \/\/          D                                ^\n-    \/\/                                           R\n-    \/\/                                  |<-----delta-------------------->|\n-    \/\/\n-    \/\/ At dump time, the archived heap regions were near the top of the heap.\n-    \/\/ At run time, if the heap ends at a different address, we need to\n-    \/\/ move them near to top of the run time heap. This can be done by\n-    \/\/ the simple math of adding the delta as shown above.\n-    \/\/\n-    \/\/ Also: D = bottom of a heap region at dump time\n-    \/\/       R = bottom of a heap region at run time\n-    \/\/\n-    \/\/ FileMapRegion* spc = ...;\n-    \/\/   address D = header()->heap_begin() + spc->mapping_offset();\n-    \/\/   address R = D + delta;\n-    address dumptime_heap_end = header()->heap_end();\n-    address runtime_heap_end = UseCompressedOops ? CompressedOops::end() :\n-                                                   (address)G1CollectedHeap::heap()->reserved().end();\n-    delta = runtime_heap_end - dumptime_heap_end;\n+    delta = heap_end - archive_end;\n@@ -2279,2 +2278,0 @@\n-  set_shared_heap_runtime_delta(delta);\n-\n@@ -2282,1 +2279,1 @@\n-  address relocated_closed_heap_region_bottom = heap_region_runtime_start_address(r);\n+  address relocated_closed_heap_region_bottom = heap_region_requested_address(r) + delta;\n@@ -2294,2 +2291,0 @@\n-    set_shared_heap_runtime_delta(delta);\n-    relocated_closed_heap_region_bottom = heap_region_runtime_start_address(r);\n@@ -2298,0 +2293,4 @@\n+\n+  ArchiveHeapLoader::init_mapped_heap_relocation(delta, narrow_oop_shift());\n+  relocated_closed_heap_region_bottom = heap_region_mapped_address(r);\n+\n@@ -2363,1 +2362,1 @@\n-      HeapWord* start = (HeapWord*)heap_region_runtime_start_address(r);\n+      HeapWord* start = (HeapWord*)heap_region_mapped_address(r);\n@@ -2428,1 +2427,0 @@\n-  log_info(cds)(\"patching heap embedded pointers\");\n@@ -2443,1 +2441,18 @@\n-    FileMapRegion* r = region_at(i + first_region_idx);\n+    int region_idx = i + first_region_idx;\n+    FileMapRegion* r = region_at(region_idx);\n+    if (UseCompressedOops) {\n+      \/\/ These are the encoded values for the bottom of this region at dump-time vs run-time:\n+      narrowOop dt_encoded_bottom = CompressedOops::narrow_oop_cast(r->mapping_offset() >> narrow_oop_shift());\n+      narrowOop rt_encoded_bottom = CompressedOops::encode_not_null(cast_to_oop(regions[i].start()));\n+      log_info(cds)(\"patching heap embedded pointers for %s: narrowOop 0x%8x -> 0x%8x\",\n+                    region_name(region_idx), (uint)dt_encoded_bottom, (uint)rt_encoded_bottom);\n+      \/\/ TODO JDK-8269736: if we have the same narrow_oop_shift between dumptime and runtime,\n+      \/\/ Each embedded pointer P can be updated by:\n+      \/\/     P += (rt_encoded_bottom - dt_encoded_bottom)\n+      \/\/\n+      \/\/ TODO:\n+      \/\/ if (dt_encoded_bottom == rt_encoded_bottom && narrow_oop_shift() == CompressedOops::shift()) {\n+      \/\/   \/\/nothing to do\n+      \/\/   return;\n+      \/\/ }\n+    }\n@@ -2609,0 +2624,1 @@\n+  assert(UseSharedSpaces, \"must be\");\n@@ -2610,7 +2626,1 @@\n-  if (HeapShared::is_heap_region(idx)) {\n-    assert(DumpSharedSpaces, \"The following doesn't work at runtime\");\n-    return r->used() > 0 ?\n-          (char*)start_address_as_decoded_with_current_oop_encoding_mode(r) : NULL;\n-  } else {\n-    return r->mapped_base();\n-  }\n+  return r->mapped_base();\n@@ -2736,11 +2746,0 @@\n-\/\/ Check if a given address is within one of the shared regions\n-bool FileMapInfo::is_in_shared_region(const void* p, int idx) {\n-  assert(idx == MetaspaceShared::ro ||\n-         idx == MetaspaceShared::rw, \"invalid region index\");\n-  char* base = region_addr(idx);\n-  if (p >= base && p < base + region_at(idx)->used()) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":112,"deletions":113,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -192,15 +192,17 @@\n-  size_t _core_region_alignment;    \/\/ how shared archive should be aligned\n-  int    _obj_alignment;            \/\/ value of ObjectAlignmentInBytes\n-  address _narrow_oop_base;         \/\/ compressed oop encoding base\n-  int    _narrow_oop_shift;         \/\/ compressed oop encoding shift\n-  bool   _compact_strings;          \/\/ value of CompactStrings\n-  uintx  _max_heap_size;            \/\/ java max heap size during dumping\n-  CompressedOops::Mode _narrow_oop_mode; \/\/ compressed oop encoding mode\n-  int     _narrow_klass_shift;      \/\/ save narrow klass base and shift\n-  bool    _compressed_oops;         \/\/ save the flag UseCompressedOops\n-  bool    _compressed_class_ptrs;   \/\/ save the flag UseCompressedClassPointers\n-  size_t  _cloned_vtables_offset;   \/\/ The address of the first cloned vtable\n-  size_t  _serialized_data_offset;  \/\/ Data accessed using {ReadClosure,WriteClosure}::serialize()\n-  address _heap_begin;              \/\/ heap begin at dump time.\n-  address _heap_end;                \/\/ heap end at dump time.\n-  bool _has_non_jar_in_classpath;   \/\/ non-jar file entry exists in classpath\n+  size_t _core_region_alignment;                  \/\/ how shared archive should be aligned\n+  int    _obj_alignment;                          \/\/ value of ObjectAlignmentInBytes\n+  address _narrow_oop_base;                       \/\/ compressed oop encoding base\n+  int    _narrow_oop_shift;                       \/\/ compressed oop encoding shift\n+  bool   _compact_strings;                        \/\/ value of CompactStrings\n+  uintx  _max_heap_size;                          \/\/ java max heap size during dumping\n+  CompressedOops::Mode _narrow_oop_mode;          \/\/ compressed oop encoding mode\n+  int     _narrow_klass_shift;                    \/\/ save narrow klass base and shift\n+  bool    _compressed_oops;                       \/\/ save the flag UseCompressedOops\n+  bool    _compressed_class_ptrs;                 \/\/ save the flag UseCompressedClassPointers\n+  size_t  _cloned_vtables_offset;                 \/\/ The address of the first cloned vtable\n+  size_t  _serialized_data_offset;                \/\/ Data accessed using {ReadClosure,WriteClosure}::serialize()\n+  address _heap_begin;                            \/\/ heap begin at dump time.\n+  address _heap_end;                              \/\/ heap end at dump time.\n+  bool _has_non_jar_in_classpath;                 \/\/ non-jar file entry exists in classpath\n+  unsigned int _common_app_classpath_prefix_size; \/\/ size of the common prefix of app class paths\n+                                                  \/\/    0 if no common prefix exists\n@@ -243,15 +245,15 @@\n-  unsigned int magic()                    const { return _generic_header._magic;    }\n-  int crc()                               const { return _generic_header._crc;      }\n-  int version()                           const { return _generic_header._version;  }\n-  unsigned int header_size()              const { return _generic_header._header_size;              }\n-  unsigned int base_archive_name_offset() const { return _generic_header._base_archive_name_offset; }\n-  unsigned int base_archive_name_size()   const { return _generic_header._base_archive_name_size;   }\n-  unsigned int common_app_classpath_prefix_size() const { return _generic_header._common_app_classpath_prefix_size; }\n-\n-  void set_magic(unsigned int m)                    { _generic_header._magic = m;       }\n-  void set_crc(int crc_value)                       { _generic_header._crc = crc_value; }\n-  void set_version(int v)                           { _generic_header._version = v;     }\n-  void set_header_size(unsigned int s)              { _generic_header._header_size = s;              }\n-  void set_base_archive_name_offset(unsigned int s) { _generic_header._base_archive_name_offset = s; }\n-  void set_base_archive_name_size(unsigned int s)   { _generic_header._base_archive_name_size = s;   }\n-  void set_common_app_classpath_prefix_size(unsigned int s) { _generic_header._common_app_classpath_prefix_size = s; }\n+  unsigned int magic()                            const { return _generic_header._magic;                    }\n+  int crc()                                       const { return _generic_header._crc;                      }\n+  int version()                                   const { return _generic_header._version;                  }\n+  unsigned int header_size()                      const { return _generic_header._header_size;              }\n+  unsigned int base_archive_name_offset()         const { return _generic_header._base_archive_name_offset; }\n+  unsigned int base_archive_name_size()           const { return _generic_header._base_archive_name_size;   }\n+  unsigned int common_app_classpath_prefix_size() const { return _common_app_classpath_prefix_size;         }\n+\n+  void set_magic(unsigned int m)                            { _generic_header._magic = m;                    }\n+  void set_crc(int crc_value)                               { _generic_header._crc = crc_value;              }\n+  void set_version(int v)                                   { _generic_header._version = v;                  }\n+  void set_header_size(unsigned int s)                      { _generic_header._header_size = s;              }\n+  void set_base_archive_name_offset(unsigned int s)         { _generic_header._base_archive_name_offset = s; }\n+  void set_base_archive_name_size(unsigned int s)           { _generic_header._base_archive_name_size = s;   }\n+  void set_common_app_classpath_prefix_size(unsigned int s) { _common_app_classpath_prefix_size = s;         }\n@@ -469,1 +471,1 @@\n-  MemRegion get_heap_regions_range_with_current_oop_encoding_mode() NOT_CDS_JAVA_HEAP_RETURN_(MemRegion());\n+  MemRegion get_heap_regions_requested_range() NOT_CDS_JAVA_HEAP_RETURN_(MemRegion());\n@@ -491,1 +493,0 @@\n-  bool is_in_shared_region(const void* p, int idx) NOT_CDS_RETURN_(false);\n@@ -584,2 +585,0 @@\n-  address heap_region_runtime_start_address(FileMapRegion* spc) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n-  void set_shared_heap_runtime_delta(ptrdiff_t delta) NOT_CDS_JAVA_HEAP_RETURN;\n@@ -592,6 +591,0 @@\n-  address decode_start_address(FileMapRegion* spc, bool with_current_oop_encoding_mode);\n-\n-  \/\/ The starting address of spc, as calculated with CompressedOop::decode_non_null()\n-  address start_address_as_decoded_with_current_oop_encoding_mode(FileMapRegion* spc) {\n-    return decode_start_address(spc, true);\n-  }\n@@ -599,4 +592,3 @@\n-  \/\/ The starting address of spc, as calculated with HeapShared::decode_from_archive()\n-  address start_address_as_decoded_from_archive(FileMapRegion* spc) {\n-    return decode_start_address(spc, false);\n-  }\n+  address heap_region_dumptime_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  address heap_region_requested_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  address heap_region_mapped_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":36,"deletions":44,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -836,1 +836,1 @@\n-void HeapShared::serialize(SerializeClosure* soc) {\n+void HeapShared::serialize_root(SerializeClosure* soc) {\n@@ -852,0 +852,3 @@\n+}\n+\n+void HeapShared::serialize_tables(SerializeClosure* soc) {\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -413,1 +413,2 @@\n-  static void serialize(SerializeClosure* soc) NOT_CDS_JAVA_HEAP_RETURN;\n+  static void serialize_root(SerializeClosure* soc) NOT_CDS_JAVA_HEAP_RETURN;\n+  static void serialize_tables(SerializeClosure* soc) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -378,0 +378,1 @@\n+  HeapShared::serialize_root(soc);\n@@ -388,1 +389,1 @@\n-  HeapShared::serialize(soc);\n+  HeapShared::serialize_tables(soc);\n@@ -958,5 +959,0 @@\n-\/\/ Return true if given address is in the misc data region\n-bool MetaspaceShared::is_in_shared_region(const void* p, int idx) {\n-  return UseSharedSpaces && FileMapInfo::current_info()->is_in_shared_region(p, idx);\n-}\n-\n@@ -1502,0 +1498,2 @@\n+  CDS_JAVA_HEAP_ONLY(Universe::update_archived_basic_type_mirrors());\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -117,3 +117,0 @@\n-  \/\/ Return true if given address is in the shared region corresponding to the idx\n-  static bool is_in_shared_region(const void* p, int idx) NOT_CDS_RETURN_(false);\n-\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,2 +29,1 @@\n-#include \"ci\/ciUtilities.inline.hpp\"\n-#include \"memory\/universe.hpp\"\n+#include \"ci\/ciUtilities.hpp\"\n@@ -107,1 +106,0 @@\n-\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,1 +72,0 @@\n-  _transitive_interfaces = NULL;\n@@ -733,25 +732,0 @@\n-GrowableArray<ciInstanceKlass*>* ciInstanceKlass::transitive_interfaces() const{\n-  if (_transitive_interfaces == NULL) {\n-    const_cast<ciInstanceKlass*>(this)->compute_transitive_interfaces();\n-  }\n-  return _transitive_interfaces;\n-}\n-\n-void ciInstanceKlass::compute_transitive_interfaces() {\n-  GUARDED_VM_ENTRY(\n-          InstanceKlass* ik = get_instanceKlass();\n-          Array<InstanceKlass*>* interfaces = ik->transitive_interfaces();\n-          Arena* arena = CURRENT_ENV->arena();\n-          int len = interfaces->length() + (is_interface() ? 1 : 0);\n-          GrowableArray<ciInstanceKlass*>* transitive_interfaces = new(arena)GrowableArray<ciInstanceKlass*>(arena, len,\n-                                                                                                             0, NULL);\n-          for (int i = 0; i < interfaces->length(); i++) {\n-            transitive_interfaces->append(CURRENT_ENV->get_instance_klass(interfaces->at(i)));\n-          }\n-          if (is_interface()) {\n-            transitive_interfaces->append(this);\n-          }\n-          _transitive_interfaces = transitive_interfaces;\n-  );\n-}\n-\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-  GrowableArray<ciInstanceKlass*>* _transitive_interfaces;\n@@ -83,1 +82,0 @@\n-  void compute_transitive_interfaces();\n@@ -297,1 +295,0 @@\n-  GrowableArray<ciInstanceKlass*>* transitive_interfaces() const;\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -170,1 +170,0 @@\n-        obj->as_instance_klass()->transitive_interfaces();\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -827,2 +827,1 @@\n-    \/\/ method to be rewritten (number of arguments at a call for\n-    \/\/ instance)\n+    \/\/ method to be rewritten (number of arguments at a call for instance)\n@@ -830,11 +829,4 @@\n-    \/\/ Method::build_profiling_method_data(method, CHECK);\n-    {\n-      \/\/ Grab a lock here to prevent multiple\n-      \/\/ MethodData*s from being created.\n-      MutexLocker ml(THREAD, MethodData_lock);\n-      if (method->method_data() == NULL) {\n-        ClassLoaderData* loader_data = method->method_holder()->class_loader_data();\n-        MethodData* method_data = MethodData::allocate(loader_data, methodHandle(THREAD, method), CHECK);\n-        method->set_method_data(method_data);\n-      }\n-    }\n+    assert(method->method_data() == NULL, \"Should only be initialized once\");\n+    ClassLoaderData* loader_data = method->method_holder()->class_loader_data();\n+    MethodData* method_data = MethodData::allocate(loader_data, methodHandle(THREAD, method), CHECK);\n+    method->set_method_data(method_data);\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -372,0 +372,7 @@\n+void ClassLoaderDataGraph::loaded_cld_do_no_keepalive(CLDClosure* cl) {\n+  ClassLoaderDataGraphIteratorNoKeepAlive iter;\n+  while (ClassLoaderData* cld = iter.get_next()) {\n+    cl->do_cld(cld);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+  static void loaded_cld_do_no_keepalive(CLDClosure* cl);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,4 @@\n-  oop cl = cld->class_loader();\n+  \/\/ Class loaders are not kept alive so this closure must only be\n+  \/\/ used during a safepoint.\n+  assert_at_safepoint();\n+  oop cl = cld->class_loader_no_keepalive();\n@@ -66,1 +69,1 @@\n-    cls->_parent = java_lang_ClassLoader::parent(cl);\n+    cls->_parent = java_lang_ClassLoader::parent_no_keepalive(cl);\n@@ -152,1 +155,1 @@\n-      cls->_parent = java_lang_ClassLoader::parent(cl);\n+      cls->_parent = java_lang_ClassLoader::parent_no_keepalive(cl);\n@@ -157,1 +160,1 @@\n-    cl = java_lang_ClassLoader::parent(cl);\n+    cl = java_lang_ClassLoader::parent_no_keepalive(cl);\n@@ -164,1 +167,1 @@\n-  ClassLoaderDataGraph::loaded_cld_do(&clsc);\n+  ClassLoaderDataGraph::loaded_cld_do_no_keepalive(&clsc);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderStats.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1125,2 +1125,3 @@\n-    oop m = Universe::_mirrors[t].resolve();\n-    if (m != NULL) {\n+    if (!is_reference_type(bt)) {\n+      oop m = Universe::java_mirror(bt);\n+      assert(m != NULL, \"sanity\");\n@@ -1141,1 +1142,1 @@\n-      Universe::replace_mirror(bt, archived_m);\n+      Universe::set_archived_basic_type_mirror_index(bt, HeapShared::append_root(archived_m));\n@@ -1911,1 +1912,1 @@\n-        if (ce == nullptr || ce->cont_oop() != java_lang_VirtualThread::continuation(_java_thread())) {\n+        if (ce == nullptr || ce->cont_oop(thread) != java_lang_VirtualThread::continuation(_java_thread())) {\n@@ -4678,0 +4679,5 @@\n+oop java_lang_ClassLoader::parent_no_keepalive(oop loader) {\n+  assert(is_instance(loader), \"loader must be oop\");\n+  return loader->obj_field_access<AS_NO_KEEPALIVE>(_parent_offset);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1481,0 +1481,1 @@\n+  static oop parent_no_keepalive(oop loader);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,24 @@\n-ResourceHashtable<uintptr_t, ResolutionErrorEntry*, 107, AnyObj::C_HEAP, mtClass> _resolution_error_table;\n+class ResolutionErrorKey {\n+  ConstantPool* _cpool;\n+  int           _index;\n+\n+ public:\n+  ResolutionErrorKey(ConstantPool* cpool, int index) : _cpool(cpool), _index(index) {\n+    assert(_index > 0, \"should be already encoded or otherwise greater than zero\");\n+  }\n+\n+  ConstantPool* cpool() const { return _cpool; }\n+\n+  static unsigned hash(const ResolutionErrorKey& key) {\n+    Symbol* name = key._cpool->pool_holder()->name();\n+    return (unsigned int)(name->identity_hash() ^ key._index);\n+  }\n+\n+  static bool equals(const ResolutionErrorKey& l, const ResolutionErrorKey& r) {\n+    return (l._cpool == r._cpool) && (l._index == r._index);\n+  }\n+};\n+\n+ResourceHashtable<ResolutionErrorKey, ResolutionErrorEntry*, 107, AnyObj::C_HEAP, mtClass,\n+                  ResolutionErrorKey::hash,\n+                  ResolutionErrorKey::equals> _resolution_error_table;\n@@ -46,2 +69,3 @@\n-  ResolutionErrorEntry* entry = new ResolutionErrorEntry(pool(), cp_index, error, message, cause, cause_msg);\n-  _resolution_error_table.put(convert_key(pool, cp_index), entry);\n+  ResolutionErrorKey key(pool(), cp_index);\n+  ResolutionErrorEntry *entry = new ResolutionErrorEntry(error, message, cause, cause_msg);\n+  _resolution_error_table.put(key, entry);\n@@ -57,2 +81,3 @@\n-  ResolutionErrorEntry* entry = new ResolutionErrorEntry(pool(), cp_index, message);\n-  _resolution_error_table.put(convert_key(pool, cp_index), entry);\n+  ResolutionErrorKey key(pool(), cp_index);\n+  ResolutionErrorEntry *entry = new ResolutionErrorEntry(message);\n+  _resolution_error_table.put(key, entry);\n@@ -64,7 +89,3 @@\n-  ResolutionErrorEntry** entry = _resolution_error_table.get(convert_key(pool, cp_index));\n-  if (entry != nullptr) {\n-    return *entry;\n-  } else {\n-    return nullptr;\n-  }\n-\n+  ResolutionErrorKey key(pool(), cp_index);\n+  ResolutionErrorEntry** entry = _resolution_error_table.get(key);\n+  return entry == nullptr ? nullptr : *entry;\n@@ -73,1 +94,1 @@\n-ResolutionErrorEntry::ResolutionErrorEntry(ConstantPool* pool, int cp_index, Symbol* error, Symbol* message,\n+ResolutionErrorEntry::ResolutionErrorEntry(Symbol* error, Symbol* message,\n@@ -75,1 +96,0 @@\n-        _cp_index(cp_index),\n@@ -80,1 +100,0 @@\n-        _pool(pool),\n@@ -83,15 +102,4 @@\n-  if (_error != nullptr) {\n-    _error->increment_refcount();\n-  }\n-\n-  if (_message != nullptr) {\n-    _message->increment_refcount();\n-  }\n-\n-  if (_cause != nullptr) {\n-    _cause->increment_refcount();\n-  }\n-\n-  if (_cause_msg != nullptr) {\n-    _cause_msg->increment_refcount();\n-  }\n+  Symbol::maybe_increment_refcount(_error);\n+  Symbol::maybe_increment_refcount(_message);\n+  Symbol::maybe_increment_refcount(_cause);\n+  Symbol::maybe_increment_refcount(_cause_msg);\n@@ -102,12 +110,5 @@\n-  if (error() != NULL) {\n-    error()->decrement_refcount();\n-  }\n-  if (message() != NULL) {\n-    message()->decrement_refcount();\n-  }\n-  if (cause() != NULL) {\n-    cause()->decrement_refcount();\n-  }\n-  if (cause_msg() != NULL) {\n-    cause_msg()->decrement_refcount();\n-  }\n+  Symbol::maybe_decrement_refcount(_error);\n+  Symbol::maybe_decrement_refcount(_message);\n+  Symbol::maybe_decrement_refcount(_cause);\n+  Symbol::maybe_decrement_refcount(_cause_msg);\n+\n@@ -119,2 +120,1 @@\n-class ResolutionErrorDeleteIterate : StackObj{\n-private:\n+class ResolutionErrorDeleteIterate : StackObj {\n@@ -127,2 +127,2 @@\n-  bool do_entry(uintptr_t key, ResolutionErrorEntry* value){\n-    if (value -> pool() == p) {\n+  bool do_entry(const ResolutionErrorKey& key, ResolutionErrorEntry* value){\n+    if (key.cpool() == p) {\n@@ -145,1 +145,1 @@\n-class ResolutionIteratePurgeErrors : StackObj{\n+class ResolutionIteratePurgeErrors : StackObj {\n@@ -147,2 +147,2 @@\n-  bool do_entry(uintptr_t key, ResolutionErrorEntry* value) {\n-    ConstantPool* pool = value -> pool();\n+  bool do_entry(const ResolutionErrorKey& key, ResolutionErrorEntry* value){\n+    ConstantPool* pool = key.cpool();\n","filename":"src\/hotspot\/share\/classfile\/resolutionErrors.cpp","additions":50,"deletions":50,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,6 +35,0 @@\n-\/\/ This value is added to the cpCache index of an invokedynamic instruction when\n-\/\/ storing the resolution error resulting from that invokedynamic instruction.\n-\/\/ This prevents issues where the cpCache index is the same as the constant pool\n-\/\/ index of another entry in the table.\n-const int CPCACHE_INDEX_MANGLE_VALUE = 1000000;\n-\n@@ -44,1 +38,0 @@\n-\n@@ -46,1 +39,1 @@\n-                 Symbol* cause, Symbol* cause_msg);\n+                        Symbol* cause, Symbol* cause_msg);\n@@ -59,0 +52,6 @@\n+  \/\/ This value is added to the cpCache index of an invokedynamic instruction when\n+  \/\/ storing the resolution error resulting from that invokedynamic instruction.\n+  \/\/ This prevents issues where the cpCache index is the same as the constant pool\n+  \/\/ index of another entry in the table.\n+  static const int CPCACHE_INDEX_MANGLE_VALUE = 1000000;\n+\n@@ -66,4 +65,0 @@\n-\n-  static uintptr_t convert_key(const constantPoolHandle& pool, int cp_index) {\n-    return (uintptr_t) (pool() + cp_index);\n-  }\n@@ -75,1 +70,0 @@\n-  int               _cp_index;\n@@ -80,1 +74,0 @@\n-  ConstantPool*     _pool;\n@@ -83,1 +76,1 @@\n- public:\n+  NONCOPYABLE(ResolutionErrorEntry);\n@@ -85,2 +78,2 @@\n-    ResolutionErrorEntry(ConstantPool* pool, int cp_index, Symbol* error, Symbol* message,\n-      Symbol* cause, Symbol* cause_msg);\n+ public:\n+    ResolutionErrorEntry(Symbol* error, Symbol* message, Symbol* cause, Symbol* cause_msg);\n@@ -88,2 +81,1 @@\n-    ResolutionErrorEntry(ConstantPool* pool, int cp_index, const char* message):\n-        _cp_index(cp_index),\n+    ResolutionErrorEntry(const char* message):\n@@ -94,1 +86,0 @@\n-        _pool(pool),\n@@ -104,2 +95,0 @@\n-  ConstantPool*      pool() const               { return _pool; }\n-  int                cp_index() const           { return _cp_index; }\n@@ -111,1 +100,0 @@\n-\n","filename":"src\/hotspot\/share\/classfile\/resolutionErrors.hpp","additions":12,"deletions":24,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+  assert(ArchiveHeapLoader::are_archived_strings_available(), \"sanity\");\n@@ -80,0 +81,1 @@\n+    assert(!ArchiveHeapLoader::is_loaded(), \"Pointer relocation for uncompressed oops is unimplemented\");\n@@ -84,1 +86,1 @@\n-                           (intptr_t)ArchiveHeapLoader::runtime_delta();\n+                           (intptr_t)ArchiveHeapLoader::mapped_heap_delta();\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -478,0 +478,3 @@\n+  case vmIntrinsics::_chacha20Block:\n+    if (!UseChaCha20Intrinsics) return true;\n+    break;\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -534,0 +534,6 @@\n+                                                                                                                        \\\n+  \/* support for com.sun.crypto.provider.ChaCha20Cipher *\/                                                              \\\n+  do_class(com_sun_crypto_provider_chacha20cipher,      \"com\/sun\/crypto\/provider\/ChaCha20Cipher\")                       \\\n+  do_intrinsic(_chacha20Block, com_sun_crypto_provider_chacha20cipher, chacha20Block_name, chacha20Block_signature, F_S) \\\n+   do_name(chacha20Block_name,                                 \"implChaCha20Block\")                                         \\\n+   do_signature(chacha20Block_signature, \"([I[B)I\")                                                                    \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+          NULL \/* barrier_set_stack_chunk *\/,\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonBarrierSet.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  assert(thread == JavaThread::current(), \"pre-condition\");\n@@ -59,0 +60,1 @@\n+  assert(thread == JavaThread::current(), \"pre-condition\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSetRuntime.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"utilities\/concurrentHashTableTasks.inline.hpp\"\n@@ -243,0 +244,1 @@\n+  using CHTScanTask = CardSetHash::ScanTask;\n@@ -244,0 +246,1 @@\n+  const static uint BucketClaimSize = 16;\n@@ -249,0 +252,1 @@\n+  CHTScanTask _table_scanner;\n@@ -294,1 +298,2 @@\n-    _table(mm, initial_log_table_size, false) {\n+    _table(mm, initial_log_table_size, false),\n+    _table_scanner(&_table, BucketClaimSize) {\n@@ -335,1 +340,1 @@\n-    _table.do_safepoint_scan(cl);\n+    _table_scanner.do_safepoint_scan(cl);\n@@ -350,0 +355,4 @@\n+  void reset_table_scanner() {\n+    _table_scanner.set(&_table, BucketClaimSize);\n+  }\n+\n@@ -1032,0 +1041,4 @@\n+\n+void G1CardSet::reset_table_scanner() {\n+  _table->reset_table_scanner();\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -381,0 +381,2 @@\n+  void reset_table_scanner();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -321,5 +321,1 @@\n-void G1GCPhaseTimes::log_phase(WorkerDataArray<double>* phase, uint indent_level, outputStream* out, bool print_sum) const {\n-  out->sp(indent_level * 2);\n-  phase->print_summary_on(out, print_sum);\n-  details(phase, indent_level);\n-\n+void G1GCPhaseTimes::print_thread_work_items(WorkerDataArray<double>* phase, uint indent_level, outputStream* out) const {\n@@ -336,0 +332,31 @@\n+void G1GCPhaseTimes::debug_phase_merge_remset() const {\n+  LogTarget(Debug, gc, phases) lt;\n+  if (!lt.is_enabled()) {\n+    return;\n+  }\n+\n+  ResourceMark rm;\n+  LogStream ls(lt);\n+\n+  WorkerDataArray<double>* phase = _gc_par_phases[MergeRS];\n+  WorkerDataArray<double>* sub_phase = _gc_par_phases[MergeER];\n+\n+  uint indent_level = 2;\n+\n+  ls.sp(indent_level * 2);\n+  phase->print_summary_on(&ls, true);\n+  details(phase, indent_level);\n+\n+  log_phase(sub_phase, (indent_level + 1), &ls, true);\n+\n+  print_thread_work_items(phase, indent_level, &ls);\n+}\n+\n+void G1GCPhaseTimes::log_phase(WorkerDataArray<double>* phase, uint indent_level, outputStream* out, bool print_sum) const {\n+  out->sp(indent_level * 2);\n+  phase->print_summary_on(out, print_sum);\n+  details(phase, indent_level);\n+\n+  print_thread_work_items(phase, indent_level, out);\n+}\n+\n@@ -438,2 +465,2 @@\n-  debug_phase(_gc_par_phases[MergeER]);\n-  debug_phase(_gc_par_phases[MergeRS]);\n+  debug_phase_merge_remset();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":34,"deletions":7,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -225,0 +225,3 @@\n+  void print_thread_work_items(WorkerDataArray<double>* phase, uint indent_level, outputStream* out) const;\n+  void debug_phase_merge_remset() const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -686,2 +686,1 @@\n-   void scan_heap_roots(HeapRegion* r) {\n-    EventGCPhaseParallel event;\n+  void scan_heap_roots(HeapRegion* r) {\n@@ -728,2 +727,0 @@\n-\n-    event.commit(GCId::current(), _worker_id, G1GCPhaseTimes::phase_name(G1GCPhaseTimes::ScanHR));\n@@ -783,0 +780,1 @@\n+  EventGCPhaseParallel event;\n@@ -786,0 +784,2 @@\n+  event.commit(GCId::current(), worker_id, G1GCPhaseTimes::phase_name(scan_phase));\n+\n@@ -819,2 +819,0 @@\n-    EventGCPhaseParallel event;\n-\n@@ -827,2 +825,0 @@\n-\n-    event.commit(GCId::current(), _worker_id, G1GCPhaseTimes::phase_name(_scan_phase));\n@@ -856,0 +852,1 @@\n+      EventGCPhaseParallel event;\n@@ -858,0 +855,2 @@\n+\n+      event.commit(GCId::current(), _worker_id, G1GCPhaseTimes::phase_name(_scan_phase));\n@@ -862,1 +861,0 @@\n-\n@@ -919,0 +917,2 @@\n+  r->prepare_remset_for_scan();\n+\n@@ -1335,6 +1335,10 @@\n-    \/\/ We schedule flushing the remembered sets of humongous fast reclaim candidates\n-    \/\/ onto the card table first to allow the remaining parallelized tasks hide it.\n-    if (_initial_evacuation &&\n-        g1h->has_humongous_reclaim_candidates() &&\n-        !_fast_reclaim_handled &&\n-        !Atomic::cmpxchg(&_fast_reclaim_handled, false, true)) {\n+    {\n+      \/\/ Merge remset of ...\n+      G1GCParPhaseTimesTracker x(p, merge_remset_phase, worker_id, !_initial_evacuation \/* allow_multiple_record *\/);\n+\n+      {\n+        \/\/ 1. eager-reclaim candidates\n+        if (_initial_evacuation &&\n+            g1h->has_humongous_reclaim_candidates() &&\n+            !_fast_reclaim_handled &&\n+            !Atomic::cmpxchg(&_fast_reclaim_handled, false, true)) {\n@@ -1342,1 +1346,1 @@\n-      G1GCParPhaseTimesTracker x(p, G1GCPhaseTimes::MergeER, worker_id);\n+          G1GCParPhaseTimesTracker subphase_x(p, G1GCPhaseTimes::MergeER, worker_id);\n@@ -1344,2 +1348,2 @@\n-      G1FlushHumongousCandidateRemSets cl(_scan_state);\n-      g1h->heap_region_iterate(&cl);\n+          G1FlushHumongousCandidateRemSets cl(_scan_state);\n+          g1h->heap_region_iterate(&cl);\n@@ -1347,2 +1351,4 @@\n-      for (uint i = 0; i < G1GCPhaseTimes::MergeRSContainersSentinel; i++) {\n-        p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged(i), i);\n+          for (uint i = 0; i < G1GCPhaseTimes::MergeRSContainersSentinel; i++) {\n+            p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged(i), i);\n+          }\n+        }\n@@ -1350,1 +1356,0 @@\n-    }\n@@ -1352,4 +1357,0 @@\n-    \/\/ Merge remembered sets of current candidates.\n-    {\n-      G1GCParPhaseTimesTracker x(p, merge_remset_phase, worker_id, !_initial_evacuation \/* allow_multiple_record *\/);\n-      G1MergeCardSetStats stats;\n@@ -1357,3 +1358,6 @@\n-        G1MergeCardSetClosure merge(_scan_state);\n-        G1ClearBitmapClosure clear(g1h);\n-        G1CombinedClosure combined(&merge, &clear);\n+        \/\/ 2. collection set\n+        G1MergeCardSetStats stats;\n+        {\n+          G1MergeCardSetClosure merge(_scan_state);\n+          G1ClearBitmapClosure clear(g1h);\n+          G1CombinedClosure combined(&merge, &clear);\n@@ -1361,3 +1365,3 @@\n-        g1h->collection_set_iterate_increment_from(&combined, &_hr_claimer, worker_id);\n-        stats = merge.stats();\n-      }\n+          g1h->collection_set_iterate_increment_from(&combined, nullptr, worker_id);\n+          stats = merge.stats();\n+        }\n@@ -1365,2 +1369,3 @@\n-      for (uint i = 0; i < G1GCPhaseTimes::MergeRSContainersSentinel; i++) {\n-        p->record_or_add_thread_work_item(merge_remset_phase, worker_id, stats.merged(i), i);\n+        for (uint i = 0; i < G1GCPhaseTimes::MergeRSContainersSentinel; i++) {\n+          p->record_or_add_thread_work_item(merge_remset_phase, worker_id, stats.merged(i), i);\n+        }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":38,"deletions":33,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -560,1 +560,1 @@\n-    \/\/ Free the region and and its remembered set.\n+    \/\/ Free the region and its remembered set.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -223,0 +223,4 @@\n+void HeapRegion::prepare_remset_for_scan() {\n+  return _rem_set->reset_table_scanner();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -460,0 +460,2 @@\n+  void prepare_remset_for_scan();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,0 +86,4 @@\n+void HeapRegionRemSet::reset_table_scanner() {\n+  _card_set.reset_table_scanner();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -125,0 +125,2 @@\n+  void reset_table_scanner();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -167,0 +167,2 @@\n+  PCIterateMarkAndPushClosure cl(this, PSParallelCompact::ref_processor());\n+\n@@ -168,0 +170,1 @@\n+    cl.do_klass(obj->klass());\n@@ -170,1 +173,0 @@\n-    PCIterateMarkAndPushClosure cl(this, PSParallelCompact::ref_processor());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.inline.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/barrierSetStackChunk.hpp\"\n@@ -65,0 +66,8 @@\n+static BarrierSetStackChunk* select_barrier_set_stack_chunk(BarrierSetStackChunk* barrier_set_stack_chunk) {\n+  if (barrier_set_stack_chunk != NULL) {\n+    return barrier_set_stack_chunk;\n+  } else {\n+    return new BarrierSetStackChunk();\n+  }\n+}\n+\n@@ -69,0 +78,1 @@\n+                       BarrierSetStackChunk* barrier_set_stack_chunk,\n@@ -74,1 +84,2 @@\n-    _barrier_set_nmethod(select_barrier_set_nmethod(barrier_set_nmethod)) {\n+    _barrier_set_nmethod(select_barrier_set_nmethod(barrier_set_nmethod)),\n+    _barrier_set_stack_chunk(select_barrier_set_stack_chunk(barrier_set_stack_chunk)) {\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+class BarrierSetStackChunk;\n@@ -77,0 +78,1 @@\n+  BarrierSetStackChunk* _barrier_set_stack_chunk;\n@@ -101,0 +103,1 @@\n+             BarrierSetStackChunk* barrier_set_stack_chunk,\n@@ -168,0 +171,5 @@\n+  BarrierSetStackChunk* barrier_set_stack_chunk() {\n+    assert(_barrier_set_stack_chunk != NULL, \"should be set\");\n+    return _barrier_set_stack_chunk;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/barrierSetStackChunk.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"oops\/access.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"oops\/stackChunkOop.inline.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+class UncompressOopsOopClosure : public OopClosure {\n+public:\n+  void do_oop(oop* p) override {\n+    assert(UseCompressedOops, \"Only needed with compressed oops\");\n+    oop obj = CompressedOops::decode(*(narrowOop*)p);\n+    assert(obj == nullptr || dbg_is_good_oop(obj), \"p: \" INTPTR_FORMAT \" obj: \" INTPTR_FORMAT, p2i(p), p2i((oopDesc*)obj));\n+    *p = obj;\n+  }\n+\n+  void do_oop(narrowOop* p) override {}\n+};\n+\n+class CompressOopsOopClosure : public OopClosure {\n+  stackChunkOop _chunk;\n+  BitMapView _bm;\n+\n+  void convert_oop_to_narrowOop(oop* p) {\n+    oop obj = *p;\n+    *p = nullptr;\n+    *(narrowOop*)p = CompressedOops::encode(obj);\n+  }\n+\n+  template <typename T>\n+  void do_oop_work(T* p) {\n+    BitMap::idx_t index = _chunk->bit_index_for(p);\n+    assert(!_bm.at(index), \"must not be set already\");\n+    _bm.set_bit(index);\n+  }\n+\n+public:\n+  CompressOopsOopClosure(stackChunkOop chunk)\n+    : _chunk(chunk), _bm(chunk->bitmap()) {}\n+\n+  virtual void do_oop(oop* p) override {\n+    if (UseCompressedOops) {\n+      \/\/ Convert all oops to narrow before marking the oop in the bitmap.\n+      convert_oop_to_narrowOop(p);\n+      do_oop_work((narrowOop*)p);\n+    } else {\n+      do_oop_work(p);\n+    }\n+  }\n+\n+  virtual void do_oop(narrowOop* p) override {\n+    do_oop_work(p);\n+  }\n+};\n+\n+void BarrierSetStackChunk::encode_gc_mode(stackChunkOop chunk, OopIterator* iterator) {\n+  CompressOopsOopClosure cl(chunk);\n+  iterator->oops_do(&cl);\n+}\n+\n+void BarrierSetStackChunk::decode_gc_mode(stackChunkOop chunk, OopIterator* iterator) {\n+  if (chunk->has_bitmap() && UseCompressedOops) {\n+    UncompressOopsOopClosure cl;\n+    iterator->oops_do(&cl);\n+  }\n+}\n+\n+oop BarrierSetStackChunk::load_oop(stackChunkOop chunk, oop* addr) {\n+  return RawAccess<>::oop_load(addr);\n+}\n+\n+oop BarrierSetStackChunk::load_oop(stackChunkOop chunk, narrowOop* addr) {\n+  return RawAccess<>::oop_load(addr);\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetStackChunk.cpp","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_BARRIERSETSTACKCHUNK_HPP\n+#define SHARE_GC_SHARED_BARRIERSETSTACKCHUNK_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class OopClosure;\n+\n+class BarrierSetStackChunk: public CHeapObj<mtGC> {\n+public:\n+  virtual void encode_gc_mode(stackChunkOop chunk, OopIterator* oop_iterator);\n+  virtual void decode_gc_mode(stackChunkOop chunk, OopIterator* oop_iterator);\n+\n+  virtual oop load_oop(stackChunkOop chunk, oop* addr);\n+  virtual oop load_oop(stackChunkOop chunk, narrowOop* addr);\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_BARRIERSETSTACKCHUNK_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetStackChunk.hpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -256,1 +256,1 @@\n-HeapWord* MemAllocator::allocate_outside_tlab(Allocation& allocation) const {\n+HeapWord* MemAllocator::mem_allocate_outside_tlab(Allocation& allocation) const {\n@@ -270,1 +270,1 @@\n-HeapWord* MemAllocator::allocate_inside_tlab(Allocation& allocation) const {\n+HeapWord* MemAllocator::mem_allocate_inside_tlab(Allocation& allocation) const {\n@@ -274,1 +274,1 @@\n-  HeapWord* mem = allocate_inside_tlab_fast();\n+  HeapWord* mem = mem_allocate_inside_tlab_fast();\n@@ -280,1 +280,1 @@\n-  return allocate_inside_tlab_slow(allocation);\n+  return mem_allocate_inside_tlab_slow(allocation);\n@@ -283,1 +283,1 @@\n-HeapWord* MemAllocator::allocate_inside_tlab_fast() const {\n+HeapWord* MemAllocator::mem_allocate_inside_tlab_fast() const {\n@@ -287,1 +287,1 @@\n-HeapWord* MemAllocator::allocate_inside_tlab_slow(Allocation& allocation) const {\n+HeapWord* MemAllocator::mem_allocate_inside_tlab_slow(Allocation& allocation) const {\n@@ -354,1 +354,5 @@\n-HeapWord* MemAllocator::mem_allocate(Allocation& allocation) const {\n+\n+HeapWord* MemAllocator::mem_allocate_slow(Allocation& allocation) const {\n+  \/\/ Allocation of an oop can always invoke a safepoint.\n+  debug_only(JavaThread::cast(_thread)->check_for_valid_safepoint_state());\n+\n@@ -356,3 +360,4 @@\n-    HeapWord* result = allocate_inside_tlab(allocation);\n-    if (result != NULL) {\n-      return result;\n+    \/\/ Try refilling the TLAB and allocating the object in it.\n+    HeapWord* mem = mem_allocate_inside_tlab_slow(allocation);\n+    if (mem != NULL) {\n+      return mem;\n@@ -362,1 +367,1 @@\n-  return allocate_outside_tlab(allocation);\n+  return mem_allocate_outside_tlab(allocation);\n@@ -365,5 +370,4 @@\n-oop MemAllocator::allocate() const {\n-  oop obj = NULL;\n-  {\n-    Allocation allocation(*this, &obj);\n-    HeapWord* mem = mem_allocate(allocation);\n+HeapWord* MemAllocator::mem_allocate(Allocation& allocation) const {\n+  if (UseTLAB) {\n+    \/\/ Try allocating from an existing TLAB.\n+    HeapWord* mem = mem_allocate_inside_tlab_fast();\n@@ -371,5 +375,1 @@\n-      obj = initialize(mem);\n-    } else {\n-      \/\/ The unhandled oop detector will poison local variable obj,\n-      \/\/ so reset it to NULL if mem is NULL.\n-      obj = NULL;\n+      return mem;\n@@ -378,1 +378,2 @@\n-  return obj;\n+\n+  return mem_allocate_slow(allocation);\n@@ -381,1 +382,1 @@\n-oop MemAllocator::try_allocate_in_existing_tlab() {\n+oop MemAllocator::allocate() const {\n@@ -383,2 +384,3 @@\n-  if (UseTLAB) {\n-    HeapWord* mem = allocate_inside_tlab_fast();\n+  {\n+    Allocation allocation(*this, &obj);\n+    HeapWord* mem = mem_allocate(allocation);\n@@ -450,17 +452,0 @@\n-\n-\/\/ Does the minimal amount of initialization needed for a TLAB allocation.\n-\/\/ We don't need to do a full initialization, as such an allocation need not be immediately walkable.\n-oop StackChunkAllocator::initialize(HeapWord* mem) const {\n-  assert(_stack_size > 0, \"\");\n-  assert(_stack_size <= max_jint, \"\");\n-  assert(_word_size > _stack_size, \"\");\n-\n-  \/\/ zero out fields (but not the stack)\n-  const size_t hs = oopDesc::header_size();\n-  Copy::fill_to_aligned_words(mem + hs, vmClasses::StackChunk_klass()->size_helper() - hs);\n-\n-  jdk_internal_vm_StackChunk::set_size(mem, (int)_stack_size);\n-  jdk_internal_vm_StackChunk::set_sp(mem, (int)_stack_size);\n-\n-  return finish(mem);\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":27,"deletions":42,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -45,0 +45,3 @@\n+  \/\/ Allocate from the current thread's TLAB, without taking a new TLAB (no safepoint).\n+ HeapWord* mem_allocate_inside_tlab_fast() const;\n+\n@@ -46,5 +49,9 @@\n-  \/\/ Allocate from the current thread's TLAB, with broken-out slow path.\n-  HeapWord* allocate_inside_tlab(Allocation& allocation) const;\n-  HeapWord* allocate_inside_tlab_fast() const;\n-  HeapWord* allocate_inside_tlab_slow(Allocation& allocation) const;\n-  HeapWord* allocate_outside_tlab(Allocation& allocation) const;\n+  \/\/ Allocate in a TLAB. Could allocate a new TLAB, and therefore potentially safepoint.\n+  HeapWord* mem_allocate_inside_tlab(Allocation& allocation) const;\n+  HeapWord* mem_allocate_inside_tlab_slow(Allocation& allocation) const;\n+\n+  \/\/ Allocate outside a TLAB. Could safepoint.\n+  HeapWord* mem_allocate_outside_tlab(Allocation& allocation) const;\n+\n+  \/\/ Fast-path TLAB allocation failed. Takes a slow-path and potentially safepoint.\n+  HeapWord* mem_allocate_slow(Allocation& allocation) const;\n@@ -81,1 +88,0 @@\n-  oop try_allocate_in_existing_tlab();\n@@ -88,0 +94,1 @@\n+\n@@ -104,0 +111,1 @@\n+\n@@ -111,5 +119,0 @@\n-  virtual oop initialize(HeapWord* mem) const;\n-};\n-\n-class StackChunkAllocator : public MemAllocator {\n-  const size_t _stack_size;\n@@ -117,4 +120,0 @@\n-public:\n-  StackChunkAllocator(Klass* klass, size_t word_size, size_t stack_size, Thread* thread = Thread::current())\n-    : MemAllocator(klass, word_size, thread),\n-      _stack_size(stack_size) {}\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+                 NULL \/* barrier_set_stack_chunk *\/,\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -192,3 +192,3 @@\n-void FilteringDCTOC::walk_mem_region(MemRegion mr,\n-                                     HeapWord* bottom,\n-                                     HeapWord* top) {\n+void ContiguousSpaceDCTOC::walk_mem_region(MemRegion mr,\n+                                           HeapWord* bottom,\n+                                           HeapWord* top) {\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -544,6 +544,12 @@\n-\n-\/\/ A dirty card to oop closure that does filtering.\n-\/\/ It knows how to filter out objects that are outside of the _boundary.\n-class FilteringDCTOC : public DirtyCardToOopClosure {\n-protected:\n-  \/\/ Override.\n+\/\/ A dirty card to oop closure for contiguous spaces (ContiguousSpace and\n+\/\/ sub-classes). It knows how to filter out objects that are outside of the\n+\/\/ _boundary.\n+\/\/\n+\/\/ Assumptions:\n+\/\/ 1. That the actual top of any area in a memory region\n+\/\/    contained by the space is bounded by the end of the contiguous\n+\/\/    region of the space.\n+\/\/ 2. That the space is really made up of objects and not just\n+\/\/    blocks.\n+class ContiguousSpaceDCTOC : public DirtyCardToOopClosure {\n+  \/\/ Overrides.\n@@ -553,0 +559,2 @@\n+  HeapWord* get_actual_top(HeapWord* top, HeapWord* top_obj);\n+\n@@ -560,35 +568,6 @@\n-  virtual void walk_mem_region_with_cl(MemRegion mr,\n-                                       HeapWord* bottom, HeapWord* top,\n-                                       OopIterateClosure* cl) = 0;\n-  virtual void walk_mem_region_with_cl(MemRegion mr,\n-                                       HeapWord* bottom, HeapWord* top,\n-                                       FilteringClosure* cl) = 0;\n-\n-public:\n-  FilteringDCTOC(Space* sp, OopIterateClosure* cl,\n-                  CardTable::PrecisionStyle precision,\n-                  HeapWord* boundary) :\n-    DirtyCardToOopClosure(sp, cl, precision, boundary) {}\n-};\n-\n-\/\/ A dirty card to oop closure for contiguous spaces\n-\/\/ (ContiguousSpace and sub-classes).\n-\/\/ It is a FilteringClosure, as defined above, and it knows:\n-\/\/\n-\/\/ 1. That the actual top of any area in a memory region\n-\/\/    contained by the space is bounded by the end of the contiguous\n-\/\/    region of the space.\n-\/\/ 2. That the space is really made up of objects and not just\n-\/\/    blocks.\n-\n-class ContiguousSpaceDCTOC : public FilteringDCTOC {\n-protected:\n-  \/\/ Overrides.\n-  HeapWord* get_actual_top(HeapWord* top, HeapWord* top_obj);\n-\n-  virtual void walk_mem_region_with_cl(MemRegion mr,\n-                                       HeapWord* bottom, HeapWord* top,\n-                                       OopIterateClosure* cl);\n-  virtual void walk_mem_region_with_cl(MemRegion mr,\n-                                       HeapWord* bottom, HeapWord* top,\n-                                       FilteringClosure* cl);\n+  void walk_mem_region_with_cl(MemRegion mr,\n+                               HeapWord* bottom, HeapWord* top,\n+                               OopIterateClosure* cl);\n+  void walk_mem_region_with_cl(MemRegion mr,\n+                               HeapWord* bottom, HeapWord* top,\n+                               FilteringClosure* cl);\n@@ -600,1 +579,1 @@\n-    FilteringDCTOC(sp, cl, precision, boundary)\n+    DirtyCardToOopClosure(sp, cl, precision, boundary)\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":21,"deletions":42,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shenandoah\/shenandoahBarrierSetStackChunk.hpp\"\n@@ -48,0 +49,1 @@\n+             new ShenandoahBarrierSetStackChunk(),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/shenandoahBarrierSet.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahBarrierSetStackChunk.hpp\"\n+\n+void ShenandoahBarrierSetStackChunk::encode_gc_mode(stackChunkOop chunk, OopIterator* oop_iterator) {\n+  \/\/ Nothing to do\n+}\n+\n+void ShenandoahBarrierSetStackChunk::decode_gc_mode(stackChunkOop chunk, OopIterator* oop_iterator) {\n+  \/\/ Nothing to do\n+}\n+\n+oop ShenandoahBarrierSetStackChunk::load_oop(stackChunkOop chunk, oop* addr) {\n+  oop result = BarrierSetStackChunk::load_oop(chunk, addr);\n+  return ShenandoahBarrierSet::barrier_set()->load_reference_barrier(result);\n+}\n+\n+oop ShenandoahBarrierSetStackChunk::load_oop(stackChunkOop chunk, narrowOop* addr) {\n+  oop result = BarrierSetStackChunk::load_oop(chunk, addr);\n+  return ShenandoahBarrierSet::barrier_set()->load_reference_barrier(result);\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSetStackChunk.cpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHBARRIERSETSTACKCHUNK_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHBARRIERSETSTACKCHUNK_HPP\n+\n+#include \"gc\/shared\/barrierSetStackChunk.hpp\"\n+\n+class ShenandoahBarrierSetStackChunk : public BarrierSetStackChunk {\n+public:\n+  virtual void encode_gc_mode(stackChunkOop chunk, OopIterator* oop_iterator) override;\n+  virtual void decode_gc_mode(stackChunkOop chunk, OopIterator* oop_iterator) override;\n+\n+  virtual oop load_oop(stackChunkOop chunk, oop* addr) override;\n+  virtual oop load_oop(stackChunkOop chunk, narrowOop* addr) override;\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHBARRIERSETSTACKCHUNK_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSetStackChunk.hpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -69,0 +69,4 @@\n+ShenandoahFullGC::~ShenandoahFullGC() {\n+  delete _preserved_marks;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+  ~ShenandoahFullGC();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+  assert(thread == JavaThread::current(), \"pre-condition\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRuntime.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/z\/zBarrierSetStackChunk.hpp\"\n@@ -49,0 +50,1 @@\n+               new ZBarrierSetStackChunk(),\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/z\/zBarrier.inline.hpp\"\n+#include \"gc\/z\/zBarrierSetStackChunk.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+void ZBarrierSetStackChunk::encode_gc_mode(stackChunkOop chunk, OopIterator* iterator) {\n+  \/\/ Do nothing\n+}\n+\n+void ZBarrierSetStackChunk::decode_gc_mode(stackChunkOop chunk, OopIterator* iterator) {\n+  \/\/ Do nothing\n+}\n+\n+oop ZBarrierSetStackChunk::load_oop(stackChunkOop chunk, oop* addr) {\n+  oop obj = Atomic::load(addr);\n+  return ZBarrier::load_barrier_on_oop_field_preloaded((volatile oop*)NULL, obj);\n+}\n+\n+oop ZBarrierSetStackChunk::load_oop(stackChunkOop chunk, narrowOop* addr) {\n+  ShouldNotReachHere();\n+  return NULL;\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetStackChunk.cpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_Z_ZBARRIERSETSTACKCHUNK_HPP\n+#define SHARE_GC_Z_ZBARRIERSETSTACKCHUNK_HPP\n+\n+#include \"gc\/shared\/barrierSetStackChunk.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class OopClosure;\n+\n+class ZBarrierSetStackChunk : public BarrierSetStackChunk {\n+public:\n+  virtual void encode_gc_mode(stackChunkOop chunk, OopIterator* iterator) override;\n+  virtual void decode_gc_mode(stackChunkOop chunk, OopIterator* iterator) override;\n+\n+  virtual oop load_oop(stackChunkOop chunk, oop* addr) override;\n+  virtual oop load_oop(stackChunkOop chunk, narrowOop* addr) override;\n+};\n+\n+#endif \/\/ SHARE_GC_Z_ZBARRIERSETSTACKCHUNK_HPP\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetStackChunk.hpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -42,1 +42,1 @@\n-#define CURRENT_CDS_ARCHIVE_VERSION 16\n+#define CURRENT_CDS_ARCHIVE_VERSION 17\n@@ -53,3 +53,11 @@\n-  size_t  _mapping_offset;    \/\/ This region should be mapped at this offset from the base address\n-                              \/\/ - for non-heap regions, the base address is SharedBaseAddress\n-                              \/\/ - for heap regions, the base address is the compressed oop encoding base\n+  size_t  _mapping_offset;    \/\/ This encodes the requested address for this region to be mapped at runtime.\n+                              \/\/ However, the JVM may choose to map at an alternative location (e.g., for ASLR,\n+                              \/\/ or to adapt to the available ranges in the Java heap range).\n+                              \/\/ - For an RO\/RW region, the requested address is:\n+                              \/\/     FileMapHeader::requested_base_address() + _mapping_offset\n+                              \/\/ - For a heap region, the requested address is:\n+                              \/\/     +UseCompressedOops: \/*runtime*\/ CompressedOops::base() + _mapping_offset\n+                              \/\/     -UseCompressedOops: FileMapHeader::heap_begin() + _mapping_offset\n+                              \/\/     See FileMapInfo::heap_region_requested_address().\n+                              \/\/ - For bitmap regions, the _mapping_offset is always zero. The runtime address\n+                              \/\/   is picked by the OS.\n@@ -76,2 +84,0 @@\n-  unsigned int _common_app_classpath_prefix_size; \/\/ size of the common prefix of app class paths\n-                                                  \/\/    0 if no common prefix exists\n","filename":"src\/hotspot\/share\/include\/cds.h","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1138,0 +1138,1 @@\n+  assert(current == JavaThread::current(), \"pre-condition\");\n@@ -1457,0 +1458,1 @@\n+  assert(current == JavaThread::current(), \"pre-condition\");\n@@ -1510,0 +1512,1 @@\n+  assert(current == JavaThread::current(), \"pre-condition\");\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -319,4 +319,4 @@\n-      jlong buffer = (jlong) NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, jbyte, buffer_size);\n-      int res = encode(THREAD, runtimeKlass, buffer, buffer_size);\n-      if ((_from_env != nullptr && _from_env->has_pending_exception()) || HAS_PENDING_EXCEPTION) {\n-        JVMCIRuntime::fatal_exception(_from_env, \"HotSpotJVMCIRuntime.encodeThrowable should not throw an exception\");\n+      jlong buffer = (jlong) NEW_RESOURCE_ARRAY_IN_THREAD_RETURN_NULL(THREAD, jbyte, buffer_size);\n+      if (buffer == 0L) {\n+        decode(THREAD, runtimeKlass, 0L);\n+        return;\n@@ -324,1 +324,17 @@\n-      if (res < 0) {\n+      int res = encode(THREAD, runtimeKlass, buffer, buffer_size);\n+      if (_from_env != nullptr && !_from_env->is_hotspot() && _from_env->has_pending_exception()) {\n+        \/\/ Cannot get name of exception thrown by `encode` as that involves\n+        \/\/ calling into libjvmci which in turn can raise another exception.\n+        _from_env->clear_pending_exception();\n+        decode(THREAD, runtimeKlass, -2L);\n+        return;\n+      } else if (HAS_PENDING_EXCEPTION) {\n+        Symbol *ex_name = PENDING_EXCEPTION->klass()->name();\n+        CLEAR_PENDING_EXCEPTION;\n+        if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {\n+          decode(THREAD, runtimeKlass, -1L);\n+        } else {\n+          decode(THREAD, runtimeKlass, -2L);\n+        }\n+        return;\n+      } else if (res < 0) {\n@@ -332,1 +348,1 @@\n-          JVMCIRuntime::fatal_exception(_to_env, \"HotSpotJVMCIRuntime.decodeAndThrowThrowable should throw an exception\");\n+          _to_env->throw_InternalError(\"HotSpotJVMCIRuntime.decodeAndThrowThrowable should have thrown an exception\");\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -413,0 +413,1 @@\n+  assert(current == JavaThread::current(), \"pre-condition\");\n@@ -420,0 +421,1 @@\n+  assert(current == JavaThread::current(), \"pre-condition\");\n@@ -436,0 +438,1 @@\n+  assert(current == JavaThread::current(), \"pre-condition\");\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -321,0 +321,1 @@\n+  static_field(StubRoutines,                _chacha20Block,                                   address)                               \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -141,1 +142,1 @@\n-enum class MEMFLAGS {\n+enum class MEMFLAGS : uint8_t  {\n@@ -146,0 +147,2 @@\n+\/\/ Extra insurance that MEMFLAGS truly has the same size as uint8_t.\n+STATIC_ASSERT(sizeof(MEMFLAGS) == sizeof(uint8_t));\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -126,0 +126,6 @@\n+\/\/ Interface for applying an OopClosure to a set of oops.\n+class OopIterator {\n+public:\n+  virtual void oops_do(OopClosure* cl) = 0;\n+};\n+\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -91,1 +91,4 @@\n-OopHandle Universe::_mirrors[T_VOID+1];\n+OopHandle Universe::_basic_type_mirrors[T_VOID+1];\n+#if INCLUDE_CDS_JAVA_HEAP\n+int Universe::_archived_basic_type_mirror_indices[T_VOID+1];\n+#endif\n@@ -183,9 +186,9 @@\n-oop Universe::int_mirror()                        { return check_mirror(_mirrors[T_INT].resolve()); }\n-oop Universe::float_mirror()                      { return check_mirror(_mirrors[T_FLOAT].resolve()); }\n-oop Universe::double_mirror()                     { return check_mirror(_mirrors[T_DOUBLE].resolve()); }\n-oop Universe::byte_mirror()                       { return check_mirror(_mirrors[T_BYTE].resolve()); }\n-oop Universe::bool_mirror()                       { return check_mirror(_mirrors[T_BOOLEAN].resolve()); }\n-oop Universe::char_mirror()                       { return check_mirror(_mirrors[T_CHAR].resolve()); }\n-oop Universe::long_mirror()                       { return check_mirror(_mirrors[T_LONG].resolve()); }\n-oop Universe::short_mirror()                      { return check_mirror(_mirrors[T_SHORT].resolve()); }\n-oop Universe::void_mirror()                       { return check_mirror(_mirrors[T_VOID].resolve()); }\n+oop Universe::int_mirror()                        { return check_mirror(_basic_type_mirrors[T_INT].resolve()); }\n+oop Universe::float_mirror()                      { return check_mirror(_basic_type_mirrors[T_FLOAT].resolve()); }\n+oop Universe::double_mirror()                     { return check_mirror(_basic_type_mirrors[T_DOUBLE].resolve()); }\n+oop Universe::byte_mirror()                       { return check_mirror(_basic_type_mirrors[T_BYTE].resolve()); }\n+oop Universe::bool_mirror()                       { return check_mirror(_basic_type_mirrors[T_BOOLEAN].resolve()); }\n+oop Universe::char_mirror()                       { return check_mirror(_basic_type_mirrors[T_CHAR].resolve()); }\n+oop Universe::long_mirror()                       { return check_mirror(_basic_type_mirrors[T_LONG].resolve()); }\n+oop Universe::short_mirror()                      { return check_mirror(_basic_type_mirrors[T_SHORT].resolve()); }\n+oop Universe::void_mirror()                       { return check_mirror(_basic_type_mirrors[T_VOID].resolve()); }\n@@ -195,6 +198,2 @@\n-  return check_mirror(_mirrors[t].resolve());\n-}\n-\n-\/\/ Used by CDS dumping\n-void Universe::replace_mirror(BasicType t, oop new_mirror) {\n-  Universe::_mirrors[t].replace(new_mirror);\n+  assert(!is_reference_type(t), \"sanity\");\n+  return check_mirror(_basic_type_mirrors[t].resolve());\n@@ -239,3 +238,0 @@\n-\/\/ Serialize metadata and pointers to primitive type mirrors in and out of CDS archive\n-void Universe::serialize(SerializeClosure* f) {\n-\n@@ -243,2 +239,8 @@\n-  {\n-    oop mirror_oop;\n+void Universe::set_archived_basic_type_mirror_index(BasicType t, int index) {\n+  assert(DumpSharedSpaces, \"dump-time only\");\n+  assert(!is_reference_type(t), \"sanity\");\n+  _archived_basic_type_mirror_indices[t] = index;\n+}\n+\n+void Universe::update_archived_basic_type_mirrors() {\n+  if (ArchiveHeapLoader::are_archived_mirrors_available()) {\n@@ -246,14 +248,5 @@\n-      if (f->reading()) {\n-        f->do_oop(&mirror_oop); \/\/ read from archive\n-        assert(oopDesc::is_oop_or_null(mirror_oop), \"is oop\");\n-        \/\/ Only create an OopHandle for non-null mirrors\n-        if (mirror_oop != NULL) {\n-          _mirrors[i] = OopHandle(vm_global(), mirror_oop);\n-        }\n-      } else {\n-        if (HeapShared::can_write()) {\n-          mirror_oop = _mirrors[i].resolve();\n-        } else {\n-          mirror_oop = NULL;\n-        }\n-        f->do_oop(&mirror_oop); \/\/ write to archive\n+      int index = _archived_basic_type_mirror_indices[i];\n+      if (!is_reference_type((BasicType)i) && index >= 0) {\n+        oop mirror_oop = HeapShared::get_root(index);\n+        assert(mirror_oop != NULL, \"must be\");\n+        _basic_type_mirrors[i] = OopHandle(vm_global(), mirror_oop);\n@@ -263,0 +256,12 @@\n+}\n+#endif\n+\n+void Universe::serialize(SerializeClosure* f) {\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n+    f->do_u4((u4*)&_archived_basic_type_mirror_indices[i]);\n+    \/\/ if f->reading(): We can't call HeapShared::get_root() yet, as the heap\n+    \/\/ contents may need to be relocated. _basic_type_mirrors[i] will be\n+    \/\/ updated later in Universe::update_archived_basic_type_mirrors().\n+  }\n@@ -453,1 +458,1 @@\n-        _mirrors[T_INT].resolve() != NULL) {\n+        _basic_type_mirrors[T_INT].resolve() != NULL) {\n@@ -456,1 +461,1 @@\n-      \/\/ check that all mirrors are mapped also\n+      \/\/ check that all basic type mirrors are mapped also\n@@ -459,1 +464,1 @@\n-          oop m = _mirrors[i].resolve();\n+          oop m = _basic_type_mirrors[i].resolve();\n@@ -464,1 +469,1 @@\n-      \/\/ _mirror[T_INT} could be NULL if archived heap is not mapped.\n+      \/\/ _basic_type_mirrors[T_INT], etc, are NULL if archived heap is not mapped.\n@@ -471,1 +476,1 @@\n-          _mirrors[i] = OopHandle(vm_global(), m);\n+          _basic_type_mirrors[i] = OopHandle(vm_global(), m);\n@@ -473,0 +478,1 @@\n+        CDS_JAVA_HEAP_ONLY(_archived_basic_type_mirror_indices[i] = -1);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":46,"deletions":40,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -199,0 +199,10 @@\n+  \/\/ Table of primitive type mirrors, excluding T_OBJECT and T_ARRAY\n+  \/\/ but including T_VOID, hence the index including T_VOID\n+  static OopHandle _basic_type_mirrors[T_VOID+1];\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  \/\/ Each slot i stores an index that can be used to restore _basic_type_mirrors[i]\n+  \/\/ from the archive heap using HeapShared::get_root(int)\n+  static int _archived_basic_type_mirror_indices[T_VOID+1];\n+#endif\n+\n@@ -234,4 +244,0 @@\n-  \/\/ Table of primitive type mirrors, excluding T_OBJECT and T_ARRAY\n-  \/\/ but including T_VOID, hence the index including T_VOID\n-  static OopHandle _mirrors[T_VOID+1];\n-\n@@ -239,1 +245,5 @@\n-  static void replace_mirror(BasicType t, oop obj);\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  static void set_archived_basic_type_mirror_index(BasicType t, int index);\n+  static void update_archived_basic_type_mirrors();\n+#endif\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -53,39 +53,45 @@\n-                   +-------------------+\n-                   |                   |\n-                   |  oop bitmap       |\n-                   |                   |\n-                   | ----------------- |\n-                   |                   |\n-                   |  [empty]          |\n-                   |                   |\n-                  -|===================|\n-                \/  |                   |\n-               |   | caller stack args |  argsize\n-               |   |                   |  words\n-               |   | ----------------- |\n-               |   |                   |\n-         ^     |   | frame             |\n-         |     |   |                   |\n-         |   size  | ----------------- |\n-         |   words |                   |\n-         |     |   | frame             |\n-         |     |   |                   |\n- Address |     |   | ----------------- |\n-         |     |   |                   |\n-         |     |   | frame             |\n-         |     |   |                   |\n-         |     |   | callee stack args |\n-         |     |   | ----------------- |<--\\\n-         |     |   | pc                |   |\n-         |     |   | rbp               |   |\n-         |     |   |                   |   |\n-         |     |   | [empty]           |   |\n-         |     \\   |                   |   |\n-                 - |===================|   |\n-                   | int maxSize       |   |\n-                   | long pc           |   |\n-            header | byte flags        |   |\n-                   | int argsize       |   |\n-                   | int sp            +---\/\n-                   | int size          |\n-                   +-------------------+\n+                   +--------------------------------+\n+                   |                                |\n+                   |  oop bitmap                    |\n+                   |                                |\n+                   | ------------------------------ |\n+                   |                                |\n+                   |  [empty]                       |\n+                   |                                |\n+                  -|================================|\n+                \/  |                                |\n+               |   | caller stack args              |   argsize\n+               |   | [metadata at frame top (1)]    | + frame::metadata_words_at_top\n+               |   | ------------------------------ |   words\n+               |   | [metadata at frame bottom (2)] |\n+         ^     |   | frame                          |\n+         |     |   |                                |\n+         |   size  | ------------------------------ |\n+         |   words |                                |\n+         |     |   | frame                          |\n+         |     |   |                                |\n+ Address |     |   | ------------------------------ |\n+         |     |   |                                |\n+         |     |   | frame                          |\n+         |     |   |                                |\n+         |     |   | callee stack args              |\n+         |     |   | [metadata at frame top (1)]    |<--\\\n+         |     |   | ------------------------------ |   |\n+         |     |   | [metadata at frame bottom (2)  |   |\n+         |     |   |  i.e. rbp, pc]                 |   |\n+         |     |   |                                |   |\n+         |     |   | [empty]                        |   |\n+         |     \\   |                                |   |\n+                 - |================================|   |\n+                   | int maxSize                    |   |\n+                   | long pc                        |   |\n+            header | byte flags                     |   |\n+                   | int argsize                    |   |\n+                   | int sp                         +---\/\n+                   | int size                       |\n+                   +--------------------------------+\n+\n+ (1) Metadata at frame top (see frame::metadata_words_at_top)\n+     Used on ppc64, empty on x86_64, aarch64\n+ (2) Metadata at the frame bottom (see frame::metadata_words_at_bottom)\n+     Used on x86_64 (saved rbp, ret.addr.), aarch64, empty on ppc64\n@@ -122,0 +128,1 @@\n+  static inline size_t gc_data_size(size_t stack_size_in_words); \/\/ In words\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.hpp","additions":46,"deletions":39,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  return align_object_size(size_helper() + stack_size_in_words + bitmap_size(stack_size_in_words));\n+  return align_object_size(size_helper() + stack_size_in_words + gc_data_size(stack_size_in_words));\n@@ -51,0 +51,5 @@\n+inline size_t InstanceStackChunkKlass::gc_data_size(size_t stack_size_in_words) {\n+  \/\/ At the moment all GCs are okay with GC data big enough to fit a bit map\n+  return bitmap_size(stack_size_in_words);\n+}\n+\n@@ -108,1 +113,1 @@\n-    intptr_t* start = chunk->sp_address() - frame::metadata_words;\n+    intptr_t* start = chunk->sp_address() - frame::metadata_words_at_bottom;\n@@ -126,1 +131,1 @@\n-    oop_oop_iterate_stack_with_bitmap<T>(chunk, closure, chunk->sp_address() - frame::metadata_words, chunk->end_address());\n+    oop_oop_iterate_stack_with_bitmap<T>(chunk, closure, chunk->sp_address() - frame::metadata_words_at_bottom, chunk->end_address());\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.inline.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -593,11 +593,7 @@\n-  \/\/ Grab a lock here to prevent multiple\n-  \/\/ MethodData*s from being created.\n-  MutexLocker ml(THREAD, MethodData_lock);\n-  if (method->method_data() == NULL) {\n-    ClassLoaderData* loader_data = method->method_holder()->class_loader_data();\n-    MethodData* method_data = MethodData::allocate(loader_data, method, THREAD);\n-    if (HAS_PENDING_EXCEPTION) {\n-      CompileBroker::log_metaspace_failure();\n-      ClassLoaderDataGraph::set_metaspace_oom(true);\n-      return;   \/\/ return the exception (which is cleared)\n-    }\n+  ClassLoaderData* loader_data = method->method_holder()->class_loader_data();\n+  MethodData* method_data = MethodData::allocate(loader_data, method, THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    CompileBroker::log_metaspace_failure();\n+    ClassLoaderDataGraph::set_metaspace_oom(true);\n+    return;   \/\/ return the exception (which is cleared)\n+  }\n@@ -605,8 +601,11 @@\n-    method->set_method_data(method_data);\n-    if (PrintMethodData && (Verbose || WizardMode)) {\n-      ResourceMark rm(THREAD);\n-      tty->print(\"build_profiling_method_data for \");\n-      method->print_name(tty);\n-      tty->cr();\n-      \/\/ At the end of the run, the MDO, full of data, will be dumped.\n-    }\n+  if (!Atomic::replace_if_null(&method->_method_data, method_data)) {\n+    MetadataFactory::free_metadata(loader_data, method_data);\n+    return;\n+  }\n+\n+  if (PrintMethodData && (Verbose || WizardMode)) {\n+    ResourceMark rm(THREAD);\n+    tty->print(\"build_profiling_method_data for \");\n+    method->print_name(tty);\n+    tty->cr();\n+    \/\/ At the end of the run, the MDO, full of data, will be dumped.\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":18,"deletions":19,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -661,0 +661,1 @@\n+  assert(!THREAD->owns_locks(), \"Should not own any locks\");\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n+#include \"gc\/shared\/barrierSetStackChunk.hpp\"\n@@ -39,0 +41,22 @@\n+template <typename RegisterMapT>\n+class FrameOopIterator : public OopIterator {\n+private:\n+  const frame& _f;\n+  const RegisterMapT* _map;\n+\n+public:\n+  FrameOopIterator(const frame& f, const RegisterMapT* map)\n+    : _f(f),\n+      _map(map) {\n+  }\n+\n+  virtual void oops_do(OopClosure* cl) override {\n+    if (_f.is_interpreted_frame()) {\n+      _f.oops_interpreted_do(cl, nullptr);\n+    } else {\n+      OopMapDo<OopClosure, DerivedOopClosure, IncludeAllValues> visitor(cl, nullptr);\n+      visitor.oops_do(&_f, _map, _f.oop_map());\n+    }\n+  }\n+};\n+\n@@ -175,1 +199,2 @@\n-class FrameToDerivedPointerClosure {\n+class EncodeGCModeConcurrentFrameClosure {\n+  stackChunkOop _chunk;\n@@ -179,2 +204,4 @@\n-  FrameToDerivedPointerClosure(DerivedPointerClosureType* cl)\n-    : _cl(cl) {}\n+  EncodeGCModeConcurrentFrameClosure(stackChunkOop chunk, DerivedPointerClosureType* cl)\n+    : _chunk(chunk),\n+      _cl(cl) {\n+  }\n@@ -185,0 +212,6 @@\n+\n+    BarrierSetStackChunk* bs_chunk = BarrierSet::barrier_set()->barrier_set_stack_chunk();\n+    frame fr = f.to_frame();\n+    FrameOopIterator<RegisterMapT> iterator(fr, map);\n+    bs_chunk->encode_gc_mode(_chunk, &iterator);\n+\n@@ -259,1 +292,1 @@\n-  FrameToDerivedPointerClosure<decltype(derived_cl)> frame_cl(&derived_cl);\n+  EncodeGCModeConcurrentFrameClosure<decltype(derived_cl)> frame_cl(this, &derived_cl);\n@@ -265,40 +298,0 @@\n-enum class OopKind { Narrow, Wide };\n-\n-template <OopKind kind>\n-class CompressOopsAndBuildBitmapOopClosure : public OopClosure {\n-  stackChunkOop _chunk;\n-  BitMapView _bm;\n-\n-  void convert_oop_to_narrowOop(oop* p) {\n-    oop obj = *p;\n-    *p = nullptr;\n-    *(narrowOop*)p = CompressedOops::encode(obj);\n-  }\n-\n-  template <typename T>\n-  void do_oop_work(T* p) {\n-    BitMap::idx_t index = _chunk->bit_index_for(p);\n-    assert(!_bm.at(index), \"must not be set already\");\n-    _bm.set_bit(index);\n-  }\n-\n-public:\n-  CompressOopsAndBuildBitmapOopClosure(stackChunkOop chunk)\n-    : _chunk(chunk), _bm(chunk->bitmap()) {}\n-\n-  virtual void do_oop(oop* p) override {\n-    if (kind == OopKind::Narrow) {\n-      \/\/ Convert all oops to narrow before marking the oop in the bitmap.\n-      convert_oop_to_narrowOop(p);\n-      do_oop_work((narrowOop*)p);\n-    } else {\n-      do_oop_work(p);\n-    }\n-  }\n-\n-  virtual void do_oop(narrowOop* p) override {\n-    do_oop_work(p);\n-  }\n-};\n-\n-template <OopKind kind>\n@@ -316,2 +309,4 @@\n-    CompressOopsAndBuildBitmapOopClosure<kind> cl(_chunk);\n-    f.iterate_oops(&cl, map);\n+    BarrierSetStackChunk* bs_chunk = BarrierSet::barrier_set()->barrier_set_stack_chunk();\n+    frame fr = f.to_frame();\n+    FrameOopIterator<RegisterMapT> iterator(fr, map);\n+    bs_chunk->encode_gc_mode(_chunk, &iterator);\n@@ -331,7 +326,2 @@\n-  if (UseCompressedOops) {\n-    TransformStackChunkClosure<OopKind::Narrow> closure(this);\n-    iterate_stack(&closure);\n-  } else {\n-    TransformStackChunkClosure<OopKind::Wide> closure(this);\n-    iterate_stack(&closure);\n-  }\n+  TransformStackChunkClosure closure(this);\n+  iterate_stack(&closure);\n@@ -394,12 +384,0 @@\n-class UncompressOopsOopClosure : public OopClosure {\n-public:\n-  void do_oop(oop* p) override {\n-    assert(UseCompressedOops, \"Only needed with compressed oops\");\n-    oop obj = CompressedOops::decode(*(narrowOop*)p);\n-    assert(obj == nullptr || dbg_is_good_oop(obj), \"p: \" PTR_FORMAT \" obj: \" PTR_FORMAT, p2i(p), p2i(obj));\n-    *p = obj;\n-  }\n-\n-  void do_oop(narrowOop* p) override {}\n-};\n-\n@@ -412,9 +390,3 @@\n-  if (has_bitmap() && UseCompressedOops) {\n-    UncompressOopsOopClosure oop_closure;\n-    if (f.is_interpreted_frame()) {\n-      f.oops_interpreted_do(&oop_closure, nullptr);\n-    } else {\n-      OopMapDo<UncompressOopsOopClosure, DerivedOopClosure, SkipNullValue> visitor(&oop_closure, nullptr);\n-      visitor.oops_do(&f, map, f.oop_map());\n-    }\n-  }\n+  BarrierSetStackChunk* bs_chunk = BarrierSet::barrier_set()->barrier_set_stack_chunk();\n+  FrameOopIterator<RegisterMapT> iterator(f, map);\n+  bs_chunk->decode_gc_mode(this, &iterator);\n@@ -444,6 +416,0 @@\n-template <typename P>\n-static inline oop safe_load(P* addr) {\n-  oop obj = RawAccess<>::oop_load(addr);\n-  return NativeAccess<>::oop_load(&obj);\n-}\n-\n@@ -462,2 +428,2 @@\n-     _count++;\n-    oop obj = safe_load(p);\n+    _count++;\n+    oop obj = _chunk->load_oop(p);\n@@ -501,1 +467,1 @@\n-    _argsize   = f.stack_argsize();\n+    _argsize   = f.stack_argsize() + frame::metadata_words_at_top;\n@@ -550,1 +516,1 @@\n-    oop obj = safe_load(p);\n+    oop obj = _chunk->load_oop(p);\n@@ -605,1 +571,1 @@\n-    assert(argsize() == closure._argsize,\n+    assert(argsize() == closure._argsize - (closure._num_frames > 0 ? frame::metadata_words_at_top : 0),\n@@ -636,1 +602,1 @@\n-                       bit_index_for((narrowOop*)(sp_address() - frame::metadata_words)),\n+                       bit_index_for((narrowOop*)(sp_address() - frame::metadata_words_at_bottom)),\n@@ -642,1 +608,1 @@\n-                       bit_index_for((oop*)(sp_address() - frame::metadata_words)),\n+                       bit_index_for((oop*)(sp_address() - frame::metadata_words_at_bottom)),\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.cpp","additions":53,"deletions":87,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -71,2 +71,0 @@\n-  inline bool is_parent_null() const;\n-  template<typename P>\n@@ -97,1 +95,0 @@\n-  template<typename P> inline oop cont() const;\n@@ -157,0 +154,1 @@\n+  inline void* gc_data() const;\n@@ -188,0 +186,3 @@\n+\n+  template <typename OopT>\n+  inline oop load_oop(OopT* addr);\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n+#include \"gc\/shared\/barrierSetStackChunk.hpp\"\n@@ -33,0 +35,1 @@\n+#include \"oops\/access.inline.hpp\"\n@@ -50,2 +53,0 @@\n-template<typename P>\n-inline bool stackChunkOopDesc::is_parent_null() const          { return jdk_internal_vm_StackChunk::is_parent_null<P>(as_oop()); }\n@@ -88,7 +89,1 @@\n-inline oop stackChunkOopDesc::cont() const              { return UseCompressedOops ? cont<narrowOop>() : cont<oop>(); \/* jdk_internal_vm_StackChunk::cont(as_oop()); *\/ }\n-template<typename P>\n-inline oop stackChunkOopDesc::cont() const              {\n-  oop obj = jdk_internal_vm_StackChunk::cont_raw<P>(as_oop());\n-  obj = (oop)NativeAccess<>::oop_load(&obj);\n-  return obj;\n-}\n+inline oop stackChunkOopDesc::cont() const                { return jdk_internal_vm_StackChunk::cont(as_oop()); }\n@@ -97,1 +92,1 @@\n-inline void stackChunkOopDesc::set_cont_raw(oop value)    {  jdk_internal_vm_StackChunk::set_cont_raw<P>(this, value); }\n+inline void stackChunkOopDesc::set_cont_raw(oop value)    { jdk_internal_vm_StackChunk::set_cont_raw<P>(this, value); }\n@@ -101,1 +96,1 @@\n-inline int stackChunkOopDesc::bottom() const { return stack_size() - argsize(); }\n+inline int stackChunkOopDesc::bottom() const { return stack_size() - argsize() - frame::metadata_words_at_top; }\n@@ -126,1 +121,1 @@\n-  assert((sp() == stack_size()) == (sp() >= stack_size() - argsize()),\n+  assert((sp() == stack_size()) == (sp() >= stack_size() - argsize() - frame::metadata_words_at_top),\n@@ -138,6 +133,1 @@\n-#if (defined(X86) || defined(AARCH64) || defined(RISCV64)) && !defined(ZERO)\n-  HeapWord* start = (HeapWord*)start_address() + sp() - frame::metadata_words;\n-#else\n-  Unimplemented();\n-  HeapWord* start = NULL;\n-#endif\n+  HeapWord* start = (HeapWord*)start_address() + sp() - frame::metadata_words_at_bottom;\n@@ -234,1 +224,1 @@\n-inline BitMapView stackChunkOopDesc::bitmap() const {\n+inline void* stackChunkOopDesc::gc_data() const {\n@@ -236,0 +226,5 @@\n+  assert(stack_sz != 0, \"stack should not be empty\");\n+\n+  \/\/ The gc data is located after the stack.\n+  return start_of_stack() + stack_sz;\n+}\n@@ -237,2 +232,3 @@\n-  \/\/ The bitmap is located after the stack.\n-  HeapWord* bitmap_addr = start_of_stack() + stack_sz;\n+inline BitMapView stackChunkOopDesc::bitmap() const {\n+  HeapWord* bitmap_addr = static_cast<HeapWord*>(gc_data());\n+  int stack_sz = stack_size();\n@@ -327,1 +323,1 @@\n-#if !defined(AMD64) || !defined(AARCH64) || !defined(RISCV64) || defined(ZERO)\n+#if !(defined(AMD64) || defined(AARCH64) || defined(RISCV64) || defined(PPC64)) || defined(ZERO)\n@@ -346,1 +342,1 @@\n-#if !defined(AMD64) || !defined(AARCH64) || !defined(RISCV64) || defined(ZERO)\n+#if !(defined(AMD64) || defined(AARCH64) || defined(RISCV64) || defined(PPC64)) || defined(ZERO)\n@@ -355,0 +351,5 @@\n+template <typename OopT>\n+inline oop stackChunkOopDesc::load_oop(OopT* addr) {\n+  return BarrierSet::barrier_set()->barrier_set_stack_chunk()->load_oop(this, addr);\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -740,0 +740,1 @@\n+  case vmIntrinsics::_chacha20Block:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -406,6 +406,2 @@\n-  if (inn->isa_oopptr() && _type->isa_oopptr()) {\n-    return ConstraintCastNode::Value(phase);\n-  }\n-\n-  const TypePtr *in_type = inn->isa_ptr();\n-  const TypePtr *my_type = _type->isa_ptr();\n+  const TypePtr *in_type   = inn->isa_ptr();\n+  const TypePtr *my_type   = _type->isa_ptr();\n@@ -413,2 +409,2 @@\n-  if (in_type != NULL && my_type != NULL) {\n-    TypePtr::PTR in_ptr = in_type->ptr();\n+  if( in_type != NULL && my_type != NULL ) {\n+    TypePtr::PTR   in_ptr    = in_type->ptr();\n@@ -417,0 +413,10 @@\n+    } else if (in_ptr == TypePtr::Constant) {\n+      if (my_type->isa_rawptr()) {\n+        result = my_type;\n+      } else {\n+        const TypeOopPtr *jptr = my_type->isa_oopptr();\n+        assert(jptr, \"\");\n+        result = !in_type->higher_equal(_type)\n+          ? my_type->cast_to_ptr_type(TypePtr::NotNull)\n+          : in_type;\n+      }\n@@ -418,1 +424,1 @@\n-      result =  my_type->cast_to_ptr_type(my_type->join_ptr(in_ptr));\n+      result =  my_type->cast_to_ptr_type( my_type->join_ptr(in_ptr) );\n@@ -422,1 +428,55 @@\n-  return result;\n+  \/\/ This is the code from TypePtr::xmeet() that prevents us from\n+  \/\/ having 2 ways to represent the same type. We have to replicate it\n+  \/\/ here because we don't go through meet\/join.\n+  if (result->remove_speculative() == result->speculative()) {\n+    result = result->remove_speculative();\n+  }\n+\n+  \/\/ Same as above: because we don't go through meet\/join, remove the\n+  \/\/ speculative type if we know we won't use it.\n+  return result->cleanup_speculative();\n+\n+  \/\/ JOIN NOT DONE HERE BECAUSE OF INTERFACE ISSUES.\n+  \/\/ FIX THIS (DO THE JOIN) WHEN UNION TYPES APPEAR!\n+\n+  \/\/\n+  \/\/ Remove this code after overnight run indicates no performance\n+  \/\/ loss from not performing JOIN at CheckCastPPNode\n+  \/\/\n+  \/\/ const TypeInstPtr *in_oop = in->isa_instptr();\n+  \/\/ const TypeInstPtr *my_oop = _type->isa_instptr();\n+  \/\/ \/\/ If either input is an 'interface', return destination type\n+  \/\/ assert (in_oop == NULL || in_oop->klass() != NULL, \"\");\n+  \/\/ assert (my_oop == NULL || my_oop->klass() != NULL, \"\");\n+  \/\/ if( (in_oop && in_oop->klass()->is_interface())\n+  \/\/   ||(my_oop && my_oop->klass()->is_interface()) ) {\n+  \/\/   TypePtr::PTR  in_ptr = in->isa_ptr() ? in->is_ptr()->_ptr : TypePtr::BotPTR;\n+  \/\/   \/\/ Preserve cast away nullness for interfaces\n+  \/\/   if( in_ptr == TypePtr::NotNull && my_oop && my_oop->_ptr == TypePtr::BotPTR ) {\n+  \/\/     return my_oop->cast_to_ptr_type(TypePtr::NotNull);\n+  \/\/   }\n+  \/\/   return _type;\n+  \/\/ }\n+  \/\/\n+  \/\/ \/\/ Neither the input nor the destination type is an interface,\n+  \/\/\n+  \/\/ \/\/ history: JOIN used to cause weird corner case bugs\n+  \/\/ \/\/          return (in == TypeOopPtr::NULL_PTR) ? in : _type;\n+  \/\/ \/\/ JOIN picks up NotNull in common instance-of\/check-cast idioms, both oops.\n+  \/\/ \/\/ JOIN does not preserve NotNull in other cases, e.g. RawPtr vs InstPtr\n+  \/\/ const Type *join = in->join(_type);\n+  \/\/ \/\/ Check if join preserved NotNull'ness for pointers\n+  \/\/ if( join->isa_ptr() && _type->isa_ptr() ) {\n+  \/\/   TypePtr::PTR join_ptr = join->is_ptr()->_ptr;\n+  \/\/   TypePtr::PTR type_ptr = _type->is_ptr()->_ptr;\n+  \/\/   \/\/ If there isn't any NotNull'ness to preserve\n+  \/\/   \/\/ OR if join preserved NotNull'ness then return it\n+  \/\/   if( type_ptr == TypePtr::BotPTR  || type_ptr == TypePtr::Null ||\n+  \/\/       join_ptr == TypePtr::NotNull || join_ptr == TypePtr::Constant ) {\n+  \/\/     return join;\n+  \/\/   }\n+  \/\/   \/\/ ELSE return same old type as before\n+  \/\/   return _type;\n+  \/\/ }\n+  \/\/ \/\/ Not joining two pointers\n+  \/\/ return join;\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":70,"deletions":10,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -1183,0 +1183,16 @@\n+  \/\/ Until we have harmony between classes and interfaces in the type\n+  \/\/ lattice, we must tread carefully around phis which implicitly\n+  \/\/ convert the one to the other.\n+  const TypePtr* ttp = _type->make_ptr();\n+  const TypeInstPtr* ttip = (ttp != NULL) ? ttp->isa_instptr() : NULL;\n+  const TypeInstKlassPtr* ttkp = (ttp != NULL) ? ttp->isa_instklassptr() : NULL;\n+  bool is_intf = false;\n+  if (ttip != NULL) {\n+    if (ttip->is_interface())\n+      is_intf = true;\n+  }\n+  if (ttkp != NULL) {\n+    if (ttkp->is_interface())\n+      is_intf = true;\n+  }\n+\n@@ -1189,0 +1205,14 @@\n+      \/\/ We assume that each input of an interface-valued Phi is a true\n+      \/\/ subtype of that interface.  This might not be true of the meet\n+      \/\/ of all the input types.  The lattice is not distributive in\n+      \/\/ such cases.  Ward off asserts in type.cpp by refusing to do\n+      \/\/ meets between interfaces and proper classes.\n+      const TypePtr* tip = ti->make_ptr();\n+      const TypeInstPtr* tiip = (tip != NULL) ? tip->isa_instptr() : NULL;\n+      if (tiip) {\n+        bool ti_is_intf = false;\n+        if (tiip->is_interface())\n+          ti_is_intf = true;\n+        if (is_intf != ti_is_intf)\n+          { t = _type; break; }\n+      }\n@@ -1212,3 +1242,25 @@\n-    \/\/ Otherwise it's something stupid like non-overlapping int ranges\n-    \/\/ found on dying counted loops.\n-    assert(ft == Type::TOP, \"\"); \/\/ Canonical empty value\n+\n+    \/\/ Check for evil case of 't' being a class and '_type' expecting an\n+    \/\/ interface.  This can happen because the bytecodes do not contain\n+    \/\/ enough type info to distinguish a Java-level interface variable\n+    \/\/ from a Java-level object variable.  If we meet 2 classes which\n+    \/\/ both implement interface I, but their meet is at 'j\/l\/O' which\n+    \/\/ doesn't implement I, we have no way to tell if the result should\n+    \/\/ be 'I' or 'j\/l\/O'.  Thus we'll pick 'j\/l\/O'.  If this then flows\n+    \/\/ into a Phi which \"knows\" it's an Interface type we'll have to\n+    \/\/ uplift the type.\n+    if (!t->empty() && ttip && ttip->is_interface()) {\n+      assert(ft == _type, \"\"); \/\/ Uplift to interface\n+    } else if (!t->empty() && ttkp && ttkp->is_interface()) {\n+      assert(ft == _type, \"\"); \/\/ Uplift to interface\n+    } else {\n+      \/\/ We also have to handle 'evil cases' of interface- vs. class-arrays\n+      Type::get_arrays_base_elements(jt, _type, NULL, &ttip);\n+      if (!t->empty() && ttip != NULL && ttip->is_interface()) {\n+          assert(ft == _type, \"\");   \/\/ Uplift to array of interface\n+      } else {\n+        \/\/ Otherwise it's something stupid like non-overlapping int ranges\n+        \/\/ found on dying counted loops.\n+        assert(ft == Type::TOP, \"\"); \/\/ Canonical empty value\n+      }\n+    }\n@@ -1219,0 +1271,25 @@\n+    \/\/ If we have an interface-typed Phi and we narrow to a class type, the join\n+    \/\/ should report back the class.  However, if we have a J\/L\/Object\n+    \/\/ class-typed Phi and an interface flows in, it's possible that the meet &\n+    \/\/ join report an interface back out.  This isn't possible but happens\n+    \/\/ because the type system doesn't interact well with interfaces.\n+    const TypePtr *jtp = jt->make_ptr();\n+    const TypeInstPtr *jtip = (jtp != NULL) ? jtp->isa_instptr() : NULL;\n+    const TypeInstKlassPtr *jtkp = (jtp != NULL) ? jtp->isa_instklassptr() : NULL;\n+    if (jtip && ttip) {\n+      if (jtip->is_interface() &&\n+          !ttip->is_interface()) {\n+        assert(ft == ttip->cast_to_ptr_type(jtip->ptr()) ||\n+               ft->isa_narrowoop() && ft->make_ptr() == ttip->cast_to_ptr_type(jtip->ptr()), \"\");\n+        jt = ft;\n+      }\n+    }\n+    if (jtkp && ttkp) {\n+      if (jtkp->is_interface() &&\n+          !jtkp->klass_is_exact() && \/\/ Keep exact interface klass (6894807)\n+          ttkp->is_loaded() && !ttkp->is_interface()) {\n+        assert(ft == ttkp->cast_to_ptr_type(jtkp->ptr()) ||\n+               ft->isa_narrowklass() && ft->make_ptr() == ttkp->cast_to_ptr_type(jtkp->ptr()), \"\");\n+        jt = ft;\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":80,"deletions":3,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -600,1 +600,1 @@\n-    Node* cls_node = makecon(TypeKlassPtr::make(receiver_constraint, Type::trust_interfaces));\n+    Node* cls_node = makecon(TypeKlassPtr::make(receiver_constraint));\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1171,0 +1171,1 @@\n+                  strcmp(call->as_CallLeaf()->_name, \"chacha20Block\") == 0 ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2185,1 +2185,1 @@\n-    const TypeKlassPtr* tklass = TypeKlassPtr::make(exact_kls, Type::trust_interfaces);\n+    const TypeKlassPtr* tklass = TypeKlassPtr::make(exact_kls);\n@@ -2639,1 +2639,1 @@\n-  cmp = gvn.transform(cmp);\n+  gvn.transform(cmp);\n@@ -2847,1 +2847,1 @@\n-  const TypeKlassPtr* tklass = TypeKlassPtr::make(klass, Type::trust_interfaces);\n+  const TypeKlassPtr* tklass = TypeKlassPtr::make(klass);\n@@ -2876,1 +2876,1 @@\n-  const TypeKlassPtr* tklass = TypeKlassPtr::make(klass, Type::trust_interfaces)->try_improve();\n+  const TypeKlassPtr* tklass = TypeKlassPtr::make(klass);\n@@ -2999,1 +2999,1 @@\n-        C->static_subtype_check(require_klass, TypeKlassPtr::make(exact_kls, Type::trust_interfaces)) == Compile::SSC_always_true) {\n+        C->static_subtype_check(require_klass, TypeKlassPtr::make(exact_kls)) == Compile::SSC_always_true) {\n@@ -3185,2 +3185,2 @@\n-  const TypeKlassPtr *tk = _gvn.type(superklass)->is_klassptr()->try_improve();\n-  const TypeOopPtr *toop = tk->cast_to_exactness(false)->as_instance_type();\n+  const TypeKlassPtr *tk = _gvn.type(superklass)->is_klassptr();\n+  const Type *toop = tk->cast_to_exactness(false)->as_instance_type();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -503,1 +503,3 @@\n-      if (toop) {\n+      if ((toop != NULL && toop->is_interface()) || (tkls != NULL && tkls->is_interface())) {\n+        s2.print(\"  Interface:\");\n+      } else if (toop) {\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -611,0 +611,2 @@\n+  case vmIntrinsics::_chacha20Block:\n+    return inline_chacha20Block();\n@@ -3664,1 +3666,1 @@\n-      int static_res = C->static_subtype_check(TypeKlassPtr::make(tm->as_klass(), Type::trust_interfaces), tp->as_klass_type());\n+      int static_res = C->static_subtype_check(TypeKlassPtr::make(tm->as_klass()), tp->as_klass_type());\n@@ -6900,0 +6902,30 @@\n+\/\/------------------------------inline_chacha20Block\n+bool LibraryCallKit::inline_chacha20Block() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseChaCha20Intrinsics, \"need ChaCha20 intrinsics support\");\n+\n+  stubAddr = StubRoutines::chacha20Block();\n+  stubName = \"chacha20Block\";\n+\n+  Node* state          = argument(0);\n+  Node* result         = argument(1);\n+\n+  state = must_be_not_null(state, true);\n+  result = must_be_not_null(result, true);\n+\n+  Node* state_start  = array_element_address(state, intcon(0), T_INT);\n+  assert(state_start, \"state is NULL\");\n+  Node* result_start  = array_element_address(result, intcon(0), T_BYTE);\n+  assert(result_start, \"result is NULL\");\n+\n+  Node* cc20Blk = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                  OptoRuntime::chacha20Block_Type(),\n+                                  stubAddr, stubName, TypePtr::BOTTOM,\n+                                  state_start, result_start);\n+  \/\/ return key stream length (int)\n+  Node* retvalue = _gvn.transform(new ProjNode(cc20Blk, TypeFunc::Parms));\n+  set_result(retvalue);\n+  return true;\n+}\n+\n@@ -7202,1 +7234,1 @@\n-  const TypeOopPtr* xtype = aklass->cast_to_exactness(false)->as_instance_type()->cast_to_ptr_type(TypePtr::NotNull);\n+  const TypeOopPtr* xtype = aklass->as_instance_type()->cast_to_ptr_type(TypePtr::NotNull);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -294,0 +294,1 @@\n+  bool inline_chacha20Block();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -279,0 +279,1 @@\n+      _parm_regs[i].set_bad();\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2035,1 +2035,1 @@\n-        return ss ? TypeKlassPtr::make(ss, Type::trust_interfaces) : TypePtr::NULL_PTR;\n+        return ss ? TypeKlassPtr::make(ss) : TypePtr::NULL_PTR;\n@@ -2066,1 +2066,1 @@\n-          return ss ? TypeKlassPtr::make(ss, Type::trust_interfaces) : TypePtr::NULL_PTR;\n+          return ss ? TypeKlassPtr::make(ss) : TypePtr::NULL_PTR;\n@@ -2326,1 +2326,1 @@\n-          return TypeKlassPtr::make(ciArrayKlass::make(t), Type::trust_interfaces);\n+          return TypeKlassPtr::make(ciArrayKlass::make(t));\n@@ -2333,1 +2333,1 @@\n-        return TypeKlassPtr::make(t->as_klass(), Type::trust_interfaces);\n+        return TypeKlassPtr::make(t->as_klass());\n@@ -2371,1 +2371,1 @@\n-      return sup ? TypeKlassPtr::make(sup, Type::trust_interfaces) : TypePtr::NULL_PTR;\n+      return sup ? TypeKlassPtr::make(sup) : TypePtr::NULL_PTR;\n@@ -2390,1 +2390,1 @@\n-  \/\/ Take apart the address into an oop and and offset.\n+  \/\/ Take apart the address into an oop and offset.\n@@ -2491,1 +2491,1 @@\n-  \/\/ Take apart the address into an oop and and offset.\n+  \/\/ Take apart the address into an oop and offset.\n@@ -2523,1 +2523,1 @@\n-  \/\/ Take apart the address into an oop and and offset.\n+  \/\/ Take apart the address into an oop and offset.\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2557,1 +2557,4 @@\n-    if (toop) {\n+    ciKlass*           klass = toop ? toop->instance_klass() : (tkls ? tkls->instance_klass() : NULL );\n+    if (klass && klass->is_loaded() && ((toop && toop->is_interface()) || (tkls && tkls->is_interface()))) {\n+      st->print(\"  Interface:\");\n+    } else if (toop) {\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -178,2 +178,0 @@\n-  BasicType bt_l = _gvn.type(l)->basic_type();\n-  BasicType bt_t = type->basic_type();\n@@ -1202,1 +1200,1 @@\n-    const Type* holder_type = TypeInstPtr::make(TypePtr::BotPTR, callee_holder, Type::trust_interfaces);\n+    const Type* holder_type = TypeInstPtr::make(TypePtr::BotPTR, callee_holder);\n@@ -1215,1 +1213,1 @@\n-      Node* holder_klass = _gvn.makecon(TypeKlassPtr::make(callee_holder, Type::trust_interfaces));\n+      Node* holder_klass = _gvn.makecon(TypeKlassPtr::make(callee_holder));\n@@ -2135,1 +2133,1 @@\n-  Node* holder = makecon(TypeKlassPtr::make(method()->holder(), Type::trust_interfaces));\n+  Node* holder = makecon(TypeKlassPtr::make(method()->holder()));\n@@ -2214,0 +2212,21 @@\n+    const TypeInstPtr *tr = phi->bottom_type()->isa_instptr();\n+    if (tr && tr->is_loaded() &&\n+        tr->is_interface()) {\n+      const TypeInstPtr *tp = value->bottom_type()->isa_instptr();\n+      if (tp && tp->is_loaded() &&\n+          !tp->is_interface()) {\n+        \/\/ sharpen the type eagerly; this eases certain assert checking\n+        if (tp->higher_equal(TypeInstPtr::NOTNULL))\n+          tr = tr->join_speculative(TypeInstPtr::NOTNULL)->is_instptr();\n+        value = _gvn.transform(new CheckCastPPNode(0, value, tr));\n+      }\n+    } else {\n+      \/\/ Also handle returns of oop-arrays to an arrays-of-interface return\n+      const TypeInstPtr* phi_tip;\n+      const TypeInstPtr* val_tip;\n+      Type::get_arrays_base_elements(phi->bottom_type(), value->bottom_type(), &phi_tip, &val_tip);\n+      if (phi_tip != NULL && phi_tip->is_loaded() && phi_tip->is_interface() &&\n+          val_tip != NULL && val_tip->is_loaded() && !val_tip->is_interface()) {\n+        value = _gvn.transform(new CheckCastPPNode(0, value, phi->bottom_type()));\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-  const TypeKlassPtr* array_klass_type = TypeKlassPtr::make(array_klass, Type::trust_interfaces);\n+  const TypeKlassPtr* array_klass_type = TypeKlassPtr::make(array_klass);\n@@ -302,1 +302,1 @@\n-  Node* array = new_array(makecon(TypeKlassPtr::make(array_klass, Type::trust_interfaces)), length, nargs);\n+  Node* array = new_array(makecon(TypeKlassPtr::make(array_klass)), length, nargs);\n@@ -388,1 +388,1 @@\n-                          makecon(TypeKlassPtr::make(array_klass, Type::trust_interfaces)),\n+                          makecon(TypeKlassPtr::make(array_klass)),\n@@ -410,1 +410,1 @@\n-                          makecon(TypeKlassPtr::make(array_klass, Type::trust_interfaces)),\n+                          makecon(TypeKlassPtr::make(array_klass)),\n@@ -417,1 +417,1 @@\n-  const Type* type = TypeOopPtr::make_from_klass_raw(array_klass, Type::trust_interfaces);\n+  const Type* type = TypeOopPtr::make_from_klass_raw(array_klass);\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-  Node* res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass, Type::trust_interfaces)));\n+  Node* res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass)));\n@@ -132,1 +132,1 @@\n-  Node* res = gen_instanceof(peek(), makecon(TypeKlassPtr::make(klass, Type::trust_interfaces)), true);\n+  Node* res = gen_instanceof(peek(), makecon(TypeKlassPtr::make(klass)), true);\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1225,0 +1225,20 @@\n+\n+\/\/ ChaCha20 Block function\n+const TypeFunc* OptoRuntime::chacha20Block_Type() {\n+    int argcnt = 2;\n+\n+    const Type** fields = TypeTuple::fields(argcnt);\n+    int argp = TypeFunc::Parms;\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ state\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ result\n+\n+    assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n+\n+    \/\/ result type needed\n+    fields = TypeTuple::fields(1);\n+    fields[TypeFunc::Parms + 0] = TypeInt::INT;     \/\/ key stream outlen as int\n+    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+    return TypeFunc::make(domain, range);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -281,0 +281,1 @@\n+  static const TypeFunc* chacha20Block_Type();\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-                                       \/\/ SB.toString or or String.<init>(SB.toString)\n+                                       \/\/ SB.toString or String.<init>(SB.toString)\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1050,1 +1050,1 @@\n-  return phase->makecon(TypeKlassPtr::make(mirror_type->as_klass(), Type::trust_interfaces));\n+  return phase->makecon(TypeKlassPtr::make(mirror_type->as_klass()));\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,2 +123,0 @@\n-const TypePtr::InterfaceSet* TypeAryPtr::_array_interfaces = NULL;\n-const TypePtr::InterfaceSet* TypeAryKlassPtr::_array_interfaces = NULL;\n@@ -139,1 +137,1 @@\n-const Type* Type::get_const_type(ciType* type, InterfaceHandling interface_handling) {\n+const Type* Type::get_const_type(ciType* type) {\n@@ -145,1 +143,1 @@\n-    return TypeOopPtr::make_from_klass(type->as_klass(), interface_handling);\n+    return TypeOopPtr::make_from_klass(type->as_klass());\n@@ -571,6 +569,0 @@\n-  GrowableArray<ciInstanceKlass*> array_interfaces;\n-  array_interfaces.push(current->env()->Cloneable_klass());\n-  array_interfaces.push(current->env()->Serializable_klass());\n-  TypeAryPtr::_array_interfaces = new TypePtr::InterfaceSet(&array_interfaces);\n-  TypeAryKlassPtr::_array_interfaces = TypeAryPtr::_array_interfaces;\n-\n@@ -789,0 +781,45 @@\n+\/\/----------------------interface_vs_oop---------------------------------------\n+#ifdef ASSERT\n+bool Type::interface_vs_oop_helper(const Type *t) const {\n+  bool result = false;\n+\n+  const TypePtr* this_ptr = this->make_ptr(); \/\/ In case it is narrow_oop\n+  const TypePtr*    t_ptr =    t->make_ptr();\n+  if( this_ptr == NULL || t_ptr == NULL )\n+    return result;\n+\n+  const TypeInstPtr* this_inst = this_ptr->isa_instptr();\n+  const TypeInstPtr*    t_inst =    t_ptr->isa_instptr();\n+  if( this_inst && this_inst->is_loaded() && t_inst && t_inst->is_loaded() ) {\n+    bool this_interface = this_inst->is_interface();\n+    bool    t_interface =    t_inst->is_interface();\n+    result = this_interface ^ t_interface;\n+  }\n+\n+  return result;\n+}\n+\n+bool Type::interface_vs_oop(const Type *t) const {\n+  if (interface_vs_oop_helper(t)) {\n+    return true;\n+  }\n+  \/\/ Now check the speculative parts as well\n+  const TypePtr* this_spec = isa_ptr() != NULL ? is_ptr()->speculative() : NULL;\n+  const TypePtr* t_spec = t->isa_ptr() != NULL ? t->is_ptr()->speculative() : NULL;\n+  if (this_spec != NULL && t_spec != NULL) {\n+    if (this_spec->interface_vs_oop_helper(t_spec)) {\n+      return true;\n+    }\n+    return false;\n+  }\n+  if (this_spec != NULL && this_spec->interface_vs_oop_helper(t)) {\n+    return true;\n+  }\n+  if (t_spec != NULL && interface_vs_oop_helper(t_spec)) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+#endif\n+\n@@ -808,1 +845,1 @@\n-  if (t2t != t->_dual || t2this != this->_dual) {\n+  if (!interface_vs_oop(t) && (t2t != t->_dual || t2this != this->_dual)) {\n@@ -1986,1 +2023,1 @@\n-const TypeTuple *TypeTuple::make_range(ciSignature* sig, InterfaceHandling interface_handling) {\n+const TypeTuple *TypeTuple::make_range(ciSignature* sig) {\n@@ -2007,1 +2044,1 @@\n-    field_array[TypeFunc::Parms] = get_const_type(return_type, interface_handling);\n+    field_array[TypeFunc::Parms] = get_const_type(return_type);\n@@ -2018,1 +2055,1 @@\n-const TypeTuple *TypeTuple::make_domain(ciInstanceKlass* recv, ciSignature* sig, InterfaceHandling interface_handling) {\n+const TypeTuple *TypeTuple::make_domain(ciInstanceKlass* recv, ciSignature* sig) {\n@@ -2027,1 +2064,1 @@\n-    field_array[pos++] = get_const_type(recv, interface_handling)->join_speculative(TypePtr::NOTNULL);\n+    field_array[pos++] = get_const_type(recv)->join_speculative(TypePtr::NOTNULL);\n@@ -2049,1 +2086,1 @@\n-      field_array[pos++] = get_const_type(type, interface_handling);\n+      field_array[pos++] = get_const_type(type);\n@@ -2280,0 +2317,15 @@\n+\/\/----------------------interface_vs_oop---------------------------------------\n+#ifdef ASSERT\n+bool TypeAry::interface_vs_oop(const Type *t) const {\n+  const TypeAry* t_ary = t->is_ary();\n+  if (t_ary) {\n+    const TypePtr* this_ptr = _elem->make_ptr(); \/\/ In case we have narrow_oops\n+    const TypePtr*    t_ptr = t_ary->_elem->make_ptr();\n+    if(this_ptr != NULL && t_ptr != NULL) {\n+      return this_ptr->interface_vs_oop(t_ptr);\n+    }\n+  }\n+  return false;\n+}\n+#endif\n+\n@@ -2317,1 +2369,3 @@\n-  if (!toop->is_loaded())   return false;  \/\/ unloaded class\n+  ciKlass* tklass = toop->klass();\n+  if (tklass == NULL)       return false;  \/\/ unloaded class\n+  if (!tklass->is_loaded()) return false;  \/\/ unloaded class\n@@ -2324,1 +2378,1 @@\n-    return tinst->instance_klass()->is_final();\n+    return tklass->as_instance_klass()->is_final();\n@@ -3116,220 +3170,0 @@\n-TypePtr::InterfaceSet::InterfaceSet()\n-        : _list(Compile::current()->type_arena(), 0, 0, NULL),\n-          _hash_computed(0), _exact_klass_computed(0), _is_loaded_computed(0) {\n-}\n-\n-TypePtr::InterfaceSet::InterfaceSet(GrowableArray<ciInstanceKlass*>* interfaces)\n-        : _list(Compile::current()->type_arena(), interfaces->length(), 0, NULL),\n-          _hash_computed(0), _exact_klass_computed(0), _is_loaded_computed(0) {\n-  for (int i = 0; i < interfaces->length(); i++) {\n-    add(interfaces->at(i));\n-  }\n-}\n-\n-\n-int TypePtr::InterfaceSet::compare(ciKlass* const& k1, ciKlass* const& k2) {\n-  if ((intptr_t)k1 < (intptr_t)k2) {\n-    return -1;\n-  } else if ((intptr_t)k1 > (intptr_t)k2) {\n-    return 1;\n-  }\n-  return 0;\n-}\n-\n-void TypePtr::InterfaceSet::add(ciKlass* interface) {\n-  assert(interface->is_interface(), \"for interfaces only\");\n-  _list.insert_sorted<compare>(interface);\n-  verify();\n-}\n-\n-void TypePtr::InterfaceSet::raw_add(ciKlass* interface) {\n-  assert(interface->is_interface(), \"for interfaces only\");\n-  _list.push(interface);\n-}\n-\n-bool TypePtr::InterfaceSet::eq(const InterfaceSet& other) const {\n-  if (_list.length() != other._list.length()) {\n-    return false;\n-  }\n-  for (int i = 0; i < _list.length(); i++) {\n-    ciKlass* k1 = _list.at(i);\n-    ciKlass* k2 = other._list.at(i);\n-    if (!k1->equals(k2)) {\n-      return false;\n-    }\n-  }\n-  return true;\n-}\n-\n-int TypePtr::InterfaceSet::hash() const {\n-  if (_hash_computed) {\n-    return _hash;\n-  }\n-  const_cast<InterfaceSet*>(this)->compute_hash();\n-  assert(_hash_computed, \"should be computed now\");\n-  return _hash;\n-}\n-\n-void TypePtr::InterfaceSet::compute_hash() {\n-  int hash = 0;\n-  for (int i = 0; i < _list.length(); i++) {\n-    ciKlass* k = _list.at(i);\n-    hash += (jint)k->hash();\n-  }\n-  _hash_computed = 1;\n-  _hash = hash;\n-}\n-\n-void TypePtr::InterfaceSet::dump(outputStream *st) const {\n-  if (_list.length() == 0) {\n-    return;\n-  }\n-  st->print(\" (\");\n-  for (int i = 0; i < _list.length(); i++) {\n-    if (i > 0) {\n-      st->print(\",\");\n-    }\n-    ciKlass* k = _list.at(i);\n-    k->print_name_on(st);\n-  }\n-  st->print(\")\");\n-}\n-\n-void TypePtr::InterfaceSet::verify() const {\n-#ifdef DEBUG\n-  for (int i = 1; i < _list.length(); i++) {\n-    ciKlass* k1 = _list.at(i-1);\n-    ciKlass* k2 = _list.at(i);\n-    assert(compare(k2, k1) > 0, \"should be ordered\");\n-    assert(k1 != k2, \"no duplicate\");\n-  }\n-#endif\n-}\n-\n-TypePtr::InterfaceSet TypeOopPtr::InterfaceSet::union_with(const InterfaceSet& other) const {\n-  InterfaceSet result;\n-  int i = 0;\n-  int j = 0;\n-  while (i < _list.length() || j < other._list.length()) {\n-    while (i < _list.length() &&\n-           (j >= other._list.length() ||\n-            compare(_list.at(i), other._list.at(j)) < 0)) {\n-      result.raw_add(_list.at(i));\n-      i++;\n-    }\n-    while (j < other._list.length() &&\n-           (i >= _list.length() ||\n-            compare(other._list.at(j), _list.at(i)) < 0)) {\n-      result.raw_add(other._list.at(j));\n-      j++;\n-    }\n-    if (i < _list.length() &&\n-        j < other._list.length() &&\n-        _list.at(i) == other._list.at(j)) {\n-      result.raw_add(_list.at(i));\n-      i++;\n-      j++;\n-    }\n-  }\n-  result.verify();\n-#ifdef DEBUG\n-  for (int i = 0; i < _list.length(); i++) {\n-    assert(result.contains(_list.at(i)), \"missing\");\n-  }\n-  for (int i = 0; i < other._list.length(); i++) {\n-    assert(result.contains(other._list.at(i)), \"missing\");\n-  }\n-  for (int i = 0; i < result._list.length(); i++) {\n-    assert(_list.contains(result._list.at(i)) || other._list.contains(result._list.at(i)), \"missing\");\n-  }\n-#endif\n-  return result;\n-}\n-\n-TypePtr::InterfaceSet TypeOopPtr::InterfaceSet::intersection_with(const InterfaceSet& other) const {\n-  InterfaceSet result;\n-  int i = 0;\n-  int j = 0;\n-  while (i < _list.length() || j < other._list.length()) {\n-    while (i < _list.length() &&\n-           (j >= other._list.length() ||\n-            compare(_list.at(i), other._list.at(j)) < 0)) {\n-      i++;\n-    }\n-    while (j < other._list.length() &&\n-           (i >= _list.length() ||\n-            compare(other._list.at(j), _list.at(i)) < 0)) {\n-      j++;\n-    }\n-    if (i < _list.length() &&\n-        j < other._list.length() &&\n-        _list.at(i) == other._list.at(j)) {\n-      result.raw_add(_list.at(i));\n-      i++;\n-      j++;\n-    }\n-  }\n-  result.verify();\n-#ifdef DEBUG\n-  for (int i = 0; i < _list.length(); i++) {\n-    assert(!other._list.contains(_list.at(i)) || result.contains(_list.at(i)), \"missing\");\n-  }\n-  for (int i = 0; i < other._list.length(); i++) {\n-    assert(!_list.contains(other._list.at(i)) || result.contains(other._list.at(i)), \"missing\");\n-  }\n-  for (int i = 0; i < result._list.length(); i++) {\n-    assert(_list.contains(result._list.at(i)) && other._list.contains(result._list.at(i)), \"missing\");\n-  }\n-#endif\n-  return result;\n-}\n-\n-\/\/ Is there a single ciKlass* that can represent the interface set?\n-ciKlass* TypePtr::InterfaceSet::exact_klass() const {\n-  if (_exact_klass_computed) {\n-    return _exact_klass;\n-  }\n-  const_cast<InterfaceSet*>(this)->compute_exact_klass();\n-  assert(_exact_klass_computed, \"should be computed now\");\n-  return _exact_klass;\n-}\n-\n-void TypePtr::InterfaceSet::compute_exact_klass() {\n-  if (_list.length() == 0) {\n-    _exact_klass_computed = 1;\n-    _exact_klass = NULL;\n-    return;\n-  }\n-  ciKlass* res = NULL;\n-  for (int i = 0; i < _list.length(); i++) {\n-    ciKlass* interface = _list.at(i);\n-    if (eq(interfaces(interface, false, true, false, trust_interfaces))) {\n-      assert(res == NULL, \"\");\n-      res = _list.at(i);\n-    }\n-  }\n-  _exact_klass_computed = 1;\n-  _exact_klass = res;\n-}\n-\n-bool TypePtr::InterfaceSet::is_loaded() const {\n-  if (_is_loaded_computed) {\n-    return _is_loaded;\n-  }\n-  const_cast<InterfaceSet*>(this)->compute_is_loaded();\n-  assert(_is_loaded_computed, \"should be computed now\");\n-  return _is_loaded;\n-}\n-\n-void TypePtr::InterfaceSet::compute_is_loaded() {\n-  _is_loaded_computed = 1;\n-  for (int i = 0; i < _list.length(); i++) {\n-    ciKlass* interface = _list.at(i);\n-    if (!interface->is_loaded()) {\n-      _is_loaded = false;\n-      return;\n-    }\n-  }\n-  _is_loaded = true;\n-}\n-\n@@ -3337,1 +3171,1 @@\n-TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int offset,\n+TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,\n@@ -3341,1 +3175,0 @@\n-    _interfaces(interfaces),\n@@ -3389,1 +3222,1 @@\n-            _is_ptr_to_narrowoop = UseCompressedOops && ::is_reference_type(basic_elem_type);\n+            _is_ptr_to_narrowoop = UseCompressedOops && is_reference_type(basic_elem_type);\n@@ -3399,1 +3232,1 @@\n-            _is_ptr_to_narrowoop = UseCompressedOops && ::is_reference_type(basic_elem_type);\n+            _is_ptr_to_narrowoop = UseCompressedOops && is_reference_type(basic_elem_type);\n@@ -3422,1 +3255,1 @@\n-  return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, InterfaceSet(), xk, o, offset, instance_id, speculative, inline_depth))->hashcons();\n+  return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, instance_id, speculative, inline_depth))->hashcons();\n@@ -3535,1 +3368,1 @@\n-  return new TypeOopPtr(_base, dual_ptr(), klass(), _interfaces, klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n+  return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n@@ -3540,1 +3373,1 @@\n-const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact, InterfaceHandling interface_handling) {\n+const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {\n@@ -3567,2 +3400,1 @@\n-    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n-    return TypeInstPtr::make(TypePtr::BotPTR, klass, interfaces, klass_is_exact, NULL, 0);\n+    return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, 0);\n@@ -3571,2 +3403,1 @@\n-    ciKlass* eklass = klass->as_obj_array_klass()->element_klass();\n-    const TypeOopPtr *etype = TypeOopPtr::make_from_klass_common(eklass, try_for_exact, false, interface_handling);\n+    const TypeOopPtr *etype = TypeOopPtr::make_from_klass_common(klass->as_obj_array_klass()->element_klass(), false, try_for_exact);\n@@ -3578,1 +3409,1 @@\n-    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, NULL, xk, 0);\n+    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, 0);\n@@ -3612,1 +3443,1 @@\n-      TypeOopPtr::make_from_klass_raw(klass->as_obj_array_klass()->element_klass(), trust_interfaces);\n+      TypeOopPtr::make_from_klass_raw(klass->as_obj_array_klass()->element_klass());\n@@ -3670,0 +3501,21 @@\n+    \/\/ Check for evil case of 'this' being a class and 'kills' expecting an\n+    \/\/ interface.  This can happen because the bytecodes do not contain\n+    \/\/ enough type info to distinguish a Java-level interface variable\n+    \/\/ from a Java-level object variable.  If we meet 2 classes which\n+    \/\/ both implement interface I, but their meet is at 'j\/l\/O' which\n+    \/\/ doesn't implement I, we have no way to tell if the result should\n+    \/\/ be 'I' or 'j\/l\/O'.  Thus we'll pick 'j\/l\/O'.  If this then flows\n+    \/\/ into a Phi which \"knows\" it's an Interface type we'll have to\n+    \/\/ uplift the type.\n+    if (!empty()) {\n+      if (ktip != NULL && ktip->is_loaded() && ktip->klass()->is_interface()) {\n+        return kills;           \/\/ Uplift to interface\n+      }\n+      \/\/ Also check for evil cases of 'this' being a class array\n+      \/\/ and 'kills' expecting an array of interfaces.\n+      Type::get_arrays_base_elements(ft, kills, NULL, &ktip);\n+      if (ktip != NULL && ktip->is_loaded() && ktip->klass()->is_interface()) {\n+        return kills;           \/\/ Uplift to array of interface\n+      }\n+    }\n+\n@@ -3673,0 +3525,12 @@\n+  \/\/ If we have an interface-typed Phi or cast and we narrow to a class type,\n+  \/\/ the join should report back the class.  However, if we have a J\/L\/Object\n+  \/\/ class-typed Phi and an interface flows in, it's possible that the meet &\n+  \/\/ join report an interface back out.  This isn't possible but happens\n+  \/\/ because the type system doesn't interact well with interfaces.\n+  if (ftip != NULL && ktip != NULL &&\n+      ftip->is_loaded() &&  ftip->klass()->is_interface() &&\n+      ktip->is_loaded() && !ktip->klass()->is_interface()) {\n+    assert(!ftip->klass_is_exact(), \"interface could not be exact\");\n+    return ktip->cast_to_ptr_type(ftip->ptr());\n+  }\n+\n@@ -3731,1 +3595,1 @@\n-const TypePtr* TypeOopPtr::add_offset(intptr_t offset) const {\n+const TypePtr *TypeOopPtr::add_offset(intptr_t offset) const {\n@@ -3798,12 +3662,0 @@\n-\n-TypePtr::InterfaceSet TypeOopPtr::meet_interfaces(const TypeOopPtr* other) const {\n-  if (above_centerline(_ptr) && above_centerline(other->_ptr)) {\n-    return _interfaces.union_with(other->_interfaces);\n-  } else if (above_centerline(_ptr) && !above_centerline(other->_ptr)) {\n-    return other->_interfaces;\n-  } else if (above_centerline(other->_ptr) && !above_centerline(_ptr)) {\n-    return _interfaces;\n-  }\n-  return _interfaces.intersection_with(other->_interfaces);\n-}\n-\n@@ -3834,1 +3686,0 @@\n-\/\/ Is there a single ciKlass* that can represent that type?\n@@ -3836,12 +3687,1 @@\n-  if (_interfaces.empty()) {\n-    return _klass;\n-  }\n-  if (_klass != ciEnv::current()->Object_klass()) {\n-    ciKlass* k = _klass;\n-    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n-    if (_interfaces.eq(interfaces)) {\n-      return _klass;\n-    }\n-    return NULL;\n-  }\n-  return _interfaces.exact_klass();\n+  return _klass;\n@@ -3851,1 +3691,1 @@\n-TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int off,\n+TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int off,\n@@ -3853,5 +3693,4 @@\n-  : TypeOopPtr(InstPtr, ptr, k, interfaces, xk, o, off, instance_id, speculative, inline_depth) {\n-  assert(k == NULL || !k->is_loaded() || !k->is_interface(), \"no interface here\");\n-  assert(k != NULL &&\n-         (k->is_loaded() || o == NULL),\n-         \"cannot have constants with non-loaded klass\");\n+  : TypeOopPtr(InstPtr, ptr, k, xk, o, off, instance_id, speculative, inline_depth) {\n+   assert(k != NULL &&\n+          (k->is_loaded() || o == NULL),\n+          \"cannot have constants with non-loaded klass\");\n@@ -3863,1 +3702,0 @@\n-                                     const InterfaceSet& interfaces,\n@@ -3884,1 +3722,0 @@\n-    assert(!ik->is_interface(), \"no interface here\");\n@@ -3890,1 +3727,1 @@\n-    (TypeInstPtr*)(new TypeInstPtr(ptr, k, interfaces, xk, o ,offset, instance_id, speculative, inline_depth))->hashcons();\n+    (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o ,offset, instance_id, speculative, inline_depth))->hashcons();\n@@ -3895,33 +3732,0 @@\n-TypePtr::InterfaceSet TypePtr::interfaces(ciKlass*& k, bool klass, bool interface, bool array, InterfaceHandling interface_handling) {\n-  if (k->is_instance_klass()) {\n-    if (k->is_loaded()) {\n-      if (k->is_interface() && interface_handling == ignore_interfaces) {\n-        assert(interface, \"no interface expected\");\n-        k = ciEnv::current()->Object_klass();\n-        InterfaceSet interfaces;\n-        return interfaces;\n-      }\n-      GrowableArray<ciInstanceKlass *> *k_interfaces = k->as_instance_klass()->transitive_interfaces();\n-      InterfaceSet interfaces(k_interfaces);\n-      if (k->is_interface()) {\n-        assert(interface, \"no interface expected\");\n-        k = ciEnv::current()->Object_klass();\n-      } else {\n-        assert(klass, \"no instance klass expected\");\n-      }\n-      return interfaces;\n-    }\n-    InterfaceSet interfaces;\n-    return interfaces;\n-  }\n-  assert(array, \"no array expected\");\n-  assert(k->is_array_klass(), \"Not an array?\");\n-  ciType* e = k->as_array_klass()->base_element_type();\n-  if (e->is_loaded() && e->is_instance_klass() && e->as_instance_klass()->is_interface()) {\n-    if (interface_handling == ignore_interfaces) {\n-      k = ciObjArrayKlass::make(ciEnv::current()->Object_klass(), k->as_array_klass()->dimension());\n-    }\n-  }\n-  return *TypeAryPtr::_array_interfaces;\n-}\n-\n@@ -3956,1 +3760,1 @@\n-  return make(ptr, klass(), _interfaces, klass_is_exact(), ptr == Constant ? const_oop() : NULL, _offset, _instance_id, _speculative, _inline_depth);\n+  return make(ptr, klass(), klass_is_exact(), ptr == Constant ? const_oop() : NULL, _offset, _instance_id, _speculative, _inline_depth);\n@@ -3966,2 +3770,2 @@\n-  assert(!ik->is_interface(), \"no interface here\");\n-  return make(ptr(), klass(), _interfaces, klass_is_exact, const_oop(), _offset, _instance_id, _speculative, _inline_depth);\n+  if( ik->is_interface() )              return this;  \/\/ cannot set xk\n+  return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _instance_id, _speculative, _inline_depth);\n@@ -3973,1 +3777,1 @@\n-  return make(_ptr, klass(),  _interfaces, _klass_is_exact, const_oop(), _offset, instance_id, _speculative, _inline_depth);\n+  return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, instance_id, _speculative, _inline_depth);\n@@ -3979,33 +3783,6 @@\n-const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst, const InterfaceSet& interfaces) const {\n-  int off = meet_offset(tinst->offset());\n-  PTR ptr = meet_ptr(tinst->ptr());\n-  int instance_id = meet_instance_id(tinst->instance_id());\n-  const TypePtr* speculative = xmeet_speculative(tinst);\n-  int depth = meet_inline_depth(tinst->inline_depth());\n-\n-  const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;\n-  const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;\n-  if( loaded->klass()->equals(ciEnv::current()->Object_klass()) ) {\n-    \/\/\n-    \/\/ Meet unloaded class with java\/lang\/Object\n-    \/\/\n-    \/\/ Meet\n-    \/\/          |                     Unloaded Class\n-    \/\/  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |\n-    \/\/  ===================================================================\n-    \/\/   TOP    | ..........................Unloaded......................|\n-    \/\/  AnyNull |  U-AN    |................Unloaded......................|\n-    \/\/ Constant | ... O-NN .................................. |   O-BOT   |\n-    \/\/  NotNull | ... O-NN .................................. |   O-BOT   |\n-    \/\/  BOTTOM  | ........................Object-BOTTOM ..................|\n-    \/\/\n-    assert(loaded->ptr() != TypePtr::Null, \"insanity check\");\n-    \/\/\n-    if (loaded->ptr() == TypePtr::TopPTR)        { return unloaded; }\n-    else if (loaded->ptr() == TypePtr::AnyNull)  { return make(ptr, unloaded->klass(), interfaces, false, NULL, off, instance_id, speculative, depth); }\n-    else if (loaded->ptr() == TypePtr::BotPTR)   { return TypeInstPtr::BOTTOM; }\n-    else if (loaded->ptr() == TypePtr::Constant || loaded->ptr() == TypePtr::NotNull) {\n-      if (unloaded->ptr() == TypePtr::BotPTR)    { return TypeInstPtr::BOTTOM;  }\n-      else                                       { return TypeInstPtr::NOTNULL; }\n-    }\n-    else if (unloaded->ptr() == TypePtr::TopPTR) { return unloaded; }\n+const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {\n+    int off = meet_offset(tinst->offset());\n+    PTR ptr = meet_ptr(tinst->ptr());\n+    int instance_id = meet_instance_id(tinst->instance_id());\n+    const TypePtr* speculative = xmeet_speculative(tinst);\n+    int depth = meet_inline_depth(tinst->inline_depth());\n@@ -4013,2 +3790,26 @@\n-    return unloaded->cast_to_ptr_type(TypePtr::AnyNull)->is_instptr();\n-  }\n+    const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;\n+    const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;\n+    if( loaded->klass()->equals(ciEnv::current()->Object_klass()) ) {\n+      \/\/\n+      \/\/ Meet unloaded class with java\/lang\/Object\n+      \/\/\n+      \/\/ Meet\n+      \/\/          |                     Unloaded Class\n+      \/\/  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |\n+      \/\/  ===================================================================\n+      \/\/   TOP    | ..........................Unloaded......................|\n+      \/\/  AnyNull |  U-AN    |................Unloaded......................|\n+      \/\/ Constant | ... O-NN .................................. |   O-BOT   |\n+      \/\/  NotNull | ... O-NN .................................. |   O-BOT   |\n+      \/\/  BOTTOM  | ........................Object-BOTTOM ..................|\n+      \/\/\n+      assert(loaded->ptr() != TypePtr::Null, \"insanity check\");\n+      \/\/\n+      if(      loaded->ptr() == TypePtr::TopPTR ) { return unloaded; }\n+      else if (loaded->ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded->klass(), false, NULL, off, instance_id, speculative, depth); }\n+      else if (loaded->ptr() == TypePtr::BotPTR ) { return TypeInstPtr::BOTTOM; }\n+      else if (loaded->ptr() == TypePtr::Constant || loaded->ptr() == TypePtr::NotNull) {\n+        if (unloaded->ptr() == TypePtr::BotPTR  ) { return TypeInstPtr::BOTTOM;  }\n+        else                                      { return TypeInstPtr::NOTNULL; }\n+      }\n+      else if( unloaded->ptr() == TypePtr::TopPTR )  { return unloaded; }\n@@ -4016,6 +3817,9 @@\n-  \/\/ Both are unloaded, not the same class, not Object\n-  \/\/ Or meet unloaded with a different loaded class, not java\/lang\/Object\n-  if (ptr != TypePtr::BotPTR) {\n-    return TypeInstPtr::NOTNULL;\n-  }\n-  return TypeInstPtr::BOTTOM;\n+      return unloaded->cast_to_ptr_type(TypePtr::AnyNull)->is_instptr();\n+    }\n+\n+    \/\/ Both are unloaded, not the same class, not Object\n+    \/\/ Or meet unloaded with a different loaded class, not java\/lang\/Object\n+    if( ptr != TypePtr::BotPTR ) {\n+      return TypeInstPtr::NOTNULL;\n+    }\n+    return TypeInstPtr::BOTTOM;\n@@ -4074,1 +3878,1 @@\n-      return make(ptr, klass(), _interfaces, klass_is_exact(),\n+      return make(ptr, klass(), klass_is_exact(),\n@@ -4102,1 +3906,1 @@\n-      return make(ptr, klass(), _interfaces, klass_is_exact(),\n+      return make(ptr, klass(), klass_is_exact(),\n@@ -4136,2 +3940,0 @@\n-    InterfaceSet interfaces = meet_interfaces(tinst);\n-\n@@ -4140,0 +3942,2 @@\n+    bool tinst_xk = tinst->klass_is_exact();\n+    bool this_xk  = klass_is_exact();\n@@ -4144,2 +3948,1 @@\n-    MeetResult kind = meet_instptr(ptr, interfaces, this, tinst, res_klass, res_xk);\n-\n+    MeetResult kind = meet_instptr(ptr, this_klass, tinst_klass, this_xk, tinst_xk, this->_ptr, tinst->_ptr, res_klass, res_xk);\n@@ -4148,1 +3951,1 @@\n-      const TypeInstPtr* unloaded_meet = xmeet_unloaded(tinst, interfaces);\n+      const TypeInstPtr* unloaded_meet = xmeet_unloaded(tinst);\n@@ -4185,1 +3988,1 @@\n-      res = make(ptr, res_klass, interfaces, res_xk, o, off, instance_id, speculative, depth);\n+      res = make(ptr, res_klass, res_xk, o, off, instance_id, speculative, depth);\n@@ -4196,10 +3999,4 @@\n-template<class T> TypePtr::MeetResult TypePtr::meet_instptr(PTR& ptr, InterfaceSet& interfaces, const T* this_type, const T* other_type,\n-                      ciKlass*& res_klass, bool& res_xk) {\n-  ciKlass* this_klass = this_type->klass();\n-  ciKlass* other_klass = other_type->klass();\n-  bool this_xk = this_type->klass_is_exact();\n-  bool other_xk = other_type->klass_is_exact();\n-  PTR this_ptr = this_type->ptr();\n-  PTR other_ptr = other_type->ptr();\n-  InterfaceSet this_interfaces = this_type->interfaces();\n-  InterfaceSet other_interfaces = other_type->interfaces();\n+TypePtr::MeetResult TypePtr::meet_instptr(PTR &ptr, ciKlass* this_klass, ciKlass* tinst_klass, bool this_xk, bool tinst_xk,\n+                                          PTR this_ptr,\n+                                          PTR tinst_ptr, ciKlass*&res_klass, bool &res_xk) {\n+\n@@ -4210,1 +4007,1 @@\n-  if (ptr != Constant && this_klass->equals(other_klass) && this_xk == other_xk) {\n+  if (ptr != Constant && this_klass->equals(tinst_klass) && this_xk == tinst_xk) {\n@@ -4217,1 +4014,1 @@\n-  if (!other_klass->is_loaded() || !this_klass->is_loaded()) {\n+  if (!tinst_klass->is_loaded() || !this_klass->is_loaded()) {\n@@ -4221,0 +4018,41 @@\n+  \/\/ Handle mixing oops and interfaces first.\n+  if (this_klass->is_interface() && !(tinst_klass->is_interface() ||\n+                                      tinst_klass == ciEnv::current()->Object_klass())) {\n+    ciKlass *tmp = tinst_klass; \/\/ Swap interface around\n+    tinst_klass = this_klass;\n+    this_klass = tmp;\n+    bool tmp2 = tinst_xk;\n+    tinst_xk = this_xk;\n+    this_xk = tmp2;\n+  }\n+  if (tinst_klass->is_interface() &&\n+      !(this_klass->is_interface() ||\n+        \/\/ Treat java\/lang\/Object as an honorary interface,\n+        \/\/ because we need a bottom for the interface hierarchy.\n+        this_klass == ciEnv::current()->Object_klass())) {\n+    \/\/ Oop meets interface!\n+\n+    \/\/ See if the oop subtypes (implements) interface.\n+    if (this_klass->is_subtype_of(tinst_klass)) {\n+      \/\/ Oop indeed subtypes.  Now keep oop or interface depending\n+      \/\/ on whether we are both above the centerline or either is\n+      \/\/ below the centerline.  If we are on the centerline\n+      \/\/ (e.g., Constant vs. AnyNull interface), use the constant.\n+      res_klass  = below_centerline(ptr) ? tinst_klass : this_klass;\n+      \/\/ If we are keeping this_klass, keep its exactness too.\n+      res_xk = below_centerline(ptr) ? tinst_xk    : this_xk;\n+      return SUBTYPE;\n+    } else {                  \/\/ Does not implement, fall to Object\n+      \/\/ Oop does not implement interface, so mixing falls to Object\n+      \/\/ just like the verifier does (if both are above the\n+      \/\/ centerline fall to interface)\n+      res_klass = above_centerline(ptr) ? tinst_klass : ciEnv::current()->Object_klass();\n+      res_xk = above_centerline(ptr) ? tinst_xk : false;\n+      \/\/ Watch out for Constant vs. AnyNull interface.\n+      if (ptr == Constant)  ptr = NotNull;   \/\/ forget it was a constant\n+      return NOT_SUBTYPE;\n+    }\n+  }\n+\n+  \/\/ Either oop vs oop or interface vs interface or interface vs Object\n+\n@@ -4246,1 +4084,1 @@\n-  const T* subtype = NULL;\n+  ciKlass *subtype = NULL;\n@@ -4248,7 +4086,5 @@\n-  InterfaceSet subtype_interfaces;\n-\n-  if (this_type->is_same_java_type_as(other_type)) {\n-    subtype = this_type;\n-    subtype_exact = below_centerline(ptr) ? (this_xk && other_xk) : (this_xk || other_xk);\n-  } else if (!other_xk && this_type->is_meet_subtype_of(other_type)) {\n-    subtype = this_type;     \/\/ Pick subtyping class\n+  if (tinst_klass->equals(this_klass)) {\n+    subtype = this_klass;\n+    subtype_exact = below_centerline(ptr) ? (this_xk && tinst_xk) : (this_xk || tinst_xk);\n+  } else if (!tinst_xk && this_klass->is_subtype_of(tinst_klass)) {\n+    subtype = this_klass;     \/\/ Pick subtyping class\n@@ -4256,3 +4092,3 @@\n-  } else if(!this_xk && other_type->is_meet_subtype_of(this_type)) {\n-    subtype = other_type;    \/\/ Pick subtyping class\n-    subtype_exact = other_xk;\n+  } else if (!this_xk && tinst_klass->is_subtype_of(this_klass)) {\n+    subtype = tinst_klass;    \/\/ Pick subtyping class\n+    subtype_exact = tinst_xk;\n@@ -4263,8 +4099,8 @@\n-      this_type = other_type = subtype;\n-      this_xk = other_xk = subtype_exact;\n-    } else if (above_centerline(this_ptr) && !above_centerline(other_ptr)) {\n-      this_type = other_type; \/\/ tinst is down; keep down man\n-      this_xk = other_xk;\n-    } else if (above_centerline(other_ptr) && !above_centerline(this_ptr)) {\n-      other_type = this_type; \/\/ this is down; keep down man\n-      other_xk = this_xk;\n+      this_klass = tinst_klass = subtype;\n+      this_xk = tinst_xk = subtype_exact;\n+    } else if (above_centerline(this_ptr) && !above_centerline(tinst_ptr)) {\n+      this_klass = tinst_klass; \/\/ tinst is down; keep down man\n+      this_xk = tinst_xk;\n+    } else if (above_centerline(tinst_ptr) && !above_centerline(this_ptr)) {\n+      tinst_klass = this_klass; \/\/ this is down; keep down man\n+      tinst_xk = this_xk;\n@@ -4277,1 +4113,1 @@\n-  if (this_type->is_same_java_type_as(other_type)) {\n+  if (tinst_klass->equals(this_klass)) {\n@@ -4281,1 +4117,1 @@\n-    res_klass = this_type->klass();\n+    res_klass = this_klass;\n@@ -4292,2 +4128,0 @@\n-  interfaces = this_interfaces.intersection_with(other_interfaces);\n-\n@@ -4295,1 +4129,1 @@\n-  ciKlass* k = this_klass->least_common_ancestor(other_klass);\n+  ciKlass* k = this_klass->least_common_ancestor(tinst_klass);\n@@ -4303,0 +4137,1 @@\n+\n@@ -4319,1 +4154,1 @@\n-  return new TypeInstPtr(dual_ptr(), klass(), _interfaces, klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n+  return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n@@ -4328,1 +4163,0 @@\n-    _interfaces.eq(p->_interfaces) &&\n@@ -4335,1 +4169,1 @@\n-  int hash = java_add(java_add((jint)klass()->hash(), (jint)TypeOopPtr::hash()), _interfaces.hash());\n+  int hash = java_add((jint)klass()->hash(), (jint)TypeOopPtr::hash());\n@@ -4340,2 +4174,14 @@\n-  return TypePtr::is_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n-}\n+  if (!is_loaded() || !other->is_loaded()) {\n+    return false;\n+  }\n+  if (!other->isa_instptr()) {\n+    return false;\n+  }\n+\n+  if (!other_exact) {\n+    return false;\n+  }\n+\n+  if (other->klass()->equals(ciEnv::current()->Object_klass())) {\n+    return true;\n+  }\n@@ -4343,0 +4189,3 @@\n+  if (!this_exact && klass()->is_interface()) {\n+    return false;\n+  }\n@@ -4344,2 +4193,11 @@\n-bool TypeInstPtr::is_same_java_type_as_helper(const TypeOopPtr* other) const {\n-  return TypePtr::is_same_java_type_as_helper_for_instance(this, other);\n+  return _klass->is_subtype_of(other->klass());\n+}\n+\n+bool TypeInstPtr::is_same_java_type_as(const TypeOopPtr* other) const {\n+  if (!is_loaded() || !other->is_loaded()) {\n+    return false;\n+  }\n+  if (!other->isa_instptr()) {\n+    return false;\n+  }\n+  return _klass->equals(other->_klass);\n@@ -4349,1 +4207,27 @@\n-  return TypePtr::maybe_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n+  if (!is_loaded() || !other->is_loaded()) {\n+    return true;\n+  }\n+\n+  if (other->isa_aryptr()) {\n+    return !this_exact && (_klass->equals(ciEnv::current()->Object_klass()) || _klass->is_interface());\n+  }\n+\n+  if ((_klass->is_interface() && !this_exact) || (other->klass()->is_interface() \/*&& !other_exact*\/)) {\n+    return true;\n+  }\n+\n+  assert(other->isa_instptr(), \"unsupported\");\n+\n+  if (this_exact && other_exact) {\n+    return is_java_subtype_of(other);\n+  }\n+\n+  if (!_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(_klass)) {\n+    return false;\n+  }\n+\n+  if (this_exact) {\n+    return _klass->is_subtype_of(other->_klass);\n+  }\n+\n+  return true;\n@@ -4359,1 +4243,0 @@\n-  _interfaces.dump(st);\n@@ -4409,1 +4292,1 @@\n-  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), xadd_offset(offset),\n+  return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset),\n@@ -4414,1 +4297,1 @@\n-  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), offset,\n+  return make(_ptr, klass(), klass_is_exact(), const_oop(), offset,\n@@ -4423,1 +4306,1 @@\n-  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset,\n+  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset,\n@@ -4427,1 +4310,1 @@\n-const TypePtr* TypeInstPtr::with_inline_depth(int depth) const {\n+const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {\n@@ -4431,1 +4314,1 @@\n-  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, depth);\n+  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, depth);\n@@ -4434,1 +4317,1 @@\n-const TypePtr* TypeInstPtr::with_instance_id(int instance_id) const {\n+const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {\n@@ -4436,1 +4319,1 @@\n-  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, instance_id, _speculative, _inline_depth);\n+  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, instance_id, _speculative, _inline_depth);\n@@ -4442,59 +4325,5 @@\n-  if (try_for_exact && !xk && !ik->has_subklass() && !ik->is_final()) {\n-    ciKlass* k = ik;\n-    TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n-    assert(k == ik, \"\");\n-    if (interfaces.eq(_interfaces)) {\n-      Compile *C = Compile::current();\n-      Dependencies* deps = C->dependencies();\n-      deps->assert_leaf_type(ik);\n-      xk = true;\n-    }\n-  }\n-  return TypeInstKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, klass(), _interfaces, 0);\n-}\n-\n-template <class T1, class T2> bool TypePtr::is_meet_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_xk, bool other_xk) {\n-  static_assert(std::is_base_of<T2, T1>::value, \"\");\n-\n-  if (!this_one->is_instance_type(other)) {\n-    return false;\n-  }\n-\n-  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty()) {\n-    return true;\n-  }\n-\n-  return this_one->klass()->is_subtype_of(other->klass()) &&\n-         (!this_xk || this_one->_interfaces.contains(other->_interfaces));\n-}\n-\n-\n-bool TypeInstPtr::is_meet_subtype_of_helper(const TypeOopPtr *other, bool this_xk, bool other_xk) const {\n-  return TypePtr::is_meet_subtype_of_helper_for_instance(this, other, this_xk, other_xk);\n-}\n-\n-template <class T1, class T2>  bool TypePtr::is_meet_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_xk, bool other_xk) {\n-  static_assert(std::is_base_of<T2, T1>::value, \"\");\n-  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty()) {\n-    return true;\n-  }\n-\n-  if (this_one->is_instance_type(other)) {\n-    return other->klass() == ciEnv::current()->Object_klass() && this_one->_interfaces.contains(other->_interfaces);\n-  }\n-\n-  int dummy;\n-  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n-  if (this_top_or_bottom) {\n-    return false;\n-  }\n-\n-  const T1* other_ary = this_one->is_array_type(other);\n-  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n-  const TypePtr* this_elem = this_one->elem()->make_ptr();\n-  if (other_elem != NULL && this_elem != NULL) {\n-    return this_one->is_reference_type(this_elem)->is_meet_subtype_of_helper(this_one->is_reference_type(other_elem), this_xk, other_xk);\n-  }\n-\n-  if (other_elem == NULL && this_elem == NULL) {\n-    return this_one->_klass->is_subtype_of(other->_klass);\n+  if (try_for_exact && !xk && !ik->has_subklass() && !ik->is_final() && !ik->is_interface()) {\n+    Compile* C = Compile::current();\n+    Dependencies* deps = C->dependencies();\n+    deps->assert_leaf_type(ik);\n+    xk = true;\n@@ -4502,14 +4331,1 @@\n-\n-  return false;\n-}\n-\n-bool TypeAryPtr::is_meet_subtype_of_helper(const TypeOopPtr *other, bool this_xk, bool other_xk) const {\n-  return TypePtr::is_meet_subtype_of_helper_for_array(this, other, this_xk, other_xk);\n-}\n-\n-bool TypeInstKlassPtr::is_meet_subtype_of_helper(const TypeKlassPtr *other, bool this_xk, bool other_xk) const {\n-  return TypePtr::is_meet_subtype_of_helper_for_instance(this, other, this_xk, other_xk);\n-}\n-\n-bool TypeAryKlassPtr::is_meet_subtype_of_helper(const TypeKlassPtr *other, bool this_xk, bool other_xk) const {\n-  return TypePtr::is_meet_subtype_of_helper_for_array(this, other, this_xk, other_xk);\n+  return TypeInstKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, klass(), 0);\n@@ -4538,4 +4354,0 @@\n-  if (k != NULL && k->is_loaded() && k->is_obj_array_klass() &&\n-      k->as_obj_array_klass()->base_element_klass()->is_interface()) {\n-    k = NULL;\n-  }\n@@ -4554,4 +4366,0 @@\n-  if (k != NULL && k->is_loaded() && k->is_obj_array_klass() &&\n-      k->as_obj_array_klass()->base_element_klass()->is_interface()) {\n-    k = NULL;\n-  }\n@@ -4585,1 +4393,1 @@\n-  if (!is_java_primitive(etype) && !::is_reference_type(etype)) {\n+  if (!is_java_primitive(etype) && !is_reference_type(etype)) {\n@@ -4693,1 +4501,22 @@\n-  return TypePtr::is_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n+  if (other->klass() == ciEnv::current()->Object_klass() && other_exact) {\n+    return true;\n+  }\n+\n+  if (!is_loaded() || !other->is_loaded() || other->klass() == NULL || klass() == NULL) {\n+    return false;\n+  }\n+  if (other->isa_instptr()) {\n+    return _klass->is_subtype_of(other->_klass) && other_exact;\n+  }\n+  if (klass() == NULL) {\n+    return false;\n+  }\n+  assert(other->isa_aryptr(), \"\");\n+  const TypeAryPtr* other_ary = other->isa_aryptr();\n+  if (other_ary->elem()->make_oopptr() && elem()->make_oopptr()) {\n+    return elem()->make_oopptr()->is_java_subtype_of_helper(other_ary->elem()->make_oopptr(), this_exact, other_exact);\n+  }\n+  if (!other_ary->elem()->make_oopptr() && !elem()->make_oopptr()) {\n+    return _klass->is_subtype_of(other->_klass);\n+  }\n+  return false;\n@@ -4696,2 +4525,13 @@\n-bool TypeAryPtr::is_same_java_type_as_helper(const TypeOopPtr* other) const {\n-  return TypePtr::is_same_java_type_as_helper_for_array(this, other);\n+bool TypeAryPtr::is_same_java_type_as(const TypeOopPtr* other) const {\n+  if (!other->isa_aryptr() ||\n+      !is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n+    return false;\n+  }\n+  const TypeAryPtr* other_ary = other->isa_aryptr();\n+  if (other_ary->elem()->make_oopptr() && elem()->make_oopptr()) {\n+    return elem()->make_oopptr()->is_same_java_type_as(other_ary->elem()->make_oopptr());\n+  }\n+  if (!other_ary->elem()->make_oopptr() && !elem()->make_oopptr()) {\n+    return _klass->equals(other->_klass);\n+  }\n+  return false;\n@@ -4701,1 +4541,25 @@\n-  return TypePtr::maybe_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n+  if (other->klass() == ciEnv::current()->Object_klass()) {\n+    return true;\n+  }\n+\n+  if (!is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n+    return true;\n+  }\n+  if (other->isa_instptr()) {\n+    return (!other_exact && other->_klass->is_interface()) || _klass->is_subtype_of(other->_klass);\n+  }\n+  assert(other->isa_aryptr(), \"\");\n+\n+  if (this_exact && other_exact) {\n+    return is_java_subtype_of(other);\n+  }\n+\n+  const TypeAryPtr* other_ary = other->isa_aryptr();\n+  if (other_ary->elem()->make_oopptr() && elem()->make_oopptr()) {\n+    return elem()->make_oopptr()->maybe_java_subtype_of_helper(other_ary->elem()->make_oopptr(), this_exact,\n+                                                               other_exact);\n+  }\n+  if (!other_ary->elem()->make_oopptr() && !elem()->make_oopptr()) {\n+    return _klass->is_subtype_of(other->_klass);\n+  }\n+  return false;\n@@ -4796,1 +4660,1 @@\n-    if (meet_aryptr(ptr, elem, this, tap, res_klass, res_xk) == NOT_SUBTYPE) {\n+    if (meet_aryptr(ptr, elem, this->klass(), tap->klass(), this->klass_is_exact(), tap->klass_is_exact(), this->ptr(), tap->ptr(), res_klass, res_xk) == NOT_SUBTYPE) {\n@@ -4826,4 +4690,0 @@\n-    InterfaceSet interfaces = meet_interfaces(tp);\n-    InterfaceSet tp_interfaces = tp->_interfaces;\n-    InterfaceSet this_interfaces = _interfaces;\n-\n@@ -4836,2 +4696,2 @@\n-      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.contains(tp_interfaces) && !tp->klass_is_exact()) {\n-        return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);\n+      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n+        return make(ptr, _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);\n@@ -4842,2 +4702,1 @@\n-        interfaces = this_interfaces.intersection_with(tp_interfaces);\n-        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, false, NULL,offset, instance_id, speculative, depth);\n+        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, NULL,offset, instance_id, speculative, depth);\n@@ -4855,1 +4714,1 @@\n-        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.contains(tp_interfaces) && !tp->klass_is_exact()) {\n+        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n@@ -4869,2 +4728,1 @@\n-      interfaces = this_interfaces.intersection_with(tp_interfaces);\n-      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, false, NULL, offset, instance_id, speculative, depth);\n+      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, NULL, offset, instance_id, speculative, depth);\n@@ -4879,8 +4737,1 @@\n-template<class T> TypePtr::MeetResult TypePtr::meet_aryptr(PTR& ptr, const Type*& elem, const T* this_ary,\n-                                                           const T* other_ary, ciKlass*& res_klass, bool& res_xk) {\n-  ciKlass* this_klass = this_ary->klass();\n-  ciKlass* other_klass = other_ary->klass();\n-  bool this_xk = this_ary->klass_is_exact();\n-  bool other_xk = other_ary->klass_is_exact();\n-  PTR this_ptr = this_ary->ptr();\n-  PTR other_ptr = other_ary->ptr();\n+TypePtr::MeetResult TypePtr::meet_aryptr(PTR& ptr, const Type*& elem, ciKlass* this_klass, ciKlass* tap_klass, bool this_xk, bool tap_xk, PTR this_ptr, PTR tap_ptr, ciKlass*& res_klass, bool& res_xk) {\n@@ -4893,2 +4744,2 @@\n-      res_klass = other_klass;\n-    else if (other_klass == NULL || other_klass == this_klass) {\n+      res_klass = tap_klass;\n+    else if (tap_klass == NULL || tap_klass == this_klass) {\n@@ -4903,1 +4754,1 @@\n-  } else {\/\/ Non integral arrays.\n+  } else \/\/ Non integral arrays.\n@@ -4906,4 +4757,1 @@\n-    int dummy;\n-    bool this_top_or_bottom = (this_ary->base_element_type(dummy) == Type::TOP || this_ary->base_element_type(dummy) == Type::BOTTOM);\n-    bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n-    if ((above_centerline(ptr) || ptr == Constant) && !this_ary->is_same_java_type_as(other_ary) &&\n+    if ((above_centerline(ptr) || ptr == Constant) && this_klass != tap_klass &&\n@@ -4911,1 +4759,1 @@\n-        !this_top_or_bottom && !other_top_or_bottom &&\n+        tap_klass != NULL  && this_klass != NULL   &&\n@@ -4913,1 +4761,1 @@\n-        ((other_xk && this_xk) ||\n+        ((tap_xk && this_xk) ||\n@@ -4915,1 +4763,1 @@\n-         (other_xk && !other_ary->is_meet_subtype_of(this_ary)) ||\n+         (tap_xk && !tap_klass->is_subtype_of(this_klass)) ||\n@@ -4917,1 +4765,1 @@\n-         (this_xk && !this_ary->is_meet_subtype_of(other_ary)))) {\n+         (this_xk && !this_klass->is_subtype_of(tap_klass)))) {\n@@ -4925,1 +4773,0 @@\n-  }\n@@ -4928,1 +4775,1 @@\n-  switch (other_ptr) {\n+  switch (tap_ptr) {\n@@ -4935,1 +4782,1 @@\n-        res_xk = (other_xk || this_xk);\n+        res_xk = (tap_xk || this_xk);\n@@ -4945,1 +4792,1 @@\n-        res_xk = this_xk && this_ary->is_same_java_type_as(other_ary);\n+        res_xk = this_xk && (this_klass == tap_klass);\n@@ -4953,1 +4800,1 @@\n-        res_xk = other_xk;\n+        res_xk = tap_xk;\n@@ -4955,2 +4802,2 @@\n-        res_xk = (other_xk && this_xk) &&\n-                 (this_ary->is_same_java_type_as(other_ary)); \/\/ Only precise for identical arrays\n+        res_xk = (tap_xk && this_xk) &&\n+          (this_klass == tap_klass); \/\/ Only precise for identical arrays\n@@ -4974,0 +4821,11 @@\n+\/\/----------------------interface_vs_oop---------------------------------------\n+#ifdef ASSERT\n+bool TypeAryPtr::interface_vs_oop(const Type *t) const {\n+  const TypeAryPtr* t_aryptr = t->isa_aryptr();\n+  if (t_aryptr) {\n+    return _ary->interface_vs_oop(t_aryptr->_ary);\n+  }\n+  return false;\n+}\n+#endif\n+\n@@ -4978,2 +4836,0 @@\n-  _interfaces.dump(st);\n-\n@@ -5032,1 +4888,1 @@\n-const TypePtr* TypeAryPtr::add_offset(intptr_t offset) const {\n+const TypePtr *TypeAryPtr::add_offset(intptr_t offset) const {\n@@ -5052,1 +4908,1 @@\n-const TypePtr* TypeAryPtr::with_inline_depth(int depth) const {\n+const TypePtr *TypeAryPtr::with_inline_depth(int depth) const {\n@@ -5059,1 +4915,1 @@\n-const TypePtr* TypeAryPtr::with_instance_id(int instance_id) const {\n+const TypePtr *TypeAryPtr::with_instance_id(int instance_id) const {\n@@ -5244,1 +5100,1 @@\n-const TypePtr* TypeMetadataPtr::add_offset( intptr_t offset ) const {\n+const TypePtr *TypeMetadataPtr::add_offset( intptr_t offset ) const {\n@@ -5419,1 +5275,1 @@\n-const TypeKlassPtr* TypeKlassPtr::make(ciKlass *klass, InterfaceHandling interface_handling) {\n+const TypeKlassPtr* TypeKlassPtr::make(ciKlass *klass) {\n@@ -5421,1 +5277,1 @@\n-    return TypeInstKlassPtr::make(klass, interface_handling);\n+    return TypeInstKlassPtr::make(klass);\n@@ -5423,1 +5279,1 @@\n-  return TypeAryKlassPtr::make(klass, interface_handling);\n+  return TypeAryKlassPtr::make(klass);\n@@ -5426,1 +5282,1 @@\n-const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* klass, int offset, InterfaceHandling interface_handling) {\n+const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* klass, int offset) {\n@@ -5428,2 +5284,1 @@\n-    const InterfaceSet interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n-    return TypeInstKlassPtr::make(ptr, klass, interfaces, offset);\n+    return TypeInstKlassPtr::make(ptr, klass, offset);\n@@ -5431,1 +5286,1 @@\n-  return TypeAryKlassPtr::make(ptr, klass, offset, interface_handling);\n+  return TypeAryKlassPtr::make(ptr, klass, offset);\n@@ -5436,4 +5291,2 @@\n-TypeKlassPtr::TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, const InterfaceSet& interfaces, int offset)\n-  : TypePtr(t, ptr, offset), _klass(klass), _interfaces(interfaces) {\n-  assert(klass == NULL || !klass->is_loaded() || (klass->is_instance_klass() && !klass->is_interface()) ||\n-         klass->is_type_array_klass() || !klass->as_obj_array_klass()->base_element_klass()->is_interface(), \"no interface here\");\n+TypeKlassPtr::TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, int offset)\n+  : TypePtr(t, ptr, offset), _klass(klass) {\n@@ -5442,1 +5295,0 @@\n-\/\/ Is there a single ciKlass* that can represent that type?\n@@ -5444,12 +5296,1 @@\n-  assert(_klass->is_instance_klass() && !_klass->is_interface(), \"No interface\");\n-  if (_interfaces.empty()) {\n-    return _klass;\n-  }\n-  if (_klass != ciEnv::current()->Object_klass()) {\n-    ciKlass* k = _klass;\n-    if (_interfaces.eq(TypePtr::interfaces(k, true, false, true, ignore_interfaces))) {\n-      return _klass;\n-    }\n-    return NULL;\n-  }\n-  return _interfaces.exact_klass();\n+  return _klass;\n@@ -5463,1 +5304,0 @@\n-    _interfaces.eq(p->_interfaces) &&\n@@ -5470,1 +5310,1 @@\n-  return java_add((jint)TypePtr::hash(), _interfaces.hash());\n+  return TypePtr::hash();\n@@ -5491,0 +5331,3 @@\n+    if (!empty() && ktkp != NULL && ktkp->klass()->is_loaded() && ktkp->klass()->is_interface())\n+      return kills;             \/\/ Uplift to interface\n+\n@@ -5494,10 +5337,7 @@\n-  return ft;\n-}\n-\n-TypePtr::InterfaceSet TypeKlassPtr::meet_interfaces(const TypeKlassPtr* other) const {\n-  if (above_centerline(_ptr) && above_centerline(other->_ptr)) {\n-    return _interfaces.union_with(other->_interfaces);\n-  } else if (above_centerline(_ptr) && !above_centerline(other->_ptr)) {\n-    return other->_interfaces;\n-  } else if (above_centerline(other->_ptr) && !above_centerline(_ptr)) {\n-    return _interfaces;\n+  \/\/ Interface klass type could be exact in opposite to interface type,\n+  \/\/ return it here instead of incorrect Constant ptr J\/L\/Object (6894807).\n+  if (ftkp != NULL && ktkp != NULL &&\n+      ftkp->is_loaded() &&  ftkp->klass()->is_interface() &&\n+      !ftkp->klass_is_exact() && \/\/ Keep exact interface klass\n+      ktkp->is_loaded() && !ktkp->klass()->is_interface()) {\n+    return ktkp->cast_to_ptr_type(ftkp->ptr());\n@@ -5505,1 +5345,2 @@\n-  return _interfaces.intersection_with(other->_interfaces);\n+\n+  return ft;\n@@ -5545,1 +5386,0 @@\n-      _interfaces.dump(st);\n@@ -5586,1 +5426,1 @@\n-const TypeInstKlassPtr *TypeInstKlassPtr::make(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, int offset) {\n+const TypeInstKlassPtr *TypeInstKlassPtr::make(PTR ptr, ciKlass* k, int offset) {\n@@ -5588,1 +5428,1 @@\n-    (TypeInstKlassPtr*)(new TypeInstKlassPtr(ptr, k, interfaces, offset))->hashcons();\n+    (TypeInstKlassPtr*)(new TypeInstKlassPtr(ptr, k, offset))->hashcons();\n@@ -5595,2 +5435,2 @@\n-const TypePtr* TypeInstKlassPtr::add_offset( intptr_t offset ) const {\n-  return make( _ptr, klass(), _interfaces, xadd_offset(offset) );\n+const TypePtr *TypeInstKlassPtr::add_offset( intptr_t offset ) const {\n+  return make( _ptr, klass(), xadd_offset(offset) );\n@@ -5600,1 +5440,1 @@\n-  return make(_ptr, klass(), _interfaces, offset);\n+  return make(_ptr, klass(), offset);\n@@ -5607,1 +5447,1 @@\n-  return make(ptr, _klass, _interfaces, _offset);\n+  return make(ptr, _klass, _offset);\n@@ -5623,1 +5463,1 @@\n-  return make(klass_is_exact ? Constant : NotNull, k, _interfaces, _offset);\n+  return make(klass_is_exact ? Constant : NotNull, k, _offset);\n@@ -5638,1 +5478,0 @@\n-  TypePtr::InterfaceSet interfaces = _interfaces;\n@@ -5647,8 +5486,3 @@\n-        ciKlass* sub_k = sub;\n-        TypePtr::InterfaceSet sub_interfaces = TypePtr::interfaces(sub_k, true, false, false, ignore_interfaces);\n-        assert(sub_k == sub, \"\");\n-        if (sub_interfaces.eq(_interfaces)) {\n-          deps->assert_abstract_with_unique_concrete_subtype(ik, sub);\n-          k = ik = sub;\n-          xk = sub->is_final();\n-        }\n+        deps->assert_abstract_with_unique_concrete_subtype(ik, sub);\n+        k = ik = sub;\n+        xk = sub->is_final();\n@@ -5658,1 +5492,1 @@\n-  return TypeInstPtr::make(TypePtr::BotPTR, k, interfaces, xk, NULL, 0);\n+  return TypeInstPtr::make(TypePtr::BotPTR, k, xk, NULL, 0);\n@@ -5699,1 +5533,1 @@\n-      return make( ptr, klass(), _interfaces, offset );\n+      return make( ptr, klass(), offset );\n@@ -5734,1 +5568,4 @@\n-    InterfaceSet interfaces = meet_interfaces(tkls);\n+    ciKlass* tkls_klass = tkls->klass();\n+    ciKlass* this_klass  = klass();\n+    bool tkls_xk = tkls->klass_is_exact();\n+    bool this_xk  = klass_is_exact();\n@@ -5738,1 +5575,1 @@\n-    switch(meet_instptr(ptr, interfaces, this, tkls, res_klass, res_xk)) {\n+    switch(meet_instptr(ptr, this_klass, tkls_klass, this_xk, tkls_xk, this->_ptr, tkls->_ptr, res_klass, res_xk)) {\n@@ -5746,2 +5583,2 @@\n-        const Type* res = make(ptr, res_klass, interfaces, off);\n-        return res;\n+        const Type* res1 = make(ptr, res_klass, off);\n+        return res1;\n@@ -5757,3 +5594,0 @@\n-    InterfaceSet interfaces = meet_interfaces(tp);\n-    InterfaceSet tp_interfaces = tp->_interfaces;\n-    InterfaceSet this_interfaces = _interfaces;\n@@ -5767,1 +5601,1 @@\n-      if (klass()->equals(ciEnv::current()->Object_klass()) && tp_interfaces.contains(this_interfaces) && !klass_is_exact()) {\n+      if (klass()->equals(ciEnv::current()->Object_klass()) && !klass_is_exact()) {\n@@ -5772,2 +5606,1 @@\n-        interfaces = _interfaces.intersection_with(tp->_interfaces);\n-        return make(ptr, ciEnv::current()->Object_klass(), interfaces, offset);\n+        return make(ptr, ciEnv::current()->Object_klass(), offset);\n@@ -5785,1 +5618,1 @@\n-        if (klass()->equals(ciEnv::current()->Object_klass()) && tp_interfaces.contains(this_interfaces) && !klass_is_exact()) {\n+        if (klass()->equals(ciEnv::current()->Object_klass())) {\n@@ -5795,2 +5628,1 @@\n-      interfaces = this_interfaces.intersection_with(tp_interfaces);\n-      return make(ptr, ciEnv::current()->Object_klass(), interfaces, offset);\n+      return make(ptr, ciEnv::current()->Object_klass(), offset);\n@@ -5808,1 +5640,1 @@\n-  return new TypeInstKlassPtr(dual_ptr(), klass(), _interfaces, dual_offset());\n+  return new TypeInstKlassPtr(dual_ptr(), klass(), dual_offset());\n@@ -5811,3 +5643,2 @@\n-template <class T1, class T2> bool TypePtr::is_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n-  static_assert(std::is_base_of<T2, T1>::value, \"\");\n-  if (!this_one->is_loaded() || !other->is_loaded()) {\n+bool TypeInstKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  if (!is_loaded() || !other->is_loaded()) {\n@@ -5816,1 +5647,1 @@\n-  if (!this_one->is_instance_type(other)) {\n+  if (!other->isa_instklassptr()) {\n@@ -5824,1 +5655,1 @@\n-  if (other->klass()->equals(ciEnv::current()->Object_klass()) && other->_interfaces.empty()) {\n+  if (other->_klass->equals(ciEnv::current()->Object_klass())) {\n@@ -5828,2 +5659,3 @@\n-  return this_one->_klass->is_subtype_of(other->_klass) && this_one->_interfaces.contains(other->_interfaces);\n-}\n+  if (!this_exact && klass()->is_interface()) {\n+    return false;\n+  }\n@@ -5831,2 +5663,1 @@\n-bool TypeInstKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  return TypePtr::is_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n+  return _klass->is_subtype_of(other->_klass);\n@@ -5835,3 +5666,2 @@\n-template <class T1, class T2> bool TypePtr::is_same_java_type_as_helper_for_instance(const T1* this_one, const T2* other) {\n-  static_assert(std::is_base_of<T2, T1>::value, \"\");\n-  if (!this_one->is_loaded() || !other->is_loaded()) {\n+bool TypeInstKlassPtr::is_same_java_type_as(const TypeKlassPtr* other) const {\n+  if (!is_loaded() || !other->is_loaded()) {\n@@ -5840,1 +5670,1 @@\n-  if (!this_one->is_instance_type(other)) {\n+  if (!other->isa_instklassptr()) {\n@@ -5843,1 +5673,1 @@\n-  return this_one->_klass->equals(other->_klass) && this_one->_interfaces.eq(other->_interfaces);\n+  return _klass->equals(other->_klass);\n@@ -5846,7 +5676,2 @@\n-bool TypeInstKlassPtr::is_same_java_type_as_helper(const TypeKlassPtr* other) const {\n-  return TypePtr::is_same_java_type_as_helper_for_instance(this, other);\n-}\n-\n-template <class T1, class T2> bool TypePtr::maybe_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n-  static_assert(std::is_base_of<T2, T1>::value, \"\");\n-  if (!this_one->is_loaded() || !other->is_loaded()) {\n+bool TypeInstKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  if (!is_loaded() || !other->is_loaded()) {\n@@ -5856,2 +5681,6 @@\n-  if (this_one->is_array_type(other)) {\n-    return !this_exact && this_one->_klass->equals(ciEnv::current()->Object_klass())  && other->_interfaces.contains(this_one->_interfaces);\n+  if (other->isa_aryklassptr()) {\n+    return !this_exact && (_klass->equals(ciEnv::current()->Object_klass()) || _klass->is_interface());\n+  }\n+\n+  if ((_klass->is_interface() && !this_exact) || (other->klass()->is_interface() \/*&& !other_exact*\/)) {\n+    return true;\n@@ -5860,1 +5689,1 @@\n-  assert(this_one->is_instance_type(other), \"unsupported\");\n+  assert(other->isa_instklassptr(), \"unsupported\");\n@@ -5863,1 +5692,1 @@\n-    return this_one->is_java_subtype_of(other);\n+    return is_java_subtype_of(other);\n@@ -5866,1 +5695,1 @@\n-  if (!this_one->_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(this_one->_klass)) {\n+  if (!_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(_klass)) {\n@@ -5871,1 +5700,1 @@\n-    return this_one->_klass->is_subtype_of(other->_klass) && this_one->_interfaces.contains(other->_interfaces);\n+    return _klass->is_subtype_of(other->_klass);\n@@ -5877,36 +5706,0 @@\n-bool TypeInstKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  return TypePtr::maybe_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n-}\n-\n-const TypeKlassPtr* TypeInstKlassPtr::try_improve() const {\n-  if (!UseUniqueSubclasses) {\n-    return this;\n-  }\n-  ciKlass* k = klass();\n-  Compile* C = Compile::current();\n-  Dependencies* deps = C->dependencies();\n-  assert((deps != NULL) == (C->method() != NULL && C->method()->code_size() > 0), \"sanity\");\n-  TypePtr::InterfaceSet interfaces = _interfaces;\n-  if (k->is_loaded()) {\n-    ciInstanceKlass* ik = k->as_instance_klass();\n-    bool klass_is_exact = ik->is_final();\n-    if (!klass_is_exact &&\n-        deps != NULL) {\n-      ciInstanceKlass* sub = ik->unique_concrete_subklass();\n-      if (sub != NULL) {\n-        ciKlass *sub_k = sub;\n-        TypePtr::InterfaceSet sub_interfaces = TypePtr::interfaces(sub_k, true, false, false, ignore_interfaces);\n-        assert(sub_k == sub, \"\");\n-        if (sub_interfaces.eq(_interfaces)) {\n-          deps->assert_abstract_with_unique_concrete_subtype(ik, sub);\n-          k = ik = sub;\n-          klass_is_exact = sub->is_final();\n-          return TypeKlassPtr::make(klass_is_exact ? Constant : _ptr, k, _offset);\n-        }\n-      }\n-    }\n-  }\n-  return this;\n-}\n-\n-\n@@ -5917,2 +5710,2 @@\n-const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, ciKlass* k, int offset, InterfaceHandling interface_handling) {\n-  if (k->is_obj_array_klass()) {\n+const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, ciKlass* klass, int offset) {\n+  if (klass->is_obj_array_klass()) {\n@@ -5920,2 +5713,2 @@\n-    ciKlass* eklass = k->as_obj_array_klass()->element_klass();\n-    const TypeKlassPtr *etype = TypeKlassPtr::make(eklass, interface_handling)->cast_to_exactness(false);\n+    ciKlass* eklass = klass->as_obj_array_klass()->element_klass();\n+    const TypeKlassPtr *etype = TypeKlassPtr::make(eklass)->cast_to_exactness(false);\n@@ -5923,1 +5716,1 @@\n-  } else if (k->is_type_array_klass()) {\n+  } else if (klass->is_type_array_klass()) {\n@@ -5925,2 +5718,2 @@\n-    const Type* etype = get_const_basic_type(k->as_type_array_klass()->element_type());\n-    return TypeAryKlassPtr::make(ptr, etype, k, offset);\n+    const Type* etype = get_const_basic_type(klass->as_type_array_klass()->element_type());\n+    return TypeAryKlassPtr::make(ptr, etype, klass, offset);\n@@ -5933,2 +5726,2 @@\n-const TypeAryKlassPtr* TypeAryKlassPtr::make(ciKlass* klass, InterfaceHandling interface_handling) {\n-  return TypeAryKlassPtr::make(Constant, klass, 0, interface_handling);\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(ciKlass* klass) {\n+  return TypeAryKlassPtr::make(Constant, klass, 0);\n@@ -5966,1 +5759,2 @@\n-    \/\/ Leave k_ary at NULL.\n+    \/\/ Compute array klass from element klass\n+    k_ary = ciObjArrayKlass::make(tinst->klass());\n@@ -5968,1 +5762,5 @@\n-    \/\/ Leave k_ary at NULL.\n+    \/\/ Compute array klass from element klass\n+    ciKlass* k_elem = tary->klass();\n+    \/\/ If element type is something like bottom[], k_elem will be null.\n+    if (k_elem != NULL)\n+      k_ary = ciObjArrayKlass::make(k_elem);\n@@ -6026,0 +5824,5 @@\n+    if (UseCompressedOops && k_ary != NULL && k_ary->is_obj_array_klass() &&\n+        _offset != 0 && _offset != arrayOopDesc::length_offset_in_bytes() &&\n+        _offset != arrayOopDesc::klass_offset_in_bytes()) {\n+      ((TypeAryPtr*)this)->_is_ptr_to_narrowoop = true;\n+    }\n@@ -6030,1 +5833,0 @@\n-\/\/ Is there a single ciKlass* that can represent that type?\n@@ -6056,1 +5858,1 @@\n-const TypePtr* TypeAryKlassPtr::add_offset(intptr_t offset) const {\n+const TypePtr *TypeAryKlassPtr::add_offset(intptr_t offset) const {\n@@ -6186,1 +5988,1 @@\n-    meet_aryptr(ptr, elem, this, tap, res_klass, res_xk);\n+    meet_aryptr(ptr, elem, this->klass(), tap->klass(), this->klass_is_exact(), tap->klass_is_exact(), this->ptr(), tap->ptr(), res_klass, res_xk);\n@@ -6194,3 +5996,0 @@\n-    InterfaceSet interfaces = meet_interfaces(tp);\n-    InterfaceSet tp_interfaces = tp->_interfaces;\n-    InterfaceSet this_interfaces = _interfaces;\n@@ -6204,1 +6003,1 @@\n-      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.intersection_with(tp_interfaces).eq(tp_interfaces) && !tp->klass_is_exact()) {\n+      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n@@ -6209,2 +6008,1 @@\n-        interfaces = this_interfaces.intersection_with(tp->_interfaces);\n-        return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, offset);\n+        return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), offset);\n@@ -6222,1 +6020,1 @@\n-        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.intersection_with(tp_interfaces).eq(tp_interfaces) && !tp->klass_is_exact()) {\n+        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n@@ -6231,2 +6029,1 @@\n-      interfaces = this_interfaces.intersection_with(tp_interfaces);\n-      return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, offset);\n+      return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), offset);\n@@ -6241,4 +6038,2 @@\n-template <class T1, class T2> bool TypePtr::is_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n-  static_assert(std::is_base_of<T2, T1>::value, \"\");\n-\n-  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty() && other_exact) {\n+bool TypeAryKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  if (other->klass() == ciEnv::current()->Object_klass() && other_exact) {\n@@ -6248,4 +6043,1 @@\n-  int dummy;\n-  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n-\n-  if (!this_one->is_loaded() || !other->is_loaded() || this_top_or_bottom) {\n+  if (!is_loaded() || !other->is_loaded() || other->klass() == NULL || klass() == NULL) {\n@@ -6254,3 +6046,2 @@\n-\n-  if (this_one->is_instance_type(other)) {\n-    return other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.intersection_with(this_one->_interfaces).eq(other->_interfaces) && other_exact;\n+  if (other->isa_instklassptr()) {\n+    return _klass->is_subtype_of(other->_klass) && other_exact;\n@@ -6258,5 +6049,1 @@\n-\n-  assert(this_one->is_array_type(other), \"\");\n-  const T1* other_ary = this_one->is_array_type(other);\n-  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n-  if (other_top_or_bottom) {\n+  if (klass() == NULL) {\n@@ -6265,5 +6052,4 @@\n-\n-  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n-  const TypePtr* this_elem = this_one->elem()->make_ptr();\n-  if (this_elem != NULL && other_elem != NULL) {\n-    return this_one->is_reference_type(this_elem)->is_java_subtype_of_helper(this_one->is_reference_type(other_elem), this_exact, other_exact);\n+  assert(other->isa_aryklassptr(), \"\");\n+  const TypeAryKlassPtr* other_ary = other->isa_aryklassptr();\n+  if (other_ary->_elem->isa_klassptr() && _elem->isa_klassptr()) {\n+    return _elem->is_klassptr()->is_java_subtype_of_helper(other_ary->_elem->is_klassptr(), this_exact, other_exact);\n@@ -6271,2 +6057,2 @@\n-  if (this_elem == NULL && other_elem == NULL) {\n-    return this_one->_klass->is_subtype_of(other->_klass);\n+  if (!other_ary->_elem->isa_klassptr() && !_elem->isa_klassptr()) {\n+    return _klass->is_subtype_of(other->_klass);\n@@ -6277,18 +6063,3 @@\n-bool TypeAryKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  return TypePtr::is_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n-}\n-\n-template <class T1, class T2> bool TypePtr::is_same_java_type_as_helper_for_array(const T1* this_one, const T2* other) {\n-  static_assert(std::is_base_of<T2, T1>::value, \"\");\n-\n-  int dummy;\n-  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n-\n-  if (!this_one->is_array_type(other) ||\n-      !this_one->is_loaded() || !other->is_loaded() || this_top_or_bottom) {\n-    return false;\n-  }\n-  const T1* other_ary = this_one->is_array_type(other);\n-  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n-\n-  if (other_top_or_bottom) {\n+bool TypeAryKlassPtr::is_same_java_type_as(const TypeKlassPtr* other) const {\n+  if (!other->isa_aryklassptr() ||\n+      !is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n@@ -6297,5 +6068,3 @@\n-\n-  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n-  const TypePtr* this_elem = this_one->elem()->make_ptr();\n-  if (other_elem != NULL && this_elem != NULL) {\n-    return this_one->is_reference_type(this_elem)->is_same_java_type_as(this_one->is_reference_type(other_elem));\n+  const TypeAryKlassPtr* other_ary = other->isa_aryklassptr();\n+  if (other_ary->_elem->isa_klassptr() && _elem->isa_klassptr()) {\n+    return _elem->is_klassptr()->is_same_java_type_as(other_ary->_elem->is_klassptr());\n@@ -6303,3 +6072,2 @@\n-  if (other_elem == NULL && this_elem == NULL) {\n-    assert(this_one->_klass != NULL && other->_klass != NULL, \"\");\n-    return this_one->_klass->equals(other->_klass);\n+  if (!other_ary->_elem->isa_klassptr() && !_elem->isa_klassptr()) {\n+    return _klass->equals(other->_klass);\n@@ -6310,7 +6078,2 @@\n-bool TypeAryKlassPtr::is_same_java_type_as_helper(const TypeKlassPtr* other) const {\n-  return TypePtr::is_same_java_type_as_helper_for_array(this, other);\n-}\n-\n-template <class T1, class T2> bool TypePtr::maybe_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n-  static_assert(std::is_base_of<T2, T1>::value, \"\");\n-  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty() && other_exact) {\n+bool TypeAryKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  if (other->klass() == ciEnv::current()->Object_klass()) {\n@@ -6319,3 +6082,1 @@\n-  int dummy;\n-  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n-  if (!this_one->is_loaded() || !other->is_loaded() || this_top_or_bottom) {\n+  if (!is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n@@ -6324,2 +6085,2 @@\n-  if (this_one->is_instance_type(other)) {\n-    return other->_klass->equals(ciEnv::current()->Object_klass()) && other->_interfaces.intersection_with(this_one->_interfaces).eq(other->_interfaces);\n+  if (other->isa_instklassptr()) {\n+    return (!other_exact && other->_klass->is_interface()) || _klass->is_subtype_of(other->_klass);\n@@ -6327,1 +6088,1 @@\n-  assert(this_one->is_array_type(other), \"\");\n+  assert(other->isa_aryklassptr(), \"\");\n@@ -6329,5 +6090,0 @@\n-  const T1* other_ary = this_one->is_array_type(other);\n-  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n-  if (other_top_or_bottom) {\n-    return true;\n-  }\n@@ -6335,1 +6091,1 @@\n-    return this_one->is_java_subtype_of(other);\n+    return is_java_subtype_of(other);\n@@ -6338,4 +6094,3 @@\n-  const TypePtr* this_elem = this_one->elem()->make_ptr();\n-  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n-  if (other_elem != NULL && this_elem != NULL) {\n-    return this_one->is_reference_type(this_elem)->maybe_java_subtype_of_helper(this_one->is_reference_type(other_elem), this_exact, other_exact);\n+  const TypeAryKlassPtr* other_ary = other->isa_aryklassptr();\n+  if (other_ary->_elem->isa_klassptr() && _elem->isa_klassptr()) {\n+    return _elem->is_klassptr()->maybe_java_subtype_of_helper(other_ary->_elem->is_klassptr(), this_exact, other_exact);\n@@ -6343,2 +6098,2 @@\n-  if (other_elem == NULL && this_elem == NULL) {\n-    return this_one->_klass->is_subtype_of(other->_klass);\n+  if (!other_ary->_elem->isa_klassptr() && !_elem->isa_klassptr()) {\n+    return _klass->is_subtype_of(other->_klass);\n@@ -6349,4 +6104,0 @@\n-bool TypeAryKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  return TypePtr::maybe_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n-}\n-\n@@ -6359,1 +6110,1 @@\n-\/\/ Is there a single ciKlass* that can represent that type?\n+\/\/------------------------------get_con----------------------------------------\n@@ -6379,1 +6130,5 @@\n-    \/\/ leave NULL\n+    k = elem()->is_klassptr()->klass();\n+    if (k != NULL) {\n+      k = ciObjArrayKlass::make(k);\n+      ((TypeAryKlassPtr*)this)->_klass = k;\n+    }\n@@ -6384,1 +6139,0 @@\n-    ((TypeAryKlassPtr*)this)->_klass = k;\n@@ -6400,1 +6154,0 @@\n-      _interfaces.dump(st);\n@@ -6449,1 +6202,1 @@\n-    domain = TypeTuple::make_domain(NULL, method->signature(), ignore_interfaces);\n+    domain = TypeTuple::make_domain(NULL, method->signature());\n@@ -6451,1 +6204,1 @@\n-    domain = TypeTuple::make_domain(method->holder(), method->signature(), ignore_interfaces);\n+    domain = TypeTuple::make_domain(method->holder(), method->signature());\n@@ -6453,1 +6206,1 @@\n-  const TypeTuple *range  = TypeTuple::make_range(method->signature(), ignore_interfaces);\n+  const TypeTuple *range  = TypeTuple::make_range(method->signature());\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":548,"deletions":795,"binary":false,"changes":1343,"status":"modified"},{"patch":"@@ -171,0 +171,4 @@\n+#ifdef ASSERT\n+  \/\/ One type is interface, the other is oop\n+  virtual bool interface_vs_oop_helper(const Type *t) const;\n+#endif\n@@ -259,0 +263,1 @@\n+  \/\/ Currently, it also works around limitations involving interface types.\n@@ -268,0 +273,5 @@\n+#ifdef ASSERT\n+  \/\/ One type is interface, the other is oop\n+  virtual bool interface_vs_oop(const Type *t) const;\n+#endif\n+\n@@ -397,4 +407,0 @@\n-  enum InterfaceHandling {\n-      trust_interfaces,\n-      ignore_interfaces\n-  };\n@@ -402,1 +408,1 @@\n-  static const Type* get_const_type(ciType* type, InterfaceHandling interface_handling = ignore_interfaces);\n+  static const Type* get_const_type(ciType* type);\n@@ -721,2 +727,2 @@\n-  static const TypeTuple *make_range(ciSignature *sig, InterfaceHandling interface_handling = ignore_interfaces);\n-  static const TypeTuple *make_domain(ciInstanceKlass* recv, ciSignature *sig, InterfaceHandling interface_handling);\n+  static const TypeTuple *make_range(ciSignature *sig);\n+  static const TypeTuple *make_domain(ciInstanceKlass* recv, ciSignature *sig);\n@@ -773,0 +779,4 @@\n+#ifdef ASSERT\n+  \/\/ One type is interface, the other is oop\n+  virtual bool interface_vs_oop(const Type *t) const;\n+#endif\n@@ -878,46 +888,0 @@\n-  friend class Type;\n-protected:\n-  class InterfaceSet {\n-  private:\n-    GrowableArray<ciKlass*> _list;\n-    void raw_add(ciKlass* interface);\n-    void add(ciKlass* interface);\n-    void verify() const;\n-    int _hash_computed:1;\n-    int _exact_klass_computed:1;\n-    int _is_loaded_computed:1;\n-    int _hash;\n-    ciKlass* _exact_klass;\n-    bool _is_loaded;\n-    void compute_hash();\n-    void compute_exact_klass();\n-  public:\n-    InterfaceSet();\n-    InterfaceSet(GrowableArray<ciInstanceKlass*>* interfaces);\n-    bool eq(const InterfaceSet& other) const;\n-    int hash() const;\n-    void dump(outputStream *st) const;\n-    InterfaceSet union_with(const InterfaceSet& other) const;\n-    InterfaceSet intersection_with(const InterfaceSet& other) const;\n-    bool contains(const InterfaceSet& other) const {\n-      return intersection_with(other).eq(other);\n-    }\n-    bool empty() const { return _list.length() == 0; }\n-\n-    inline void* operator new(size_t x) throw() {\n-      Compile* compile = Compile::current();\n-      return compile->type_arena()->AmallocWords(x);\n-    }\n-    inline void operator delete( void* ptr ) {\n-      ShouldNotReachHere();\n-    }\n-    ciKlass* exact_klass() const;\n-    bool is_loaded() const;\n-\n-    static int compare(ciKlass* const &, ciKlass* const & k2);\n-\n-    void compute_is_loaded();\n-  };\n-\n-  static InterfaceSet interfaces(ciKlass*& k, bool klass, bool interface, bool array, InterfaceHandling interface_handling);\n-\n@@ -982,14 +946,6 @@\n-  template<class T> static TypePtr::MeetResult meet_instptr(PTR& ptr, InterfaceSet& interfaces, const T* this_type,\n-                                                            const T* other_type, ciKlass*& res_klass, bool& res_xk);\n-\n-  template<class T> static MeetResult meet_aryptr(PTR& ptr, const Type*& elem, const T* this_ary, const T* other_ary,\n-                                                  ciKlass*& res_klass, bool& res_xk);\n-\n-  template <class T1, class T2> static bool is_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact);\n-  template <class T1, class T2> static bool is_same_java_type_as_helper_for_instance(const T1* this_one, const T2* other);\n-  template <class T1, class T2> static bool maybe_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact);\n-  template <class T1, class T2> static bool is_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact);\n-  template <class T1, class T2> static bool is_same_java_type_as_helper_for_array(const T1* this_one, const T2* other);\n-  template <class T1, class T2> static bool maybe_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact);\n-  template <class T1, class T2> static bool is_meet_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_xk, bool other_xk);\n-  template <class T1, class T2> static bool is_meet_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_xk, bool other_xk);\n+  static MeetResult\n+  meet_instptr(PTR &ptr, ciKlass* this_klass, ciKlass* tinst_klass, bool this_xk, bool tinst_xk, PTR this_ptr,\n+               PTR tinst_ptr, ciKlass*&res_klass, bool &res_xk);\n+  static MeetResult\n+  meet_aryptr(PTR& ptr, const Type*& elem, ciKlass* this_klass, ciKlass* tap_klass, bool this_xk, bool tap_xk, PTR this_ptr, PTR tap_ptr, ciKlass*& res_klass, bool& res_xk);\n+\n@@ -1104,1 +1060,1 @@\n- TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int offset, int instance_id,\n+  TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id,\n@@ -1120,3 +1076,0 @@\n-\n-  const InterfaceSet _interfaces;\n-\n@@ -1134,1 +1087,1 @@\n-  static const TypeOopPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact, InterfaceHandling interface_handling);\n+  static const TypeOopPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact);\n@@ -1139,2 +1092,0 @@\n-  InterfaceSet meet_interfaces(const TypeOopPtr* other) const;\n-\n@@ -1152,9 +1103,1 @@\n-\n-  bool is_same_java_type_as(const TypePtr* other) const {\n-    return is_same_java_type_as_helper(other->is_oopptr());\n-  }\n-\n-  virtual bool is_same_java_type_as_helper(const TypeOopPtr* other) const {\n-    ShouldNotReachHere(); return false;\n-  }\n-\n+  virtual bool is_same_java_type_as(const TypeOopPtr* other) const { ShouldNotReachHere(); return false; }\n@@ -1171,2 +1114,2 @@\n-  static const TypeOopPtr* make_from_klass(ciKlass* klass, InterfaceHandling interface_handling = ignore_interfaces) {\n-    return make_from_klass_common(klass, true, false, interface_handling);\n+  static const TypeOopPtr* make_from_klass(ciKlass* klass) {\n+    return make_from_klass_common(klass, true, false);\n@@ -1176,2 +1119,2 @@\n-  static const TypeOopPtr* make_from_klass_unique(ciKlass* klass, InterfaceHandling interface_handling= ignore_interfaces) {\n-    return make_from_klass_common(klass, true, true, interface_handling);\n+  static const TypeOopPtr* make_from_klass_unique(ciKlass* klass) {\n+    return make_from_klass_common(klass, true, true);\n@@ -1181,2 +1124,2 @@\n-  static const TypeOopPtr* make_from_klass_raw(ciKlass* klass, InterfaceHandling interface_handling = ignore_interfaces) {\n-    return make_from_klass_common(klass, false, false, interface_handling);\n+  static const TypeOopPtr* make_from_klass_raw(ciKlass* klass) {\n+    return make_from_klass_common(klass, false, false);\n@@ -1201,2 +1144,2 @@\n-  virtual bool  is_loaded() const { return klass()->is_loaded() && _interfaces.is_loaded(); }\n-  virtual bool klass_is_exact()    const { return _klass_is_exact; }\n+  virtual bool  is_loaded() const { return klass()->is_loaded(); }\n+  bool klass_is_exact()    const { return _klass_is_exact; }\n@@ -1244,24 +1187,0 @@\n-private:\n-  virtual bool is_meet_subtype_of(const TypePtr* other) const {\n-    return is_meet_subtype_of_helper(other->is_oopptr(), klass_is_exact(), other->is_oopptr()->klass_is_exact());\n-  }\n-\n-  virtual bool is_meet_subtype_of_helper(const TypeOopPtr* other, bool this_xk, bool other_xk) const {\n-    ShouldNotReachHere(); return false;\n-  }\n-\n-  virtual const InterfaceSet interfaces() const {\n-    return _interfaces;\n-  };\n-\n-  const TypeOopPtr* is_reference_type(const Type* other) const {\n-    return other->isa_oopptr();\n-  }\n-\n-  const TypeAryPtr* is_array_type(const TypeOopPtr* other) const {\n-    return other->isa_aryptr();\n-  }\n-\n-  const TypeInstPtr* is_instance_type(const TypeOopPtr* other) const {\n-    return other->isa_instptr();\n-  }\n@@ -1274,1 +1193,1 @@\n-  TypeInstPtr(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int offset, int instance_id,\n+  TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id,\n@@ -1285,1 +1204,3 @@\n-    assert(!(klass()->is_loaded() && klass()->is_interface()), \"\");\n+    if (klass()->is_loaded() && klass()->is_interface()) {\n+      return Compile::current()->env()->Object_klass();\n+    }\n@@ -1289,1 +1210,1 @@\n-  bool is_same_java_type_as_helper(const TypeOopPtr* other) const;\n+  bool is_same_java_type_as(const TypeOopPtr* other) const;\n@@ -1295,3 +1216,1 @@\n-    ciKlass* k = o->klass();\n-    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n-    return make(TypePtr::Constant, k, interfaces, true, o, 0, InstanceBot);\n+    return make(TypePtr::Constant, o->klass(), true, o, 0, InstanceBot);\n@@ -1301,3 +1220,1 @@\n-    ciKlass* k = o->klass();\n-    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n-    return make(TypePtr::Constant, k, interfaces, true, o, offset, InstanceBot);\n+    return make(TypePtr::Constant, o->klass(), true, o, offset, InstanceBot);\n@@ -1307,3 +1224,2 @@\n-  static const TypeInstPtr *make(PTR ptr, ciKlass* klass, InterfaceHandling interface_handling = ignore_interfaces) {\n-    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n-    return make(ptr, klass, interfaces, false, NULL, 0, InstanceBot);\n+  static const TypeInstPtr *make(PTR ptr, ciKlass* klass) {\n+    return make(ptr, klass, false, NULL, 0, InstanceBot);\n@@ -1314,2 +1230,1 @@\n-    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, false, false, ignore_interfaces);\n-    return make(ptr, klass, interfaces, true, NULL, 0, InstanceBot);\n+    return make(ptr, klass, true, NULL, 0, InstanceBot);\n@@ -1320,2 +1235,1 @@\n-    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, false, false, ignore_interfaces);\n-    return make(ptr, klass, interfaces, false, NULL, offset, InstanceBot);\n+    return make(ptr, klass, false, NULL, offset, InstanceBot);\n@@ -1324,1 +1238,2 @@\n-  static const TypeInstPtr *make(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int offset,\n+  \/\/ Make a pointer to an oop.\n+  static const TypeInstPtr *make(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,\n@@ -1329,5 +1244,0 @@\n-  static const TypeInstPtr *make(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id = InstanceBot) {\n-    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n-    return make(ptr, k, interfaces, xk, o, offset, instance_id);\n-  }\n-\n@@ -1358,1 +1268,1 @@\n-  virtual const TypeInstPtr *xmeet_unloaded(const TypeInstPtr *t, const InterfaceSet& interfaces) const;\n+  virtual const TypeInstPtr *xmeet_unloaded( const TypeInstPtr *t ) const;\n@@ -1363,0 +1273,2 @@\n+  bool is_interface() const { return is_loaded() && klass()->is_interface(); }\n+\n@@ -1372,8 +1284,0 @@\n-\n-private:\n-  virtual bool is_meet_subtype_of_helper(const TypeOopPtr* other, bool this_xk, bool other_xk) const;\n-\n-  virtual bool is_meet_same_type_as(const TypePtr* other) const {\n-    return _klass->equals(other->is_instptr()->_klass) && _interfaces.eq(other->is_instptr()->_interfaces);\n-  }\n-\n@@ -1385,3 +1289,0 @@\n-  friend class Type;\n-  friend class TypePtr;\n-\n@@ -1391,1 +1292,1 @@\n-    : TypeOopPtr(AryPtr,ptr,k,*_array_interfaces,xk,o,offset, instance_id, speculative, inline_depth),\n+    : TypeOopPtr(AryPtr,ptr,k,xk,o,offset, instance_id, speculative, inline_depth),\n@@ -1395,7 +1296,14 @@\n-    int dummy;\n-    bool top_or_bottom = (base_element_type(dummy) == Type::TOP || base_element_type(dummy) == Type::BOTTOM);\n-\n-    if (UseCompressedOops && (elem()->make_oopptr() != NULL && !top_or_bottom) &&\n-        _offset != 0 && _offset != arrayOopDesc::length_offset_in_bytes() &&\n-        _offset != arrayOopDesc::klass_offset_in_bytes()) {\n-      _is_ptr_to_narrowoop = true;\n+#ifdef ASSERT\n+    if (k != NULL) {\n+      \/\/ Verify that specified klass and TypeAryPtr::klass() follow the same rules.\n+      ciKlass* ck = compute_klass(true);\n+      if (k != ck) {\n+        this->dump(); tty->cr();\n+        tty->print(\" k: \");\n+        k->print(); tty->cr();\n+        tty->print(\"ck: \");\n+        if (ck != NULL) ck->print();\n+        else tty->print(\"<NULL>\");\n+        tty->cr();\n+        assert(false, \"unexpected TypeAryPtr::_klass\");\n+      }\n@@ -1403,1 +1311,1 @@\n-\n+#endif\n@@ -1412,3 +1320,0 @@\n-  \/\/ A pointer to delay allocation to Type::Initialize_shared()\n-\n-  static const InterfaceSet* _array_interfaces;\n@@ -1416,1 +1321,0 @@\n-  \/\/ Only guaranteed non null for array of basic types\n@@ -1421,1 +1325,1 @@\n-  bool is_same_java_type_as_helper(const TypeOopPtr* other) const;\n+  bool is_same_java_type_as(const TypeOopPtr* other) const;\n@@ -1498,0 +1402,4 @@\n+#ifdef ASSERT\n+  \/\/ One type is interface, the other is oop\n+  virtual bool interface_vs_oop(const Type *t) const;\n+#endif\n@@ -1501,2 +1409,0 @@\n-private:\n-  virtual bool is_meet_subtype_of_helper(const TypeOopPtr* other, bool this_xk, bool other_xk) const;\n@@ -1550,1 +1456,0 @@\n-  friend class TypePtr;\n@@ -1552,1 +1457,1 @@\n-  TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, const InterfaceSet& interfaces, int offset);\n+  TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, int offset);\n@@ -1564,2 +1469,1 @@\n-  const InterfaceSet _interfaces;\n-  InterfaceSet meet_interfaces(const TypeKlassPtr* other) const;\n+\n@@ -1575,4 +1479,0 @@\n-  bool is_same_java_type_as(const TypePtr* other) const {\n-    return is_same_java_type_as_helper(other->is_klassptr());\n-  }\n-\n@@ -1582,1 +1482,1 @@\n-  virtual bool is_same_java_type_as_helper(const TypeKlassPtr* other) const { ShouldNotReachHere(); return false; }\n+  virtual bool is_same_java_type_as(const TypeKlassPtr* other) const { ShouldNotReachHere(); return false; }\n@@ -1588,1 +1488,0 @@\n-  virtual bool klass_is_exact()    const { return _ptr == Constant; }\n@@ -1590,2 +1489,4 @@\n-  static const TypeKlassPtr* make(ciKlass* klass, InterfaceHandling interface_handling = ignore_interfaces);\n-  static const TypeKlassPtr *make(PTR ptr, ciKlass* klass, int offset, InterfaceHandling interface_handling = ignore_interfaces);\n+  bool klass_is_exact()    const { return _ptr == Constant; }\n+\n+  static const TypeKlassPtr* make(ciKlass* klass);\n+  static const TypeKlassPtr *make(PTR ptr, ciKlass* klass, int offset);\n@@ -1610,2 +1511,0 @@\n-  virtual const TypeKlassPtr* try_improve() const { return this; }\n-\n@@ -1615,24 +1514,0 @@\n-private:\n-  virtual bool is_meet_subtype_of(const TypePtr* other) const {\n-    return is_meet_subtype_of_helper(other->is_klassptr(), klass_is_exact(), other->is_klassptr()->klass_is_exact());\n-  }\n-\n-  virtual bool is_meet_subtype_of_helper(const TypeKlassPtr* other, bool this_xk, bool other_xk) const {\n-    ShouldNotReachHere(); return false;\n-  }\n-\n-  virtual const InterfaceSet interfaces() const {\n-    return _interfaces;\n-  };\n-\n-  const TypeKlassPtr* is_reference_type(const Type* other) const {\n-    return other->isa_klassptr();\n-  }\n-\n-  const TypeAryKlassPtr* is_array_type(const TypeKlassPtr* other) const {\n-    return other->isa_aryklassptr();\n-  }\n-\n-  const TypeInstKlassPtr* is_instance_type(const TypeKlassPtr* other) const {\n-    return other->isa_instklassptr();\n-  }\n@@ -1644,3 +1519,2 @@\n-  TypeInstKlassPtr(PTR ptr, ciKlass* klass, const InterfaceSet& interfaces, int offset)\n-    : TypeKlassPtr(InstKlassPtr, ptr, klass, interfaces, offset) {\n-    assert(klass->is_instance_klass() && (!klass->is_loaded() || !klass->is_interface()), \"\");\n+  TypeInstKlassPtr(PTR ptr, ciKlass* klass, int offset)\n+    : TypeKlassPtr(InstKlassPtr, ptr, klass, offset) {\n@@ -1654,1 +1528,3 @@\n-    assert(!klass()->is_interface(), \"\");\n+    if (klass()->is_interface()) {\n+      return Compile::current()->env()->Object_klass();\n+    }\n@@ -1658,1 +1534,1 @@\n-  bool is_same_java_type_as_helper(const TypeKlassPtr* other) const;\n+  bool is_same_java_type_as(const TypeKlassPtr* other) const;\n@@ -1662,9 +1538,2 @@\n-  static const TypeInstKlassPtr *make(ciKlass* k, InterfaceHandling interface_handling) {\n-    InterfaceSet interfaces = TypePtr::interfaces(k, true, true, false, interface_handling);\n-    return make(TypePtr::Constant, k, interfaces, 0);\n-  }\n-  static const TypeInstKlassPtr* make(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, int offset);\n-\n-  static const TypeInstKlassPtr* make(PTR ptr, ciKlass* k, int offset) {\n-    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n-    return make(ptr, k, interfaces, offset);\n+  static const TypeInstKlassPtr *make(ciKlass* k) {\n+    return make(TypePtr::Constant, k, 0);\n@@ -1672,0 +1541,1 @@\n+  static const TypeInstKlassPtr *make(PTR ptr, ciKlass* k, int offset);\n@@ -1687,1 +1557,1 @@\n-  virtual const TypeKlassPtr* try_improve() const;\n+  bool is_interface() const { return klass()->is_interface(); }\n@@ -1692,2 +1562,0 @@\n-private:\n-  virtual bool is_meet_subtype_of_helper(const TypeKlassPtr* other, bool this_xk, bool other_xk) const;\n@@ -1699,3 +1567,0 @@\n-  friend class Type;\n-  friend class TypePtr;\n-\n@@ -1704,1 +1569,0 @@\n-  static const InterfaceSet* _array_interfaces;\n@@ -1706,2 +1570,1 @@\n-    : TypeKlassPtr(AryKlassPtr, ptr, klass, *_array_interfaces, offset), _elem(elem) {\n-    assert(klass == NULL || klass->is_type_array_klass() || !klass->as_obj_array_klass()->base_element_klass()->is_interface(), \"\");\n+    : TypeKlassPtr(AryKlassPtr, ptr, klass, offset), _elem(elem) {\n@@ -1711,1 +1574,0 @@\n-  \/\/ Only guaranteed non null for array of basic types\n@@ -1721,1 +1583,1 @@\n-  static const TypeAryKlassPtr *make(PTR ptr, ciKlass* k, int offset, InterfaceHandling interface_handling);\n+  static const TypeAryKlassPtr *make(PTR ptr, ciKlass* k, int offset);\n@@ -1723,1 +1585,1 @@\n-  bool is_same_java_type_as_helper(const TypeKlassPtr* other) const;\n+  bool is_same_java_type_as(const TypeKlassPtr* other) const;\n@@ -1730,1 +1592,1 @@\n-  static const TypeAryKlassPtr* make(ciKlass* klass, InterfaceHandling interface_handling);\n+  static const TypeAryKlassPtr* make(ciKlass* klass);\n@@ -1757,2 +1619,0 @@\n-private:\n-  virtual bool is_meet_subtype_of_helper(const TypeKlassPtr* other, bool this_xk, bool other_xk) const;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":92,"deletions":232,"binary":false,"changes":324,"status":"modified"},{"patch":"@@ -49,3 +49,0 @@\n-\/\/ Complain every extra number of unplanned local refs\n-#define CHECK_JNI_LOCAL_REF_CAP_WARN_THRESHOLD 32\n-\n@@ -205,11 +202,0 @@\n-\/**\n- * Add to the planned number of handles. I.e. plus current live & warning threshold\n- *\/\n-static inline void\n-add_planned_handle_capacity(JNIHandleBlock* handles, size_t capacity) {\n-  handles->set_planned_capacity(capacity +\n-                                handles->get_number_of_live_handles() +\n-                                CHECK_JNI_LOCAL_REF_CAP_WARN_THRESHOLD);\n-}\n-\n-\n@@ -247,12 +233,1 @@\n-  JNIHandleBlock* handles = thr->active_handles();\n-  size_t planned_capacity = handles->get_planned_capacity();\n-  size_t live_handles = handles->get_number_of_live_handles();\n-  if (live_handles > planned_capacity) {\n-    IN_VM(\n-      tty->print_cr(\"WARNING: JNI local refs: \" SIZE_FORMAT \", exceeds capacity: \" SIZE_FORMAT,\n-                    live_handles, planned_capacity);\n-      thr->print_stack();\n-    )\n-    \/\/ Complain just the once, reset to current + warn threshold\n-    add_planned_handle_capacity(handles, 0);\n-  }\n+  \/\/ No checks at this time\n@@ -749,3 +724,0 @@\n-    if (result == JNI_OK) {\n-      add_planned_handle_capacity(thr->active_handles(), capacity);\n-    }\n@@ -853,6 +825,0 @@\n-    if (result == JNI_OK) {\n-      \/\/ increase local ref capacity if needed\n-      if ((size_t)capacity > thr->active_handles()->get_planned_capacity()) {\n-        add_planned_handle_capacity(thr->active_handles(), capacity);\n-      }\n-    }\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":1,"deletions":35,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"runtime\/stackWatermarkSet.inline.hpp\"\n@@ -637,0 +638,6 @@\n+\n+  \/\/ This could be a different thread to the current one. So we need to ensure that\n+  \/\/ processing has started before we are allowed to read the continuation oop of\n+  \/\/ another thread, as it is a direct root of that other thread.\n+  StackWatermarkSet::start_processing(java_thread, StackWatermarkKind::gc);\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include \"runtime\/keepStackGCProcessed.hpp\"\n@@ -1967,0 +1968,5 @@\n+  \/\/ The KeepStackGCProcessedMark below keeps the target thread and its stack fully\n+  \/\/ GC processed across this scope. This is needed because there is a stack walk\n+  \/\/ below with safepoint polls inside of it. After such safepoints, we have to\n+  \/\/ ensure the stack is sufficiently processed.\n+  KeepStackGCProcessedMark ksgcpm(thread);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-  oop cont() override { return continuation() != NULL ? continuation(): ContinuationEntry::cont_oop_or_null(_cont_entry); }\n+  oop cont()       override { return continuation() != NULL ? continuation(): ContinuationEntry::cont_oop_or_null(_cont_entry, _map->thread()); }\n","filename":"src\/hotspot\/share\/prims\/stackwalk.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"classfile\/classLoaderStats.hpp\"\n@@ -1822,0 +1823,6 @@\n+WB_ENTRY(void, WB_ForceClassLoaderStatsSafepoint(JNIEnv* env, jobject wb))\n+  nullStream dev_null;\n+  ClassLoaderStatsVMOperation force_op(&dev_null);\n+  VMThread::execute(&force_op);\n+WB_END\n+\n@@ -2678,0 +2685,1 @@\n+  {CC\"forceClassLoaderStatsSafepoint\", CC\"()V\",       (void*)&WB_ForceClassLoaderStatsSafepoint },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -64,10 +64,0 @@\n-const ContinuationEntry* Continuation::last_continuation(const JavaThread* thread, oop cont_scope) {\n-  \/\/ guarantee (thread->has_last_Java_frame(), \"\");\n-  for (ContinuationEntry* entry = thread->last_continuation(); entry != nullptr; entry = entry->parent()) {\n-    if (cont_scope == jdk_internal_vm_Continuation::scope(entry->cont_oop())) {\n-      return entry;\n-    }\n-  }\n-  return nullptr;\n-}\n-\n@@ -80,1 +70,1 @@\n-    if (continuation == entry->cont_oop()) {\n+    if (continuation == entry->cont_oop(thread)) {\n@@ -102,4 +92,0 @@\n-bool Continuation::is_continuation_scope_mounted(JavaThread* thread, oop cont_scope) {\n-  return is_on_stack(thread, last_continuation(thread, cont_scope));\n-}\n-\n@@ -196,1 +182,1 @@\n-  oop continuation = ce->cont_oop();\n+  oop continuation = ce->cont_oop(map->thread());\n@@ -242,1 +228,1 @@\n-#if (defined(X86) || defined(AARCH64) || defined(RISCV64)) && !defined(ZERO)\n+#if (defined(X86) || defined(AARCH64) || defined(RISCV64) || defined(PPC64)) && !defined(ZERO)\n@@ -269,1 +255,1 @@\n-    continuation = ce->cont_oop();\n+    continuation = ce->cont_oop(map->thread());\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-  static const ContinuationEntry* last_continuation(const JavaThread* thread, oop cont_scope);\n@@ -81,1 +80,0 @@\n-  static bool is_continuation_scope_mounted(JavaThread* thread, oop cont_scope);\n","filename":"src\/hotspot\/share\/runtime\/continuation.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,5 +93,0 @@\n-void ContinuationEntry::setup_oopmap(OopMap* map) {\n-  map->set_oop(VMRegImpl::stack2reg(in_bytes(cont_offset())  \/ VMRegImpl::stack_slot_size));\n-  map->set_oop(VMRegImpl::stack2reg(in_bytes(chunk_offset()) \/ VMRegImpl::stack_slot_size));\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+#include CPU_HEADER(continuationEntry)\n+\n@@ -40,0 +42,1 @@\n+  ContinuationEntryPD _pd;\n@@ -69,0 +72,2 @@\n+  \/\/ Size in words of the stack arguments of the bottom frame on stack if compiled 0 otherwise.\n+  \/\/ The caller (if there is one) is the still frozen top frame in the StackChunk.\n@@ -88,2 +93,0 @@\n-  static void setup_oopmap(OopMap* map);\n-\n@@ -129,3 +132,6 @@\n-  inline oop cont_oop() const;\n-  inline oop scope() const;\n-  inline static oop cont_oop_or_null(const ContinuationEntry* ce);\n+  inline oop cont_oop(const JavaThread* thread) const;\n+  inline oop scope(const JavaThread* thread) const;\n+  inline static oop cont_oop_or_null(const ContinuationEntry* ce, const JavaThread* thread);\n+\n+  oop* cont_addr() { return (oop*)&_cont; }\n+  oop* chunk_addr() { return (oop*)&_chunk; }\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.hpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-#include \"oops\/access.hpp\"\n+#include \"gc\/shared\/collectedHeap.hpp\"\n+#include \"memory\/universe.hpp\"\n@@ -32,0 +33,2 @@\n+#include \"runtime\/stackWatermarkSet.inline.hpp\"\n+#include \"runtime\/thread.hpp\"\n@@ -33,1 +36,0 @@\n-\n@@ -37,1 +39,3 @@\n-  intptr_t* sp = entry_sp() - argsize();\n+  \/\/ the entry frame is extended if the bottom frame has stack arguments\n+  int entry_frame_extension = argsize() > 0 ? argsize() + frame::metadata_words_at_top : 0;\n+  intptr_t* sp = entry_sp() - entry_frame_extension;\n@@ -44,3 +48,15 @@\n-inline oop ContinuationEntry::cont_oop() const {\n-  oop snapshot = _cont;\n-  return NativeAccess<>::oop_load(&snapshot);\n+inline bool is_stack_watermark_processing_started(const JavaThread* thread) {\n+  StackWatermark* sw = StackWatermarkSet::get(const_cast<JavaThread*>(thread), StackWatermarkKind::gc);\n+\n+  if (sw == nullptr) {\n+    \/\/ No stale processing without stack watermarks\n+    return true;\n+  }\n+\n+  return sw->processing_started();\n+}\n+\n+inline oop ContinuationEntry::cont_oop(const JavaThread* thread) const {\n+  assert(!Universe::heap()->is_in((void*)&_cont), \"Should not be in the heap\");\n+  assert(is_stack_watermark_processing_started(thread != nullptr ? thread : JavaThread::current()), \"Not processed\");\n+  return *(oop*)&_cont;\n@@ -49,2 +65,2 @@\n-inline oop ContinuationEntry::cont_oop_or_null(const ContinuationEntry* ce) {\n-  return ce == nullptr ? nullptr : ce->cont_oop();\n+inline oop ContinuationEntry::cont_oop_or_null(const ContinuationEntry* ce, const JavaThread* thread) {\n+  return ce == nullptr ? nullptr : ce->cont_oop(thread);\n@@ -53,2 +69,2 @@\n-inline oop ContinuationEntry::scope() const {\n-  return Continuation::continuation_scope(cont_oop());\n+inline oop ContinuationEntry::scope(const JavaThread* thread) const {\n+  return Continuation::continuation_scope(cont_oop(thread));\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.inline.hpp","additions":26,"deletions":10,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -440,1 +440,1 @@\n-    return chunk->sp() >= chunk->stack_size() - chunk->argsize();\n+    return chunk->sp() >= chunk->stack_size() - chunk->argsize() - frame::metadata_words_at_top;\n@@ -471,1 +471,1 @@\n-  _bottom_address = _cont.entrySP() - _cont.argsize();\n+  _bottom_address = _cont.entrySP() - _cont.entry_frame_extension();\n@@ -487,1 +487,2 @@\n-  static const int doYield_stub_frame_size = frame::metadata_words;\n+  static const int doYield_stub_frame_size = NOT_PPC64(frame::metadata_words)\n+                                             PPC64_ONLY(frame::abi_reg_args_size >> LogBytesPerWord);\n@@ -492,1 +493,2 @@\n-  _cont_stack_bottom = _cont.entrySP() - ContinuationHelper::frame_align_words(_cont.argsize()); \/\/ see alignment in thaw\n+  _cont_stack_bottom = _cont.entrySP() + (_cont.argsize() == 0 ? frame::metadata_words_at_top : 0)\n+      - ContinuationHelper::frame_align_words(_cont.argsize()); \/\/ see alignment in thaw\n@@ -557,2 +559,0 @@\n-  assert(SharedRuntime::cont_doYield_stub()->frame_size() == frame::metadata_words, \"\");\n-\n@@ -560,1 +560,0 @@\n-\n@@ -568,1 +567,1 @@\n-    total_size_needed -= _cont.argsize();\n+    total_size_needed -= _cont.argsize() + frame::metadata_words_at_top;\n@@ -571,1 +570,1 @@\n-  int chunk_free_room = chunk_sp - frame::metadata_words;\n+  int chunk_free_room = chunk_sp - frame::metadata_words_at_bottom;\n@@ -591,1 +590,2 @@\n-    const int chunk_start_sp = chunk->sp() + _cont.argsize(); \/\/ we overlap; we'll overwrite the chunk's top frame's callee arguments\n+    \/\/ we overlap; we'll overwrite the chunk's top frame's callee arguments\n+    const int chunk_start_sp = chunk->sp() + _cont.argsize() + frame::metadata_words_at_top;\n@@ -595,1 +595,1 @@\n-    chunk->set_max_thawing_size(chunk->max_thawing_size() + cont_size() - _cont.argsize());\n+    chunk->set_max_thawing_size(chunk->max_thawing_size() + cont_size() - _cont.argsize() - frame::metadata_words_at_top);\n@@ -597,1 +597,1 @@\n-    intptr_t* const bottom_sp = _cont_stack_bottom - _cont.argsize();\n+    intptr_t* const bottom_sp = _cont_stack_bottom - _cont.argsize() - frame::metadata_words_at_top;\n@@ -674,3 +674,3 @@\n-  intptr_t* from = _cont_stack_top - frame::metadata_words;\n-  intptr_t* to   = chunk_top - frame::metadata_words;\n-  copy_to_chunk(from, to, cont_size() + frame::metadata_words);\n+  intptr_t* from = _cont_stack_top - frame::metadata_words_at_bottom;\n+  intptr_t* to   = chunk_top - frame::metadata_words_at_bottom;\n+  copy_to_chunk(from, to, cont_size() + frame::metadata_words_at_bottom);\n@@ -680,1 +680,1 @@\n-  intptr_t* chunk_bottom_sp = chunk_top + cont_size() - _cont.argsize();\n+  intptr_t* chunk_bottom_sp = chunk_top + cont_size() - _cont.argsize() - frame::metadata_words_at_top;\n@@ -786,0 +786,1 @@\n+\/\/ The parameter callee_argsize includes metadata that has to be part of caller\/callee overlap.\n@@ -815,0 +816,2 @@\n+\/\/ The parameter callee_argsize includes metadata that has to be part of caller\/callee overlap.\n+\/\/ See also StackChunkFrameStream<frame_kind>::frame_size()\n@@ -863,1 +866,4 @@\n-freeze_result FreezeBase::finalize_freeze(const frame& callee, frame& caller, int argsize) {\n+\/\/ The parameter argsize_md includes metadata that has to be part of caller\/callee overlap.\n+\/\/ See also StackChunkFrameStream<frame_kind>::frame_size()\n+freeze_result FreezeBase::finalize_freeze(const frame& callee, frame& caller, int argsize_md) {\n+  int argsize = argsize_md - frame::metadata_words_at_top;\n@@ -892,1 +898,1 @@\n-        overlap = argsize;\n+        overlap = argsize_md;\n@@ -939,1 +945,1 @@\n-    int sp = chunk->stack_size() - argsize;\n+    int sp = chunk->stack_size() - argsize_md;\n@@ -947,1 +953,1 @@\n-      int sp = chunk->stack_size() - argsize;\n+      int sp = chunk->stack_size() - argsize_md;\n@@ -980,1 +986,2 @@\n-  DEBUG_ONLY(_last_write = caller.unextended_sp() + (empty_chunk ? argsize : overlap);)\n+  DEBUG_ONLY(_last_write = caller.unextended_sp() + (empty_chunk ? argsize_md : overlap);)\n+\n@@ -1017,1 +1024,1 @@\n-    ContinuationHelper::InterpretedFrame::patch_sender_sp(hf, caller.unextended_sp());\n+    ContinuationHelper::InterpretedFrame::patch_sender_sp(hf, caller);\n@@ -1042,0 +1049,2 @@\n+\/\/ The parameter callee_argsize includes metadata that has to be part of caller\/callee overlap.\n+\/\/ See also StackChunkFrameStream<frame_kind>::frame_size()\n@@ -1043,1 +1052,1 @@\n-                                                                    int callee_argsize,\n+                                                                    int callee_argsize \/* incl. metadata *\/,\n@@ -1049,0 +1058,1 @@\n+  intptr_t* const callers_sp      = ContinuationHelper::InterpretedFrame::callers_sp(f);\n@@ -1050,1 +1060,1 @@\n-  const int fsize = f.fp() NOT_RISCV64(+ frame::metadata_words) + locals - stack_frame_top;\n+  const int fsize = callers_sp + frame::metadata_words_at_top + locals - stack_frame_top;\n@@ -1058,1 +1068,2 @@\n-  const int argsize = ContinuationHelper::InterpretedFrame::stack_argsize(f);\n+  \/\/ including metadata between f and its args\n+  const int argsize = ContinuationHelper::InterpretedFrame::stack_argsize(f) + frame::metadata_words_at_top;\n@@ -1076,1 +1087,1 @@\n-  _total_align_size += frame::align_wiggle; \/\/ add alignment room for internal interpreted frame alignment om AArch64\n+  _total_align_size += frame::align_wiggle; \/\/ add alignment room for internal interpreted frame alignment on AArch64\/PPC64\n@@ -1101,1 +1112,5 @@\n-freeze_result FreezeBase::recurse_freeze_compiled_frame(frame& f, frame& caller, int callee_argsize, bool callee_interpreted) {\n+\/\/ The parameter callee_argsize includes metadata that has to be part of caller\/callee overlap.\n+\/\/ See also StackChunkFrameStream<frame_kind>::frame_size()\n+freeze_result FreezeBase::recurse_freeze_compiled_frame(frame& f, frame& caller,\n+                                                        int callee_argsize \/* incl. metadata *\/,\n+                                                        bool callee_interpreted) {\n@@ -1105,1 +1120,2 @@\n-  const int argsize = ContinuationHelper::CompiledFrame::stack_argsize(f);\n+  \/\/ including metadata between f and its stackargs\n+  const int argsize = ContinuationHelper::CompiledFrame::stack_argsize(f) + frame::metadata_words_at_top;\n@@ -1216,1 +1232,5 @@\n-    ContinuationGCSupport::transform_stack_chunk(_cont.tail());\n+    if (UseShenandoahGC) {\n+      _cont.tail()->relativize_derived_pointers_concurrently();\n+    } else {\n+      ContinuationGCSupport::transform_stack_chunk(_cont.tail());\n+    }\n@@ -1250,0 +1270,78 @@\n+class StackChunkAllocator : public MemAllocator {\n+  const size_t                                 _stack_size;\n+  ContinuationWrapper&                         _continuation_wrapper;\n+  JvmtiSampledObjectAllocEventCollector* const _jvmti_event_collector;\n+  mutable bool                                 _took_slow_path;\n+\n+  \/\/ Does the minimal amount of initialization needed for a TLAB allocation.\n+  \/\/ We don't need to do a full initialization, as such an allocation need not be immediately walkable.\n+  virtual oop initialize(HeapWord* mem) const override {\n+    assert(_stack_size > 0, \"\");\n+    assert(_stack_size <= max_jint, \"\");\n+    assert(_word_size > _stack_size, \"\");\n+\n+    \/\/ zero out fields (but not the stack)\n+    const size_t hs = oopDesc::header_size();\n+    Copy::fill_to_aligned_words(mem + hs, vmClasses::StackChunk_klass()->size_helper() - hs);\n+\n+    jdk_internal_vm_StackChunk::set_size(mem, (int)_stack_size);\n+    jdk_internal_vm_StackChunk::set_sp(mem, (int)_stack_size);\n+\n+    return finish(mem);\n+  }\n+\n+  stackChunkOop allocate_fast() const {\n+    if (!UseTLAB) {\n+      return nullptr;\n+    }\n+\n+    HeapWord* const mem = MemAllocator::mem_allocate_inside_tlab_fast();\n+    if (mem == nullptr) {\n+      return nullptr;\n+    }\n+\n+    oop obj = initialize(mem);\n+    return stackChunkOopDesc::cast(obj);\n+  }\n+\n+public:\n+  StackChunkAllocator(Klass* klass,\n+                      size_t word_size,\n+                      Thread* thread,\n+                      size_t stack_size,\n+                      ContinuationWrapper& continuation_wrapper,\n+                      JvmtiSampledObjectAllocEventCollector* jvmti_event_collector)\n+    : MemAllocator(klass, word_size, thread),\n+      _stack_size(stack_size),\n+      _continuation_wrapper(continuation_wrapper),\n+      _jvmti_event_collector(jvmti_event_collector),\n+      _took_slow_path(false) {}\n+\n+  \/\/ Provides it's own, specialized allocation which skips instrumentation\n+  \/\/ if the memory can be allocated without going to a slow-path.\n+  stackChunkOop allocate() const {\n+    \/\/ First try to allocate without any slow-paths or instrumentation.\n+    stackChunkOop obj = allocate_fast();\n+    if (obj != nullptr) {\n+      return obj;\n+    }\n+\n+    \/\/ Now try full-blown allocation with all expensive operations,\n+    \/\/ including potentially safepoint operations.\n+    _took_slow_path = true;\n+\n+    \/\/ Protect unhandled Loom oops\n+    ContinuationWrapper::SafepointOp so(_thread, _continuation_wrapper);\n+\n+    \/\/ Can safepoint\n+    _jvmti_event_collector->start();\n+\n+    \/\/ Can safepoint\n+    return stackChunkOopDesc::cast(MemAllocator::allocate());\n+  }\n+\n+  bool took_slow_path() const {\n+    return _took_slow_path;\n+  }\n+};\n+\n@@ -1267,11 +1365,11 @@\n-  StackChunkAllocator allocator(klass, size_in_words, stack_size, current);\n-  oop fast_oop = allocator.try_allocate_in_existing_tlab();\n-  oop chunk_oop = fast_oop;\n-  if (chunk_oop == nullptr) {\n-    ContinuationWrapper::SafepointOp so(current, _cont);\n-    assert(_jvmti_event_collector != nullptr, \"\");\n-    _jvmti_event_collector->start();  \/\/ can safepoint\n-    chunk_oop = allocator.allocate(); \/\/ can safepoint\n-    if (chunk_oop == nullptr) {\n-      return nullptr; \/\/ OOME\n-    }\n+  \/\/ Allocate the chunk.\n+  \/\/\n+  \/\/ This might safepoint while allocating, but all safepointing due to\n+  \/\/ instrumentation have been deferred. This property is important for\n+  \/\/ some GCs, as this ensures that the allocated object is in the young\n+  \/\/ generation \/ newly allocated memory.\n+  StackChunkAllocator allocator(klass, size_in_words, current, stack_size, _cont, _jvmti_event_collector);\n+  stackChunkOop chunk = allocator.allocate();\n+\n+  if (chunk == nullptr) {\n+    return nullptr; \/\/ OOME\n@@ -1280,1 +1378,0 @@\n-  stackChunkOop chunk = stackChunkOopDesc::cast(chunk_oop);\n@@ -1296,1 +1393,8 @@\n-  assert(chunk->parent() == nullptr || chunk->parent()->is_stackChunk(), \"\");\n+#if INCLUDE_ZGC\n+ if (UseZGC) {\n+    assert(!chunk->requires_barriers(), \"ZGC always allocates in the young generation\");\n+    _barriers = false;\n+  } else\n+#endif\n+#if INCLUDE_SHENANDOAHGC\n+if (UseShenandoahGC) {\n@@ -1298,3 +1402,13 @@\n-  \/\/ Shenandoah: even continuation is good, it does not mean it is deeply good.\n-  if (UseShenandoahGC && chunk->requires_barriers()) {\n-    fast_oop = nullptr;\n+    _barriers = chunk->requires_barriers();\n+  } else\n+#endif\n+  {\n+    if (!allocator.took_slow_path()) {\n+      \/\/ Guaranteed to be in young gen \/ newly allocated memory\n+      assert(!chunk->requires_barriers(), \"Unfamiliar GC requires barriers on TLAB allocation\");\n+      _barriers = false;\n+    } else {\n+      \/\/ Some GCs could put direct allocations in old gen for slow-path\n+      \/\/ allocations; need to explicitly check if that was the case.\n+      _barriers = chunk->requires_barriers();\n+    }\n@@ -1303,9 +1417,2 @@\n-  if (fast_oop != nullptr) {\n-    assert(!chunk->requires_barriers(), \"Unfamiliar GC requires barriers on TLAB allocation\");\n-  } else {\n-    assert(!UseZGC || !chunk->requires_barriers(), \"Allocated ZGC object requires barriers\");\n-    _barriers = !UseZGC && chunk->requires_barriers();\n-\n-    if (_barriers) {\n-      log_develop_trace(continuations)(\"allocation requires barriers\");\n-    }\n+  if (_barriers) {\n+    log_develop_trace(continuations)(\"allocation requires barriers\");\n@@ -1313,0 +1420,3 @@\n+\n+  assert(chunk->parent() == nullptr || chunk->parent()->is_stackChunk(), \"\");\n+\n@@ -1418,2 +1528,2 @@\n-  oop oopCont = entry->cont_oop();\n-  assert(oopCont == current->last_continuation()->cont_oop(), \"\");\n+  oop oopCont = entry->cont_oop(current);\n+  assert(oopCont == current->last_continuation()->cont_oop(current), \"\");\n@@ -1426,1 +1536,1 @@\n-  assert(entry->is_virtual_thread() == (entry->scope() == java_lang_VirtualThread::vthread_scope()), \"\");\n+  assert(entry->is_virtual_thread() == (entry->scope(current) == java_lang_VirtualThread::vthread_scope()), \"\");\n@@ -1510,1 +1620,1 @@\n-      oop scope = jdk_internal_vm_Continuation::scope(entry->cont_oop());\n+      oop scope = jdk_internal_vm_Continuation::scope(entry->cont_oop(thread));\n@@ -1547,1 +1657,1 @@\n-  oop continuation = ce->cont_oop();\n+  oop continuation = ce->cont_oop(thread);\n@@ -1665,0 +1775,1 @@\n+  inline void patch_caller_links(intptr_t* sp, intptr_t* bottom);\n@@ -1687,1 +1798,2 @@\n-  ReconstructedStack(intptr_t* base, int thaw_size, int argsize) : _base(base), _thaw_size(thaw_size), _argsize(argsize) {\n+  ReconstructedStack(intptr_t* base, int thaw_size, int argsize)\n+  : _base(base), _thaw_size(thaw_size - (argsize == 0 ? frame::metadata_words_at_top : 0)), _argsize(argsize) {\n@@ -1691,1 +1803,1 @@\n-    assert(_base - 1 <= top() + total_size() + frame::metadata_words, \"missed entry frame\");\n+    assert(_base - 1 <= top() + total_size() + frame::metadata_words_at_bottom, \"missed entry frame\");\n@@ -1696,0 +1808,1 @@\n+  int entry_frame_extension() const { return _argsize + (_argsize > 0 ? frame::metadata_words_at_top : 0); }\n@@ -1699,1 +1812,1 @@\n-  intptr_t* bottom_sp() const { return ContinuationHelper::frame_align_pointer(_base - _argsize); }\n+  intptr_t* bottom_sp() const { return ContinuationHelper::frame_align_pointer(_base - entry_frame_extension()); }\n@@ -1703,2 +1816,2 @@\n-  intptr_t* top() const { return sp() - frame::metadata_words;  }\n-  int total_size() const { return _thaw_size + frame::metadata_words; }\n+  intptr_t* top() const { return sp() - frame::metadata_words_at_bottom;  }\n+  int total_size() const { return _thaw_size + frame::metadata_words_at_bottom; }\n@@ -1739,1 +1852,1 @@\n-  return frame_size + argsize;\n+  return frame_size + argsize + frame::metadata_words_at_top;\n@@ -1797,1 +1910,1 @@\n-  const bool is_last = empty && chunk->is_parent_null<typename ConfigT::OopT>();\n+  const bool is_last = empty && chunk->parent() == NULL;\n@@ -1800,2 +1913,2 @@\n-  log_develop_trace(continuations)(\"thaw_fast partial: %d is_last: %d empty: %d size: %d argsize: %d\",\n-                              partial, is_last, empty, thaw_size, argsize);\n+  log_develop_trace(continuations)(\"thaw_fast partial: %d is_last: %d empty: %d size: %d argsize: %d entrySP: \" PTR_FORMAT,\n+                              partial, is_last, empty, thaw_size, argsize, p2i(_cont.entrySP()));\n@@ -1805,2 +1918,2 @@\n-  \/\/ also copy metadata words\n-  copy_from_chunk(chunk_sp - frame::metadata_words, rs.top(), rs.total_size());\n+  \/\/ also copy metadata words at frame bottom\n+  copy_from_chunk(chunk_sp - frame::metadata_words_at_bottom, rs.top(), rs.total_size());\n@@ -1816,0 +1929,3 @@\n+  \/\/ insert the back links from callee to caller frames\n+  patch_caller_links(rs.top(), rs.top() + rs.total_size());\n+\n@@ -1878,1 +1994,0 @@\n-    \/\/ TODO ZGC: this is where we'd want to restore color to the oops\n@@ -2002,1 +2117,1 @@\n-    ContinuationHelper::InterpretedFrame::patch_sender_sp(f, caller.unextended_sp());\n+    ContinuationHelper::InterpretedFrame::patch_sender_sp(f, caller);\n@@ -2033,1 +2148,1 @@\n-  intptr_t* const stack_frame_top = f.sp();\n+  intptr_t* const stack_frame_top = f.sp() + frame::metadata_words_at_top;\n@@ -2035,1 +2150,1 @@\n-  intptr_t* const heap_frame_top = hf.unextended_sp();\n+  intptr_t* const heap_frame_top = hf.unextended_sp() + frame::metadata_words_at_top;\n@@ -2044,1 +2159,1 @@\n-  \/\/ on AArch64 we add padding between the locals and the rest of the frame to keep the fp 16-byte-aligned\n+  \/\/ on AArch64\/PPC64 we add padding between the locals and the rest of the frame to keep the fp 16-byte-aligned\n@@ -2104,3 +2219,4 @@\n-  intptr_t* from = heap_frame_top - frame::metadata_words;\n-  intptr_t* to   = stack_frame_top - frame::metadata_words;\n-  int sz = fsize + frame::metadata_words;\n+  intptr_t* from = heap_frame_top - frame::metadata_words_at_bottom;\n+  intptr_t* to   = stack_frame_top - frame::metadata_words_at_bottom;\n+  \/\/ copy metadata, except the metadata at the top of the (unextended) entry frame\n+  int sz = fsize + frame::metadata_words_at_bottom + (is_bottom_frame && added_argsize == 0 ? 0 : frame::metadata_words_at_top);\n@@ -2140,1 +2256,1 @@\n-    clear_bitmap_bits(heap_frame_top + ContinuationHelper::CompiledFrame::size(hf), added_argsize);\n+    clear_bitmap_bits(heap_frame_top + ContinuationHelper::CompiledFrame::size(hf) + frame::metadata_words_at_top, added_argsize);\n@@ -2213,1 +2329,1 @@\n-  if ((intptr_t)f.sp() % frame::frame_alignment != 0) {\n+  if (!is_aligned(f.sp(), frame::frame_alignment)) {\n@@ -2215,1 +2331,1 @@\n-    f.set_sp(f.sp() - 1);\n+    f.set_sp(align_down(f.sp(), frame::frame_alignment));\n@@ -2243,1 +2359,1 @@\n-  assert(f.sp() - frame::metadata_words >= _top_stack_address, \"overwrote past thawing space\"\n+  assert(f.sp() - frame::metadata_words_at_bottom >= _top_stack_address, \"overwrote past thawing space\"\n@@ -2263,1 +2379,1 @@\n-  oop oopCont = entry->cont_oop();\n+  oop oopCont = entry->cont_oop(thread);\n@@ -2269,1 +2385,1 @@\n-  assert(entry->is_virtual_thread() == (entry->scope() == java_lang_VirtualThread::vthread_scope()), \"\");\n+  assert(entry->is_virtual_thread() == (entry->scope(thread) == java_lang_VirtualThread::vthread_scope()), \"\");\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":200,"deletions":84,"binary":false,"changes":284,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-  static inline intptr_t* sender_unextended_sp(const frame& f);\n+  static inline intptr_t* callers_sp(const frame& f);\n@@ -98,1 +98,1 @@\n-  static void patch_sender_sp(frame& f, intptr_t* sp);\n+  static void patch_sender_sp(frame& f, const frame& caller);\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -109,2 +109,0 @@\n-  static inline bool is_parent_null(oop chunk); \/\/ bypasses barriers for a faster test\n-  template<typename P>\n@@ -134,9 +132,7 @@\n- \/\/ cont oop's processing is essential for the chunk's GC protocol\n-  static inline oop cont(oop chunk);\n-  static inline void set_cont(oop chunk, oop value);\n-  template<typename P>\n-  static inline oop cont_raw(oop chunk);\n-  template<typename P>\n-  static inline void set_cont_raw(oop chunk, oop value);\n-  template<DecoratorSet decorators>\n-  static inline void set_cont_access(oop chunk, oop value);\n+  \/\/ cont oop's processing is essential for the chunk's GC protocol\n+   static inline oop cont(oop chunk);\n+   static inline void set_cont(oop chunk, oop value);\n+   template<typename P>\n+   static inline void set_cont_raw(oop chunk, oop value);\n+   template<DecoratorSet decorators>\n+   static inline void set_cont_access(oop chunk, oop value);\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.hpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -90,5 +90,0 @@\n-template<typename P>\n-inline bool jdk_internal_vm_StackChunk::is_parent_null(oop chunk) {\n-  return (oop)RawAccess<>::oop_load(chunk->field_addr<P>(_parent_offset)) == NULL;\n-}\n-\n@@ -113,5 +108,0 @@\n-template<typename P>\n-inline oop jdk_internal_vm_StackChunk::cont_raw(oop chunk) {\n-  return (oop)RawAccess<>::oop_load(chunk->field_addr<P>(_cont_offset));\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.inline.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  assert(_entry == nullptr || _continuation == _entry->cont_oop(),\n+  assert(_entry == nullptr || _continuation == _entry->cont_oop(map->thread()),\n@@ -48,1 +48,1 @@\n-    p2i( (oopDesc*)_continuation), p2i((oopDesc*)_entry->cont_oop()), p2i(entrySP()));\n+    p2i( (oopDesc*)_continuation), p2i((oopDesc*)_entry->cont_oop(map->thread())), p2i(entrySP()));\n","filename":"src\/hotspot\/share\/runtime\/continuationWrapper.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-    _tail = (stackChunkOop)badOop;\n+    *reinterpret_cast<intptr_t*>(&_tail) = badHeapOopVal;\n@@ -128,0 +128,5 @@\n+  int entry_frame_extension() const {\n+    \/\/ the entry frame is extended if the bottom frame has stack arguments\n+    assert(_entry->argsize() >= 0, \"\");\n+    return _entry->argsize() == 0 ? _entry->argsize() : _entry->argsize() + frame::metadata_words_at_top;\n+  }\n@@ -147,2 +152,0 @@\n-  assert(_continuation == _entry->cont_oop(), \"cont: \" INTPTR_FORMAT \" entry: \" INTPTR_FORMAT \" entry_sp: \"\n-         INTPTR_FORMAT, p2i((oopDesc*)_continuation), p2i((oopDesc*)_entry->cont_oop()), p2i(entrySP()));\n","filename":"src\/hotspot\/share\/runtime\/continuationWrapper.inline.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -747,0 +747,1 @@\n+  assert(thread == JavaThread::current(), \"pre-condition\");\n@@ -1736,0 +1737,1 @@\n+  assert(thread == JavaThread::current(), \"pre-condition\");\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1632,1 +1632,8 @@\n-          && (strncmp(fv.description, \"interpreter_frame_\", 18) == 0 || strstr(fv.description, \" method \"))) {\n+#if !defined(PPC64)\n+          && (strncmp(fv.description, \"interpreter_frame_\", 18) == 0 || strstr(fv.description, \" method \"))\n+#else  \/\/ !defined(PPC64)\n+          && (strcmp(fv.description, \"sender_sp\") == 0 || strcmp(fv.description, \"top_frame_sp\") == 0 ||\n+              strcmp(fv.description, \"esp\") == 0 || strcmp(fv.description, \"monitors\") == 0 ||\n+              strcmp(fv.description, \"locals\") == 0 || strstr(fv.description, \" method \"))\n+#endif \/\/!defined(PPC64)\n+          ) {\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -326,0 +326,3 @@\n+  product(bool, UseChaCha20Intrinsics, false, DIAGNOSTIC,                   \\\n+          \"Use intrinsics for the vectorized version of ChaCha20\")          \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1385,0 +1385,11 @@\n+\n+  \/\/ The continuation oops are really on the stack. But there is typically at most\n+  \/\/ one of those per thread, so we handle them here in the oops_do_no_frames part\n+  \/\/ so that we don't have to sprinkle as many stack watermark checks where these\n+  \/\/ oops are used. We just need to make sure the thread has started processing.\n+  ContinuationEntry* entry = _cont_entry;\n+  while (entry != nullptr) {\n+    f->do_oop((oop*)entry->cont_addr());\n+    f->do_oop((oop*)entry->chunk_addr());\n+    entry = entry->parent();\n+  }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -359,1 +359,0 @@\n-  block->_planned_capacity = block_size_in_oops;\n@@ -553,16 +552,0 @@\n-class CountJNIHandleClosure: public OopClosure {\n-private:\n-  int _count;\n-public:\n-  CountJNIHandleClosure(): _count(0) {}\n-  virtual void do_oop(oop* ooph) { _count++; }\n-  virtual void do_oop(narrowOop* unused) { ShouldNotReachHere(); }\n-  int count() { return _count; }\n-};\n-\n-const size_t JNIHandleBlock::get_number_of_live_handles() {\n-  CountJNIHandleClosure counter;\n-  oops_do(&counter);\n-  return counter.count();\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -150,2 +150,0 @@\n-  \/\/ Check JNI, \"planned capacity\" for current frame (or push\/ensure)\n-  size_t          _planned_capacity;\n@@ -182,5 +180,0 @@\n-  \/\/ Checked JNI support\n-  void set_planned_capacity(size_t planned_capacity) { _planned_capacity = planned_capacity; }\n-  const size_t get_planned_capacity() { return _planned_capacity; }\n-  const size_t get_number_of_live_handles();\n-\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -72,1 +72,0 @@\n-Mutex*   MethodData_lock              = NULL;\n@@ -300,1 +299,0 @@\n-  def(MethodData_lock              , PaddedMutex  , safepoint);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-extern Mutex*   MethodData_lock;                 \/\/ a lock on installation of method data\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-  \/\/    between UTC and and local time.\n+  \/\/    between UTC and local time.\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -453,1 +453,3 @@\n-  jint doppel = SharedRuntime::f2i(x);\n+  union {jfloat f; jint i;} bits;\n+  bits.f = x;\n+  jint doppel = bits.i;\n@@ -470,1 +472,1 @@\n-  jint exp = 0x7f800000 & doppel;\n+  jint exp = ((0x7f800000 & doppel) >> (24 - 1)) - 127;\n@@ -504,0 +506,1 @@\n+  union {jfloat f; jint i;} bits;\n@@ -519,3 +522,9 @@\n-  }else if (hf_exp == 16) {\n-    return (hf_significand_bits == 0) ? sign * float_infinity : (SharedRuntime::i2f((hf_sign_bit << 16) | 0x7f800000 |\n-           (hf_significand_bits << significand_shift)));\n+  } else if (hf_exp == 16) {\n+    if (hf_significand_bits == 0) {\n+      bits.i = 0x7f800000;\n+      return sign * bits.f;\n+    } else {\n+      bits.i = (hf_sign_bit << 16) | 0x7f800000 |\n+               (hf_significand_bits << significand_shift);\n+      return bits.f;\n+    }\n@@ -525,1 +534,1 @@\n-  int float_exp_bits = (hf_exp + 127) << (24 - 1);\n+  jint float_exp_bits = (hf_exp + 127) << (24 - 1);\n@@ -528,1 +537,4 @@\n-  return SharedRuntime::i2f((hf_sign_bit << 16) | float_exp_bits | (hf_significand_bits << significand_shift));\n+  bits.i = (hf_sign_bit << 16) | float_exp_bits |\n+           (hf_significand_bits << significand_shift);\n+\n+  return bits.f;\n@@ -1115,0 +1127,2 @@\n+  assert(current == JavaThread::current(), \"pre-condition\");\n+\n@@ -1129,0 +1143,1 @@\n+  assert(current == JavaThread::current(), \"pre-condition\");\n@@ -2319,0 +2334,1 @@\n+  assert(current == JavaThread::current(), \"pre-condition\");\n@@ -3129,1 +3145,1 @@\n-#if defined(AARCH64)\n+#if defined(AARCH64) || defined(PPC64)\n@@ -3133,1 +3149,5 @@\n-      buffer.initialize_consts_size(8);\n+      \/\/ On PPC64 the continuation enter intrinsic needs the constant pool for the compiled\n+      \/\/ static java call that is resolved in the runtime.\n+      if (PPC64_ONLY(method->is_continuation_enter_intrinsic() &&) true) {\n+        buffer.initialize_consts_size(8 PPC64_ONLY(+ 24));\n+      }\n@@ -3267,0 +3287,2 @@\n+  assert(current == JavaThread::current(), \"pre-condition\");\n+\n@@ -3401,0 +3423,1 @@\n+  assert(current == JavaThread::current(), \"pre-condition\");\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":32,"deletions":9,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -126,0 +126,50 @@\n+\/\/ StackChunkFrameStream<frame_kind>::frame_size() returns the words required to\n+\/\/ store the given frame as the only frame in a StackChunk. This is the size of the\n+\/\/ frame itself plus its stack arguments plus metadata at the caller's frame top (1)\n+\/\/\n+\/\/ |====================|          ---\n+\/\/ | F0's stackargs     |           ^\n+\/\/ |                    |           |\n+\/\/ |--------------------|           |\n+\/\/ | metadata@top       | <- caller's sp\n+\/\/ |====================|           |\n+\/\/ | metadata@bottom(2) |           |\n+\/\/ |--------------------|\n+\/\/ |                    |       size S0\n+\/\/ | Frame F0           |                 ---     |====================|          ---\n+\/\/ |                    |           |      ^      | F1's stackargs     |           ^\n+\/\/ |                    |           |      |      |                    |           |\n+\/\/ |--------------------|           |   overlap   |--------------------|           |\n+\/\/ | metadata@top(1)    |<- sp      v      v      | metadata@top       | <- caller's sp\n+\/\/ |====================|          ---    ---     |====================|           |\n+\/\/                                                | metadata@bottom    |           |\n+\/\/           |                                    |--------------------|\n+\/\/           |                                    | Frame F1           |       size S1\n+\/\/      Stack Growth                              | (F0's callee)      |\n+\/\/           |                                    |                    |           |\n+\/\/           |                                    |                    |           |\n+\/\/           v                                    |--------------------|           |\n+\/\/                                                | metadata@top       |<- sp      v\n+\/\/                                                |====================|          ---\n+\/\/\n+\/\/ 2 frames of the same kind (interpreted or compiled) overlap. So the total\n+\/\/ size required in the StackChunk is S0 + S1 - overlap, where the overlap is\n+\/\/ the size of F1's stackargs plus frame::metadata_words_at_top.\n+\/\/\n+\/\/ The callers of frame_size() are supposed to deduct the overlap.  The bottom\n+\/\/ frame in the StackChunk obviously does not overlap with it's caller, as it is\n+\/\/ in the parent chunk.\n+\/\/\n+\/\/ There is no overlap if caller\/callee are of different kinds. In that case the\n+\/\/ caller is extended to accomodate the callee's stack arguments. The extension\n+\/\/ is not counted though in the caller's size, so there is indeed no overlap.\n+\/\/\n+\/\/ See ppc implementation of StackChunkFrameStream<frame_kind>::interpreter_frame_size()\n+\/\/ for more details.\n+\/\/\n+\/\/ (1) Metadata at frame top (see frame::metadata_words_at_top)\n+\/\/     Part of the overlap. Used on ppc64, empty on x86_64, aarch64\n+\/\/ (2) Metadata at the frame bottom (see frame::metadata_words_at_bottom)\n+\/\/     Not part of the overlap.\n+\/\/     Used on x86_64 (saved rbp, ret. addr.), aarch64. Empty on ppc64.\n+\/\/\n@@ -129,1 +179,1 @@\n-                          : cb()->frame_size() + stack_argsize();\n+                          : cb()->frame_size() + stack_argsize() + frame::metadata_words_at_top;\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.inline.hpp","additions":51,"deletions":1,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -44,12 +44,0 @@\n-\n-template <typename OopT>\n-static oop read_oop_local(OopT* p) {\n-  \/\/ We can't do a native access directly from p because load barriers\n-  \/\/ may self-heal. If that happens on a base pointer for compressed oops,\n-  \/\/ then there will be a crash later on. Only the stack watermark API is\n-  \/\/ allowed to heal oops, because it heals derived pointers before their\n-  \/\/ corresponding base pointers.\n-  oop obj = RawAccess<>::oop_load(p);\n-  return NativeAccess<>::oop_load(&obj);\n-}\n-\n@@ -64,2 +52,74 @@\n-template StackValue* StackValue::create_stack_value(ScopeValue*, address, const RegisterMap*);\n-template StackValue* StackValue::create_stack_value(ScopeValue*, address, const SmallRegisterMap*);\n+static oop oop_from_oop_location(stackChunkOop chunk, void* addr) {\n+  if (addr == nullptr) {\n+    return nullptr;\n+  }\n+\n+  if (UseCompressedOops) {\n+    \/\/ When compressed oops is enabled, an oop location may\n+    \/\/ contain narrow oop values - we deal with that here\n+\n+    if (chunk != NULL && chunk->has_bitmap()) {\n+      \/\/ Transformed stack chunk with narrow oops\n+      return chunk->load_oop((narrowOop*)addr);\n+    }\n+\n+#ifdef _LP64\n+    if (CompressedOops::is_base(*(void**)addr)) {\n+      \/\/ Compiled code may produce decoded oop = narrow_oop_base\n+      \/\/ when a narrow oop implicit null check is used.\n+      \/\/ The narrow_oop_base could be NULL or be the address\n+      \/\/ of the page below heap. Use NULL value for both cases.\n+      return nullptr;\n+    }\n+#endif\n+  }\n+\n+  if (chunk != NULL) {\n+    \/\/ Load oop from chunk\n+    return chunk->load_oop((oop*)addr);\n+  }\n+\n+  \/\/ Load oop from stack\n+  return *(oop*)addr;\n+}\n+\n+static oop oop_from_narrowOop_location(stackChunkOop chunk, void* addr, bool is_register) {\n+  assert(UseCompressedOops, \"Narrow oops should not exist\");\n+  assert(addr != nullptr, \"Not expecting null address\");\n+  narrowOop* narrow_addr;\n+  if (is_register) {\n+    \/\/ The callee has no clue whether the register holds an int,\n+    \/\/ long or is unused.  He always saves a long.  Here we know\n+    \/\/ a long was saved, but we only want an int back.  Narrow the\n+    \/\/ saved long to the int that the JVM wants.  We can't just\n+    \/\/ use narrow_oop_cast directly, because we don't know what\n+    \/\/ the high bits of the value might be.\n+    narrow_addr = ((narrowOop*)addr) BIG_ENDIAN_ONLY(+ 1);\n+  } else {\n+    narrow_addr = (narrowOop*)addr;\n+  }\n+\n+  if (chunk != NULL) {\n+    \/\/ Load oop from chunk\n+    return chunk->load_oop(narrow_addr);\n+  }\n+\n+  \/\/ Load oop from stack\n+  return CompressedOops::decode(*narrow_addr);\n+}\n+\n+StackValue* StackValue::create_stack_value_from_oop_location(stackChunkOop chunk, void* addr) {\n+  oop val = oop_from_oop_location(chunk, addr);\n+  assert(oopDesc::is_oop_or_null(val), \"bad oop found at \" INTPTR_FORMAT \" in_cont: %d compressed: %d\",\n+         p2i(addr), chunk != NULL, chunk != NULL && chunk->has_bitmap() && UseCompressedOops);\n+  Handle h(Thread::current(), val); \/\/ Wrap a handle around the oop\n+  return new StackValue(h);\n+}\n+\n+StackValue* StackValue::create_stack_value_from_narrowOop_location(stackChunkOop chunk, void* addr, bool is_register) {\n+  oop val = oop_from_narrowOop_location(chunk, addr, is_register);\n+  assert(oopDesc::is_oop_or_null(val), \"bad oop found at \" INTPTR_FORMAT \" in_cont: %d compressed: %d\",\n+         p2i(addr), chunk != NULL, chunk != NULL && chunk->has_bitmap() && UseCompressedOops);\n+  Handle h(Thread::current(), val); \/\/ Wrap a handle around the oop\n+  return new StackValue(h);\n+}\n@@ -69,0 +129,1 @@\n+  stackChunkOop chunk = reg_map->stack_chunk()();\n@@ -114,22 +175,2 @@\n-    case Location::narrowoop: {\n-      assert(UseCompressedOops, \"\");\n-      union { intptr_t p; narrowOop noop;} value;\n-      value.p = (intptr_t) CONST64(0xDEADDEAFDEADDEAF);\n-      if (loc.is_register()) {\n-        \/\/ The callee has no clue whether the register holds an int,\n-        \/\/ long or is unused.  He always saves a long.  Here we know\n-        \/\/ a long was saved, but we only want an int back.  Narrow the\n-        \/\/ saved long to the int that the JVM wants.  We can't just\n-        \/\/ use narrow_oop_cast directly, because we don't know what\n-        \/\/ the high bits of the value might be.\n-        static_assert(sizeof(narrowOop) == sizeof(juint), \"size mismatch\");\n-        juint narrow_value = (juint) *(julong*)value_addr;\n-        value.noop = CompressedOops::narrow_oop_cast(narrow_value);\n-      } else {\n-        value.noop = *(narrowOop*) value_addr;\n-      }\n-      \/\/ Decode narrowoop\n-      oop val = read_oop_local(&value.noop);\n-      Handle h(Thread::current(), val); \/\/ Wrap a handle around the oop\n-      return new StackValue(h);\n-    }\n+    case Location::narrowoop:\n+      return create_stack_value_from_narrowOop_location(reg_map->stack_chunk()(), (void*)value_addr, loc.is_register());\n@@ -137,22 +178,2 @@\n-    case Location::oop: {\n-      oop val;\n-      if (reg_map->in_cont() && reg_map->stack_chunk()->has_bitmap() && UseCompressedOops) {\n-        val = CompressedOops::decode(*(narrowOop*)value_addr);\n-      } else {\n-        val = *(oop *)value_addr;\n-      }\n-#ifdef _LP64\n-      if (CompressedOops::is_base(val)) {\n-         \/\/ Compiled code may produce decoded oop = narrow_oop_base\n-         \/\/ when a narrow oop implicit null check is used.\n-         \/\/ The narrow_oop_base could be NULL or be the address\n-         \/\/ of the page below heap. Use NULL value for both cases.\n-         val = (oop)NULL;\n-      }\n-#endif\n-      val = read_oop_local(&val);\n-      assert(oopDesc::is_oop_or_null(val), \"bad oop found at \" INTPTR_FORMAT \" in_cont: %d compressed: %d\",\n-        p2i(value_addr), reg_map->in_cont(), reg_map->in_cont() && reg_map->stack_chunk()->has_bitmap() && UseCompressedOops);\n-      Handle h(Thread::current(), val); \/\/ Wrap a handle around the oop\n-      return new StackValue(h);\n-    }\n+    case Location::oop:\n+      return create_stack_value_from_oop_location(reg_map->stack_chunk()(), (void*)value_addr);\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":79,"deletions":58,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -111,0 +111,3 @@\n+  static StackValue* create_stack_value_from_oop_location(stackChunkOop chunk, void* addr);\n+  static StackValue* create_stack_value_from_narrowOop_location(stackChunkOop chunk, void* addr, bool is_register);\n+\n","filename":"src\/hotspot\/share\/runtime\/stackValue.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -131,0 +131,1 @@\n+address StubRoutines::_chacha20Block                       = NULL;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -212,0 +212,1 @@\n+  static address _chacha20Block;\n@@ -391,0 +392,1 @@\n+  static address chacha20Block()         { return _chacha20Block; }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -335,2 +335,1 @@\n-  assert(index >= 0 &&\n-         index < oop_mask.number_of_entries(), \"invariant\");\n+  assert(index >= 0 && index < oop_mask.number_of_entries(), \"invariant\");\n@@ -340,11 +339,1 @@\n-    oop obj = NULL;\n-    if (addr != NULL) {\n-      if (chunk != NULL) {\n-        obj = (chunk->has_bitmap() && UseCompressedOops) ? (oop)HeapAccess<>::oop_load((narrowOop*)addr) : HeapAccess<>::oop_load((oop*)addr);\n-      } else {\n-        obj = *(oop*)addr;\n-      }\n-    }\n-    \/\/ reference (oop) \"r\"\n-    Handle h(Thread::current(), obj);\n-    return new StackValue(h);\n+    return StackValue::create_stack_value_from_oop_location(chunk, (void*)addr);\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    return _cont_entry->cont_oop();\n+    return _cont_entry->cont_oop(_reg_map.thread());\n@@ -85,1 +85,2 @@\n-      assert(_cont_entry->cont_oop() != NULL, \"_cont: \" INTPTR_FORMAT, p2i(_cont_entry));\n+      \/\/ Reading oops are only safe if process_frames() is true, and we fix the oops.\n+      assert(!_reg_map.process_frames() || _cont_entry->cont_oop(_reg_map.thread()) != NULL, \"_cont: \" INTPTR_FORMAT, p2i(_cont_entry));\n@@ -90,1 +91,1 @@\n-          (_continuation_scope.not_null() && _cont_entry->scope() == _continuation_scope())) {\n+          (_continuation_scope.not_null() && _cont_entry->scope(_reg_map.thread()) == _continuation_scope())) {\n","filename":"src\/hotspot\/share\/runtime\/vframe.inline.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -544,0 +544,1 @@\n+     static_field(StubRoutines,                _chacha20Block,                                address)                               \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-  const uint8_t _flags;\n+  const MEMFLAGS _flags;\n@@ -122,1 +122,1 @@\n-  inline MEMFLAGS flags() const { return (MEMFLAGS)_flags; }\n+  inline MEMFLAGS flags() const { return _flags; }\n","filename":"src\/hotspot\/share\/services\/mallocHeader.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  : _size(size), _mst_marker(mst_marker), _flags(NMTUtil::flag_to_index(flags)),\n+  : _size(size), _mst_marker(mst_marker), _flags(flags),\n","filename":"src\/hotspot\/share\/services\/mallocHeader.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -323,1 +323,1 @@\n-void BitMap::at_put_range(idx_t start_offset, idx_t end_offset, bool value) {\n+void BitMap::at_put_range(idx_t beg_offset, idx_t end_offset, bool value) {\n@@ -325,1 +325,1 @@\n-    set_range(start_offset, end_offset);\n+    set_range(beg_offset, end_offset);\n@@ -327,1 +327,1 @@\n-    clear_range(start_offset, end_offset);\n+    clear_range(beg_offset, end_offset);\n","filename":"src\/hotspot\/share\/utilities\/bitMap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-  \/\/ - aligned_right is true if r_index is a priori on a bm_word_t boundary.\n+  \/\/ - aligned_right is true if end is a priori on a bm_word_t boundary.\n@@ -102,1 +102,1 @@\n-  inline idx_t get_next_bit_impl(idx_t l_index, idx_t r_index) const;\n+  inline idx_t get_next_bit_impl(idx_t beg, idx_t end) const;\n@@ -265,5 +265,5 @@\n-  \/\/ Looking for 1's and 0's at indices equal to or greater than \"l_index\",\n-  \/\/ stopping if none has been found before \"r_index\", and returning\n-  \/\/ \"r_index\" (which must be at most \"size\") in that case.\n-  idx_t get_next_one_offset (idx_t l_index, idx_t r_index) const;\n-  idx_t get_next_zero_offset(idx_t l_index, idx_t r_index) const;\n+  \/\/ Looking for 1's and 0's at indices equal to or greater than \"beg\",\n+  \/\/ stopping if none has been found before \"end\", and returning\n+  \/\/ \"end\" (which must be at most \"size\") in that case.\n+  idx_t get_next_one_offset (idx_t beg, idx_t end) const;\n+  idx_t get_next_zero_offset(idx_t beg, idx_t end) const;\n@@ -278,1 +278,1 @@\n-  \/\/ Like \"get_next_one_offset\", except requires that \"r_index\" is\n+  \/\/ Like \"get_next_one_offset\", except requires that \"end\" is\n@@ -280,1 +280,1 @@\n-  idx_t get_next_one_offset_aligned_right(idx_t l_index, idx_t r_index) const;\n+  idx_t get_next_one_offset_aligned_right(idx_t beg, idx_t end) const;\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+      _next = 0;\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTableTasks.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -531,4 +531,23 @@\n-# define BEGIN if (_current_step == 0) { _current_step = __LINE__;\n-# define STEP(s) } if (_current_step < __LINE__) { _current_step = __LINE__; _current_step_info = s; \\\n-  record_step_start_time(); _step_did_timeout = false;\n-# define END clear_step_start_time(); }\n+# define BEGIN                                             \\\n+  if (_current_step == 0) {                                \\\n+    _current_step = __LINE__;                              \\\n+    {\n+      \/\/ [Begin logic]\n+\n+# define STEP_IF(s,cond)                                   \\\n+    }                                                      \\\n+  }                                                        \\\n+  if (_current_step < __LINE__) {                          \\\n+    _current_step = __LINE__;                              \\\n+    _current_step_info = s;                                \\\n+    record_step_start_time();                              \\\n+    _step_did_timeout = false;                             \\\n+    if ((cond)) {\n+      \/\/ [Step logic]\n+\n+# define STEP(s) STEP_IF(s, true)\n+\n+# define END                                               \\\n+    }                                                      \\\n+    clear_step_start_time();                               \\\n+  }\n@@ -544,1 +563,0 @@\n-\n@@ -561,20 +579,15 @@\n-  STEP(\"test secondary crash 1\")\n-    if (_verbose && TestCrashInErrorHandler == TEST_SECONDARY_CRASH) {\n-      st->print_cr(\"Will crash now (TestCrashInErrorHandler=%u)...\",\n-        TestCrashInErrorHandler);\n-      controlled_crash(TestCrashInErrorHandler);\n-    }\n-\n-  STEP(\"test secondary crash 2\")\n-    if (_verbose && TestCrashInErrorHandler == TEST_SECONDARY_CRASH) {\n-      st->print_cr(\"Will crash now (TestCrashInErrorHandler=%u)...\",\n-        TestCrashInErrorHandler);\n-      controlled_crash(TestCrashInErrorHandler);\n-    }\n-\n-  STEP(\"test missing ResourceMark does not crash\")\n-    if (_verbose && TestCrashInErrorHandler == TEST_RESOURCE_MARK_CRASH) {\n-      stringStream message;\n-      message.print(\"This is a message with no ResourceMark\");\n-      tty->print_cr(\"%s\", message.as_string());\n-    }\n+  STEP_IF(\"test secondary crash 1\", _verbose && TestCrashInErrorHandler == TEST_SECONDARY_CRASH)\n+    st->print_cr(\"Will crash now (TestCrashInErrorHandler=%u)...\",\n+      TestCrashInErrorHandler);\n+    controlled_crash(TestCrashInErrorHandler);\n+\n+  STEP_IF(\"test secondary crash 2\", _verbose && TestCrashInErrorHandler == TEST_SECONDARY_CRASH)\n+    st->print_cr(\"Will crash now (TestCrashInErrorHandler=%u)...\",\n+      TestCrashInErrorHandler);\n+    controlled_crash(TestCrashInErrorHandler);\n+\n+  STEP_IF(\"test missing ResourceMark does not crash\",\n+      _verbose && TestCrashInErrorHandler == TEST_RESOURCE_MARK_CRASH)\n+    stringStream message;\n+    message.print(\"This is a message with no ResourceMark\");\n+    tty->print_cr(\"%s\", message.as_string());\n@@ -586,11 +599,11 @@\n-  STEP(\"setup for test unresponsive error reporting step\")\n-    if (_verbose && TestUnresponsiveErrorHandler) {\n-      \/\/ We record reporting_start_time for this test here because we\n-      \/\/ care about the time spent executing TIMEOUT_TEST_STEP and not\n-      \/\/ about the time it took us to get here.\n-      tty->print_cr(\"Recording reporting_start_time for TestUnresponsiveErrorHandler.\");\n-      record_reporting_start_time();\n-    }\n-\n-  #define TIMEOUT_TEST_STEP STEP(\"test unresponsive error reporting step\") \\\n-    if (_verbose && TestUnresponsiveErrorHandler) { os::infinite_sleep(); }\n+  STEP_IF(\"setup for test unresponsive error reporting step\",\n+      _verbose && TestUnresponsiveErrorHandler)\n+    \/\/ We record reporting_start_time for this test here because we\n+    \/\/ care about the time spent executing TIMEOUT_TEST_STEP and not\n+    \/\/ about the time it took us to get here.\n+    tty->print_cr(\"Recording reporting_start_time for TestUnresponsiveErrorHandler.\");\n+    record_reporting_start_time();\n+\n+  #define TIMEOUT_TEST_STEP STEP_IF(\"test unresponsive error reporting step\", \\\n+      _verbose && TestUnresponsiveErrorHandler) \\\n+    os::infinite_sleep();\n@@ -603,1 +616,1 @@\n-  STEP(\"test safefetch in error handler\")\n+  STEP_IF(\"test safefetch in error handler\", _verbose && TestSafeFetchInErrorHandler)\n@@ -606,11 +619,9 @@\n-    if (_verbose && TestSafeFetchInErrorHandler) {\n-      st->print_cr(\"Will test SafeFetch...\");\n-      int* const invalid_pointer = (int*)segfault_address;\n-      const int x = 0x76543210;\n-      int i1 = SafeFetch32(invalid_pointer, x);\n-      int i2 = SafeFetch32(invalid_pointer, x);\n-      if (i1 == x && i2 == x) {\n-        st->print_cr(\"SafeFetch OK.\"); \/\/ Correctly deflected and returned default pattern\n-      } else {\n-        st->print_cr(\"??\");\n-      }\n+    st->print_cr(\"Will test SafeFetch...\");\n+    int* const invalid_pointer = (int*)segfault_address;\n+    const int x = 0x76543210;\n+    int i1 = SafeFetch32(invalid_pointer, x);\n+    int i2 = SafeFetch32(invalid_pointer, x);\n+    if (i1 == x && i2 == x) {\n+      st->print_cr(\"SafeFetch OK.\"); \/\/ Correctly deflected and returned default pattern\n+    } else {\n+      st->print_cr(\"??\");\n@@ -621,35 +632,34 @@\n-\n-     switch(static_cast<unsigned int>(_id)) {\n-       case OOM_MALLOC_ERROR:\n-       case OOM_MMAP_ERROR:\n-       case OOM_MPROTECT_ERROR:\n-         if (_size) {\n-           st->print(\"# Native memory allocation \");\n-           st->print((_id == (int)OOM_MALLOC_ERROR) ? \"(malloc) failed to allocate \" :\n-                     (_id == (int)OOM_MMAP_ERROR)   ? \"(mmap) failed to map \" :\n-                                                      \"(mprotect) failed to protect \");\n-           jio_snprintf(buf, sizeof(buf), SIZE_FORMAT, _size);\n-           st->print(\"%s\", buf);\n-           st->print(\" bytes\");\n-           if (strlen(_detail_msg) > 0) {\n-             st->print(\" for \");\n-             st->print(\"%s\", _detail_msg);\n-           }\n-           st->cr();\n-         } else {\n-           if (strlen(_detail_msg) > 0) {\n-             st->print(\"# \");\n-             st->print_cr(\"%s\", _detail_msg);\n-           }\n-         }\n-         \/\/ In error file give some solutions\n-         if (_verbose) {\n-           print_oom_reasons(st);\n-         } else {\n-           return;  \/\/ that's enough for the screen\n-         }\n-         break;\n-       case INTERNAL_ERROR:\n-       default:\n-         break;\n-     }\n+    switch(static_cast<unsigned int>(_id)) {\n+      case OOM_MALLOC_ERROR:\n+      case OOM_MMAP_ERROR:\n+      case OOM_MPROTECT_ERROR:\n+        if (_size) {\n+          st->print(\"# Native memory allocation \");\n+          st->print((_id == (int)OOM_MALLOC_ERROR) ? \"(malloc) failed to allocate \" :\n+                    (_id == (int)OOM_MMAP_ERROR)   ? \"(mmap) failed to map \" :\n+                                                    \"(mprotect) failed to protect \");\n+          jio_snprintf(buf, sizeof(buf), SIZE_FORMAT, _size);\n+          st->print(\"%s\", buf);\n+          st->print(\" bytes\");\n+          if (strlen(_detail_msg) > 0) {\n+            st->print(\" for \");\n+            st->print(\"%s\", _detail_msg);\n+          }\n+          st->cr();\n+        } else {\n+          if (strlen(_detail_msg) > 0) {\n+            st->print(\"# \");\n+            st->print_cr(\"%s\", _detail_msg);\n+          }\n+        }\n+        \/\/ In error file give some solutions\n+        if (_verbose) {\n+          print_oom_reasons(st);\n+        } else {\n+          return;  \/\/ that's enough for the screen\n+        }\n+        break;\n+      case INTERNAL_ERROR:\n+      default:\n+        break;\n+    }\n@@ -658,18 +668,17 @@\n-\n-     st->print_cr(\"#\");\n-     st->print(\"#  \");\n-     \/\/ Is it an OS exception\/signal?\n-     if (os::exception_name(_id, buf, sizeof(buf))) {\n-       st->print(\"%s\", buf);\n-       st->print(\" (0x%x)\", _id);                \/\/ signal number\n-       st->print(\" at pc=\" PTR_FORMAT, p2i(_pc));\n-       if (_siginfo != NULL && os::signal_sent_by_kill(_siginfo)) {\n-         st->print(\" (sent by kill)\");\n-       }\n-     } else {\n-       if (should_report_bug(_id)) {\n-         st->print(\"Internal Error\");\n-       } else {\n-         st->print(\"Out of Memory Error\");\n-       }\n-       if (_filename != NULL && _lineno > 0) {\n+    st->print_cr(\"#\");\n+    st->print(\"#  \");\n+    \/\/ Is it an OS exception\/signal?\n+    if (os::exception_name(_id, buf, sizeof(buf))) {\n+      st->print(\"%s\", buf);\n+      st->print(\" (0x%x)\", _id);                \/\/ signal number\n+      st->print(\" at pc=\" PTR_FORMAT, p2i(_pc));\n+      if (_siginfo != NULL && os::signal_sent_by_kill(_siginfo)) {\n+        st->print(\" (sent by kill)\");\n+      }\n+    } else {\n+      if (should_report_bug(_id)) {\n+        st->print(\"Internal Error\");\n+      } else {\n+        st->print(\"Out of Memory Error\");\n+      }\n+      if (_filename != NULL && _lineno > 0) {\n@@ -677,2 +686,2 @@\n-         \/\/ In product mode chop off pathname\n-         const char *file = get_filename_only();\n+        \/\/ In product mode chop off pathname\n+        const char *file = get_filename_only();\n@@ -680,1 +689,1 @@\n-         const char *file = _filename;\n+        const char *file = _filename;\n@@ -682,5 +691,5 @@\n-         st->print(\" (%s:%d)\", file, _lineno);\n-       } else {\n-         st->print(\" (0x%x)\", _id);\n-       }\n-     }\n+        st->print(\" (%s:%d)\", file, _lineno);\n+      } else {\n+        st->print(\" (0x%x)\", _id);\n+      }\n+    }\n@@ -689,0 +698,4 @@\n+    \/\/ process id, thread id\n+    st->print(\", pid=%d\", os::current_process_id());\n+    st->print(\", tid=\" UINTX_FORMAT, os::current_thread_id());\n+    st->cr();\n@@ -690,15 +703,7 @@\n-     \/\/ process id, thread id\n-     st->print(\", pid=%d\", os::current_process_id());\n-     st->print(\", tid=\" UINTX_FORMAT, os::current_thread_id());\n-     st->cr();\n-\n-  STEP(\"printing error message\")\n-\n-     if (should_report_bug(_id)) {  \/\/ already printed the message.\n-       \/\/ error message\n-       if (strlen(_detail_msg) > 0) {\n-         st->print_cr(\"#  %s: %s\", _message ? _message : \"Error\", _detail_msg);\n-       } else if (_message) {\n-         st->print_cr(\"#  Error: %s\", _message);\n-       }\n-     }\n+  STEP_IF(\"printing error message\", should_report_bug(_id)) \/\/ already printed the message.\n+    \/\/ error message\n+    if (strlen(_detail_msg) > 0) {\n+      st->print_cr(\"#  %s: %s\", _message ? _message : \"Error\", _detail_msg);\n+    } else if (_message) {\n+      st->print_cr(\"#  Error: %s\", _message);\n+    }\n@@ -707,0 +712,1 @@\n+    report_vm_version(st, buf, sizeof(buf));\n@@ -708,13 +714,8 @@\n-     report_vm_version(st, buf, sizeof(buf));\n-\n-  STEP(\"printing problematic frame\")\n-\n-     \/\/ Print current frame if we have a context (i.e. it's a crash)\n-     if (_context) {\n-       st->print_cr(\"# Problematic frame:\");\n-       st->print(\"# \");\n-       frame fr = os::fetch_frame_from_context(_context);\n-       fr.print_on_error(st, buf, sizeof(buf));\n-       st->cr();\n-       st->print_cr(\"#\");\n-     }\n+  STEP_IF(\"printing problematic frame\", _context != nullptr)\n+    \/\/ Print current frame if we have a context (i.e. it's a crash)\n+    st->print_cr(\"# Problematic frame:\");\n+    st->print(\"# \");\n+    frame fr = os::fetch_frame_from_context(_context);\n+    fr.print_on_error(st, buf, sizeof(buf));\n+    st->cr();\n+    st->print_cr(\"#\");\n@@ -739,23 +740,2 @@\n-  STEP(\"printing bug submit message\")\n-\n-     if (should_submit_bug_report(_id) && _verbose) {\n-       print_bug_submit_message(st, _thread);\n-     }\n-\n-  STEP(\"printing summary\")\n-\n-     if (_verbose) {\n-       st->cr();\n-       st->print_cr(\"---------------  S U M M A R Y ------------\");\n-       st->cr();\n-     }\n-\n-  STEP(\"printing VM option summary\")\n-\n-     if (_verbose) {\n-       \/\/ VM options\n-       Arguments::print_summary_on(st);\n-       st->cr();\n-     }\n-\n-  STEP(\"printing summary machine and OS info\")\n+  STEP_IF(\"printing bug submit message\", should_submit_bug_report(_id) && _verbose)\n+    print_bug_submit_message(st, _thread);\n@@ -763,31 +743,4 @@\n-     if (_verbose) {\n-       os::print_summary_info(st, buf, sizeof(buf));\n-     }\n-\n-  STEP(\"printing date and time\")\n-\n-     if (_verbose) {\n-       os::print_date_and_time(st, buf, sizeof(buf));\n-     }\n-\n-  STEP(\"printing thread\")\n-\n-     if (_verbose) {\n-       st->cr();\n-       st->print_cr(\"---------------  T H R E A D  ---------------\");\n-       st->cr();\n-     }\n-\n-  STEP(\"printing current thread\")\n-\n-     \/\/ current thread\n-     if (_verbose) {\n-       if (_thread) {\n-         st->print(\"Current thread (\" PTR_FORMAT \"):  \", p2i(_thread));\n-         _thread->print_on_error(st, buf, sizeof(buf));\n-         st->cr();\n-       } else {\n-         st->print_cr(\"Current thread is native thread\");\n-       }\n-       st->cr();\n-     }\n+  STEP_IF(\"printing summary\", _verbose)\n+    st->cr();\n+    st->print_cr(\"---------------  S U M M A R Y ------------\");\n+    st->cr();\n@@ -795,1 +748,4 @@\n-  STEP(\"printing current compile task\")\n+  STEP_IF(\"printing VM option summary\", _verbose)\n+    \/\/ VM options\n+    Arguments::print_summary_on(st);\n+    st->cr();\n@@ -797,118 +753,2 @@\n-     if (_verbose && _thread && _thread->is_Compiler_thread()) {\n-        CompilerThread* t = (CompilerThread*)_thread;\n-        if (t->task()) {\n-           st->cr();\n-           st->print_cr(\"Current CompileTask:\");\n-           t->task()->print_line_on_error(st, buf, sizeof(buf));\n-           st->cr();\n-        }\n-     }\n-\n-  STEP(\"printing stack bounds\")\n-\n-     if (_verbose) {\n-       st->print(\"Stack: \");\n-\n-       address stack_top;\n-       size_t stack_size;\n-\n-       if (_thread) {\n-          stack_top = _thread->stack_base();\n-          stack_size = _thread->stack_size();\n-       } else {\n-          stack_top = os::current_stack_base();\n-          stack_size = os::current_stack_size();\n-       }\n-\n-       address stack_bottom = stack_top - stack_size;\n-       st->print(\"[\" PTR_FORMAT \",\" PTR_FORMAT \"]\", p2i(stack_bottom), p2i(stack_top));\n-\n-       frame fr = _context ? os::fetch_frame_from_context(_context)\n-                           : os::current_frame();\n-\n-       if (fr.sp()) {\n-         st->print(\",  sp=\" PTR_FORMAT, p2i(fr.sp()));\n-         size_t free_stack_size = pointer_delta(fr.sp(), stack_bottom, 1024);\n-         st->print(\",  free space=\" SIZE_FORMAT \"k\", free_stack_size);\n-       }\n-\n-       st->cr();\n-     }\n-\n-  STEP(\"printing native stack (with source info)\")\n-\n-   if (_verbose) {\n-     if (os::platform_print_native_stack(st, _context, buf, sizeof(buf))) {\n-       \/\/ We have printed the native stack in platform-specific code\n-       \/\/ Windows\/x64 needs special handling.\n-     } else {\n-       frame fr = _context ? os::fetch_frame_from_context(_context)\n-                           : os::current_frame();\n-\n-       print_native_stack(st, fr, _thread, true, buf, sizeof(buf));\n-       _print_native_stack_used = true;\n-     }\n-     print_native_stack_succeeded = true;\n-   }\n-\n-  STEP(\"retry printing native stack (no source info)\")\n-\n-   if (_verbose && !print_native_stack_succeeded) {\n-     st->cr();\n-     st->print_cr(\"Retrying call stack printing without source information...\");\n-     frame fr = _context ? os::fetch_frame_from_context(_context) : os::current_frame();\n-     print_native_stack(st, fr, _thread, false, buf, sizeof(buf));\n-     _print_native_stack_used = true;\n-   }\n-\n-  STEP(\"printing Java stack\")\n-\n-     if (_verbose && _thread && _thread->is_Java_thread()) {\n-       print_stack_trace(st, JavaThread::cast(_thread), buf, sizeof(buf));\n-     }\n-\n-  STEP(\"printing target Java thread stack\")\n-\n-     \/\/ printing Java thread stack trace if it is involved in GC crash\n-     if (_verbose && _thread && (_thread->is_Named_thread())) {\n-       Thread* thread = ((NamedThread *)_thread)->processed_thread();\n-       if (thread != NULL && thread->is_Java_thread()) {\n-         JavaThread* jt = JavaThread::cast(thread);\n-         st->print_cr(\"JavaThread \" PTR_FORMAT \" (nid = %d) was being processed\", p2i(jt), jt->osthread()->thread_id());\n-         print_stack_trace(st, jt, buf, sizeof(buf), true);\n-       }\n-     }\n-\n-  STEP(\"printing siginfo\")\n-\n-     \/\/ signal no, signal code, address that caused the fault\n-     if (_verbose && _siginfo) {\n-       st->cr();\n-       os::print_siginfo(st, _siginfo);\n-       st->cr();\n-     }\n-\n-  STEP(\"CDS archive access warning\")\n-\n-     \/\/ Print an explicit hint if we crashed on access to the CDS archive.\n-     if (_verbose && _siginfo) {\n-       check_failing_cds_access(st, _siginfo);\n-       st->cr();\n-     }\n-\n-  STEP(\"printing registers\")\n-\n-     \/\/ printing registers\n-     if (_verbose && _context) {\n-       os::print_context(st, _context);\n-       st->cr();\n-     }\n-\n-  STEP(\"printing register info\")\n-\n-     \/\/ decode register contents if possible\n-     if (_verbose && _context && _thread && Universe::is_fully_initialized()) {\n-       ResourceMark rm(_thread);\n-       os::print_register_info(st, _context);\n-       st->cr();\n-     }\n+  STEP_IF(\"printing summary machine and OS info\", _verbose)\n+    os::print_summary_info(st, buf, sizeof(buf));\n@@ -916,1 +756,2 @@\n-  STEP(\"printing top of stack, instructions near pc\")\n+  STEP_IF(\"printing date and time\", _verbose)\n+    os::print_date_and_time(st, buf, sizeof(buf));\n@@ -918,24 +759,4 @@\n-     \/\/ printing top of stack, instructions near pc\n-     if (_verbose && _context) {\n-       os::print_tos_pc(st, _context);\n-       st->cr();\n-     }\n-\n-  STEP(\"inspecting top of stack\")\n-\n-     \/\/ decode stack contents if possible\n-     if (_verbose && _context && _thread && Universe::is_fully_initialized()) {\n-       frame fr = os::fetch_frame_from_context(_context);\n-       const int slots = 8;\n-       const intptr_t *start = fr.sp();\n-       const intptr_t *end = start + slots;\n-       if (is_aligned(start, sizeof(intptr_t)) && os::is_readable_range(start, end)) {\n-         st->print_cr(\"Stack slot to memory mapping:\");\n-         for (int i = 0; i < slots; ++i) {\n-           st->print(\"stack at sp + %d slots: \", i);\n-           ResourceMark rm(_thread);\n-           os::print_location(st, *(start + i));\n-         }\n-       }\n-       st->cr();\n-     }\n+  STEP_IF(\"printing thread\", _verbose)\n+    st->cr();\n+    st->print_cr(\"---------------  T H R E A D  ---------------\");\n+    st->cr();\n@@ -943,1 +764,10 @@\n-  STEP(\"printing code blobs if possible\")\n+  STEP_IF(\"printing current thread\", _verbose)\n+    \/\/ current thread\n+    if (_thread) {\n+      st->print(\"Current thread (\" PTR_FORMAT \"):  \", p2i(_thread));\n+      _thread->print_on_error(st, buf, sizeof(buf));\n+      st->cr();\n+    } else {\n+      st->print_cr(\"Current thread is native thread\");\n+    }\n+    st->cr();\n@@ -945,55 +775,9 @@\n-     if (_verbose) {\n-       const int printed_capacity = max_error_log_print_code;\n-       address printed[printed_capacity];\n-       printed[0] = nullptr;\n-       int printed_len = 0;\n-       \/\/ Even though ErrorLogPrintCodeLimit is ranged checked\n-       \/\/ during argument parsing, there's no way to prevent it\n-       \/\/ subsequently (i.e., after parsing) being set to a\n-       \/\/ value outside the range.\n-       int limit = MIN2(ErrorLogPrintCodeLimit, printed_capacity);\n-       if (limit > 0) {\n-         \/\/ Scan the native stack\n-         if (!_print_native_stack_used) {\n-           \/\/ Only try to print code of the crashing frame since\n-           \/\/ the native stack cannot be walked with next_frame.\n-           if (print_code(st, _thread, _pc, true, printed, printed_capacity)) {\n-             printed_len++;\n-           }\n-         } else {\n-           frame fr = _context ? os::fetch_frame_from_context(_context)\n-                               : os::current_frame();\n-           while (printed_len < limit && fr.pc() != nullptr) {\n-             if (print_code(st, _thread, fr.pc(), fr.pc() == _pc, printed, printed_capacity)) {\n-               printed_len++;\n-             }\n-             fr = next_frame(fr, _thread);\n-           }\n-         }\n-\n-         \/\/ Scan the Java stack\n-         if (_thread != nullptr && _thread->is_Java_thread()) {\n-           JavaThread* jt = JavaThread::cast(_thread);\n-           if (jt->has_last_Java_frame()) {\n-             for (StackFrameStream sfs(jt, true \/* update *\/, true \/* process_frames *\/); printed_len < limit && !sfs.is_done(); sfs.next()) {\n-               address pc = sfs.current()->pc();\n-               if (print_code(st, _thread, pc, pc == _pc, printed, printed_capacity)) {\n-                 printed_len++;\n-               }\n-             }\n-           }\n-         }\n-       }\n-     }\n-\n-  STEP(\"printing VM operation\")\n-\n-     if (_verbose && _thread && _thread->is_VM_thread()) {\n-        VMThread* t = (VMThread*)_thread;\n-        VM_Operation* op = t->vm_operation();\n-        if (op) {\n-          op->print_on_error(st);\n-          st->cr();\n-          st->cr();\n-        }\n-     }\n+  STEP_IF(\"printing current compile task\",\n+      _verbose && _thread != nullptr && _thread->is_Compiler_thread())\n+    CompilerThread* t = (CompilerThread*)_thread;\n+    if (t->task()) {\n+        st->cr();\n+        st->print_cr(\"Current CompileTask:\");\n+        t->task()->print_line_on_error(st, buf, sizeof(buf));\n+        st->cr();\n+    }\n@@ -1001,1 +785,2 @@\n-  STEP(\"printing process\")\n+  STEP_IF(\"printing stack bounds\", _verbose)\n+    st->print(\"Stack: \");\n@@ -1003,5 +788,2 @@\n-     if (_verbose) {\n-       st->cr();\n-       st->print_cr(\"---------------  P R O C E S S  ---------------\");\n-       st->cr();\n-     }\n+    address stack_top;\n+    size_t stack_size;\n@@ -1009,1 +791,7 @@\n-  STEP(\"printing user info\")\n+    if (_thread) {\n+      stack_top = _thread->stack_base();\n+      stack_size = _thread->stack_size();\n+    } else {\n+      stack_top = os::current_stack_base();\n+      stack_size = os::current_stack_size();\n+    }\n@@ -1011,3 +799,2 @@\n-     if (ExtensiveErrorReports && _verbose) {\n-       os::print_user_info(st);\n-     }\n+    address stack_bottom = stack_top - stack_size;\n+    st->print(\"[\" PTR_FORMAT \",\" PTR_FORMAT \"]\", p2i(stack_bottom), p2i(stack_top));\n@@ -1015,1 +802,2 @@\n-  STEP(\"printing all threads\")\n+    frame fr = _context ? os::fetch_frame_from_context(_context)\n+                        : os::current_frame();\n@@ -1017,5 +805,5 @@\n-     \/\/ all threads\n-     if (_verbose && _thread) {\n-       Threads::print_on_error(st, _thread, buf, sizeof(buf));\n-       st->cr();\n-     }\n+    if (fr.sp()) {\n+      st->print(\",  sp=\" PTR_FORMAT, p2i(fr.sp()));\n+      size_t free_stack_size = pointer_delta(fr.sp(), stack_bottom, 1024);\n+      st->print(\",  free space=\" SIZE_FORMAT \"k\", free_stack_size);\n+    }\n@@ -1023,1 +811,1 @@\n-  STEP(\"printing VM state\")\n+    st->cr();\n@@ -1025,3 +813,7 @@\n-     if (_verbose) {\n-       \/\/ Safepoint state\n-       st->print(\"VM state: \");\n+  STEP_IF(\"printing native stack (with source info)\", _verbose)\n+    if (os::platform_print_native_stack(st, _context, buf, sizeof(buf))) {\n+      \/\/ We have printed the native stack in platform-specific code\n+      \/\/ Windows\/x64 needs special handling.\n+    } else {\n+      frame fr = _context ? os::fetch_frame_from_context(_context)\n+                          : os::current_frame();\n@@ -1029,3 +821,4 @@\n-       if (SafepointSynchronize::is_synchronizing()) st->print(\"synchronizing\");\n-       else if (SafepointSynchronize::is_at_safepoint()) st->print(\"at safepoint\");\n-       else st->print(\"not at safepoint\");\n+      print_native_stack(st, fr, _thread, true, buf, sizeof(buf));\n+      _print_native_stack_used = true;\n+    }\n+    print_native_stack_succeeded = true;\n@@ -1033,11 +826,11 @@\n-       \/\/ Also see if error occurred during initialization or shutdown\n-       if (!Universe::is_fully_initialized()) {\n-         st->print(\" (not fully initialized)\");\n-       } else if (VM_Exit::vm_exited()) {\n-         st->print(\" (shutting down)\");\n-       } else {\n-         st->print(\" (normal execution)\");\n-       }\n-       st->cr();\n-       st->cr();\n-     }\n+  STEP_IF(\"retry printing native stack (no source info)\", _verbose && !print_native_stack_succeeded)\n+    st->cr();\n+    st->print_cr(\"Retrying call stack printing without source information...\");\n+    frame fr = _context ? os::fetch_frame_from_context(_context) : os::current_frame();\n+    print_native_stack(st, fr, _thread, false, buf, sizeof(buf));\n+    _print_native_stack_used = true;\n+\n+  STEP_IF(\"printing Java stack\", _verbose && _thread && _thread->is_Java_thread())\n+    if (_verbose && _thread && _thread->is_Java_thread()) {\n+      print_stack_trace(st, JavaThread::cast(_thread), buf, sizeof(buf));\n+    }\n@@ -1045,1 +838,9 @@\n-  STEP(\"printing owned locks on error\")\n+  STEP_IF(\"printing target Java thread stack\",\n+      _verbose && _thread != nullptr && (_thread->is_Named_thread()))\n+    \/\/ printing Java thread stack trace if it is involved in GC crash\n+    Thread* thread = ((NamedThread *)_thread)->processed_thread();\n+    if (thread != NULL && thread->is_Java_thread()) {\n+      JavaThread* jt = JavaThread::cast(thread);\n+      st->print_cr(\"JavaThread \" PTR_FORMAT \" (nid = %d) was being processed\", p2i(jt), jt->osthread()->thread_id());\n+      print_stack_trace(st, jt, buf, sizeof(buf), true);\n+    }\n@@ -1047,5 +848,5 @@\n-     \/\/ mutexes\/monitors that currently have an owner\n-     if (_verbose) {\n-       print_owned_locks_on_error(st);\n-       st->cr();\n-     }\n+  STEP_IF(\"printing siginfo\", _verbose && _siginfo != nullptr)\n+    \/\/ signal no, signal code, address that caused the fault\n+    st->cr();\n+    os::print_siginfo(st, _siginfo);\n+    st->cr();\n@@ -1053,1 +854,4 @@\n-  STEP(\"printing number of OutOfMemoryError and StackOverflow exceptions\")\n+  STEP_IF(\"CDS archive access warning\", _verbose && _siginfo != nullptr)\n+    \/\/ Print an explicit hint if we crashed on access to the CDS archive.\n+    check_failing_cds_access(st, _siginfo);\n+    st->cr();\n@@ -1055,5 +859,4 @@\n-     if (_verbose && Exceptions::has_exception_counts()) {\n-       st->print_cr(\"OutOfMemory and StackOverflow Exception counts:\");\n-       Exceptions::print_exception_counts_on_error(st);\n-       st->cr();\n-     }\n+  STEP_IF(\"printing registers\", _verbose && _context != nullptr)\n+    \/\/ printing registers\n+    os::print_context(st, _context);\n+    st->cr();\n@@ -1061,2 +864,6 @@\n-#ifdef _LP64\n-  STEP(\"printing compressed oops mode\")\n+  STEP_IF(\"printing register info\",\n+      _verbose && _context != nullptr && _thread != nullptr && Universe::is_fully_initialized())\n+    \/\/ decode register contents if possible\n+    ResourceMark rm(_thread);\n+    os::print_register_info(st, _context);\n+    st->cr();\n@@ -1064,4 +871,0 @@\n-     if (_verbose && UseCompressedOops) {\n-       CompressedOops::print_mode(st);\n-       st->cr();\n-     }\n@@ -1069,1 +872,1 @@\n-  STEP(\"printing compressed klass pointers mode\")\n+  STEP(\"printing top of stack, instructions near pc\")\n@@ -1071,7 +874,4 @@\n-     if (_verbose && UseCompressedClassPointers) {\n-       CDS_ONLY(MetaspaceShared::print_on(st);)\n-       Metaspace::print_compressed_class_space(st);\n-       CompressedKlassPointers::print_mode(st);\n-       st->cr();\n-     }\n-#endif\n+  STEP_IF(\"printing top of stack, instructions near pc\", _verbose && _context)\n+    \/\/ printing top of stack, instructions near pc\n+    os::print_tos_pc(st, _context);\n+    st->cr();\n@@ -1079,1 +879,16 @@\n-  STEP(\"printing heap information\")\n+  STEP_IF(\"inspecting top of stack\",\n+      _verbose && _context != nullptr && _thread != nullptr && Universe::is_fully_initialized())\n+    \/\/ decode stack contents if possible\n+    frame fr = os::fetch_frame_from_context(_context);\n+    const int slots = 8;\n+    const intptr_t *start = fr.sp();\n+    const intptr_t *end = start + slots;\n+    if (is_aligned(start, sizeof(intptr_t)) && os::is_readable_range(start, end)) {\n+      st->print_cr(\"Stack slot to memory mapping:\");\n+      for (int i = 0; i < slots; ++i) {\n+        st->print(\"stack at sp + %d slots: \", i);\n+        ResourceMark rm(_thread);\n+        os::print_location(st, *(start + i));\n+      }\n+    }\n+    st->cr();\n@@ -1081,2 +896,1 @@\n-     if (_verbose) {\n-       GCLogPrecious::print_on_error(st);\n+  STEP(\"printing code blobs if possible\")\n@@ -1084,4 +898,28 @@\n-       if (Universe::heap() != NULL) {\n-         Universe::heap()->print_on_error(st);\n-         st->cr();\n-       }\n+  STEP_IF(\"printing code blobs if possible\", _verbose)\n+    const int printed_capacity = max_error_log_print_code;\n+    address printed[printed_capacity];\n+    printed[0] = nullptr;\n+    int printed_len = 0;\n+    \/\/ Even though ErrorLogPrintCodeLimit is ranged checked\n+    \/\/ during argument parsing, there's no way to prevent it\n+    \/\/ subsequently (i.e., after parsing) being set to a\n+    \/\/ value outside the range.\n+    int limit = MIN2(ErrorLogPrintCodeLimit, printed_capacity);\n+    if (limit > 0) {\n+      \/\/ Scan the native stack\n+      if (!_print_native_stack_used) {\n+        \/\/ Only try to print code of the crashing frame since\n+        \/\/ the native stack cannot be walked with next_frame.\n+        if (print_code(st, _thread, _pc, true, printed, printed_capacity)) {\n+          printed_len++;\n+        }\n+      } else {\n+        frame fr = _context ? os::fetch_frame_from_context(_context)\n+                            : os::current_frame();\n+        while (printed_len < limit && fr.pc() != nullptr) {\n+          if (print_code(st, _thread, fr.pc(), fr.pc() == _pc, printed, printed_capacity)) {\n+            printed_len++;\n+          }\n+          fr = next_frame(fr, _thread);\n+        }\n+      }\n@@ -1089,5 +927,13 @@\n-       if (Universe::is_fully_initialized()) {\n-         st->print_cr(\"Polling page: \" PTR_FORMAT, p2i(SafepointMechanism::get_polling_page()));\n-         st->cr();\n-       }\n-     }\n+      \/\/ Scan the Java stack\n+      if (_thread != nullptr && _thread->is_Java_thread()) {\n+        JavaThread* jt = JavaThread::cast(_thread);\n+        if (jt->has_last_Java_frame()) {\n+          for (StackFrameStream sfs(jt, true \/* update *\/, true \/* process_frames *\/); printed_len < limit && !sfs.is_done(); sfs.next()) {\n+            address pc = sfs.current()->pc();\n+            if (print_code(st, _thread, pc, pc == _pc, printed, printed_capacity)) {\n+              printed_len++;\n+            }\n+          }\n+        }\n+      }\n+    }\n@@ -1095,1 +941,8 @@\n-  STEP(\"printing metaspace information\")\n+  STEP_IF(\"printing VM operation\", _verbose && _thread != nullptr && _thread->is_VM_thread())\n+    VMThread* t = (VMThread*)_thread;\n+    VM_Operation* op = t->vm_operation();\n+    if (op) {\n+      op->print_on_error(st);\n+      st->cr();\n+      st->cr();\n+    }\n@@ -1097,4 +950,1 @@\n-     if (_verbose && Universe::is_fully_initialized()) {\n-       st->print_cr(\"Metaspace:\");\n-       MetaspaceUtils::print_basic_report(st, 0);\n-     }\n+  STEP(\"printing process\")\n@@ -1102,1 +952,4 @@\n-  STEP(\"printing code cache information\")\n+  STEP_IF(\"printing process\", _verbose)\n+    st->cr();\n+    st->print_cr(\"---------------  P R O C E S S  ---------------\");\n+    st->cr();\n@@ -1104,5 +957,2 @@\n-     if (_verbose && Universe::is_fully_initialized()) {\n-       \/\/ print code cache information before vm abort\n-       CodeCache::print_summary(st);\n-       st->cr();\n-     }\n+  STEP_IF(\"printing user info\", ExtensiveErrorReports && _verbose)\n+    os::print_user_info(st);\n@@ -1110,1 +960,4 @@\n-  STEP(\"printing ring buffers\")\n+  STEP_IF(\"printing all threads\", _verbose && _thread)\n+    \/\/ all threads\n+    Threads::print_on_error(st, _thread, buf, sizeof(buf));\n+    st->cr();\n@@ -1112,4 +965,3 @@\n-     if (_verbose) {\n-       Events::print_all(st);\n-       st->cr();\n-     }\n+  STEP_IF(\"printing VM state\", _verbose)\n+    \/\/ Safepoint state\n+    st->print(\"VM state: \");\n@@ -1117,1 +969,3 @@\n-  STEP(\"printing dynamic libraries\")\n+    if (SafepointSynchronize::is_synchronizing()) st->print(\"synchronizing\");\n+    else if (SafepointSynchronize::is_at_safepoint()) st->print(\"at safepoint\");\n+    else st->print(\"not at safepoint\");\n@@ -1119,5 +973,10 @@\n-     if (_verbose) {\n-       \/\/ dynamic libraries, or memory map\n-       os::print_dll_info(st);\n-       st->cr();\n-     }\n+    \/\/ Also see if error occurred during initialization or shutdown\n+    if (!Universe::is_fully_initialized()) {\n+      st->print(\" (not fully initialized)\");\n+    } else if (VM_Exit::vm_exited()) {\n+      st->print(\" (shutting down)\");\n+    } else {\n+      st->print(\" (normal execution)\");\n+    }\n+    st->cr();\n+    st->cr();\n@@ -1125,1 +984,4 @@\n-  STEP(\"printing native decoder state\")\n+  STEP_IF(\"printing owned locks on error\", _verbose)\n+    \/\/ mutexes\/monitors that currently have an owner\n+    print_owned_locks_on_error(st);\n+    st->cr();\n@@ -1127,4 +989,5 @@\n-     if (_verbose) {\n-       Decoder::print_state_on(st);\n-       st->cr();\n-     }\n+  STEP_IF(\"printing number of OutOfMemoryError and StackOverflow exceptions\",\n+      _verbose && Exceptions::has_exception_counts())\n+    st->print_cr(\"OutOfMemory and StackOverflow Exception counts:\");\n+    Exceptions::print_exception_counts_on_error(st);\n+    st->cr();\n@@ -1132,1 +995,4 @@\n-  STEP(\"printing VM options\")\n+#ifdef _LP64\n+  STEP_IF(\"printing compressed oops mode\", _verbose && UseCompressedOops)\n+    CompressedOops::print_mode(st);\n+    st->cr();\n@@ -1134,5 +1000,6 @@\n-     if (_verbose) {\n-       \/\/ VM options\n-       Arguments::print_on(st);\n-       st->cr();\n-     }\n+  STEP_IF(\"printing compressed klass pointers mode\", _verbose && UseCompressedClassPointers)\n+    CDS_ONLY(MetaspaceShared::print_on(st);)\n+    Metaspace::print_compressed_class_space(st);\n+    CompressedKlassPointers::print_mode(st);\n+    st->cr();\n+#endif\n@@ -1140,1 +1007,2 @@\n-  STEP(\"printing flags\")\n+  STEP_IF(\"printing heap information\", _verbose)\n+    GCLogPrecious::print_on_error(st);\n@@ -1142,6 +1010,2 @@\n-    if (_verbose) {\n-      JVMFlag::printFlags(\n-        st,\n-        true, \/\/ with comments\n-        false, \/\/ no ranges\n-        true); \/\/ skip defaults\n+    if (Universe::heap() != NULL) {\n+      Universe::heap()->print_on_error(st);\n@@ -1151,11 +1015,2 @@\n-  STEP(\"printing warning if internal testing API used\")\n-\n-     if (WhiteBox::used()) {\n-       st->print_cr(\"Unsupported internal testing APIs have been used.\");\n-       st->cr();\n-     }\n-\n-  STEP(\"printing log configuration\")\n-    if (_verbose){\n-      st->print_cr(\"Logging:\");\n-      LogConfiguration::describe_current_configuration(st);\n+    if (Universe::is_fully_initialized()) {\n+      st->print_cr(\"Polling page: \" PTR_FORMAT, p2i(SafepointMechanism::get_polling_page()));\n@@ -1165,1 +1020,12 @@\n-  STEP(\"printing all environment variables\")\n+  STEP_IF(\"printing metaspace information\", _verbose && Universe::is_fully_initialized())\n+    st->print_cr(\"Metaspace:\");\n+    MetaspaceUtils::print_basic_report(st, 0);\n+\n+  STEP_IF(\"printing code cache information\", _verbose && Universe::is_fully_initialized())\n+    \/\/ print code cache information before vm abort\n+    CodeCache::print_summary(st);\n+    st->cr();\n+\n+  STEP_IF(\"printing ring buffers\", _verbose)\n+    Events::print_all(st);\n+    st->cr();\n@@ -1167,4 +1033,4 @@\n-     if (_verbose) {\n-       os::print_environment_variables(st, env_list);\n-       st->cr();\n-     }\n+  STEP_IF(\"printing dynamic libraries\", _verbose)\n+    \/\/ dynamic libraries, or memory map\n+    os::print_dll_info(st);\n+    st->cr();\n@@ -1172,1 +1038,3 @@\n-  STEP(\"printing locale settings\")\n+  STEP_IF(\"printing native decoder state\", _verbose)\n+    Decoder::print_state_on(st);\n+    st->cr();\n@@ -1174,4 +1042,4 @@\n-     if (_verbose) {\n-       os::print_active_locale(st);\n-       st->cr();\n-     }\n+  STEP_IF(\"printing VM options\", _verbose)\n+    \/\/ VM options\n+    Arguments::print_on(st);\n+    st->cr();\n@@ -1179,1 +1047,7 @@\n-  STEP(\"printing signal handlers\")\n+  STEP_IF(\"printing flags\", _verbose)\n+    JVMFlag::printFlags(\n+      st,\n+      true, \/\/ with comments\n+      false, \/\/ no ranges\n+      true); \/\/ skip defaults\n+    st->cr();\n@@ -1181,4 +1055,3 @@\n-     if (_verbose) {\n-       os::print_signal_handlers(st, buf, sizeof(buf));\n-       st->cr();\n-     }\n+  STEP_IF(\"printing warning if internal testing API used\", WhiteBox::used())\n+    st->print_cr(\"Unsupported internal testing APIs have been used.\");\n+    st->cr();\n@@ -1186,4 +1059,4 @@\n-  STEP(\"Native Memory Tracking\")\n-     if (_verbose) {\n-       MemTracker::error_report(st);\n-     }\n+  STEP_IF(\"printing log configuration\", _verbose)\n+    st->print_cr(\"Logging:\");\n+    LogConfiguration::describe_current_configuration(st);\n+    st->cr();\n@@ -1191,1 +1064,3 @@\n-  STEP(\"printing system\")\n+  STEP_IF(\"printing all environment variables\", _verbose)\n+    os::print_environment_variables(st, env_list);\n+    st->cr();\n@@ -1193,5 +1068,3 @@\n-     if (_verbose) {\n-       st->cr();\n-       st->print_cr(\"---------------  S Y S T E M  ---------------\");\n-       st->cr();\n-     }\n+  STEP_IF(\"printing locale settings\", _verbose)\n+    os::print_active_locale(st);\n+    st->cr();\n@@ -1199,1 +1072,3 @@\n-  STEP(\"printing OS information\")\n+  STEP_IF(\"printing signal handlers\", _verbose)\n+    os::print_signal_handlers(st, buf, sizeof(buf));\n+    st->cr();\n@@ -1201,4 +1076,2 @@\n-     if (_verbose) {\n-       os::print_os_info(st);\n-       st->cr();\n-     }\n+  STEP_IF(\"Native Memory Tracking\", _verbose)\n+    MemTracker::error_report(st);\n@@ -1206,5 +1079,4 @@\n-  STEP(\"printing CPU info\")\n-     if (_verbose) {\n-       os::print_cpu_info(st, buf, sizeof(buf));\n-       st->cr();\n-     }\n+  STEP_IF(\"printing system\", _verbose)\n+    st->cr();\n+    st->print_cr(\"---------------  S Y S T E M  ---------------\");\n+    st->cr();\n@@ -1212,1 +1084,3 @@\n-  STEP(\"printing memory info\")\n+  STEP_IF(\"printing OS information\", _verbose)\n+    os::print_os_info(st);\n+    st->cr();\n@@ -1214,4 +1088,3 @@\n-     if (_verbose) {\n-       os::print_memory_info(st);\n-       st->cr();\n-     }\n+  STEP_IF(\"printing CPU info\", _verbose)\n+    os::print_cpu_info(st, buf, sizeof(buf));\n+    st->cr();\n@@ -1219,1 +1092,3 @@\n-  STEP(\"printing internal vm info\")\n+  STEP_IF(\"printing memory info\", _verbose)\n+    os::print_memory_info(st);\n+    st->cr();\n@@ -1221,4 +1096,3 @@\n-     if (_verbose) {\n-       st->print_cr(\"vm_info: %s\", VM_Version::internal_vm_info_string());\n-       st->cr();\n-     }\n+  STEP_IF(\"printing internal vm info\", _verbose)\n+    st->print_cr(\"vm_info: %s\", VM_Version::internal_vm_info_string());\n+    st->cr();\n@@ -1227,5 +1101,2 @@\n-  STEP(\"printing end marker\")\n-\n-     if (_verbose) {\n-       st->print_cr(\"END.\");\n-     }\n+  STEP_IF(\"printing end marker\", _verbose)\n+    st->print_cr(\"END.\");\n@@ -1236,0 +1107,1 @@\n+# undef STEP_IF\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":436,"deletions":564,"binary":false,"changes":1000,"status":"modified"},{"patch":"@@ -42,0 +42,3 @@\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n@@ -61,2 +64,3 @@\n-    private static final int KEYSTREAM_SIZE = 64;\n-    private static final int KS_SIZE_INTS = KEYSTREAM_SIZE \/ Integer.BYTES;\n+    private static final int KS_MAX_LEN = 1024;\n+    private static final int KS_BLK_SIZE = 64;\n+    private static final int KS_SIZE_INTS = KS_BLK_SIZE \/ Integer.BYTES;\n@@ -88,4 +92,3 @@\n-    \/\/ Two arrays, both implemented as 16-element integer arrays:\n-    \/\/ The base state, created at initialization time, and a working\n-    \/\/ state which is a clone of the start state, and is then modified\n-    \/\/ with the counter and the ChaCha20 block function.\n+    \/\/ The base state is created at initialization time as a 16-int array\n+    \/\/ and then is copied into either local variables for computations (Java) or\n+    \/\/ into SIMD registers (intrinsics).\n@@ -93,1 +96,0 @@\n-    private final byte[] keyStream = new byte[KEYSTREAM_SIZE];\n@@ -95,1 +97,7 @@\n-    \/\/ The offset into the current keystream\n+    \/\/ The output keystream array is sized to hold keystream output from the\n+    \/\/ implChaCha20Block method.  This can range from a single block at a time\n+    \/\/ (Java software) up to 16 blocks on x86_64 with AVX512 support.\n+    private final byte[] keyStream = new byte[KS_MAX_LEN];\n+\n+    \/\/ The keystream buffer limit and offset\n+    private int keyStrLimit;\n@@ -564,1 +572,2 @@\n-        \/\/ We can also get one block's worth of keystream created\n+        \/\/ We can also generate the first block (or blocks if intrinsics\n+        \/\/ are capable of doing multiple blocks at a time) of keystream.\n@@ -566,1 +575,3 @@\n-        generateKeystream();\n+        this.keyStrLimit = chaCha20Block(startState, counter, keyStream);\n+        this.keyStrOffset = 0;\n+        this.counter += (keyStrLimit \/ KS_BLK_SIZE);\n@@ -569,1 +580,0 @@\n-        this.keyStrOffset = 0;\n@@ -834,9 +844,12 @@\n-    \/**\n-     * Using the current state and counter create the next set of keystream\n-     * bytes.  This method will generate the next 512 bits of keystream and\n-     * return it in the {@code keyStream} parameter.  Following the\n-     * block function the counter will be incremented.\n-     *\/\n-    private void generateKeystream() {\n-        chaCha20Block(startState, counter, keyStream);\n-        counter++;\n+    @ForceInline\n+    private static int chaCha20Block(int[] initState, long counter,\n+            byte[] result) {\n+        if (initState.length != KS_SIZE_INTS || result.length != KS_MAX_LEN) {\n+            throw new IllegalArgumentException(\n+                    \"Illegal state or keystream buffer length\");\n+        }\n+\n+        \/\/ Set the counter value before sending into the underlying\n+        \/\/ private block method\n+        initState[12] = (int)counter;\n+        return implChaCha20Block(initState, result);\n@@ -848,3 +861,1 @@\n-     * @param initState the starting state, not including the counter\n-     *      value.\n-     * @param counter the counter value to apply\n+     * @param initState the starting state using the current counter value.\n@@ -854,2 +865,4 @@\n-     * @note it is the caller's responsibility to ensure that the workState\n-     * is sized the same as the initState, no checking is performed internally.\n+     * @return the number of keystream bytes generated.  In a pure Java method\n+     *      this will always be 64 bytes, but intrinsics that make use of\n+     *      AVX2 or AVX512 registers may generate multiple blocks of keystream\n+     *      in a single call and therefore may be a larger multiple of 64.\n@@ -857,2 +870,2 @@\n-    private static void chaCha20Block(int[] initState, long counter,\n-                                      byte[] result) {\n+    @IntrinsicCandidate\n+    private static int implChaCha20Block(int[] initState, byte[] result) {\n@@ -872,1 +885,1 @@\n-        int ws12 = (int)counter;\n+        int ws12 = initState[12];\n@@ -989,2 +1002,1 @@\n-        \/\/ Add the counter back into workState[12]\n-        asIntLittleEndian.set(result, 48, ws12 + (int)counter);\n+        asIntLittleEndian.set(result, 48, ws12 + initState[12]);\n@@ -994,0 +1006,2 @@\n+\n+        return KS_BLK_SIZE;\n@@ -1012,1 +1026,1 @@\n-            int ksRemain = keyStream.length - keyStrOffset;\n+            int ksRemain = keyStrLimit - keyStrOffset;\n@@ -1015,1 +1029,10 @@\n-                    generateKeystream();\n+                    \/\/ Intrinsics can do multiple blocks at once.  This means\n+                    \/\/ it may overrun the counter. In order to prevent key\n+                    \/\/ stream reuse, we adjust the key stream limit to only the\n+                    \/\/ key stream length that is calculated from unique\n+                    \/\/ counter values.\n+                    keyStrLimit = chaCha20Block(startState, counter, keyStream);\n+                    counter += (keyStrLimit \/ KS_BLK_SIZE);\n+                    if (counter > finalCounterValue) {\n+                        keyStrLimit -= (int)(counter - finalCounterValue) * 64;\n+                    }\n@@ -1017,1 +1040,1 @@\n-                    ksRemain = keyStream.length;\n+                    ksRemain = keyStrLimit;\n@@ -1063,3 +1086,4 @@\n-        \/\/ Derive the Poly1305 key from the starting state\n-        byte[] serializedKey = new byte[KEYSTREAM_SIZE];\n-        chaCha20Block(startState, 0, serializedKey);\n+        \/\/ Derive the Poly1305 key from the starting state with the counter\n+        \/\/ value forced to zero.\n+        byte[] serializedKey = new byte[KS_MAX_LEN];\n+        chaCha20Block(startState, 0L, serializedKey);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ChaCha20Cipher.java","additions":60,"deletions":36,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.security.ProviderException;\n@@ -47,1 +46,1 @@\n- * @see java.security.KeyAgreement\n+ * @see javax.crypto.KeyAgreement\n@@ -83,2 +82,0 @@\n-     *\n-     * @throws ProviderException if the key cannot be encoded\n@@ -100,2 +97,0 @@\n-     *\n-     * @throws ProviderException if the key cannot be encoded\n@@ -108,10 +103,6 @@\n-        try {\n-            byte[] xbytes = x.toByteArray();\n-            DerValue val = new DerValue(DerValue.tag_Integer, xbytes);\n-            this.key = val.toByteArray();\n-            val.clear();\n-            Arrays.fill(xbytes, (byte)0);\n-            encode();\n-        } catch (IOException e) {\n-            throw new ProviderException(\"Cannot produce ASN.1 encoding\", e);\n-        }\n+        byte[] xbytes = x.toByteArray();\n+        DerValue val = new DerValue(DerValue.tag_Integer, xbytes);\n+        this.key = val.toByteArray();\n+        val.clear();\n+        Arrays.fill(xbytes, (byte) 0);\n+        encode();\n@@ -224,2 +215,1 @@\n-            try {\n-                DerOutputStream tmp = new DerOutputStream();\n+            DerOutputStream tmp = new DerOutputStream();\n@@ -227,4 +217,4 @@\n-                \/\/\n-                \/\/ version\n-                \/\/\n-                tmp.putInteger(PKCS8_VERSION);\n+            \/\/\n+            \/\/ version\n+            \/\/\n+            tmp.putInteger(PKCS8_VERSION);\n@@ -232,4 +222,4 @@\n-                \/\/\n-                \/\/ privateKeyAlgorithm\n-                \/\/\n-                DerOutputStream algid = new DerOutputStream();\n+            \/\/\n+            \/\/ privateKeyAlgorithm\n+            \/\/\n+            DerOutputStream algid = new DerOutputStream();\n@@ -237,16 +227,16 @@\n-                \/\/ store OID\n-                algid.putOID(DHPublicKey.DH_OID);\n-                \/\/ encode parameters\n-                DerOutputStream params = new DerOutputStream();\n-                params.putInteger(this.p);\n-                params.putInteger(this.g);\n-                if (this.l != 0) {\n-                    params.putInteger(this.l);\n-                }\n-                \/\/ wrap parameters into SEQUENCE\n-                DerValue paramSequence = new DerValue(DerValue.tag_Sequence,\n-                                                      params.toByteArray());\n-                \/\/ store parameter SEQUENCE in algid\n-                algid.putDerValue(paramSequence);\n-                \/\/ wrap algid into SEQUENCE\n-                tmp.write(DerValue.tag_Sequence, algid);\n+            \/\/ store OID\n+            algid.putOID(DHPublicKey.DH_OID);\n+            \/\/ encode parameters\n+            DerOutputStream params = new DerOutputStream();\n+            params.putInteger(this.p);\n+            params.putInteger(this.g);\n+            if (this.l != 0) {\n+                params.putInteger(this.l);\n+            }\n+            \/\/ wrap parameters into SEQUENCE\n+            DerValue paramSequence = new DerValue(DerValue.tag_Sequence,\n+                    params.toByteArray());\n+            \/\/ store parameter SEQUENCE in algid\n+            algid.putDerValue(paramSequence);\n+            \/\/ wrap algid into SEQUENCE\n+            tmp.write(DerValue.tag_Sequence, algid);\n@@ -254,2 +244,2 @@\n-                \/\/ privateKey\n-                tmp.putOctetString(this.key);\n+            \/\/ privateKey\n+            tmp.putOctetString(this.key);\n@@ -257,7 +247,4 @@\n-                \/\/ make it a SEQUENCE\n-                DerValue val = DerValue.wrap(DerValue.tag_Sequence, tmp);\n-                this.encodedKey = val.toByteArray();\n-                val.clear();\n-            } catch (IOException e) {\n-                throw new AssertionError(e);\n-            }\n+            \/\/ make it a SEQUENCE\n+            DerValue val = DerValue.wrap(DerValue.tag_Sequence, tmp);\n+            this.encodedKey = val.toByteArray();\n+            val.clear();\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHPrivateKey.java","additions":39,"deletions":52,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.security.ProviderException;\n@@ -100,2 +99,0 @@\n-     *\n-     * @exception ProviderException if the key cannot be encoded\n@@ -108,7 +105,3 @@\n-        try {\n-            this.key = new DerValue(DerValue.tag_Integer,\n-                                    this.y.toByteArray()).toByteArray();\n-            this.encodedKey = getEncoded();\n-        } catch (IOException e) {\n-            throw new ProviderException(\"Cannot produce ASN.1 encoding\", e);\n-        }\n+        this.key = new DerValue(DerValue.tag_Integer,\n+                this.y.toByteArray()).toByteArray();\n+        this.encodedKey = getEncoded();\n@@ -204,2 +197,1 @@\n-            try {\n-                DerOutputStream algid = new DerOutputStream();\n+            DerOutputStream algid = new DerOutputStream();\n@@ -207,2 +199,2 @@\n-                \/\/ store oid in algid\n-                algid.putOID(DH_OID);\n+            \/\/ store oid in algid\n+            algid.putOID(DH_OID);\n@@ -210,12 +202,12 @@\n-                \/\/ encode parameters\n-                DerOutputStream params = new DerOutputStream();\n-                params.putInteger(this.p);\n-                params.putInteger(this.g);\n-                if (this.l != 0) {\n-                    params.putInteger(this.l);\n-                }\n-                \/\/ wrap parameters into SEQUENCE\n-                DerValue paramSequence = new DerValue(DerValue.tag_Sequence,\n-                                                      params.toByteArray());\n-                \/\/ store parameter SEQUENCE in algid\n-                algid.putDerValue(paramSequence);\n+            \/\/ encode parameters\n+            DerOutputStream params = new DerOutputStream();\n+            params.putInteger(this.p);\n+            params.putInteger(this.g);\n+            if (this.l != 0) {\n+                params.putInteger(this.l);\n+            }\n+            \/\/ wrap parameters into SEQUENCE\n+            DerValue paramSequence = new DerValue(DerValue.tag_Sequence,\n+                    params.toByteArray());\n+            \/\/ store parameter SEQUENCE in algid\n+            algid.putDerValue(paramSequence);\n@@ -223,3 +215,3 @@\n-                \/\/ wrap algid into SEQUENCE, and store it in key encoding\n-                DerOutputStream tmpDerKey = new DerOutputStream();\n-                tmpDerKey.write(DerValue.tag_Sequence, algid);\n+            \/\/ wrap algid into SEQUENCE, and store it in key encoding\n+            DerOutputStream tmpDerKey = new DerOutputStream();\n+            tmpDerKey.write(DerValue.tag_Sequence, algid);\n@@ -227,2 +219,2 @@\n-                \/\/ store key data\n-                tmpDerKey.putBitString(this.key);\n+            \/\/ store key data\n+            tmpDerKey.putBitString(this.key);\n@@ -230,7 +222,4 @@\n-                \/\/ wrap algid and key into SEQUENCE\n-                DerOutputStream derKey = new DerOutputStream();\n-                derKey.write(DerValue.tag_Sequence, tmpDerKey);\n-                this.encodedKey = derKey.toByteArray();\n-            } catch (IOException e) {\n-                return null;\n-            }\n+            \/\/ wrap algid and key into SEQUENCE\n+            DerOutputStream derKey = new DerOutputStream();\n+            derKey.write(DerValue.tag_Sequence, tmpDerKey);\n+            this.encodedKey = derKey.toByteArray();\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHPublicKey.java","additions":28,"deletions":39,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -110,3 +110,1 @@\n-    byte[] getEncoded()\n-        throws IOException\n-    {\n+    byte[] getEncoded() {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/EncryptedPrivateKeyInfo.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-                    t.setDaemon(true);\n+                    privilegedThreadSetDaemon(t, true);\n@@ -118,0 +118,16 @@\n+    @SuppressWarnings(\"removal\")\n+    private static void privilegedThreadSetName(Thread thread, String name) {\n+        AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n+            thread.setName(name);\n+            return null;\n+        });\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void privilegedThreadSetDaemon(Thread thread, boolean on) {\n+        AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n+            thread.setDaemon(on);\n+            return null;\n+        });\n+    }\n+\n@@ -143,2 +159,3 @@\n-                        String threadName = Thread.currentThread().getName();\n-                        Thread.currentThread().setName(\"process reaper (pid \" + pid + \")\");\n+                        Thread t = Thread.currentThread();\n+                        String threadName = t.getName();\n+                        privilegedThreadSetName(t, \"process reaper (pid \" + pid + \")\");\n@@ -175,1 +192,1 @@\n-                            Thread.currentThread().setName(threadName);\n+                            privilegedThreadSetName(t, threadName);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ProcessHandleImpl.java","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1644,1 +1644,1 @@\n-     *   is negative or larger then the length of this\n+     *   is negative or larger than the length of this\n@@ -1654,3 +1654,0 @@\n-        if (index < 0 || index > length()) {\n-            throw new IndexOutOfBoundsException();\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.reflect.Field;\n@@ -1110,1 +1111,2 @@\n-        private static final long NEXT;\n+        private static final Object NEXT_BASE;\n+        private static final long NEXT_OFFSET;\n@@ -1113,1 +1115,7 @@\n-            NEXT = U.objectFieldOffset(ThreadNumbering.class, \"next\");\n+            try {\n+                Field nextField = ThreadNumbering.class.getDeclaredField(\"next\");\n+                NEXT_BASE = U.staticFieldBase(nextField);\n+                NEXT_OFFSET = U.staticFieldOffset(nextField);\n+            } catch (NoSuchFieldException e) {\n+                throw new ExceptionInInitializerError(e);\n+            }\n@@ -1117,1 +1125,1 @@\n-            return U.getAndAddInt(ThreadNumbering.class, NEXT, 1);\n+            return U.getAndAddInt(NEXT_BASE, NEXT_OFFSET, 1);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+ * @sealedGraph\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDesc.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+ * @sealedGraph\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/CallSite.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1092,1 +1092,1 @@\n-        @Stable MethodHandle invoker;\n+        private @Stable MethodType type;\n@@ -1188,4 +1188,0 @@\n-                if (invoker == null) {\n-                    traceInterpreter(\"| getInvoker\", this);\n-                    invoker();\n-                }\n@@ -1207,3 +1203,1 @@\n-            if (invoker != null)  return invoker;\n-            \/\/ Get an invoker and cache it.\n-            return invoker = computeInvoker(methodType().form());\n+            return computeInvoker(methodType().form());\n@@ -1213,1 +1207,9 @@\n-            if (resolvedHandle != null)\n+            MethodType type = this.type;\n+            if (type == null) {\n+                this.type = type = calculateMethodType(member, resolvedHandle);\n+            }\n+            return type;\n+        }\n+\n+        private static MethodType calculateMethodType(MemberName member, MethodHandle resolvedHandle) {\n+            if (resolvedHandle != null) {\n@@ -1215,1 +1217,1 @@\n-            else\n+            } else {\n@@ -1218,0 +1220,1 @@\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -608,1 +608,5 @@\n-    @Stable private Boolean callerSensitive;       \/\/ lazily initialize\n+    \/\/  0 = not initialized (@Stable contract)\n+    \/\/  1 = initialized, CS\n+    \/\/ -1 = initialized, not CS\n+    @Stable private byte callerSensitive;\n+\n@@ -610,3 +614,3 @@\n-        Boolean cs = callerSensitive;\n-        if (cs == null) {\n-            callerSensitive = cs = Reflection.isCallerSensitive(this);\n+        byte cs = callerSensitive;\n+        if (cs == 0) {\n+            callerSensitive = cs = (byte)(Reflection.isCallerSensitive(this) ? 1 : -1);\n@@ -614,1 +618,1 @@\n-        return cs;\n+        return (cs > 0);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1534,7 +1534,4 @@\n-\n-        \/\/ Must insert leading 0 in rem if its length did not change\n-        if (rem.intLen == nlen) {\n-            rem.offset = 0;\n-            rem.value[0] = 0;\n-            rem.intLen++;\n-        }\n+        \/\/ Insert leading 0 in rem\n+        rem.offset = 0;\n+        rem.value[0] = 0;\n+        rem.intLen++;\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -189,1 +189,2 @@\n-                throw new IllegalArgumentException(\"Invalid characters in hostname\");\n+                final String message = String.format(\"Invalid character \\\\u%04x in hostname\", (int) c);\n+                throw new IllegalArgumentException(message);\n","filename":"src\/java.base\/share\/classes\/java\/net\/HostPortrange.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3557,1 +3557,1 @@\n-     * @throws NullPointerException if {@code priorityList} or {@code tags} is\n+     * @throws NullPointerException if {@code priorityList} or {@code locales} is\n","filename":"src\/java.base\/share\/classes\/java\/util\/Locale.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.lang.reflect.Field;\n@@ -1530,0 +1531,1 @@\n+    private static final Object POOLIDS_BASE;\n@@ -1548,1 +1550,1 @@\n-        return U.getAndAddInt(ForkJoinPool.class, POOLIDS, x);\n+        return U.getAndAddInt(POOLIDS_BASE, POOLIDS, x);\n@@ -3766,1 +3768,3 @@\n-            POOLIDS = U.staticFieldOffset(klass.getDeclaredField(\"poolIds\"));\n+            Field poolIdsField = klass.getDeclaredField(\"poolIds\");\n+            POOLIDS_BASE = U.staticFieldBase(poolIdsField);\n+            POOLIDS = U.staticFieldOffset(poolIdsField);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -328,4 +328,0 @@\n-     * <p>\n-     * When a new thread is created, its current subject is the same as\n-     * the one of its parent thread, and will not change even if\n-     * its parent thread's current subject is changed to another value.\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/Subject.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        @JEP(number=427, title=\"Pattern Matching for switch\", status=\"Third Preview\")\n+        @JEP(number=433, title=\"Pattern Matching for switch\", status=\"Fourth Preview\")\n@@ -69,1 +69,1 @@\n-        @JEP(number=405, title=\"Record Patterns\")\n+        @JEP(number=432, title=\"Record Patterns\", status=\"Second Preview\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2002,2 +2002,2 @@\n-            throw new ProtocolException(\"Server redirected too many \" +\n-                                        \" times (\"+ redirects + \")\");\n+            throw new ProtocolException(\"Server redirected too many times (\" +\n+                    redirects + \")\");\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/HttpURLConnection.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-public class ContentInfo {\n+public class ContentInfo implements DerEncoder {\n@@ -169,1 +169,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    @Override\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/ContentInfo.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -118,3 +118,1 @@\n-    public byte[] getEncoded()\n-        throws IOException\n-    {\n+    public byte[] getEncoded() {\n@@ -144,4 +142,3 @@\n-        try {\n-            byte[] thisEncrInfo = this.getEncoded();\n-            byte[] otherEncrInfo\n-                = ((EncryptedPrivateKeyInfo)other).getEncoded();\n+        byte[] thisEncrInfo = this.getEncoded();\n+        byte[] otherEncrInfo\n+                = ((EncryptedPrivateKeyInfo) other).getEncoded();\n@@ -149,7 +146,1 @@\n-            if (thisEncrInfo.length != otherEncrInfo.length)\n-                return false;\n-            for (int i = 0; i < thisEncrInfo.length; i++)\n-                 if (thisEncrInfo[i] != otherEncrInfo[i])\n-                     return false;\n-            return true;\n-        } catch (IOException e) {\n+        if (thisEncrInfo.length != otherEncrInfo.length)\n@@ -157,1 +148,4 @@\n-        }\n+        for (int i = 0; i < thisEncrInfo.length; i++)\n+            if (thisEncrInfo[i] != otherEncrInfo[i])\n+                return false;\n+        return true;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/EncryptedPrivateKeyInfo.java","additions":9,"deletions":15,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -439,12 +439,0 @@\n-    \/**\n-     * Encodes the signed data to an output stream.\n-     *\n-     * @param out the output stream to write the encoded data to.\n-     * @exception IOException on encoding errors.\n-     *\/\n-    public void encodeSignedData(OutputStream out) throws IOException {\n-        DerOutputStream derout = new DerOutputStream();\n-        encodeSignedData(derout);\n-        out.write(derout.toByteArray());\n-    }\n-\n@@ -853,1 +841,1 @@\n-        ByteArrayOutputStream p7out = new ByteArrayOutputStream();\n+        DerOutputStream p7out = new DerOutputStream();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS7.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -201,2 +201,1 @@\n-        byte[] b = getEncodedInternal();\n-        return (b == null) ? null : b.clone();\n+        return getEncodedInternal().clone();\n@@ -216,1 +215,1 @@\n-     * @return the encoding, or null if there is an I\/O error.\n+     * @return the encoding\n@@ -220,11 +219,7 @@\n-            try {\n-                DerOutputStream tmp = new DerOutputStream();\n-                tmp.putInteger(V1);\n-                algid.encode(tmp);\n-                tmp.putOctetString(key);\n-                DerValue out = DerValue.wrap(DerValue.tag_Sequence, tmp);\n-                encodedKey = out.toByteArray();\n-                out.clear();\n-            } catch (IOException e) {\n-                \/\/ encodedKey is still null\n-            }\n+            DerOutputStream tmp = new DerOutputStream();\n+            tmp.putInteger(V1);\n+            algid.encode(tmp);\n+            tmp.putOctetString(key);\n+            DerValue out = DerValue.wrap(DerValue.tag_Sequence, tmp);\n+            encodedKey = out.toByteArray();\n+            out.clear();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS8Key.java","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.security.cert.CertificateException;\n@@ -533,1 +532,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n@@ -538,1 +537,1 @@\n-            temp.write((byte[])value);\n+            temp.writeBytes((byte[])value);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS9Attribute.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.io.OutputStream;\n@@ -158,1 +157,1 @@\n-    throws IllegalArgumentException, IOException {\n+            throws IllegalArgumentException {\n@@ -235,2 +234,0 @@\n-     *\n-     * @exception IOException  on output error.\n@@ -238,1 +235,1 @@\n-    public void encode(byte tag, OutputStream out) throws IOException {\n+    public void encode(byte tag, DerOutputStream out) {\n@@ -243,1 +240,1 @@\n-    private byte[] generateDerEncoding() throws IOException {\n+    private byte[] generateDerEncoding() {\n@@ -254,1 +251,1 @@\n-    public byte[] getDerEncoding() throws IOException {\n+    public byte[] getDerEncoding() {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS9Attributes.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -215,4 +215,1 @@\n-     * @param out\n-     * the output stream on which to write the DER encoding.\n-     *\n-     * @exception IOException on encoding error.\n+     * @param out the output stream on which to write the DER encoding.\n@@ -221,1 +218,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n@@ -435,10 +432,5 @@\n-                try {\n-                    \/\/ We don't care whether this extension was marked\n-                    \/\/ critical in the certificate.\n-                    \/\/ We're interested only in its value (i.e., the bits set)\n-                    \/\/ and treat the extension as critical.\n-                    keyUsage = new KeyUsageExtension(keyUsageBits);\n-                } catch (IOException ioe) {\n-                    throw new SignatureException(\"Failed to parse keyUsage \"\n-                                                 + \"extension\");\n-                }\n+                \/\/ We don't care whether this extension was marked\n+                \/\/ critical in the certificate.\n+                \/\/ We're interested only in its value (i.e., the bits set)\n+                \/\/ and treat the extension as critical.\n+                keyUsage = new KeyUsageExtension(keyUsageBits);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/SignerInfo.java","additions":7,"deletions":15,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-            throws IOException, SignatureException,\n+            throws SignatureException,\n@@ -220,1 +220,1 @@\n-        scratch.write(subjectPublicKeyInfo.getEncoded()); \/\/ public key\n+        scratch.writeBytes(subjectPublicKeyInfo.getEncoded()); \/\/ public key\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs10\/PKCS10.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,4 +105,1 @@\n-     * @param out\n-     * the OutputStream on which to write the DER encoding.\n-     *\n-     * @exception IOException on encoding errors.\n+     * @param out the DerOutputStream on which to write the DER encoding.\n@@ -111,1 +108,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs10\/PKCS10Attribute.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -94,2 +94,1 @@\n-     * @param out the OutputStream to marshal the contents to.\n-     * @exception IOException on encoding errors.\n+     * @param out the DerOutputStream to marshal the contents to.\n@@ -98,1 +97,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs10\/PKCS10Attributes.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-    public byte[] getEncoded() throws NoSuchAlgorithmException, IOException\n+    public byte[] getEncoded() throws NoSuchAlgorithmException\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs12\/MacData.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -832,32 +832,0 @@\n-    \/*\n-     * parse Algorithm Parameters\n-     *\/\n-    private AlgorithmParameters parseAlgParameters(ObjectIdentifier algorithm,\n-        DerInputStream in) throws IOException\n-    {\n-        AlgorithmParameters algParams = null;\n-        try {\n-            DerValue params;\n-            if (in.available() == 0) {\n-                params = null;\n-            } else {\n-                params = in.getDerValue();\n-                if (params.tag == DerValue.tag_Null) {\n-                   params = null;\n-                }\n-            }\n-            if (params != null) {\n-                if (algorithm.equals(pbes2_OID)) {\n-                    algParams = AlgorithmParameters.getInstance(\"PBES2\");\n-                } else {\n-                    algParams = AlgorithmParameters.getInstance(\"PBE\");\n-                }\n-                algParams.init(params.toByteArray());\n-            }\n-        } catch (Exception e) {\n-           throw new IOException(\"parseAlgParameters failed: \" +\n-                                 e.getMessage(), e);\n-        }\n-        return algParams;\n-    }\n-\n@@ -1209,1 +1177,1 @@\n-        pfx.write(pfxVersion);\n+        pfx.writeBytes(pfxVersion);\n@@ -1250,1 +1218,1 @@\n-                encrData.write(encryptContent(certsData, password));\n+                encrData.writeBytes(encryptContent(certsData, password));\n@@ -1272,1 +1240,1 @@\n-        pfx.write(authSafeData);\n+        pfx.writeBytes(authSafeData);\n@@ -1618,1 +1586,1 @@\n-        Set<KeyStore.Entry.Attribute> attributes) throws IOException {\n+        Set<KeyStore.Entry.Attribute> attributes) {\n@@ -1624,1 +1592,1 @@\n-        Set<KeyStore.Entry.Attribute> attributes) throws IOException {\n+        Set<KeyStore.Entry.Attribute> attributes) {\n@@ -1678,1 +1646,1 @@\n-            attrs.write(friendlyName);\n+            attrs.writeBytes(friendlyName);\n@@ -1681,1 +1649,1 @@\n-            attrs.write(localKeyID);\n+            attrs.writeBytes(localKeyID);\n@@ -1684,1 +1652,1 @@\n-            attrs.write(trustedKeyUsage);\n+            attrs.writeBytes(trustedKeyUsage);\n@@ -1696,1 +1664,1 @@\n-                attrs.write(((PKCS12Attribute) attribute).getEncoded());\n+                attrs.writeBytes(((PKCS12Attribute) attribute).getEncoded());\n@@ -1709,3 +1677,1 @@\n-    private byte[] getCertificateData()\n-        throws CertificateException, IOException\n-    {\n+    private byte[] getCertificateData() throws CertificateException {\n@@ -1753,1 +1719,1 @@\n-                bagValue.write(certBagValue);\n+                bagValue.writeBytes(certBagValue);\n@@ -1787,1 +1753,1 @@\n-                    safeBag.write(bagAttrs);\n+                    safeBag.writeBytes(bagAttrs);\n@@ -1839,1 +1805,1 @@\n-                bagValue.write(encrInfo.getEncoded());\n+                bagValue.writeBytes(encrInfo.getEncoded());\n@@ -1866,1 +1832,1 @@\n-                bagValue.write(secretBagValue);\n+                bagValue.writeBytes(secretBagValue);\n@@ -1878,1 +1844,1 @@\n-            safeBag.write(bagAttrs);\n+            safeBag.writeBytes(bagAttrs);\n@@ -1934,1 +1900,1 @@\n-            bytes2.write(encodedAlgId);\n+            bytes2.writeBytes(encodedAlgId);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs12\/PKCS12KeyStore.java","additions":16,"deletions":50,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -263,12 +263,7 @@\n-            try {\n-                DerOutputStream outseq = new DerOutputStream(100);\n-                outseq.putInteger(r);\n-                outseq.putInteger(s);\n-                DerValue result = new DerValue(DerValue.tag_Sequence,\n-                        outseq.toByteArray());\n-\n-                return result.toByteArray();\n-\n-            } catch (IOException e) {\n-                throw new SignatureException(\"error encoding signature\");\n-            }\n+            DerOutputStream outseq = new DerOutputStream(100);\n+            outseq.putInteger(r);\n+            outseq.putInteger(s);\n+            DerValue result = new DerValue(DerValue.tag_Sequence,\n+                    outseq.toByteArray());\n+\n+            return result.toByteArray();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/DSA.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -71,9 +71,5 @@\n-        try {\n-            byte[] xbytes = x.toByteArray();\n-            DerValue val = new DerValue(DerValue.tag_Integer, xbytes);\n-            key = val.toByteArray();\n-            val.clear();\n-            Arrays.fill(xbytes, (byte)0);\n-        } catch (IOException e) {\n-            throw new AssertionError(\"Should not happen\", e);\n-        }\n+        byte[] xbytes = x.toByteArray();\n+        DerValue val = new DerValue(DerValue.tag_Integer, xbytes);\n+        key = val.toByteArray();\n+        val.clear();\n+        Arrays.fill(xbytes, (byte)0);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/DSAPrivateKey.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -85,2 +85,1 @@\n-                        BigInteger g)\n-    throws InvalidKeyException {\n+                        BigInteger g) {\n@@ -90,9 +89,4 @@\n-        try {\n-            byte[] keyArray = new DerValue(DerValue.tag_Integer,\n-                               y.toByteArray()).toByteArray();\n-            setKey(new BitArray(keyArray.length*8, keyArray));\n-            encode();\n-        } catch (IOException e) {\n-            throw new InvalidKeyException(\"could not DER encode y: \" +\n-                                          e.getMessage());\n-        }\n+        byte[] keyArray = new DerValue(DerValue.tag_Integer,\n+                           y.toByteArray()).toByteArray();\n+        setKey(new BitArray(keyArray.length*8, keyArray));\n+        encode();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/DSAPublicKey.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -208,8 +208,3 @@\n-        AlgorithmId encrAlg;\n-        try {\n-            encrAlg = new AlgorithmId(ObjectIdentifier.of\n-                    (KnownOIDs.JAVASOFT_JDKKeyProtector));\n-            return new EncryptedPrivateKeyInfo(encrAlg,encrKey).getEncoded();\n-        } catch (IOException ioe) {\n-            throw new KeyStoreException(ioe.getMessage());\n-        }\n+        AlgorithmId encrAlg = new AlgorithmId(ObjectIdentifier.of\n+                (KnownOIDs.JAVASOFT_JDKKeyProtector));\n+        return new EncryptedPrivateKeyInfo(encrAlg,encrKey).getEncoded();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/KeyProtector.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-public class CertId {\n+public class CertId implements DerEncoder {\n@@ -157,1 +157,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    @Override\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/CertId.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -202,43 +202,38 @@\n-        try {\n-            byte[][] nbytes = new byte[8][];\n-            nbytes[0] = n.toByteArray();\n-            nbytes[1] = e.toByteArray();\n-            nbytes[2] = d.toByteArray();\n-            nbytes[3] = p.toByteArray();\n-            nbytes[4] = q.toByteArray();\n-            nbytes[5] = pe.toByteArray();\n-            nbytes[6] = qe.toByteArray();\n-            nbytes[7] = coeff.toByteArray();\n-\n-            \/\/ Initiate with a big enough size so there's no need to\n-            \/\/ reallocate memory later and thus can be cleaned up\n-            \/\/ reliably.\n-            DerOutputStream out = new DerOutputStream(\n-                    nbytes[0].length + nbytes[1].length +\n-                    nbytes[2].length + nbytes[3].length +\n-                    nbytes[4].length + nbytes[5].length +\n-                    nbytes[6].length + nbytes[7].length +\n-                    100); \/\/ Enough for version(3) and 8 tag+length(3 or 4)\n-            out.putInteger(0); \/\/ version must be 0\n-            out.putInteger(nbytes[0]);\n-            out.putInteger(nbytes[1]);\n-            out.putInteger(nbytes[2]);\n-            out.putInteger(nbytes[3]);\n-            out.putInteger(nbytes[4]);\n-            out.putInteger(nbytes[5]);\n-            out.putInteger(nbytes[6]);\n-            out.putInteger(nbytes[7]);\n-            \/\/ Private values from [2] on.\n-            Arrays.fill(nbytes[2], (byte)0);\n-            Arrays.fill(nbytes[3], (byte)0);\n-            Arrays.fill(nbytes[4], (byte)0);\n-            Arrays.fill(nbytes[5], (byte)0);\n-            Arrays.fill(nbytes[6], (byte)0);\n-            Arrays.fill(nbytes[7], (byte)0);\n-            DerValue val = DerValue.wrap(DerValue.tag_Sequence, out);\n-            key = val.toByteArray();\n-            val.clear();\n-        } catch (IOException exc) {\n-            \/\/ should never occur\n-            throw new InvalidKeyException(exc);\n-        }\n+        byte[][] nbytes = new byte[8][];\n+        nbytes[0] = n.toByteArray();\n+        nbytes[1] = e.toByteArray();\n+        nbytes[2] = d.toByteArray();\n+        nbytes[3] = p.toByteArray();\n+        nbytes[4] = q.toByteArray();\n+        nbytes[5] = pe.toByteArray();\n+        nbytes[6] = qe.toByteArray();\n+        nbytes[7] = coeff.toByteArray();\n+\n+        \/\/ Initiate with a big enough size so there's no need to\n+        \/\/ reallocate memory later and thus can be cleaned up\n+        \/\/ reliably.\n+        DerOutputStream out = new DerOutputStream(\n+                nbytes[0].length + nbytes[1].length +\n+                        nbytes[2].length + nbytes[3].length +\n+                        nbytes[4].length + nbytes[5].length +\n+                        nbytes[6].length + nbytes[7].length +\n+                        100); \/\/ Enough for version(3) and 8 tag+length(3 or 4)\n+        out.putInteger(0); \/\/ version must be 0\n+        out.putInteger(nbytes[0]);\n+        out.putInteger(nbytes[1]);\n+        out.putInteger(nbytes[2]);\n+        out.putInteger(nbytes[3]);\n+        out.putInteger(nbytes[4]);\n+        out.putInteger(nbytes[5]);\n+        out.putInteger(nbytes[6]);\n+        out.putInteger(nbytes[7]);\n+        \/\/ Private values from [2] on.\n+        Arrays.fill(nbytes[2], (byte) 0);\n+        Arrays.fill(nbytes[3], (byte) 0);\n+        Arrays.fill(nbytes[4], (byte) 0);\n+        Arrays.fill(nbytes[5], (byte) 0);\n+        Arrays.fill(nbytes[6], (byte) 0);\n+        Arrays.fill(nbytes[7], (byte) 0);\n+        DerValue val = DerValue.wrap(DerValue.tag_Sequence, out);\n+        key = val.toByteArray();\n+        val.clear();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateCrtKeyImpl.java","additions":38,"deletions":43,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.IOException;\n@@ -92,25 +91,20 @@\n-        try {\n-            \/\/ generate the key encoding\n-            byte[] nbytes = n.toByteArray();\n-            byte[] dbytes = d.toByteArray();\n-            DerOutputStream out = new DerOutputStream(\n-                    nbytes.length + dbytes.length + 50);\n-                    \/\/ Enough for 7 zeroes (21) and 2 tag+length(4)\n-            out.putInteger(0); \/\/ version must be 0\n-            out.putInteger(nbytes);\n-            Arrays.fill(nbytes, (byte)0);\n-            out.putInteger(0);\n-            out.putInteger(dbytes);\n-            Arrays.fill(dbytes, (byte)0);\n-            out.putInteger(0);\n-            out.putInteger(0);\n-            out.putInteger(0);\n-            out.putInteger(0);\n-            out.putInteger(0);\n-            DerValue val = DerValue.wrap(DerValue.tag_Sequence, out);\n-            key = val.toByteArray();\n-            val.clear();\n-        } catch (IOException exc) {\n-            \/\/ should never occur\n-            throw new InvalidKeyException(exc);\n-        }\n+        \/\/ generate the key encoding\n+        byte[] nbytes = n.toByteArray();\n+        byte[] dbytes = d.toByteArray();\n+        DerOutputStream out = new DerOutputStream(\n+                nbytes.length + dbytes.length + 50);\n+        \/\/ Enough for 7 zeroes (21) and 2 tag+length(4)\n+        out.putInteger(0); \/\/ version must be 0\n+        out.putInteger(nbytes);\n+        Arrays.fill(nbytes, (byte) 0);\n+        out.putInteger(0);\n+        out.putInteger(dbytes);\n+        Arrays.fill(dbytes, (byte) 0);\n+        out.putInteger(0);\n+        out.putInteger(0);\n+        out.putInteger(0);\n+        out.putInteger(0);\n+        out.putInteger(0);\n+        DerValue val = DerValue.wrap(DerValue.tag_Sequence, out);\n+        key = val.toByteArray();\n+        val.clear();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateKeyImpl.java","additions":21,"deletions":27,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -129,6 +129,5 @@\n-        try {\n-            \/\/ generate the key encoding\n-            DerOutputStream out = new DerOutputStream();\n-            out.putInteger(n);\n-            out.putInteger(e);\n-            byte[] keyArray =\n+        \/\/ generate the key encoding\n+        DerOutputStream out = new DerOutputStream();\n+        out.putInteger(n);\n+        out.putInteger(e);\n+        byte[] keyArray =\n@@ -136,6 +135,2 @@\n-                             out.toByteArray()).toByteArray();\n-            setKey(new BitArray(keyArray.length*8, keyArray));\n-        } catch (IOException exc) {\n-            \/\/ should never occur\n-            throw new InvalidKeyException(exc);\n-        }\n+                        out.toByteArray()).toByteArray();\n+        setKey(new BitArray(keyArray.length * 8, keyArray));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPublicKeyImpl.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -196,2 +196,0 @@\n-        } catch (IOException e) {\n-            throw new SignatureException(\"Could not encode data\", e);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSASignature.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -173,2 +173,1 @@\n-    public static byte[] encodeSignature(ObjectIdentifier oid, byte[] digest)\n-            throws IOException {\n+    public static byte[] encodeSignature(ObjectIdentifier oid, byte[] digest) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAUtil.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.io.IOException;\n-\n@@ -43,2 +41,1 @@\n-    void encode(DerOutputStream out)\n-        throws IOException;\n+    void encode(DerOutputStream out);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerEncoder.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.io.IOException;\n@@ -58,2 +57,2 @@\n-public class DerOutputStream\n-extends ByteArrayOutputStream implements DerEncoder {\n+public final class DerOutputStream\n+        extends ByteArrayOutputStream implements DerEncoder {\n@@ -81,1 +80,1 @@\n-    public DerOutputStream write(byte tag, byte[] buf) throws IOException {\n+    public DerOutputStream write(byte tag, byte[] buf) {\n@@ -84,1 +83,1 @@\n-        write(buf, 0, buf.length);\n+        writeBytes(buf);\n@@ -97,1 +96,1 @@\n-    public DerOutputStream write(byte tag, DerOutputStream out) throws IOException {\n+    public DerOutputStream write(byte tag, DerOutputStream out) {\n@@ -121,2 +120,1 @@\n-    public DerOutputStream writeImplicit(byte tag, DerOutputStream value)\n-    throws IOException {\n+    public DerOutputStream writeImplicit(byte tag, DerOutputStream value) {\n@@ -131,1 +129,1 @@\n-    public DerOutputStream putDerValue(DerValue val) throws IOException {\n+    public DerOutputStream putDerValue(DerValue val) {\n@@ -147,1 +145,1 @@\n-    public DerOutputStream putBoolean(boolean val) throws IOException {\n+    public DerOutputStream putBoolean(boolean val) {\n@@ -162,1 +160,1 @@\n-    public DerOutputStream putEnumerated(int i) throws IOException {\n+    public DerOutputStream putEnumerated(int i) {\n@@ -173,1 +171,1 @@\n-    public DerOutputStream putInteger(BigInteger i) throws IOException {\n+    public DerOutputStream putInteger(BigInteger i) {\n@@ -177,1 +175,1 @@\n-        write(buf, 0, buf.length);\n+        writeBytes(buf);\n@@ -186,1 +184,1 @@\n-    public DerOutputStream putInteger(byte[] buf) throws IOException {\n+    public DerOutputStream putInteger(byte[] buf) {\n@@ -189,1 +187,1 @@\n-        write(buf, 0, buf.length);\n+        writeBytes(buf);\n@@ -197,1 +195,1 @@\n-    public DerOutputStream putInteger(Integer i) throws IOException {\n+    public DerOutputStream putInteger(Integer i) {\n@@ -205,1 +203,1 @@\n-    public DerOutputStream putInteger(int i) throws IOException {\n+    public DerOutputStream putInteger(int i) {\n@@ -211,1 +209,1 @@\n-    private void putIntegerContents(int i) throws IOException {\n+    private void putIntegerContents(int i) {\n@@ -261,1 +259,1 @@\n-    public DerOutputStream putBitString(byte[] bits) throws IOException {\n+    public DerOutputStream putBitString(byte[] bits) {\n@@ -265,1 +263,1 @@\n-        write(bits);\n+        writeBytes(bits);\n@@ -275,1 +273,1 @@\n-    public DerOutputStream putUnalignedBitString(BitArray ba) throws IOException {\n+    public DerOutputStream putUnalignedBitString(BitArray ba) {\n@@ -281,1 +279,1 @@\n-        write(bits);\n+        writeBytes(bits);\n@@ -291,1 +289,1 @@\n-    public DerOutputStream putTruncatedUnalignedBitString(BitArray ba) throws IOException {\n+    public DerOutputStream putTruncatedUnalignedBitString(BitArray ba) {\n@@ -300,1 +298,1 @@\n-    public DerOutputStream putOctetString(byte[] octets) throws IOException {\n+    public DerOutputStream putOctetString(byte[] octets) {\n@@ -308,1 +306,1 @@\n-    public DerOutputStream putNull() throws IOException {\n+    public DerOutputStream putNull() {\n@@ -318,1 +316,1 @@\n-    public DerOutputStream putOID(ObjectIdentifier oid) throws IOException {\n+    public DerOutputStream putOID(ObjectIdentifier oid) {\n@@ -328,1 +326,1 @@\n-    public DerOutputStream putSequence(DerValue[] seq) throws IOException {\n+    public DerOutputStream putSequence(DerValue[] seq) {\n@@ -345,1 +343,1 @@\n-    public DerOutputStream putSet(DerValue[] set) throws IOException {\n+    public DerOutputStream putSet(DerValue[] set) {\n@@ -365,1 +363,1 @@\n-    public DerOutputStream putOrderedSetOf(byte tag, DerEncoder[] set) throws IOException {\n+    public DerOutputStream putOrderedSetOf(byte tag, DerEncoder[] set) {\n@@ -379,1 +377,1 @@\n-    public DerOutputStream putOrderedSet(byte tag, DerEncoder[] set) throws IOException {\n+    public DerOutputStream putOrderedSet(byte tag, DerEncoder[] set) {\n@@ -402,1 +400,1 @@\n-                               Comparator<byte[]> order) throws IOException {\n+                               Comparator<byte[]> order) {\n@@ -419,1 +417,1 @@\n-            bytes.write(bufs[i]);\n+            bytes.writeBytes(bufs[i]);\n@@ -427,1 +425,1 @@\n-    public DerOutputStream putUTF8String(String s) throws IOException {\n+    public DerOutputStream putUTF8String(String s) {\n@@ -434,1 +432,1 @@\n-    public DerOutputStream putPrintableString(String s) throws IOException {\n+    public DerOutputStream putPrintableString(String s) {\n@@ -441,1 +439,1 @@\n-    public DerOutputStream putT61String(String s) throws IOException {\n+    public DerOutputStream putT61String(String s) {\n@@ -452,1 +450,1 @@\n-    public DerOutputStream putIA5String(String s) throws IOException {\n+    public DerOutputStream putIA5String(String s) {\n@@ -459,1 +457,1 @@\n-    public DerOutputStream putBMPString(String s) throws IOException {\n+    public DerOutputStream putBMPString(String s) {\n@@ -466,1 +464,1 @@\n-    public DerOutputStream putGeneralString(String s) throws IOException {\n+    public DerOutputStream putGeneralString(String s) {\n@@ -478,2 +476,1 @@\n-    private DerOutputStream writeString(String s, byte stringTag, Charset charset)\n-        throws IOException {\n+    private DerOutputStream writeString(String s, byte stringTag, Charset charset) {\n@@ -484,1 +481,1 @@\n-        write(data);\n+        writeBytes(data);\n@@ -494,1 +491,1 @@\n-    public DerOutputStream putUTCTime(Date d) throws IOException {\n+    public DerOutputStream putUTCTime(Date d) {\n@@ -504,1 +501,1 @@\n-    public DerOutputStream putGeneralizedTime(Date d) throws IOException {\n+    public DerOutputStream putGeneralizedTime(Date d) {\n@@ -515,1 +512,1 @@\n-    private DerOutputStream putTime(Date d, byte tag) throws IOException {\n+    private DerOutputStream putTime(Date d, byte tag) {\n@@ -541,1 +538,1 @@\n-        write(time);\n+        writeBytes(time);\n@@ -549,1 +546,0 @@\n-     * @exception IOException on writing errors.\n@@ -551,1 +547,1 @@\n-    public void putLength(int len) throws IOException {\n+    public void putLength(int len) {\n@@ -582,2 +578,0 @@\n-     *\n-     *  @exception IOException on output error.\n@@ -586,2 +580,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n-        out.write(toByteArray());\n+    public void encode(DerOutputStream out) {\n+        out.writeBytes(toByteArray());\n@@ -593,1 +587,0 @@\n-     * @throws IOException on output error\n@@ -595,1 +588,1 @@\n-    public DerOutputStream write(DerEncoder encoder) throws IOException {\n+    public DerOutputStream write(DerEncoder encoder) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerOutputStream.java","additions":46,"deletions":53,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -496,1 +496,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n@@ -777,1 +777,1 @@\n-    public byte[] getDataBytes() throws IOException {\n+    public byte[] getDataBytes() {\n@@ -1136,1 +1136,1 @@\n-    public byte[] toByteArray() throws IOException {\n+    public byte[] toByteArray() {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerValue.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.io.IOException;\n@@ -62,5 +61,1 @@\n-        try {\n-            out.putOID(ObjectIdentifier.of(ko));\n-        } catch (IOException e) {\n-            throw new RuntimeException(\"Internal error\", e);\n-        }\n+        out.putOID(ObjectIdentifier.of(ko));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/NamedCurve.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -327,1 +327,1 @@\n-    void encode(DerOutputStream out) throws IOException {\n+    void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/ObjectIdentifier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -153,8 +153,0 @@\n-\n-    \/**\n-     * Some implementations required reduction operations to be requested\n-     * by the client at certain times. This method reduces the representation.\n-     *\n-     * @return this\n-     *\/\n-    MutableIntegerModuloP setReduced();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/MutableIntegerModuloP.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,3 +38,1 @@\n- * to multiplication must be less than 32 bits. All IntegerPolynomial\n- * implementations allow at most one addition before multiplication. Additions\n- * after that will result in an ArithmeticException.\n+ * to multiplication must be less than 32 bits.\n@@ -556,4 +554,0 @@\n-        protected boolean isSummand() {\n-            return numAdds < maxAdds;\n-        }\n-\n@@ -563,3 +557,13 @@\n-            Element b = (Element) genB;\n-            if (!(isSummand() && b.isSummand())) {\n-                throw new ArithmeticException(\"Not a valid summand\");\n+            Element b = (Element)genB;\n+\n+            \/\/ Reduce if required.\n+            \/\/ if (numAdds >= maxAdds) {\n+            if (numAdds > 32 - bitsPerLimb) {\n+               reduce(limbs);\n+               numAdds = 0;\n+            }\n+\n+            \/\/ if (b.numAdds >= maxAdds) {\n+            if (b.numAdds > 32 - bitsPerLimb) {\n+                reduce(b.limbs);\n+                b.numAdds = 0;\n@@ -600,1 +604,12 @@\n-            Element b = (Element) genB;\n+            Element b = (Element)genB;\n+\n+            \/\/ Reduce if required.\n+            if (numAdds > maxAdds) {\n+                reduce(limbs);\n+                numAdds = 0;\n+            }\n+\n+            if (b.numAdds > maxAdds) {\n+                reduce(b.limbs);\n+                b.numAdds = 0;\n+            }\n@@ -609,0 +624,6 @@\n+            \/\/ Reduce if required.\n+            if (numAdds > maxAdds) {\n+                reduce(limbs);\n+                numAdds = 0;\n+            }\n+\n@@ -616,3 +637,6 @@\n-            Element other = (Element) arg;\n-            if (!(isSummand() && other.isSummand())) {\n-                throw new ArithmeticException(\"Not a valid summand\");\n+            Element other = (Element)arg;\n+\n+            \/\/ Reduce if required.\n+            if (numAdds > 32 - bitsPerLimb) {\n+                reduce(limbs);\n+                numAdds = 0;\n@@ -620,0 +644,6 @@\n+\n+            if (other.numAdds > 32 - bitsPerLimb) {\n+                reduce(other.limbs);\n+                other.numAdds = 0;\n+            }\n+\n@@ -624,2 +654,4 @@\n-            if (!isSummand()) {\n-                throw new ArithmeticException(\"Not a valid summand\");\n+            \/\/ Reduce if required.\n+            if (numAdds != 0) {\n+                reduce(limbs);\n+                numAdds = 0;\n@@ -627,0 +659,1 @@\n+\n@@ -701,1 +734,13 @@\n-            Element b = (Element) genB;\n+            Element b = (Element)genB;\n+\n+            \/\/ Reduce if required.\n+            if (numAdds > maxAdds) {\n+                reduce(limbs);\n+                numAdds = 0;\n+            }\n+\n+            if (b.numAdds > maxAdds) {\n+                reduce(b.limbs);\n+                b.numAdds = 0;\n+            }\n+\n@@ -709,1 +754,7 @@\n-            int value = ((Limb) v).value;\n+            \/\/ Reduce if required.\n+            if (numAdds > maxAdds) {\n+                reduce(limbs);\n+                numAdds = 0;\n+            }\n+\n+            int value = ((Limb)v).value;\n@@ -718,3 +769,13 @@\n-            Element b = (Element) genB;\n-            if (!(isSummand() && b.isSummand())) {\n-                throw new ArithmeticException(\"Not a valid summand\");\n+            Element b = (Element)genB;\n+\n+            \/\/ Reduce if required.\n+            \/\/ if (numAdds >= maxAdds) {\n+            if (numAdds > 32 - bitsPerLimb) {\n+               reduce(limbs);\n+               numAdds = 0;\n+            }\n+\n+            \/\/ if (b.numAdds >= maxAdds) {\n+            if (b.numAdds > 32 - bitsPerLimb) {\n+                reduce(b.limbs);\n+                b.numAdds = 0;\n@@ -734,3 +795,13 @@\n-            Element b = (Element) genB;\n-            if (!(isSummand() && b.isSummand())) {\n-                throw new ArithmeticException(\"Not a valid summand\");\n+            Element b = (Element)genB;\n+\n+            \/\/ Reduce if required.\n+            \/\/ if (numAdds >= maxAdds) {\n+            if (numAdds > 32 - bitsPerLimb) {\n+               reduce(limbs);\n+               numAdds = 0;\n+            }\n+\n+            \/\/ if (b.numAdds >= maxAdds) {\n+            if (b.numAdds > 32 - bitsPerLimb) {\n+                reduce(b.limbs);\n+                b.numAdds = 0;\n@@ -749,0 +820,6 @@\n+            \/\/ Reduce if required.\n+            if (numAdds > maxAdds) {\n+                reduce(limbs);\n+                numAdds = 0;\n+            }\n+\n@@ -761,7 +838,0 @@\n-\n-        @Override\n-        public MutableElement setReduced() {\n-            reduce(limbs);\n-            numAdds = 0;\n-            return this;\n-        }\n@@ -798,2 +868,0 @@\n-\n-\n@@ -801,0 +869,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial.java","additions":102,"deletions":33,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -623,4 +623,1 @@\n-     * @param out\n-     * the output stream on which to write the DER encoding.\n-     *\n-     * @exception IOException on encoding error.\n+     * @param out the output stream on which to write the DER encoding.\n@@ -629,2 +626,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n-        DerOutputStream         tmp = new DerOutputStream();\n+    public void encode(DerOutputStream out) {\n+        DerOutputStream tmp = new DerOutputStream();\n@@ -708,6 +705,1 @@\n-            byte[] data;\n-            try {\n-                data = value.toByteArray();\n-            } catch (IOException ie) {\n-                throw new IllegalArgumentException(\"DER Value conversion\");\n-            }\n+            byte[] data = value.toByteArray();\n@@ -725,6 +717,1 @@\n-            String valStr;\n-            try {\n-                valStr = new String(value.getDataBytes(), UTF_8);\n-            } catch (IOException ie) {\n-                throw new IllegalArgumentException(\"DER Value conversion\");\n-            }\n+            String valStr = new String(value.getDataBytes(), UTF_8);\n@@ -843,6 +830,1 @@\n-            byte[] data;\n-            try {\n-                data = value.toByteArray();\n-            } catch (IOException ie) {\n-                throw new IllegalArgumentException(\"DER Value conversion\");\n-            }\n+            byte[] data = value.toByteArray();\n@@ -860,6 +842,1 @@\n-            String valStr;\n-            try {\n-                valStr = new String(value.getDataBytes(), UTF_8);\n-            } catch (IOException ie) {\n-                throw new IllegalArgumentException(\"DER Value conversion\");\n-            }\n+            String valStr = new String(value.getDataBytes(), UTF_8);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AVA.java","additions":7,"deletions":30,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AccessDescription.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -156,4 +156,1 @@\n-     * @param out\n-     * the output stream on which to write the DER encoding.\n-     *\n-     * @exception IOException on encoding error.\n+     * @param out the output stream on which to write the DER encoding.\n@@ -162,1 +159,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n@@ -223,1 +220,1 @@\n-            bytes.write(encodedParams);\n+            bytes.writeBytes(encodedParams);\n@@ -232,1 +229,1 @@\n-    public final byte[] encode() throws IOException {\n+    public final byte[] encode() {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AlgorithmId.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-     * @throws IOException on error\n@@ -82,1 +81,1 @@\n-            List<AccessDescription> accessDescriptions) throws IOException {\n+            List<AccessDescription> accessDescriptions) {\n@@ -141,1 +140,0 @@\n-     * @exception IOException on encoding errors.\n@@ -144,1 +142,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n@@ -154,1 +152,1 @@\n-    private void encodeThis() throws IOException {\n+    private void encodeThis() {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AuthorityInfoAccessExtension.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    private void encodeThis() throws IOException {\n+    private void encodeThis() {\n@@ -81,9 +81,5 @@\n-        try {\n-            if (names != null) {\n-                DerOutputStream tmp1 = new DerOutputStream();\n-                names.encode(tmp1);\n-                tmp.writeImplicit(DerValue.createTag(DerValue.TAG_CONTEXT,\n-                                  true, TAG_NAMES), tmp1);\n-            }\n-        } catch (Exception e) {\n-            throw new IOException(e.toString());\n+        if (names != null) {\n+            DerOutputStream tmp1 = new DerOutputStream();\n+            names.encode(tmp1);\n+            tmp.writeImplicit(DerValue.createTag(DerValue.TAG_CONTEXT,\n+                              true, TAG_NAMES), tmp1);\n@@ -109,1 +105,0 @@\n-     * @exception IOException on error.\n@@ -112,2 +107,1 @@\n-                                           SerialNumber sn)\n-            throws IOException {\n+                                           SerialNumber sn) {\n@@ -208,1 +202,0 @@\n-     * @exception IOException on error.\n@@ -211,1 +204,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AuthorityKeyIdentifierExtension.java","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    private void encodeThis() throws IOException {\n+    private void encodeThis() {\n@@ -81,1 +81,1 @@\n-    public BasicConstraintsExtension(boolean ca, int len) throws IOException {\n+    public BasicConstraintsExtension(boolean ca, int len) {\n@@ -92,2 +92,1 @@\n-    public BasicConstraintsExtension(Boolean critical, boolean ca, int len)\n-    throws IOException {\n+    public BasicConstraintsExtension(Boolean critical, boolean ca, int len) {\n@@ -181,1 +180,1 @@\n-     public void encode(DerOutputStream out) throws IOException {\n+     public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/BasicConstraintsExtension.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -96,1 +96,0 @@\n-     * @throws IOException on error\n@@ -99,1 +98,1 @@\n-        List<DistributionPoint> distributionPoints) throws IOException {\n+            List<DistributionPoint> distributionPoints) {\n@@ -111,1 +110,0 @@\n-     * @throws IOException on error\n@@ -114,1 +112,1 @@\n-        List<DistributionPoint> distributionPoints) throws IOException {\n+        List<DistributionPoint> distributionPoints) {\n@@ -125,1 +123,1 @@\n-            String extensionName) throws IOException {\n+            String extensionName) {\n@@ -192,1 +190,0 @@\n-     * @exception IOException on encoding errors.\n@@ -195,1 +192,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n@@ -204,1 +201,1 @@\n-            boolean isCritical) throws IOException {\n+            boolean isCritical) {\n@@ -224,1 +221,1 @@\n-    private void encodeThis() throws IOException {\n+    private void encodeThis() {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/CRLDistributionPointsExtension.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -140,1 +140,0 @@\n-     * @exception CRLException on encoding errors.\n@@ -142,7 +141,5 @@\n-    public void encode(OutputStream out, boolean isExplicit)\n-    throws CRLException {\n-        try {\n-            DerOutputStream extOut = new DerOutputStream();\n-            for (Extension ext : map.values()) {\n-                ext.encode(extOut);\n-            }\n+    public void encode(DerOutputStream out, boolean isExplicit) {\n+        DerOutputStream extOut = new DerOutputStream();\n+        for (Extension ext : map.values()) {\n+            ext.encode(extOut);\n+        }\n@@ -150,2 +147,2 @@\n-            DerOutputStream seq = new DerOutputStream();\n-            seq.write(DerValue.tag_Sequence, extOut);\n+        DerOutputStream seq = new DerOutputStream();\n+        seq.write(DerValue.tag_Sequence, extOut);\n@@ -153,6 +150,6 @@\n-            DerOutputStream tmp = new DerOutputStream();\n-            if (isExplicit)\n-                tmp.write(DerValue.createTag(DerValue.TAG_CONTEXT,\n-                                             true, (byte)0), seq);\n-            else\n-                tmp = seq;\n+        DerOutputStream tmp = new DerOutputStream();\n+        if (isExplicit)\n+            tmp.write(DerValue.createTag(DerValue.TAG_CONTEXT,\n+                    true, (byte) 0), seq);\n+        else\n+            tmp = seq;\n@@ -160,4 +157,1 @@\n-            out.write(tmp.toByteArray());\n-        } catch (IOException e) {\n-            throw new CRLException(\"Encoding error: \" + e.toString());\n-        }\n+        out.writeBytes(tmp.toByteArray());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/CRLExtensions.java","additions":14,"deletions":20,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    private void encodeThis() throws IOException {\n+    private void encodeThis() {\n@@ -72,1 +72,1 @@\n-    public CRLNumberExtension(int crlNum) throws IOException {\n+    public CRLNumberExtension(int crlNum) {\n@@ -83,1 +83,1 @@\n-    public CRLNumberExtension(BigInteger crlNum) throws IOException {\n+    public CRLNumberExtension(BigInteger crlNum) {\n@@ -91,2 +91,2 @@\n-        boolean isCritical, BigInteger crlNum, String extensionName,\n-        String extensionLabel) throws IOException {\n+            boolean isCritical, BigInteger crlNum, String extensionName,\n+            String extensionLabel) {\n@@ -161,1 +161,0 @@\n-     * @exception IOException on encoding errors.\n@@ -164,1 +163,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n@@ -173,1 +172,1 @@\n-            boolean isCritical) throws IOException {\n+            boolean isCritical) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/CRLNumberExtension.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    private void encodeThis() throws IOException {\n+    private void encodeThis() {\n@@ -74,2 +74,1 @@\n-    public CRLReasonCodeExtension(boolean critical, int reason)\n-            throws IOException {\n+    public CRLReasonCodeExtension(boolean critical, int reason) {\n@@ -113,1 +112,0 @@\n-     * @exception IOException on encoding errors.\n@@ -116,1 +114,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/CRLReasonCodeExtension.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-     * @exception IOException on errors.\n@@ -91,1 +90,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/CertificateAlgorithmId.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -140,2 +140,0 @@\n-     * @exception CertificateException on encoding errors.\n-     * @exception IOException on errors.\n@@ -144,1 +142,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n@@ -153,2 +151,0 @@\n-     * @exception CertificateException on encoding errors.\n-     * @exception IOException on errors.\n@@ -156,2 +152,1 @@\n-    public void encode(DerOutputStream out, boolean isCertReq)\n-            throws IOException {\n+    public void encode(DerOutputStream out, boolean isCertReq) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/CertificateExtensions.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    private void encodeThis() throws IOException {\n+    private void encodeThis() {\n@@ -84,1 +84,0 @@\n-     * @throws IOException on error\n@@ -86,1 +85,1 @@\n-    public CertificateIssuerExtension(GeneralNames issuer) throws IOException {\n+    public CertificateIssuerExtension(GeneralNames issuer) {\n@@ -131,1 +130,0 @@\n-     * @exception IOException on encoding errors\n@@ -134,1 +132,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/CertificateIssuerExtension.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-    private void encodeThis() throws IOException {\n+    private void encodeThis() {\n@@ -99,2 +99,1 @@\n-    public CertificatePoliciesExtension(List<PolicyInformation> certPolicies)\n-    throws IOException {\n+    public CertificatePoliciesExtension(List<PolicyInformation> certPolicies) {\n@@ -112,1 +111,1 @@\n-            List<PolicyInformation> certPolicies) throws IOException {\n+            List<PolicyInformation> certPolicies) {\n@@ -171,1 +170,0 @@\n-     * @exception IOException on encoding errors.\n@@ -174,1 +172,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/CertificatePoliciesExtension.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-public class CertificatePolicyId {\n+public class CertificatePolicyId implements DerEncoder {\n@@ -82,1 +82,0 @@\n-     * @exception IOException on errors.\n@@ -84,1 +83,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    @Override\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/CertificatePolicyId.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-public class CertificatePolicyMap {\n+public class CertificatePolicyMap implements DerEncoder {\n@@ -97,1 +97,0 @@\n-     * @exception IOException on errors.\n@@ -99,1 +98,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    @Override\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/CertificatePolicyMap.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-public class CertificatePolicySet {\n+public class CertificatePolicySet implements DerEncoder {\n@@ -85,1 +85,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    @Override\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/CertificatePolicySet.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -107,1 +107,0 @@\n-     * @exception IOException on errors.\n@@ -110,1 +109,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/CertificateSerialNumber.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -94,1 +94,0 @@\n-     * @exception IOException on errors.\n@@ -97,1 +96,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/CertificateSubjectName.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-     * @exception IOException on errors.\n@@ -129,1 +128,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/CertificateValidity.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -149,1 +149,0 @@\n-     * @exception IOException on errors.\n@@ -152,1 +151,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/CertificateVersion.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -91,1 +91,0 @@\n-     * @exception IOException on errors.\n@@ -94,2 +93,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n-        out.write(key.getEncoded());\n+    public void encode(DerOutputStream out) {\n+        out.writeBytes(key.getEncoded());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/CertificateX509Key.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -153,1 +153,0 @@\n-     * @exception IOException on encoding errors.\n@@ -155,1 +154,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    @Override\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/DNSName.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    public DeltaCRLIndicatorExtension(int crlNum) throws IOException {\n+    public DeltaCRLIndicatorExtension(int crlNum) {\n@@ -83,1 +83,1 @@\n-    public DeltaCRLIndicatorExtension(BigInteger crlNum) throws IOException {\n+    public DeltaCRLIndicatorExtension(BigInteger crlNum) {\n@@ -105,1 +105,0 @@\n-     * @exception IOException on encoding errors.\n@@ -108,1 +107,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/DeltaCRLIndicatorExtension.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import sun.security.util.DerEncoder;\n@@ -96,1 +97,1 @@\n-public class DistributionPoint {\n+public class DistributionPoint implements DerEncoder {\n@@ -278,1 +279,0 @@\n-     * @exception IOException on error.\n@@ -280,1 +280,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    @Override\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/DistributionPoint.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import sun.security.util.DerEncoder;\n@@ -81,1 +82,1 @@\n-public class DistributionPointName {\n+public class DistributionPointName implements DerEncoder {\n@@ -167,1 +168,0 @@\n-     * @exception IOException on encoding error.\n@@ -169,1 +169,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    @Override\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/DistributionPointName.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -127,1 +127,0 @@\n-     * @exception IOException on encoding errors.\n@@ -129,1 +128,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    @Override\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/EDIPartyName.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-    private void encodeThis() throws IOException {\n+    private void encodeThis() {\n@@ -111,2 +111,1 @@\n-    public ExtendedKeyUsageExtension(Vector<ObjectIdentifier> keyUsages)\n-    throws IOException {\n+    public ExtendedKeyUsageExtension(Vector<ObjectIdentifier> keyUsages) {\n@@ -124,2 +123,1 @@\n-    public ExtendedKeyUsageExtension(Boolean critical, Vector<ObjectIdentifier> keyUsages)\n-            throws IOException {\n+    public ExtendedKeyUsageExtension(Boolean critical, Vector<ObjectIdentifier> keyUsages) {\n@@ -191,1 +189,0 @@\n-     * @exception IOException on encoding errors.\n@@ -194,1 +191,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/ExtendedKeyUsageExtension.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -172,1 +172,0 @@\n-     * @exception IOException on encoding errors\n@@ -175,1 +174,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/Extension.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -68,2 +68,1 @@\n-    public FreshestCRLExtension(List<DistributionPoint> distributionPoints)\n-        throws IOException {\n+    public FreshestCRLExtension(List<DistributionPoint> distributionPoints) {\n@@ -91,1 +90,0 @@\n-     * @exception IOException on encoding errors.\n@@ -94,1 +92,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/FreshestCRLExtension.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-public class GeneralName {\n+public class GeneralName implements DerEncoder {\n@@ -234,1 +234,0 @@\n-     * @exception IOException on encoding errors.\n@@ -236,1 +235,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    @Override\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/GeneralName.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.io.IOException;\n-\n@@ -39,1 +37,1 @@\n-public interface GeneralNameInterface {\n+public interface GeneralNameInterface extends DerEncoder {\n@@ -68,9 +66,0 @@\n-    \/**\n-     * Encode the name to the specified DerOutputStream.\n-     *\n-     * @param out the DerOutputStream to encode the GeneralName to.\n-     * @exception IOException thrown if the GeneralName could not be\n-     *            encoded.\n-     *\/\n-    void encode(DerOutputStream out) throws IOException;\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/GeneralNameInterface.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -112,1 +112,0 @@\n-     * @exception IOException on error.\n@@ -114,1 +113,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/GeneralNames.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-public class GeneralSubtree {\n+public class GeneralSubtree implements DerEncoder {\n@@ -197,1 +197,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    @Override\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/GeneralSubtree.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-public class GeneralSubtrees implements Cloneable {\n+public class GeneralSubtrees implements Cloneable, DerEncoder {\n@@ -135,1 +135,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    @Override\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/GeneralSubtrees.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -229,1 +229,0 @@\n-     * @exception IOException on encoding errors.\n@@ -231,1 +230,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    @Override\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/IPAddressName.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    private void encodeThis() throws IOException {\n+    private void encodeThis() {\n@@ -84,1 +84,1 @@\n-    public InhibitAnyPolicyExtension(int skipCerts) throws IOException {\n+    public InhibitAnyPolicyExtension(int skipCerts) {\n@@ -147,1 +147,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/InhibitAnyPolicyExtension.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    private void encodeThis() throws IOException {\n+    private void encodeThis() {\n@@ -83,1 +83,1 @@\n-    public InvalidityDateExtension(Date date) throws IOException {\n+    public InvalidityDateExtension(Date date) {\n@@ -93,2 +93,1 @@\n-    public InvalidityDateExtension(boolean critical, Date date)\n-            throws IOException {\n+    public InvalidityDateExtension(boolean critical, Date date) {\n@@ -144,1 +143,0 @@\n-     * @exception IOException on encoding errors\n@@ -147,1 +145,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/InvalidityDateExtension.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    private void encodeThis() throws IOException {\n+    private void encodeThis() {\n@@ -69,1 +69,0 @@\n-     * @exception IOException on error.\n@@ -71,2 +70,1 @@\n-    public IssuerAlternativeNameExtension(GeneralNames names)\n-            throws IOException {\n+    public IssuerAlternativeNameExtension(GeneralNames names) {\n@@ -82,1 +80,0 @@\n-     * @exception IOException on error.\n@@ -84,2 +81,1 @@\n-    public IssuerAlternativeNameExtension(Boolean critical, GeneralNames names)\n-            throws IOException {\n+    public IssuerAlternativeNameExtension(Boolean critical, GeneralNames names) {\n@@ -141,1 +137,0 @@\n-     * @exception IOException on encoding error.\n@@ -144,1 +139,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/IssuerAlternativeNameExtension.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -115,1 +115,0 @@\n-     * @throws IOException on encoding error.\n@@ -120,2 +119,1 @@\n-        boolean hasOnlyAttributeCerts, boolean isIndirectCRL)\n-            throws IOException {\n+        boolean hasOnlyAttributeCerts, boolean isIndirectCRL) {\n@@ -225,1 +223,0 @@\n-     * @exception IOException on encoding error.\n@@ -228,1 +225,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n@@ -267,1 +264,1 @@\n-    private void encodeThis() throws IOException {\n+    private void encodeThis() {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/IssuingDistributionPointExtension.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-    void encode(DerOutputStream out) throws IOException {\n+    void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/KeyIdentifier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-    private void encodeThis() throws IOException {\n+    private void encodeThis() {\n@@ -97,1 +97,1 @@\n-    public KeyUsageExtension(byte[] bitString) throws IOException {\n+    public KeyUsageExtension(byte[] bitString) {\n@@ -111,1 +111,1 @@\n-    public KeyUsageExtension(boolean[] bitString) throws IOException {\n+    public KeyUsageExtension(boolean[] bitString) {\n@@ -124,1 +124,1 @@\n-    public KeyUsageExtension(BitArray bitString) throws IOException {\n+    public KeyUsageExtension(BitArray bitString) {\n@@ -275,1 +275,0 @@\n-     * @exception IOException on encoding errors.\n@@ -278,1 +277,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/KeyUsageExtension.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-    private void encodeThis() throws IOException {\n+    private void encodeThis() {\n@@ -138,2 +138,1 @@\n-                                    GeneralSubtrees excluded)\n-            throws IOException {\n+                                    GeneralSubtrees excluded) {\n@@ -229,1 +228,0 @@\n-     * @exception IOException on encoding errors.\n@@ -232,1 +230,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/NameConstraintsExtension.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.util.*;\n@@ -89,7 +88,0 @@\n-    private static final Vector<String> mAttributeNames = new Vector<>();\n-    static {\n-        for (MapEntry entry : mMapData) {\n-            mAttributeNames.add(entry.mName);\n-        }\n-    }\n-\n@@ -106,1 +98,1 @@\n-    private void encodeThis() throws IOException {\n+    private void encodeThis() {\n@@ -141,1 +133,1 @@\n-    public NetscapeCertTypeExtension(byte[] bitString) throws IOException {\n+    public NetscapeCertTypeExtension(byte[] bitString) {\n@@ -155,1 +147,1 @@\n-    public NetscapeCertTypeExtension(boolean[] bitString) throws IOException {\n+    public NetscapeCertTypeExtension(boolean[] bitString) {\n@@ -241,1 +233,0 @@\n-     * @exception IOException on encoding errors.\n@@ -244,1 +235,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/NetscapeCertTypeExtension.java","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -89,1 +89,0 @@\n-     * @exception IOException on encoding errors.\n@@ -91,1 +90,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    @Override\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/OIDName.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -154,1 +154,0 @@\n-     * @exception IOException on encoding errors.\n@@ -156,1 +155,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    @Override\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/OtherName.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-    private void encodeThis() throws IOException {\n+    private void encodeThis() {\n@@ -97,2 +97,1 @@\n-    public PolicyConstraintsExtension(int require, int inhibit)\n-    throws IOException {\n+    public PolicyConstraintsExtension(int require, int inhibit) {\n@@ -111,2 +110,1 @@\n-    public PolicyConstraintsExtension(Boolean critical, int require, int inhibit)\n-            throws IOException {\n+    public PolicyConstraintsExtension(Boolean critical, int require, int inhibit) {\n@@ -193,1 +191,0 @@\n-     * @exception IOException on encoding errors.\n@@ -196,1 +193,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/PolicyConstraintsExtension.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import sun.security.util.DerEncoder;\n@@ -62,1 +63,1 @@\n-public class PolicyInformation {\n+public class PolicyInformation implements DerEncoder {\n@@ -181,1 +182,0 @@\n-     * @exception IOException on encoding errors.\n@@ -183,1 +183,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    @Override\n+    public void encode(DerOutputStream out) {\n@@ -189,1 +190,1 @@\n-                tmp2.write(pq.getEncoded());\n+                tmp2.writeBytes(pq.getEncoded());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/PolicyInformation.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    private void encodeThis() throws IOException {\n+    private void encodeThis() {\n@@ -80,2 +80,1 @@\n-    public PolicyMappingsExtension(List<CertificatePolicyMap> maps)\n-            throws IOException {\n+    public PolicyMappingsExtension(List<CertificatePolicyMap> maps) {\n@@ -132,1 +131,0 @@\n-     * @exception IOException on encoding errors.\n@@ -135,1 +133,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/PolicyMappingsExtension.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-    private void encodeThis() throws IOException {\n+    private void encodeThis() {\n@@ -104,2 +104,1 @@\n-    public PrivateKeyUsageExtension(Date notBefore, Date notAfter)\n-            throws IOException {\n+    public PrivateKeyUsageExtension(Date notBefore, Date notAfter) {\n@@ -233,1 +232,0 @@\n-     * @exception IOException on encoding errors.\n@@ -236,1 +234,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/PrivateKeyUsageExtension.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -336,1 +336,0 @@\n-     * @throws IOException on error\n@@ -338,1 +337,1 @@\n-    void encode(DerOutputStream out) throws IOException {\n+    void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/RDN.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -117,1 +117,0 @@\n-     * @exception IOException on encoding errors.\n@@ -119,1 +118,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    @Override\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/RFC822Name.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,4 +30,1 @@\n-import sun.security.util.BitArray;\n-import sun.security.util.DerInputStream;\n-import sun.security.util.DerOutputStream;\n-import sun.security.util.DerValue;\n+import sun.security.util.*;\n@@ -56,1 +53,1 @@\n-public class ReasonFlags {\n+public class ReasonFlags implements DerEncoder {\n@@ -234,1 +231,0 @@\n-     * @exception IOException on encoding errors.\n@@ -236,1 +232,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    @Override\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/ReasonFlags.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2002, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,0 @@\n-     * @exception IOException on errors.\n@@ -113,1 +112,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/SerialNumber.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    private void encodeThis() throws IOException {\n+    private void encodeThis() {\n@@ -75,1 +75,0 @@\n-     * @exception IOException on error.\n@@ -77,2 +76,1 @@\n-    public SubjectAlternativeNameExtension(GeneralNames names)\n-    throws IOException {\n+    public SubjectAlternativeNameExtension(GeneralNames names) {\n@@ -88,1 +86,0 @@\n-     * @exception IOException on error.\n@@ -90,2 +87,1 @@\n-    public SubjectAlternativeNameExtension(Boolean critical, GeneralNames names)\n-            throws IOException {\n+    public SubjectAlternativeNameExtension(Boolean critical, GeneralNames names) {\n@@ -145,1 +141,0 @@\n-     * @exception IOException on encoding errors.\n@@ -148,1 +143,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/SubjectAlternativeNameExtension.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -83,1 +83,0 @@\n-     * @throws IOException on error\n@@ -86,1 +85,1 @@\n-            List<AccessDescription> accessDescriptions) throws IOException {\n+            List<AccessDescription> accessDescriptions) {\n@@ -146,1 +145,0 @@\n-     * @exception IOException on encoding errors.\n@@ -149,1 +147,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n@@ -159,1 +157,1 @@\n-    private void encodeThis() throws IOException {\n+    private void encodeThis() {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/SubjectInfoAccessExtension.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    private void encodeThis() throws IOException {\n+    private void encodeThis() {\n@@ -75,2 +75,1 @@\n-    public SubjectKeyIdentifierExtension(byte[] octetString)\n-            throws IOException {\n+    public SubjectKeyIdentifierExtension(byte[] octetString) {\n@@ -113,1 +112,0 @@\n-     * @exception IOException on encoding errors.\n@@ -116,1 +114,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/SubjectKeyIdentifierExtension.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -200,1 +200,0 @@\n-     * @exception IOException on encoding errors.\n@@ -202,1 +201,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    @Override\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/URIName.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,1 +95,0 @@\n-     * @exception IOException on errors.\n@@ -97,1 +96,1 @@\n-    public void encode(DerOutputStream out, byte tag) throws IOException {\n+    public void encode(DerOutputStream out, byte tag) {\n@@ -105,1 +104,1 @@\n-        out.write(bytes);\n+        out.writeBytes(bytes);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/UniqueIdentity.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -367,1 +367,0 @@\n-     * @exception IOException on encoding errors.\n@@ -370,1 +369,1 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X400Address.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -829,1 +829,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n+    @Override\n+    public void encode(DerOutputStream out) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X500Name.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -155,1 +155,0 @@\n-     * @exception CRLException on encoding errors.\n@@ -157,12 +156,11 @@\n-    public void encode(DerOutputStream outStrm) throws CRLException {\n-        try {\n-            if (revokedCert == null) {\n-                DerOutputStream tmp = new DerOutputStream();\n-                \/\/ sequence { serialNumber, revocationDate, extensions }\n-                serialNumber.encode(tmp);\n-\n-                if (revocationDate.getTime() < CertificateValidity.YR_2050) {\n-                    tmp.putUTCTime(revocationDate);\n-                } else {\n-                    tmp.putGeneralizedTime(revocationDate);\n-                }\n+    public void encode(DerOutputStream outStrm) {\n+        if (revokedCert == null) {\n+            DerOutputStream tmp = new DerOutputStream();\n+            \/\/ sequence { serialNumber, revocationDate, extensions }\n+            serialNumber.encode(tmp);\n+\n+            if (revocationDate.getTime() < CertificateValidity.YR_2050) {\n+                tmp.putUTCTime(revocationDate);\n+            } else {\n+                tmp.putGeneralizedTime(revocationDate);\n+            }\n@@ -170,2 +168,2 @@\n-                if (extensions != null)\n-                    extensions.encode(tmp, isExplicit);\n+            if (extensions != null)\n+                extensions.encode(tmp, isExplicit);\n@@ -173,2 +171,2 @@\n-                DerOutputStream seq = new DerOutputStream();\n-                seq.write(DerValue.tag_Sequence, tmp);\n+            DerOutputStream seq = new DerOutputStream();\n+            seq.write(DerValue.tag_Sequence, tmp);\n@@ -176,5 +174,1 @@\n-                revokedCert = seq.toByteArray();\n-            }\n-            outStrm.write(revokedCert);\n-        } catch (IOException e) {\n-             throw new CRLException(\"Encoding error: \" + e.toString());\n+            revokedCert = seq.toByteArray();\n@@ -182,0 +176,1 @@\n+        outStrm.writeBytes(revokedCert);\n@@ -187,2 +182,0 @@\n-     *\n-     * @exception CRLException if an encoding error occurs.\n@@ -190,1 +183,1 @@\n-    public byte[] getEncoded() throws CRLException {\n+    public byte[] getEncoded() {\n@@ -195,1 +188,1 @@\n-    private byte[] getEncoded0() throws CRLException {\n+    private byte[] getEncoded0() {\n@@ -526,11 +519,6 @@\n-        try {\n-            byte[] thisEncoded = this.getEncoded0();\n-            byte[] thatEncoded = that.getEncoded0();\n-            for (int i=0; i<thisEncoded.length && i<thatEncoded.length; i++) {\n-                int a = thisEncoded[i] & 0xff;\n-                int b = thatEncoded[i] & 0xff;\n-                if (a != b) return a-b;\n-            }\n-            return thisEncoded.length -thatEncoded.length;\n-        } catch (CRLException ce) {\n-            return -1;\n+        byte[] thisEncoded = this.getEncoded0();\n+        byte[] thatEncoded = that.getEncoded0();\n+        for (int i=0; i<thisEncoded.length && i<thatEncoded.length; i++) {\n+            int a = thisEncoded[i] & 0xff;\n+            int b = thatEncoded[i] & 0xff;\n+            if (a != b) return a-b;\n@@ -538,0 +526,1 @@\n+        return thisEncoded.length -thatEncoded.length;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509CRLEntryImpl.java","additions":26,"deletions":37,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -301,14 +301,19 @@\n-            try {\n-                DerOutputStream tmp = new DerOutputStream();\n-                DerOutputStream rCerts = new DerOutputStream();\n-                DerOutputStream seq = new DerOutputStream();\n-\n-                if (version != 0) \/\/ v2 crl encode version\n-                    tmp.putInteger(version);\n-                infoSigAlgId.encode(tmp);\n-                if ((version == 0) && (issuer.toString() == null))\n-                    throw new CRLException(\"Null Issuer DN not allowed in v1 CRL\");\n-                issuer.encode(tmp);\n-\n-                if (thisUpdate.getTime() < CertificateValidity.YR_2050)\n-                    tmp.putUTCTime(thisUpdate);\n+            DerOutputStream tmp = new DerOutputStream();\n+            DerOutputStream rCerts = new DerOutputStream();\n+            DerOutputStream seq = new DerOutputStream();\n+\n+            if (version != 0) \/\/ v2 crl encode version\n+                tmp.putInteger(version);\n+            infoSigAlgId.encode(tmp);\n+            if ((version == 0) && (issuer.toString() == null))\n+                throw new CRLException(\"Null Issuer DN not allowed in v1 CRL\");\n+            issuer.encode(tmp);\n+\n+            if (thisUpdate.getTime() < CertificateValidity.YR_2050)\n+                tmp.putUTCTime(thisUpdate);\n+            else\n+                tmp.putGeneralizedTime(thisUpdate);\n+\n+            if (nextUpdate != null) {\n+                if (nextUpdate.getTime() < CertificateValidity.YR_2050)\n+                    tmp.putUTCTime(nextUpdate);\n@@ -316,1 +321,2 @@\n-                    tmp.putGeneralizedTime(thisUpdate);\n+                    tmp.putGeneralizedTime(nextUpdate);\n+            }\n@@ -318,12 +324,3 @@\n-                if (nextUpdate != null) {\n-                    if (nextUpdate.getTime() < CertificateValidity.YR_2050)\n-                        tmp.putUTCTime(nextUpdate);\n-                    else\n-                        tmp.putGeneralizedTime(nextUpdate);\n-                }\n-\n-                if (!revokedList.isEmpty()) {\n-                    for (X509CRLEntry entry : revokedList) {\n-                        ((X509CRLEntryImpl)entry).encode(rCerts);\n-                    }\n-                    tmp.write(DerValue.tag_Sequence, rCerts);\n+            if (!revokedList.isEmpty()) {\n+                for (X509CRLEntry entry : revokedList) {\n+                    ((X509CRLEntryImpl) entry).encode(rCerts);\n@@ -331,0 +328,2 @@\n+                tmp.write(DerValue.tag_Sequence, rCerts);\n+            }\n@@ -332,2 +331,2 @@\n-                if (extensions != null)\n-                    extensions.encode(tmp, isExplicit);\n+            if (extensions != null)\n+                extensions.encode(tmp, isExplicit);\n@@ -335,1 +334,1 @@\n-                seq.write(DerValue.tag_Sequence, tmp);\n+            seq.write(DerValue.tag_Sequence, tmp);\n@@ -337,4 +336,1 @@\n-                return seq.toByteArray();\n-            } catch (IOException e) {\n-                throw new CRLException(\"Encoding error: \" + e.getMessage());\n-            }\n+            return seq.toByteArray();\n@@ -342,1 +338,0 @@\n-\n@@ -608,4 +603,3 @@\n-        try {\n-            Signature sigEngine = SignatureUtil.fromKey(algorithm, key, provider);\n-            AlgorithmId sigAlgId = SignatureUtil.fromSignature(sigEngine, key);\n-            info.infoSigAlgId = sigAlgId;\n+        Signature sigEngine = SignatureUtil.fromKey(algorithm, key, provider);\n+        AlgorithmId sigAlgId = SignatureUtil.fromSignature(sigEngine, key);\n+        info.infoSigAlgId = sigAlgId;\n@@ -613,2 +607,2 @@\n-            DerOutputStream out = new DerOutputStream();\n-            DerOutputStream tmp = new DerOutputStream();\n+        DerOutputStream out = new DerOutputStream();\n+        DerOutputStream tmp = new DerOutputStream();\n@@ -616,3 +610,3 @@\n-            \/\/ encode crl info\n-            byte[] tbsCertList = info.encodeInfo();\n-            tmp.writeBytes(tbsCertList);\n+        \/\/ encode crl info\n+        byte[] tbsCertList = info.encodeInfo();\n+        tmp.writeBytes(tbsCertList);\n@@ -620,2 +614,2 @@\n-            \/\/ encode algorithm identifier\n-            sigAlgId.encode(tmp);\n+        \/\/ encode algorithm identifier\n+        sigAlgId.encode(tmp);\n@@ -623,4 +617,4 @@\n-            \/\/ Create and encode the signature itself.\n-            sigEngine.update(tbsCertList, 0, tbsCertList.length);\n-            byte[] signature = sigEngine.sign();\n-            tmp.putBitString(signature);\n+        \/\/ Create and encode the signature itself.\n+        sigEngine.update(tbsCertList, 0, tbsCertList.length);\n+        byte[] signature = sigEngine.sign();\n+        tmp.putBitString(signature);\n@@ -628,3 +622,3 @@\n-            \/\/ Wrap the signed data in a SEQUENCE { data, algorithm, sig }\n-            out.write(DerValue.tag_Sequence, tmp);\n-            byte[] signedCRL = out.toByteArray();\n+        \/\/ Wrap the signed data in a SEQUENCE { data, algorithm, sig }\n+        out.write(DerValue.tag_Sequence, tmp);\n+        byte[] signedCRL = out.toByteArray();\n@@ -632,6 +626,2 @@\n-            return new X509CRLImpl(info, sigAlgId, signature,\n-                    tbsCertList, signedCRL);\n-        } catch (IOException e) {\n-            throw new CRLException(\"Error while encoding data: \" +\n-                                   e.getMessage());\n-        }\n+        return new X509CRLImpl(info, sigAlgId, signature,\n+                tbsCertList, signedCRL);\n@@ -1254,2 +1244,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n-        out.write(signedCRL.clone());\n+    public void encode(DerOutputStream out) {\n+        out.writeBytes(signedCRL);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509CRLImpl.java","additions":51,"deletions":61,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -263,2 +263,0 @@\n-     *\n-     * @exception IOException on encoding error.\n@@ -267,2 +265,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n-        out.write(signedCert.clone());\n+    public void encode(DerOutputStream out) {\n+        out.writeBytes(signedCert);\n@@ -471,4 +469,3 @@\n-        try {\n-            Signature sigEngine = SignatureUtil.fromKey(\n-                    algorithm, key, provider);\n-            AlgorithmId algId = SignatureUtil.fromSignature(sigEngine, key);\n+        Signature sigEngine = SignatureUtil.fromKey(\n+                algorithm, key, provider);\n+        AlgorithmId algId = SignatureUtil.fromSignature(sigEngine, key);\n@@ -476,2 +473,2 @@\n-            DerOutputStream out = new DerOutputStream();\n-            DerOutputStream tmp = new DerOutputStream();\n+        DerOutputStream out = new DerOutputStream();\n+        DerOutputStream tmp = new DerOutputStream();\n@@ -479,4 +476,4 @@\n-            \/\/ encode certificate info\n-            info.setAlgorithmId(new CertificateAlgorithmId(algId));\n-            info.encode(tmp);\n-            byte[] rawCert = tmp.toByteArray();\n+        \/\/ encode certificate info\n+        info.setAlgorithmId(new CertificateAlgorithmId(algId));\n+        info.encode(tmp);\n+        byte[] rawCert = tmp.toByteArray();\n@@ -484,2 +481,2 @@\n-            \/\/ encode algorithm identifier\n-            algId.encode(tmp);\n+        \/\/ encode algorithm identifier\n+        algId.encode(tmp);\n@@ -487,4 +484,4 @@\n-            \/\/ Create and encode the signature itself.\n-            sigEngine.update(rawCert, 0, rawCert.length);\n-            byte[] signature = sigEngine.sign();\n-            tmp.putBitString(signature);\n+        \/\/ Create and encode the signature itself.\n+        sigEngine.update(rawCert, 0, rawCert.length);\n+        byte[] signature = sigEngine.sign();\n+        tmp.putBitString(signature);\n@@ -492,3 +489,3 @@\n-            \/\/ Wrap the signed data in a SEQUENCE { data, algorithm, sig }\n-            out.write(DerValue.tag_Sequence, tmp);\n-            byte[] signedCert = out.toByteArray();\n+        \/\/ Wrap the signed data in a SEQUENCE { data, algorithm, sig }\n+        out.write(DerValue.tag_Sequence, tmp);\n+        byte[] signedCert = out.toByteArray();\n@@ -496,4 +493,1 @@\n-            return new X509CertImpl(info, algId, signature, signedCert);\n-        } catch (IOException e) {\n-            throw new CertificateEncodingException(e.toString());\n-        }\n+        return new X509CertImpl(info, algId, signature, signedCert);\n@@ -1256,7 +1250,1 @@\n-                try {\n-                    name.encode(derOut);\n-                } catch (IOException ioe) {\n-                    \/\/ should not occur since name has already been decoded\n-                    \/\/ from cert (this would indicate a bug in our code)\n-                    throw new RuntimeException(\"name cannot be encoded\", ioe);\n-                }\n+                name.encode(derOut);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509CertImpl.java","additions":22,"deletions":34,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -148,1 +148,0 @@\n-     * @exception IOException on other errors.\n@@ -151,1 +150,1 @@\n-            throws CertificateException, IOException {\n+            throws CertificateException {\n@@ -156,1 +155,1 @@\n-            out.write(rawCertInfo.clone());\n+            out.writeBytes(rawCertInfo.clone());\n@@ -173,1 +172,1 @@\n-        } catch (IOException | CertificateException e) {\n+        } catch (CertificateException e) {\n@@ -467,2 +466,1 @@\n-    private void emit(DerOutputStream out)\n-    throws CertificateException, IOException {\n+    private void emit(DerOutputStream out) throws CertificateException {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509CertInfo.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-public class X509Key implements PublicKey {\n+public class X509Key implements PublicKey, DerEncoder {\n@@ -103,2 +103,1 @@\n-    private X509Key(AlgorithmId algid, BitArray key)\n-    throws InvalidKeyException {\n+    private X509Key(AlgorithmId algid, BitArray key) {\n@@ -193,1 +192,0 @@\n-     * @exception IOException on parsing errors.\n@@ -196,1 +194,1 @@\n-    protected void parseKeyBits() throws IOException, InvalidKeyException {\n+    protected void parseKeyBits() throws InvalidKeyException {\n@@ -290,2 +288,0 @@\n-     *\n-     * @exception IOException on encoding errors.\n@@ -293,2 +289,2 @@\n-    public final void encode(DerOutputStream out) throws IOException\n-    {\n+    @Override\n+    public final void encode(DerOutputStream out) {\n@@ -302,6 +298,1 @@\n-        try {\n-            return getEncodedInternal().clone();\n-        } catch (InvalidKeyException e) {\n-            \/\/ XXX\n-        }\n-        return null;\n+        return getEncodedInternal().clone();\n@@ -310,1 +301,1 @@\n-    public byte[] getEncodedInternal() throws InvalidKeyException {\n+    public byte[] getEncodedInternal() {\n@@ -313,9 +304,3 @@\n-            try {\n-                DerOutputStream out = new DerOutputStream();\n-                encode(out);\n-                encoded = out.toByteArray();\n-            } catch (IOException e) {\n-                throw new InvalidKeyException(\"IOException : \" +\n-                                               e.getMessage());\n-            }\n-            encodedKey = encoded;\n+            DerOutputStream out = new DerOutputStream();\n+            encode(out);\n+            encodedKey = encoded = out.toByteArray();\n@@ -335,2 +320,0 @@\n-     *\n-     * @exception InvalidKeyException on encoding errors.\n@@ -338,1 +321,1 @@\n-    public byte[] encode() throws InvalidKeyException {\n+    public byte[] encode() {\n@@ -431,11 +414,6 @@\n-        try {\n-            byte[] thisEncoded = this.getEncodedInternal();\n-            byte[] otherEncoded;\n-            if (obj instanceof X509Key) {\n-                otherEncoded = ((X509Key)obj).getEncodedInternal();\n-            } else {\n-                otherEncoded = ((Key)obj).getEncoded();\n-            }\n-            return Arrays.equals(thisEncoded, otherEncoded);\n-        } catch (InvalidKeyException e) {\n-            return false;\n+        byte[] thisEncoded = this.getEncodedInternal();\n+        byte[] otherEncoded;\n+        if (obj instanceof X509Key) {\n+            otherEncoded = ((X509Key) obj).getEncodedInternal();\n+        } else {\n+            otherEncoded = ((Key) obj).getEncoded();\n@@ -443,0 +421,1 @@\n+        return Arrays.equals(thisEncoded, otherEncoded);\n@@ -450,10 +429,4 @@\n-        try {\n-            byte[] b1 = getEncodedInternal();\n-            int r = b1.length;\n-            for (int i = 0; i < b1.length; i++) {\n-                r += (b1[i] & 0xff) * 37;\n-            }\n-            return r;\n-        } catch (InvalidKeyException e) {\n-            \/\/ should not happen\n-            return 0;\n+        byte[] b1 = getEncodedInternal();\n+        int r = b1.length;\n+        for (int i = 0; i < b1.length; i++) {\n+            r += (b1[i] & 0xff) * 37;\n@@ -461,0 +434,1 @@\n+        return r;\n@@ -466,2 +440,1 @@\n-    static void encode(DerOutputStream out, AlgorithmId algid, BitArray key)\n-        throws IOException {\n+    static void encode(DerOutputStream out, AlgorithmId algid, BitArray key) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509Key.java","additions":24,"deletions":51,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -418,2 +418,2 @@\n-The following sections describe the options that are obsolete,\n-deprecated, and removed:\n+The following sections describe the options that are deprecated,\n+obsolete, and removed:\n@@ -444,0 +444,3 @@\n+If the option \\f[V]-agentlib:foo\\f[R] is specified, then the JVM\n+attempts to load the library named \\f[V]foo\\f[R] using the platform\n+specific naming conventions and locations:\n@@ -446,5 +449,3 @@\n-\\f[B]Linux and macOS:\\f[R] If the option \\f[V]-agentlib:foo\\f[R] is\n-specified, then the JVM attempts to load the library named\n-\\f[V]libfoo.so\\f[R] in the location specified by the\n-\\f[V]LD_LIBRARY_PATH\\f[R] system variable (on macOS this variable is\n-\\f[V]DYLD_LIBRARY_PATH\\f[R]).\n+\\f[B]Linux and other POSIX-like platforms:\\f[R] The JVM attempts to load\n+the library named \\f[V]libfoo.so\\f[R] in the location specified by the\n+\\f[V]LD_LIBRARY_PATH\\f[R] system variable.\n@@ -452,3 +453,7 @@\n-\\f[B]Windows:\\f[R] If the option \\f[V]-agentlib:foo\\f[R] is specified,\n-then the JVM attempts to load the library named \\f[V]foo.dll\\f[R] in the\n-location specified by the \\f[V]PATH\\f[R] system variable.\n+\\f[B]macOS:\\f[R] The JVM attempts to load the library named\n+\\f[V]libfoo.dylib\\f[R] in the location specified by the\n+\\f[V]DYLD_LIBRARY_PATH\\f[R] system variable.\n+.IP \\[bu] 2\n+\\f[B]Windows:\\f[R] The JVM attempts to load the library named\n+\\f[V]foo.dll\\f[R] in the location specified by the \\f[V]PATH\\f[R] system\n+variable.\n@@ -814,4 +819,0 @@\n-The number of JNI local references existing when a JNI function\n-terminates exceeds the number guaranteed to be available.\n-See the \\f[V]EnsureLocalcapacity\\f[R] function.\n-.IP \\[bu] 2\n@@ -969,1 +970,1 @@\n-\\f[B]Linux and macOS:\\f[R]\n+\\f[B]Non-Windows:\\f[R]\n@@ -1015,1 +1016,1 @@\n-\\f[B]Linux and macOS:\\f[R] \\f[V]SIGQUIT\\f[R] thread dumps aren\\[aq]t\n+\\f[B]Non-Windows:\\f[R] \\f[V]SIGQUIT\\f[R] thread dumps aren\\[aq]t\n@@ -1021,1 +1022,1 @@\n-by calling the \\f[V]System.exit()\\f[R] when the JVM is to be terminated.\n+by calling \\f[V]System.exit()\\f[R] when the JVM is to be terminated.\n@@ -1072,1 +1073,1 @@\n-\\f[B]Linux:\\f[R] Shows host system or container configuration and\n+\\f[B]Linux only:\\f[R] Shows host system or container configuration and\n@@ -1083,1 +1084,2 @@\n-The default value depends on the platform:\n+The default value depends on the platform.\n+For example:\n@@ -1086,1 +1088,3 @@\n-Linux\/x64 (64-bit): 1024 KB\n+Linux\/x64: 1024 KB\n+.IP \\[bu] 2\n+Linux\/Aarch64: 2048 KB\n@@ -1088,1 +1092,3 @@\n-macOS (64-bit): 1024 KB\n+macOS\/x64: 1024 KB\n+.IP \\[bu] 2\n+macOS\/Aarch64: 2048 KB\n@@ -1254,2 +1260,2 @@\n-\\f[B]Linux and macOS:\\f[R] The following example shows how to set the\n-error log to \\f[V]\/var\/log\/java\/java_error.log\\f[R]:\n+\\f[B]Non-Windows:\\f[R] The following example shows how to set the error\n+log to \\f[V]\/var\/log\/java\/java_error.log\\f[R]:\n@@ -1277,1 +1283,1 @@\n-\\f[B]Linux and macOS:\\f[R] The temporary directory is \\f[V]\/tmp\\f[R].\n+\\f[B]Non-Windows:\\f[R] The temporary directory is \\f[V]\/tmp\\f[R].\n@@ -1409,1 +1415,1 @@\n-The only time that you may need to disable this is on Mac OS, where its\n+The only time that you may need to disable this is on macOS, where its\n@@ -1488,1 +1494,1 @@\n-\\f[B]Linux and macOS:\\f[R] The following example shows how the\n+\\f[B]Non-Windows:\\f[R] The following example shows how the\n@@ -1732,1 +1738,2 @@\n-The default value depends on the platform:\n+The default value depends on the platform.\n+For example:\n@@ -1735,1 +1742,5 @@\n-Linux\/x64 (64-bit): 1024 KB\n+Linux\/x64: 1024 KB\n+.IP \\[bu] 2\n+Linux\/Aarch64: 2048 KB\n+.IP \\[bu] 2\n+macOS\/x64: 1024 KB\n@@ -1737,1 +1748,1 @@\n-macOS (64-bit): 1024 KB\n+macOS\/Aarch64: 2048 KB\n@@ -1775,3 +1786,4 @@\n-The VM now provides automatic container detection support, which allows\n-the VM to determine the amount of memory and number of processors that\n-are available to a Java process running in docker containers.\n+\\f[B]Linux only:\\f[R] The VM now provides automatic container detection\n+support, which allows the VM to determine the amount of memory and\n+number of processors that are available to a Java process running in\n+docker containers.\n@@ -1779,3 +1791,2 @@\n-This support is only available on Linux x64 platforms.\n-If supported, the default for this flag is \\f[V]true\\f[R], and container\n-support is enabled by default.\n+The default for this flag is \\f[V]true\\f[R], and container support is\n+enabled by default.\n@@ -1825,1 +1836,2 @@\n-Enables installation of signal handlers by the application.\n+\\f[B]Non-Windows:\\f[R] Enables installation of signal handlers by the\n+application.\n@@ -2785,2 +2797,2 @@\n-\\f[B]Linux and macOS:\\f[R] The following example shows how to set the\n-heap dump file to \\f[V]\/var\/log\/java\/java_heapdump.hprof\\f[R]:\n+\\f[B]Non-Windows:\\f[R] The following example shows how to set the heap\n+dump file to \\f[V]\/var\/log\/java\/java_heapdump.hprof\\f[R]:\n@@ -2810,2 +2822,2 @@\n-\\f[B]Linux and macOS:\\f[R] The following example shows how to set the\n-log file to \\f[V]\/var\/log\/java\/hotspot.log\\f[R]:\n+\\f[B]Non-Windows:\\f[R] The following example shows how to set the log\n+file to \\f[V]\/var\/log\/java\/hotspot.log\\f[R]:\n@@ -2834,1 +2846,1 @@\n-\\f[B]Linux and macOS:\\f[R] \\f[V]Control+Break\\f[R]\n+\\f[B]Non-Windows:\\f[R] \\f[V]Control+\\[rs]\\f[R] (\\f[V]SIGQUIT\\f[R])\n@@ -2851,1 +2863,1 @@\n-\\f[B]Linux and macOS:\\f[R] \\f[V]Control+Break\\f[R]\n+\\f[B]Non-Windows:\\f[R] \\f[V]Control+\\[rs]\\f[R] (\\f[V]SIGQUIT\\f[R])\n","filename":"src\/java.base\/share\/man\/java.1","additions":54,"deletions":42,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -139,0 +139,6 @@\n+    if (elements != NULL) {\n+        for (i = 0; i < nElements; i++) {\n+            NSString *pbFormat = formatForIndex(elements[i]);\n+            if (pbFormat)\n+                [formatArray addObject:pbFormat];\n+        }\n@@ -140,4 +146,2 @@\n-    for (i = 0; i < nElements; i++) {\n-        NSString *pbFormat = formatForIndex(elements[i]);\n-        if (pbFormat)\n-            [formatArray addObject:pbFormat];\n+        (*env)->ReleasePrimitiveArrayCritical(env, inTypes, elements, JNI_ABORT);\n+        [[CClipboard sharedClipboard] declareTypes:formatArray withOwner:inJavaClip jniEnv:env];\n@@ -145,3 +149,0 @@\n-\n-    (*env)->ReleasePrimitiveArrayCritical(env, inTypes, elements, JNI_ABORT);\n-    [[CClipboard sharedClipboard] declareTypes:formatArray withOwner:inJavaClip jniEnv:env];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CClipboard.m","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -61,2 +61,3 @@\n-    CTS_GetGlyphsAsIntsForCharacters(awtFont, unicodes,\n-                                     cgGlyphs, glyphCodeInts, count);\n+    if (glyphCodeInts != NULL) {\n+        CTS_GetGlyphsAsIntsForCharacters(awtFont, unicodes,\n+                                         cgGlyphs, glyphCodeInts, count);\n@@ -64,3 +65,4 @@\n-    \/\/ Do not use JNI_COMMIT, as that will not free the buffer copy\n-    \/\/ when +ProtectJavaHeap is on.\n-    (*env)->ReleasePrimitiveArrayCritical(env, glyphs, glyphCodeInts, 0);\n+        \/\/ Do not use JNI_COMMIT, as that will not free the buffer copy\n+        \/\/ when +ProtectJavaHeap is on.\n+        (*env)->ReleasePrimitiveArrayCritical(env, glyphs, glyphCodeInts, 0);\n+    }\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/CCharToGlyphMapper.m","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -280,5 +280,7 @@\n-    rect[0] = partBounds.origin.x;\n-    rect[1] = partBounds.origin.y;\n-    rect[2] = partBounds.size.width;\n-    rect[3] = partBounds.size.height;\n-    (*env)->ReleasePrimitiveArrayCritical(env, rectArray, rect, 0);\n+    if (rect != NULL) {\n+        rect[0] = partBounds.origin.x;\n+        rect[1] = partBounds.origin.y;\n+        rect[2] = partBounds.size.width;\n+        rect[3] = partBounds.size.height;\n+        (*env)->ReleasePrimitiveArrayCritical(env, rectArray, rect, 0);\n+    }\n","filename":"src\/java.desktop\/macosx\/native\/libosxui\/JRSUIController.m","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -354,0 +354,2 @@\n+            FileSystemView fsv = getFileChooser().getFileSystemView();\n+            getChangeToParentDirectoryAction().setEnabled(!fsv.isFileSystemRoot(currentDirectory));\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKFileChooserUI.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -593,0 +593,1 @@\n+                 \"BACK_SPACE\", \"Go Up\",\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKLookAndFeel.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -289,0 +289,12 @@\n+\n+        if ((c instanceof JCheckBox) && (state & SynthConstants.DISABLED) != 0) {\n+            if (UIManager.getColor(\"CheckBox.disabledText\") != null) {\n+                return UIManager.getColor(\"CheckBox.disabledText\");\n+            }\n+        } else if ((c instanceof JRadioButton) &&\n+                (state & SynthConstants.DISABLED) != 0) {\n+            if (UIManager.getColor(\"RadioButton.disabledText\") != null) {\n+                return UIManager.getColor(\"RadioButton.disabledText\");\n+            }\n+        }\n+\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKStyle.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+ * @sealedGraph\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/MultipleGradientPaint.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+ * @sealedGraph\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/TextComponent.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import sun.awt.AWTAccessor;\n@@ -137,0 +138,4 @@\n+    static {\n+        AWTAccessor.setICC_ProfileAccessor(ICC_Profile::cmmProfile);\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_Profile.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+ * @sealedGraph\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/desktop\/AppEvent.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+ * @sealedGraph\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/desktop\/FilesEvent.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+ * @sealedGraph\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/event\/InputEvent.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+ * @sealedGraph\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/Path2D.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,3 +38,1 @@\n-import sun.java2d.StateTrackable.State;\n-import static sun.java2d.StateTrackable.State.*;\n-import sun.java2d.StateTrackableDelegate;\n+import java.lang.annotation.Native;\n@@ -43,0 +41,2 @@\n+import sun.java2d.StateTrackable.State;\n+import sun.java2d.StateTrackableDelegate;\n@@ -44,1 +44,1 @@\n-import java.lang.annotation.Native;\n+import static sun.java2d.StateTrackable.State.UNTRACKABLE;\n@@ -78,1 +78,1 @@\n-    \/** Tag for signed short data.  Placeholder for future use. *\/\n+    \/** Tag for signed short data. *\/\n@@ -84,1 +84,1 @@\n-    \/** Tag for float data.  Placeholder for future use. *\/\n+    \/** Tag for float data. *\/\n@@ -87,1 +87,1 @@\n-    \/** Tag for double data.  Placeholder for future use. *\/\n+    \/** Tag for double data. *\/\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/DataBuffer.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.util.HashMap;\n@@ -32,4 +31,0 @@\n-import java.util.Map;\n-import java.util.NoSuchElementException;\n-import java.util.Set;\n-import java.util.Vector;\n@@ -55,0 +50,1 @@\n+import java.util.List;\n@@ -90,1 +86,1 @@\n-     * A {@code Vector} containing the valid IIO registry\n+     * A {@code List} containing the valid IIO registry\n@@ -93,9 +89,7 @@\n-    private static final Vector<Class<?>> initialCategories = new Vector<>(5);\n-\n-    static {\n-        initialCategories.add(ImageReaderSpi.class);\n-        initialCategories.add(ImageWriterSpi.class);\n-        initialCategories.add(ImageTranscoderSpi.class);\n-        initialCategories.add(ImageInputStreamSpi.class);\n-        initialCategories.add(ImageOutputStreamSpi.class);\n-    }\n+    private static final List<Class<?>> initialCategories = List.of(\n+            ImageReaderSpi.class,\n+            ImageWriterSpi.class,\n+            ImageTranscoderSpi.class,\n+            ImageInputStreamSpi.class,\n+            ImageOutputStreamSpi.class\n+    );\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/spi\/IIORegistry.java","additions":10,"deletions":16,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import javax.swing.text.AbstractDocument;\n@@ -41,0 +42,1 @@\n+import javax.swing.text.DocumentFilter;\n@@ -303,12 +305,20 @@\n-        int nleft = doc.getLength();\n-        Segment text = new Segment();\n-        \/\/ we would like to get direct data array access, not a copy of it\n-        text.setPartialReturn(true);\n-        int offs = 0;\n-        try {\n-            while (nleft > 0) {\n-                doc.getText(offs, nleft, text);\n-                Arrays.fill(text.array, text.offset,\n-                            text.count + text.offset, '\\u0000');\n-                nleft -= text.count;\n-                offs += text.count;\n+        DocumentFilter filter = null;\n+        if (doc instanceof AbstractDocument adoc) {\n+            filter = adoc.getDocumentFilter();\n+        }\n+        if (filter == null) {\n+            int nleft = doc.getLength();\n+            Segment text = new Segment();\n+            \/\/ we would like to get direct data array access, not a copy of it\n+            text.setPartialReturn(true);\n+            int offs = 0;\n+            try {\n+                while (nleft > 0) {\n+                    doc.getText(offs, nleft, text);\n+                    Arrays.fill(text.array, text.offset,\n+                                text.count + text.offset, '\\u0000');\n+                    nleft -= text.count;\n+                    offs += text.count;\n+                }\n+            } catch (BadLocationException ignored) {\n+                \/\/ we tried\n@@ -316,2 +326,0 @@\n-        } catch (BadLocationException ignored) {\n-            \/\/ we tried\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JPasswordField.java","additions":23,"deletions":15,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -620,0 +620,3 @@\n+                if (table.isEditing()) {\n+                    table.getCellEditor().cancelCellEditing();\n+                }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicTableUI.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+import static sun.java2d.pipe.Region.clipRound;\n+\n@@ -249,13 +251,0 @@\n-        \/**\n-         * Rounds a double to the nearest integer. It rounds 0.5 down,\n-         * for example 1.5 is rounded to 1.0.\n-         *\n-         * @param d number to be rounded\n-         * @return the rounded value\n-         *\/\n-        private static int roundHalfDown(double d) {\n-            double decP = (Math.ceil(d) - d);\n-            return (int)((decP == 0.5) ?  Math.floor(d) :  Math.round(d));\n-        }\n-\n-\n@@ -278,4 +267,3 @@\n-            Graphics2D g2d = (Graphics2D) g;\n-            AffineTransform at = g2d.getTransform();\n-            Stroke oldStk = g2d.getStroke();\n-            Color oldColor = g2d.getColor();\n+            AffineTransform at = null;\n+            Stroke oldStk = null;\n+            boolean resetTransform = false;\n@@ -283,0 +271,10 @@\n+            double scaleFactor = 1;\n+\n+            if (g instanceof Graphics2D g2d) {\n+                at = g2d.getTransform();\n+                scaleFactor = at.getScaleX();\n+                oldStk = g2d.getStroke();\n+\n+                \/\/ if m01 or m10 is non-zero, then there is a rotation or shear\n+                \/\/ skip resetting the transform\n+                resetTransform = ((at.getShearX() == 0) && (at.getShearY() == 0));\n@@ -284,3 +282,6 @@\n-            \/\/ if m01 or m10 is non-zero, then there is a rotation or shear\n-            \/\/ skip resetting the transform\n-            boolean resetTransform = ((at.getShearX() == 0) && (at.getShearY() == 0));\n+                if (resetTransform) {\n+                    g2d.setTransform(new AffineTransform());\n+                    stkWidth = clipRound(Math.min(at.getScaleX(), at.getScaleY()));\n+                    g2d.setStroke(new BasicStroke((float) stkWidth));\n+                }\n+            }\n@@ -294,3 +295,0 @@\n-                g2d.setTransform(new AffineTransform());\n-                stkWidth = roundHalfDown(Math.min(at.getScaleX(), at.getScaleY()));\n-\n@@ -299,4 +297,4 @@\n-                xtranslation = roundHalfDown(xx);\n-                ytranslation = roundHalfDown(yy);\n-                width = roundHalfDown(at.getScaleX() * w + xx) - xtranslation;\n-                height = roundHalfDown(at.getScaleY() * h + yy) - ytranslation;\n+                xtranslation = clipRound(xx);\n+                ytranslation = clipRound(yy);\n+                width = clipRound(at.getScaleX() * w + xx) - xtranslation;\n+                height = clipRound(at.getScaleY() * h + yy) - ytranslation;\n@@ -304,2 +302,0 @@\n-                width = w;\n-                height = h;\n@@ -308,0 +304,2 @@\n+                width = w;\n+                height = h;\n@@ -309,1 +307,1 @@\n-            g2d.translate(xtranslation, ytranslation);\n+            g.translate(xtranslation, ytranslation);\n@@ -312,1 +310,1 @@\n-            int thickness = (int) Math.ceil(4 * at.getScaleX());\n+            int thickness = (int) Math.ceil(4 * scaleFactor);\n@@ -321,3 +319,0 @@\n-                \/\/ set new stroke to draw shadow and highlight lines\n-                g2d.setStroke(new BasicStroke((float) stkWidth));\n-\n@@ -327,1 +322,1 @@\n-                int offset = ((at.getScaleX() - stkWidth) >= 0 && stkWidth % 2 != 0) ? 1 : 0;\n+                int offset = (((scaleFactor - stkWidth) >= 0) && ((stkWidth % 2) != 0)) ? 1 : 0;\n@@ -331,1 +326,1 @@\n-                int corner = (int) Math.round(CORNER * at.getScaleX());\n+                int corner = (int) Math.round(CORNER * scaleFactor);\n@@ -353,1 +348,1 @@\n-            g2d.translate(-xtranslation, -ytranslation);\n+            g.translate(-xtranslation, -ytranslation);\n@@ -355,1 +350,1 @@\n-                g2d.setColor(oldColor);\n+                Graphics2D g2d = (Graphics2D) g;\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalBorders.java","additions":33,"deletions":38,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+ * @sealedGraph\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/StyleConstants.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -706,1 +706,1 @@\n-                } else if (s.terminate()) {\n+                } else if (s.terminate() && !s.elem.omitEnd()) {\n@@ -711,0 +711,1 @@\n+                    \/\/ but not if the closing tag is optional like tr,th,td\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/parser\/Parser.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.awt.color.ICC_Profile;\n@@ -53,0 +54,2 @@\n+import sun.java2d.cmm.Profile;\n+\n@@ -70,0 +73,10 @@\n+    \/*\n+     * An interface of accessor for the java.awt.color.ICC_Profile class.\n+     *\/\n+    public interface ICC_ProfileAccessor {\n+        \/*\n+         * Activates and returns the deferred standard profiles.\n+         *\/\n+        Profile cmmProfile(ICC_Profile profile);\n+    }\n+\n@@ -834,0 +847,1 @@\n+    private static ICC_ProfileAccessor iccProfileAccessor;\n@@ -866,0 +880,19 @@\n+    \/*\n+     * Set an accessor object for the java.awt.color.ICC_Profile class.\n+     *\/\n+    public static void setICC_ProfileAccessor(ICC_ProfileAccessor ipa) {\n+        iccProfileAccessor = ipa;\n+    }\n+\n+    \/*\n+     * Retrieve the accessor object for the java.awt.color.ICC_Profile class.\n+     *\/\n+    public static ICC_ProfileAccessor getICC_ProfileAccessor() {\n+        var access = iccProfileAccessor;\n+        if (access == null) {\n+            ensureClassInitialized(ICC_Profile.class);\n+            access = iccProfileAccessor;\n+        }\n+        return access;\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/AWTAccessor.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    private static LCMSProfile getLcmsProfile(Profile p) {\n+    static LCMSProfile getLcmsProfile(Profile p) {\n@@ -98,2 +98,0 @@\n-    static synchronized native LCMSProfile getProfileID(ICC_Profile profile);\n-\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMS.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import sun.awt.AWTAccessor;\n@@ -88,0 +89,1 @@\n+        var acc = AWTAccessor.getICC_ProfileAccessor();\n@@ -90,1 +92,1 @@\n-            lcmsProfiles[i] = LCMS.getProfileID(profiles[i]);\n+            lcmsProfiles[i] = LCMS.getLcmsProfile(acc.cmmProfile(profiles[i]));\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMSTransform.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,2 @@\n+DECLARE_SRCOVER_MASKBLIT(FourByteAbgrPre, IntArgbPre);\n+DECLARE_ALPHA_MASKBLIT(FourByteAbgrPre, IntArgbPre);\n@@ -106,0 +108,2 @@\n+    REGISTER_SRCOVER_MASKBLIT(FourByteAbgrPre, IntArgbPre),\n+    REGISTER_ALPHA_MASKBLIT(FourByteAbgrPre, IntArgbPre),\n@@ -180,0 +184,4 @@\n+DEFINE_SRCOVER_MASKBLIT(FourByteAbgrPre, IntArgbPre, 4ByteArgb)\n+\n+DEFINE_ALPHA_MASKBLIT(FourByteAbgrPre, IntArgbPre, 4ByteArgb)\n+\n","filename":"src\/java.desktop\/share\/native\/libawt\/java2d\/loops\/FourByteAbgrPre.c","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -560,34 +560,0 @@\n-\/*\n- * Class:     sun_java2d_cmm_lcms_LCMS\n- * Method:    getProfileID\n- * Signature: (Ljava\/awt\/color\/ICC_Profile;)Lsun\/java2d\/cmm\/lcms\/LCMSProfile;\n- *\/\n-JNIEXPORT jobject JNICALL Java_sun_java2d_cmm_lcms_LCMS_getProfileID\n-  (JNIEnv *env, jclass cls, jobject pf)\n-{\n-    if (pf == NULL) {\n-        return NULL;\n-    }\n-    jclass pcls = (*env)->GetObjectClass(env, pf);\n-    if (pcls == NULL) {\n-        return NULL;\n-    }\n-    jmethodID mid = (*env)->GetMethodID(env, pcls, \"cmmProfile\",\n-                                        \"()Lsun\/java2d\/cmm\/Profile;\");\n-    if (mid == NULL) {\n-        return NULL;\n-    }\n-    jobject cmmProfile = (*env)->CallObjectMethod(env, pf, mid);\n-    if ((*env)->ExceptionCheck(env)) {\n-        return NULL;\n-    }\n-    jclass lcmsPCls = (*env)->FindClass(env, \"sun\/java2d\/cmm\/lcms\/LCMSProfile\");\n-    if (lcmsPCls == NULL) {\n-        return NULL;\n-    }\n-    if ((*env)->IsInstanceOf(env, cmmProfile, lcmsPCls)) {\n-        return cmmProfile;\n-    }\n-    return NULL;\n-}\n-\n","filename":"src\/java.desktop\/share\/native\/liblcms\/LCMS.c","additions":0,"deletions":34,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -338,0 +338,5 @@\n+    if (buffer == 0) {\n+        (*env)->ExceptionClear(env);\n+        JNU_ThrowOutOfMemoryError(env, \"Could not get image buffer\");\n+        return -1;\n+    }\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/swing_GTKEngine.c","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -439,4 +439,5 @@\n-        BOOL transparent = FALSE;\n-        transparent = IsThemeBackgroundPartiallyTransparentFunc(hTheme, part, state);\n-        copyDIBToBufferedImage(pDstBits, pSrcBits, transparent, w, h, stride);\n-        env->ReleasePrimitiveArrayCritical(array, pDstBits, 0);\n+        if (pDstBits != NULL) {\n+            BOOL transparent = IsThemeBackgroundPartiallyTransparentFunc(hTheme, part, state);\n+            copyDIBToBufferedImage(pDstBits, pSrcBits, transparent, w, h, stride);\n+            env->ReleasePrimitiveArrayCritical(array, pDstBits, 0);\n+        }\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/ThemeReader.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -166,0 +166,4 @@\n+    if (pLogPalette == NULL) {\n+        env->DeleteLocalRef(paletteBytes);\n+        return NULL;\n+    }\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_DataTransferer.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2864,2 +2864,4 @@\n-        for (int i = 0; i < (sizeof indexMap)\/(sizeof *indexMap) && i < colorLen; i++) {\n-            colorsPtr[i] = DesktopColor2RGB(indexMap[i]);\n+        if (colorsPtr != NULL) {\n+            for (int i = 0; i < (sizeof indexMap)\/(sizeof *indexMap) && i < colorLen; i++) {\n+                colorsPtr[i] = DesktopColor2RGB(indexMap[i]);\n+            }\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Toolkit.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-    static final int DEFAULT_KEEP_ALIVE_TIMEOUT = 1200;\n+    static final int DEFAULT_KEEP_ALIVE_TIMEOUT = 30;\n@@ -362,0 +362,1 @@\n+    private final WeakReference<HttpClientImpl> implRef;\n@@ -405,0 +406,1 @@\n+    private final AtomicBoolean isStarted = new AtomicBoolean();\n@@ -473,0 +475,1 @@\n+        implRef = new WeakReference<>(this);\n@@ -522,1 +525,6 @@\n-        selmgr.start();\n+        try {\n+            selmgr.start();\n+        } catch (Throwable t) {\n+            isStarted.set(true);\n+            throw t;\n+        }\n@@ -717,0 +725,1 @@\n+        final Reference<?> implRef;\n@@ -718,0 +727,1 @@\n+        final AtomicBoolean isStarted;\n@@ -727,0 +737,1 @@\n+                          Reference<?> implRef,\n@@ -728,0 +739,1 @@\n+                          AtomicBoolean isStarted,\n@@ -737,0 +749,1 @@\n+            this.implRef = implRef;\n@@ -738,0 +751,1 @@\n+            this.isStarted = isStarted;\n@@ -768,0 +782,4 @@\n+        public boolean isImplementationReferenced() {\n+            return !implRef.refersTo(null);\n+        }\n+        \/\/ The selector is considered alive if it's not yet started\n@@ -769,1 +787,1 @@\n-        public boolean isSelectorAlive() { return isAlive.get(); }\n+        public boolean isSelectorAlive() { return isAlive.get() || !isStarted.get(); }\n@@ -786,0 +804,1 @@\n+                implRef,\n@@ -787,0 +806,1 @@\n+                isStarted,\n@@ -1158,1 +1178,2 @@\n-            owner.isAlive.set(true);\n+            owner.isAlive.set(true);   \/\/ goes back to false when run exits\n+            owner.isStarted.set(true); \/\/ never goes back to false\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -552,0 +552,1 @@\n+                            assert buffers.remainingCapacity() > 1; \/\/ should contain at least 2\n@@ -558,1 +559,0 @@\n-                    assert buffers.remainingCapacity() > 1; \/\/ should contain at least 2\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ResponseSubscribers.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -178,3 +178,0 @@\n-                } else {\n-                    if (debug.on()) debug.log(\"subscribing user subscriber\");\n-                    subscriber.onSubscribe(userSubscription);\n@@ -182,0 +179,2 @@\n+                if (debug.on()) debug.log(\"subscribing user subscriber\");\n+                subscriber.onSubscribe(userSubscription);\n@@ -420,1 +419,1 @@\n-        \/\/ ensure that the body subscriber will be subsribed and onError() is\n+        \/\/ ensure that the body subscriber will be subscribed and onError() is\n@@ -537,1 +536,1 @@\n-                \/\/ we haven't receive the headers yet, and won't receive any!\n+                \/\/ we haven't received the headers yet, and won't receive any!\n@@ -539,1 +538,1 @@\n-                handleReset(frame, subscriber);\n+                handleReset(frame, null);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -67,0 +67,3 @@\n+        \/\/ Whether the implementation of the facade\n+        \/\/ is still referenced\n+        boolean isImplementationReferenced();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/OperationTrackers.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,131 @@\n- *\n+ * <p>\n+ * <b id=\"httpclientprops\">System properties used by the java.net.http API<\/b>\n+ * <p>\n+ * The following is a list of system networking properties used by the java.net.http\n+ * client implementation in the JDK. Any properties below that take a numeric value\n+ * assume the default value if given a string that does not parse as a number.\n+ * Unless otherwise specified below, all values can be set in the {@code conf\/net.properties}\n+ * file. In all cases, values can be specified as system properties on the command line,\n+ * in which case, any value in {@code conf\/net.properties} is overridden. No guarantee is\n+ * provided that property values can be set programatically with {@code System.setProperty()}.\n+ * Other implementations of this API may choose not to support these properties.\n+ * <ul>\n+ * <li><p><b>{@systemProperty jdk.httpclient.allowRestrictedHeaders}<\/b> (default: see below)<br>\n+ * A comma-separated list of normally restricted HTTP header names that users may set in HTTP\n+ * requests or by user code in HttpRequest instances. By default, the following request\n+ * headers are not allowed to be set by user code: connection, content-length, expect, host,\n+ * and upgrade. You can override this behavior with this property. The names are case-insensitive\n+ * and whitespace is ignored. Note that this property is intended for testing and not for\n+ * real-world deployments. Protocol errors or other undefined behavior are likely to occur\n+ * when using this property. There may be other headers that are restricted from being set\n+ * depending on the context. This includes the \"Authorization\" header when the relevant\n+ * HttpClient has an authenticator set. These restrictions cannot be overridden by this\n+ * property.\n+ * <\/li>\n+ * <li><p><b>{@systemProperty jdk.httpclient.bufsize}<\/b> (default: 16384 bytes or 16 kB)<br>\n+ * The size to use for internal allocated buffers in bytes.\n+ * <\/li>\n+ * <li><p><b>{@systemProperty jdk.httpclient.connectionPoolSize}<\/b> (default: 0)<br>\n+ * The maximum number of connections to keep in the HTTP\/1.1 keep alive cache. A value of 0\n+ * means that the cache is unbounded.\n+ * <\/li>\n+ * <li><p><b>{@systemProperty jdk.httpclient.connectionWindowSize}<\/b> (default: 2^26)<br>\n+ * The HTTP\/2 client connection window size in bytes. The maximum size is 2^31-1. This value\n+ * cannot be smaller than the stream window size, which can be configured through the\n+ * {@code jdk.httpclient.windowsize} system property.\n+ * <\/li>\n+ * <li><p><b>{@systemProperty jdk.httpclient.disableRetryConnect}<\/b> (default: false)<br>\n+ * Whether automatic retry of connection failures is disabled. If false, then retries are\n+ * attempted (subject to the retry limit).\n+ * <\/li>\n+ * <li><p><b>{@systemProperty jdk.httpclient.enableAllMethodRetry}<\/b> (default: false)<br>\n+ * Whether it is permitted to automatically retry non-idempotent HTTP requests.\n+ * <\/li>\n+ * <li><p><b>{@systemProperty jdk.httpclient.enablepush}<\/b> (default: 1)<br>\n+ * Whether HTTP\/2 push promise is enabled. A value of 1 enables push promise; a value of 0\n+ * disables it.\n+ * <\/li>\n+ * <li><p><b>{@systemProperty jdk.httpclient.hpack.maxheadertablesize}<\/b> (default: 16384 or\n+ * 16 kB)<br> The HTTP\/2 client maximum HPACK header table size in bytes.\n+ * <\/li>\n+ * <li><p><b>{@systemProperty jdk.httpclient.HttpClient.log}<\/b> (default: none)<br>\n+ * Enables high-level logging of various events through the {@linkplain java.lang.System.Logger\n+ * Platform Logging API}. The value contains a comma-separated list of any of the\n+ * following items:\n+ * <ul>\n+ *   <li>errors<\/li>\n+ *   <li>requests<\/li>\n+ *   <li>headers<\/li>\n+ *   <li>content<\/li>\n+ *   <li>frames<\/li>\n+ *   <li>ssl<\/li>\n+ *   <li>trace<\/li>\n+ *   <li>channel<\/li>\n+ * <\/ul><br>\n+ * You can append the frames item with a colon-separated list of any of the following items:\n+ * <ul>\n+ *   <li>control<\/li>\n+ *   <li>data<\/li>\n+ *   <li>window<\/li>\n+ *   <li>all<\/li>\n+ * <\/ul><br>\n+ * Specifying an item adds it to the HTTP client's log. For example, if you specify the\n+ * following value, then the Platform Logging API logs all possible HTTP Client events:<br>\n+ * \"errors,requests,headers,frames:control:data:window,ssl,trace,channel\"<br>\n+ * Note that you can replace control:data:window with all. The name of the logger is\n+ * \"jdk.httpclient.HttpClient\", and all logging is at level INFO.\n+ * <\/li>\n+ * <li><p><b>{@systemProperty jdk.httpclient.keepalive.timeout}<\/b> (default: 30)<br>\n+ * The number of seconds to keep idle HTTP connections alive in the keep alive cache. This\n+ * property applies to both HTTP\/1.1 and HTTP\/2. The value for HTTP\/2 can be overridden\n+ * with the {@code jdk.httpclient.keepalive.timeout.h2 property}.\n+ * <\/li>\n+ * <li><p><b>{@systemProperty jdk.httpclient.keepalive.timeout.h2}<\/b> (default: see\n+ * below)<br>The number of seconds to keep idle HTTP\/2 connections alive. If not set, then the\n+ * {@code jdk.httpclient.keepalive.timeout} setting is used.\n+ * <\/li>\n+ * <li><p><b>{@systemProperty jdk.httpclient.maxframesize}<\/b> (default: 16384 or 16kB)<br>\n+ * The HTTP\/2 client maximum frame size in bytes. The server is not permitted to send a frame\n+ * larger than this.\n+ * <\/li>\n+ * <li><p><b>{@systemProperty jdk.httpclient.maxstreams}<\/b> (default: 100)<br>\n+ * The maximum number of HTTP\/2 push streams that the client will permit servers to open\n+ * simultaneously.\n+ * <\/li>\n+ * <li><p><b>{@systemProperty jdk.httpclient.receiveBufferSize}<\/b> (default: operating system\n+ * default)<br>The HTTP client <a href=\"..\/java.base\/java\/net\/StandardSocketOptions.html#SO_RCVBUF\">\n+ * socket receive buffer size<\/a> in bytes.\n+ * <\/li>\n+ * <li><p><b>{@systemProperty jdk.httpclient.redirects.retrylimit}<\/b> (default: 5)<br>\n+ * The maximum number of attempts to send a HTTP request when redirected or any failure occurs\n+ * for any reason.\n+ * <\/li>\n+ * <li><p><b>{@systemProperty jdk.httpclient.websocket.writeBufferSize}<\/b> (default: 16384\n+ * or 16kB)<br>The buffer size used by the web socket implementation for socket writes.\n+ * <\/li>\n+ * <li><p><b>{@systemProperty jdk.httpclient.windowsize}<\/b> (default: 16777216 or 16 MB)<br>\n+ * The HTTP\/2 client stream window size in bytes.\n+ * <\/li>\n+ * <li><p><b>{@systemProperty jdk.httpclient.auth.retrylimit}<\/b> (default: 3)<br>\n+ * The number of attempts the Basic authentication filter will attempt to retry a failed\n+ * authentication.\n+ * <\/li>\n+ * <li><p><b>{@systemProperty jdk.httpclient.sendBufferSize}<\/b> (default: operating system\n+ * default)<br>The HTTP client socket\n+ * <a href=\"..\/java.base\/java\/net\/StandardSocketOptions.html#SO_SNDBUF\">send buffer size<\/a>.\n+ * Values less than or equal to zero are ignored.\n+ * <\/li>\n+ * <li><p><b>{@systemProperty jdk.internal.httpclient.disableHostnameVerification}<\/b> (default:\n+ * false)<br>If true (or set to an empty string), hostname verification in SSL certificates\n+ * is disabled. This is a system property only and not available in {@code conf\/net.properties}.\n+ * It is provided for testing purposes only.\n+ * <\/li>\n+ * <li><p><b>{@systemProperty jdk.http.auth.proxying.disabledSchemes}<\/b> (default: see\n+ * conf\/net.properties)<br>A comma separated list of HTTP authentication scheme names,\n+ * that are disallowed for use by the HTTP client implementation, for HTTP proxying.\n+ * <\/li>\n+ * <li><p><b>{@systemProperty jdk.http.auth.tunneling.disabledSchemes}<\/b> (default: see\n+ * conf\/net.properties)<br>A comma separated list of HTTP authentication scheme names, that\n+ * are disallowed for use by the HTTP client implementation, for HTTP CONNECT tunneling.\n+ * <\/li>\n+ * <\/ul>\n","filename":"src\/java.net.http\/share\/classes\/module-info.java","additions":132,"deletions":2,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -177,0 +177,3 @@\n+        \/\/ Since JDK-8297065, this method no longer throws a GSSException.\n+        \/\/ The throws clause in the method definition might be removed in\n+        \/\/ a future Java GSS-API update.\n@@ -179,5 +182,1 @@\n-            try {\n-                dout.putOID(oid);\n-            } catch (IOException e) {\n-                throw new GSSException(GSSException.FAILURE, e.getMessage());\n-            }\n+            dout.putOID(oid);\n","filename":"src\/java.security.jgss\/share\/classes\/org\/ietf\/jgss\/Oid.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -158,6 +158,3 @@\n-        try {\n-            DerOutputStream temp = new DerOutputStream();\n-            temp.putOID(mechOid);\n-            mechOidBytesSize = temp.toByteArray().length;\n-        } catch (IOException ignored) {\n-        }\n+        DerOutputStream temp = new DerOutputStream();\n+        temp.putOID(mechOid);\n+        mechOidBytesSize = temp.toByteArray().length;\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/GSSHeader.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -411,7 +411,1 @@\n-        try {\n-            dout.putOID(oid);\n-        } catch (IOException e) {\n-            throw new GSSExceptionImpl(GSSException.FAILURE,\n-                                   \"Could not ASN.1 Encode \"\n-                                   + oid.toString());\n-        }\n+        dout.putOID(oid);\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/GSSNameImpl.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -91,10 +91,9 @@\n-    final byte[] encode() throws GSSException {\n-        try {\n-            \/\/ create negInitToken\n-            DerOutputStream initToken = new DerOutputStream();\n-\n-            \/\/ DER-encoded mechTypes with CONTEXT 00\n-            if (mechTypes != null) {\n-                initToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,\n-                                                true, (byte) 0x00), mechTypes);\n-            }\n+    final byte[] encode() {\n+        \/\/ create negInitToken\n+        DerOutputStream initToken = new DerOutputStream();\n+\n+        \/\/ DER-encoded mechTypes with CONTEXT 00\n+        if (mechTypes != null) {\n+            initToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,\n+                    true, (byte) 0x00), mechTypes);\n+        }\n@@ -102,7 +101,7 @@\n-            \/\/ write context flags with CONTEXT 01\n-            if (reqFlags != null) {\n-                DerOutputStream flags = new DerOutputStream();\n-                flags.putUnalignedBitString(reqFlags);\n-                initToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,\n-                                                true, (byte) 0x01), flags);\n-            }\n+        \/\/ write context flags with CONTEXT 01\n+        if (reqFlags != null) {\n+            DerOutputStream flags = new DerOutputStream();\n+            flags.putUnalignedBitString(reqFlags);\n+            initToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,\n+                    true, (byte) 0x01), flags);\n+        }\n@@ -110,7 +109,7 @@\n-            \/\/ mechToken with CONTEXT 02\n-            if (mechToken != null) {\n-                DerOutputStream dataValue = new DerOutputStream();\n-                dataValue.putOctetString(mechToken);\n-                initToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,\n-                                                true, (byte) 0x02), dataValue);\n-            }\n+        \/\/ mechToken with CONTEXT 02\n+        if (mechToken != null) {\n+            DerOutputStream dataValue = new DerOutputStream();\n+            dataValue.putOctetString(mechToken);\n+            initToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,\n+                    true, (byte) 0x02), dataValue);\n+        }\n@@ -118,10 +117,5 @@\n-            \/\/ mechListMIC with CONTEXT 03\n-            if (mechListMIC != null) {\n-                if (DEBUG) {\n-                    System.out.println(\"SpNegoToken NegTokenInit: \" +\n-                                        \"sending MechListMIC\");\n-                }\n-                DerOutputStream mic = new DerOutputStream();\n-                mic.putOctetString(mechListMIC);\n-                initToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,\n-                                                true, (byte) 0x03), mic);\n+        \/\/ mechListMIC with CONTEXT 03\n+        if (mechListMIC != null) {\n+            if (DEBUG) {\n+                System.out.println(\"SpNegoToken NegTokenInit: \" +\n+                        \"sending MechListMIC\");\n@@ -129,0 +123,5 @@\n+            DerOutputStream mic = new DerOutputStream();\n+            mic.putOctetString(mechListMIC);\n+            initToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,\n+                    true, (byte) 0x03), mic);\n+        }\n@@ -130,5 +129,3 @@\n-            \/\/ insert in a SEQUENCE\n-            DerOutputStream out = new DerOutputStream();\n-            out.write(DerValue.tag_Sequence, initToken);\n-\n-            return out.toByteArray();\n+        \/\/ insert in a SEQUENCE\n+        DerOutputStream out = new DerOutputStream();\n+        out.write(DerValue.tag_Sequence, initToken);\n@@ -136,4 +133,1 @@\n-        } catch (IOException e) {\n-            throw new GSSException(GSSException.DEFECTIVE_TOKEN, -1,\n-                \"Invalid SPNEGO NegTokenInit token : \" + e.getMessage());\n-        }\n+        return out.toByteArray();\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/spnego\/NegTokenInit.java","additions":37,"deletions":43,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,7 +78,14 @@\n-        try {\n-            \/\/ create negTargToken\n-            DerOutputStream targToken = new DerOutputStream();\n-\n-            \/\/ write the negotiated result with CONTEXT 00\n-            DerOutputStream result = new DerOutputStream();\n-            result.putEnumerated(negResult);\n+        \/\/ create negTargToken\n+        DerOutputStream targToken = new DerOutputStream();\n+\n+        \/\/ write the negotiated result with CONTEXT 00\n+        DerOutputStream result = new DerOutputStream();\n+        result.putEnumerated(negResult);\n+        targToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,\n+                true, (byte) 0x00), result);\n+\n+        \/\/ supportedMech with CONTEXT 01\n+        if (supportedMech != null) {\n+            DerOutputStream mech = new DerOutputStream();\n+            byte[] mechType = supportedMech.getDER();\n+            mech.writeBytes(mechType);\n@@ -86,10 +93,2 @@\n-                                true, (byte) 0x00), result);\n-\n-            \/\/ supportedMech with CONTEXT 01\n-            if (supportedMech != null) {\n-                DerOutputStream mech = new DerOutputStream();\n-                byte[] mechType = supportedMech.getDER();\n-                mech.write(mechType);\n-                targToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,\n-                                                true, (byte) 0x01), mech);\n-            }\n+                    true, (byte) 0x01), mech);\n+        }\n@@ -97,7 +96,7 @@\n-            \/\/ response Token with CONTEXT 02\n-            if (responseToken != null) {\n-                DerOutputStream rspToken = new DerOutputStream();\n-                rspToken.putOctetString(responseToken);\n-                targToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,\n-                                        true, (byte) 0x02), rspToken);\n-            }\n+        \/\/ response Token with CONTEXT 02\n+        if (responseToken != null) {\n+            DerOutputStream rspToken = new DerOutputStream();\n+            rspToken.putOctetString(responseToken);\n+            targToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,\n+                    true, (byte) 0x02), rspToken);\n+        }\n@@ -105,10 +104,5 @@\n-            \/\/ mechListMIC with CONTEXT 03\n-            if (mechListMIC != null) {\n-                if (DEBUG) {\n-                    System.out.println(\"SpNegoToken NegTokenTarg: \" +\n-                                                \"sending MechListMIC\");\n-                }\n-                DerOutputStream mic = new DerOutputStream();\n-                mic.putOctetString(mechListMIC);\n-                targToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,\n-                                        true, (byte) 0x03), mic);\n+        \/\/ mechListMIC with CONTEXT 03\n+        if (mechListMIC != null) {\n+            if (DEBUG) {\n+                System.out.println(\"SpNegoToken NegTokenTarg: \" +\n+                        \"sending MechListMIC\");\n@@ -116,0 +110,5 @@\n+            DerOutputStream mic = new DerOutputStream();\n+            mic.putOctetString(mechListMIC);\n+            targToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,\n+                    true, (byte) 0x03), mic);\n+        }\n@@ -117,5 +116,3 @@\n-            \/\/ insert in a SEQUENCE\n-            DerOutputStream out = new DerOutputStream();\n-            out.write(DerValue.tag_Sequence, targToken);\n-\n-            return out.toByteArray();\n+        \/\/ insert in a SEQUENCE\n+        DerOutputStream out = new DerOutputStream();\n+        out.write(DerValue.tag_Sequence, targToken);\n@@ -123,4 +120,1 @@\n-        } catch (IOException e) {\n-            throw new GSSException(GSSException.DEFECTIVE_TOKEN, -1,\n-                \"Invalid SPNEGO NegTokenTarg token : \" + e.getMessage());\n-        }\n+        return out.toByteArray();\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/spnego\/NegTokenTarg.java","additions":38,"deletions":44,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -51,6 +51,0 @@\n-    \/**\n-     * Returns the binding variable.\n-     * @return the binding variable\n-     *\/\n-    VariableTree getVariable();\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/DeconstructionPatternTree.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -44,0 +46,17 @@\n+    \/**\n+     * \"Enhanced\" {@code for} declarations come in two forms:\n+     * <ul>\n+     * <li> local variable declarations and\n+     * <li> record patterns\n+     * <\/ul>\n+     *\n+     * @since 20\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n+    public enum DeclarationKind {\n+        \/** enum constant for local variable declarations *\/\n+        VARIABLE,\n+        \/** enum constant for record pattern declarations *\/\n+        PATTERN\n+    }\n+\n@@ -46,1 +65,1 @@\n-     * @return the control variable\n+     * @return the control variable, or {@code null} if this \"enhanced\" {@code for} uses a pattern\n@@ -50,0 +69,8 @@\n+    \/**\n+     * Returns the control variable or pattern for the loop.\n+     * @return the control variable or pattern\n+     * @since 20\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n+    Tree getVariableOrRecordPattern();\n+\n@@ -61,0 +88,8 @@\n+\n+    \/**\n+     * Returns the kind of the declaration of the \"enhanced\" {@code for}.\n+     * @return the kind of the declaration\n+     * @since 20\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n+    DeclarationKind getDeclarationKind();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/EnhancedForLoopTree.java","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -43,0 +45,17 @@\n+\n+    \/**\n+     * Two possible variants of instanceof expressions:\n+     * <ul>\n+     * <li> testing types, and\n+     * <li> performing pattern matching\n+     * <\/ul>\n+     * @since 20\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n+    public enum TestKind {\n+        \/** instanceof only testing a type *\/\n+        TYPE,\n+        \/** instanceof doing a pattern matching *\/\n+        PATTERN\n+    }\n+\n@@ -76,0 +95,9 @@\n+\n+    \/**\n+     * Returns the kind of this instanceof expression.\n+     *\n+     * @return the kind of this instanceof expression\n+     * @since 20\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.RECORD_PATTERNS, reflective=true)\n+    TestKind getTestKind();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/InstanceOfTree.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -336,1 +336,1 @@\n-        R r = scan(node.getVariable(), p);\n+        R r = scan(node.getVariableOrRecordPattern(), p);\n@@ -842,1 +842,0 @@\n-        r = scanAndReduce(node.getVariable(), p, r);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -193,0 +193,1 @@\n+    public final Type nullPointerExceptionType;\n@@ -558,0 +559,1 @@\n+        nullPointerExceptionType = enterClass(\"java.lang.NullPointerException\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2045,0 +2045,5 @@\n+        public void setNormal() {\n+            Assert.check(this.kind == Kind.CAPTURED);\n+            this.kind = Kind.NORMAL;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import com.sun.source.tree.EnhancedForLoopTree;\n@@ -427,1 +428,2 @@\n-            return !isImplicitlyTyped(tree.var);\n+            return tree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE &&\n+                    !isImplicitlyTyped((JCVariableDecl) tree.varOrRecordPattern);\n@@ -431,0 +433,2 @@\n+            Assert.check(oldTree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE);\n+\n@@ -432,1 +436,1 @@\n-            newTree.var = rewriteVarType(oldTree.var);\n+            newTree.varOrRecordPattern = rewriteVarType((JCVariableDecl) oldTree.varOrRecordPattern);\n@@ -438,1 +442,4 @@\n-            processVar(oldTree.var, newTree.var, hasErrors);\n+            Assert.check(oldTree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE);\n+\n+            processVar((JCVariableDecl) oldTree.varOrRecordPattern,\n+                           (JCVariableDecl) newTree.varOrRecordPattern, hasErrors);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Analyzer.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import com.sun.source.tree.EnhancedForLoopTree;\n@@ -1516,0 +1517,1 @@\n+\n@@ -1522,2 +1524,2 @@\n-            Type elemtype = types.elemtype(exprType); \/\/ perhaps expr is an array?\n-            if (elemtype == null) {\n+            tree.elementType = types.elemtype(exprType); \/\/ perhaps expr is an array?\n+            if (tree.elementType == null) {\n@@ -1530,1 +1532,1 @@\n-                    elemtype = types.createErrorType(exprType);\n+                    tree.elementType = types.createErrorType(exprType);\n@@ -1533,1 +1535,1 @@\n-                    elemtype = iterableParams.isEmpty()\n+                    tree.elementType = iterableParams.isEmpty()\n@@ -1547,3 +1549,33 @@\n-            if (tree.var.isImplicitlyTyped()) {\n-                Type inferredType = chk.checkLocalVarType(tree.var, elemtype, tree.var.name);\n-                setSyntheticVariableType(tree.var, inferredType);\n+            if (tree.varOrRecordPattern instanceof JCVariableDecl jcVariableDecl) {\n+                if (jcVariableDecl.isImplicitlyTyped()) {\n+                    Type inferredType = chk.checkLocalVarType(jcVariableDecl, tree.elementType, jcVariableDecl.name);\n+                    setSyntheticVariableType(jcVariableDecl, inferredType);\n+                }\n+                attribStat(jcVariableDecl, loopEnv);\n+                chk.checkType(tree.expr.pos(), tree.elementType, jcVariableDecl.sym.type);\n+\n+                loopEnv.tree = tree; \/\/ before, we were not in loop!\n+                attribStat(tree.body, loopEnv);\n+            } else {\n+                Assert.check(tree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.PATTERN);\n+                JCRecordPattern jcRecordPattern = (JCRecordPattern) tree.varOrRecordPattern;\n+\n+                attribExpr(jcRecordPattern, loopEnv, tree.elementType);\n+\n+                \/\/ for(<pattern> x : xs) { y }\n+                \/\/ we include x's bindings when true in y\n+                \/\/ we don't do anything with x's bindings when false\n+\n+                MatchBindings forWithRecordPatternBindings = matchBindings;\n+                Env<AttrContext> recordPatternEnv = bindingEnv(loopEnv, forWithRecordPatternBindings.bindingsWhenTrue);\n+\n+                Type clazztype = jcRecordPattern.type;\n+\n+                checkCastablePattern(tree.expr.pos(), tree.elementType, clazztype);\n+\n+                recordPatternEnv.tree = tree; \/\/ before, we were not in loop!\n+                try {\n+                    attribStat(tree.body, recordPatternEnv);\n+                } finally {\n+                    recordPatternEnv.info.scope.leave();\n+                }\n@@ -1551,4 +1583,0 @@\n-            attribStat(tree.var, loopEnv);\n-            chk.checkType(tree.expr.pos(), elemtype, tree.var.sym.type);\n-            loopEnv.tree = tree; \/\/ before, we were not in loop!\n-            attribStat(tree.body, loopEnv);\n@@ -1668,1 +1696,2 @@\n-                                     .anyMatch(l -> l.hasTag(PATTERNCASELABEL));\n+                                     .anyMatch(l -> l.hasTag(PATTERNCASELABEL) ||\n+                                                    TreeInfo.isNullCaseLabel(l));\n@@ -1680,1 +1709,0 @@\n-            MatchBindings prevBindings = null;\n@@ -1690,1 +1718,1 @@\n-                MatchBindings currentBindings = prevBindings;\n+                MatchBindings currentBindings = null;\n@@ -1754,1 +1782,1 @@\n-                        attribExpr(pat, switchEnv);\n+                        attribExpr(pat, switchEnv, seltype);\n@@ -1808,3 +1836,0 @@\n-\n-                prevBindings = c.caseKind == CaseTree.CaseKind.STATEMENT && c.completesNormally ? currentBindings\n-                                                                                                : null;\n@@ -4081,1 +4106,1 @@\n-            attribTree(tree.pattern, env, unknownExprInfo);\n+            attribExpr(tree.pattern, env, exprtype);\n@@ -4122,0 +4147,4 @@\n+        \/\/ if any type is erroneous, the problem is reported elsewhere\n+        if (exprType.isErroneous() || pattType.isErroneous()) {\n+            return false;\n+        }\n@@ -4145,2 +4174,1 @@\n-            ResultInfo varInfo = new ResultInfo(KindSelector.TYP, resultInfo.pt, resultInfo.checkContext);\n-            type = attribTree(tree.var.vartype, env, varInfo);\n+            type = attribType(tree.var.vartype, env);\n@@ -4169,1 +4197,10 @@\n-        tree.type = attribType(tree.deconstructor, env);\n+        Type type = attribType(tree.deconstructor, env);\n+        if (type.isRaw() && type.tsym.getTypeParameters().nonEmpty()) {\n+            Type inferred = infer.instantiatePatternType(resultInfo.pt, type.tsym);\n+            if (inferred == null) {\n+                log.error(tree.pos(), Errors.PatternTypeCannotInfer);\n+            } else {\n+                type = inferred;\n+            }\n+        }\n+        tree.type = tree.deconstructor.type = type;\n@@ -4174,3 +4211,0 @@\n-            if (record.type.getTypeArguments().nonEmpty() && tree.type.isRaw()) {\n-                log.error(tree.pos(),Errors.RawDeconstructionPattern);\n-            }\n@@ -4183,1 +4217,1 @@\n-            expectedRecordTypes = Stream.generate(() -> Type.noType)\n+            expectedRecordTypes = Stream.generate(() -> types.createErrorType(tree.type))\n@@ -4186,0 +4220,1 @@\n+            tree.record = syms.errSymbol;\n@@ -4193,4 +4228,1 @@\n-                boolean nestedIsVarPattern = false;\n-                nestedIsVarPattern |= nestedPatterns.head.hasTag(BINDINGPATTERN) &&\n-                                      ((JCBindingPattern) nestedPatterns.head).var.vartype == null;\n-                attribExpr(nestedPatterns.head, localEnv, nestedIsVarPattern ? recordTypes.head : Type.noType);\n+                attribExpr(nestedPatterns.head, localEnv, recordTypes.head);\n@@ -4214,15 +4246,0 @@\n-            if (tree.var != null) {\n-                BindingSymbol v = new BindingSymbol(tree.var.mods.flags, tree.var.name, tree.type,\n-                                                    localEnv.info.scope.owner);\n-                v.pos = tree.pos;\n-                tree.var.sym = v;\n-                if (chk.checkUnique(tree.var.pos(), v, localEnv.info.scope)) {\n-                    chk.checkTransparentVar(tree.var.pos(), v, localEnv.info.scope);\n-                }\n-                if (tree.var.vartype != null) {\n-                    annotate.annotateLater(tree.var.mods.annotations, localEnv, v, tree.pos());\n-                    annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, localEnv, v, tree.var.pos());\n-                    annotate.flush();\n-                }\n-                outBindings.add(v);\n-            }\n@@ -4651,1 +4668,1 @@\n-                    return v.type = types.createErrorType(v.type);\n+                    return tree.type = v.type = types.createErrorType(v.type);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":63,"deletions":46,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -4349,9 +4349,0 @@\n-        boolean wasConstant = false;          \/\/ Seen a constant in the same case label\n-        boolean wasDefault = false;           \/\/ Seen a default in the same case label\n-        boolean wasNullPattern = false;       \/\/ Seen a null pattern in the same case label,\n-                                              \/\/or fall through from a null pattern\n-        boolean wasPattern = false;           \/\/ Seen a pattern in the same case label\n-                                              \/\/or fall through from a pattern\n-        boolean wasTypePattern = false;       \/\/ Seen a pattern in the same case label\n-                                              \/\/or fall through from a type pattern\n-        boolean wasNonEmptyFallThrough = false;\n@@ -4360,11 +4351,9 @@\n-            for (JCCaseLabel label : c.labels) {\n-                if (label.hasTag(CONSTANTCASELABEL)) {\n-                    JCExpression expr = ((JCConstantCaseLabel) label).expr;\n-                    if (TreeInfo.isNull(expr)) {\n-                        if (wasPattern && !wasTypePattern && !wasNonEmptyFallThrough) {\n-                            log.error(label.pos(), Errors.FlowsThroughFromPattern);\n-                        }\n-                        wasNullPattern = true;\n-                    } else {\n-                        if (wasPattern && !wasNonEmptyFallThrough) {\n-                            log.error(label.pos(), Errors.FlowsThroughFromPattern);\n+            if (c.labels.head instanceof JCConstantCaseLabel constLabel) {\n+                if (TreeInfo.isNull(constLabel.expr)) {\n+                    if (c.labels.tail.nonEmpty()) {\n+                        if (c.labels.tail.head instanceof JCDefaultCaseLabel defLabel) {\n+                            if (c.labels.tail.tail.nonEmpty()) {\n+                                log.error(c.labels.tail.tail.head.pos(), Errors.InvalidCaseLabelCombination);\n+                            }\n+                        } else {\n+                            log.error(c.labels.tail.head.pos(), Errors.InvalidCaseLabelCombination);\n@@ -4372,5 +4361,0 @@\n-                        wasConstant = true;\n-                    }\n-                } else if (label.hasTag(DEFAULTCASELABEL)) {\n-                    if (wasPattern && !wasNonEmptyFallThrough) {\n-                        log.error(label.pos(), Errors.FlowsThroughFromPattern);\n@@ -4378,1 +4362,0 @@\n-                    wasDefault = true;\n@@ -4380,8 +4363,5 @@\n-                    JCPattern pat = ((JCPatternCaseLabel) label).pat;\n-                    while (pat instanceof JCParenthesizedPattern parenthesized) {\n-                        pat = parenthesized.pattern;\n-                    }\n-                    boolean isTypePattern = pat.hasTag(BINDINGPATTERN);\n-                    if (wasPattern || wasConstant || wasDefault ||\n-                        (wasNullPattern && (!isTypePattern || wasNonEmptyFallThrough))) {\n-                        log.error(label.pos(), Errors.FlowsThroughToPattern);\n+                    for (JCCaseLabel label : c.labels.tail) {\n+                        if (!(label instanceof JCConstantCaseLabel) || TreeInfo.isNullCaseLabel(label)) {\n+                            log.error(label.pos(), Errors.InvalidCaseLabelCombination);\n+                            break;\n+                        }\n@@ -4389,2 +4369,0 @@\n-                    wasPattern = true;\n-                    wasTypePattern = isTypePattern;\n@@ -4392,0 +4370,26 @@\n+            } else {\n+                if (c.labels.tail.nonEmpty()) {\n+                    log.error(c.labels.tail.head.pos(), Errors.FlowsThroughFromPattern);\n+                }\n+            }\n+        }\n+\n+        boolean isCaseStatementGroup = cases.nonEmpty() &&\n+                                       cases.head.caseKind == CaseTree.CaseKind.STATEMENT;\n+\n+        if (isCaseStatementGroup) {\n+            boolean previousCompletessNormally = false;\n+            for (List<JCCase> l = cases; l.nonEmpty(); l = l.tail) {\n+                JCCase c = l.head;\n+                if (previousCompletessNormally &&\n+                    c.stats.nonEmpty() &&\n+                    c.labels.head instanceof JCPatternCaseLabel patternLabel &&\n+                    hasBindings(patternLabel.pat)) {\n+                    log.error(c.labels.head.pos(), Errors.FlowsThroughToPattern);\n+                } else if (c.stats.isEmpty() &&\n+                           c.labels.head instanceof JCPatternCaseLabel patternLabel &&\n+                           hasBindings(patternLabel.pat) &&\n+                           hasStatements(l.tail)) {\n+                    log.error(c.labels.head.pos(), Errors.FlowsThroughFromPattern);\n+                }\n+                previousCompletessNormally = c.completesNormally;\n@@ -4393,0 +4397,2 @@\n+        }\n+    }\n@@ -4394,2 +4400,2 @@\n-            boolean completesNormally = c.caseKind == CaseTree.CaseKind.STATEMENT ? c.completesNormally\n-                                                                                  : false;\n+    boolean hasBindings(JCPattern p) {\n+        boolean[] bindings = new boolean[1];\n@@ -4397,6 +4403,5 @@\n-            if (c.stats.nonEmpty()) {\n-                wasConstant = false;\n-                wasDefault = false;\n-                wasNullPattern &= completesNormally;\n-                wasPattern &= completesNormally;\n-                wasTypePattern &= completesNormally;\n+        new TreeScanner() {\n+            @Override\n+            public void visitBindingPattern(JCBindingPattern tree) {\n+                bindings[0] = true;\n+                super.visitBindingPattern(tree);\n@@ -4404,0 +4409,1 @@\n+        }.scan(p);\n@@ -4405,2 +4411,1 @@\n-            wasNonEmptyFallThrough = c.stats.nonEmpty() && completesNormally;\n-        }\n+        return bindings[0];\n@@ -4409,0 +4414,9 @@\n+    boolean hasStatements(List<JCCase> cases) {\n+        for (List<JCCase> l = cases; l.nonEmpty(); l = l.tail) {\n+            if (l.head.stats.nonEmpty()) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n@@ -4411,0 +4425,3 @@\n+        boolean seenDefault = false;\n+        boolean seenDefaultLabel = false;\n+        boolean warnDominatedByDefault = false;\n@@ -4414,1 +4431,4 @@\n-                if (label.hasTag(DEFAULTCASELABEL) || TreeInfo.isNullCaseLabel(label)) {\n+                if (label.hasTag(DEFAULTCASELABEL)) {\n+                    seenDefault = true;\n+                    seenDefaultLabel |=\n+                            TreeInfo.isNullCaseLabel(c.labels.head);\n@@ -4417,0 +4437,13 @@\n+                if (TreeInfo.isNullCaseLabel(label)) {\n+                    if (seenDefault) {\n+                        log.error(label.pos(), Errors.PatternDominated);\n+                    }\n+                    continue;\n+                }\n+                if (seenDefault && !warnDominatedByDefault) {\n+                    if (label.hasTag(PATTERNCASELABEL) ||\n+                        (label instanceof JCConstantCaseLabel && seenDefaultLabel)) {\n+                        log.error(label.pos(), Errors.PatternDominated);\n+                        warnDominatedByDefault = true;\n+                    }\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":80,"deletions":47,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+import com.sun.tools.javac.code.Types.UniqueType;\n@@ -647,1 +648,15 @@\n-            visitVarDef(tree.var);\n+            if(tree.varOrRecordPattern instanceof JCVariableDecl jcVariableDecl) {\n+                visitVarDef(jcVariableDecl);\n+            } else if (tree.varOrRecordPattern instanceof JCRecordPattern jcRecordPattern) {\n+                visitRecordPattern(jcRecordPattern);\n+\n+                Set<Symbol> coveredSymbols =\n+                        coveredSymbols(jcRecordPattern.pos(), List.of(jcRecordPattern));\n+\n+                boolean isExhaustive =\n+                        isExhaustive(jcRecordPattern.pos(), tree.elementType, coveredSymbols);\n+\n+                if (!isExhaustive) {\n+                    log.error(tree, Errors.ForeachNotExhaustiveOnType(jcRecordPattern.type, tree.elementType));\n+                }\n+            }\n@@ -691,1 +706,1 @@\n-                Set<Symbol> coveredSymbols = coveredSymbolsForCases(tree.pos(), tree.selector, tree.cases);\n+                Set<Symbol> coveredSymbols = coveredSymbolsForCases(tree.pos(), tree.cases);\n@@ -726,1 +741,1 @@\n-            Set<Symbol> coveredSymbols = coveredSymbolsForCases(tree.pos(), tree.selector, tree.cases);\n+            Set<Symbol> coveredSymbols = coveredSymbolsForCases(tree.pos(), tree.cases);\n@@ -738,1 +753,1 @@\n-                                                   JCExpression selector, List<JCCase> cases) {\n+                                                   List<JCCase> cases) {\n@@ -746,1 +761,1 @@\n-            return coveredSymbols(pos, selector.type, labelValues);\n+            return coveredSymbols(pos, labelValues);\n@@ -749,1 +764,1 @@\n-        private Set<Symbol> coveredSymbols(DiagnosticPosition pos, Type targetType,\n+        private Set<Symbol> coveredSymbols(DiagnosticPosition pos,\n@@ -752,1 +767,1 @@\n-            Map<Symbol, List<JCRecordPattern>> deconstructionPatternsBySymbol = new HashMap<>();\n+            Map<UniqueType, List<JCRecordPattern>> deconstructionPatternsByType = new HashMap<>();\n@@ -764,1 +779,1 @@\n-                        Symbol type = dpat.record;\n+                        UniqueType type = new UniqueType(dpat.type, types);\n@@ -766,1 +781,1 @@\n-                                deconstructionPatternsBySymbol.getOrDefault(type, List.nil())\n+                                deconstructionPatternsByType.getOrDefault(type, List.nil())\n@@ -769,1 +784,1 @@\n-                        deconstructionPatternsBySymbol.put(type, augmentedPatterns);\n+                        deconstructionPatternsByType.put(type, augmentedPatterns);\n@@ -780,3 +795,5 @@\n-            for (Entry<Symbol, List<JCRecordPattern>> e : deconstructionPatternsBySymbol.entrySet()) {\n-                if (coversDeconstructionFromComponent(pos, targetType, e.getValue(), 0)) {\n-                    coveredSymbols.add(e.getKey());\n+            for (Entry<UniqueType, List<JCRecordPattern>> e : deconstructionPatternsByType.entrySet()) {\n+                if (e.getValue().stream().anyMatch(r -> r.nested.size() != r.record.getRecordComponents().size())) {\n+                    coveredSymbols.add(syms.errSymbol);\n+                } else if (coversDeconstructionFromComponent(pos, e.getKey().type, e.getValue(), 0)) {\n+                    coveredSymbols.add(e.getKey().type.tsym);\n@@ -789,1 +806,1 @@\n-                                                          Type targetType,\n+                                                          Type recordType,\n@@ -812,1 +829,1 @@\n-            Type instantiatedComponentType = types.memberType(targetType, components.get(component));\n+            Type instantiatedComponentType = types.memberType(recordType, components.get(component));\n@@ -814,1 +831,1 @@\n-            Set<Symbol> coveredSymbolsForComponent = coveredSymbols(pos, instantiatedComponentType,\n+            Set<Symbol> coveredSymbolsForComponent = coveredSymbols(pos,\n@@ -854,1 +871,1 @@\n-                if (coversDeconstructionFromComponent(pos, targetType, e.getValue(), component + 1)) {\n+                if (coversDeconstructionFromComponent(pos, recordType, e.getValue(), component + 1)) {\n@@ -935,1 +952,1 @@\n-                    yield covered.contains(seltype.tsym);\n+                    yield covered.contains(types.erasure(seltype).tsym);\n@@ -1358,1 +1375,5 @@\n-            visitVarDef(tree.var);\n+            if(tree.varOrRecordPattern instanceof JCVariableDecl jcVariableDecl) {\n+                visitVarDef(jcVariableDecl);\n+            } else if (tree.varOrRecordPattern instanceof JCRecordPattern jcRecordPattern) {\n+                visitRecordPattern(jcRecordPattern);\n+            }\n@@ -2506,2 +2527,0 @@\n-            visitVarDef(tree.var);\n-\n@@ -2516,1 +2535,7 @@\n-            letInit(tree.pos(), tree.var.sym);\n+            if(tree.varOrRecordPattern instanceof JCVariableDecl jcVariableDecl) {\n+                visitVarDef(jcVariableDecl);\n+                letInit(tree.pos(), jcVariableDecl.sym);\n+            } else if (tree.varOrRecordPattern instanceof JCRecordPattern jcRecordPattern) {\n+                visitRecordPattern(jcRecordPattern);\n+            }\n+\n@@ -2970,8 +2995,0 @@\n-        @Override\n-        public void visitRecordPattern(JCRecordPattern tree) {\n-            super.visitRecordPattern(tree);\n-            if (tree.var != null) {\n-                initParam(tree.var);\n-            }\n-        }\n-\n@@ -3152,1 +3169,0 @@\n-            scan(tree.var);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":47,"deletions":31,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -60,2 +60,1 @@\n-import java.util.HashMap;\n-import java.util.HashSet;\n+import java.util.LinkedHashMap;\n@@ -72,0 +71,1 @@\n+import java.util.Comparator;\n@@ -510,2 +510,5 @@\n-        List<Type> formals = vars;\n-        for (Type t : todo) {\n+        replaceTypeVarsInBounds(todo.toList(), inferenceContext);\n+    }\n+\n+    private void replaceTypeVarsInBounds(List<Type> vars, InferenceContext inferenceContext) {\n+        for (Type t : vars) {\n@@ -519,1 +522,0 @@\n-            formals = formals.tail;\n@@ -654,0 +656,116 @@\n+\n+    \/**\n+     * Infer record type for pattern matching. Given an expression type\n+     * (@code expressionType}), and a given record ({@code patternTypeSymbol}),\n+     * a parameterized type of {@code patternTypeSymbol} is inferred\n+     * according to JLS 18.5.5.\n+     *\n+     * @param expressionType\n+     * @param patternTypeSymbol\n+     * @return\n+     *\/\n+    public Type instantiatePatternType(Type expressionType, TypeSymbol patternTypeSymbol) {\n+        if (expressionType.tsym == patternTypeSymbol)\n+            return expressionType;\n+\n+        \/\/step 1:\n+        List<Type> expressionTypes = List.nil();\n+        List<Type> params = patternTypeSymbol.type.allparams();\n+        List<Type> capturedWildcards = List.nil();\n+        List<Type> todo = List.of(expressionType);\n+        while (todo.nonEmpty()) {\n+            Type current = todo.head;\n+            todo = todo.tail;\n+            switch (current.getTag()) {\n+                case CLASS -> {\n+                    if (current.isCompound()) {\n+                        todo = todo.prependList(types.directSupertypes(current));\n+                    } else {\n+                        Type captured = types.capture(current);\n+\n+                        for (Type ta : captured.getTypeArguments()) {\n+                            if (ta.hasTag(TYPEVAR) && ((TypeVar) ta).isCaptured()) {\n+                                params = params.prepend((TypeVar) ta);\n+                                capturedWildcards = capturedWildcards.prepend(ta);\n+                            }\n+                        }\n+                        expressionTypes = expressionTypes.prepend(captured);\n+                    }\n+                }\n+                case TYPEVAR -> {\n+                    todo = todo.prepend(types.skipTypeVars(current, false));\n+                }\n+                default -> expressionTypes = expressionTypes.prepend(current);\n+            }\n+        }\n+        \/\/add synthetic captured ivars\n+        InferenceContext c = new InferenceContext(this, params);\n+        Type patternType = c.asUndetVar(patternTypeSymbol.type);\n+        List<Type> exprTypes = expressionTypes.map(t -> c.asUndetVar(t));\n+\n+        capturedWildcards.forEach(s -> ((UndetVar) c.asUndetVar(s)).setNormal());\n+\n+        try {\n+            \/\/step 2:\n+            for (Type exprType : exprTypes) {\n+                if (exprType.isParameterized()) {\n+                    Type patternAsExpression =\n+                            types.asSuper(patternType, exprType.tsym);\n+                    if (patternAsExpression == null ||\n+                        !types.isSameType(patternAsExpression, exprType)) {\n+                        return null;\n+                    }\n+                }\n+            }\n+\n+            doIncorporation(c, types.noWarnings);\n+\n+            \/\/step 3:\n+            List<Type> freshVars = instantiatePatternVars(params, c);\n+\n+            Type substituted = c.asInstType(patternTypeSymbol.type);\n+\n+            \/\/step 4:\n+            return types.upward(substituted, freshVars);\n+        } catch (Infer.InferenceException ex) {\n+            return null;\n+        }\n+    }\n+\n+    private List<Type> instantiatePatternVars(List<Type> vars, InferenceContext c) {\n+        ListBuffer<Type> freshVars = new ListBuffer<>();\n+        ListBuffer<Type> todo = new ListBuffer<>();\n+\n+        \/\/step 1 - create fresh tvars\n+        for (Type t : vars) {\n+            UndetVar undet = (UndetVar) c.asUndetVar(t);\n+            List<Type> bounds = InferenceStep.EQ.filterBounds(undet, c);\n+            if (bounds.nonEmpty()) {\n+                undet.setInst(bounds.head);\n+            } else {\n+                List<Type> upperBounds = undet.getBounds(InferenceBound.UPPER);\n+                Type upper;\n+                boolean recursive = Type.containsAny(upperBounds, vars);\n+                if (recursive) {\n+                    upper = types.makeIntersectionType(upperBounds);\n+                    todo.append(undet);\n+                } else if (upperBounds.nonEmpty()) {\n+                    upper = types.glb(upperBounds);\n+                } else {\n+                    upper = syms.objectType;\n+                }\n+                List<Type> lowerBounds = undet.getBounds(InferenceBound.LOWER);\n+                Type lower = lowerBounds.isEmpty() ? syms.botType\n+                                                   : lowerBounds.tail.isEmpty() ? lowerBounds.head\n+                                                                                : types.lub(lowerBounds);\n+                TypeVar vt = new TypeVar(syms.noSymbol, upper, lower);\n+                freshVars.add(vt);\n+                undet.setInst(vt);\n+            }\n+        }\n+\n+        \/\/step 2 - replace fresh tvars in their bounds\n+        replaceTypeVarsInBounds(todo.toList(), c);\n+\n+        return freshVars.toList();\n+    }\n@@ -1148,1 +1266,1 @@\n-    Map<IncorporationBinaryOp, Boolean> incorporationCache = new HashMap<>();\n+    Map<IncorporationBinaryOp, Boolean> incorporationCache = new LinkedHashMap<>();\n@@ -1310,1 +1428,1 @@\n-        final Map<Node, Pair<List<Node>, Integer>> treeCache = new HashMap<>();\n+        final Map<Node, Pair<List<Node>, Integer>> treeCache = new LinkedHashMap<>();\n@@ -1638,1 +1756,1 @@\n-                    Set<Node> closure = new HashSet<>();\n+                    Set<Node> closure = new LinkedHashSet<>();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":126,"deletions":8,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.HashMap;\n@@ -554,1 +553,1 @@\n-    Map<JCTree, Type> captureTypeCache = new HashMap<>();\n+    Map<JCTree, Type> captureTypeCache = new LinkedHashMap<>();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/InferenceContext.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import com.sun.source.tree.EnhancedForLoopTree;\n@@ -57,0 +58,1 @@\n+import com.sun.tools.javac.code.Source.Feature;\n@@ -103,0 +105,1 @@\n+    private final boolean useMatchException;\n@@ -129,0 +132,4 @@\n+        Source source = Source.instance(context);\n+        Preview preview = Preview.instance(context);\n+        useMatchException = Feature.PATTERN_SWITCH.allowedInSource(source) &&\n+                            (preview.isEnabled() || !preview.isPreview(Feature.PATTERN_SWITCH));\n@@ -3464,5 +3471,9 @@\n-            JCVariableDecl loopvardef = (JCVariableDecl)make.VarDef(tree.var.mods,\n-                                                  tree.var.name,\n-                                                  tree.var.vartype,\n-                                                  loopvarinit).setType(tree.var.type);\n-            loopvardef.sym = tree.var.sym;\n+\n+            Assert.check(tree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE);\n+            JCVariableDecl jcVariableDecl = (JCVariableDecl) tree.varOrRecordPattern;\n+\n+            JCVariableDecl loopvardef = (JCVariableDecl)make.VarDef(jcVariableDecl.mods,\n+                    jcVariableDecl.name,\n+                    jcVariableDecl.vartype,\n+                    loopvarinit).setType(jcVariableDecl.type);\n+            loopvardef.sym = jcVariableDecl.sym;\n@@ -3470,1 +3481,2 @@\n-                Block(0, List.of(loopvardef, tree.body));\n+                    Block(0, List.of(loopvardef, tree.body));\n+\n@@ -3549,1 +3561,5 @@\n-            if (tree.var.type.isPrimitive())\n+\n+            Assert.check(tree.getDeclarationKind() == EnhancedForLoopTree.DeclarationKind.VARIABLE);\n+\n+            JCVariableDecl var = (JCVariableDecl) tree.varOrRecordPattern;\n+            if (var.type.isPrimitive())\n@@ -3552,6 +3568,6 @@\n-                vardefinit = make.TypeCast(tree.var.type, vardefinit);\n-            JCVariableDecl indexDef = (JCVariableDecl)make.VarDef(tree.var.mods,\n-                                                  tree.var.name,\n-                                                  tree.var.vartype,\n-                                                  vardefinit).setType(tree.var.type);\n-            indexDef.sym = tree.var.sym;\n+                vardefinit = make.TypeCast(var.type, vardefinit);\n+            JCVariableDecl indexDef = (JCVariableDecl) make.VarDef(var.mods,\n+                    var.name,\n+                    var.vartype,\n+                    vardefinit).setType(var.type);\n+            indexDef.sym = var.sym;\n@@ -3561,4 +3577,4 @@\n-                ForLoop(List.of(init),\n-                        cond,\n-                        List.nil(),\n-                        body));\n+                    ForLoop(List.of(init),\n+                            cond,\n+                            List.nil(),\n+                            body));\n@@ -3627,2 +3643,3 @@\n-        boolean matchException = tree.patternSwitch && !tree.wasEnumSelector;\n-        List<JCCase> cases = tree.patternSwitch ? addDefaultIfNeeded(matchException, tree.cases)\n+        List<JCCase> cases = tree.patternSwitch ? addDefaultIfNeeded(tree.patternSwitch,\n+                                                                     tree.wasEnumSelector,\n+                                                                     tree.cases)\n@@ -3635,2 +3652,1 @@\n-        boolean matchException = tree.patternSwitch && !tree.wasEnumSelector;\n-        List<JCCase> cases = addDefaultIfNeeded(matchException, tree.cases);\n+        List<JCCase> cases = addDefaultIfNeeded(tree.patternSwitch, tree.wasEnumSelector, tree.cases);\n@@ -3640,1 +3656,2 @@\n-    private List<JCCase> addDefaultIfNeeded(boolean matchException, List<JCCase> cases) {\n+    private List<JCCase> addDefaultIfNeeded(boolean patternSwitch, boolean wasEnumSelector,\n+                                            List<JCCase> cases) {\n@@ -3642,0 +3659,2 @@\n+            boolean matchException = useMatchException;\n+            matchException |= patternSwitch && !wasEnumSelector;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":41,"deletions":22,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -1226,0 +1226,4 @@\n+        \/\/java.base may not be completed yet and computeTransitiveClosure\n+        \/\/may not complete it either, make sure it is completed:\n+        syms.java_base.complete();\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.source.tree.EnhancedForLoopTree;\n@@ -58,0 +59,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCThrow;\n@@ -326,17 +328,0 @@\n-        if (tree.var != null) {\n-            BindingSymbol binding = (BindingSymbol) tree.var.sym;\n-            Type castTargetType = principalType(tree);\n-            VarSymbol bindingVar = bindingContext.bindingDeclared(binding);\n-\n-            JCAssign fakeInit =\n-                    (JCAssign) make.at(TreeInfo.getStartPos(tree))\n-                                   .Assign(make.Ident(bindingVar),\n-                                           convert(make.Ident(currentValue), castTargetType))\n-                                   .setType(bindingVar.erasure(types));\n-            LetExpr nestedLE = make.LetExpr(List.of(make.Exec(fakeInit)),\n-                                            make.Literal(true));\n-            nestedLE.needsCond = true;\n-            nestedLE.setType(syms.booleanType);\n-            test = test != null ? makeBinary(Tag.AND, test, nestedLE) : nestedLE;\n-        }\n-\n@@ -444,9 +429,0 @@\n-            ListBuffer<JCCase> newCases = new ListBuffer<>();\n-            for (List<JCCase> c = cases; c.nonEmpty(); c = c.tail) {\n-                if (c.head.stats.isEmpty() && c.tail.nonEmpty()) {\n-                    c.tail.head.labels = c.tail.head.labels.prependList(c.head.labels);\n-                } else {\n-                    newCases.add(c.head);\n-                }\n-            }\n-            cases = newCases.toList();\n@@ -718,0 +694,71 @@\n+    @Override\n+    public void visitForeachLoop(JCTree.JCEnhancedForLoop tree) {\n+        bindingContext = new BasicBindingContext();\n+        VarSymbol prevCurrentValue = currentValue;\n+        try {\n+            if (tree.varOrRecordPattern instanceof JCRecordPattern jcRecordPattern) {\n+                \/**\n+                 * A statement of the form\n+                 *\n+                 * <pre>\n+                 *     for (<pattern> : coll ) stmt ;\n+                 * <\/pre>\n+                 *\n+                 * (where coll implements {@code Iterable<R>}) gets translated to\n+                 *\n+                 * <pre>{@code\n+                 *     for (<type-of-coll-item> N$temp : coll) {\n+                 *     switch (N$temp) {\n+                 *         case <pattern>: stmt;\n+                 *         case null: throw new MatchException();\n+                 *     }\n+                 * }<\/pre>\n+                 *\n+                 *\/\n+                Type selectorType = types.classBound(tree.elementType);\n+\n+                currentValue = new VarSymbol(Flags.FINAL | Flags.SYNTHETIC,\n+                        names.fromString(\"patt\" + tree.pos + target.syntheticNameChar() + \"temp\"),\n+                        selectorType,\n+                        currentMethodSym);\n+\n+                JCStatement newForVariableDeclaration =\n+                        make.at(tree.pos).VarDef(currentValue, null).setType(selectorType);\n+\n+                List<JCExpression> nestedNPEParams = List.of(makeNull());\n+                JCNewClass nestedNPE = makeNewClass(syms.nullPointerExceptionType, nestedNPEParams);\n+\n+                List<JCExpression> matchExParams = List.of(makeNull(), nestedNPE);\n+                JCThrow thr = make.Throw(makeNewClass(syms.matchExceptionType, matchExParams));\n+\n+                JCCase caseNull = make.Case(JCCase.STATEMENT, List.of(make.ConstantCaseLabel(makeNull())), List.of(thr), null);\n+\n+                JCCase casePattern = make.Case(CaseTree.CaseKind.STATEMENT,\n+                        List.of(make.PatternCaseLabel(jcRecordPattern, null)),\n+                        List.of(translate(tree.body)),\n+                        null);\n+\n+                JCSwitch switchBody =\n+                        make.Switch(make.Ident(currentValue).setType(selectorType),\n+                                List.of(caseNull, casePattern));\n+\n+                switchBody.patternSwitch = true;\n+\n+                \/\/ re-using the same node to eliminate the need to re-patch targets (break\/continue)\n+                tree.varOrRecordPattern = newForVariableDeclaration.setType(selectorType);\n+                tree.expr = translate(tree.expr);\n+                tree.body = translate(switchBody);\n+\n+                JCTree.JCEnhancedForLoop newForEach = tree;\n+\n+                result = bindingContext.decorateStatement(newForEach);\n+            } else {\n+                super.visitForeachLoop(tree);\n+                result = bindingContext.decorateStatement(tree);\n+            }\n+        } finally {\n+            currentValue = prevCurrentValue;\n+            bindingContext.pop();\n+        }\n+    }\n+\n@@ -760,1 +807,1 @@\n-            result = make.at(tree.pos).Ident(bindingVar);\n+            result = make.at(tree.pos).Ident(bindingVar).setType(bindingVar.erasure(types));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":74,"deletions":27,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -514,1 +514,1 @@\n-        tree.var = translate(tree.var, null);\n+        tree.varOrRecordPattern = translate(tree.varOrRecordPattern, null);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -376,1 +376,1 @@\n-                scan(tree.var, that.var)\n+                scan(tree.varOrRecordPattern, that.varOrRecordPattern)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TreeDiffer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -296,1 +296,1 @@\n-            sr.mergeWith(csp(tree.var));\n+            sr.mergeWith(csp(tree.varOrRecordPattern));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/CRTable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.SimpleDiagnosticPosition;\n@@ -762,1 +763,0 @@\n-\n@@ -799,12 +799,1 @@\n-                JCVariableDecl var;\n-                if (token.kind == IDENTIFIER) {\n-                    if (!checkGuard || token.name() != names.when) {\n-                        var = to(F.at(token.pos).VarDef(F.Modifiers(0), token.name(), e, null));\n-                        nextToken();\n-                    } else {\n-                        var = null;\n-                    }\n-                } else {\n-                    var = null;\n-                }\n-                pattern = toP(F.at(pos).RecordPattern(e, nested.toList(), var));\n+                pattern = toP(F.at(pos).RecordPattern(e, nested.toList()));\n@@ -1539,0 +1528,1 @@\n+            boolean allowDefault = false;\n@@ -1540,1 +1530,1 @@\n-                JCCaseLabel label = parseCaseLabel();\n+                JCCaseLabel label = parseCaseLabel(allowDefault);\n@@ -1545,0 +1535,1 @@\n+                allowDefault = TreeInfo.isNullCaseLabel(label);\n@@ -2829,6 +2820,15 @@\n-            List<JCStatement> inits = token.kind == SEMI ? List.nil() : forInit();\n-            if (inits.length() == 1 &&\n-                inits.head.hasTag(VARDEF) &&\n-                ((JCVariableDecl) inits.head).init == null &&\n-                token.kind == COLON) {\n-                JCVariableDecl var = (JCVariableDecl)inits.head;\n+            JCTree pattern;\n+\n+            ForInitResult initResult = analyzeForInit();\n+\n+            if (initResult == ForInitResult.RecordPattern) {\n+                int patternPos = token.pos;\n+                JCModifiers mods = optFinal(0);\n+                int typePos = token.pos;\n+                JCExpression type = unannotatedType(false);\n+\n+                pattern = parsePattern(patternPos, mods, type, false, false);\n+\n+                if (pattern != null) {\n+                    checkSourceLevel(token.pos, Feature.PATTERN_SWITCH);\n+                }\n@@ -2839,1 +2839,1 @@\n-                return F.at(pos).ForeachLoop(var, expr, body);\n+                return F.at(pos).ForeachLoop(pattern, expr, body);\n@@ -2841,7 +2841,20 @@\n-                accept(SEMI);\n-                JCExpression cond = token.kind == SEMI ? null : parseExpression();\n-                accept(SEMI);\n-                List<JCExpressionStatement> steps = token.kind == RPAREN ? List.nil() : forUpdate();\n-                accept(RPAREN);\n-                JCStatement body = parseStatementAsBlock();\n-                return F.at(pos).ForLoop(inits, cond, steps, body);\n+                List<JCStatement> inits = token.kind == SEMI ? List.nil() : forInit();\n+                if (inits.length() == 1 &&\n+                        inits.head.hasTag(VARDEF) &&\n+                        ((JCVariableDecl) inits.head).init == null &&\n+                        token.kind == COLON) {\n+                    JCVariableDecl var = (JCVariableDecl) inits.head;\n+                    accept(COLON);\n+                    JCExpression expr = parseExpression();\n+                    accept(RPAREN);\n+                    JCStatement body = parseStatementAsBlock();\n+                    return F.at(pos).ForeachLoop(var, expr, body);\n+                } else {\n+                    accept(SEMI);\n+                    JCExpression cond = token.kind == SEMI ? null : parseExpression();\n+                    accept(SEMI);\n+                    List<JCExpressionStatement> steps = token.kind == RPAREN ? List.nil() : forUpdate();\n+                    accept(RPAREN);\n+                    JCStatement body = parseStatementAsBlock();\n+                    return F.at(pos).ForLoop(inits, cond, steps, body);\n+                }\n@@ -2964,0 +2977,85 @@\n+    private enum ForInitResult {\n+        LocalVarDecl,\n+        RecordPattern\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    ForInitResult analyzeForInit() {\n+        boolean inType = false;\n+        boolean inSelectionAndParenthesis = false;\n+        int typeParameterPossibleStart = -1;\n+        outer: for (int lookahead = 0; ; lookahead++) {\n+            TokenKind tk = S.token(lookahead).kind;\n+            switch (tk) {\n+                case DOT:\n+                    if (inType) break; \/\/ in qualified type\n+                case COMMA:\n+                    typeParameterPossibleStart = lookahead;\n+                    break;\n+                case QUES:\n+                    \/\/ \"?\" only allowed in a type parameter position - otherwise it's an expression\n+                    if (typeParameterPossibleStart == lookahead - 1) break;\n+                    else return ForInitResult.LocalVarDecl;\n+                case EXTENDS: case SUPER: case AMP:\n+                case GTGTGT: case GTGT: case GT:\n+                case FINAL: case ELLIPSIS:\n+                    break;\n+                case BYTE: case SHORT: case INT: case LONG: case FLOAT:\n+                case DOUBLE: case BOOLEAN: case CHAR: case VOID:\n+                    if (peekToken(lookahead, IDENTIFIER)) {\n+                        return inSelectionAndParenthesis ? ForInitResult.RecordPattern\n+                                                         : ForInitResult.LocalVarDecl;\n+                    }\n+                    break;\n+                case LPAREN:\n+                    if (lookahead != 0 && inType) {\n+                        inSelectionAndParenthesis = true;\n+                        inType = false;\n+                    }\n+                    break;\n+                case RPAREN:\n+                    \/\/ a method call in the init part or a record pattern?\n+                    if (inSelectionAndParenthesis) {\n+                        if (peekToken(lookahead, DOT)  ||\n+                                peekToken(lookahead, SEMI) ||\n+                                peekToken(lookahead, ARROW)) {\n+                            return ForInitResult.LocalVarDecl;\n+                        }\n+                        else if(peekToken(lookahead, COLON)) {\n+                            return ForInitResult.RecordPattern;\n+                        }\n+                        break;\n+                    }\n+                case UNDERSCORE:\n+                case ASSERT:\n+                case ENUM:\n+                case IDENTIFIER:\n+                    if (lookahead == 0) {\n+                        inType = true;\n+                    }\n+                    break;\n+                case MONKEYS_AT: {\n+                    int prevLookahead = lookahead;\n+                    lookahead = skipAnnotation(lookahead);\n+                    if (typeParameterPossibleStart == prevLookahead - 1) {\n+                        \/\/ move possible start of type param after the anno\n+                        typeParameterPossibleStart = lookahead;\n+                    }\n+                    break;\n+                }\n+                case LBRACKET:\n+                    if (peekToken(lookahead, RBRACKET)) {\n+                        return inSelectionAndParenthesis ? ForInitResult.RecordPattern\n+                                                         : ForInitResult.LocalVarDecl;\n+                    }\n+                    return ForInitResult.LocalVarDecl;\n+                case LT:\n+                    typeParameterPossibleStart = lookahead;\n+                    break;\n+                default:\n+                    \/\/this includes EOF\n+                    return ForInitResult.LocalVarDecl;\n+            }\n+        }\n+    }\n+\n@@ -3037,0 +3135,1 @@\n+            boolean allowDefault = false;\n@@ -3038,1 +3137,2 @@\n-                pats.append(parseCaseLabel());\n+                JCCaseLabel label = parseCaseLabel(allowDefault);\n+                pats.append(label);\n@@ -3042,0 +3142,1 @@\n+                allowDefault = TreeInfo.isNullCaseLabel(label);\n@@ -3094,1 +3195,1 @@\n-    private JCCaseLabel parseCaseLabel() {\n+    private JCCaseLabel parseCaseLabel(boolean allowDefault) {\n@@ -3100,0 +3201,4 @@\n+            if (!allowDefault) {\n+                reportSyntaxError(new SimpleDiagnosticPosition(token.pos),\n+                                  Errors.DefaultLabelNotAllowed);\n+            }\n@@ -3849,0 +3954,1 @@\n+                List<JCExpression> implNames;\n@@ -3851,3 +3957,1 @@\n-                    List<JCExpression> implNames = qualidentList(false);\n-                    accept(SEMI);\n-                    defs.append(toP(F.at(pos).Provides(serviceName, implNames)));\n+                    implNames = qualidentList(false);\n@@ -3856,1 +3960,1 @@\n-                    skip(false, false, false, false);\n+                    implNames = List.nil();\n@@ -3858,0 +3962,2 @@\n+                accept(SEMI);\n+                defs.append(toP(F.at(pos).Provides(serviceName, implNames)));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":140,"deletions":34,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -528,0 +528,9 @@\n+compiler.err.invalid.case.label.combination=\\\n+    invalid case label combination\n+\n+compiler.err.default.label.not.allowed=\\\n+    default label not allowed here\n+\n+compiler.err.pattern.type.cannot.infer=\\\n+    cannot infer pattern type\n+\n@@ -597,0 +606,4 @@\n+# 0: type, 1: type\n+compiler.err.foreach.not.exhaustive.on.type=\\\n+    Pattern {0} is not exhaustive on {1}\n+\n@@ -3913,3 +3926,0 @@\n-compiler.err.raw.deconstruction.pattern=\\\n-    raw deconstruction patterns are not allowed\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1213,1 +1213,1 @@\n-        public JCVariableDecl var;\n+        public JCTree varOrRecordPattern;\n@@ -1216,2 +1216,4 @@\n-        protected JCEnhancedForLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {\n-            this.var = var;\n+        public Type elementType;\n+\n+        protected JCEnhancedForLoop(JCTree varOrRecordPattern, JCExpression expr, JCStatement body) {\n+            this.varOrRecordPattern = varOrRecordPattern;\n@@ -1227,1 +1229,5 @@\n-        public JCVariableDecl getVariable() { return var; }\n+        public JCVariableDecl getVariable() {\n+            return varOrRecordPattern instanceof JCVariableDecl var ? var : null;\n+        }\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public JCTree getVariableOrRecordPattern() { return varOrRecordPattern; }\n@@ -1240,0 +1246,4 @@\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public EnhancedForLoopTree.DeclarationKind getDeclarationKind() {\n+            return varOrRecordPattern.hasTag(VARDEF) ? DeclarationKind.VARIABLE : DeclarationKind.PATTERN;\n+        }\n@@ -2230,0 +2240,4 @@\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public TestKind getTestKind() {\n+            return pattern instanceof JCPatternCaseLabel ? TestKind.PATTERN : TestKind.TYPE;\n+        }\n@@ -2431,1 +2445,0 @@\n-        public JCVariableDecl var;\n@@ -2435,2 +2448,1 @@\n-        protected JCRecordPattern(JCExpression deconstructor, List<JCPattern> nested,\n-                                  JCVariableDecl var) {\n+        protected JCRecordPattern(JCExpression deconstructor, List<JCPattern> nested) {\n@@ -2439,1 +2451,0 @@\n-            this.var = var;\n@@ -2478,5 +2489,0 @@\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public VariableTree getVariable() {\n-            return var;\n-        }\n-\n@@ -3417,1 +3423,1 @@\n-        JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body);\n+        JCEnhancedForLoop ForeachLoop(JCTree var, JCExpression expr, JCStatement body);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":20,"deletions":14,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -804,1 +804,1 @@\n-            printExpr(tree.var);\n+            printExpr(tree.varOrRecordPattern);\n@@ -948,4 +948,0 @@\n-            if (tree.var != null) {\n-                print(\" \");\n-                print(tree.var.name);\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-        JCVariableDecl var = copy(t.var, p);\n+        JCTree varOrRecordPattern = copy(t.varOrRecordPattern, p);\n@@ -229,1 +229,1 @@\n-        return M.at(t.pos).ForeachLoop(var, expr, body);\n+        return M.at(t.pos).ForeachLoop(varOrRecordPattern, expr, body);\n@@ -533,2 +533,1 @@\n-        JCVariableDecl var = copy(t.var, p);\n-        return M.at(t.pos).RecordPattern(deconstructor, nested, var);\n+        return M.at(t.pos).RecordPattern(deconstructor, nested);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -276,2 +276,2 @@\n-    public JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {\n-        JCEnhancedForLoop tree = new JCEnhancedForLoop(var, expr, body);\n+    public JCEnhancedForLoop ForeachLoop(JCTree varOrRecordPattern, JCExpression expr, JCStatement body) {\n+        JCEnhancedForLoop tree = new JCEnhancedForLoop(varOrRecordPattern, expr, body);\n@@ -515,3 +515,2 @@\n-    public JCRecordPattern RecordPattern(JCExpression deconstructor, List<JCPattern> nested,\n-                                         JCVariableDecl var) {\n-        JCRecordPattern tree = new JCRecordPattern(deconstructor, nested, var);\n+    public JCRecordPattern RecordPattern(JCExpression deconstructor, List<JCPattern> nested) {\n+        JCRecordPattern tree = new JCRecordPattern(deconstructor, nested);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-        scan(tree.var);\n+        scan(tree.varOrRecordPattern);\n@@ -334,3 +334,0 @@\n-        if (that.var != null) {\n-            scan(that.var);\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-        tree.var = translate(tree.var);\n+        tree.varOrRecordPattern = translate(tree.varOrRecordPattern);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -482,9 +482,6 @@\n-                if (mode.equals(\"readWrite\")) {\n-                    nssDbMode = Secmod.DbMode.READ_WRITE;\n-                } else if (mode.equals(\"readOnly\")) {\n-                    nssDbMode = Secmod.DbMode.READ_ONLY;\n-                } else if (mode.equals(\"noDb\")) {\n-                    nssDbMode = Secmod.DbMode.NO_DB;\n-                } else {\n-                    throw excToken(\"nssDbMode must be one of readWrite, readOnly, and noDb:\");\n-                }\n+                nssDbMode = switch (mode) {\n+                    case \"readWrite\" -> Secmod.DbMode.READ_WRITE;\n+                    case \"readOnly\" -> Secmod.DbMode.READ_ONLY;\n+                    case \"noDb\" -> Secmod.DbMode.NO_DB;\n+                    default -> throw excToken(\"nssDbMode must be one of readWrite, readOnly, and noDb:\");\n+                };\n@@ -519,1 +516,1 @@\n-        if (nssUseSecmod == false) {\n+        if (!nssUseSecmod) {\n@@ -536,1 +533,1 @@\n-            if (nssUseSecmodTrust != false) {\n+            if (nssUseSecmodTrust) {\n@@ -626,8 +623,5 @@\n-        switch (val) {\n-            case \"true\":\n-                return true;\n-            case \"false\":\n-                return false;\n-            default:\n-                throw excToken(\"Expected boolean value, read:\");\n-        }\n+        return switch (val) {\n+            case \"true\" -> true;\n+            case \"false\" -> false;\n+            default -> throw excToken(\"Expected boolean value, read:\");\n+        };\n@@ -691,1 +685,1 @@\n-        if (str.startsWith(\"0h\") == false) {\n+        if (!str.startsWith(\"0h\")) {\n@@ -836,1 +830,1 @@\n-            if (s.equals(\"compatibility\") == false) {\n+            if (!s.equals(\"compatibility\")) {\n@@ -967,10 +961,6 @@\n-        switch (op) {\n-            case \"*\":\n-                return TemplateManager.O_ANY;\n-            case \"generate\":\n-                return TemplateManager.O_GENERATE;\n-            case \"import\":\n-                return TemplateManager.O_IMPORT;\n-            default:\n-                throw excLine(\"Unknown operation \" + op);\n-        }\n+        return switch (op) {\n+            case \"*\" -> TemplateManager.O_ANY;\n+            case \"generate\" -> TemplateManager.O_GENERATE;\n+            case \"import\" -> TemplateManager.O_IMPORT;\n+            default -> throw excLine(\"Unknown operation \" + op);\n+        };\n@@ -1047,9 +1037,6 @@\n-        if (val.equals(\"ignoreAll\")) {\n-            handleStartupErrors = ERR_IGNORE_ALL;\n-        } else if (val.equals(\"ignoreMissingLibrary\")) {\n-            handleStartupErrors = ERR_IGNORE_LIB;\n-        } else if (val.equals(\"halt\")) {\n-            handleStartupErrors = ERR_HALT;\n-        } else {\n-            throw excToken(\"Invalid value for handleStartupErrors:\");\n-        }\n+        handleStartupErrors = switch (val) {\n+            case \"ignoreAll\" -> ERR_IGNORE_ALL;\n+            case \"ignoreMissingLibrary\" -> ERR_IGNORE_LIB;\n+            case \"halt\" -> ERR_HALT;\n+            default -> throw excToken(\"Invalid value for handleStartupErrors:\");\n+        };\n@@ -1064,0 +1051,1 @@\n+    @Serial\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Config.java","additions":28,"deletions":40,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-            if (o instanceof IdentityWrapper == false) {\n+            if (!(o instanceof IdentityWrapper)) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/KeyCache.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-            case AES_GCM:\n+            case AES_GCM -> {\n@@ -221,2 +221,2 @@\n-            break;\n-            case CHACHA20_POLY1305:\n+            }\n+            case CHACHA20_POLY1305 -> {\n@@ -231,3 +231,2 @@\n-            break;\n-            default:\n-                throw new AssertionError(\"Unsupported type \" + type);\n+            }\n+            default -> throw new AssertionError(\"Unsupported type \" + type);\n@@ -314,12 +313,4 @@\n-                switch (type) {\n-                    case AES_GCM:\n-                        paramSpec =\n-                            params.getParameterSpec(GCMParameterSpec.class);\n-                        break;\n-                    case CHACHA20_POLY1305:\n-                        paramSpec =\n-                            params.getParameterSpec(IvParameterSpec.class);\n-                        break;\n-                    default:\n-                        throw new AssertionError(\"Unsupported type \" + type);\n-                }\n+                paramSpec = switch (type) {\n+                    case AES_GCM -> params.getParameterSpec(GCMParameterSpec.class);\n+                    case CHACHA20_POLY1305 -> params.getParameterSpec(IvParameterSpec.class);\n+                };\n@@ -346,1 +337,1 @@\n-            case Cipher.ENCRYPT_MODE:\n+            case Cipher.ENCRYPT_MODE -> {\n@@ -354,2 +345,2 @@\n-                break;\n-            case Cipher.DECRYPT_MODE:\n+            }\n+            case Cipher.DECRYPT_MODE -> {\n@@ -358,6 +349,4 @@\n-                break;\n-            case Cipher.WRAP_MODE:\n-            case Cipher.UNWRAP_MODE:\n-                throw new UnsupportedOperationException\n-                        (\"Unsupported mode: \" + opmode);\n-            default:\n+            }\n+            case Cipher.WRAP_MODE, Cipher.UNWRAP_MODE -> throw new UnsupportedOperationException\n+                    (\"Unsupported mode: \" + opmode);\n+            default ->\n@@ -365,1 +354,1 @@\n-                throw new AssertionError(\"Unknown mode: \" + opmode);\n+                    throw new AssertionError(\"Unknown mode: \" + opmode);\n@@ -375,14 +364,3 @@\n-            switch (type) {\n-                case AES_GCM:\n-                    iv = new byte[type.defIvLen];\n-                    this.random.nextBytes(iv);\n-                    tagLen = type.defTagLen;\n-                    break;\n-                case CHACHA20_POLY1305:\n-                    iv = new byte[type.defIvLen];\n-                    this.random.nextBytes(iv);\n-                    tagLen = type.defTagLen;\n-                    break;\n-                default:\n-                    throw new AssertionError(\"Unsupported type \" + type);\n-            }\n+            iv = new byte[type.defIvLen];\n+            this.random.nextBytes(iv);\n+            tagLen = type.defTagLen;\n@@ -466,4 +444,2 @@\n-            CK_MECHANISM mechWithParams;\n-            switch (type) {\n-                case AES_GCM:\n-                    mechWithParams = new CK_MECHANISM(mechanism,\n+            CK_MECHANISM mechWithParams = switch (type) {\n+                case AES_GCM -> new CK_MECHANISM(mechanism,\n@@ -471,3 +447,1 @@\n-                    break;\n-                case CHACHA20_POLY1305:\n-                    mechWithParams = new CK_MECHANISM(mechanism,\n+                case CHACHA20_POLY1305 -> new CK_MECHANISM(mechanism,\n@@ -475,4 +449,1 @@\n-                    break;\n-                default:\n-                    throw new AssertionError(\"Unsupported type: \" + type);\n-            }\n+            };\n@@ -516,1 +487,1 @@\n-        return (result > 0 ? result : 0);\n+        return (Math.max(result, 0));\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":25,"deletions":54,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -228,7 +228,8 @@\n-        int result;\n-        if (mode.equals(\"ECB\")) {\n-            result = MODE_ECB;\n-        } else if (mode.equals(\"CBC\")) {\n-            if (blockSize == 0) {\n-                throw new NoSuchAlgorithmException\n-                        (\"CBC mode not supported with stream ciphers\");\n+        return switch (mode) {\n+            case \"ECB\" -> MODE_ECB;\n+            case \"CBC\" -> {\n+                if (blockSize == 0) {\n+                    throw new NoSuchAlgorithmException\n+                            (\"CBC mode not supported with stream ciphers\");\n+                }\n+                yield MODE_CBC;\n@@ -236,7 +237,3 @@\n-            result = MODE_CBC;\n-        } else if (mode.equals(\"CTR\")) {\n-            result = MODE_CTR;\n-        } else {\n-            throw new NoSuchAlgorithmException(\"Unsupported mode \" + mode);\n-        }\n-        return result;\n+            case \"CTR\" -> MODE_CTR;\n+            default -> throw new NoSuchAlgorithmException(\"Unsupported mode \" + mode);\n+        };\n@@ -324,1 +321,1 @@\n-            if (params instanceof IvParameterSpec == false) {\n+            if (!(params instanceof IvParameterSpec)) {\n@@ -366,12 +363,6 @@\n-        switch (opmode) {\n-            case Cipher.ENCRYPT_MODE:\n-                encrypt = true;\n-                break;\n-            case Cipher.DECRYPT_MODE:\n-                encrypt = false;\n-                break;\n-            case Cipher.WRAP_MODE:\n-            case Cipher.UNWRAP_MODE:\n-                throw new UnsupportedOperationException\n-                        (\"Unsupported mode: \" + opmode);\n-            default:\n+        encrypt = switch (opmode) {\n+            case Cipher.ENCRYPT_MODE -> true;\n+            case Cipher.DECRYPT_MODE -> false;\n+            case Cipher.WRAP_MODE, Cipher.UNWRAP_MODE -> throw new UnsupportedOperationException\n+                    (\"Unsupported mode: \" + opmode);\n+            default ->\n@@ -379,2 +370,2 @@\n-                throw new AssertionError(\"Unknown mode: \" + opmode);\n-        }\n+                    throw new AssertionError(\"Unknown mode: \" + opmode);\n+        };\n@@ -393,1 +384,1 @@\n-                if (encrypt == false) {\n+                if (!encrypt) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":21,"deletions":30,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -54,2 +54,1 @@\n-            if (key instanceof DHPublicKey) {\n-                DHPublicKey dhKey = (DHPublicKey)key;\n+            if (key instanceof DHPublicKey dhKey) {\n@@ -83,2 +82,1 @@\n-            if (key instanceof DHPrivateKey) {\n-                DHPrivateKey dhKey = (DHPrivateKey)key;\n+            if (key instanceof DHPrivateKey dhKey) {\n@@ -123,1 +121,1 @@\n-        if (keySpec instanceof DHPublicKeySpec == false) {\n+        if (!(keySpec instanceof DHPublicKeySpec)) {\n@@ -154,1 +152,1 @@\n-        if (keySpec instanceof DHPrivateKeySpec == false) {\n+        if (!(keySpec instanceof DHPrivateKeySpec)) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11DHKeyFactory.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -52,2 +52,1 @@\n-            if (key instanceof DSAPublicKey) {\n-                DSAPublicKey dsaKey = (DSAPublicKey)key;\n+            if (key instanceof DSAPublicKey dsaKey) {\n@@ -78,2 +77,1 @@\n-            if (key instanceof DSAPrivateKey) {\n-                DSAPrivateKey dsaKey = (DSAPrivateKey)key;\n+            if (key instanceof DSAPrivateKey dsaKey) {\n@@ -115,1 +113,1 @@\n-        if (keySpec instanceof DSAPublicKeySpec == false) {\n+        if (!(keySpec instanceof DSAPublicKeySpec)) {\n@@ -147,1 +145,1 @@\n-        if (keySpec instanceof DSAPrivateKeySpec == false) {\n+        if (!(keySpec instanceof DSAPrivateKeySpec)) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11DSAKeyFactory.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -98,29 +98,9 @@\n-        switch ((int)mechanism) {\n-        case (int)CKM_MD2:\n-        case (int)CKM_MD5:\n-            digestLength = 16;\n-            break;\n-        case (int)CKM_SHA_1:\n-            digestLength = 20;\n-            break;\n-        case (int)CKM_SHA224:\n-        case (int)CKM_SHA512_224:\n-        case (int)CKM_SHA3_224:\n-            digestLength = 28;\n-            break;\n-        case (int)CKM_SHA256:\n-        case (int)CKM_SHA512_256:\n-        case (int)CKM_SHA3_256:\n-            digestLength = 32;\n-            break;\n-        case (int)CKM_SHA384:\n-        case (int)CKM_SHA3_384:\n-            digestLength = 48;\n-            break;\n-        case (int)CKM_SHA512:\n-        case (int)CKM_SHA3_512:\n-            digestLength = 64;\n-            break;\n-        default:\n-            throw new ProviderException(\"Unknown mechanism: \" + mechanism);\n-        }\n+        digestLength = switch ((int) mechanism) {\n+            case (int) CKM_MD2, (int) CKM_MD5 -> 16;\n+            case (int) CKM_SHA_1 -> 20;\n+            case (int) CKM_SHA224, (int) CKM_SHA512_224, (int) CKM_SHA3_224 -> 28;\n+            case (int) CKM_SHA256, (int) CKM_SHA512_256, (int) CKM_SHA3_256 -> 32;\n+            case (int) CKM_SHA384, (int) CKM_SHA3_384 -> 48;\n+            case (int) CKM_SHA512, (int) CKM_SHA3_512 -> 64;\n+            default -> throw new ProviderException(\"Unknown mechanism: \" + mechanism);\n+        };\n@@ -153,2 +133,2 @@\n-            if (state == S_INIT && token.explicitCancel == true\n-                    && session.hasObjects() == false) {\n+            if (state == S_INIT && token.explicitCancel\n+                    && !session.hasObjects()) {\n@@ -255,1 +235,1 @@\n-        if (key instanceof P11Key == false) {\n+        if (!(key instanceof P11Key p11Key)) {\n@@ -258,1 +238,0 @@\n-        P11Key p11Key = (P11Key)key;\n@@ -292,1 +271,1 @@\n-        if (byteBuffer instanceof DirectBuffer == false) {\n+        if (!(byteBuffer instanceof DirectBuffer)) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Digest.java","additions":13,"deletions":34,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-        if (key instanceof PrivateKey == false) {\n+        if (!(key instanceof PrivateKey)) {\n@@ -102,1 +102,1 @@\n-        if (lastPhase == false) {\n+        if (!lastPhase) {\n@@ -106,1 +106,1 @@\n-        if (key instanceof ECPublicKey == false) {\n+        if (!(key instanceof ECPublicKey ecKey)) {\n@@ -110,1 +110,0 @@\n-        ECPublicKey ecKey = (ECPublicKey)key;\n@@ -172,1 +171,1 @@\n-        if (algorithm.equals(\"TlsPremasterSecret\") == false) {\n+        if (!algorithm.equals(\"TlsPremasterSecret\")) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11ECDHKeyAgreement.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,2 +94,1 @@\n-        if (key instanceof ECPublicKey) {\n-            ECPublicKey ecKey = (ECPublicKey)key;\n+        if (key instanceof ECPublicKey ecKey) {\n@@ -108,2 +107,1 @@\n-            if (key instanceof ECPublicKey) {\n-                ECPublicKey ecKey = (ECPublicKey)key;\n+            if (key instanceof ECPublicKey ecKey) {\n@@ -137,2 +135,1 @@\n-            if (key instanceof ECPrivateKey) {\n-                ECPrivateKey ecKey = (ECPrivateKey)key;\n+            if (key instanceof ECPrivateKey ecKey) {\n@@ -177,1 +174,1 @@\n-        if (keySpec instanceof ECPublicKeySpec == false) {\n+        if (!(keySpec instanceof ECPublicKeySpec)) {\n@@ -207,1 +204,1 @@\n-        if (keySpec instanceof ECPrivateKeySpec == false) {\n+        if (!(keySpec instanceof ECPrivateKeySpec)) {\n@@ -233,2 +230,1 @@\n-            try {\n-                encodedPoint =\n+            encodedPoint =\n@@ -236,5 +232,1 @@\n-                        .toByteArray();\n-            } catch (IOException e) {\n-                throw new\n-                    IllegalArgumentException(\"Could not DER encode point\", e);\n-            }\n+                            .toByteArray();\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11ECKeyFactory.java","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+    @Serial\n@@ -191,1 +192,1 @@\n-        if (token.isValid() == false) {\n+        if (!token.isValid()) {\n@@ -194,1 +195,1 @@\n-        if (obj instanceof Key == false) {\n+        if (!(obj instanceof Key other)) {\n@@ -203,2 +204,1 @@\n-        Key other = (Key)obj;\n-        if (thisFormat.equals(other.getFormat()) == false) {\n+        if (!thisFormat.equals(other.getFormat())) {\n@@ -219,1 +219,1 @@\n-        if (token.isValid() == false) {\n+        if (!token.isValid()) {\n@@ -372,15 +372,10 @@\n-        switch (algorithm) {\n-            case \"RSA\":\n-                return new P11RSAPublicKey(session, keyID, algorithm,\n-                        keyLength, attrs);\n-            case \"DSA\":\n-                return new P11DSAPublicKey(session, keyID, algorithm,\n-                        keyLength, attrs);\n-            case \"DH\":\n-                return new P11DHPublicKey(session, keyID, algorithm,\n-                        keyLength, attrs);\n-            case \"EC\":\n-                return new P11ECPublicKey(session, keyID, algorithm,\n-                        keyLength, attrs);\n-            default:\n-                throw new ProviderException\n+        return switch (algorithm) {\n+            case \"RSA\" -> new P11RSAPublicKey(session, keyID, algorithm,\n+                    keyLength, attrs);\n+            case \"DSA\" -> new P11DSAPublicKey(session, keyID, algorithm,\n+                    keyLength, attrs);\n+            case \"DH\" -> new P11DHPublicKey(session, keyID, algorithm,\n+                    keyLength, attrs);\n+            case \"EC\" -> new P11ECPublicKey(session, keyID, algorithm,\n+                    keyLength, attrs);\n+            default -> throw new ProviderException\n@@ -388,1 +383,1 @@\n-        }\n+        };\n@@ -402,3 +397,2 @@\n-        switch (algorithm) {\n-        case \"RSA\":\n-            return P11RSAPrivateKeyInternal.of(session, keyID, algorithm,\n+        return switch (algorithm) {\n+            case \"RSA\" -> P11RSAPrivateKeyInternal.of(session, keyID, algorithm,\n@@ -406,2 +400,1 @@\n-        case \"DSA\":\n-            return P11DSAPrivateKeyInternal.of(session, keyID, algorithm,\n+            case \"DSA\" -> P11DSAPrivateKeyInternal.of(session, keyID, algorithm,\n@@ -409,2 +402,1 @@\n-        case \"DH\":\n-            return P11DHPrivateKeyInternal.of(session, keyID, algorithm,\n+            case \"DH\" -> P11DHPrivateKeyInternal.of(session, keyID, algorithm,\n@@ -412,2 +404,1 @@\n-        case \"EC\":\n-            return P11ECPrivateKeyInternal.of(session, keyID, algorithm,\n+            case \"EC\" -> P11ECPrivateKeyInternal.of(session, keyID, algorithm,\n@@ -415,2 +406,1 @@\n-        default:\n-            throw new ProviderException\n+            default -> throw new ProviderException\n@@ -418,1 +408,1 @@\n-        }\n+        };\n@@ -424,0 +414,1 @@\n+        @Serial\n@@ -444,0 +435,1 @@\n+        @Serial\n@@ -487,0 +479,1 @@\n+        @Serial\n@@ -500,0 +493,1 @@\n+        @Serial\n@@ -520,0 +514,1 @@\n+        @Serial\n@@ -593,0 +588,1 @@\n+        @Serial\n@@ -670,0 +666,1 @@\n+        @Serial\n@@ -715,0 +712,1 @@\n+        @Serial\n@@ -771,0 +769,1 @@\n+        @Serial\n@@ -804,7 +803,3 @@\n-                try {\n-                    Key key = new sun.security.provider.DSAPublicKey\n-                            (y, params.getP(), params.getQ(), params.getG());\n-                    encoded = key.getEncoded();\n-                } catch (InvalidKeyException e) {\n-                    throw new ProviderException(e);\n-                }\n+                Key key = new sun.security.provider.DSAPublicKey\n+                        (y, params.getP(), params.getQ(), params.getG());\n+                encoded = key.getEncoded();\n@@ -830,0 +825,1 @@\n+        @Serial\n@@ -871,0 +867,1 @@\n+        @Serial\n@@ -923,0 +920,1 @@\n+        @Serial\n@@ -963,0 +961,1 @@\n+        @Serial\n@@ -1101,1 +1100,1 @@\n-            if (token.isValid() == false) {\n+            if (!token.isValid()) {\n@@ -1110,1 +1109,1 @@\n-            if (token.isValid() == false) {\n+            if (!token.isValid()) {\n@@ -1113,1 +1112,1 @@\n-            if (!(obj instanceof DHPublicKey)) {\n+            if (!(obj instanceof DHPublicKey other)) {\n@@ -1117,1 +1116,0 @@\n-            DHPublicKey other = (DHPublicKey) obj;\n@@ -1127,0 +1125,1 @@\n+        @Serial\n@@ -1171,0 +1170,1 @@\n+        @Serial\n@@ -1229,0 +1229,1 @@\n+        @Serial\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":45,"deletions":44,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-        if (key instanceof PrivateKey == false) {\n+        if (!(key instanceof PrivateKey)) {\n@@ -129,1 +129,1 @@\n-        if ((multiPartyAgreement != null) || (lastPhase == false)) {\n+        if ((multiPartyAgreement != null) || (!lastPhase)) {\n@@ -142,2 +142,2 @@\n-        if ((key instanceof PublicKey == false)\n-                || (key.getAlgorithm().equals(algorithm) == false)) {\n+        if ((!(key instanceof PublicKey))\n+                || (!key.getAlgorithm().equals(algorithm))) {\n@@ -148,2 +148,1 @@\n-        if (key instanceof DHPublicKey) {\n-            DHPublicKey dhKey = (DHPublicKey)key;\n+        if (key instanceof DHPublicKey dhKey) {\n@@ -179,2 +178,1 @@\n-        if (privateKey instanceof DHPrivateKey) {\n-            DHPrivateKey dhKey = (DHPrivateKey)privateKey;\n+        if (privateKey instanceof DHPrivateKey dhKey) {\n@@ -182,2 +180,2 @@\n-            if ((p.equals(params.getP()) == false)\n-                                || (g.equals(params.getG()) == false)) {\n+            if ((!p.equals(params.getP()))\n+                                || (!g.equals(params.getG()))) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyAgreement.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-        if (key.getAlgorithm().equals(this.algorithm) == false) {\n+        if (!key.getAlgorithm().equals(this.algorithm)) {\n@@ -141,2 +141,1 @@\n-        if (key instanceof P11Key) {\n-            P11Key p11Key = (P11Key)key;\n+        if (key instanceof P11Key p11Key) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyFactory.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -212,89 +212,94 @@\n-        switch ((int)mechanism) {\n-        case (int)CKM_DES_KEY_GEN:\n-            keySize = 64;\n-            keyType = CKK_DES;\n-            significantKeySize = 56;\n-            break;\n-        case (int)CKM_DES2_KEY_GEN:\n-            keySize = 128;\n-            keyType = CKK_DES2;\n-            significantKeySize = 112;\n-            break;\n-        case (int)CKM_DES3_KEY_GEN:\n-            keySize = 192;\n-            keyType = CKK_DES3;\n-            significantKeySize = 168;\n-            break;\n-        case (int)CKM_AES_KEY_GEN:\n-            keySize = adjustKeySize\n-                    (SecurityProviderConstants.getDefAESKeySize(), range);\n-            keyType = CKK_AES;\n-            break;\n-        case (int)CKM_RC4_KEY_GEN:\n-            keySize = adjustKeySize(128, range);\n-            keyType = CKK_RC4;\n-            break;\n-        case (int)CKM_BLOWFISH_KEY_GEN:\n-            keySize = adjustKeySize(128, range);\n-            keyType = CKK_BLOWFISH;\n-            break;\n-        case (int)CKM_CHACHA20_KEY_GEN:\n-            keySize = 256;\n-            keyType = CKK_CHACHA20;\n-            break;\n-        case (int)CKM_SHA_1_KEY_GEN:\n-            keySize = adjustKeySize(160, range);\n-            keyType = CKK_SHA_1_HMAC;\n-            break;\n-        case (int)CKM_SHA224_KEY_GEN:\n-            keySize = adjustKeySize(224, range);\n-            keyType = CKK_SHA224_HMAC;\n-            break;\n-        case (int)CKM_SHA256_KEY_GEN:\n-            keySize = adjustKeySize(256, range);\n-            keyType = CKK_SHA256_HMAC;\n-            break;\n-        case (int)CKM_SHA384_KEY_GEN:\n-            keySize = adjustKeySize(384, range);\n-            keyType = CKK_SHA384_HMAC;\n-            break;\n-        case (int)CKM_SHA512_KEY_GEN:\n-            keySize = adjustKeySize(512, range);\n-            keyType = CKK_SHA512_HMAC;\n-            break;\n-        case (int)CKM_SHA512_224_KEY_GEN:\n-            keySize = adjustKeySize(224, range);\n-            keyType = CKK_SHA512_224_HMAC;\n-            break;\n-        case (int)CKM_SHA512_256_KEY_GEN:\n-            keySize = adjustKeySize(256, range);\n-            keyType = CKK_SHA512_256_HMAC;\n-            break;\n-        case (int)CKM_SHA3_224_KEY_GEN:\n-            keySize = adjustKeySize(224, range);\n-            keyType = CKK_SHA3_224_HMAC;\n-            break;\n-        case (int)CKM_SHA3_256_KEY_GEN:\n-            keySize = adjustKeySize(256, range);\n-            keyType = CKK_SHA3_256_HMAC;\n-            break;\n-        case (int)CKM_SHA3_384_KEY_GEN:\n-            keySize = adjustKeySize(384, range);\n-            keyType = CKK_SHA3_384_HMAC;\n-            break;\n-        case (int)CKM_SHA3_512_KEY_GEN:\n-            keySize = adjustKeySize(512, range);\n-            keyType = CKK_SHA3_512_HMAC;\n-            break;\n-        case (int)CKM_GENERIC_SECRET_KEY_GEN:\n-            if (algorithm.startsWith(\"Hmac\")) {\n-                String digest = algorithm.substring(4);\n-                keySize = adjustKeySize(switch (digest) {\n-                    case \"MD5\" -> 512;\n-                    case \"SHA1\" -> 160;\n-                    case \"SHA224\", \"SHA512\/224\", \"SHA3-224\" -> 224;\n-                    case \"SHA256\", \"SHA512\/256\", \"SHA3-256\" -> 256;\n-                    case \"SHA384\", \"SHA3-384\" -> 384;\n-                    case \"SHA512\", \"SHA3-512\" -> 512;\n-                    default -> {\n-                        throw new ProviderException(\"Unsupported algorithm \" +\n+        switch ((int) mechanism) {\n+            case (int) CKM_DES_KEY_GEN -> {\n+                keySize = 64;\n+                keyType = CKK_DES;\n+                significantKeySize = 56;\n+            }\n+            case (int) CKM_DES2_KEY_GEN -> {\n+                keySize = 128;\n+                keyType = CKK_DES2;\n+                significantKeySize = 112;\n+            }\n+            case (int) CKM_DES3_KEY_GEN -> {\n+                keySize = 192;\n+                keyType = CKK_DES3;\n+                significantKeySize = 168;\n+            }\n+            case (int) CKM_AES_KEY_GEN -> {\n+                keySize = adjustKeySize\n+                        (SecurityProviderConstants.getDefAESKeySize(), range);\n+                keyType = CKK_AES;\n+            }\n+            case (int) CKM_RC4_KEY_GEN -> {\n+                keySize = adjustKeySize(128, range);\n+                keyType = CKK_RC4;\n+            }\n+            case (int) CKM_BLOWFISH_KEY_GEN -> {\n+                keySize = adjustKeySize(128, range);\n+                keyType = CKK_BLOWFISH;\n+            }\n+            case (int) CKM_CHACHA20_KEY_GEN -> {\n+                keySize = 256;\n+                keyType = CKK_CHACHA20;\n+            }\n+            case (int) CKM_SHA_1_KEY_GEN -> {\n+                keySize = adjustKeySize(160, range);\n+                keyType = CKK_SHA_1_HMAC;\n+            }\n+            case (int) CKM_SHA224_KEY_GEN -> {\n+                keySize = adjustKeySize(224, range);\n+                keyType = CKK_SHA224_HMAC;\n+            }\n+            case (int) CKM_SHA256_KEY_GEN -> {\n+                keySize = adjustKeySize(256, range);\n+                keyType = CKK_SHA256_HMAC;\n+            }\n+            case (int) CKM_SHA384_KEY_GEN -> {\n+                keySize = adjustKeySize(384, range);\n+                keyType = CKK_SHA384_HMAC;\n+            }\n+            case (int) CKM_SHA512_KEY_GEN -> {\n+                keySize = adjustKeySize(512, range);\n+                keyType = CKK_SHA512_HMAC;\n+            }\n+            case (int) CKM_SHA512_224_KEY_GEN -> {\n+                keySize = adjustKeySize(224, range);\n+                keyType = CKK_SHA512_224_HMAC;\n+            }\n+            case (int) CKM_SHA512_256_KEY_GEN -> {\n+                keySize = adjustKeySize(256, range);\n+                keyType = CKK_SHA512_256_HMAC;\n+            }\n+            case (int) CKM_SHA3_224_KEY_GEN -> {\n+                keySize = adjustKeySize(224, range);\n+                keyType = CKK_SHA3_224_HMAC;\n+            }\n+            case (int) CKM_SHA3_256_KEY_GEN -> {\n+                keySize = adjustKeySize(256, range);\n+                keyType = CKK_SHA3_256_HMAC;\n+            }\n+            case (int) CKM_SHA3_384_KEY_GEN -> {\n+                keySize = adjustKeySize(384, range);\n+                keyType = CKK_SHA3_384_HMAC;\n+            }\n+            case (int) CKM_SHA3_512_KEY_GEN -> {\n+                keySize = adjustKeySize(512, range);\n+                keyType = CKK_SHA3_512_HMAC;\n+            }\n+            case (int) CKM_GENERIC_SECRET_KEY_GEN -> {\n+                if (algorithm.startsWith(\"Hmac\")) {\n+                    String digest = algorithm.substring(4);\n+                    keySize = adjustKeySize(switch (digest) {\n+                        case \"MD5\" -> 512;\n+                        case \"SHA1\" -> 160;\n+                        case \"SHA224\", \"SHA512\/224\", \"SHA3-224\" -> 224;\n+                        case \"SHA256\", \"SHA512\/256\", \"SHA3-256\" -> 256;\n+                        case \"SHA384\", \"SHA3-384\" -> 384;\n+                        case \"SHA512\", \"SHA3-512\" -> 512;\n+                        default -> {\n+                            throw new ProviderException(\"Unsupported algorithm \" +\n+                                    algorithm);\n+                        }\n+                    }, range);\n+                } else {\n+                    throw new ProviderException(\"Unsupported algorithm \" +\n@@ -302,5 +307,2 @@\n-                    }\n-                }, range);\n-            } else {\n-                throw new ProviderException(\"Unsupported algorithm \" +\n-                        algorithm);\n+                }\n+                keyType = CKK_GENERIC_SECRET;\n@@ -308,4 +310,1 @@\n-            keyType = CKK_GENERIC_SECRET;\n-            break;\n-        default:\n-            throw new ProviderException(\"Unknown mechanism \" + mechanism);\n+            default -> throw new ProviderException(\"Unknown mechanism \" + mechanism);\n@@ -366,15 +365,9 @@\n-            CK_ATTRIBUTE[] attributes;\n-\n-            switch ((int)mechanism) {\n-            case (int)CKM_DES_KEY_GEN:\n-            case (int)CKM_DES2_KEY_GEN:\n-            case (int)CKM_DES3_KEY_GEN:\n-                \/\/ fixed length, do not specify CKA_VALUE_LEN\n-                attributes = new CK_ATTRIBUTE[] {\n-                    new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),\n-                };\n-                break;\n-            default:\n-                attributes = new CK_ATTRIBUTE[] {\n-                    new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),\n-                    new CK_ATTRIBUTE(CKA_VALUE_LEN, keySize >> 3),\n+            CK_ATTRIBUTE[] attributes = switch ((int) mechanism) {\n+                case (int) CKM_DES_KEY_GEN, (int) CKM_DES2_KEY_GEN, (int) CKM_DES3_KEY_GEN ->\n+                    \/\/ fixed length, do not specify CKA_VALUE_LEN\n+                        new CK_ATTRIBUTE[]{\n+                                new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),\n+                        };\n+                default -> new CK_ATTRIBUTE[]{\n+                        new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),\n+                        new CK_ATTRIBUTE(CKA_VALUE_LEN, keySize >> 3),\n@@ -382,2 +375,2 @@\n-                break;\n-            }\n+            };\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyGenerator.java","additions":108,"deletions":115,"binary":false,"changes":223,"status":"modified"},{"patch":"@@ -175,13 +175,8 @@\n-        if (algorithm.equals(\"DH\")) {\n-            if (params instanceof DHParameterSpec == false) {\n-                throw new InvalidAlgorithmParameterException\n-                        (\"DHParameterSpec required for Diffie-Hellman\");\n-            }\n-            DHParameterSpec dhParams = (DHParameterSpec) params;\n-            tmpKeySize = dhParams.getP().bitLength();\n-            checkKeySize(tmpKeySize, dhParams);\n-            \/\/ XXX sanity check params\n-        } else if (algorithm.equals(\"RSA\")) {\n-            if (params instanceof RSAKeyGenParameterSpec == false) {\n-                throw new InvalidAlgorithmParameterException\n-                        (\"RSAKeyGenParameterSpec required for RSA\");\n+        switch (algorithm) {\n+            case \"DH\" -> {\n+                if (!(params instanceof DHParameterSpec dhParams)) {\n+                    throw new InvalidAlgorithmParameterException\n+                            (\"DHParameterSpec required for Diffie-Hellman\");\n+                }\n+                tmpKeySize = dhParams.getP().bitLength();\n+                checkKeySize(tmpKeySize, dhParams);\n@@ -189,7 +184,0 @@\n-            RSAKeyGenParameterSpec rsaParams =\n-                (RSAKeyGenParameterSpec) params;\n-            tmpKeySize = rsaParams.getKeysize();\n-            checkKeySize(tmpKeySize, rsaParams);\n-            \/\/ override the supplied params to null\n-            params = null;\n-            this.rsaPublicExponent = rsaParams.getPublicExponent();\n@@ -197,4 +185,10 @@\n-        } else if (algorithm.equals(\"DSA\")) {\n-            if (params instanceof DSAParameterSpec == false) {\n-                throw new InvalidAlgorithmParameterException\n-                        (\"DSAParameterSpec required for DSA\");\n+            case \"RSA\" -> {\n+                if (!(params instanceof RSAKeyGenParameterSpec rsaParams)) {\n+                    throw new InvalidAlgorithmParameterException\n+                            (\"RSAKeyGenParameterSpec required for RSA\");\n+                }\n+                tmpKeySize = rsaParams.getKeysize();\n+                checkKeySize(tmpKeySize, rsaParams);\n+                \/\/ override the supplied params to null\n+                params = null;\n+                this.rsaPublicExponent = rsaParams.getPublicExponent();\n@@ -202,3 +196,0 @@\n-            DSAParameterSpec dsaParams = (DSAParameterSpec) params;\n-            tmpKeySize = dsaParams.getP().bitLength();\n-            checkKeySize(tmpKeySize, dsaParams);\n@@ -206,6 +197,2 @@\n-        } else if (algorithm.equals(\"EC\")) {\n-            ECParameterSpec ecParams;\n-            if (params instanceof ECParameterSpec) {\n-                ecParams = P11ECKeyFactory.getECParameterSpec(\n-                    (ECParameterSpec)params);\n-                if (ecParams == null) {\n+            case \"DSA\" -> {\n+                if (!(params instanceof DSAParameterSpec dsaParams)) {\n@@ -213,1 +200,1 @@\n-                        (\"Unsupported curve: \" + params);\n+                            (\"DSAParameterSpec required for DSA\");\n@@ -215,4 +202,22 @@\n-            } else if (params instanceof ECGenParameterSpec) {\n-                String name = ((ECGenParameterSpec) params).getName();\n-                ecParams = P11ECKeyFactory.getECParameterSpec(name);\n-                if (ecParams == null) {\n+                tmpKeySize = dsaParams.getP().bitLength();\n+                checkKeySize(tmpKeySize, dsaParams);\n+            }\n+            \/\/ XXX sanity check params\n+            case \"EC\" -> {\n+                ECParameterSpec ecParams;\n+                if (params instanceof ECParameterSpec ecParameterSpec) {\n+                    ecParams = P11ECKeyFactory.getECParameterSpec(ecParameterSpec);\n+                    if (ecParams == null) {\n+                        throw new InvalidAlgorithmParameterException\n+                                (\"Unsupported curve: \" + params);\n+                    }\n+                } else if (params instanceof ECGenParameterSpec ecGenParameterSpec) {\n+                    String name = ecGenParameterSpec.getName();\n+                    ecParams = P11ECKeyFactory.getECParameterSpec(name);\n+                    if (ecParams == null) {\n+                        throw new InvalidAlgorithmParameterException\n+                                (\"Unknown curve name: \" + name);\n+                    }\n+                    \/\/ override the supplied params with the derived one\n+                    params = ecParams;\n+                } else {\n@@ -220,1 +225,1 @@\n-                        (\"Unknown curve name: \" + name);\n+                            (\"ECParameterSpec or ECGenParameterSpec required for EC\");\n@@ -222,5 +227,2 @@\n-                \/\/ override the supplied params with the derived one\n-                params = ecParams;\n-            } else {\n-                throw new InvalidAlgorithmParameterException\n-                    (\"ECParameterSpec or ECGenParameterSpec required for EC\");\n+                tmpKeySize = ecParams.getCurve().getField().getFieldSize();\n+                checkKeySize(tmpKeySize, ecParams);\n@@ -228,4 +230,1 @@\n-            tmpKeySize = ecParams.getCurve().getField().getFieldSize();\n-            checkKeySize(tmpKeySize, ecParams);\n-        } else {\n-            throw new ProviderException(\"Unknown algorithm: \" + algorithm);\n+            default -> throw new ProviderException(\"Unknown algorithm: \" + algorithm);\n@@ -340,19 +339,24 @@\n-        if (algorithm.equals(\"RSA\")) {\n-            keyType = CKK_RSA;\n-            publicKeyTemplate = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_MODULUS_BITS, keySize),\n-                new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT, rsaPublicExponent),\n-            };\n-            privateKeyTemplate = new CK_ATTRIBUTE[] {\n-                \/\/ empty\n-            };\n-        } else if (algorithm.equals(\"DSA\")) {\n-            keyType = CKK_DSA;\n-            DSAParameterSpec dsaParams;\n-            if (params == null) {\n-                try {\n-                    dsaParams = ParameterCache.getDSAParameterSpec\n-                                                    (keySize, random);\n-                } catch (GeneralSecurityException e) {\n-                    throw new ProviderException\n-                            (\"Could not generate DSA parameters\", e);\n+        switch (algorithm) {\n+            case \"RSA\" -> {\n+                keyType = CKK_RSA;\n+                publicKeyTemplate = new CK_ATTRIBUTE[]{\n+                        new CK_ATTRIBUTE(CKA_MODULUS_BITS, keySize),\n+                        new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT, rsaPublicExponent),\n+                };\n+                privateKeyTemplate = new CK_ATTRIBUTE[]{\n+                        \/\/ empty\n+                };\n+            }\n+            case \"DSA\" -> {\n+                keyType = CKK_DSA;\n+                DSAParameterSpec dsaParams;\n+                if (params == null) {\n+                    try {\n+                        dsaParams = ParameterCache.getDSAParameterSpec\n+                                (keySize, random);\n+                    } catch (GeneralSecurityException e) {\n+                        throw new ProviderException\n+                                (\"Could not generate DSA parameters\", e);\n+                    }\n+                } else {\n+                    dsaParams = (DSAParameterSpec) params;\n@@ -360,2 +364,8 @@\n-            } else {\n-                dsaParams = (DSAParameterSpec)params;\n+                publicKeyTemplate = new CK_ATTRIBUTE[]{\n+                        new CK_ATTRIBUTE(CKA_PRIME, dsaParams.getP()),\n+                        new CK_ATTRIBUTE(CKA_SUBPRIME, dsaParams.getQ()),\n+                        new CK_ATTRIBUTE(CKA_BASE, dsaParams.getG()),\n+                };\n+                privateKeyTemplate = new CK_ATTRIBUTE[]{\n+                        \/\/ empty\n+                };\n@@ -363,19 +373,16 @@\n-            publicKeyTemplate = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_PRIME, dsaParams.getP()),\n-                new CK_ATTRIBUTE(CKA_SUBPRIME, dsaParams.getQ()),\n-                new CK_ATTRIBUTE(CKA_BASE, dsaParams.getG()),\n-            };\n-            privateKeyTemplate = new CK_ATTRIBUTE[] {\n-                \/\/ empty\n-            };\n-        } else if (algorithm.equals(\"DH\")) {\n-            keyType = CKK_DH;\n-            DHParameterSpec dhParams;\n-            int privateBits;\n-            if (params == null) {\n-                try {\n-                    dhParams = ParameterCache.getDHParameterSpec\n-                                                    (keySize, random);\n-                } catch (GeneralSecurityException e) {\n-                    throw new ProviderException\n-                            (\"Could not generate DH parameters\", e);\n+            case \"DH\" -> {\n+                keyType = CKK_DH;\n+                DHParameterSpec dhParams;\n+                int privateBits;\n+                if (params == null) {\n+                    try {\n+                        dhParams = ParameterCache.getDHParameterSpec\n+                                (keySize, random);\n+                    } catch (GeneralSecurityException e) {\n+                        throw new ProviderException\n+                                (\"Could not generate DH parameters\", e);\n+                    }\n+                    privateBits = 0;\n+                } else {\n+                    dhParams = (DHParameterSpec) params;\n+                    privateBits = dhParams.getL();\n@@ -383,4 +390,11 @@\n-                privateBits = 0;\n-            } else {\n-                dhParams = (DHParameterSpec)params;\n-                privateBits = dhParams.getL();\n+                if (privateBits <= 0) {\n+                    \/\/ XXX find better defaults\n+                    privateBits = (keySize >= 1024) ? 768 : 512;\n+                }\n+                publicKeyTemplate = new CK_ATTRIBUTE[]{\n+                        new CK_ATTRIBUTE(CKA_PRIME, dhParams.getP()),\n+                        new CK_ATTRIBUTE(CKA_BASE, dhParams.getG())\n+                };\n+                privateKeyTemplate = new CK_ATTRIBUTE[]{\n+                        new CK_ATTRIBUTE(CKA_VALUE_BITS, privateBits),\n+                };\n@@ -388,3 +402,10 @@\n-            if (privateBits <= 0) {\n-                \/\/ XXX find better defaults\n-                privateBits = (keySize >= 1024) ? 768 : 512;\n+            case \"EC\" -> {\n+                keyType = CKK_EC;\n+                byte[] encodedParams =\n+                        P11ECKeyFactory.encodeParameters((ECParameterSpec) params);\n+                publicKeyTemplate = new CK_ATTRIBUTE[]{\n+                        new CK_ATTRIBUTE(CKA_EC_PARAMS, encodedParams),\n+                };\n+                privateKeyTemplate = new CK_ATTRIBUTE[]{\n+                        \/\/ empty\n+                };\n@@ -392,19 +413,1 @@\n-            publicKeyTemplate = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_PRIME, dhParams.getP()),\n-                new CK_ATTRIBUTE(CKA_BASE, dhParams.getG())\n-            };\n-            privateKeyTemplate = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_VALUE_BITS, privateBits),\n-            };\n-        } else if (algorithm.equals(\"EC\")) {\n-            keyType = CKK_EC;\n-            byte[] encodedParams =\n-                    P11ECKeyFactory.encodeParameters((ECParameterSpec)params);\n-            publicKeyTemplate = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_EC_PARAMS, encodedParams),\n-            };\n-            privateKeyTemplate = new CK_ATTRIBUTE[] {\n-                \/\/ empty\n-            };\n-        } else {\n-            throw new ProviderException(\"Unknown algorithm: \" + algorithm);\n+            default -> throw new ProviderException(\"Unknown algorithm: \" + algorithm);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyPairGenerator.java","additions":117,"deletions":114,"binary":false,"changes":231,"status":"modified"},{"patch":"@@ -782,1 +782,1 @@\n-            if (mapLabels() == true) {\n+            if (mapLabels()) {\n@@ -864,1 +864,1 @@\n-            if (mapLabels() == true) {\n+            if (mapLabels()) {\n@@ -1033,1 +1033,1 @@\n-            if (useSecmodTrust == false) {\n+            if (!useSecmodTrust) {\n@@ -1046,1 +1046,1 @@\n-            if (cert instanceof X509Certificate == false) {\n+            if (!(cert instanceof X509Certificate xcert)) {\n@@ -1049,1 +1049,0 @@\n-            X509Certificate xcert = (X509Certificate)cert;\n@@ -1125,1 +1124,1 @@\n-            } else if (entry instanceof KeyStore.SecretKeyEntry) {\n+            } else if (entry instanceof SecretKeyEntry ske) {\n@@ -1127,1 +1126,0 @@\n-                KeyStore.SecretKeyEntry ske = (KeyStore.SecretKeyEntry)entry;\n@@ -1218,1 +1216,1 @@\n-            lChain = new ArrayList<X509Certificate>();\n+            lChain = new ArrayList<>();\n@@ -1512,1 +1510,1 @@\n-            if (key.tokenObject == true) {\n+            if (key.tokenObject) {\n@@ -1552,1 +1550,1 @@\n-        ArrayList<CK_ATTRIBUTE> attrList = new ArrayList<CK_ATTRIBUTE>();\n+        ArrayList<CK_ATTRIBUTE> attrList = new ArrayList<>();\n@@ -1676,2 +1674,1 @@\n-        if (key instanceof P11Key) {\n-            P11Key p11Key = (P11Key)key;\n+        if (key instanceof P11Key p11Key) {\n@@ -1694,3 +1691,1 @@\n-        } else if (key instanceof DSAPrivateKey) {\n-\n-            DSAPrivateKey dsaKey = (DSAPrivateKey)key;\n+        } else if (key instanceof DSAPrivateKey dsaKey) {\n@@ -1725,3 +1720,1 @@\n-        } else if (key instanceof DHPrivateKey) {\n-\n-            DHPrivateKey dhKey = (DHPrivateKey)key;\n+        } else if (key instanceof DHPrivateKey dhKey) {\n@@ -1751,3 +1744,1 @@\n-        } else if (key instanceof ECPrivateKey) {\n-\n-            ECPrivateKey ecKey = (ECPrivateKey)key;\n+        } else if (key instanceof ECPrivateKey ecKey) {\n@@ -1782,1 +1773,1 @@\n-        } else if (key instanceof P11Key) {\n+        } else if (key instanceof P11Key p11Key) {\n@@ -1784,1 +1775,0 @@\n-            P11Key p11Key = (P11Key)key;\n@@ -1834,1 +1824,1 @@\n-        if (key instanceof RSAPrivateCrtKey) {\n+        if (key instanceof RSAPrivateCrtKey rsaKey) {\n@@ -1840,2 +1830,0 @@\n-            RSAPrivateCrtKey rsaKey = (RSAPrivateCrtKey)key;\n-\n@@ -1873,2 +1861,0 @@\n-            RSAPrivateKey rsaKey = key;\n-\n@@ -1882,1 +1868,1 @@\n-                                rsaKey.getModulus()),\n+                                key.getModulus()),\n@@ -1884,1 +1870,1 @@\n-                                rsaKey.getPrivateExponent()) };\n+                                key.getPrivateExponent()) };\n@@ -1908,1 +1894,1 @@\n-        if ((id || netscapeDb) == false) {\n+        if (!(id || netscapeDb)) {\n@@ -2013,1 +1999,1 @@\n-                    \/\/ self signed - done\n+                    \/\/ self-signed - done\n@@ -2236,1 +2222,1 @@\n-                ArrayList<THandle> list = new ArrayList<THandle>(h.length);\n+                ArrayList<THandle> list = new ArrayList<>(h.length);\n@@ -2302,1 +2288,1 @@\n-            ArrayList<byte[]> pkeyIDs = new ArrayList<byte[]>();\n+            ArrayList<byte[]> pkeyIDs = new ArrayList<>();\n@@ -2329,1 +2315,1 @@\n-                                new HashMap<String, HashSet<AliasInfo>>();\n+                                new HashMap<>();\n@@ -2402,5 +2388,1 @@\n-                HashSet<AliasInfo> infoSet = certMap.get(cka_label);\n-                if (infoSet == null) {\n-                    infoSet = new HashSet<AliasInfo>(2);\n-                    certMap.put(cka_label, infoSet);\n-                }\n+                HashSet<AliasInfo> infoSet = certMap.computeIfAbsent(cka_label, k -> new HashSet<>(2));\n@@ -2424,1 +2406,1 @@\n-                    new HashMap<String, AliasInfo>();\n+                    new HashMap<>();\n@@ -2480,1 +2462,1 @@\n-        aliasMap = new HashMap<String, AliasInfo>();\n+        aliasMap = new HashMap<>();\n@@ -2483,1 +2465,1 @@\n-        ArrayList<AliasInfo> matchedCerts = new ArrayList<AliasInfo>();\n+        ArrayList<AliasInfo> matchedCerts = new ArrayList<>();\n@@ -2569,1 +2551,1 @@\n-                if (aliasInfo.matched == true) {\n+                if (aliasInfo.matched) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyStore.java","additions":26,"deletions":44,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -348,2 +348,1 @@\n-                case Cipher.ENCRYPT_MODE:\n-                    token.p11.C_EncryptInit(session.id(), mechWithParams,\n+                    case Cipher.ENCRYPT_MODE -> token.p11.C_EncryptInit(session.id(), mechWithParams,\n@@ -351,3 +350,1 @@\n-                break;\n-                case Cipher.DECRYPT_MODE:\n-                    token.p11.C_DecryptInit(session.id(), mechWithParams,\n+                    case Cipher.DECRYPT_MODE -> token.p11.C_DecryptInit(session.id(), mechWithParams,\n@@ -355,1 +352,0 @@\n-                break;\n@@ -389,1 +385,1 @@\n-        return (result > 0 ? result : 0);\n+        return (Math.max(result, 0));\n@@ -747,1 +743,1 @@\n-            case Cipher.PRIVATE_KEY:\n+            case Cipher.PRIVATE_KEY -> {\n@@ -750,2 +746,2 @@\n-                break;\n-            case Cipher.SECRET_KEY:\n+            }\n+            case Cipher.SECRET_KEY -> {\n@@ -754,7 +750,6 @@\n-                break;\n-            case Cipher.PUBLIC_KEY:\n-                throw new UnsupportedOperationException\n-                        (\"cannot unwrap public keys\");\n-            default: \/\/ should never happen\n-                throw new AssertionError();\n-        };\n+            }\n+            case Cipher.PUBLIC_KEY -> throw new UnsupportedOperationException\n+                    (\"cannot unwrap public keys\");\n+            default -> \/\/ should never happen\n+                    throw new AssertionError();\n+        }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyWrapCipher.java","additions":12,"deletions":17,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -88,36 +88,17 @@\n-        switch ((int)mechanism) {\n-        case (int)CKM_MD5_HMAC:\n-            macLength = 16;\n-            break;\n-        case (int)CKM_SHA_1_HMAC:\n-            macLength = 20;\n-            break;\n-        case (int)CKM_SHA224_HMAC:\n-        case (int)CKM_SHA512_224_HMAC:\n-        case (int)CKM_SHA3_224_HMAC:\n-            macLength = 28;\n-            break;\n-        case (int)CKM_SHA256_HMAC:\n-        case (int)CKM_SHA512_256_HMAC:\n-        case (int)CKM_SHA3_256_HMAC:\n-            macLength = 32;\n-            break;\n-        case (int)CKM_SHA384_HMAC:\n-        case (int)CKM_SHA3_384_HMAC:\n-            macLength = 48;\n-            break;\n-        case (int)CKM_SHA512_HMAC:\n-        case (int)CKM_SHA3_512_HMAC:\n-            macLength = 64;\n-            break;\n-        case (int)CKM_SSL3_MD5_MAC:\n-            macLength = 16;\n-            params = Long.valueOf(16);\n-            break;\n-        case (int)CKM_SSL3_SHA1_MAC:\n-            macLength = 20;\n-            params = Long.valueOf(20);\n-            break;\n-        default:\n-            throw new ProviderException(\"Unknown mechanism: \" + mechanism);\n-        }\n+        macLength = switch ((int) mechanism) {\n+            case (int) CKM_MD5_HMAC -> 16;\n+            case (int) CKM_SHA_1_HMAC -> 20;\n+            case (int) CKM_SHA224_HMAC, (int) CKM_SHA512_224_HMAC, (int) CKM_SHA3_224_HMAC -> 28;\n+            case (int) CKM_SHA256_HMAC, (int) CKM_SHA512_256_HMAC, (int) CKM_SHA3_256_HMAC -> 32;\n+            case (int) CKM_SHA384_HMAC, (int) CKM_SHA3_384_HMAC -> 48;\n+            case (int) CKM_SHA512_HMAC, (int) CKM_SHA3_512_HMAC -> 64;\n+            case (int) CKM_SSL3_MD5_MAC -> {\n+                params = Long.valueOf(16);\n+                yield 16;\n+            }\n+            case (int) CKM_SSL3_SHA1_MAC -> {\n+                params = Long.valueOf(20);\n+                yield 20;\n+            }\n+            default -> throw new ProviderException(\"Unknown mechanism: \" + mechanism);\n+        };\n@@ -268,1 +249,1 @@\n-            if (byteBuffer instanceof DirectBuffer == false) {\n+            if (!(byteBuffer instanceof DirectBuffer directBuffer)) {\n@@ -272,1 +253,1 @@\n-            long addr = ((DirectBuffer)byteBuffer).address();\n+            long addr = directBuffer.address();\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Mac.java","additions":19,"deletions":38,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -74,2 +74,1 @@\n-    private static final Hashtable<String, Integer> DIGEST_LENGTHS =\n-        new Hashtable<String, Integer>();\n+    private static final Hashtable<String, Integer> DIGEST_LENGTHS = new Hashtable<>();\n@@ -176,19 +175,12 @@\n-        switch ((int)mechId) {\n-        case (int)CKM_SHA1_RSA_PKCS_PSS:\n-        case (int)CKM_SHA224_RSA_PKCS_PSS:\n-        case (int)CKM_SHA256_RSA_PKCS_PSS:\n-        case (int)CKM_SHA384_RSA_PKCS_PSS:\n-        case (int)CKM_SHA512_RSA_PKCS_PSS:\n-        case (int)CKM_SHA3_224_RSA_PKCS_PSS:\n-        case (int)CKM_SHA3_256_RSA_PKCS_PSS:\n-        case (int)CKM_SHA3_384_RSA_PKCS_PSS:\n-        case (int)CKM_SHA3_512_RSA_PKCS_PSS:\n-            type = T_UPDATE;\n-            this.md = null;\n-            break;\n-        case (int)CKM_RSA_PKCS_PSS:\n-            \/\/ check if the digest algo is supported by underlying PKCS11 lib\n-            if (this.mdAlg != null && token.getMechanismInfo\n-                    (Functions.getHashMechId(this.mdAlg)) == null) {\n-                throw new NoSuchAlgorithmException(\"Unsupported algorithm: \" +\n-                        algorithm);\n+        switch ((int) mechId) {\n+            case (int) CKM_SHA1_RSA_PKCS_PSS,\n+                 (int) CKM_SHA224_RSA_PKCS_PSS,\n+                 (int) CKM_SHA256_RSA_PKCS_PSS,\n+                 (int) CKM_SHA384_RSA_PKCS_PSS,\n+                 (int) CKM_SHA512_RSA_PKCS_PSS,\n+                 (int) CKM_SHA3_224_RSA_PKCS_PSS,\n+                 (int) CKM_SHA3_256_RSA_PKCS_PSS,\n+                 (int) CKM_SHA3_384_RSA_PKCS_PSS,\n+                 (int) CKM_SHA3_512_RSA_PKCS_PSS -> {\n+                type = T_UPDATE;\n+                this.md = null;\n@@ -196,6 +188,12 @@\n-            this.md = (this.mdAlg == null ? null :\n-                    MessageDigest.getInstance(this.mdAlg));\n-            type = T_DIGEST;\n-            break;\n-        default:\n-            throw new ProviderException(\"Unsupported mechanism: \" + mechId);\n+            case (int) CKM_RSA_PKCS_PSS -> {\n+                \/\/ check if the digest algo is supported by underlying PKCS11 lib\n+                if (this.mdAlg != null && token.getMechanismInfo\n+                        (Functions.getHashMechId(this.mdAlg)) == null) {\n+                    throw new NoSuchAlgorithmException(\"Unsupported algorithm: \" +\n+                            algorithm);\n+                }\n+                this.md = (this.mdAlg == null ? null :\n+                        MessageDigest.getInstance(this.mdAlg));\n+                type = T_DIGEST;\n+            }\n+            default -> throw new ProviderException(\"Unsupported mechanism: \" + mechId);\n@@ -238,1 +236,1 @@\n-        if (initialized == false) {\n+        if (!initialized) {\n@@ -416,1 +414,1 @@\n-        if (!(p instanceof PSSParameterSpec)) {\n+        if (!(p instanceof PSSParameterSpec params)) {\n@@ -421,1 +419,0 @@\n-        PSSParameterSpec params = (PSSParameterSpec) p;\n@@ -618,5 +615,24 @@\n-        case T_UPDATE:\n-            if (byteBuffer instanceof DirectBuffer == false) {\n-                \/\/ cannot do better than default impl\n-                super.engineUpdate(byteBuffer);\n-                return;\n+            case T_UPDATE -> {\n+                if (byteBuffer instanceof DirectBuffer == false) {\n+                    \/\/ cannot do better than default impl\n+                    super.engineUpdate(byteBuffer);\n+                    return;\n+                }\n+                long addr = ((DirectBuffer) byteBuffer).address();\n+                int ofs = byteBuffer.position();\n+                try {\n+                    if (mode == M_SIGN) {\n+                        if (DEBUG) System.out.println(this + \": Calling C_SignUpdate\");\n+                        token.p11.C_SignUpdate\n+                                (session.id(), addr + ofs, null, 0, len);\n+                    } else {\n+                        if (DEBUG) System.out.println(this + \": Calling C_VerifyUpdate\");\n+                        token.p11.C_VerifyUpdate\n+                                (session.id(), addr + ofs, null, 0, len);\n+                    }\n+                    bytesProcessed += len;\n+                    byteBuffer.position(ofs + len);\n+                } catch (PKCS11Exception e) {\n+                    reset(false);\n+                    throw new ProviderException(\"Update failed\", e);\n+                }\n@@ -624,11 +640,4 @@\n-            long addr = ((DirectBuffer)byteBuffer).address();\n-            int ofs = byteBuffer.position();\n-            try {\n-                if (mode == M_SIGN) {\n-                    if (DEBUG) System.out.println(this + \": Calling C_SignUpdate\");\n-                    token.p11.C_SignUpdate\n-                        (session.id(), addr + ofs, null, 0, len);\n-                } else {\n-                    if (DEBUG) System.out.println(this + \": Calling C_VerifyUpdate\");\n-                    token.p11.C_VerifyUpdate\n-                        (session.id(), addr + ofs, null, 0, len);\n+            case T_DIGEST -> {\n+                \/\/ should not happen as this should be covered by earlier checks\n+                if (md == null) {\n+                    throw new ProviderException(\"PSS Parameters required\");\n@@ -636,0 +645,1 @@\n+                md.update(byteBuffer);\n@@ -637,4 +647,0 @@\n-                byteBuffer.position(ofs + len);\n-            } catch (PKCS11Exception e) {\n-                reset(false);\n-                throw new ProviderException(\"Update failed\", e);\n@@ -642,5 +648,3 @@\n-            break;\n-        case T_DIGEST:\n-            \/\/ should not happen as this should be covered by earlier checks\n-            if (md == null) {\n-                throw new ProviderException(\"PSS Parameters required\");\n+            default -> {\n+                reset(false);\n+                throw new ProviderException(\"Internal error\");\n@@ -648,6 +652,0 @@\n-            md.update(byteBuffer);\n-            bytesProcessed += len;\n-            break;\n-        default:\n-            reset(false);\n-            throw new ProviderException(\"Internal error\");\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11PSSSignature.java","additions":59,"deletions":61,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-        if (mode.equalsIgnoreCase(\"ECB\") == false) {\n+        if (!mode.equalsIgnoreCase(\"ECB\")) {\n@@ -208,1 +208,1 @@\n-            if (p11Key.isPublic() == false) {\n+            if (!p11Key.isPublic()) {\n@@ -216,1 +216,1 @@\n-            if (p11Key.isPrivate() == false) {\n+            if (!p11Key.isPrivate()) {\n@@ -292,12 +292,7 @@\n-            case MODE_ENCRYPT:\n-                p11.C_Encrypt(sessId, 0, buffer, 0, inLen, 0, buffer, 0, outLen);\n-                break;\n-            case MODE_DECRYPT:\n-                p11.C_Decrypt(sessId, 0, buffer, 0, inLen, 0, buffer, 0, outLen);\n-                break;\n-            case MODE_SIGN:\n-                byte[] tmpBuffer = new byte[maxInputSize];\n-                p11.C_Sign(sessId, tmpBuffer);\n-                break;\n-            case MODE_VERIFY:\n-                p11.C_VerifyRecover(sessId, buffer, 0, inLen, buffer,\n+                case MODE_ENCRYPT -> p11.C_Encrypt(sessId, 0, buffer, 0, inLen, 0, buffer, 0, outLen);\n+                case MODE_DECRYPT -> p11.C_Decrypt(sessId, 0, buffer, 0, inLen, 0, buffer, 0, outLen);\n+                case MODE_SIGN -> {\n+                    byte[] tmpBuffer = new byte[maxInputSize];\n+                    p11.C_Sign(sessId, tmpBuffer);\n+                }\n+                case MODE_VERIFY -> p11.C_VerifyRecover(sessId, buffer, 0, inLen, buffer,\n@@ -305,3 +300,1 @@\n-                break;\n-            default:\n-                throw new ProviderException(\"internal error\");\n+                default -> throw new ProviderException(\"internal error\");\n@@ -335,14 +328,5 @@\n-            case MODE_ENCRYPT:\n-                p11.C_EncryptInit(session.id(), ckMechanism, keyID);\n-                break;\n-            case MODE_DECRYPT:\n-                p11.C_DecryptInit(session.id(), ckMechanism, keyID);\n-                break;\n-            case MODE_SIGN:\n-                p11.C_SignInit(session.id(), ckMechanism, keyID);\n-                break;\n-            case MODE_VERIFY:\n-                p11.C_VerifyRecoverInit(session.id(), ckMechanism, keyID);\n-                break;\n-            default:\n-                throw new AssertionError(\"internal error\");\n+                case MODE_ENCRYPT -> p11.C_EncryptInit(session.id(), ckMechanism, keyID);\n+                case MODE_DECRYPT -> p11.C_DecryptInit(session.id(), ckMechanism, keyID);\n+                case MODE_SIGN -> p11.C_SignInit(session.id(), ckMechanism, keyID);\n+                case MODE_VERIFY -> p11.C_VerifyRecoverInit(session.id(), ckMechanism, keyID);\n+                default -> throw new AssertionError(\"internal error\");\n@@ -386,4 +370,2 @@\n-            int n;\n-            switch (mode) {\n-            case MODE_ENCRYPT:\n-                n = p11.C_Encrypt\n+            return switch (mode) {\n+                case MODE_ENCRYPT -> p11.C_Encrypt\n@@ -391,3 +373,1 @@\n-                break;\n-            case MODE_DECRYPT:\n-                n = p11.C_Decrypt\n+                case MODE_DECRYPT ->  p11.C_Decrypt\n@@ -395,9 +375,11 @@\n-                break;\n-            case MODE_SIGN:\n-                byte[] tmpBuffer = new byte[bufOfs];\n-                System.arraycopy(buffer, 0, tmpBuffer, 0, bufOfs);\n-                tmpBuffer = p11.C_Sign(session.id(), tmpBuffer);\n-                if (tmpBuffer.length > outLen) {\n-                    throw new BadPaddingException(\n-                        \"Output buffer (\" + outLen + \") is too small to \" +\n-                        \"hold the produced data (\" + tmpBuffer.length + \")\");\n+                case MODE_SIGN -> {\n+                    byte[] tmpBuffer = new byte[bufOfs];\n+                    System.arraycopy(buffer, 0, tmpBuffer, 0, bufOfs);\n+                    tmpBuffer = p11.C_Sign(session.id(), tmpBuffer);\n+                    if (tmpBuffer.length > outLen) {\n+                        throw new BadPaddingException(\n+                                \"Output buffer (\" + outLen + \") is too small to \" +\n+                                        \"hold the produced data (\" + tmpBuffer.length + \")\");\n+                    }\n+                    System.arraycopy(tmpBuffer, 0, out, outOfs, tmpBuffer.length);\n+                    yield tmpBuffer.length;\n@@ -405,5 +387,1 @@\n-                System.arraycopy(tmpBuffer, 0, out, outOfs, tmpBuffer.length);\n-                n = tmpBuffer.length;\n-                break;\n-            case MODE_VERIFY:\n-                n = p11.C_VerifyRecover\n+                case MODE_VERIFY -> p11.C_VerifyRecover\n@@ -411,5 +389,2 @@\n-                break;\n-            default:\n-                throw new ProviderException(\"internal error\");\n-            }\n-            return n;\n+                default -> throw new ProviderException(\"internal error\");\n+            };\n@@ -714,10 +689,6 @@\n-        switch (keyType) {\n-        case Cipher.SECRET_KEY:\n-            return constructSecretKey(encoding, keyAlgorithm);\n-        case Cipher.PRIVATE_KEY:\n-            return constructPrivateKey(encoding, keyAlgorithm);\n-        case Cipher.PUBLIC_KEY:\n-            return constructPublicKey(encoding, keyAlgorithm);\n-        default:\n-            throw new InvalidKeyException(\"Unknown keytype \" + keyType);\n-        }\n+        return switch (keyType) {\n+            case Cipher.SECRET_KEY -> constructSecretKey(encoding, keyAlgorithm);\n+            case Cipher.PRIVATE_KEY -> constructPrivateKey(encoding, keyAlgorithm);\n+            case Cipher.PUBLIC_KEY -> constructPublicKey(encoding, keyAlgorithm);\n+            default -> throw new InvalidKeyException(\"Unknown keytype \" + keyType);\n+        };\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11RSACipher.java","additions":39,"deletions":68,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -57,2 +57,1 @@\n-            if (key instanceof RSAPublicKey) {\n-                RSAPublicKey rsaKey = (RSAPublicKey)key;\n+            if (key instanceof RSAPublicKey rsaKey) {\n@@ -77,2 +76,1 @@\n-            if (key instanceof RSAPrivateCrtKey) {\n-                RSAPrivateCrtKey rsaKey = (RSAPrivateCrtKey)key;\n+            if (key instanceof RSAPrivateCrtKey rsaKey) {\n@@ -89,2 +87,1 @@\n-            } else if (key instanceof RSAPrivateKey) {\n-                RSAPrivateKey rsaKey = (RSAPrivateKey)key;\n+            } else if (key instanceof RSAPrivateKey rsaKey) {\n@@ -120,1 +117,1 @@\n-        if (keySpec instanceof RSAPublicKeySpec == false) {\n+        if (!(keySpec instanceof RSAPublicKeySpec)) {\n@@ -291,2 +288,1 @@\n-            if (key instanceof RSAPrivateCrtKey) {\n-                RSAPrivateCrtKey crtKey = (RSAPrivateCrtKey)key;\n+            if (key instanceof RSAPrivateCrtKey crtKey) {\n@@ -310,1 +306,1 @@\n-                if (!(key instanceof RSAPrivateKey)) {\n+                if (!(key instanceof RSAPrivateKey rsaKey)) {\n@@ -318,1 +314,0 @@\n-                RSAPrivateKey rsaKey = (RSAPrivateKey) key;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11RSAKeyFactory.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -139,1 +139,1 @@\n-        if (key instanceof SecretKey == false) {\n+        if (!(key instanceof SecretKey)) {\n@@ -158,2 +158,1 @@\n-        if (key instanceof P11Key) {\n-            P11Key p11Key = (P11Key)key;\n+        if (key instanceof P11Key p11Key) {\n@@ -188,1 +187,1 @@\n-        if (\"RAW\".equalsIgnoreCase(key.getFormat()) == false) {\n+        if (!\"RAW\".equalsIgnoreCase(key.getFormat())) {\n@@ -211,2 +210,2 @@\n-            switch ((int)keyType) {\n-                case (int)CKK_DES:\n+            switch ((int) keyType) {\n+                case (int) CKK_DES -> {\n@@ -214,1 +213,1 @@\n-                        P11KeyGenerator.checkKeySize(CKM_DES_KEY_GEN, n, token);\n+                            P11KeyGenerator.checkKeySize(CKM_DES_KEY_GEN, n, token);\n@@ -216,2 +215,2 @@\n-                    break;\n-                case (int)CKK_DES3:\n+                }\n+                case (int) CKK_DES3 -> {\n@@ -219,1 +218,1 @@\n-                        P11KeyGenerator.checkKeySize(CKM_DES3_KEY_GEN, n, token);\n+                            P11KeyGenerator.checkKeySize(CKM_DES3_KEY_GEN, n, token);\n@@ -228,3 +227,2 @@\n-                    break;\n-                case (int)CKK_AES:\n-                    keyLength =\n+                }\n+                case (int) CKK_AES -> keyLength =\n@@ -232,3 +230,1 @@\n-                    break;\n-                case (int)CKK_RC4:\n-                    keyLength =\n+                case (int) CKK_RC4 -> keyLength =\n@@ -236,3 +232,1 @@\n-                    break;\n-                case (int)CKK_BLOWFISH:\n-                    keyLength =\n+                case (int) CKK_BLOWFISH -> keyLength =\n@@ -240,4 +234,2 @@\n-                        token);\n-                    break;\n-                case (int)CKK_CHACHA20:\n-                    keyLength = P11KeyGenerator.checkKeySize(\n+                                token);\n+                case (int) CKK_CHACHA20 -> keyLength = P11KeyGenerator.checkKeySize(\n@@ -245,9 +237,3 @@\n-                    break;\n-                case (int)CKK_GENERIC_SECRET:\n-                case (int)PCKK_TLSPREMASTER:\n-                case (int)PCKK_TLSRSAPREMASTER:\n-                case (int)PCKK_TLSMASTER:\n-                    keyType = CKK_GENERIC_SECRET;\n-                    break;\n-                case (int)PCKK_SSLMAC:\n-                case (int)PCKK_HMAC:\n+                case (int) CKK_GENERIC_SECRET, (int) PCKK_TLSPREMASTER, (int) PCKK_TLSRSAPREMASTER, (int) PCKK_TLSMASTER ->\n+                        keyType = CKK_GENERIC_SECRET;\n+                case (int) PCKK_SSLMAC, (int) PCKK_HMAC -> {\n@@ -259,4 +245,3 @@\n-                    break;\n-                default:\n-                    throw new InvalidKeyException(\"Unknown algorithm \" +\n-                            algorithm);\n+                }\n+                default -> throw new InvalidKeyException(\"Unknown algorithm \" +\n+                        algorithm);\n@@ -331,1 +316,1 @@\n-            if (\"RAW\".equalsIgnoreCase(key.getFormat()) == false) {\n+            if (!\"RAW\".equalsIgnoreCase(key.getFormat())) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11SecretKeyFactory.java","additions":22,"deletions":37,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    @Serial\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11SecureRandom.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -175,54 +175,15 @@\n-        switch ((int)mechanism) {\n-        case (int)CKM_MD2_RSA_PKCS:\n-        case (int)CKM_MD5_RSA_PKCS:\n-        case (int)CKM_SHA1_RSA_PKCS:\n-        case (int)CKM_SHA224_RSA_PKCS:\n-        case (int)CKM_SHA256_RSA_PKCS:\n-        case (int)CKM_SHA384_RSA_PKCS:\n-        case (int)CKM_SHA512_RSA_PKCS:\n-        case (int)CKM_SHA3_224_RSA_PKCS:\n-        case (int)CKM_SHA3_256_RSA_PKCS:\n-        case (int)CKM_SHA3_384_RSA_PKCS:\n-        case (int)CKM_SHA3_512_RSA_PKCS:\n-            keyAlgorithm = \"RSA\";\n-            type = T_UPDATE;\n-            buffer = new byte[1];\n-            break;\n-        case (int)CKM_DSA_SHA1:\n-        case (int)CKM_DSA_SHA224:\n-        case (int)CKM_DSA_SHA256:\n-        case (int)CKM_DSA_SHA384:\n-        case (int)CKM_DSA_SHA512:\n-        case (int)CKM_DSA_SHA3_224:\n-        case (int)CKM_DSA_SHA3_256:\n-        case (int)CKM_DSA_SHA3_384:\n-        case (int)CKM_DSA_SHA3_512:\n-            keyAlgorithm = \"DSA\";\n-            type = T_UPDATE;\n-            buffer = new byte[1];\n-            break;\n-        case (int)CKM_ECDSA_SHA1:\n-        case (int)CKM_ECDSA_SHA224:\n-        case (int)CKM_ECDSA_SHA256:\n-        case (int)CKM_ECDSA_SHA384:\n-        case (int)CKM_ECDSA_SHA512:\n-        case (int)CKM_ECDSA_SHA3_224:\n-        case (int)CKM_ECDSA_SHA3_256:\n-        case (int)CKM_ECDSA_SHA3_384:\n-        case (int)CKM_ECDSA_SHA3_512:\n-            keyAlgorithm = \"EC\";\n-            type = T_UPDATE;\n-            buffer = new byte[1];\n-            break;\n-        case (int)CKM_DSA:\n-            keyAlgorithm = \"DSA\";\n-            if (algorithm.equals(\"DSA\") ||\n-                algorithm.equals(\"DSAinP1363Format\")) {\n-                type = T_DIGEST;\n-                md = MessageDigest.getInstance(\"SHA-1\");\n-            } else if (algorithm.equals(\"RawDSA\") ||\n-                       algorithm.equals(\"RawDSAinP1363Format\")) {\n-                type = T_RAW;\n-                buffer = new byte[20];\n-            } else {\n-                throw new ProviderException(algorithm);\n+        switch ((int) mechanism) {\n+            case (int) CKM_MD2_RSA_PKCS,\n+                    (int) CKM_MD5_RSA_PKCS,\n+                    (int) CKM_SHA1_RSA_PKCS,\n+                    (int) CKM_SHA224_RSA_PKCS,\n+                    (int) CKM_SHA256_RSA_PKCS,\n+                    (int) CKM_SHA384_RSA_PKCS,\n+                    (int) CKM_SHA512_RSA_PKCS,\n+                    (int) CKM_SHA3_224_RSA_PKCS,\n+                    (int) CKM_SHA3_256_RSA_PKCS,\n+                    (int) CKM_SHA3_384_RSA_PKCS,\n+                    (int) CKM_SHA3_512_RSA_PKCS -> {\n+                keyAlgorithm = \"RSA\";\n+                type = T_UPDATE;\n+                buffer = new byte[1];\n@@ -230,8 +191,54 @@\n-            break;\n-        case (int)CKM_ECDSA:\n-            keyAlgorithm = \"EC\";\n-            if (algorithm.equals(\"NONEwithECDSA\") ||\n-                algorithm.equals(\"NONEwithECDSAinP1363Format\")) {\n-                type = T_RAW;\n-                buffer = new byte[RAW_ECDSA_MAX];\n-            } else {\n+            case (int) CKM_DSA_SHA1,\n+                    (int) CKM_DSA_SHA224,\n+                    (int) CKM_DSA_SHA256,\n+                    (int) CKM_DSA_SHA384,\n+                    (int) CKM_DSA_SHA512,\n+                    (int) CKM_DSA_SHA3_224,\n+                    (int) CKM_DSA_SHA3_256,\n+                    (int) CKM_DSA_SHA3_384,\n+                    (int) CKM_DSA_SHA3_512 -> {\n+                keyAlgorithm = \"DSA\";\n+                type = T_UPDATE;\n+                buffer = new byte[1];\n+            }\n+            case (int) CKM_ECDSA_SHA1,\n+                    (int) CKM_ECDSA_SHA224,\n+                    (int) CKM_ECDSA_SHA256,\n+                    (int) CKM_ECDSA_SHA384,\n+                    (int) CKM_ECDSA_SHA512,\n+                    (int) CKM_ECDSA_SHA3_224,\n+                    (int) CKM_ECDSA_SHA3_256,\n+                    (int) CKM_ECDSA_SHA3_384,\n+                    (int) CKM_ECDSA_SHA3_512 -> {\n+                keyAlgorithm = \"EC\";\n+                type = T_UPDATE;\n+                buffer = new byte[1];\n+            }\n+            case (int) CKM_DSA -> {\n+                keyAlgorithm = \"DSA\";\n+                if (algorithm.equals(\"DSA\") ||\n+                        algorithm.equals(\"DSAinP1363Format\")) {\n+                    type = T_DIGEST;\n+                    md = MessageDigest.getInstance(\"SHA-1\");\n+                } else if (algorithm.equals(\"RawDSA\") ||\n+                        algorithm.equals(\"RawDSAinP1363Format\")) {\n+                    type = T_RAW;\n+                    buffer = new byte[20];\n+                } else {\n+                    throw new ProviderException(algorithm);\n+                }\n+            }\n+            case (int) CKM_ECDSA -> {\n+                keyAlgorithm = \"EC\";\n+                if (algorithm.equals(\"NONEwithECDSA\") ||\n+                        algorithm.equals(\"NONEwithECDSAinP1363Format\")) {\n+                    type = T_RAW;\n+                    buffer = new byte[RAW_ECDSA_MAX];\n+                } else {\n+                    type = T_DIGEST;\n+                    md = MessageDigest.getInstance\n+                            (getDigestEnum(algorithm).stdName());\n+                }\n+            }\n+            case (int) CKM_RSA_PKCS, (int) CKM_RSA_X_509 -> {\n+                keyAlgorithm = \"RSA\";\n@@ -239,2 +246,3 @@\n-                md = MessageDigest.getInstance\n-                        (getDigestEnum(algorithm).stdName());\n+                KnownOIDs digestAlg = getDigestEnum(algorithm);\n+                md = MessageDigest.getInstance(digestAlg.stdName());\n+                digestOID = ObjectIdentifier.of(digestAlg);\n@@ -242,11 +250,1 @@\n-            break;\n-        case (int)CKM_RSA_PKCS:\n-        case (int)CKM_RSA_X_509:\n-            keyAlgorithm = \"RSA\";\n-            type = T_DIGEST;\n-            KnownOIDs digestAlg = getDigestEnum(algorithm);\n-            md = MessageDigest.getInstance(digestAlg.stdName());\n-            digestOID = ObjectIdentifier.of(digestAlg);\n-            break;\n-        default:\n-            throw new ProviderException(\"Unknown mechanism: \" + mechanism);\n+            default -> throw new ProviderException(\"Unknown mechanism: \" + mechanism);\n@@ -411,2 +409,2 @@\n-        if (key instanceof P11Key) {\n-            keySize = ((P11Key) key).length();\n+        if (key instanceof P11Key keyP11) {\n+            keySize = keyP11.length();\n@@ -415,9 +413,6 @@\n-                if (keyAlgo.equals(\"RSA\")) {\n-                    keySize = ((RSAKey) key).getModulus().bitLength();\n-                } else if (keyAlgo.equals(\"DSA\")) {\n-                    keySize = ((DSAKey) key).getParams().getP().bitLength();\n-                } else if (keyAlgo.equals(\"EC\")) {\n-                    keySize = ((ECKey) key).getParams().getCurve().getField().getFieldSize();\n-                } else {\n-                    throw new ProviderException(\"Error: unsupported algo \" + keyAlgo);\n-                }\n+                keySize = switch (keyAlgo) {\n+                    case \"RSA\" -> ((RSAKey) key).getModulus().bitLength();\n+                    case \"DSA\" -> ((DSAKey) key).getParams().getP().bitLength();\n+                    case \"EC\" -> ((ECKey) key).getParams().getCurve().getField().getFieldSize();\n+                    default -> throw new ProviderException(\"Error: unsupported algo \" + keyAlgo);\n+                };\n@@ -509,12 +504,3 @@\n-        case T_UPDATE:\n-            buffer[0] = b;\n-            engineUpdate(buffer, 0, 1);\n-            break;\n-        case T_DIGEST:\n-            md.update(b);\n-            bytesProcessed++;\n-            break;\n-        case T_RAW:\n-            if (bytesProcessed >= buffer.length) {\n-                bytesProcessed = buffer.length + 1;\n-                return;\n+            case T_UPDATE -> {\n+                buffer[0] = b;\n+                engineUpdate(buffer, 0, 1);\n@@ -522,4 +508,12 @@\n-            buffer[bytesProcessed++] = b;\n-            break;\n-        default:\n-            throw new ProviderException(\"Internal error\");\n+            case T_DIGEST -> {\n+                md.update(b);\n+                bytesProcessed++;\n+            }\n+            case T_RAW -> {\n+                if (bytesProcessed >= buffer.length) {\n+                    bytesProcessed = buffer.length + 1;\n+                    return;\n+                }\n+                buffer[bytesProcessed++] = b;\n+            }\n+            default -> throw new ProviderException(\"Internal error\");\n@@ -583,5 +577,22 @@\n-        case T_UPDATE:\n-            if (byteBuffer instanceof DirectBuffer == false) {\n-                \/\/ cannot do better than default impl\n-                super.engineUpdate(byteBuffer);\n-                return;\n+            case T_UPDATE -> {\n+                if (!(byteBuffer instanceof DirectBuffer)) {\n+                    \/\/ cannot do better than default impl\n+                    super.engineUpdate(byteBuffer);\n+                    return;\n+                }\n+                long addr = ((DirectBuffer) byteBuffer).address();\n+                int ofs = byteBuffer.position();\n+                try {\n+                    if (mode == M_SIGN) {\n+                        token.p11.C_SignUpdate\n+                                (session.id(), addr + ofs, null, 0, len);\n+                    } else {\n+                        token.p11.C_VerifyUpdate\n+                                (session.id(), addr + ofs, null, 0, len);\n+                    }\n+                    bytesProcessed += len;\n+                    byteBuffer.position(ofs + len);\n+                } catch (PKCS11Exception e) {\n+                    reset(false);\n+                    throw new ProviderException(\"Update failed\", e);\n+                }\n@@ -589,9 +600,8 @@\n-            long addr = ((DirectBuffer)byteBuffer).address();\n-            int ofs = byteBuffer.position();\n-            try {\n-                if (mode == M_SIGN) {\n-                    token.p11.C_SignUpdate\n-                        (session.id(), addr + ofs, null, 0, len);\n-                } else {\n-                    token.p11.C_VerifyUpdate\n-                        (session.id(), addr + ofs, null, 0, len);\n+            case T_DIGEST -> {\n+                md.update(byteBuffer);\n+                bytesProcessed += len;\n+            }\n+            case T_RAW -> {\n+                if (bytesProcessed + len > buffer.length) {\n+                    bytesProcessed = buffer.length + 1;\n+                    return;\n@@ -599,0 +609,1 @@\n+                byteBuffer.get(buffer, bytesProcessed, len);\n@@ -600,4 +611,0 @@\n-                byteBuffer.position(ofs + len);\n-            } catch (PKCS11Exception e) {\n-                reset(false);\n-                throw new ProviderException(\"Update failed\", e);\n@@ -605,9 +612,3 @@\n-            break;\n-        case T_DIGEST:\n-            md.update(byteBuffer);\n-            bytesProcessed += len;\n-            break;\n-        case T_RAW:\n-            if (bytesProcessed + len > buffer.length) {\n-                bytesProcessed = buffer.length + 1;\n-                return;\n+            default -> {\n+                reset(false);\n+                throw new ProviderException(\"Internal error\");\n@@ -615,6 +616,0 @@\n-            byteBuffer.get(buffer, bytesProcessed, len);\n-            bytesProcessed += len;\n-            break;\n-        default:\n-            reset(false);\n-            throw new ProviderException(\"Internal error\");\n@@ -654,1 +649,1 @@\n-                if (keyAlgorithm.equals(\"RSA\") == false) {\n+                if (!keyAlgorithm.equals(\"RSA\")) {\n@@ -727,1 +722,1 @@\n-                if (keyAlgorithm.equals(\"RSA\") == false) {\n+                if (!keyAlgorithm.equals(\"RSA\")) {\n@@ -768,5 +763,1 @@\n-        try {\n-            return RSAUtil.encodeSignature(digestOID, digest);\n-        } catch (IOException e) {\n-            throw new SignatureException(\"Invalid encoding\", e);\n-        }\n+        return RSAUtil.encodeSignature(digestOID, digest);\n@@ -805,10 +796,6 @@\n-        try {\n-            DerOutputStream outseq = new DerOutputStream(100);\n-            outseq.putInteger(r);\n-            outseq.putInteger(s);\n-            DerValue result = new DerValue(DerValue.tag_Sequence,\n-                                           outseq.toByteArray());\n-            return result.toByteArray();\n-        } catch (IOException e) {\n-            throw new RuntimeException(\"Internal error\", e);\n-        }\n+        DerOutputStream outseq = new DerOutputStream(100);\n+        outseq.putInteger(r);\n+        outseq.putInteger(s);\n+        DerValue result = new DerValue(DerValue.tag_Sequence,\n+                outseq.toByteArray());\n+        return result.toByteArray();\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Signature.java","additions":139,"deletions":152,"binary":false,"changes":291,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-        if (params instanceof TlsMasterSecretParameterSpec == false) {\n+        if (!(params instanceof TlsMasterSecretParameterSpec)) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11TlsMasterSecretGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-        if (params instanceof TlsPrfParameterSpec == false) {\n+        if (!(params instanceof TlsPrfParameterSpec)) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11TlsPrfGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-        if (!(params instanceof TlsRsaPremasterSecretParameterSpec)) {\n+        if (!(params instanceof TlsRsaPremasterSecretParameterSpec spec)) {\n@@ -90,2 +90,0 @@\n-        TlsRsaPremasterSecretParameterSpec spec =\n-            (TlsRsaPremasterSecretParameterSpec) params;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11TlsRsaPremasterSecretGenerator.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-        if (isLoaded() == false) {\n+        if (!isLoaded()) {\n@@ -139,1 +139,1 @@\n-        if (supported == false) {\n+        if (!supported) {\n@@ -197,1 +197,1 @@\n-            if (base.isDirectory() == false) {\n+            if (!base.isDirectory()) {\n@@ -201,1 +201,1 @@\n-            if (platformFile.isFile() == false) {\n+            if (!platformFile.isFile()) {\n@@ -217,1 +217,1 @@\n-            if (configBase.isDirectory() == false ) {\n+            if (!configBase.isDirectory()) {\n@@ -222,1 +222,1 @@\n-                if (secmodFile.isFile() == false) {\n+                if (!secmodFile.isFile()) {\n@@ -232,1 +232,1 @@\n-        if (supported == false) {\n+        if (!supported) {\n@@ -242,1 +242,1 @@\n-        if (initok == false) {\n+        if (!initok) {\n@@ -258,1 +258,1 @@\n-            if (isInitialized() == false) {\n+            if (!isInitialized()) {\n@@ -356,29 +356,34 @@\n-    static final String TEMPLATE_EXTERNAL =\n-        \"library = %s\\n\"\n-        + \"name = \\\"%s\\\"\\n\"\n-        + \"slotListIndex = %d\\n\";\n-\n-    static final String TEMPLATE_TRUSTANCHOR =\n-        \"library = %s\\n\"\n-        + \"name = \\\"NSS Trust Anchors\\\"\\n\"\n-        + \"slotListIndex = 0\\n\"\n-        + \"enabledMechanisms = { KeyStore }\\n\"\n-        + \"nssUseSecmodTrust = true\\n\";\n-\n-    static final String TEMPLATE_CRYPTO =\n-        \"library = %s\\n\"\n-        + \"name = \\\"NSS SoftToken Crypto\\\"\\n\"\n-        + \"slotListIndex = 0\\n\"\n-        + \"disabledMechanisms = { KeyStore }\\n\";\n-\n-    static final String TEMPLATE_KEYSTORE =\n-        \"library = %s\\n\"\n-        + \"name = \\\"NSS SoftToken KeyStore\\\"\\n\"\n-        + \"slotListIndex = 1\\n\"\n-        + \"nssUseSecmodTrust = true\\n\";\n-\n-    static final String TEMPLATE_FIPS =\n-        \"library = %s\\n\"\n-        + \"name = \\\"NSS FIPS SoftToken\\\"\\n\"\n-        + \"slotListIndex = 0\\n\"\n-        + \"nssUseSecmodTrust = true\\n\";\n+    static final String TEMPLATE_EXTERNAL = \"\"\"\n+                    library = %s\n+                    name = \"%s\"\n+                    slotListIndex = %d\n+                    \"\"\";\n+\n+    static final String TEMPLATE_TRUSTANCHOR = \"\"\"\n+                    library = %s\n+                    name = \"NSS Trust Anchors\"\n+                    slotListIndex = 0\n+                    enabledMechanisms = { KeyStore }\n+                    nssUseSecmodTrust = true\n+                    \"\"\";\n+\n+    static final String TEMPLATE_CRYPTO = \"\"\"\n+                    library = %s\n+                    name = \"NSS SoftToken Crypto\"\n+                    slotListIndex = 0\n+                    disabledMechanisms = { KeyStore }\n+                    \"\"\";\n+\n+    static final String TEMPLATE_KEYSTORE = \"\"\"\n+                    library = %s\n+                    name = \"NSS SoftToken KeyStore\"\n+                    slotListIndex = 1\n+                    nssUseSecmodTrust = true\n+                    \"\"\";\n+\n+    static final String TEMPLATE_FIPS = \"\"\"\n+                    library = %s\n+                    name = \"NSS FIPS SoftToken\"\n+                    slotListIndex = 0\n+                    nssUseSecmodTrust = true\n+                    \"\"\";\n@@ -445,20 +450,7 @@\n-            switch (type) {\n-            case EXTERNAL:\n-                config = String.format(TEMPLATE_EXTERNAL, libraryName,\n-                                            commonName + \" \" + slot, slot);\n-                break;\n-            case CRYPTO:\n-                config = String.format(TEMPLATE_CRYPTO, libraryName);\n-                break;\n-            case KEYSTORE:\n-                config = String.format(TEMPLATE_KEYSTORE, libraryName);\n-                break;\n-            case FIPS:\n-                config = String.format(TEMPLATE_FIPS, libraryName);\n-                break;\n-            case TRUSTANCHOR:\n-                config = String.format(TEMPLATE_TRUSTANCHOR, libraryName);\n-                break;\n-            default:\n-                throw new RuntimeException(\"Unknown module type: \" + type);\n-            }\n+            config = switch (type) {\n+                case EXTERNAL -> String.format(TEMPLATE_EXTERNAL, libraryName, commonName + \" \" + slot, slot);\n+                case CRYPTO -> String.format(TEMPLATE_CRYPTO, libraryName);\n+                case KEYSTORE -> String.format(TEMPLATE_KEYSTORE, libraryName);\n+                case FIPS -> String.format(TEMPLATE_FIPS, libraryName);\n+                case TRUSTANCHOR -> String.format(TEMPLATE_TRUSTANCHOR, libraryName);\n+            };\n@@ -548,1 +540,1 @@\n-                if (attr.isTrusted(TrustType.ALL) == false) {\n+                if (!attr.isTrusted(TrustType.ALL)) {\n@@ -749,1 +741,1 @@\n-            if (o instanceof Bytes == false) {\n+            if (!(o instanceof Bytes other)) {\n@@ -752,1 +744,0 @@\n-            Bytes other = (Bytes)o;\n@@ -759,1 +750,1 @@\n-        Map<Bytes,TrustAttributes> trustMap = new HashMap<Bytes,TrustAttributes>();\n+        Map<Bytes,TrustAttributes> trustMap = new HashMap<>();\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Secmod.java","additions":53,"deletions":62,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-        if (token.isPresent(this.id) == false) {\n+        if (!token.isPresent(this.id)) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Session.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-        if ((session == null) || (token.isValid() == false)) {\n+        if ((session == null) || (!token.isValid())) {\n@@ -179,1 +179,1 @@\n-        if ((session == null) || (token.isValid() == false)) {\n+        if ((session == null) || (!token.isValid())) {\n@@ -196,1 +196,1 @@\n-        if (token.isValid() == false) {\n+        if (!token.isValid()) {\n@@ -205,1 +205,1 @@\n-        if (present == false) {\n+        if (!present) {\n@@ -212,1 +212,1 @@\n-        \/\/ higher. Therefore releaseSession method, which performs additional\n+        \/\/ higher. Therefore, releaseSession method, which performs additional\n@@ -258,1 +258,1 @@\n-                pool = new LinkedBlockingQueue<Session>();\n+                pool = new LinkedBlockingQueue<>();\n@@ -260,1 +260,1 @@\n-                pool = new LinkedBlockingQueue<Session>(SESSION_MAX);\n+                pool = new LinkedBlockingQueue<>(SESSION_MAX);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SessionManager.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+    @Serial\n@@ -191,1 +192,1 @@\n-                                (s.equals(nssSecmodDirectory) == false)) {\n+                                (!s.equals(nssSecmodDirectory))) {\n@@ -201,1 +202,1 @@\n-                                (s.equals(nssLibraryDirectory) == false)) {\n+                                (!s.equals(nssLibraryDirectory))) {\n@@ -304,2 +305,2 @@\n-        if (libraryFile.getName().equals(library) == false) {\n-            if (new File(library).isFile() == false) {\n+        if (!libraryFile.getName().equals(library)) {\n+            if (!new File(library).isFile()) {\n@@ -334,1 +335,1 @@\n-                if (config.getAllowSingleThreadedModules() == false) {\n+                if (!config.getAllowSingleThreadedModules()) {\n@@ -482,5 +483,1 @@\n-            List<Descriptor> list = descriptors.get(key);\n-            if (list == null) {\n-                list = new ArrayList<Descriptor>();\n-                descriptors.put(key, list);\n-            }\n+            List<Descriptor> list = descriptors.computeIfAbsent(key, k -> new ArrayList<>());\n@@ -956,1 +953,1 @@\n-                if (enabled == false) {\n+                if (!enabled) {\n@@ -1253,1 +1250,1 @@\n-            if (token.isValid() == false) {\n+            if (!token.isValid()) {\n@@ -1275,2 +1272,2 @@\n-                } else if (algorithm.indexOf(\"\/KW\/\") != -1 ||\n-                        algorithm.indexOf(\"\/KWP\/\") != -1) {\n+                } else if (algorithm.contains(\"\/KW\/\") ||\n+                        algorithm.contains(\"\/KWP\/\")) {\n@@ -1282,1 +1279,1 @@\n-                if (algorithm.indexOf(\"RSASSA-PSS\") != -1) {\n+                if (algorithm.contains(\"RSASSA-PSS\")) {\n@@ -1341,1 +1338,1 @@\n-            if ((param == null) || (token.isValid() == false)) {\n+            if ((param == null) || (!token.isValid())) {\n@@ -1344,1 +1341,1 @@\n-            if (param instanceof Key == false) {\n+            if (!(param instanceof Key key)) {\n@@ -1349,1 +1346,0 @@\n-            Key key = (Key)param;\n@@ -1353,2 +1349,2 @@\n-                    || (type == SIG) && (algorithm.indexOf(\"RSA\") != -1)) {\n-                if (keyAlgorithm.equals(\"RSA\") == false) {\n+                    || (type == SIG) && (algorithm.contains(\"RSA\"))) {\n+                if (!keyAlgorithm.equals(\"RSA\")) {\n@@ -1364,1 +1360,1 @@\n-                if (keyAlgorithm.equals(\"EC\") == false) {\n+                if (!keyAlgorithm.equals(\"EC\")) {\n@@ -1374,1 +1370,1 @@\n-                if (keyAlgorithm.equals(\"DSA\") == false) {\n+                if (!keyAlgorithm.equals(\"DSA\")) {\n@@ -1388,1 +1384,1 @@\n-                if (keyAlgorithm.equals(\"DH\") == false) {\n+                if (!keyAlgorithm.equals(\"DH\")) {\n@@ -1579,1 +1575,1 @@\n-        if (hasValidToken() == false) {\n+        if (!hasValidToken()) {\n@@ -1777,1 +1773,1 @@\n-            if ((p == null) || (p.config.getFileName().equals(configName) == false)) {\n+            if ((p == null) || (!p.config.getFileName().equals(configName))) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":21,"deletions":25,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -88,2 +88,2 @@\n-        primitiveTemplates = new ArrayList<KeyAndTemplate>();\n-        compositeTemplates = new ConcurrentHashMap<TemplateKey,Template>();\n+        primitiveTemplates = new ArrayList<>();\n+        compositeTemplates = new ConcurrentHashMap<>();\n@@ -154,1 +154,1 @@\n-            if (obj instanceof TemplateKey == false) {\n+            if (!(obj instanceof TemplateKey other)) {\n@@ -157,1 +157,0 @@\n-            TemplateKey other = (TemplateKey)obj;\n@@ -215,1 +214,1 @@\n-            List<CK_ATTRIBUTE> attrs = new ArrayList<CK_ATTRIBUTE>();\n+            List<CK_ATTRIBUTE> attrs = new ArrayList<>();\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/TemplateManager.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+    @Serial\n@@ -56,1 +57,1 @@\n-    \/\/ that is done in SunPKCS11. Currently 50 ms.\n+    \/\/ that is done in SunPKCS11. Currently, 50 ms.\n@@ -170,2 +171,1 @@\n-        mechInfoMap =\n-            new ConcurrentHashMap<Long, CK_MECHANISM_INFO>(10);\n+        mechInfoMap = new ConcurrentHashMap<>(10);\n@@ -244,1 +244,1 @@\n-        if (isLoggedIn(session) == false) {\n+        if (!isLoggedIn(session)) {\n@@ -252,1 +252,1 @@\n-        if (removable == false) {\n+        if (!removable) {\n@@ -259,1 +259,1 @@\n-        if (isValid() == false) {\n+        if (!isValid()) {\n@@ -267,1 +267,1 @@\n-        if (removable == false) {\n+        if (!removable) {\n@@ -270,1 +270,1 @@\n-        if (valid == false) {\n+        if (!valid) {\n@@ -295,1 +295,1 @@\n-                    if (ok == false) {\n+                    if (!ok) {\n@@ -420,1 +420,1 @@\n-            serializedTokens.add(new WeakReference<Token>(this));\n+            serializedTokens.add(new WeakReference<>(this));\n@@ -429,2 +429,1 @@\n-    private static final List<Reference<Token>> serializedTokens =\n-        new ArrayList<Reference<Token>>();\n+    private static final List<Reference<Token>> serializedTokens = new ArrayList<>();\n@@ -433,1 +432,1 @@\n-        if (isValid() == false) {\n+        if (!isValid()) {\n@@ -444,0 +443,1 @@\n+        @Serial\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Token.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.io.Serial;\n@@ -66,0 +67,1 @@\n+    @Serial\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/PKCS11Exception.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,0 +51,2 @@\n+import java.io.Serial;\n+\n@@ -60,0 +62,1 @@\n+    @Serial\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/PKCS11RuntimeException.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -296,1 +296,0 @@\n-        p.getX().setReduced();\n@@ -369,1 +368,0 @@\n-        p.getY().setReduced();\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECOperations.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,15 +101,10 @@\n-        (AlgorithmId.EC_oid, ECParameters.getAlgorithmParameters(params));\n-        try {\n-            DerOutputStream out = new DerOutputStream();\n-            out.putInteger(1); \/\/ version 1\n-            byte[] privBytes = s.clone();\n-            ArrayUtil.reverse(privBytes);\n-            out.putOctetString(privBytes);\n-            Arrays.fill(privBytes, (byte)0);\n-            DerValue val = DerValue.wrap(DerValue.tag_Sequence, out);\n-            key = val.toByteArray();\n-            val.clear();\n-        } catch (IOException exc) {\n-            \/\/ should never occur\n-            throw new InvalidKeyException(exc);\n-        }\n+                (AlgorithmId.EC_oid, ECParameters.getAlgorithmParameters(params));\n+        DerOutputStream out = new DerOutputStream();\n+        out.putInteger(1); \/\/ version 1\n+        byte[] privBytes = s.clone();\n+        ArrayUtil.reverse(privBytes);\n+        out.putOctetString(privBytes);\n+        Arrays.fill(privBytes, (byte) 0);\n+        DerValue val = DerValue.wrap(DerValue.tag_Sequence, out);\n+        key = val.toByteArray();\n+        val.clear();\n@@ -121,21 +116,17 @@\n-        try {\n-            byte[] sArr = s.toByteArray();\n-            \/\/ convert to fixed-length array\n-            int numOctets = (params.getOrder().bitLength() + 7) \/ 8;\n-            byte[] sOctets = new byte[numOctets];\n-            int inPos = Math.max(sArr.length - sOctets.length, 0);\n-            int outPos = Math.max(sOctets.length - sArr.length, 0);\n-            int length = Math.min(sArr.length, sOctets.length);\n-            System.arraycopy(sArr, inPos, sOctets, outPos, length);\n-            Arrays.fill(sArr, (byte)0);\n-\n-            DerOutputStream out = new DerOutputStream();\n-            out.putInteger(1); \/\/ version 1\n-            out.putOctetString(sOctets);\n-            Arrays.fill(sOctets, (byte)0);\n-            DerValue val = DerValue.wrap(DerValue.tag_Sequence, out);\n-            key = val.toByteArray();\n-            val.clear();\n-        } catch (IOException exc) {\n-            throw new AssertionError(\"Should not happen\", exc);\n-        }\n+        byte[] sArr = s.toByteArray();\n+        \/\/ convert to fixed-length array\n+        int numOctets = (params.getOrder().bitLength() + 7) \/ 8;\n+        byte[] sOctets = new byte[numOctets];\n+        int inPos = Math.max(sArr.length - sOctets.length, 0);\n+        int outPos = Math.max(sOctets.length - sArr.length, 0);\n+        int length = Math.min(sArr.length, sOctets.length);\n+        System.arraycopy(sArr, inPos, sOctets, outPos, length);\n+        Arrays.fill(sArr, (byte) 0);\n+\n+        DerOutputStream out = new DerOutputStream();\n+        out.putInteger(1); \/\/ version 1\n+        out.putOctetString(sOctets);\n+        Arrays.fill(sOctets, (byte) 0);\n+        DerValue val = DerValue.wrap(DerValue.tag_Sequence, out);\n+        key = val.toByteArray();\n+        val.clear();\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECPrivateKeyImpl.java","additions":27,"deletions":36,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,2 +57,0 @@\n-        } catch (IOException ex) {\n-            throw new AssertionError(\"Should not happen\", ex);\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/XDHPrivateKeyImpl.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n-        t2.setValue(p.getX()).setSum(p.getY()).setReduced();\n+        t2.setValue(p.getX()).setSum(p.getY());\n@@ -201,1 +201,1 @@\n-        t1.setValue(p.getX()).setDifference(p.getY()).setReduced();\n+        t1.setValue(p.getX()).setDifference(p.getY());\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/Ed25519Operations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-        p1.getX().setDifference(t1).setReduced().setDifference(p1.getY());\n+        p1.getX().setDifference(t1).setDifference(p1.getY());\n@@ -188,1 +188,1 @@\n-        t1.setValue(t2).setSum(p.getY()).setReduced();\n+        t1.setValue(t2).setSum(p.getY());\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/Ed448Operations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,2 +119,0 @@\n-        \/\/ need to be reduced before output conversion\n-        S.setReduced();\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/EdDSAOperations.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.security.ProviderException;\n@@ -58,2 +57,0 @@\n-        } catch (IOException ex) {\n-            throw new AssertionError(\"Should not happen\", ex);\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/EdDSAPrivateKeyImpl.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -139,3 +139,0 @@\n-        \/\/ work around 1.4.2 counter inititization bugs\n-        kludge(map);\n-\n@@ -304,145 +301,0 @@\n-    \/**\n-     * method to make adjustments for known counter problems. This\n-     * method depends on the availability of certain counters, which\n-     * is generally guaranteed by the synchWithTarget() method.\n-     *\/\n-    protected void kludge(Map<String, Monitor> map) {\n-        if (Boolean.getBoolean(\"sun.jvmstat.perfdata.disableKludge\")) {\n-            \/\/ bypass all kludges\n-            return;\n-        }\n-\n-        String name = \"java.vm.version\";\n-        StringMonitor jvm_version = (StringMonitor)map.get(name);\n-        if (jvm_version == null) {\n-            jvm_version = (StringMonitor)findByAlias(name);\n-        }\n-\n-        name = \"java.vm.name\";\n-        StringMonitor jvm_name = (StringMonitor)map.get(name);\n-        if (jvm_name == null) {\n-            jvm_name = (StringMonitor)findByAlias(name);\n-        }\n-\n-        name = \"hotspot.vm.args\";\n-        StringMonitor args = (StringMonitor)map.get(name);\n-        if (args == null) {\n-            args = (StringMonitor)findByAlias(name);\n-        }\n-\n-        assert ((jvm_name != null) && (jvm_version != null) && (args != null));\n-\n-        if (jvm_name.stringValue().indexOf(\"HotSpot\") >= 0) {\n-            if (jvm_version.stringValue().startsWith(\"1.4.2\")) {\n-                kludgeMantis(map, args);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * method to repair the 1.4.2 parallel scavenge counters that are\n-     * incorrectly initialized by the JVM when UseAdaptiveSizePolicy\n-     * is set. This bug couldn't be fixed for 1.4.2 FCS due to putback\n-     * restrictions.\n-     *\/\n-    private void kludgeMantis(Map<String, Monitor> map, StringMonitor args) {\n-        \/*\n-         * the HotSpot 1.4.2 JVM with the +UseParallelGC option along\n-         * with its default +UseAdaptiveSizePolicy option has a bug with\n-         * the initialization of the sizes of the eden and survivor spaces.\n-         * See bugid 4890736.\n-         *\n-         * note - use explicit 1.4.2 counter names here - don't update\n-         * to latest counter names or attempt to find aliases.\n-         *\/\n-\n-        String cname = \"hotspot.gc.collector.0.name\";\n-        StringMonitor collector = (StringMonitor)map.get(cname);\n-\n-        if (collector.stringValue().equals(\"PSScavenge\")) {\n-            boolean adaptiveSizePolicy = true;\n-\n-            \/*\n-             * HotSpot processes the -XX:Flags\/.hotspotrc arguments prior to\n-             * processing the command line arguments. This allows the command\n-             * line arguments to override any defaults set in .hotspotrc\n-             *\/\n-            cname = \"hotspot.vm.flags\";\n-            StringMonitor flags = (StringMonitor)map.get(cname);\n-            String allArgs = flags.stringValue() + \" \" + args.stringValue();\n-\n-            \/*\n-             * ignore the -XX: prefix as it only applies to the arguments\n-             * passed from the command line (i.e. the invocation api).\n-             * arguments passed through .hotspotrc omit the -XX: prefix.\n-             *\/\n-            int ahi = allArgs.lastIndexOf(\"+AggressiveHeap\");\n-            int aspi = allArgs.lastIndexOf(\"-UseAdaptiveSizePolicy\");\n-\n-            if (ahi != -1) {\n-                \/*\n-                 * +AggressiveHeap was set, check if -UseAdaptiveSizePolicy\n-                 * is set after +AggressiveHeap.\n-                 *\/\n-                \/\/\n-                if ((aspi != -1) && (aspi > ahi)) {\n-                    adaptiveSizePolicy = false;\n-                }\n-            } else {\n-                \/*\n-                 * +AggressiveHeap not set, must be +UseParallelGC. The\n-                 * relative position of -UseAdaptiveSizePolicy is not\n-                 * important in this case, as it will override the\n-                 * UseParallelGC default (+UseAdaptiveSizePolicy) if it\n-                 * appears anywhere in the JVM arguments.\n-                 *\/\n-                if (aspi != -1) {\n-                    adaptiveSizePolicy = false;\n-                }\n-            }\n-\n-            if (adaptiveSizePolicy) {\n-                \/\/ adjust the buggy AdaptiveSizePolicy size counters.\n-\n-                \/\/ first remove the real counters.\n-                String eden_size = \"hotspot.gc.generation.0.space.0.size\";\n-                String s0_size = \"hotspot.gc.generation.0.space.1.size\";\n-                String s1_size = \"hotspot.gc.generation.0.space.2.size\";\n-                map.remove(eden_size);\n-                map.remove(s0_size);\n-                map.remove(s1_size);\n-\n-                \/\/ get the maximum new generation size\n-                String new_max_name = \"hotspot.gc.generation.0.capacity.max\";\n-                LongMonitor new_max = (LongMonitor)map.get(new_max_name);\n-\n-                \/*\n-                 * replace the real counters with pseudo counters that are\n-                 * initialized to the correct values. The maximum size of\n-                 * the eden and survivor spaces are supposed to be:\n-                 *    max_eden_size = new_size - (2*alignment).\n-                 *    max_survivor_size = new_size - (2*alignment).\n-                 * since we don't know the alignment value used, and because\n-                 * of other parallel scavenge bugs that result in oversized\n-                 * spaces, we just set the maximum size of each space to the\n-                 * full new gen size.\n-                 *\/\n-                Monitor monitor = null;\n-\n-                LongBuffer lb = LongBuffer.allocate(1);\n-                lb.put(new_max.longValue());\n-                monitor = new PerfLongMonitor(eden_size, Units.BYTES,\n-                                              Variability.CONSTANT, false, lb);\n-                map.put(eden_size, monitor);\n-\n-                monitor = new PerfLongMonitor(s0_size, Units.BYTES,\n-                                              Variability.CONSTANT, false, lb);\n-                map.put(s0_size, monitor);\n-\n-                monitor = new PerfLongMonitor(s1_size, Units.BYTES,\n-                                              Variability.CONSTANT, false, lb);\n-                map.put(s1_size, monitor);\n-            }\n-        }\n-    }\n-\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/perfdata\/monitor\/v1_0\/PerfDataBuffer.java","additions":1,"deletions":149,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-package javacserver.options;\n+package jdk.internal.opt;\n@@ -29,0 +29,2 @@\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n@@ -36,0 +38,7 @@\n+\/*\n+ * This file was originally a copy of CommandLine.java in\n+ * com.sun.tools.javac.main -- and it will be the last.\n+ *\n+ * Find details at https:\/\/bugs.openjdk.org\/browse\/JDK-8236919\n+ *\/\n+\n@@ -38,5 +47,0 @@\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n@@ -44,1 +48,10 @@\n-public class CommandLine {\n+public final class CommandLine {\n+    \/**\n+     * Convenient wrapper for the {@code List}-based parse method.\n+     *\n+     * @see #parse(List)\n+     *\/\n+    public static String[] parse(String... args) throws IOException {\n+        return parse(List.of(args)).toArray(String[]::new);\n+    }\n+\n@@ -93,1 +106,1 @@\n-     * @throws UnmatchedQuote\n+     * @throws CommandLine.UnmatchedQuote\n@@ -106,0 +119,5 @@\n+    public static void loadCmdFile(InputStream in, List<String> args) throws IOException {\n+        Reader reader = new InputStreamReader(in);\n+        loadCmdFileAndCloseReader(reader, args);\n+    }\n+\n@@ -107,1 +125,6 @@\n-        try (Reader r = Files.newBufferedReader(Paths.get(name), Charset.defaultCharset())) {\n+        Reader reader = Files.newBufferedReader(Paths.get(name), Charset.defaultCharset());\n+        loadCmdFileAndCloseReader(reader, args);\n+    }\n+\n+    private static void loadCmdFileAndCloseReader(Reader r, List<String> args) throws IOException {\n+        try (r) {\n","filename":"src\/jdk.internal.opt\/share\/classes\/jdk\/internal\/opt\/CommandLine.java","additions":32,"deletions":9,"binary":false,"changes":41,"previous_filename":"make\/langtools\/tools\/javacserver\/options\/CommandLine.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+    exports jdk.internal.opt to jdk.jartool, jdk.jlink, jdk.jpackage;\n","filename":"src\/jdk.internal.opt\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -212,2 +212,8 @@\n-     * @param buffer a native byte buffer containing an exception encoded by\n-     *            {@link #encodeThrowable}\n+     * @param errorOrBuffer an error code or a native byte buffer containing an exception encoded by\n+     *            {@link #encodeThrowable}. Error code values and their meanings are:\n+     *\n+     *            <pre>\n+     *             0: native memory for the buffer could not be allocated\n+     *            -1: an OutOfMemoryError was thrown while encoding the exception\n+     *            -2: some other throwable was thrown while encoding the exception\n+     *            <\/pre>\n@@ -216,1 +222,13 @@\n-    static void decodeAndThrowThrowable(long buffer) throws Throwable {\n+    static void decodeAndThrowThrowable(long errorOrBuffer) throws Throwable {\n+        if (errorOrBuffer >= -2L && errorOrBuffer <= 0) {\n+            String context = String.format(\"while encoding an exception to translate it from %s to %s\",\n+                            IS_IN_NATIVE_IMAGE ? \"HotSpot\" : \"libjvmci\",\n+                            IS_IN_NATIVE_IMAGE ? \"libjvmci\" : \"HotSpot\");\n+            if (errorOrBuffer == 0) {\n+                throw new InternalError(\"native buffer could not be allocated \" + context);\n+            }\n+            if (errorOrBuffer == -1L) {\n+                throw new OutOfMemoryError(\"OutOfMemoryError occurred \" + context);\n+            }\n+            throw new InternalError(\"unexpected problem occurred \" + context);\n+        }\n@@ -218,1 +236,1 @@\n-        int encodingLength = unsafe.getInt(buffer);\n+        int encodingLength = unsafe.getInt(errorOrBuffer);\n@@ -220,1 +238,1 @@\n-        unsafe.copyMemory(null, buffer + 4, encoding, Unsafe.ARRAY_BYTE_BASE_OFFSET, encodingLength);\n+        unsafe.copyMemory(null, errorOrBuffer + 4, encoding, Unsafe.ARRAY_BYTE_BASE_OFFSET, encodingLength);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -152,1 +152,0 @@\n-    @VMEntryPoint\n@@ -226,1 +225,0 @@\n-    @VMEntryPoint\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/TranslatedException.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,0 +51,2 @@\n+    requires jdk.internal.opt;\n+\n","filename":"src\/jdk.jartool\/share\/classes\/module-info.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.tools.jar;\n-\n-import java.io.IOException;\n-import java.io.Reader;\n-import java.io.FileReader;\n-import java.io.BufferedReader;\n-import java.io.StreamTokenizer;\n-import java.util.List;\n-import java.util.ArrayList;\n-\n-\/**\n- * Various utility methods for processing Java tool command line arguments.\n- *\n- *  <p><b>This is NOT part of any API supported by Oracle.  If\n- *  you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class CommandLine {\n-    \/**\n-     * Process Win32-style command files for the specified command line\n-     * arguments and return the resulting arguments. A command file argument\n-     * is of the form '@file' where 'file' is the name of the file whose\n-     * contents are to be parsed for additional arguments. The contents of\n-     * the command file are parsed using StreamTokenizer and the original\n-     * '@file' argument replaced with the resulting tokens. Recursive command\n-     * files are not supported. The '@' character itself can be quoted with\n-     * the sequence '@@'.\n-     *\/\n-    public static String[] parse(String[] args)\n-        throws IOException\n-    {\n-        List<String> newArgs = new ArrayList<>(args.length);\n-        for (int i = 0; i < args.length; i++) {\n-            String arg = args[i];\n-            if (arg.length() > 1 && arg.charAt(0) == '@') {\n-                arg = arg.substring(1);\n-                if (arg.charAt(0) == '@') {\n-                    newArgs.add(arg);\n-                } else {\n-                    loadCmdFile(arg, newArgs);\n-                }\n-            } else {\n-                newArgs.add(arg);\n-            }\n-        }\n-        return newArgs.toArray(new String[newArgs.size()]);\n-    }\n-\n-    private static void loadCmdFile(String name, List<String> args)\n-        throws IOException\n-    {\n-        Reader r = new BufferedReader(new FileReader(name));\n-        StreamTokenizer st = new StreamTokenizer(r);\n-        st.resetSyntax();\n-        st.wordChars(' ', 255);\n-        st.whitespaceChars(0, ' ');\n-        st.commentChar('#');\n-        st.quoteChar('\"');\n-        st.quoteChar('\\'');\n-        while (st.nextToken() != StreamTokenizer.TT_EOF) {\n-            args.add(st.sval);\n-        }\n-        r.close();\n-    }\n-}\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/CommandLine.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -71,0 +71,1 @@\n+import jdk.internal.opt.CommandLine;\n@@ -877,0 +878,1 @@\n+                e.setMethod(ZipEntry.STORED);\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-import com.sun.source.doctree.TextTree;\n@@ -88,1 +87,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;\n@@ -166,1 +164,1 @@\n-    private static final int SEE_TAG_MAX_INLINE_LENGTH = 30;\n+    private static final int TAG_LIST_ITEM_MAX_INLINE_LENGTH = 30;\n@@ -391,1 +389,1 @@\n-        var seeList = HtmlTree.UL(hasLongLabels ? HtmlStyle.seeListLong : HtmlStyle.seeList);\n+        var seeList = HtmlTree.UL(hasLongLabels ? HtmlStyle.tagListLong : HtmlStyle.tagList);\n@@ -406,1 +404,1 @@\n-        return s.length() > SEE_TAG_MAX_INLINE_LENGTH || s.contains(\",\");\n+        return s.length() > TAG_LIST_ITEM_MAX_INLINE_LENGTH || s.contains(\",\");\n@@ -416,7 +414,0 @@\n-    private void appendSeparatorIfNotEmpty(ContentBuilder body) {\n-        if (!body.isEmpty()) {\n-            body.add(\", \");\n-            body.add(Text.NL);\n-        }\n-    }\n-\n@@ -756,4 +747,2 @@\n-        ContentBuilder body = new ContentBuilder();\n-        for (SpecTree st : specTags) {\n-            appendSeparatorIfNotEmpty(body);\n-            body.add(specTagToContent(holder, st));\n+        if (specTags.isEmpty()) {\n+            return Text.EMPTY;\n@@ -761,2 +750,11 @@\n-        if (body.isEmpty())\n-            return body;\n+\n+        List<Content> links = specTags.stream()\n+                .map(st -> specTagToContent(holder, st))\n+                .collect(Collectors.toList());\n+\n+        \/\/ Use a different style if any link label is longer than 30 chars or contains commas.\n+        boolean hasLongLabels = links.stream().anyMatch(this::isLongOrHasComma);\n+        var specList = HtmlTree.UL(hasLongLabels ? HtmlStyle.tagListLong : HtmlStyle.tagList);\n+        links.stream()\n+                .filter(Predicate.not(Content::isEmpty))\n+                .forEach(item -> specList.add(HtmlTree.LI(item)));\n@@ -766,1 +764,1 @@\n-                HtmlTree.DD(body));\n+                HtmlTree.DD(specList));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":17,"deletions":19,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n-     * The class for the list containing the {@code @see} tags of an element.\n+     * The class for a list containing the tags of an element.\n@@ -388,1 +388,1 @@\n-    seeList,\n+    tagList,\n@@ -391,2 +391,2 @@\n-     * The class for the list containing the {@code @see} tags of an element\n-     * when some of the tags have longer labels.\n+     * The class for a list containing the tags of an element\n+     * when some tags have longer labels or contain commas.\n@@ -394,1 +394,1 @@\n-    seeListLong,\n+    tagListLong,\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/HtmlStyle.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-function analyzeMatch(matcher, input, startOfName, category) {\n+function findMatch(matcher, input, startOfName, endOfName) {\n@@ -164,1 +164,5 @@\n-    while (!match && from > 1) {\n+    \/\/ Expand search area until we get a valid result or reach the beginning of the string\n+    while (!match || match.index + match[0].length < startOfName || endOfName < match.index) {\n+        if (from === 0) {\n+            return NO_MATCH;\n+        }\n@@ -169,3 +173,0 @@\n-    if (!match) {\n-        return NO_MATCH;\n-    }\n@@ -174,10 +175,0 @@\n-    var leftParen = input.indexOf(\"(\");\n-    \/\/ exclude peripheral matches\n-    if (category !== \"modules\" && category !== \"searchTags\") {\n-        if (leftParen > -1 && leftParen < match.index) {\n-            return NO_MATCH;\n-        } else if (startOfName - 1 >= matchEnd) {\n-            return NO_MATCH;\n-        }\n-    }\n-    var endOfName = leftParen > -1 ? leftParen : input.length;\n@@ -223,1 +214,0 @@\n-        category: category,\n@@ -288,1 +278,3 @@\n-            var m = analyzeMatch(matcher.plainMatcher, input, startOfName, category);\n+            var endOfName = category === \"members\" && input.indexOf(\"(\", startOfName) > -1\n+                ? input.indexOf(\"(\", startOfName) : input.length;\n+            var m = findMatch(matcher.plainMatcher, input, startOfName, endOfName);\n@@ -290,1 +282,1 @@\n-                m = analyzeMatch(matcher.camelCaseMatcher, input, startOfName, category);\n+                m = findMatch(matcher.camelCaseMatcher, input, startOfName, endOfName);\n@@ -295,0 +287,1 @@\n+                m.category = category;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/search.js.template","additions":11,"deletions":18,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -31,3 +31,4 @@\n-    \/* Background and text colors for highlighted elements *\/\n-    --highlight-background-color: #f8981d;\n-    --highlight-text-color: #253441;\n+    \/* Background and text colors for selected tabs and navigation items *\/\n+    --selected-background-color: #f8981d;\n+    --selected-text-color: #253441;\n+    --selected-link-color: #1f389c;\n@@ -45,0 +46,1 @@\n+    --snippet-highlight-color: #f7c590;\n@@ -48,0 +50,12 @@\n+    \/* Search input colors *\/\n+    --search-input-background-color: #ffffff;\n+    --search-input-text-color: #000000;\n+    --search-input-placeholder-color: #909090;\n+    \/* Highlight color for active search tag target *\/\n+    --search-tag-highlight-color: #ffff00;\n+    \/* Adjustments for icon and active background colors of copy-to-clipboard buttons *\/\n+    --copy-icon-brightness: 100%;\n+    --copy-button-background-color-active: rgba(168, 168, 176, 0.3);\n+    \/* Colors for invalid tag notifications *\/\n+    --invalid-tag-background-color: #ffe6e6;\n+    --invalid-tag-text-color: #000000;\n@@ -81,3 +95,0 @@\n-a[name] {\n-    color:#353833;\n-}\n@@ -183,1 +194,0 @@\n-    padding:0;\n@@ -187,1 +197,1 @@\n-    padding-top:10px;\n+    padding:10px 0 0 0;\n@@ -247,1 +257,1 @@\n-    color:#bb7a2a;\n+    color:var(--link-color-active);\n@@ -250,2 +260,2 @@\n-    background-color:var(--highlight-background-color);\n-    color:var(--highlight-text-color);\n+    background-color:var(--selected-background-color);\n+    color:var(--selected-text-color);\n@@ -314,1 +324,1 @@\n-    font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif;\n+    font-family: var(--body-font-family);\n@@ -369,1 +379,0 @@\n-  margin-left:0;\n@@ -380,1 +389,1 @@\n-ul.see-list, ul.see-list-long {\n+ul.tag-list, ul.tag-list-long {\n@@ -384,1 +393,1 @@\n-ul.see-list li {\n+ul.tag-list li {\n@@ -387,2 +396,3 @@\n-ul.see-list li:not(:last-child):after,\n-ul.see-list-long li:not(:last-child):after {\n+ul.tag-list li:not(:last-child):after,\n+ul.tag-list-long li:not(:last-child):after\n+{\n@@ -412,1 +422,1 @@\n-    color:#253441;\n+    color:var(--selected-text-color);\n@@ -415,3 +425,1 @@\n-    padding:0;\n-    padding-top:10px;\n-    padding-left:1px;\n+    padding: 10px 0 0 1px;\n@@ -421,1 +429,1 @@\n-    color:#1f389c;\n+    color:var(--selected-link-color);\n@@ -433,1 +441,1 @@\n-    background-color:var(--highlight-background-color);\n+    background-color:var(--selected-background-color);\n@@ -441,6 +449,0 @@\n-div.table-tabs > span {\n-    background-color: #EEE;\n-    color: #000;\n-    border: none;\n-    padding: 5px 12px 8px 12px;\n-}\n@@ -455,2 +457,2 @@\n-    background: var(--highlight-background-color);\n-    color: var(--highlight-text-color);\n+    background: var(--selected-background-color);\n+    color: var(--selected-text-color);\n@@ -638,1 +640,2 @@\n-    color:green;\n+    \/* Color of line numbers in source pages can be set via custom property below *\/\n+    color:var(--source-linenumber-color, green);\n@@ -682,2 +685,3 @@\n-    background: #ffe6e6;\n-    border: thin solid #000000;\n+    color: var(--invalid-tag-text-color);\n+    background: var(--invalid-tag-background-color);\n+    border: thin solid var(--table-border-color);\n@@ -702,3 +706,3 @@\n-    background: var(--highlight-background-color);\n-    border: 1px solid var(--highlight-background-color);\n-    color: var(--highlight-text-color);\n+    background: var(--selected-background-color);\n+    border: 1px solid var(--selected-background-color);\n+    color: var(--selected-text-color);\n@@ -738,1 +742,1 @@\n-    font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif;\n+    font-family: var(--body-font-family);\n@@ -745,1 +749,1 @@\n-    color:#4A6782;\n+    color:var(--link-color);\n@@ -760,0 +764,3 @@\n+    background-color: var(--search-input-background-color);\n+    color: var(--search-input-text-color);\n+    border-color: var(--border-color);\n@@ -782,1 +789,1 @@\n-    color:#909090;\n+    color:var(--search-input-placeholder-color);\n@@ -794,1 +801,1 @@\n-    background-color:yellow;\n+    background-color:var(--search-tag-highlight-color);\n@@ -926,0 +933,4 @@\n+    filter: brightness(var(--copy-icon-brightness));\n+}\n+button.copy:active {\n+    background-color: var(--copy-button-background-color-active);\n@@ -945,3 +956,0 @@\n-button.copy-header:active {\n-    background-color: rgba(128, 128, 160, 0.2);\n-}\n@@ -972,6 +980,0 @@\n-div.page-search-info button#page-search-copy:hover {\n-    background-color: rgba(128, 128, 160, 0.2);\n-}\n-div.page-search-info button#page-search-copy:active {\n-    background-color: rgba(128, 128, 160, 0.4);\n-}\n@@ -1009,3 +1011,0 @@\n-button.snippet-copy:active {\n-    background-color: rgba(128, 128, 160, 0.2);\n-}\n@@ -1263,1 +1262,1 @@\n-    background-color: #f7c590;\n+    background-color: var(--snippet-highlight-color);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/stylesheet.css","additions":53,"deletions":54,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -66,3 +66,2 @@\n-                ExecutableElement m = result.get().method();\n-                tags = utils.getSpecTrees(m);\n-                e = m;\n+                e = result.get().method();\n+                tags = result.get().specTrees();\n@@ -74,1 +73,1 @@\n-    private record Documentation(List<? extends SpecTree> seeTrees, ExecutableElement method) { }\n+    private record Documentation(List<? extends SpecTree> specTrees, ExecutableElement method) { }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SpecTaglet.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1624,0 +1624,9 @@\n+static jvmtiError\n+adjust_jvmti_error(jvmtiError error) {\n+    \/\/ Allow WRONG_PHASE if vm is exiting.\n+    if (error == JVMTI_ERROR_WRONG_PHASE && gdata->vmDead) {\n+        error = JVMTI_ERROR_NONE;\n+    }\n+    return error;\n+}\n+\n@@ -1640,1 +1649,3 @@\n-     * be very noisy and hurt performance a lot.\n+     * be very noisy and hurt performance a lot. Note the VM might be exiting,\n+     * and we might get the VM_DEATH event while executing here, so don't\n+     * complain about JVMTI_ERROR_WRONG_PHASE if we've already seen VM_DEATH event.\n@@ -1646,1 +1657,1 @@\n-        if (error != JVMTI_ERROR_NONE) {\n+        if (adjust_jvmti_error(error) != JVMTI_ERROR_NONE) {\n@@ -1651,1 +1662,1 @@\n-        if (error != JVMTI_ERROR_NONE) {\n+        if (adjust_jvmti_error(error) != JVMTI_ERROR_NONE) {\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.c","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import jdk.jfr.internal.management.StreamBarrier;\n@@ -383,0 +384,37 @@\n+    \/**\n+     * Stops the recording stream.\n+     * <p>\n+     * Stops a started stream and waits until all events in the recording have\n+     * been consumed.\n+     * <p>\n+     * Invoking this method in an action, for example in the\n+     * {@link #onEvent(Consumer)} method, could block the stream indefinitely.\n+     * To stop the stream abruptly, use the {@link #close} method.\n+     * <p>\n+     * The following code snippet illustrates how this method can be used in\n+     * conjunction with the {@link #startAsync()} method to monitor what happens\n+     * during a test method:\n+     * <p>\n+     * {@snippet class=\"Snippets\" region=\"RecordingStreamStop\"}\n+     *\n+     * @return {@code true} if recording is stopped, {@code false} otherwise\n+     *\n+     * @throws IllegalStateException if the recording is not started or is already stopped\n+     *\n+     * @since 20\n+     *\/\n+    public boolean stop() {\n+        boolean stopped = false;\n+        try {\n+            try (StreamBarrier sb = directoryStream.activateStreamBarrier()) {\n+                stopped = recording.stop();\n+                directoryStream.setCloseOnComplete(false);\n+                sb.setStreamEnd(recording.getStopTime().toEpochMilli());\n+            }\n+            directoryStream.awaitTermination();\n+        } catch (InterruptedException | IOException e) {\n+            \/\/ OK, return\n+        }\n+        return stopped;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -169,0 +170,22 @@\n+\n+    void RecordingStreamStop() throws Exception {\n+        \/\/ @start region=\"RecordingStreamStop\"\n+        AtomicBoolean socketUse = new AtomicBoolean();\n+        try (var r = new RecordingStream()) {\n+            r.setMaxSize(Long.MAX_VALUE);\n+            r.enable(\"jdk.SocketWrite\").withoutThreshold();\n+            r.enable(\"jdk.SocketRead\").withoutThreshold();\n+            r.onEvent(event -> socketUse.set(true));\n+            r.startAsync();\n+            testFoo();\n+            r.stop();\n+            if (socketUse.get()) {\n+                r.dump(Path.of(\"socket-events.jfr\"));\n+                throw new AssertionError(\"testFoo() should not use network\");\n+            }\n+        }\n+        \/\/ @end\n+    }\n+\n+    void testFoo() {\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/snippet-files\/Snippets.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+    private volatile boolean closeOnComplete = true;\n@@ -68,0 +69,1 @@\n+\n@@ -110,0 +112,7 @@\n+    \/\/ When set to false, it becomes the callers responsibility\n+    \/\/ to invoke close() and clean up resources. By default,\n+    \/\/ the resource is cleaned up when the process() call has finished.\n+    public final void setCloseOnComplete(boolean closeOnComplete) {\n+        this.closeOnComplete = closeOnComplete;\n+    }\n+\n@@ -261,1 +270,3 @@\n-                close();\n+                if (closeOnComplete) {\n+                    close();\n+                }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/AbstractEventStream.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import jdk.jfr.internal.management.StreamBarrier;\n@@ -57,0 +58,1 @@\n+    private final StreamBarrier barrier = new StreamBarrier();\n@@ -61,1 +63,0 @@\n-\n@@ -153,1 +154,0 @@\n-\n@@ -169,2 +169,8 @@\n-                    if (currentParser.getStartNanos() + currentParser.getChunkDuration() > filterEnd) {\n-                        close();\n+                    barrier.check(); \/\/ block if recording is being stopped\n+                    long endNanos = currentParser.getStartNanos() + currentParser.getChunkDuration();\n+                    \/\/ same conversion as in RecordingInfo\n+                    long endMillis = Instant.ofEpochSecond(0, endNanos).toEpochMilli();\n+                    if (barrier.getStreamEnd() <= endMillis) {\n+                        return;\n+                    }\n+                    if (endNanos > filterEnd) {\n@@ -208,0 +214,1 @@\n+\n@@ -262,0 +269,5 @@\n+\n+    public StreamBarrier activateStreamBarrier() {\n+        barrier.activate();\n+        return barrier;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+import jdk.jfr.internal.consumer.AbstractEventStream;\n@@ -181,0 +182,14 @@\n+\n+    \/\/ An EventStream is passive, so a stop() method doesn't fit well in the API.\n+    \/\/ RemoteRecordingStream::stop() implementation need to prevent stream\n+    \/\/ from being closed, so this method is needed\n+    public static void setCloseOnComplete(EventStream stream, boolean closeOnComplete) {\n+        AbstractEventStream aes = (AbstractEventStream) stream;\n+        aes.setCloseOnComplete(closeOnComplete);\n+    }\n+\n+    \/\/ Internal method needed to block parser\n+    public static StreamBarrier activateStreamBarrier(EventStream stream) {\n+        EventDirectoryStream aes = (EventDirectoryStream) stream;\n+        return aes.activateStreamBarrier();\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ManagementSupport.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.management;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+\n+\/**\n+ * Purpose of this class is to provide a synchronization point when stopping a\n+ * recording. Without it, a race can happen where a stream advances beyond the\n+ * last chunk of the recording.\n+ *\n+ * Code that is processing the stream calls check() and Unless the recording is\n+ * in the process of being stopped, it will just return. On the other hand, if\n+ * the recording is stopping, the thread waits and when it wakes up an end\n+ * position should have been set (last chunk position) beyond which the stream\n+ * processing should not continue.\n+ *\/\n+public final class StreamBarrier implements Closeable {\n+\n+    private boolean activated = false;\n+    private long end = Long.MAX_VALUE;\n+\n+    \/\/ Blocks thread until barrier is deactivated\n+    public synchronized void check() {\n+        while (activated) {\n+            try {\n+                this.wait();\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+            }\n+        }\n+    }\n+\n+    public synchronized void setStreamEnd(long timestamp) {\n+        end = timestamp;\n+    }\n+\n+    public synchronized long getStreamEnd() {\n+        return end;\n+    }\n+\n+    public synchronized void activate() {\n+        activated = true;\n+    }\n+\n+    @Override\n+    public synchronized void close() throws IOException {\n+        activated = false;\n+        this.notifyAll();\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/StreamBarrier.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -1,166 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.tools.jlink.internal;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.Reader;\n-import java.util.List;\n-\n-\/**\n- * This file was originally a copy of CommandLine.java in\n- * com.sun.tools.javac.main.\n- * It should track changes made to that file.\n- *\/\n-\n-\/**\n- * Various utility methods for processing Java tool command line arguments.\n- *\/\n-public class CommandLine {\n-\n-    static void loadCmdFile(InputStream in, List<String> args)\n-            throws IOException {\n-        try (Reader r = new InputStreamReader(in)) {\n-            Tokenizer t = new Tokenizer(r);\n-            String s;\n-            while ((s = t.nextToken()) != null) {\n-                args.add(s);\n-            }\n-        }\n-    }\n-    public static class Tokenizer {\n-        private final Reader in;\n-        private int ch;\n-\n-        public Tokenizer(Reader in) throws IOException {\n-            this.in = in;\n-            ch = in.read();\n-        }\n-\n-        public String nextToken() throws IOException {\n-            skipWhite();\n-            if (ch == -1) {\n-                return null;\n-            }\n-\n-            StringBuilder sb = new StringBuilder();\n-            char quoteChar = 0;\n-\n-            while (ch != -1) {\n-                switch (ch) {\n-                    case ' ':\n-                    case '\\t':\n-                    case '\\f':\n-                        if (quoteChar == 0) {\n-                            return sb.toString();\n-                        }\n-                        sb.append((char) ch);\n-                        break;\n-\n-                    case '\\n':\n-                    case '\\r':\n-                        return sb.toString();\n-\n-                    case '\\'':\n-                    case '\"':\n-                        if (quoteChar == 0) {\n-                            quoteChar = (char) ch;\n-                        } else if (quoteChar == ch) {\n-                            quoteChar = 0;\n-                        } else {\n-                            sb.append((char) ch);\n-                        }\n-                        break;\n-\n-                    case '\\\\':\n-                        if (quoteChar != 0) {\n-                            ch = in.read();\n-                            switch (ch) {\n-                                case '\\n':\n-                                case '\\r':\n-                                    while (ch == ' ' || ch == '\\n'\n-                                            || ch == '\\r' || ch == '\\t'\n-                                            || ch == '\\f') {\n-                                        ch = in.read();\n-                                    }\n-                                    continue;\n-\n-                                case 'n':\n-                                    ch = '\\n';\n-                                    break;\n-                                case 'r':\n-                                    ch = '\\r';\n-                                    break;\n-                                case 't':\n-                                    ch = '\\t';\n-                                    break;\n-                                case 'f':\n-                                    ch = '\\f';\n-                                    break;\n-                                default:\n-                                    break;\n-                            }\n-                        }\n-                        sb.append((char) ch);\n-                        break;\n-\n-                    default:\n-                        sb.append((char) ch);\n-                }\n-\n-                ch = in.read();\n-            }\n-\n-            return sb.toString();\n-        }\n-\n-        void skipWhite() throws IOException {\n-            while (ch != -1) {\n-                switch (ch) {\n-                    case ' ':\n-                    case '\\t':\n-                    case '\\n':\n-                    case '\\r':\n-                    case '\\f':\n-                        break;\n-\n-                    case '#':\n-                        ch = in.read();\n-                        while (ch != '\\n' && ch != '\\r' && ch != -1) {\n-                            ch = in.read();\n-                        }\n-                        break;\n-\n-                    default:\n-                        return;\n-                }\n-\n-                ch = in.read();\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/CommandLine.java","additions":0,"deletions":166,"binary":false,"changes":166,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,1 @@\n+import jdk.internal.opt.CommandLine;\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,215 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.main;\n-\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.io.Reader;\n-import java.nio.charset.Charset;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-\/**\n- * This file was originally a copy of CommandLine.java in\n- * com.sun.tools.javac.main.\n- * It should track changes made to that file.\n- *\/\n-\n-\/**\n- * Various utility methods for processing Java tool command line arguments.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-class CommandLine {\n-    \/**\n-     * Process Win32-style command files for the specified command line\n-     * arguments and return the resulting arguments. A command file argument\n-     * is of the form '@file' where 'file' is the name of the file whose\n-     * contents are to be parsed for additional arguments. The contents of\n-     * the command file are parsed using StreamTokenizer and the original\n-     * '@file' argument replaced with the resulting tokens. Recursive command\n-     * files are not supported. The '@' character itself can be quoted with\n-     * the sequence '@@'.\n-     * @param args the arguments that may contain @files\n-     * @return the arguments, with @files expanded\n-     * @throws IOException if there is a problem reading any of the @files\n-     *\/\n-    public static String[] parse(String[] args) throws IOException {\n-        List<String> newArgs = new ArrayList<>();\n-        appendParsedCommandArgs(newArgs, Arrays.asList(args));\n-        return newArgs.toArray(new String[newArgs.size()]);\n-    }\n-\n-    private static void appendParsedCommandArgs(List<String> newArgs,\n-            List<String> args) throws IOException {\n-        for (String arg : args) {\n-            if (arg.length() > 1 && arg.charAt(0) == '@') {\n-                arg = arg.substring(1);\n-                if (arg.charAt(0) == '@') {\n-                    newArgs.add(arg);\n-                } else {\n-                    loadCmdFile(arg, newArgs);\n-                }\n-            } else {\n-                newArgs.add(arg);\n-            }\n-        }\n-    }\n-\n-    private static void loadCmdFile(String name, List<String> args)\n-            throws IOException {\n-        if (!Files.isReadable(Path.of(name))) {\n-            throw new FileNotFoundException(name);\n-        }\n-        try (Reader r = Files.newBufferedReader(Paths.get(name),\n-                Charset.defaultCharset())) {\n-            Tokenizer t = new Tokenizer(r);\n-            String s;\n-            while ((s = t.nextToken()) != null) {\n-                args.add(s);\n-            }\n-        }\n-    }\n-\n-    public static class Tokenizer {\n-        private final Reader in;\n-        private int ch;\n-\n-        public Tokenizer(Reader in) throws IOException {\n-            this.in = in;\n-            ch = in.read();\n-        }\n-\n-        public String nextToken() throws IOException {\n-            skipWhite();\n-            if (ch == -1) {\n-                return null;\n-            }\n-\n-            StringBuilder sb = new StringBuilder();\n-            char quoteChar = 0;\n-\n-            while (ch != -1) {\n-                switch (ch) {\n-                    case ' ':\n-                    case '\\t':\n-                    case '\\f':\n-                        if (quoteChar == 0) {\n-                            return sb.toString();\n-                        }\n-                        sb.append((char) ch);\n-                        break;\n-\n-                    case '\\n':\n-                    case '\\r':\n-                        return sb.toString();\n-\n-                    case '\\'':\n-                    case '\"':\n-                        if (quoteChar == 0) {\n-                            quoteChar = (char) ch;\n-                        } else if (quoteChar == ch) {\n-                            quoteChar = 0;\n-                        } else {\n-                            sb.append((char) ch);\n-                        }\n-                        break;\n-\n-                    case '\\\\':\n-                        if (quoteChar != 0) {\n-                            ch = in.read();\n-                            switch (ch) {\n-                                case '\\n':\n-                                case '\\r':\n-                                    while (ch == ' ' || ch == '\\n'\n-                                            || ch == '\\r' || ch == '\\t'\n-                                            || ch == '\\f') {\n-                                        ch = in.read();\n-                                    }\n-                                    continue;\n-\n-                                case 'n':\n-                                    ch = '\\n';\n-                                    break;\n-                                case 'r':\n-                                    ch = '\\r';\n-                                    break;\n-                                case 't':\n-                                    ch = '\\t';\n-                                    break;\n-                                case 'f':\n-                                    ch = '\\f';\n-                                    break;\n-                                default:\n-                                    break;\n-                            }\n-                        }\n-                        sb.append((char) ch);\n-                        break;\n-\n-                    default:\n-                        sb.append((char) ch);\n-                }\n-\n-                ch = in.read();\n-            }\n-\n-            return sb.toString();\n-        }\n-\n-        void skipWhite() throws IOException {\n-            while (ch != -1) {\n-                switch (ch) {\n-                    case ' ':\n-                    case '\\t':\n-                    case '\\n':\n-                    case '\\r':\n-                    case '\\f':\n-                        break;\n-\n-                    case '#':\n-                        ch = in.read();\n-                        while (ch != '\\n' && ch != '\\r' && ch != -1) {\n-                            ch = in.read();\n-                        }\n-                        break;\n-\n-                    default:\n-                        return;\n-                }\n-\n-                ch = in.read();\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/main\/CommandLine.java","additions":0,"deletions":215,"binary":false,"changes":215,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.internal.opt.CommandLine;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/main\/Main.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+    requires jdk.internal.opt;\n","filename":"src\/jdk.jpackage\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import jdk.jfr.internal.management.StreamBarrier;\n@@ -129,0 +130,1 @@\n+    private final StreamBarrier barrier = new StreamBarrier();\n@@ -156,0 +158,1 @@\n+        barrier.check();\n@@ -348,0 +351,4 @@\n+            if (currentChunk.endTime.toEpochMilli() == barrier.getStreamEnd()) {\n+                \/\/ Recording has been stopped, need to complete last chunk\n+                completePrevious(currentChunk);\n+            }\n@@ -515,0 +522,5 @@\n+\n+    public StreamBarrier activateStreamBarrier() {\n+        barrier.activate();\n+        return barrier;\n+    }\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/DiskRepository.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+import jdk.jfr.internal.management.StreamBarrier;\n@@ -563,0 +564,69 @@\n+    \/**\n+     * Stops the recording stream.\n+     * <p>\n+     * Stops a started stream and waits until all events in the recording have\n+     * been consumed.\n+     * <p>\n+     * Invoking this method in an action, for example in the\n+     * {@link #onEvent(Consumer)} method, could block the stream indefinitely.\n+     * To stop the stream abruptly, use the {@link #close} method.\n+     * <p>\n+     * The following code snippet illustrates how this method can be used in\n+     * conjunction with the {@link #startAsync()} method to monitor what happens\n+     * during a test method:\n+     * <p>\n+     * {@snippet :\n+     *   AtomicLong bytesWritten = new AtomicLong();\n+     *   try (var r = new RemoteRecordingStream(connection)) {\n+     *     r.setMaxSize(Long.MAX_VALUE);\n+     *     r.enable(\"jdk.FileWrite\").withoutThreshold();\n+     *     r.onEvent(event ->\n+     *       bytesWritten.addAndGet(event.getLong(\"bytesWritten\"))\n+     *     );\n+     *     r.startAsync();\n+     *     testFoo();\n+     *     r.stop();\n+     *     if (bytesWritten.get() > 1_000_000L) {\n+     *       r.dump(Path.of(\"file-write-events.jfr\"));\n+     *       throw new AssertionError(\"testFoo() writes too much data to disk\");\n+     *     }\n+     *   }\n+     * }\n+     * @return {@code true} if recording is stopped, {@code false} otherwise\n+     *\n+     * @throws IllegalStateException if the recording is not started or is already stopped\n+     *\n+     * @since 20\n+     *\/\n+    public boolean stop() {\n+        synchronized (lock) {\n+            if (closed) {\n+                throw new IllegalStateException(\"Event stream is closed\");\n+            }\n+            if (!started) {\n+                throw new IllegalStateException(\"Event stream must be started before it can stopped\");\n+            }\n+            try {\n+                boolean stopped = false;\n+                try (StreamBarrier pb = ManagementSupport.activateStreamBarrier(stream)) {\n+                    try (StreamBarrier rb = repository.activateStreamBarrier()) {\n+                        stopped = mbean.stopRecording(recordingId);\n+                        ManagementSupport.setCloseOnComplete(stream, false);\n+                        long stopTime = getRecordingInfo(mbean.getRecordings(), recordingId).getStopTime();\n+                        pb.setStreamEnd(stopTime);\n+                        rb.setStreamEnd(stopTime);\n+                    }\n+                }\n+                try {\n+                    stream.awaitTermination();\n+                } catch (InterruptedException e) {\n+                    \/\/ OK\n+                }\n+                return stopped;\n+            } catch (Exception e) {\n+                ManagementSupport.logDebug(e.getMessage());\n+                return false;\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/RemoteRecordingStream.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -1014,1 +1014,1 @@\n-        elif not self._isPredicated and (name in [\"and\", \"eor\", \"orr\", \"bic\"]):\n+        elif not self._isPredicated and (name in [\"and\", \"eor\", \"orr\", \"bic\", \"eor3\"]):\n@@ -1043,1 +1043,2 @@\n-        formatStr = \"%s%s\" + ''.join([\", %s\" for i in range(1, self.numRegs)])\n+        firstArg = 0 if self._name == \"eor3\" else 1\n+        formatStr = \"%s%s\" + ''.join([\", %s\" for i in range(firstArg, self.numRegs)])\n@@ -1053,1 +1054,1 @@\n-            restRegs = dnReg + [str(self.reg[i]) + self._width.astr() for i in range(1, self.numRegs)]\n+            restRegs = dnReg + [str(self.reg[i]) + self._width.astr() for i in range(firstArg, self.numRegs)]\n@@ -1929,0 +1930,1 @@\n+                       [\"eor3\", \"ZZZ\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1215,0 +1215,1 @@\n+    __ sve_eor3(z20, z5, z1);                          \/\/       eor3    z20.d, z20.d, z5.d, z1.d\n@@ -1217,9 +1218,9 @@\n-    __ sve_andv(v20, __ H, p1, z1);                    \/\/       andv h20, p1, z1.h\n-    __ sve_orv(v13, __ H, p0, z7);                     \/\/       orv h13, p0, z7.h\n-    __ sve_eorv(v11, __ D, p4, z4);                    \/\/       eorv d11, p4, z4.d\n-    __ sve_smaxv(v15, __ D, p0, z3);                   \/\/       smaxv d15, p0, z3.d\n-    __ sve_sminv(v0, __ S, p5, z5);                    \/\/       sminv s0, p5, z5.s\n-    __ sve_fminv(v30, __ S, p7, z13);                  \/\/       fminv s30, p7, z13.s\n-    __ sve_fmaxv(v8, __ S, p3, z29);                   \/\/       fmaxv s8, p3, z29.s\n-    __ sve_fadda(v14, __ S, p7, z3);                   \/\/       fadda s14, p7, s14, z3.s\n-    __ sve_uaddv(v25, __ H, p2, z24);                  \/\/       uaddv d25, p2, z24.h\n+    __ sve_andv(v13, __ H, p0, z7);                    \/\/       andv h13, p0, z7.h\n+    __ sve_orv(v11, __ D, p4, z4);                     \/\/       orv d11, p4, z4.d\n+    __ sve_eorv(v15, __ D, p0, z3);                    \/\/       eorv d15, p0, z3.d\n+    __ sve_smaxv(v0, __ S, p5, z5);                    \/\/       smaxv s0, p5, z5.s\n+    __ sve_sminv(v30, __ H, p7, z13);                  \/\/       sminv h30, p7, z13.h\n+    __ sve_fminv(v8, __ S, p3, z29);                   \/\/       fminv s8, p3, z29.s\n+    __ sve_fmaxv(v14, __ S, p7, z3);                   \/\/       fmaxv s14, p7, z3.s\n+    __ sve_fadda(v25, __ S, p2, z24);                  \/\/       fadda s25, p2, s25, z24.s\n+    __ sve_uaddv(v1, __ H, p6, z10);                   \/\/       uaddv d1, p6, z10.h\n@@ -1244,7 +1245,7 @@\n-    0x14000000,     0x17ffffd7,     0x14000401,     0x94000000,\n-    0x97ffffd4,     0x940003fe,     0x3400000a,     0x34fffa2a,\n-    0x34007f6a,     0x35000008,     0x35fff9c8,     0x35007f08,\n-    0xb400000b,     0xb4fff96b,     0xb4007eab,     0xb500001d,\n-    0xb5fff91d,     0xb5007e5d,     0x10000013,     0x10fff8b3,\n-    0x10007df3,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36307d76,     0x3758000c,     0x375ff7cc,     0x37587d0c,\n+    0x14000000,     0x17ffffd7,     0x14000402,     0x94000000,\n+    0x97ffffd4,     0x940003ff,     0x3400000a,     0x34fffa2a,\n+    0x34007f8a,     0x35000008,     0x35fff9c8,     0x35007f28,\n+    0xb400000b,     0xb4fff96b,     0xb4007ecb,     0xb500001d,\n+    0xb5fff91d,     0xb5007e7d,     0x10000013,     0x10fff8b3,\n+    0x10007e13,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36307d96,     0x3758000c,     0x375ff7cc,     0x37587d2c,\n@@ -1255,13 +1256,13 @@\n-    0x54007ae0,     0x54000001,     0x54fff541,     0x54007a81,\n-    0x54000002,     0x54fff4e2,     0x54007a22,     0x54000002,\n-    0x54fff482,     0x540079c2,     0x54000003,     0x54fff423,\n-    0x54007963,     0x54000003,     0x54fff3c3,     0x54007903,\n-    0x54000004,     0x54fff364,     0x540078a4,     0x54000005,\n-    0x54fff305,     0x54007845,     0x54000006,     0x54fff2a6,\n-    0x540077e6,     0x54000007,     0x54fff247,     0x54007787,\n-    0x54000008,     0x54fff1e8,     0x54007728,     0x54000009,\n-    0x54fff189,     0x540076c9,     0x5400000a,     0x54fff12a,\n-    0x5400766a,     0x5400000b,     0x54fff0cb,     0x5400760b,\n-    0x5400000c,     0x54fff06c,     0x540075ac,     0x5400000d,\n-    0x54fff00d,     0x5400754d,     0x5400000e,     0x54ffefae,\n-    0x540074ee,     0x5400000f,     0x54ffef4f,     0x5400748f,\n+    0x54007b00,     0x54000001,     0x54fff541,     0x54007aa1,\n+    0x54000002,     0x54fff4e2,     0x54007a42,     0x54000002,\n+    0x54fff482,     0x540079e2,     0x54000003,     0x54fff423,\n+    0x54007983,     0x54000003,     0x54fff3c3,     0x54007923,\n+    0x54000004,     0x54fff364,     0x540078c4,     0x54000005,\n+    0x54fff305,     0x54007865,     0x54000006,     0x54fff2a6,\n+    0x54007806,     0x54000007,     0x54fff247,     0x540077a7,\n+    0x54000008,     0x54fff1e8,     0x54007748,     0x54000009,\n+    0x54fff189,     0x540076e9,     0x5400000a,     0x54fff12a,\n+    0x5400768a,     0x5400000b,     0x54fff0cb,     0x5400762b,\n+    0x5400000c,     0x54fff06c,     0x540075cc,     0x5400000d,\n+    0x54fff00d,     0x5400756d,     0x5400000e,     0x54ffefae,\n+    0x5400750e,     0x5400000f,     0x54ffef4f,     0x540074af,\n@@ -1498,3 +1499,4 @@\n-    0x4591b33e,     0x45ccb56e,     0x045a2434,     0x045820ed,\n-    0x04d9308b,     0x04c8206f,     0x048a34a0,     0x65873dbe,\n-    0x65862fa8,     0x65983c6e,     0x04412b19,\n+    0x4591b33e,     0x45ccb56e,     0x04253834,     0x045a20ed,\n+    0x04d8308b,     0x04d9206f,     0x048834a0,     0x044a3dbe,\n+    0x65872fa8,     0x65863c6e,     0x65982b19,     0x04413941,\n+\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":34,"deletions":32,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -71,3 +71,0 @@\n-compiler\/debug\/TestStressCM.java 8297343 generic-all\n-compiler\/debug\/TestStressIGVNAndCCP.java 8297343 generic-all\n-\n@@ -170,0 +167,2 @@\n+\n+vmTestbase\/nsk\/stress\/except\/except012.java 8297977 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-requiredVersion=7+1\n+requiredVersion=7.1+1\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -129,5 +129,1 @@\n-  vmTestbase\/nsk\/monitoring\/ThreadMXBean\/resetPeakThreadCount\/reset001\/TestDescription.java \\\n-  vmTestbase\/nsk\/monitoring\/ThreadMXBean\/resetPeakThreadCount\/reset002\/TestDescription.java \\\n-  vmTestbase\/nsk\/monitoring\/ThreadMXBean\/resetPeakThreadCount\/reset003\/TestDescription.java \\\n-  vmTestbase\/nsk\/monitoring\/ThreadMXBean\/resetPeakThreadCount\/reset004\/TestDescription.java \\\n-  vmTestbase\/nsk\/monitoring\/ThreadMXBean\/resetPeakThreadCount\/reset005\/TestDescription.java \\\n+  vmTestbase\/nsk\/monitoring\/ThreadMXBean\/resetPeakThreadCount\/reset001.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.quick-groups","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,317 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.intrinsics.chacha;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.ChaCha20ParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.GeneralSecurityException;\n+import java.util.*;\n+\n+public class ExerciseChaCha20 {\n+\n+    private static final int WARMUP_CYCLES = 200000;\n+\n+    \/\/ Use the test vectors from RFC 7539 to exercise the ChaCha20 block\n+    \/\/ intrinsic\n+    public static final List<TestData> testList = List.of(\n+        new TestData(\"RFC 7539 Sample Test Vector\",\n+            \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\",\n+            \"000000000000004a00000000\",\n+            1, Cipher.ENCRYPT_MODE,\n+            \"4c616469657320616e642047656e746c656d656e206f662074686520636c6173\" +\n+            \"73206f66202739393a204966204920636f756c64206f6666657220796f75206f\" +\n+            \"6e6c79206f6e652074697020666f7220746865206675747572652c2073756e73\" +\n+            \"637265656e20776f756c642062652069742e\",\n+            null,\n+            \"6e2e359a2568f98041ba0728dd0d6981e97e7aec1d4360c20a27afccfd9fae0b\" +\n+            \"f91b65c5524733ab8f593dabcd62b3571639d624e65152ab8f530c359f0861d8\" +\n+            \"07ca0dbf500d6a6156a38e088a22b65e52bc514d16ccf806818ce91ab7793736\" +\n+            \"5af90bbf74a35be6b40b8eedf2785e42874d\"),\n+        new TestData(\"RFC 7539 Test Vector 1 (all zeroes)\",\n+            \"0000000000000000000000000000000000000000000000000000000000000000\",\n+            \"000000000000000000000000\",\n+            0, Cipher.ENCRYPT_MODE,\n+            \"0000000000000000000000000000000000000000000000000000000000000000\" +\n+            \"0000000000000000000000000000000000000000000000000000000000000000\",\n+            null,\n+            \"76b8e0ada0f13d90405d6ae55386bd28bdd219b8a08ded1aa836efcc8b770dc7\" +\n+            \"da41597c5157488d7724e03fb8d84a376a43b8f41518a11cc387b669b2ee6586\"),\n+        new TestData(\"RFC 7539 Test Vector 2\",\n+            \"0000000000000000000000000000000000000000000000000000000000000001\",\n+            \"000000000000000000000002\",\n+            1, Cipher.ENCRYPT_MODE,\n+            \"416e79207375626d697373696f6e20746f20746865204945544620696e74656e\" +\n+            \"6465642062792074686520436f6e7472696275746f7220666f72207075626c69\" +\n+            \"636174696f6e20617320616c6c206f722070617274206f6620616e2049455446\" +\n+            \"20496e7465726e65742d4472616674206f722052464320616e6420616e792073\" +\n+            \"746174656d656e74206d6164652077697468696e2074686520636f6e74657874\" +\n+            \"206f6620616e204945544620616374697669747920697320636f6e7369646572\" +\n+            \"656420616e20224945544620436f6e747269627574696f6e222e205375636820\" +\n+            \"73746174656d656e747320696e636c756465206f72616c2073746174656d656e\" +\n+            \"747320696e20494554462073657373696f6e732c2061732077656c6c20617320\" +\n+            \"7772697474656e20616e6420656c656374726f6e696320636f6d6d756e696361\" +\n+            \"74696f6e73206d61646520617420616e792074696d65206f7220706c6163652c\" +\n+            \"207768696368206172652061646472657373656420746f\",\n+            null,\n+            \"a3fbf07df3fa2fde4f376ca23e82737041605d9f4f4f57bd8cff2c1d4b7955ec\" +\n+            \"2a97948bd3722915c8f3d337f7d370050e9e96d647b7c39f56e031ca5eb6250d\" +\n+            \"4042e02785ececfa4b4bb5e8ead0440e20b6e8db09d881a7c6132f420e527950\" +\n+            \"42bdfa7773d8a9051447b3291ce1411c680465552aa6c405b7764d5e87bea85a\" +\n+            \"d00f8449ed8f72d0d662ab052691ca66424bc86d2df80ea41f43abf937d3259d\" +\n+            \"c4b2d0dfb48a6c9139ddd7f76966e928e635553ba76c5c879d7b35d49eb2e62b\" +\n+            \"0871cdac638939e25e8a1e0ef9d5280fa8ca328b351c3c765989cbcf3daa8b6c\" +\n+            \"cc3aaf9f3979c92b3720fc88dc95ed84a1be059c6499b9fda236e7e818b04b0b\" +\n+            \"c39c1e876b193bfe5569753f88128cc08aaa9b63d1a16f80ef2554d7189c411f\" +\n+            \"5869ca52c5b83fa36ff216b9c1d30062bebcfd2dc5bce0911934fda79a86f6e6\" +\n+            \"98ced759c3ff9b6477338f3da4f9cd8514ea9982ccafb341b2384dd902f3d1ab\" +\n+            \"7ac61dd29c6f21ba5b862f3730e37cfdc4fd806c22f221\"),\n+        new TestData(\"RFC 7539 Test Vector 3\",\n+            \"1c9240a5eb55d38af333888604f6b5f0473917c1402b80099dca5cbc207075c0\",\n+            \"000000000000000000000002\",\n+            42, Cipher.ENCRYPT_MODE,\n+            \"2754776173206272696c6c69672c20616e642074686520736c6974687920746f\" +\n+            \"7665730a446964206779726520616e642067696d626c6520696e207468652077\" +\n+            \"6162653a0a416c6c206d696d737920776572652074686520626f726f676f7665\" +\n+            \"732c0a416e6420746865206d6f6d65207261746873206f757467726162652e\",\n+            null,\n+            \"62e6347f95ed87a45ffae7426f27a1df5fb69110044c0d73118effa95b01e5cf\" +\n+            \"166d3df2d721caf9b21e5fb14c616871fd84c54f9d65b283196c7fe4f60553eb\" +\n+            \"f39c6402c42234e32a356b3e764312a61a5532055716ead6962568f87d3f3f77\" +\n+            \"04c6a8d1bcd1bf4d50d6154b6da731b187b58dfd728afa36757a797ac188d1\")\n+    );\n+\n+    public static class TestData {\n+        public TestData(String name, String keyStr, String nonceStr, int ctr,\n+                        int dir, String inputStr, String aadStr, String outStr) {\n+            testName = Objects.requireNonNull(name);\n+            HexFormat hex = HexFormat.of();\n+            key = hex.parseHex(Objects.requireNonNull(keyStr));\n+            nonce = hex.parseHex(Objects.requireNonNull(nonceStr));\n+            if ((counter = ctr) < 0) {\n+                throw new IllegalArgumentException(\n+                        \"counter must be 0 or greater\");\n+            }\n+            direction = dir;\n+            if ((direction != Cipher.ENCRYPT_MODE) &&\n+                    (direction != Cipher.DECRYPT_MODE)) {\n+                throw new IllegalArgumentException(\n+                        \"Direction must be ENCRYPT_MODE or DECRYPT_MODE\");\n+            }\n+            input = hex.parseHex(Objects.requireNonNull(inputStr));\n+            aad = (aadStr != null) ? hex.parseHex(aadStr) : null;\n+            expOutput = hex.parseHex(Objects.requireNonNull(outStr));\n+        }\n+\n+        public final String testName;\n+        public final byte[] key;\n+        public final byte[] nonce;\n+        public final int counter;\n+        public final int direction;\n+        public final byte[] input;\n+        public final byte[] aad;\n+        public final byte[] expOutput;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        int testsPassed = 0;\n+        int testNumber = 0;\n+\n+        \/\/ Use the first test vector to warm up the JVM and activate\n+        \/\/ the intrinsics.\n+        System.out.println(\"Running \" + WARMUP_CYCLES + \" warm up cycles\");\n+        for (int i = 0; i < WARMUP_CYCLES; i++) {\n+            runSinglePartTest(testList.get(0));\n+        }\n+\n+        System.out.println(\"----- Single-part Tests -----\");\n+        for (TestData test : testList) {\n+            System.out.println(\"*** Test \" + ++testNumber + \": \" +\n+                    test.testName);\n+            if (runSinglePartTest(test)) {\n+                testsPassed++;\n+            }\n+        }\n+        System.out.println();\n+\n+        System.out.println(\"----- Multi-part Tests -----\");\n+        for (TestData test : testList) {\n+            System.out.println(\"*** Test \" + ++testNumber + \": \" +\n+                    test.testName);\n+            if (runMultiPartTest(test)) {\n+                testsPassed++;\n+            }\n+        }\n+        System.out.println();\n+\n+        System.out.println(\"Total tests: \" + testNumber +\n+                \", Passed: \" + testsPassed + \", Failed: \" +\n+                (testNumber - testsPassed));\n+        if (testsPassed != testNumber) {\n+            throw new RuntimeException(\"One or more tests failed.  \" +\n+                    \"Check output for details\");\n+        }\n+    }\n+\n+    private static boolean runSinglePartTest(TestData testData)\n+            throws GeneralSecurityException {\n+        boolean encRes = false;\n+        boolean decRes = false;\n+        byte[] encryptedResult;\n+        byte[] decryptedResult;\n+\n+        \/\/ Get a Cipher instance and set up the parameters\n+        Cipher mambo = Cipher.getInstance(\"ChaCha20\");\n+        SecretKeySpec mamboKey = new SecretKeySpec(testData.key, \"ChaCha20\");\n+        ChaCha20ParameterSpec mamboSpec = new ChaCha20ParameterSpec(\n+                testData.nonce, testData.counter);\n+\n+        \/\/ Encrypt our input\n+        mambo.init(Cipher.ENCRYPT_MODE, mamboKey, mamboSpec);\n+        encryptedResult = mambo.doFinal(testData.input);\n+\n+        if (!Arrays.equals(encryptedResult, testData.expOutput)) {\n+            System.out.println(\"ERROR - Output Mismatch!\");\n+            System.out.println(\"Expected:\\n\" +\n+                    dumpHexBytes(testData.expOutput, 16, \"\\n\", \" \"));\n+            System.out.println(\"Actual:\\n\" +\n+                    dumpHexBytes(encryptedResult, 16, \"\\n\", \" \"));\n+            System.out.println();\n+        } else {\n+            encRes = true;\n+        }\n+\n+        \/\/ Decrypt the result of the encryption operation\n+        mambo = Cipher.getInstance(\"ChaCha20\");\n+        mambo.init(Cipher.DECRYPT_MODE, mamboKey, mamboSpec);\n+        decryptedResult = mambo.doFinal(encryptedResult);\n+\n+        if (!Arrays.equals(decryptedResult, testData.input)) {\n+            System.out.println(\"ERROR - Output Mismatch!\");\n+            System.out.println(\"Expected:\\n\" +\n+                    dumpHexBytes(testData.input, 16, \"\\n\", \" \"));\n+            System.out.println(\"Actual:\\n\" +\n+                    dumpHexBytes(decryptedResult, 16, \"\\n\", \" \"));\n+            System.out.println();\n+        } else {\n+            decRes = true;\n+        }\n+\n+        return (encRes && decRes);\n+    }\n+\n+    private static boolean runMultiPartTest(TestData testData)\n+            throws GeneralSecurityException {\n+        boolean encRes = false;\n+        boolean decRes = false;\n+\n+        \/\/ Get a cipher instance and initialize it\n+        Cipher mambo = Cipher.getInstance(\"ChaCha20\");\n+        SecretKeySpec mamboKey = new SecretKeySpec(testData.key, \"ChaCha20\");\n+        ChaCha20ParameterSpec mamboSpec = new ChaCha20ParameterSpec(\n+                testData.nonce, testData.counter);\n+\n+        byte[] encryptedResult = new byte[testData.input.length];\n+        mambo.init(Cipher.ENCRYPT_MODE, mamboKey, mamboSpec);\n+        System.out.print(\"Encrypt - \");\n+        doMulti(mambo, testData.input, encryptedResult);\n+\n+        if (!Arrays.equals(encryptedResult, testData.expOutput)) {\n+            System.out.println(\"ERROR - Output Mismatch!\");\n+            System.out.println(\"Expected:\\n\" +\n+                    dumpHexBytes(testData.expOutput));\n+            System.out.println(\"Actual:\\n\" +\n+                    dumpHexBytes(encryptedResult));\n+            System.out.println();\n+        } else {\n+            encRes = true;\n+        }\n+\n+        \/\/ Decrypt the result of the encryption operation\n+        mambo = Cipher.getInstance(\"ChaCha20\");\n+        byte[] decryptedResult = new byte[encryptedResult.length];\n+        mambo.init(Cipher.DECRYPT_MODE, mamboKey, mamboSpec);\n+        System.out.print(\"Decrypt - \");\n+        doMulti(mambo, encryptedResult, decryptedResult);\n+\n+        if (!Arrays.equals(decryptedResult, testData.input)) {\n+            System.out.println(\"ERROR - Output Mismatch!\");\n+            System.out.println(\"Expected:\\n\" + dumpHexBytes(testData.input));\n+            System.out.println(\"Actual:\\n\" + dumpHexBytes(decryptedResult));\n+            System.out.println();\n+        } else {\n+            decRes = true;\n+        }\n+\n+        return (encRes && decRes);\n+    }\n+\n+    private static void doMulti(Cipher c, byte[] input, byte[] output)\n+            throws GeneralSecurityException {\n+        int offset = 0;\n+        boolean done = false;\n+        Random randIn = new Random(System.currentTimeMillis());\n+\n+        \/\/ Send small updates between 1 - 8 bytes in length until we get\n+        \/\/ 8 or less bytes from the end of the input, then finalize.\n+        System.out.println(\"Input length: \" + input.length);\n+        System.out.print(\"Multipart (bytes in\/out): \");\n+        while (!done) {\n+            int mPartLen = randIn.nextInt(8) + 1;\n+            int bytesLeft = input.length - offset;\n+            int processed;\n+            if (mPartLen < bytesLeft) {\n+                System.out.print(mPartLen + \"\/\");\n+                processed = c.update(input, offset, mPartLen,\n+                        output, offset);\n+                offset += processed;\n+                System.out.print(processed + \" \");\n+            } else {\n+                processed = c.doFinal(input, offset, bytesLeft,\n+                        output, offset);\n+                System.out.print(bytesLeft + \"\/\" + processed + \" \");\n+                done = true;\n+            }\n+        }\n+        System.out.println();\n+    }\n+\n+    private static String dumpHexBytes(byte[] data) {\n+        return dumpHexBytes(data, 16, \"\\n\", \" \");\n+    }\n+\n+    private static String dumpHexBytes(byte[] data, int itemsPerLine,\n+           String lineDelim, String itemDelim) {\n+        StringBuilder sb = new StringBuilder();\n+        if (data != null) {\n+            for (int i = 0; i < data.length; i++) {\n+                if (i % itemsPerLine == 0 && i != 0) {\n+                    sb.append(lineDelim);\n+                }\n+                sb.append(String.format(\"%02X\", data[i])).append(itemDelim);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/chacha\/ExerciseChaCha20.java","additions":317,"deletions":0,"binary":false,"changes":317,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.intrinsics.chacha;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.whitebox.cpuinfo.CPUInfo;\n+\n+\/**\n+ * @test\n+ * @bug 8247645\n+ * @summary ChaCha20 Intrinsics\n+ * @library \/test\/lib\n+ * @build   compiler.intrinsics.chacha.ExerciseChaCha20\n+ *          jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=7200\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      compiler.intrinsics.chacha.TestChaCha20\n+ *\/\n+public class TestChaCha20 {\n+\n+    \/\/ Default to 1\/4 of the CPUs, and allow users to override.\n+    static final int MAX_PARALLELISM = Integer.getInteger(\"maxParallelism\",\n+        Math.max(1, Runtime.getRuntime().availableProcessors() \/ 4));\n+\n+    private static List<String> mix(List<String> o, String... mix) {\n+        List<String> n = new ArrayList<>(o);\n+        for (String m : mix) {\n+            n.add(m);\n+        }\n+        return n;\n+    }\n+\n+    private static boolean containsFuzzy(List<String> list, String sub) {\n+        for (String s : list) {\n+            if (s.contains(sub)) return true;\n+        }\n+        return false;\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        List<List<String>> configs = new ArrayList<>();\n+        List<String> cpuFeatures = CPUInfo.getFeatures();\n+\n+        System.out.print(\"CPU Features: \");\n+        cpuFeatures.forEach(f -> System.out.print(f + \" \"));\n+        System.out.println();\n+\n+        if (Platform.isX64()) {\n+            \/\/ If CPU features were not found, provide a default config.\n+            if (cpuFeatures.isEmpty()) {\n+                configs.add(new ArrayList());\n+            }\n+\n+            \/\/ Otherwise, select the tests that make sense on current platform.\n+            if (containsFuzzy(cpuFeatures, \"avx512\")) {\n+                System.out.println(\"Setting up AVX512 worker\");\n+                configs.add(List.of(\"-XX:UseAVX=3\"));\n+            }\n+            if (containsFuzzy(cpuFeatures, \"avx2\")) {\n+                System.out.println(\"Setting up AVX2 worker\");\n+                configs.add(List.of(\"-XX:UseAVX=2\"));\n+            }\n+            if (containsFuzzy(cpuFeatures, \"avx\")) {\n+                System.out.println(\"Setting up AVX worker\");\n+                configs.add(List.of(\"-XX:UseAVX=1\"));\n+            }\n+        } else if (Platform.isAArch64()) {\n+            \/\/ AArch64 intrinsics require the advanced simd instructions\n+            if (containsFuzzy(cpuFeatures, \"simd\")) {\n+                System.out.println(\"Setting up ASIMD worker\");\n+                configs.add(new ArrayList());\n+            }\n+        } else {\n+            \/\/ We only have ChaCha20 intrinsics on x64 and aarch64\n+            \/\/ currently.  If the platform is neither of these then\n+            \/\/ the ChaCha20 known answer tests in\n+            \/\/ com\/sun\/crypto\/provider\/Cipher are sufficient.\n+            return;\n+        }\n+\n+        \/\/ If by this point we have no configs, it means we are running\n+        \/\/ on a platform that intrinsics have been written for, but does\n+        \/\/ not possess the necessary instruction sets for that processor.\n+        \/\/ We can exit out if that is the case.\n+        if (configs.isEmpty()) {\n+            System.out.println(\"No intrinsics-capable configurations found\");\n+            return;\n+        }\n+\n+        \/\/ We can expand this array later to include other tests if new\n+        \/\/ ChaCha20 intrinsics are developed.\n+        String[] classNames = {\n+            \"compiler.intrinsics.chacha.ExerciseChaCha20\"\n+        };\n+\n+        ArrayList<Fork> forks = new ArrayList<>();\n+        int jobs = 0;\n+\n+        for (List<String> c : configs) {\n+            for (String className : classNames) {\n+                \/\/ Start a new job\n+                {\n+                    ProcessBuilder pb = ProcessTools.createTestJvm(\n+                            mix(c, \"-Xmx256m\", className));\n+                    Process p = pb.start();\n+                    OutputAnalyzer oa = new OutputAnalyzer(p);\n+                    forks.add(new Fork(p, oa));\n+                    jobs++;\n+                }\n+\n+                \/\/ Wait for the completion of other jobs\n+                while (jobs >= MAX_PARALLELISM) {\n+                    Fork f = findDone(forks);\n+                    if (f != null) {\n+                        OutputAnalyzer oa = f.oa();\n+                        oa.shouldHaveExitValue(0);\n+                        forks.remove(f);\n+                        jobs--;\n+                    } else {\n+                        \/\/ Nothing is done, wait a little.\n+                        Thread.sleep(200);\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ Drain the rest\n+        for (Fork f : forks) {\n+            OutputAnalyzer oa = f.oa();\n+            oa.shouldHaveExitValue(0);\n+        }\n+    }\n+\n+    private static Fork findDone(List<Fork> forks) {\n+        for (Fork f : forks) {\n+            if (!f.p().isAlive()) {\n+                return f;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static record Fork(Process p, OutputAnalyzer oa) {};\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/chacha\/TestChaCha20.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -135,1 +135,1 @@\n-        t.runTest(methodObjClassCast,  false,  svalue);\n+        t.runTest(methodObjClassCast,  true,  svalue);\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/klass\/CastNullCheckDroppingsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,9 @@\n- * Tests {@link HotSpotResolvedJavaField} functionality.\n+ *\n+ * @test\n+ * @requires vm.jvmci\n+ * @summary Tests HotSpotResolvedJavaField functionality\n+ * @library ..\/..\/..\/..\/..\/\n+ * @modules jdk.internal.vm.ci\/jdk.vm.ci.meta\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.runtime\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n+ * @run junit\/othervm --add-opens=jdk.internal.vm.ci\/jdk.vm.ci.hotspot=ALL-UNNAMED -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler jdk.vm.ci.hotspot.test.HotSpotResolvedJavaFieldTest\n@@ -64,1 +72,1 @@\n-            m = typeImpl.getDeclaredMethod(\"createField\", JavaType.class, long.class, int.class, int.class);\n+            m = typeImpl.getDeclaredMethod(\"createField\", JavaType.class, int.class, int.class, int.class);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/HotSpotResolvedJavaFieldTest.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8297556\n- * @summary Parse::check_interpreter_type fails with assert \"must constrain OSR typestate\"\n- *\n- * @run main\/othervm -Xbatch -XX:-TieredCompilation -XX:CompileOnly=TestExactArrayOfBasicType::test TestExactArrayOfBasicType\n- *\n- *\/\n-\n-\n-public class TestExactArrayOfBasicType {\n-    public static void test() {\n-        int[][][][][] array = new int[1][2][3][4][5];\n-\n-        for (int i = 0; i < 50_000; ++i) {\n-            array[0] = new int[0][1][2][3];\n-        }\n-    }\n-\n-    public static void main(String args[]) {\n-        test();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/types\/TestExactArrayOfBasicType.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8296924\n+ * @summary Tests compilation of an unreachable unsafe access with a bad base address.\n+ * @modules java.base\/jdk.internal.misc:+open\n+ * @run main\/othervm -XX:CompileCommand=compileonly,TestBadBaseAddress::test -XX:-TieredCompilation -Xcomp TestBadBaseAddress\n+ *\/\n+\n+import java.lang.reflect.*;\n+import sun.misc.*;\n+\n+public class TestBadBaseAddress {\n+    private static Unsafe unsafe;\n+\n+    static {\n+        try {\n+            Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");\n+            field.setAccessible(true);\n+            unsafe = (Unsafe)field.get(null);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static void test(boolean b) {\n+        if (b) {\n+            unsafe.putLong(-1, 42);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        test(false);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/TestBadBaseAddress.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+import java.util.Random;\n+\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8293488\n+ * @summary Test EOR3 Neon\/SVE2 instruction for aarch64 SHA3 extension\n+ * @library \/test\/lib \/\n+ * @requires os.arch == \"aarch64\"\n+ * @run driver compiler.vectorization.TestEor3AArch64\n+ *\/\n+\n+public class TestEor3AArch64 {\n+\n+    private static final int LENGTH = 2048;\n+    private static final Random RD = Utils.getRandomInstance();\n+\n+    private static int[] ia;\n+    private static int[] ib;\n+    private static int[] ic;\n+    private static int[] ir;\n+\n+    private static long[] la;\n+    private static long[] lb;\n+    private static long[] lc;\n+    private static long[] lr;\n+\n+    static {\n+        ia = new int[LENGTH];\n+        ib = new int[LENGTH];\n+        ic = new int[LENGTH];\n+        ir = new int[LENGTH];\n+\n+        la = new long[LENGTH];\n+        lb = new long[LENGTH];\n+        lc = new long[LENGTH];\n+        lr = new long[LENGTH];\n+\n+        for (int i = 0; i < LENGTH; i++) {\n+            ia[i] = RD.nextInt(30);\n+            ib[i] = RD.nextInt(30);\n+            ic[i] = RD.nextInt(30);\n+\n+            la[i] = RD.nextLong(30);\n+            lb[i] = RD.nextLong(30);\n+            lc[i] = RD.nextLong(30);\n+        }\n+    }\n+\n+    \/\/ Test for eor3 Neon and SVE2 instruction for integers\n+    @Test\n+    @IR(counts = {\"veor3_neon\", \"> 0\"}, applyIf = {\"MaxVectorSize\", \"16\"}, applyIfCPUFeature = {\"sha3\", \"true\"})\n+    @IR(counts = {\"veor3_sve\", \"> 0\"}, applyIfAnd = {\"UseSVE\", \"2\", \"MaxVectorSize\", \"> 16\"})\n+    public static void testIntEor3() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            ir[i] = ia[i] ^ ib[i] ^ ic[i];\n+        }\n+    }\n+\n+    @Run(test = \"testIntEor3\")\n+    public static void testIntEor3_runner() {\n+        testIntEor3();\n+        for (int i = 0; i < LENGTH; i++) {\n+            Asserts.assertEquals((ia[i] ^ ib[i] ^ ic[i]), ir[i]);\n+        }\n+    }\n+\n+    \/\/ Test for eor3 Neon and SVE2 instruction for longs\n+    @Test\n+    @IR(counts = {\"veor3_neon\", \"> 0\"}, applyIf = {\"MaxVectorSize\", \"16\"}, applyIfCPUFeature = {\"sha3\", \"true\"})\n+    @IR(counts = {\"veor3_sve\", \"> 0\"}, applyIfAnd = {\"UseSVE\", \"2\", \"MaxVectorSize\", \"> 16\"})\n+    public static void testLongEor3() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            lr[i] = la[i] ^ lb[i] ^ lc[i];\n+        }\n+    }\n+\n+    @Run(test = \"testLongEor3\")\n+    public static void testLongEor3_runner() {\n+        testLongEor3();\n+        for (int i = 0; i < LENGTH; i++) {\n+            Asserts.assertEquals((la[i] ^ lb[i] ^ lc[i]), lr[i]);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestEor3AArch64.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8210559\n+ * @bug 8210559 8297740\n@@ -38,0 +38,2 @@\n+import java.lang.reflect.Array;\n+\n@@ -39,1 +41,1 @@\n- * Test that verifies that classes are unloaded when they are no longer reachable.\n+ * Test that verifies that liveness of classes is correctly tracked.\n@@ -41,4 +43,6 @@\n- * The test creates a class loader, uses the loader to load a class and creates an instance\n- * of that class. The it nulls out all the references to the instance, class and class loader\n- * and tries to trigger class unloading. Then it verifies that the class is no longer\n- * loaded by the VM.\n+ * The test creates a class loader, uses the loader to load a class and creates\n+ * an instance related to that class.\n+ * 1. Then, it nulls out references to the class loader, triggers class\n+ *    unloading and verifies the class is *not* unloaded.\n+ * 2. Next, it nulls out references to the instance, triggers class unloading\n+ *    and verifies the class is unloaded.\n@@ -47,1 +51,2 @@\n-    private static String className = \"test.Empty\";\n+    \/\/ Using a global static field to keep the object live in -Xcomp mode.\n+    private static Object o;\n@@ -50,1 +55,2 @@\n-       run();\n+       test_unload_instance_klass();\n+       test_unload_obj_array_klass();\n@@ -53,1 +59,2 @@\n-    private static void run() throws Exception {\n+    private static void test_unload_instance_klass() throws Exception {\n+        final String className = \"test.Empty\";\n@@ -59,2 +66,1 @@\n-        Class<?> c = cl.loadClass(className);\n-        Object o = c.newInstance();\n+        o = cl.loadClass(className).newInstance();\n@@ -68,1 +74,6 @@\n-        cl = null; c = null; o = null;\n+        cl = null;\n+        ClassUnloadCommon.triggerUnloading();\n+\n+        ClassUnloadCommon.failIf(!wb.isClassAlive(className), \"should still be live\");\n+\n+        o = null;\n@@ -70,0 +81,29 @@\n+\n+\n+        ClassUnloadCommon.failIf(wb.isClassAlive(className), \"should have been unloaded\");\n+\n+        int unloadedRefcount = wb.getSymbolRefcount(loaderName);\n+        System.out.println(\"Refcount of symbol \" + loaderName + \" is \" + unloadedRefcount);\n+        ClassUnloadCommon.failIf(unloadedRefcount != (loadedRefcount - 1), \"Refcount must be decremented\");\n+    }\n+\n+    private static void test_unload_obj_array_klass() throws Exception {\n+        final WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+        ClassLoader cl = ClassUnloadCommon.newClassLoader();\n+        o = Array.newInstance(cl.loadClass(\"test.Empty\"), 1);\n+        final String className = o.getClass().getName();\n+\n+        ClassUnloadCommon.failIf(!wb.isClassAlive(className), \"should be live here\");\n+\n+        String loaderName = cl.getName();\n+        int loadedRefcount = wb.getSymbolRefcount(loaderName);\n+        System.out.println(\"Refcount of symbol \" + loaderName + \" is \" + loadedRefcount);\n+\n+        cl = null;\n+        ClassUnloadCommon.triggerUnloading();\n+        ClassUnloadCommon.failIf(!wb.isClassAlive(className), \"should still be live\");\n+\n+        o = null;\n+        ClassUnloadCommon.triggerUnloading();\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassUnload\/UnloadTest.java","additions":52,"deletions":12,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test Make sure class unloading occur even if ClassLoaderStats VM operations are executed\n+ * @bug 8297427\n+ * @requires vm.opt.final.ClassUnloading\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib classes\n+ * @build jdk.test.whitebox.WhiteBox test.Empty test.LoadInParent test.LoadInChild\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xlog:gc*,class+unload=debug UnloadTestDuringClassLoaderStatsVMOperation\n+ *\/\n+import java.lang.ref.Reference;\n+import java.net.URLClassLoader;\n+\n+import jdk.test.lib.classloader.ClassUnloadCommon;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class UnloadTestDuringClassLoaderStatsVMOperation {\n+    private static final WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    private static String className = \"test.Empty\";\n+    private static String parentClassName = \"test.LoadInParent\";\n+    private static String childClassName = \"test.LoadInChild\";\n+\n+    public static void main(String args[]) throws Exception {\n+        \/\/ Create a thread forcing ClassLoaderStats VM operations.\n+        var clsThread = new Thread(() -> {\n+            while (true) {\n+                wb.forceClassLoaderStatsSafepoint();\n+            }\n+        });\n+        clsThread.setDaemon(true);\n+        clsThread.start();\n+\n+        \/\/ Make sure classes can be unloaded even though the class loader\n+        \/\/ stats VM operation is running.\n+        testClassIsUnloaded();\n+        testClassLoadedInParentIsUnloaded();\n+    }\n+\n+    public static void testClassIsUnloaded() throws Exception {\n+        ClassUnloadCommon.failIf(wb.isClassAlive(className), className + \" is not expected to be alive yet\");\n+\n+        \/\/ Load a test class and verify that it gets unloaded once we do a major collection.\n+        var classLoader = ClassUnloadCommon.newClassLoader();\n+        var loaded = classLoader.loadClass(className);\n+        var object = loaded.getDeclaredConstructor().newInstance();\n+\n+        ClassUnloadCommon.failIf(!wb.isClassAlive(className), className + \" should be loaded and live\");\n+\n+        \/\/ Using reachabilityFence() to ensure the object is live. If the test\n+        \/\/ is run with -Xcomp and ergonomically triggered GCs occur the class\n+        \/\/ could otherwise be unloaded before verified to be alive above.\n+        Reference.reachabilityFence(object);\n+\n+        System.out.println(\"testClassIsUnloaded loaded klass: \" + className);\n+\n+        \/\/ Make class unloadable.\n+        classLoader = null;\n+        loaded = null;\n+        object = null;\n+\n+        \/\/ Full\/Major collection should always unload classes.\n+        wb.fullGC();\n+        ClassUnloadCommon.failIf(wb.isClassAlive(className), className + \" should have been unloaded\");\n+    }\n+\n+    public static void testClassLoadedInParentIsUnloaded() throws Exception {\n+        ClassUnloadCommon.failIf(wb.isClassAlive(parentClassName), parentClassName + \" is not expected to be alive yet\");\n+        ClassUnloadCommon.failIf(wb.isClassAlive(childClassName), childClassName + \" is not expected to be alive yet\");\n+\n+        \/\/ Create two class loaders and load a test class in the parent and\n+        \/\/ verify that it gets unloaded once we do a major collection.\n+        var parentClassLoader = ClassUnloadCommon.newClassLoader();\n+        var childClassLoader =  new ChildURLClassLoader((URLClassLoader) parentClassLoader);\n+        var loadedParent = parentClassLoader.loadClass(parentClassName);\n+        var loadedChild = childClassLoader.loadClass(childClassName);\n+        var parent = loadedParent.getDeclaredConstructor().newInstance();\n+        var child = loadedChild.getDeclaredConstructor().newInstance();\n+\n+        ClassUnloadCommon.failIf(!wb.isClassAlive(parentClassName), parentClassName + \" should be loaded and live\");\n+        ClassUnloadCommon.failIf(!wb.isClassAlive(childClassName), childClassName + \" should be loaded and live\");\n+\n+        \/\/ Using reachabilityFence() to ensure the objects are live. If the test\n+        \/\/ is run with -Xcomp and ergonomically triggered GCs occur they could\n+        \/\/ otherwise be unloaded before verified to be alive above.\n+        Reference.reachabilityFence(parent);\n+        Reference.reachabilityFence(child);\n+\n+        System.out.println(\"testClassLoadedInParentIsUnloaded loaded klass: \" + loadedParent);\n+        System.out.println(\"testClassLoadedInParentIsUnloaded loaded klass: \" + loadedChild);\n+\n+        \/\/ Clear to allow unloading.\n+        parentClassLoader = null;\n+        childClassLoader = null;\n+        loadedParent = null;\n+        loadedChild = null;\n+        parent = null;\n+        child = null;\n+\n+        \/\/ Full\/Major collection should always unload classes.\n+        wb.fullGC();\n+        ClassUnloadCommon.failIf(wb.isClassAlive(parentClassName), parentClassName + \" should have been unloaded\");\n+        ClassUnloadCommon.failIf(wb.isClassAlive(childClassName), childClassName + \" should have been unloaded\");\n+    }\n+\n+    static class ChildURLClassLoader extends URLClassLoader {\n+        public ChildURLClassLoader(URLClassLoader parent) {\n+            super(\"ChildURLClassLoader\", parent.getURLs(), parent);\n+        }\n+\n+        @Override\n+        public Class<?> loadClass(String cn, boolean resolve) throws ClassNotFoundException {\n+            synchronized (getClassLoadingLock(cn)) {\n+                Class<?> c = findLoadedClass(cn);\n+                if (c == null) {\n+                    try {\n+                        c = findClass(cn);\n+                    } catch (ClassNotFoundException e) {\n+                        c = getParent().loadClass(cn);\n+                    }\n+                }\n+                if (resolve) {\n+                    resolveClass(c);\n+                }\n+                return c;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassUnload\/UnloadTestDuringClassLoaderStatsVMOperation.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package test;\n+\n+public class LoadInChild {\n+    public String toString() { return \"Load In Child\"; }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassUnload\/classes\/test\/LoadInChild.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package test;\n+\n+public class LoadInParent {\n+    public String toString() { return \"Load In Parent\"; }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassUnload\/classes\/test\/LoadInParent.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,16 +61,1 @@\n-    String hs_err_file = output_detail.firstMatch(\"# *(\\\\S*hs_err_pid\\\\d+\\\\.log)\", 1);\n-    if (hs_err_file == null) {\n-        throw new RuntimeException(\"Did not find hs-err file in output.\\n\");\n-    }\n-\n-    File f = new File(hs_err_file);\n-    if (!f.exists()) {\n-        throw new RuntimeException(\"hs-err file missing at \" +\n-                                   f.getAbsolutePath() + \".\\n\");\n-    }\n-\n-    System.out.println(\"Found hs_err file. Scanning...\");\n-\n-    FileInputStream fis = new FileInputStream(f);\n-    BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n-    String line = null;\n+    File hs_err_file = HsErrFileUtils.openHsErrFileFromOutput(output_detail);\n@@ -80,13 +65,3 @@\n-    Pattern pattern =\n-        Pattern.compile(\"\\\\[error occurred during error reporting \\\\(printing native stack\\\\), id .*\\\\]\");\n-\n-    String lastLine = null;\n-    while ((line = br.readLine()) != null) {\n-        if (pattern.matcher(line).matches()) {\n-            System.out.println(\"Found: \" + line + \".\");\n-            throw new RuntimeException(\"hs-err file should not contain: '\" +\n-                                       pattern + \"'\");\n-        }\n-        lastLine = line;\n-    }\n-    br.close();\n+    Pattern negativePatterns[] = {\n+        Pattern.compile(\"\\\\[error occurred during error reporting \\\\(printing native stack\\\\), id .*\\\\]\")\n+    };\n@@ -94,5 +69,1 @@\n-    if (!lastLine.equals(\"END.\")) {\n-        throw new RuntimeException(\"hs-err file incomplete (missing END marker.)\");\n-    } else {\n-        System.out.println(\"End marker found.\");\n-    }\n+    HsErrFileUtils.checkHsErrFileContent(hs_err_file, null, negativePatterns, true \/* check end marker *\/, false \/* verbose *\/);\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/BadNativeStackInErrorHandlingTest.java","additions":6,"deletions":35,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.*;\n@@ -50,2 +51,0 @@\n-     * @param output\n-     * @return\n@@ -63,2 +62,7 @@\n-     * Given an open hs-err file, read it line by line and check for pattern. Pattern\n-     * need to appear in order, but not necessarily uninterrupted.\n+     * Given an open hs-err file, read it line by line and check for existence of a set of patterns. Will fail\n+     * if patterns are missing, or if the END marker is missing.\n+     * @param f Input file\n+     * @param patterns An array of patterns that need to match, in that order\n+     * @param verbose If true, the content of the hs-err file is printed while matching. If false, only the matched patterns\n+     *                are printed.\n+     * @throws RuntimeException, {@link IOException}\n@@ -67,0 +71,2 @@\n+        checkHsErrFileContent(f, patterns, null, true, verbose);\n+    }\n@@ -68,10 +74,25 @@\n-        FileInputStream fis = new FileInputStream(f);\n-        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n-        String line = null;\n-\n-        int currentPattern = 0;\n-\n-        String lastLine = null;\n-        while ((line = br.readLine()) != null) {\n-            if (verbose) {\n-                System.out.println(line);\n+    \/**\n+     * Given an open hs-err file, read it line by line and check for various conditions.\n+     * @param f input file\n+     * @param positivePatterns Optional array of patterns that need to appear, in given order, in the file. Missing\n+     *                        patterns cause the test to fail.\n+     * @param negativePatterns Optional array of patterns that must not appear in the file; test fails if they do.\n+     *                        Order is irrelevant.\n+     * @param checkEndMarker If true, we check for the final \"END\" in an hs-err file; if it is missing it indicates\n+     *                        that hs-err file printing did not complete successfully.\n+     * @param verbose If true, the content of the hs-err file is printed while matching. If false, only important\n+     *               information are printed.\n+     * @throws RuntimeException, {@link IOException}\n+     *\/\n+    public static void checkHsErrFileContent(File f, Pattern[] positivePatterns, Pattern[] negativePatterns, boolean checkEndMarker, boolean verbose) throws IOException {\n+        try (\n+                FileInputStream fis = new FileInputStream(f);\n+                BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n+        ) {\n+            String line = null;\n+            String lastLine = null;\n+            int lineNo = 0;\n+\n+            Deque<Pattern> positivePatternStack = new ArrayDeque<Pattern>();\n+            if (positivePatterns != null) {\n+                Collections.addAll(positivePatternStack, positivePatterns);\n@@ -79,4 +100,28 @@\n-            if (currentPattern < patterns.length) {\n-                if (patterns[currentPattern].matcher(line).matches()) {\n-                    if (!verbose) {\n-                        System.out.println(line);\n+            Pattern currentPositivePattern = positivePatternStack.pollFirst();\n+\n+            while ((line = br.readLine()) != null) {\n+                if (verbose) {\n+                    System.out.println(line);\n+                }\n+                if (currentPositivePattern != null) {\n+                    if (currentPositivePattern.matcher(line).matches()) {\n+                        if (!verbose) {\n+                            System.out.println(line);\n+                        }\n+                        System.out.println(\"^^^ Matches \" + currentPositivePattern + \" at line \" + lineNo + \"^^^\");\n+                        currentPositivePattern = positivePatternStack.pollFirst();\n+                        if (currentPositivePattern == null && negativePatterns == null && checkEndMarker == false) {\n+                            System.out.println(\"Lazily skipping the rest of the hs-err file...\");\n+                            break; \/\/ Shortcut. Nothing to do.\n+                        }\n+                    }\n+                }\n+                if (negativePatterns != null) {\n+                    for (Pattern negativePattern : negativePatterns) {\n+                        if (negativePattern.matcher(line).matches()) {\n+                            if (!verbose) {\n+                                System.out.println(line);\n+                            }\n+                            System.out.println(\"^^^ Forbidden pattern found at line \" + lineNo + \": \" + negativePattern + \"^^^\");\n+                            throw new RuntimeException(\"Forbidden pattern found at line \" + lineNo + \": \" + negativePattern);\n+                        }\n@@ -84,2 +129,0 @@\n-                    System.out.println(\"^^^ Match \" + currentPattern + \": matches \" + patterns[currentPattern] + \"^^^\");\n-                    currentPattern ++;\n@@ -87,0 +130,2 @@\n+                lastLine = line;\n+                lineNo++;\n@@ -88,11 +133,8 @@\n-            lastLine = line;\n-        }\n-        br.close();\n-\n-        if (currentPattern < patterns.length) {\n-            throw new RuntimeException(\"hs-err file incomplete (found \" + currentPattern + \" matching pattern, \" +\n-                                       \"first missing pattern: \" + patterns[currentPattern] + \")\");\n-        }\n-\n-        if (!lastLine.equals(\"END.\")) {\n-            throw new RuntimeException(\"hs-err file incomplete (missing END marker.)\");\n+            \/\/ Found all positive pattern?\n+            if (!positivePatternStack.isEmpty()) {\n+                throw new RuntimeException(\"hs-err file incomplete (first missing pattern: \" + positivePatternStack.peek() + \")\");\n+            }\n+            if (checkEndMarker && !lastLine.equals(\"END.\")) {\n+                throw new RuntimeException(\"hs-err file incomplete (missing END marker.)\");\n+            }\n+            System.out.println(\"hs-err file \" + f.getAbsolutePath() + \" scanned successfully.\");\n@@ -100,3 +142,0 @@\n-\n-        System.out.println(\"Found all expected pattern in hs-err file at \" + f.getAbsolutePath());\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/HsErrFileUtils.java","additions":73,"deletions":34,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.io.File;\n@@ -129,6 +130,2 @@\n-        String hs_err_file = output.firstMatch(\"# *(\\\\S*hs_err_pid\\\\d+\\\\.log)\", 1);\n-        if (hs_err_file == null) {\n-            output.reportDiagnosticSummary();\n-            throw new RuntimeException(\"Did not find hs_err_pid file in output\");\n-        }\n-        Path hsErrPath = Paths.get(hs_err_file);\n+        File hs_err_file = HsErrFileUtils.openHsErrFileFromOutput(output);\n+        Path hsErrPath = hs_err_file.toPath();\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/MachCodeFramesInErrorFile.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,16 +73,1 @@\n-    String hs_err_file = output_detail.firstMatch(\"# *(\\\\S*hs_err_pid\\\\d+\\\\.log)\", 1);\n-    if (hs_err_file == null) {\n-        throw new RuntimeException(\"Did not find hs_err_pid file in output.\\n\");\n-    }\n-\n-    File f = new File(hs_err_file);\n-    if (!f.exists()) {\n-        throw new RuntimeException(\"hs_err_pid file missing at \"\n-                                   + f.getAbsolutePath() + \".\\n\");\n-    }\n-\n-    System.out.println(\"Found hs_err_pid file. Scanning...\");\n-\n-    FileInputStream fis = new FileInputStream(f);\n-    BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n-    String line = null;\n+    File hs_err_file = HsErrFileUtils.openHsErrFileFromOutput(output_detail);\n@@ -104,17 +89,0 @@\n-    int currentPattern = 0;\n-\n-    String lastLine = null;\n-    while ((line = br.readLine()) != null) {\n-        if (currentPattern < pattern.length) {\n-            if (pattern[currentPattern].matcher(line).matches()) {\n-                System.out.println(\"Found: \" + line + \".\");\n-                currentPattern++;\n-            }\n-        }\n-        lastLine = line;\n-    }\n-    br.close();\n-\n-    if (currentPattern < pattern.length) {\n-        throw new RuntimeException(\"hs_err_pid file incomplete (first missing pattern: \" +  currentPattern + \")\");\n-    }\n@@ -122,5 +90,1 @@\n-    if (!lastLine.equals(\"END.\")) {\n-        throw new RuntimeException(\"hs-err file incomplete (missing END marker.)\");\n-    } else {\n-        System.out.println(\"End marker found.\");\n-    }\n+    HsErrFileUtils.checkHsErrFileContent(hs_err_file, pattern, false);\n@@ -128,1 +92,0 @@\n-    System.out.println(\"Done scanning hs_err_pid_file.\");\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/NestedThreadsListHandleInErrorHandlingTest.java","additions":3,"deletions":40,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -66,4 +66,1 @@\n-    String hs_err_file = output_detail.firstMatch(\"# *(\\\\S*hs_err_pid\\\\d+\\\\.log)\", 1);\n-    if (hs_err_file == null) {\n-      throw new RuntimeException(\"Did not find hs-err file in output.\\n\");\n-    }\n+    File hs_err_file = HsErrFileUtils.openHsErrFileFromOutput(output_detail);\n@@ -76,13 +73,1 @@\n-    File f = new File(hs_err_file);\n-    if (!f.exists()) {\n-      throw new RuntimeException(\"hs-err file missing at \"\n-          + f.getAbsolutePath() + \".\\n\");\n-    }\n-\n-    System.out.println(\"Found hs_err file. Scanning...\");\n-\n-    FileInputStream fis = new FileInputStream(f);\n-    BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n-    String line = null;\n-\n-    Pattern [] pattern = new Pattern[] {\n+    Pattern [] negativePattern = new Pattern[] {\n@@ -91,17 +76,0 @@\n-    int currentPattern = 0;\n-\n-    String lastLine = null;\n-    while ((line = br.readLine()) != null) {\n-      if (currentPattern < pattern.length) {\n-        if (pattern[currentPattern].matcher(line).matches()) {\n-          System.out.println(\"Found: \" + line + \".\");\n-          currentPattern ++;\n-        }\n-      }\n-      lastLine = line;\n-    }\n-    br.close();\n-\n-    if (currentPattern == pattern.length) {\n-      throw new RuntimeException(\"hs-err file found secondary crash for ResourceMark\");\n-    }\n@@ -109,5 +77,1 @@\n-    if (!lastLine.equals(\"END.\")) {\n-      throw new RuntimeException(\"hs-err file incomplete (missing END marker.)\");\n-    } else {\n-      System.out.println(\"End marker found.\");\n-    }\n+    HsErrFileUtils.checkHsErrFileContent(hs_err_file, null, negativePattern, true \/* check end marker *\/, false \/* verbose *\/);\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/ResourceMarkTest.java","additions":3,"deletions":39,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,16 +64,1 @@\n-    String hs_err_file = output_detail.firstMatch(\"# *(\\\\S*hs_err_pid\\\\d+\\\\.log)\", 1);\n-    if (hs_err_file == null) {\n-      throw new RuntimeException(\"Did not find hs-err file in output.\\n\");\n-    }\n-\n-    File f = new File(hs_err_file);\n-    if (!f.exists()) {\n-      throw new RuntimeException(\"hs-err file missing at \"\n-          + f.getAbsolutePath() + \".\\n\");\n-    }\n-\n-    System.out.println(\"Found hs_err file. Scanning...\");\n-\n-    FileInputStream fis = new FileInputStream(f);\n-    BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n-    String line = null;\n+    File hs_err_file = HsErrFileUtils.openHsErrFileFromOutput(output_detail);\n@@ -80,0 +66,2 @@\n+    \/\/ File should contain \"Will test SafeFetch, SafeFetch OK\". The latter indicates we survived the SafeFetch without\n+    \/\/ a secondary crash.\n@@ -84,17 +72,0 @@\n-    int currentPattern = 0;\n-\n-    String lastLine = null;\n-    while ((line = br.readLine()) != null) {\n-      if (currentPattern < pattern.length) {\n-        if (pattern[currentPattern].matcher(line).matches()) {\n-          System.out.println(\"Found: \" + line + \".\");\n-          currentPattern ++;\n-        }\n-      }\n-      lastLine = line;\n-    }\n-    br.close();\n-\n-    if (currentPattern < pattern.length) {\n-      throw new RuntimeException(\"hs-err file incomplete (first missing pattern: \" +  currentPattern + \")\");\n-    }\n@@ -102,5 +73,1 @@\n-    if (!lastLine.equals(\"END.\")) {\n-      throw new RuntimeException(\"hs-err file incomplete (missing END marker.)\");\n-    } else {\n-      System.out.println(\"End marker found.\");\n-    }\n+    HsErrFileUtils.checkHsErrFileContent(hs_err_file, pattern, true);\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/SafeFetchInErrorHandlingTest.java","additions":6,"deletions":39,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +28,1 @@\n- * @bug 8065896\n+ * @bug 8065895\n@@ -66,4 +67,1 @@\n-    String hs_err_file = output_detail.firstMatch(\"# *(\\\\S*hs_err_pid\\\\d+\\\\.log)\", 1);\n-    if (hs_err_file == null) {\n-      throw new RuntimeException(\"Did not find hs-err file in output.\\n\");\n-    }\n+    File hs_err_file = HsErrFileUtils.openHsErrFileFromOutput(output_detail);\n@@ -76,11 +74,0 @@\n-    File f = new File(hs_err_file);\n-    if (!f.exists()) {\n-      throw new RuntimeException(\"hs-err file missing at \"\n-          + f.getAbsolutePath() + \".\\n\");\n-    }\n-\n-    System.out.println(\"Found hs_err file. Scanning...\");\n-\n-    FileInputStream fis = new FileInputStream(f);\n-    BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n-    String line = null;\n@@ -94,23 +81,2 @@\n-    int currentPattern = 0;\n-\n-    String lastLine = null;\n-    while ((line = br.readLine()) != null) {\n-      if (currentPattern < pattern.length) {\n-        if (pattern[currentPattern].matcher(line).matches()) {\n-          System.out.println(\"Found: \" + line + \".\");\n-          currentPattern ++;\n-        }\n-      }\n-      lastLine = line;\n-    }\n-    br.close();\n-\n-    if (currentPattern < pattern.length) {\n-      throw new RuntimeException(\"hs-err file incomplete (first missing pattern: \" +  currentPattern + \")\");\n-    }\n-\n-    if (!lastLine.equals(\"END.\")) {\n-      throw new RuntimeException(\"hs-err file incomplete (missing END marker.)\");\n-    } else {\n-      System.out.println(\"End marker found.\");\n-    }\n+\n+    HsErrFileUtils.checkHsErrFileContent(hs_err_file, pattern, false);\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/SecondaryErrorTest.java","additions":6,"deletions":40,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2018, 2022 SAP SE. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/ShowRegistersOnAssertTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import java.util.regex.Pattern;\n@@ -91,4 +92,1 @@\n-        String hs_err_file = output.firstMatch(\"# *(\\\\S*hs_err_pid\\\\d+\\\\.log)\", 1);\n-        if (hs_err_file == null) {\n-            throw new Error(\"Did not find hs-err file in output.\\n\");\n-        }\n+        File hs_err_file = HsErrFileUtils.openHsErrFileFromOutput(output);\n@@ -96,7 +94,6 @@\n-        \/*\n-         * Check if hs_err files exist or not\n-         *\/\n-        File f = new File(hs_err_file);\n-        if (!f.exists()) {\n-            throw new Error(\"hs-err file missing at \"+ f.getAbsolutePath() + \".\\n\");\n-        }\n+        \/\/ Do a perfunctory check of the hs-err file produced by the crash.\n+        Pattern[] pattern = new Pattern[] {\n+            Pattern.compile(\".*fatal error: OutOfMemory encountered: Requested array size exceeds VM limit.*\")\n+        };\n+\n+        HsErrFileUtils.checkHsErrFileContent(hs_err_file, pattern, false);\n@@ -104,17 +101,0 @@\n-        \/*\n-         * Checking the completness of hs_err file. If last line of hs_err file is \"END\"\n-         * then it proves that file is complete.\n-         *\/\n-        try (FileInputStream fis = new FileInputStream(f);\n-            BufferedReader br = new BufferedReader(new InputStreamReader(fis))) {\n-            String line = null;\n-            String lastLine = null;\n-            while ((line = br.readLine()) != null) {\n-                lastLine = line;\n-            }\n-            if (!lastLine.equals(\"END.\")) {\n-                throw new Error(\"hs-err file incomplete (missing END marker.)\");\n-            } else {\n-                System.out.println(\"End marker found.\");\n-            }\n-        }\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/TestCrashOnOutOfMemoryError.java","additions":9,"deletions":29,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -126,2 +126,0 @@\n-        Pattern pattern = Pattern.compile(\"hs_err_pid[0-9]*.log\");\n-        Matcher matcher = pattern.matcher(crashOutputString);\n@@ -129,5 +127,4 @@\n-        if (matcher.find()) {\n-            String hsErrFileName = matcher.group();\n-            System.out.println(\"hs_err_file: \" + hsErrFileName);\n-            File hs_err_file = new File(hsErrFileName);\n-            BufferedReader reader = new BufferedReader(new FileReader(hs_err_file));\n+\n+        File hs_err_file = HsErrFileUtils.openHsErrFileFromOutput(crashOut);\n+        try (FileReader fr = new FileReader(hs_err_file);\n+             BufferedReader reader = new BufferedReader(fr)) {\n@@ -138,0 +135,1 @@\n+            Pattern pattern = Pattern.compile(\"[CV][\\\\s\\\\t]+\\\\[([a-zA-Z0-9_.]+)\\\\+0x.+][\\\\s\\\\t]+.*\\\\+0x.+[\\\\s\\\\t]+\\\\([a-zA-Z0-9_.]+\\\\.[a-z]+:[1-9][0-9]*\\\\)\");\n@@ -150,2 +148,1 @@\n-                        pattern = Pattern.compile(\"[CV][\\\\s\\\\t]+\\\\[([a-zA-Z0-9_.]+)\\\\+0x.+][\\\\s\\\\t]+.*\\\\+0x.+[\\\\s\\\\t]+\\\\([a-zA-Z0-9_.]+\\\\.[a-z]+:[1-9][0-9]*\\\\)\");\n-                        matcher = pattern.matcher(line);\n+                        Matcher matcher = pattern.matcher(line);\n@@ -170,2 +167,0 @@\n-        } else {\n-            throw new RuntimeException(\"Could not find an hs_err_file\");\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/TestDwarf.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,16 +73,1 @@\n-    String hs_err_file = output_detail.firstMatch(\"# *(\\\\S*hs_err_pid\\\\d+\\\\.log)\", 1);\n-    if (hs_err_file == null) {\n-        throw new RuntimeException(\"Did not find hs_err_pid file in output.\\n\");\n-    }\n-\n-    File f = new File(hs_err_file);\n-    if (!f.exists()) {\n-        throw new RuntimeException(\"hs_err_pid file missing at \"\n-                                   + f.getAbsolutePath() + \".\\n\");\n-    }\n-\n-    System.out.println(\"Found hs_err_pid file. Scanning...\");\n-\n-    FileInputStream fis = new FileInputStream(f);\n-    BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n-    String line = null;\n+    File hs_err_file = HsErrFileUtils.openHsErrFileFromOutput(output_detail);\n@@ -104,17 +89,0 @@\n-    int currentPattern = 0;\n-\n-    String lastLine = null;\n-    while ((line = br.readLine()) != null) {\n-        if (currentPattern < pattern.length) {\n-            if (pattern[currentPattern].matcher(line).matches()) {\n-                System.out.println(\"Found: \" + line + \".\");\n-                currentPattern++;\n-            }\n-        }\n-        lastLine = line;\n-    }\n-    br.close();\n-\n-    if (currentPattern < pattern.length) {\n-        throw new RuntimeException(\"hs_err_pid file incomplete (first missing pattern: \" +  currentPattern + \")\");\n-    }\n@@ -122,5 +90,1 @@\n-    if (!lastLine.equals(\"END.\")) {\n-        throw new RuntimeException(\"hs-err file incomplete (missing END marker.)\");\n-    } else {\n-        System.out.println(\"End marker found.\");\n-    }\n+    HsErrFileUtils.checkHsErrFileContent(hs_err_file, pattern, false);\n@@ -128,1 +92,0 @@\n-    System.out.println(\"Done scanning hs_err_pid_file.\");\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/ThreadsListHandleInErrorHandlingTest.java","additions":3,"deletions":40,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,2 +99,4 @@\n-        String hs_err_file = output_detail.firstMatch(\"# *(\\\\S*hs_err_pid\\\\d+\\\\.log)\", 1);\n-        if (hs_err_file == null) {\n+        File hs_err_file;\n+        try {\n+            hs_err_file = HsErrFileUtils.openHsErrFileFromOutput(output_detail);\n+        } catch (Exception e) {\n@@ -105,12 +108,1 @@\n-            throw new RuntimeException(\"Did not find hs-err file in output.\\n\");\n-        }\n-\n-        File f = new File(hs_err_file);\n-        if (!f.exists()) {\n-            if (!verbose) {\n-                System.err.println(\"<begin cmd output>\");\n-                System.err.println(output_detail.getOutput());\n-                System.err.println(\"<end cmd output>\");\n-            }\n-            throw new RuntimeException(\"hs-err file missing at \"\n-                + f.getAbsolutePath() + \".\\n\");\n+            throw e;\n@@ -121,5 +113,0 @@\n-        FileInputStream fis = new FileInputStream(f);\n-        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n-        String line = null;\n-\n-\n@@ -130,21 +117,0 @@\n-        int currentPattern = 0;\n-\n-        String lastLine = null;\n-        StringBuilder saved_hs_err = new StringBuilder();\n-        while ((line = br.readLine()) != null) {\n-            saved_hs_err.append(line + System.lineSeparator());\n-            if (currentPattern < pattern.length) {\n-                if (pattern[currentPattern].matcher(line).matches()) {\n-                    System.out.println(\"Found: \" + line + \".\");\n-                    currentPattern ++;\n-                }\n-            }\n-            lastLine = line;\n-        }\n-        br.close();\n-\n-        if (verbose) {\n-            System.err.println(\"<begin hs_err contents>\");\n-            System.err.print(saved_hs_err);\n-            System.err.println(\"<end hs_err contents>\");\n-        }\n@@ -152,8 +118,4 @@\n-        if (currentPattern < pattern.length) {\n-            if (!verbose) {\n-                System.err.println(\"<begin hs_err contents>\");\n-                System.err.print(saved_hs_err);\n-                System.err.println(\"<end hs_err contents>\");\n-            }\n-            throw new RuntimeException(\"hs-err file incomplete (first missing pattern: \" +  currentPattern + \")\");\n-        }\n+        \/\/ Note: we *dont* check for the end marker, since the hs-err file will likely not have\n+        \/\/ one but a global timeout marker. As explained above, we don't check for that one either\n+        \/\/ since it is too instable.\n+        HsErrFileUtils.checkHsErrFileContent(hs_err_file, pattern, null, false \/* check end marker *\/,true \/* verbose *\/);\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/TimeoutInErrorHandlingTest.java","additions":11,"deletions":49,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, SAP. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022 SAP. All rights reserved.\n@@ -64,4 +64,1 @@\n-    String hs_err_file = output_detail.firstMatch(\"# *(\\\\S*hs_err_pid\\\\d+\\\\.log)\", 1);\n-    if (hs_err_file == null) {\n-      throw new RuntimeException(\"Did not find hs-err file in output.\\n\");\n-    }\n+    File hs_err_file = HsErrFileUtils.openHsErrFileFromOutput(output_detail);\n@@ -72,5 +69,2 @@\n-    File f = new File(hs_err_file);\n-    if (!f.exists()) {\n-      throw new RuntimeException(\"hs-err file missing at \"\n-              + f.getAbsolutePath() + \".\\n\");\n-    }\n+    \/\/ It is highly likely that we miss the END marker, too, since its likely we hit the\n+    \/\/ secondary error recursion limit.\n@@ -78,7 +72,1 @@\n-    System.out.println(\"Found hs_err file. Scanning...\");\n-\n-    FileInputStream fis = new FileInputStream(f);\n-    BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n-    String line = null;\n-\n-    Pattern[] pattern = new Pattern[]{\n+    Pattern[] pattern = new Pattern[] {\n@@ -87,26 +75,1 @@\n-    int currentPattern = 0;\n-\n-    boolean endMarkerFound = false;\n-    while ((line = br.readLine()) != null) {\n-      if (currentPattern < pattern.length) {\n-        if (pattern[currentPattern].matcher(line).matches()) {\n-          System.out.println(\"Found: \" + line + \".\");\n-          currentPattern++;\n-        }\n-      }\n-      if (line.equals(\"END.\")) {\n-        endMarkerFound = true;\n-        break;\n-      }\n-    }\n-    br.close();\n-\n-    if (currentPattern < pattern.length) {\n-      throw new RuntimeException(\"hs-err file incomplete (first missing pattern: \" + currentPattern + \")\");\n-    }\n-\n-    if (!endMarkerFound) {\n-      throw new RuntimeException(\"hs-err file incomplete (missing END marker.)\");\n-    } else {\n-      System.out.println(\"End marker found.\");\n-    }\n+    HsErrFileUtils.checkHsErrFileContent(hs_err_file, pattern, null, false \/* check end marker *\/, true \/* verbose *\/);\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/VeryEarlyAssertTest.java","additions":7,"deletions":44,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -40,0 +40,21 @@\n+\/\/ Below is exactly the same as above, except:\n+\/\/ - requires vm.bits == \"64\"\n+\/\/ - extra argument \"false\"\n+\n+\/*\n+ * @test Loading CDS archived heap objects into SerialGC\n+ * @bug 8234679\n+ * @requires vm.cds\n+ * @requires vm.gc.Serial\n+ * @requires vm.gc.G1\n+ * @requires vm.bits == \"64\"\n+ *\n+ * @comment don't run this test if any -XX::+Use???GC options are specified, since they will\n+ *          interfere with the test.\n+ * @requires vm.gc == null\n+ *\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @compile test-classes\/Hello.java\n+ * @run driver TestSerialGCWithCDS false\n+ *\/\n+\n@@ -46,0 +67,1 @@\n+    static boolean useCompressedOops = true;\n@@ -50,0 +72,4 @@\n+        if (args.length > 0 && args[0].equals(\"false\")) {\n+            useCompressedOops = false;\n+        }\n+\n@@ -57,1 +83,3 @@\n-        if (Platform.is64bit()) test(false, true, true);\n+        if (Platform.is64bit()) {\n+            test(false, true, \/*useSmallRegions=*\/true);\n+        }\n@@ -68,0 +96,1 @@\n+        String DUMMY = \"-showversion\"; \/\/ A harmless option that doesn't doesn't do anything except for printing out the version\n@@ -70,2 +99,8 @@\n-        String small1 = useSmallRegions ? \"-Xmx256m\" : \"-showversion\";\n-        String small2 = useSmallRegions ? \"-XX:ObjectAlignmentInBytes=64\" : \"-showversion\";\n+        String small1 = useSmallRegions ? \"-Xmx256m\" : DUMMY;\n+        String small2 = useSmallRegions ? \"-XX:ObjectAlignmentInBytes=64\" : DUMMY;\n+        String coops;\n+        if (Platform.is64bit()) {\n+            coops = useCompressedOops ? \"-XX:+UseCompressedOops\" : \"-XX:-UseCompressedOops\";\n+        } else {\n+            coops = DUMMY;\n+        }\n@@ -80,0 +115,1 @@\n+                              coops,\n@@ -89,0 +125,1 @@\n+                              coops,\n@@ -91,2 +128,1 @@\n-        out.shouldContain(HELLO);\n-        out.shouldHaveExitValue(0);\n+        checkExecOutput(dumpWithSerial, execWithSerial, out);\n@@ -99,0 +135,1 @@\n+                              coops,\n@@ -102,1 +139,0 @@\n-        out.shouldContain(HELLO);\n@@ -109,1 +145,1 @@\n-        out.shouldHaveExitValue(0);\n+        checkExecOutput(dumpWithSerial, execWithSerial, out);\n@@ -129,0 +165,1 @@\n+                                      coops,\n@@ -132,1 +169,1 @@\n-                    out.shouldContain(HELLO);\n+                    checkExecOutput(dumpWithSerial, execWithSerial, out);\n@@ -145,0 +182,15 @@\n+\n+    static void checkExecOutput(boolean dumpWithSerial, boolean execWithSerial, OutputAnalyzer out) {\n+        String errMsg = \"Cannot use CDS heap data. UseG1GC is required for -XX:-UseCompressedOops\";\n+        if (Platform.is64bit() &&\n+            !Platform.isWindows() && \/\/ archive heap not supported on Windows.\n+            !dumpWithSerial && \/\/ Dumped with G1, so we have an archived heap\n+            execWithSerial && \/\/ Running with serial\n+            !useCompressedOops) { \/\/ ArchiveHeapLoader::can_load() always returns false when COOP is disabled\n+            out.shouldContain(errMsg);\n+        }\n+        if (!execWithSerial) {\n+            \/\/ We should never see this message with G1\n+            out.shouldNotContain(errMsg);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestSerialGCWithCDS.java","additions":60,"deletions":8,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @summary Check that -XX:+AutoCreateSharedArchive automatically recreates an archive when you change the JDK version.\n+ * @requires os.family == \"linux\" & vm.bits == \"64\" & (os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @library \/test\/lib\n+ * @compile -source 1.8 -target 1.8 ..\/test-classes\/HelloJDK8.java\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar Hello.jar HelloJDK8\n+ * @run driver TestAutoCreateSharedArchiveUpgrade\n+ *\/\n+\n+import java.io.File;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestAutoCreateSharedArchiveUpgrade {\n+    \/\/ The JDK being tested\n+    private static final String TEST_JDK = System.getProperty(\"test.jdk\", null);\n+\n+    \/\/ If you're running this test manually, specify the location of a previous version of\n+    \/\/ the JDK using \"jtreg -vmoption:-Dtest.previous.jdk=${JDK19_HOME} ...\"\n+    private static final String PREV_JDK = System.getProperty(\"test.previous.jdk\", null);\n+\n+    \/\/ If you're unning this test using something like\n+    \/\/ \"make test TEST=test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestAutoCreateSharedArchiveUpgrade.java\",\n+    \/\/ the test.boot.jdk property is passed by make\/RunTests.gmk\n+    private static final String BOOT_JDK = System.getProperty(\"test.boot.jdk\", null);\n+\n+    private static final String USER_DIR = System.getProperty(\"user.dir\", \".\");\n+    private static final String FS = System.getProperty(\"file.separator\", \"\/\");\n+\n+    private static final String JAR = ClassFileInstaller.getJarPath(\"Hello.jar\");\n+    private static final String JSA = USER_DIR + FS + \"Hello.jsa\";\n+\n+    private static String oldJVM;\n+    private static String newJVM;\n+\n+    public static void main(String[] args) throws Throwable {\n+        setupJVMs();\n+        doTest();\n+    }\n+\n+    static void setupJVMs() throws Throwable {\n+        if (TEST_JDK == null) {\n+            throw new RuntimeException(\"-Dtest.jdk should point to the JDK being tested\");\n+        }\n+\n+        newJVM = TEST_JDK + FS + \"bin\" + FS + \"java\";\n+\n+        if (PREV_JDK != null) {\n+            oldJVM = PREV_JDK + FS + \"bin\" + FS + \"java\";\n+        } else if (BOOT_JDK != null) {\n+            oldJVM = BOOT_JDK + FS + \"bin\" + FS + \"java\";\n+        } else {\n+            throw new RuntimeException(\"Use -Dtest.previous.jdk or -Dtest.boot.jdk to specify a \" +\n+                                       \"previous version of the JDK that supports \" +\n+                                       \"-XX:+AutoCreateSharedArchive\");\n+        }\n+\n+        System.out.println(\"Using newJVM = \" + newJVM);\n+        System.out.println(\"Using oldJVM = \" + oldJVM);\n+    }\n+\n+    static void doTest() throws Throwable {\n+        File jsaF = new File(JSA);\n+        jsaF.delete();\n+        OutputAnalyzer output;\n+\n+        \/\/ NEW JDK -- create and then use the JSA\n+        output = run(newJVM);\n+        assertJSANotFound(output);\n+        assertCreatedJSA(output);\n+\n+        output = run(newJVM);\n+        assertUsedJSA(output);\n+\n+        \/\/ OLD JDK -- should reject the JSA created by NEW JDK, and create its own\n+        output = run(oldJVM);\n+        assertJSAVersionMismatch(output);\n+        assertCreatedJSA(output);\n+\n+        output = run(oldJVM);\n+        assertUsedJSA(output);\n+\n+        \/\/ NEW JDK -- should reject the JSA created by OLD JDK, and create its own\n+        output = run(newJVM);\n+        assertJSAVersionMismatch(output);\n+        assertCreatedJSA(output);\n+\n+        output = run(newJVM);\n+        assertUsedJSA(output);\n+    }\n+\n+    static OutputAnalyzer run(String jvm) throws Throwable {\n+        OutputAnalyzer output =\n+            ProcessTools.executeCommand(jvm, \"-XX:+AutoCreateSharedArchive\",\n+                                        \"-XX:SharedArchiveFile=\" + JSA,\n+                                        \"-Xlog:cds\",\n+                                        \"-cp\", JAR, \"HelloJDK8\");\n+        output.shouldHaveExitValue(0);\n+        return output;\n+    }\n+\n+    static void assertJSANotFound(OutputAnalyzer output) {\n+        output.shouldContain(\"Specified shared archive not found\");\n+    }\n+\n+    static void assertCreatedJSA(OutputAnalyzer output) {\n+        output.shouldContain(\"Dumping shared data to file\");\n+    }\n+\n+    static void assertJSAVersionMismatch(OutputAnalyzer output) {\n+        output.shouldContain(\"does not match the required version\");\n+    }\n+\n+    static void assertUsedJSA(OutputAnalyzer output) {\n+        output.shouldContain(\"Mapped dynamic region #0\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestAutoCreateSharedArchiveUpgrade.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+\/\/ Used by tests like dynamicArchive\/TestAutoCreateSharedArchiveUpgrade.java, which\n+\/\/ runs this class in an earlier JDK\n+\/\/\n+\/\/ It should be compiled like this in the jtreg spec:\n+\/\/ @compile -source 1.8 -target 1.8 test-classes\/HelloJDK8.java\n+\n+public class HelloJDK8 {\n+    public static void main(String args[]) {\n+        System.out.println(\"This class is compiled by JDK 8\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/HelloJDK8.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 8193222\n- * @summary Check EnsureLocalCapacity doesn't shrink unexpectedly\n- * @library \/test\/lib\n- * @run main\/native TestCheckedEnsureLocalCapacity launch\n- *\/\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class TestCheckedEnsureLocalCapacity {\n-\n-    static {\n-        System.loadLibrary(\"TestCheckedEnsureLocalCapacity\");\n-    }\n-\n-    \/\/ Calls EnsureLocalCapacity(capacity) and then creates \"copies\" number\n-    \/\/ of LocalRefs to \"o\".\n-    \/\/ If capacity > copies no warning should ensue (with the bug fixed).\n-    \/\/ If copies > capacity + warning-threshold then we still get a warning.\n-    private static native void ensureCapacity(Object o, int capacity, int copies);\n-\n-    private static int[][] testArgs = {\n-        { 60, 45 }, \/\/ good: capacity > copies\n-        { 1, 45 }   \/\/ bad: copies >> capacity\n-    };\n-\n-    \/\/ Patterns EXCEED_WARNING and WARNING are not anchored to the beginning\n-    \/\/ of lines to allow matching interleaved output.\n-\n-    private static final String EXCEED_WARNING =\n-        \"WARNING: JNI local refs: \\\\d++, exceeds capacity:\";\n-\n-    private static final String WARNING = \"WARNING:\";\n-\n-    public static void main(String[] args) throws Throwable {\n-        if (args.length == 2) {\n-            ensureCapacity(new Object(),\n-                           Integer.parseInt(args[0]),\n-                           Integer.parseInt(args[1]));\n-            return;\n-        }\n-\n-        \/\/ No warning\n-        ProcessTools.executeTestJvm(\"-Xcheck:jni\",\n-                                    \"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH,\n-                                    \"TestCheckedEnsureLocalCapacity\",\n-                                    Integer.toString(testArgs[0][0]),\n-                                    Integer.toString(testArgs[0][1])).\n-            shouldHaveExitValue(0).\n-            \/\/ check no capacity warning\n-            stdoutShouldNotMatch(EXCEED_WARNING).\n-            \/\/ check no other warning\n-            stdoutShouldNotMatch(WARNING).\n-            reportDiagnosticSummary();\n-\n-        \/\/ Warning\n-        ProcessTools.executeTestJvm(\"-Xcheck:jni\",\n-                                    \"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH,\n-                                    \"TestCheckedEnsureLocalCapacity\",\n-                                    Integer.toString(testArgs[1][0]),\n-                                    Integer.toString(testArgs[1][1])).\n-            shouldHaveExitValue(0).\n-            \/\/ check for capacity warning\n-            stdoutShouldMatch(EXCEED_WARNING).\n-            reportDiagnosticSummary();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/TestCheckedEnsureLocalCapacity.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <jni.h>\n-#include <stdio.h>\n-\n-void reduceLocalCapacity(JNIEnv* env) {\n-    puts(\"reduceLocalCapacity: setting to 1\");\n-    (*env)->EnsureLocalCapacity(env,1);\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_TestCheckedEnsureLocalCapacity_ensureCapacity(JNIEnv *env,\n-                                                   jobject unused,\n-                                                   jobject target,\n-                                                   jint capacity,\n-                                                   jint copies) {\n-  int i;\n-  printf(\"ensureCapacity: setting to %d\\n\", capacity);\n-  (*env)->EnsureLocalCapacity(env, capacity); \/\/ set high\n-  reduceLocalCapacity(env);     \/\/ sets low\n-\n-  printf(\"ensureCapacity: creating %d LocalRefs\\n\", copies);\n-  for (i = 0; i < copies; i++) {\n-    target = (*env)->NewLocalRef(env, target);\n-  }\n-\n-  puts(\"ensureCapacity: done\");\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/libTestCheckedEnsureLocalCapacity.c","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -40,1 +40,1 @@\n- *          Attaches to a running application and and returns a mirror of its VM.\n+ *          Attaches to a running application and returns a mirror of its VM.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/AttachingConnector\/attach\/attach003\/TestDescription.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n- *     and and checks that there is no data in the reply packet.\n+ *     and checks that there is no data in the reply packet.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdwp\/ClassType\/SetValues\/setvalues001\/TestDescription.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n- *     and and checks that there is no data in the reply packet.\n+ *     and checks that there is no data in the reply packet.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdwp\/ObjectReference\/SetValues\/setvalues001\/TestDescription.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,61 @@\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/monitoring\/ThreadMXBean\/resetPeakThreadCount\/reset001..reset005\n+ * VM Testbase keywords: [quick, monitoring]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test checks that\n+ *         ThreadMXBean.resetPeakThreadCount()\n+ *     returns correct result.\n+ *     The test starts a couple of user threads and waits until they finish. After\n+ *     that, resetPeakThreadCount() is invoked to reset the peak. Then\n+ *     getPeakThreadCount() and getThreadCount() must return the same values. The\n+ *     expectation is that no threads are created, or terminated, between\n+ *     \"getPeakThreadCount()\" and getThreadCount()\" calls.\n+ *     The test implements defferent ways to access to the metrics.\n+ *\n+ * @comment Direct access to the metrics.\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ * @run main\/othervm nsk.monitoring.ThreadMXBean.resetPeakThreadCount.reset001\n+ *\/\n+\n+\/*\n+ * @test\n+ * @comment Access to the metrics via default MBean server.\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ * @run main\/othervm nsk.monitoring.ThreadMXBean.resetPeakThreadCount.reset001 -testMode=server\n+ *\/\n+\n+\/*\n+ * @test\n+ * @comment Access to the metrics via custom MBean server.\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ * @run main\/othervm\n+ *      nsk.monitoring.ThreadMXBean.resetPeakThreadCount.reset001\n+ *      -testMode=server\n+ *      -MBeanServer=custom\n+ *\/\n+\n+\/*\n+ * @test\n+ * @comment Access to the metrics via default MBean server proxy.\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ * @run main\/othervm nsk.monitoring.ThreadMXBean.resetPeakThreadCount.reset001 -testMode=proxy\n+ *\/\n+\n+\/*\n+ * @test\n+ * @comment Access to the metrics via custom MBean server proxy.\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ * @run main\/othervm\n+ *      nsk.monitoring.ThreadMXBean.resetPeakThreadCount.reset001\n+ *      -testMode=proxy\n+ *      -MBeanServer=custom\n+ *\/\n+\n@@ -57,1 +118,1 @@\n-        \/\/ The test supposes that no threads are appered\/disappeared between\n+        \/\/ The test assumes that no threads are created or terminated between\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadMXBean\/resetPeakThreadCount\/reset001.java","additions":63,"deletions":2,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/monitoring\/ThreadMXBean\/resetPeakThreadCount\/reset001.\n- * VM Testbase keywords: [quick, monitoring]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test checks that\n- *         ThreadMXBean.resetPeakThreadCount()\n- *     returns correct result.\n- *     The test starts a couple of user threads and waits until they finish. After\n- *     that, resetPeakThreadCount() is invoked to reset the peak. Then\n- *     getPeakThreadCount() and getThreadCount() must return the same values. The\n- *     preposition is that no threads are appered\/disappeared between\n- *     \"getPeakThreadCount()\" and getThreadCount()\" calls.\n- *     The test implements direct access to the metrics.\n- * COMMENT\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm nsk.monitoring.ThreadMXBean.resetPeakThreadCount.reset001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadMXBean\/resetPeakThreadCount\/reset001\/TestDescription.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/monitoring\/ThreadMXBean\/resetPeakThreadCount\/reset002.\n- * VM Testbase keywords: [quick, monitoring]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test checks that\n- *         ThreadMXBean.resetPeakThreadCount()\n- *     returns correct result.\n- *     The test starts a couple of user threads and waits until they finish. After\n- *     that, resetPeakThreadCount() is invoked to reset the peak. Then\n- *     getPeakThreadCount() and getThreadCount() must return the same values. The\n- *     preposition is that no threads are appered\/disappeared between\n- *     \"getPeakThreadCount()\" and getThreadCount()\" calls.\n- *     The test implements access to the metrics via default MBean server.\n- * COMMENT\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm nsk.monitoring.ThreadMXBean.resetPeakThreadCount.reset001 -testMode=server\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadMXBean\/resetPeakThreadCount\/reset002\/TestDescription.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/monitoring\/ThreadMXBean\/resetPeakThreadCount\/reset003.\n- * VM Testbase keywords: [quick, monitoring]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test checks that\n- *         ThreadMXBean.resetPeakThreadCount()\n- *     returns correct result.\n- *     The test starts a couple of user threads and waits until they finish. After\n- *     that, resetPeakThreadCount() is invoked to reset the peak. Then\n- *     getPeakThreadCount() and getThreadCount() must return the same values. The\n- *     preposition is that no threads are appered\/disappeared between\n- *     \"getPeakThreadCount()\" and getThreadCount()\" calls.\n- *     The test implements access to the metrics via custom MBean server.\n- * COMMENT\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      nsk.monitoring.ThreadMXBean.resetPeakThreadCount.reset001\n- *      -testMode=server\n- *      -MBeanServer=custom\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadMXBean\/resetPeakThreadCount\/reset003\/TestDescription.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/monitoring\/ThreadMXBean\/resetPeakThreadCount\/reset004.\n- * VM Testbase keywords: [quick, monitoring]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test checks that\n- *         ThreadMXBean.resetPeakThreadCount()\n- *     returns correct result.\n- *     The test starts a couple of user threads and waits until they finish. After\n- *     that, resetPeakThreadCount() is invoked to reset the peak. Then\n- *     getPeakThreadCount() and getThreadCount() must return the same values. The\n- *     preposition is that no threads are appered\/disappeared between\n- *     \"getPeakThreadCount()\" and getThreadCount()\" calls.\n- *     The test implements access to the metrics via default MBean server proxy.\n- * COMMENT\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm nsk.monitoring.ThreadMXBean.resetPeakThreadCount.reset001 -testMode=proxy\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadMXBean\/resetPeakThreadCount\/reset004\/TestDescription.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/monitoring\/ThreadMXBean\/resetPeakThreadCount\/reset005.\n- * VM Testbase keywords: [quick, monitoring]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test checks that\n- *         ThreadMXBean.resetPeakThreadCount()\n- *     returns correct result.\n- *     The test starts a couple of user threads and waits until they finish. After\n- *     that, resetPeakThreadCount() is invoked to reset the peak. Then\n- *     getPeakThreadCount() and getThreadCount() must return the same values. The\n- *     preposition is that no threads are appered\/disappeared between\n- *     \"getPeakThreadCount()\" and getThreadCount()\" calls.\n- *     The test implements access to the metrics via custom MBean server proxy.\n- * COMMENT\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\n- *      nsk.monitoring.ThreadMXBean.resetPeakThreadCount.reset001\n- *      -testMode=proxy\n- *      -MBeanServer=custom\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadMXBean\/resetPeakThreadCount\/reset005\/TestDescription.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -30,2 +30,2 @@\n- * Class used to create deadlocked threads. It is possible create 2 or more deadlocked thread, also\n- * is is possible to specify resource of which type should lock each deadlocked thread\n+ * Class used to create deadlocked threads. It is possible to create 2 or more deadlocked threads, also\n+ * it is possible to specify resource of which type should lock each deadlocked thread.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/locks\/DeadlockMaker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-Suppose we want to to define a test Test with an option \"iterations\",\n+Suppose we want to define a test Test with an option \"iterations\",\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/options\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-requiredVersion=7+1\n+requiredVersion=7.1+1\n","filename":"test\/jaxp\/TEST.ROOT","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-java\/lang\/Float\/Binary16Conversion.java 8295351 generic-x64\n","filename":"test\/jdk\/ProblemList-Xcomp.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+java\/awt\/Frame\/RestoreToOppositeScreen\/RestoreToOppositeScreen.java 8286840 linux-all\n@@ -481,1 +482,0 @@\n-jdk\/internal\/misc\/TerminatingThreadLocal\/TestTerminatingThreadLocal.java 8292051 generic-all\n@@ -496,1 +496,0 @@\n-java\/io\/File\/TempDirDoesNotExist.java                           8297528 windows-all\n@@ -659,1 +658,0 @@\n-javax\/swing\/JRadioButton\/4314194\/bug4314194.java 8295006 linux-all\n@@ -688,1 +686,0 @@\n-tools\/launcher\/TestXcheckJNIWarnings.java#jdwp-agent   8296936 generic-all\n@@ -719,2 +716,0 @@\n-sun\/tools\/jhsdb\/BasicLauncherTest.java                          8228649 linux-ppc64,linux-ppc64le\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-requiredVersion=7+1\n+requiredVersion=7.1+1\n","filename":"test\/jdk\/TEST.ROOT","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8078471\n+ * @key headful\n+ * @requires (os.family == \"linux\")\n+ * @summary Verifies if filechooser current directory changed to parent\n+ * directory on BACKSPACE key press except root directory.\n+ * @run main TestBackSpaceAction\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Component;\n+import java.awt.event.HierarchyEvent;\n+import java.awt.event.HierarchyListener;\n+import java.awt.event.KeyEvent;\n+import java.awt.Robot;\n+import java.io.File;\n+import javax.swing.JFileChooser;\n+import javax.swing.JPanel;\n+import javax.swing.JComboBox;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+\n+\n+public class TestBackSpaceAction {\n+    private static JFrame frame;\n+    private static JFileChooser fileChooser;\n+    private static Robot robot;\n+    private static File testDir;\n+    private static File subDir;\n+    private static File prevDir;\n+    private static File crntDir;\n+\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+        robot.setAutoDelay(100);\n+        try {\n+            \/\/ create test directory\n+            String tmpDir = System.getProperty(\"java.io.tmpdir\");\n+            \/\/'java.io.tmpdir' isn't guaranteed to be defined\n+            if (tmpDir.length() == 0) {\n+                tmpDir = System.getProperty(\"user.home\");\n+            }\n+            testDir = new File(tmpDir, \"testDir\");\n+            testDir.mkdir();\n+            testDir.deleteOnExit();\n+\n+            \/\/ create sub directory inside test directory\n+            subDir = new File(testDir, \"subDir\");\n+            subDir.mkdir();\n+            subDir.deleteOnExit();\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+\n+        for (UIManager.LookAndFeelInfo laf :\n+                        UIManager.getInstalledLookAndFeels()) {\n+            if (!laf.getClassName().contains(\"MotifLookAndFeel\")) {\n+                System.out.println(\"Testing LAF: \" + laf.getClassName());\n+                SwingUtilities.invokeAndWait(() -> setLookAndFeel(laf));\n+                doTesting(laf);\n+            }\n+        }\n+    }\n+\n+    private static void setLookAndFeel(UIManager.LookAndFeelInfo laf) {\n+        try {\n+            UIManager.setLookAndFeel(laf.getClassName());\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Unsupported LAF: \" + laf.getClassName());\n+        } catch (ClassNotFoundException | InstantiationException\n+                 | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static void doTesting(UIManager.LookAndFeelInfo laf)\n+            throws Exception {\n+        try {\n+            SwingUtilities.invokeAndWait(() -> {\n+                createAndShowUI();\n+            });\n+            boolean passed_1 = false;\n+            boolean passed_2 = false;\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            \/\/ check backspace key at subDir level\n+            clickBackSpace();\n+            if (prevDir != crntDir) {\n+                passed_1 = true;\n+            }\n+\n+            \/\/ check if backspace key changes directory at root level\n+            while (!fileChooser.getFileSystemView().isFileSystemRoot(prevDir)) {\n+                clickBackSpace();\n+                if (prevDir == crntDir) {\n+                    passed_2 = true;\n+                    break;\n+                }\n+            }\n+\n+            if (passed_1 && passed_2) {\n+                System.out.println(\"Passed\");\n+            } else {\n+                throw new RuntimeException(\"BackSpace does not lead to \" +\n+                        \"parent directory for LAF: \" + laf.getClassName());\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void createAndShowUI() {\n+        frame = new JFrame(\"Test File Chooser Backspace Action\");\n+        frame.getContentPane().setLayout(new BorderLayout());\n+        fileChooser = new JFileChooser(subDir);\n+        fileChooser.setControlButtonsAreShown(false);\n+        fileChooser.addHierarchyListener(new HierarchyListener(){\n+            public void hierarchyChanged(HierarchyEvent he) {\n+                grabFocusForComboBox(fileChooser.getComponents());\n+            }\n+        });\n+        frame.getContentPane().add(fileChooser, BorderLayout.CENTER);\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setVisible(true);\n+    }\n+\n+    private static void grabFocusForComboBox(Component[] comp)\n+    {\n+        for (Component c:comp) {\n+            if (c instanceof JComboBox) {\n+                JComboBox cb = (JComboBox)c;\n+                cb.requestFocusInWindow();\n+                break;\n+            } else if (c instanceof JPanel) {\n+                JPanel jp = (JPanel)c;\n+                grabFocusForComboBox(jp.getComponents());\n+            }\n+        }\n+    }\n+\n+    private static void clickBackSpace() {\n+        prevDir = fileChooser.getCurrentDirectory();\n+        robot.keyPress(KeyEvent.VK_BACK_SPACE);\n+        robot.keyRelease(KeyEvent.VK_BACK_SPACE);\n+        crntDir = fileChooser.getCurrentDirectory();\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/java\/swing\/plaf\/gtk\/TestBackSpaceAction.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug     8258836\n- * @summary JNI local refs exceed capacity getDiagnosticCommandInfo\n- * @library \/test\/lib\n- * @run main\/othervm DcmdMBeanTestCheckJni\n- *\/\n-\n-import java.lang.management.ManagementFactory;\n-import javax.management.MBeanServer;\n-import javax.management.ObjectName;\n-import javax.management.MBeanServerConnection;\n-import javax.management.remote.JMXConnectorFactory;\n-import javax.management.remote.JMXConnector;\n-import javax.management.remote.JMXConnectorServerFactory;\n-import javax.management.remote.JMXServiceURL;\n-import javax.management.remote.JMXConnectorServer;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class DcmdMBeanTestCheckJni {\n-\n-    public static void main(String[] args) throws Exception {\n-        OutputAnalyzer out = ProcessTools.executeTestJvm(\n-            \"-Xcheck:jni\",\n-            DcmdMBeanRunner.class.getName());\n-        out.shouldNotMatch(\"WARNING: JNI local refs: \\\\d+, exceeds capacity: \\\\d+\\\\s+\" +\n-                           \"at com.sun.management.internal.DiagnosticCommandImpl.getDiagnosticCommandInfo\")\n-           .shouldContain(\"DcmdMBeanRunner COMPLETE\")\n-           .shouldHaveExitValue(0);\n-    }\n-\n-}\n-\n-class DcmdMBeanRunner {\n-\n-    private static final String HOTSPOT_DIAGNOSTIC_MXBEAN_NAME =\n-        \"com.sun.management:type=DiagnosticCommand\";\n-\n-    public static void main(String[] args) throws Exception {\n-        MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n-        JMXServiceURL url = new JMXServiceURL(\"rmi\", null, 0);\n-        JMXConnectorServer cs = null;\n-        JMXConnector cc = null;\n-        try {\n-            cs = JMXConnectorServerFactory.newJMXConnectorServer(url, null, mbs);\n-            cs.start();\n-            JMXServiceURL addr = cs.getAddress();\n-            cc = JMXConnectorFactory.connect(addr);\n-            MBeanServerConnection mbsc = cc.getMBeanServerConnection();\n-            ObjectName name = new ObjectName(HOTSPOT_DIAGNOSTIC_MXBEAN_NAME);\n-            System.out.println(\"DiagnosticCommand MBean: \" + name);\n-            System.out.println(\"DcmdMBeanRunner COMPLETE\");\n-        } finally {\n-            try {\n-                cc.close();\n-                cs.stop();\n-            } catch (Exception e) { \/* ignored *\/ }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/com\/sun\/management\/DiagnosticCommandMBean\/DcmdMBeanTestCheckJni.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 4424517\n+ * @summary Verify the mapping of various KeyEvents with their KeyLocations\n+ * is as expected.\n+ * @run main KeyEventLocationTest\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.Robot;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.KeyListener;\n+import java.awt.event.MouseEvent;\n+\n+import javax.swing.SwingUtilities;\n+\n+public class KeyEventLocationTest {\n+\n+    private static volatile Frame frame;\n+    private static volatile boolean keyPressed;\n+    private static volatile boolean keyReleased;\n+    private static volatile boolean keyTyped;\n+    private static volatile Robot robot;\n+    private static volatile int xLocation;\n+    private static volatile int yLocation;\n+    private static volatile int width;\n+    private static volatile int height;\n+    private static volatile Label label = new Label();\n+    private static volatile String currentString = \"\";\n+\n+    private static int[] keyEvents = { KeyEvent.VK_0, KeyEvent.VK_1,\n+        KeyEvent.VK_2, KeyEvent.VK_3, KeyEvent.VK_4, KeyEvent.VK_5,\n+        KeyEvent.VK_6, KeyEvent.VK_7, KeyEvent.VK_8, KeyEvent.VK_9,\n+        KeyEvent.VK_A, KeyEvent.VK_B, KeyEvent.VK_C, KeyEvent.VK_D,\n+        KeyEvent.VK_E, KeyEvent.VK_F, KeyEvent.VK_G, KeyEvent.VK_H,\n+        KeyEvent.VK_I, KeyEvent.VK_J, KeyEvent.VK_K, KeyEvent.VK_L,\n+        KeyEvent.VK_M, KeyEvent.VK_N, KeyEvent.VK_O, KeyEvent.VK_P,\n+        KeyEvent.VK_Q, KeyEvent.VK_R, KeyEvent.VK_S, KeyEvent.VK_T,\n+        KeyEvent.VK_U, KeyEvent.VK_V, KeyEvent.VK_W, KeyEvent.VK_X,\n+        KeyEvent.VK_Y, KeyEvent.VK_Z, KeyEvent.VK_BACK_QUOTE,\n+        KeyEvent.VK_BACK_SLASH, KeyEvent.VK_BACK_SPACE,\n+        KeyEvent.VK_CLOSE_BRACKET, KeyEvent.VK_COMMA, KeyEvent.VK_EQUALS,\n+        KeyEvent.VK_ESCAPE, KeyEvent.VK_MINUS, KeyEvent.VK_OPEN_BRACKET,\n+        KeyEvent.VK_PERIOD, KeyEvent.VK_QUOTE, KeyEvent.VK_SEMICOLON,\n+        KeyEvent.VK_SLASH, KeyEvent.VK_SPACE };\n+\n+    private static int specialKeyEvents[] = { KeyEvent.VK_F1, KeyEvent.VK_F2,\n+        KeyEvent.VK_F3, KeyEvent.VK_F4, KeyEvent.VK_F5, KeyEvent.VK_F6,\n+        KeyEvent.VK_F7, KeyEvent.VK_F8, KeyEvent.VK_F9, KeyEvent.VK_F10 };\n+\n+    private static void createGUI() {\n+        frame = new Frame(\"Test frame\");\n+        frame.setLayout(new BorderLayout());\n+        frame.setAlwaysOnTop(true);\n+\n+        frame.addKeyListener(new KeyListener() {\n+            public void keyPressed(KeyEvent event) {\n+                try {\n+                    handleEvent(\"keyPressed\", event);\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+                keyPressed = true;\n+            }\n+\n+            public void keyReleased(KeyEvent event) {\n+                try {\n+                    handleEvent(\"keyReleased\", event);\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+                keyReleased = true;\n+            }\n+\n+            public void keyTyped(KeyEvent event) {\n+                try {\n+                    handleEvent(\"keyTyped\", event);\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+                keyTyped = true;\n+            }\n+\n+            private void handleEvent(String eventString, KeyEvent event)\n+                throws Exception {\n+                label.setText(eventString + \" triggered for \" + event);\n+                if ((event.getID() == KeyEvent.KEY_TYPED\n+                    && event.getKeyLocation() != KeyEvent.KEY_LOCATION_UNKNOWN)\n+                    || ((event.getID() == KeyEvent.KEY_PRESSED\n+                    || event.getID() == KeyEvent.KEY_PRESSED)\n+                    && event.getKeyLocation()\n+                    != KeyEvent.KEY_LOCATION_STANDARD)) {\n+                    throw new Exception(\"FAIL: Incorrect KeyLocation: \"\n+                        + event.getKeyLocation() + \" returned when \"\n+                        + eventString + \" triggered for \" + event.getKeyChar());\n+                }\n+            }\n+        });\n+        label.setText(\"Current Event: \");\n+        frame.add(label, BorderLayout.SOUTH);\n+        frame.setSize(600, 300);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+        frame.toFront();\n+    }\n+\n+    private static void doTest() throws Exception {\n+        robot = new Robot();\n+        robot.setAutoWaitForIdle(true);\n+        robot.setAutoDelay(100);\n+\n+        SwingUtilities.invokeAndWait(() -> {\n+            xLocation = frame.getLocationOnScreen().x;\n+            yLocation = frame.getLocationOnScreen().y;\n+            width = frame.getWidth();\n+            height = frame.getHeight();\n+        });\n+\n+        robot.mouseMove(xLocation + width \/ 2, yLocation + height \/ 2);\n+        robot.mousePress(MouseEvent.BUTTON1_MASK);\n+        robot.mouseRelease(MouseEvent.BUTTON1_MASK);\n+\n+        for (int i = 0; i < keyEvents.length; i++) {\n+            resetValues();\n+            robot.keyPress(keyEvents[i]);\n+            robot.delay(200);\n+            if (!keyPressed) {\n+                throw new Exception(\n+                    \"FAIL: keyPressed did not get triggered for \"\n+                        + KeyEvent.getKeyText(keyEvents[i]));\n+            }\n+            robot.keyRelease(keyEvents[i]);\n+            robot.delay(200);\n+            if (!keyReleased) {\n+                throw new Exception(\n+                    \"FAIL: keyReleased did not get triggered for \"\n+                        + KeyEvent.getKeyText(keyEvents[i]));\n+            }\n+            robot.delay(200);\n+            if (!keyTyped) {\n+                throw new Exception(\"FAIL: keyTyped did not get triggered for \"\n+                    + KeyEvent.getKeyText(keyEvents[i]));\n+            }\n+        }\n+\n+        for (int i = 0; i < specialKeyEvents.length; i++) {\n+            resetValues();\n+            robot.keyPress(specialKeyEvents[i]);\n+            robot.delay(200);\n+            if (!keyPressed) {\n+                throw new Exception(\"FAIL: keyPressed did not get triggered\"\n+                    + \" for \" + KeyEvent.getKeyText(specialKeyEvents[i]));\n+            }\n+            robot.keyRelease(specialKeyEvents[i]);\n+            robot.delay(200);\n+            if (!keyReleased) {\n+                throw new Exception(\"FAIL: keyReleased got triggered for \"\n+                    + KeyEvent.getKeyText(specialKeyEvents[i]));\n+            }\n+            robot.delay(200);\n+            if (keyTyped) {\n+                throw new Exception(\"FAIL: keyTyped got triggered for \"\n+                    + KeyEvent.getKeyText(specialKeyEvents[i]));\n+            }\n+        }\n+    }\n+\n+    private static void resetValues() {\n+        keyPressed = false;\n+        keyReleased = false;\n+        keyTyped = false;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            EventQueue.invokeAndWait(() -> createGUI());\n+            doTest();\n+            System.out.println(\"Test Passed\");\n+        } finally {\n+            if (frame != null)\n+                EventQueue.invokeAndWait(() -> frame.dispose());\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/awt\/event\/KeyEvent\/KeyEventLocationTest.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n-import java.util.ArrayList;\n@@ -40,0 +39,1 @@\n+import java.util.concurrent.CopyOnWriteArrayList;\n@@ -58,1 +58,1 @@\n-    private static final List<TestWindow> WINDOWS = new ArrayList<TestWindow>();\n+    private static final List<TestWindow> WINDOWS = new CopyOnWriteArrayList<>();\n@@ -129,1 +129,1 @@\n-        private int counter = 0;\n+        private volatile int counter = 0;\n","filename":"test\/jdk\/java\/awt\/event\/SequencedEvent\/MultipleContextsFunctionalTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- *              -nativepath:<path-to-build-dir>\/support\/test\/jdk\/jtreg\/native\/manual\/lib\/ \\\n+ *              -nativepath:<path-to-build-dir>\/images\/test\/jdk\/jtreg\/native\/ \\\n@@ -41,2 +41,2 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.UpcallLinker.USE_SPEC=false\n@@ -53,2 +53,2 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.UpcallLinker.USE_SPEC=false\n@@ -65,2 +65,2 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.UpcallLinker.USE_SPEC=true\n@@ -77,2 +77,2 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.UpcallLinker.USE_SPEC=true\n@@ -82,1 +82,1 @@\n-\/* @test id=Downcall-F\n+\/* @test id=DowncallScope-F\n@@ -85,1 +85,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestDowncall\n+ * @build NativeTestHelper CallGeneratorHelper TestDowncallBase\n@@ -89,2 +89,2 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   TestDowncall\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=false\n+ *   TestDowncallScope\n@@ -93,1 +93,1 @@\n-\/* @test id=Downcall-T\n+\/* @test id=DowncallScope-T\n@@ -96,1 +96,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestDowncall\n+ * @build NativeTestHelper CallGeneratorHelper TestDowncallBase\n@@ -100,2 +100,24 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   TestDowncall\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=true\n+ *   TestDowncallScope\n+ *\/\n+\n+\/* @test id=DowncallStack-F\n+ * @enablePreview\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @build NativeTestHelper CallGeneratorHelper TestDowncallBase\n+ *\n+ * @run testng\/othervm\/native\/manual\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=false\n+ *   TestDowncallStack\n+ *\/\n+\n+\/* @test id=DowncallStack-T\n+ * @enablePreview\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @build NativeTestHelper CallGeneratorHelper TestDowncallBase\n+ *\n+ * @run testng\/othervm\/native\/manual\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=true\n+ *   TestDowncallStack\n@@ -111,2 +133,2 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.UpcallLinker.USE_SPEC=false\n@@ -123,2 +145,2 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.UpcallLinker.USE_SPEC=false\n@@ -135,2 +157,2 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.UpcallLinker.USE_SPEC=true\n@@ -147,2 +169,2 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.UpcallLinker.USE_SPEC=true\n@@ -159,2 +181,2 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.UpcallLinker.USE_SPEC=false\n@@ -171,2 +193,2 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.UpcallLinker.USE_SPEC=false\n@@ -183,2 +205,2 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.UpcallLinker.USE_SPEC=true\n@@ -195,2 +217,2 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.UpcallLinker.USE_SPEC=true\n@@ -207,2 +229,2 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.UpcallLinker.USE_SPEC=false\n@@ -219,2 +241,2 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.UpcallLinker.USE_SPEC=false\n@@ -231,2 +253,2 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.UpcallLinker.USE_SPEC=true\n@@ -243,2 +265,2 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.UpcallLinker.USE_SPEC=true\n@@ -247,0 +269,11 @@\n+\n+\/*\n+ * @test id=VarArgs\n+ * @enablePreview\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @build NativeTestHelper CallGeneratorHelper\n+ *\n+ * @run testng\/othervm\/native\/manual\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   TestVarArgs\n+ *\/\n","filename":"test\/jdk\/java\/foreign\/TestMatrix.java","additions":74,"deletions":41,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @library ..\/\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestMixedMallocFree\n- *\/\n-\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemorySegment;\n-\n-import org.testng.annotations.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static org.testng.Assert.assertEquals;\n-\n-public class TestMixedMallocFree extends NativeTestHelper {\n-\n-    static final MethodHandle MH_my_malloc;\n-\n-    static {\n-        System.loadLibrary(\"Malloc\");\n-        MH_my_malloc = Linker.nativeLinker().downcallHandle(\n-                findNativeOrThrow(\"my_malloc\"),\n-                FunctionDescriptor.of(C_POINTER, C_LONG_LONG));\n-    }\n-\n-    @Test\n-    public void testMalloc() throws Throwable {\n-        MemorySegment seg = (MemorySegment) MH_my_malloc.invokeExact(4L);\n-        seg.set(JAVA_INT, 0, 42);\n-        assertEquals(seg.get(JAVA_INT, 0), 42);\n-        \/\/ Test if this free crashes the VM, which might be the case if we load the wrong default library\n-        \/\/ and end up mixing two allocators together.\n-        freeMemory(seg);\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/foreign\/malloc\/TestMixedMallocFree.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-#include <stdlib.h>\n-\n-#ifdef _WIN64\n-#define EXPORT __declspec(dllexport)\n-#else\n-#define EXPORT\n-#endif\n-\n-EXPORT void* my_malloc(size_t size) {\n-    return malloc(size);\n-}\n","filename":"test\/jdk\/java\/foreign\/malloc\/libMalloc.c","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -45,1 +45,1 @@\n-        String timeStamp = java.time.Instant.now().toString();\n+        String timeStamp = System.currentTimeMillis() + \"\";\n","filename":"test\/jdk\/java\/io\/File\/TempDirDoesNotExist.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-        \/\/ overflows around 709.8, sinh(x) ~= exp(x)\/2; will will test\n+        \/\/ overflows around 709.8, sinh(x) ~= exp(x)\/2; will test\n@@ -628,1 +628,1 @@\n-        \/\/ overflows around 709.8, cosh(x) ~= exp(x)\/2; will will test\n+        \/\/ overflows around 709.8, cosh(x) ~= exp(x)\/2; will test\n","filename":"test\/jdk\/java\/lang\/Math\/HyperbolicTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 6980747\n+ * @bug 6980747 8297451\n@@ -55,0 +55,11 @@\n+    \/\/ Security manager that unconditionally performs Thread Modify Access checks.\n+    @SuppressWarnings(\"removal\")\n+    private static class TMACSecurityManager extends SecurityManager {\n+        static final RuntimePermission MODIFY_THREAD_PERMISSION =\n+                new RuntimePermission(\"modifyThread\");\n+        @Override\n+        public void checkAccess(Thread thread) {\n+            checkPermission(MODIFY_THREAD_PERMISSION);\n+        }\n+    }\n+\n@@ -63,1 +74,2 @@\n-             new RuntimePermission(\"setSecurityManager\"));\n+             new RuntimePermission(\"setSecurityManager\"),\n+             new RuntimePermission(\"modifyThread\"));\n@@ -66,1 +78,1 @@\n-        System.setSecurityManager(new SecurityManager());\n+        System.setSecurityManager(new TMACSecurityManager());\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/SecurityManagerClinit.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n- * @compile --enable-preview -source ${jdk.version} BuilderTest.java\n- * @run testng\/othervm --enable-preview BuilderTest\n+ * @enablePreview\n+ * @run testng BuilderTest\n","filename":"test\/jdk\/java\/lang\/Thread\/BuilderTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n- * @compile --enable-preview -source ${jdk.version} Collectable.java\n- * @run testng\/othervm --enable-preview Collectable\n+ * @enablePreview\n+ * @run testng Collectable\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/Collectable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n- * @compile --enable-preview -source ${jdk.version} CustomScheduler.java\n- * @run testng\/othervm --enable-preview CustomScheduler\n+ * @enablePreview\n+ * @run testng CustomScheduler\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/CustomScheduler.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n- * @compile --enable-preview -source ${jdk.version} GetStackTrace.java\n- * @run testng\/othervm --enable-preview GetStackTrace\n+ * @enablePreview\n+ * @run testng GetStackTrace\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/GetStackTrace.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n- * @compile --enable-preview -source ${jdk.version} GetStackTraceWhenRunnable.java\n- * @run main\/othervm --enable-preview -Djdk.virtualThreadScheduler.maxPoolSize=1 GetStackTraceWhenRunnable\n+ * @enablePreview\n+ * @run main\/othervm -Djdk.virtualThreadScheduler.maxPoolSize=1 GetStackTraceWhenRunnable\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/GetStackTraceWhenRunnable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n- * @compile --enable-preview -source ${jdk.version} HoldsLock.java\n- * @run testng\/othervm --enable-preview HoldsLock\n+ * @enablePreview\n+ * @run testng HoldsLock\n@@ -38,2 +38,2 @@\n- * @compile --enable-preview -source ${jdk.version} HoldsLock.java\n- * @run testng\/othervm --enable-preview -XX:+UseHeavyMonitors HoldsLock\n+ * @enablePreview\n+ * @run testng\/othervm -XX:+UseHeavyMonitors HoldsLock\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/HoldsLock.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n- * @compile --enable-preview -source ${jdk.version} JfrEvents.java\n- * @run testng\/othervm --enable-preview JfrEvents\n+ * @enablePreview\n+ * @run testng\/othervm JfrEvents\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/JfrEvents.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n- * @compile --enable-preview -source ${jdk.version} Locking.java\n- * @run testng\/othervm --enable-preview Locking\n+ * @enablePreview\n+ * @run testng Locking\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/Locking.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n- * @compile --enable-preview -source ${jdk.version} ParkWithFixedThreadPool.java\n- * @run testng\/othervm --enable-preview ParkWithFixedThreadPool\n+ * @enablePreview\n+ * @run testng ParkWithFixedThreadPool\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ParkWithFixedThreadPool.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n- * @compile --enable-preview -source ${jdk.version} Parking.java\n- * @run testng\/othervm --enable-preview Parking\n+ * @enablePreview\n+ * @run testng Parking\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/Parking.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n- * @compile --enable-preview -source ${jdk.version} Reflection.java\n- * @run testng\/othervm --enable-preview Reflection\n+ * @enablePreview\n+ * @run testng Reflection\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/Reflection.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n- * @compile --enable-preview -source ${jdk.version} ShutdownHook.java\n- * @run main\/othervm --enable-preview ShutdownHook test\n+ * @enablePreview\n+ * @run main ShutdownHook test\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ShutdownHook.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,3 +31,3 @@\n- * @compile --enable-preview -source ${jdk.version} StackTraces.java\n- * @run testng\/othervm --enable-preview StackTraces\n- * @run testng\/othervm --enable-preview -XX:+UnlockDiagnosticVMOptions -XX:+ShowCarrierFrames StackTraces\n+ * @enablePreview\n+ * @run testng StackTraces\n+ * @run testng\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+ShowCarrierFrames StackTraces\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/StackTraces.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n- * @compile --enable-preview -source ${jdk.version} ThreadLocals.java\n- * @run testng\/othervm --enable-preview ThreadLocals\n+ * @enablePreview\n+ * @run testng ThreadLocals\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadLocals.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n- * @compile --enable-preview -source ${jdk.version} WaitNotify.java\n- * @run testng\/othervm --enable-preview WaitNotify\n+ * @enablePreview\n+ * @run testng WaitNotify\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/WaitNotify.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,3 +29,3 @@\n- * @compile --enable-preview -source ${jdk.version} GetStackTraceALot.java ..\/ThreadBuilders.java\n- * @run main\/othervm --enable-preview GetStackTraceALot\n- *\n+ * @enablePreview\n+ * @compile GetStackTraceALot.java ..\/ThreadBuilders.java\n+ * @run main GetStackTraceALot\n@@ -38,2 +38,3 @@\n- * @compile --enable-preview -source ${jdk.version} GetStackTraceALot.java ..\/ThreadBuilders.java\n- * @run main\/othervm\/timeout=300 --enable-preview GetStackTraceALot 1000\n+ * @enablePreview\n+ * @compile GetStackTraceALot.java ..\/ThreadBuilders.java\n+ * @run main\/timeout=300 GetStackTraceALot 1000\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/GetStackTraceALot.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * Class to have an indirectly missing annotation applied for for\n+ * Class to have an indirectly missing annotation applied for\n","filename":"test\/jdk\/java\/lang\/annotation\/Missing\/B.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,2 +40,3 @@\n- * @compile --enable-preview -source ${jdk.version} SwitchBootstrapsTest.java\n- * @run testng\/othervm --enable-preview SwitchBootstrapsTest\n+ * @enablePreview\n+ * @compile SwitchBootstrapsTest.java\n+ * @run testng\/othervm SwitchBootstrapsTest\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-             * dividend (i.e. this) and and divisor since the scales\n+             * dividend (i.e. this) and divisor since the scales\n","filename":"test\/jdk\/java\/math\/BigDecimal\/DivideTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,2 +29,3 @@\n- * @compile --enable-preview -source ${jdk.version} Timeouts.java\n- * @run testng\/othervm\/timeout=180 --enable-preview Timeouts\n+ * @enablePreview\n+ * @compile Timeouts.java\n+ * @run testng\/othervm\/timeout=180 Timeouts\n@@ -255,1 +256,1 @@\n-            \/\/ schedule s2 to be be closed\n+            \/\/ schedule s2 to be closed\n","filename":"test\/jdk\/java\/net\/Socket\/Timeouts.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-                            System.err.println(\"ERROR: Client closed before before \" +\n+                            System.err.println(\"ERROR: Client closed before \" +\n","filename":"test\/jdk\/java\/net\/URLConnection\/DisconnectAfterEOF.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.URLPermission;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test\n+ * @bug 8297311\n+ * @summary Verify that the exception thrown by URLPermission class, for invalid host name,\n+ * contains expected exception message\n+ * @run testng InvalidCharacterTest\n+ *\/\n+public class InvalidCharacterTest {\n+\n+    \/**\n+     * Creates an instance of URLPermission with a string containing invalid character\n+     * and verifies that the construction fails with IllegalArgumentException\n+     *\/\n+    @Test\n+    public void testIllegalArgException() throws Exception {\n+        final char invalidChar = '%';\n+        \/\/ we expect this string in the exception message\n+        final String expectedStringInMessage = String.format(\"\\\\u%04x\", (int) invalidChar);\n+        final String url = \"http:\/\/foo\" + invalidChar + \"bar.com:12345\";\n+        final IllegalArgumentException iae = Assert.expectThrows(IllegalArgumentException.class,\n+                () -> new URLPermission(url));\n+        \/\/ additionally check the error message contains the invalid char\n+        final String exMessage = iae.getMessage();\n+        System.out.println(\"Got exception message: \" + exMessage);\n+        Assert.assertNotNull(exMessage, \"Exception message is null\");\n+        Assert.assertTrue(exMessage.contains(expectedStringInMessage),\n+                expectedStringInMessage + \" missing from exception message: \" + exMessage);\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/URLPermission\/InvalidCharacterTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+import java.time.Duration;\n@@ -106,1 +107,1 @@\n-                \"outstanding operations or unreleased resources\", false);\n+                \"outstanding operations or unreleased resources\", true);\n@@ -213,0 +214,3 @@\n+        long waitStart = System.nanoTime();\n+        long waited = 0;\n+        long toWait = Math.min(graceDelayMs, Math.max(delay, 1));\n@@ -220,1 +224,2 @@\n-                    Thread.sleep(Math.min(graceDelayMs, Math.max(delay, 1)));\n+                    waited += toWait;\n+                    Thread.sleep(toWait);\n@@ -224,1 +229,6 @@\n-            } else break;\n+            } else {\n+                System.out.println(\"No outstanding HTTP operations remaining after \"\n+                        + i + \"\/\" + count + \" iterations and \" + waited + \"\/\" + graceDelayMs\n+                        + \" ms, (wait\/iteration \" + toWait + \" ms)\");\n+                break;\n+            }\n@@ -226,0 +236,1 @@\n+        long duration = Duration.ofNanos(System.nanoTime() - waitStart).toMillis();\n@@ -232,1 +243,2 @@\n-            System.out.println(\"PASSED: No \" + description + \" found in \" + tracker.getName());\n+            System.out.println(\"PASSED: No \" + description + \" found in \"\n+                    + tracker.getName() + \" in \" + duration + \" ms\");\n@@ -236,2 +248,3 @@\n-                printThreads(\"Some selector manager threads are still alive: \", System.out);\n-                printThreads(\"Some selector manager threads are still alive: \", System.err);\n+                var msg = \"Selector manager threads are still alive for \" + tracker.getName() + \": \";\n+                printThreads(msg, System.out);\n+                printThreads(msg, System.err);\n@@ -239,0 +252,2 @@\n+            System.out.println(\"AssertionError: Found some \" + description + \" in \"\n+                    + tracker.getName() + \" after \" + duration + \" ms, waited \" + waited + \" ms\");\n","filename":"test\/jdk\/java\/net\/httpclient\/ReferenceTracker.java","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @bug 8203771 8218546\n+ * @bug 8203771 8218546 8297200\n@@ -49,0 +49,1 @@\n+import jdk.internal.net.http.common.OperationTrackers.Tracker;\n@@ -304,0 +305,5 @@\n+    static void throwIfNotNull(Throwable throwable) throws Exception {\n+        if (throwable instanceof Exception ex) throw ex;\n+        if (throwable instanceof Error e) throw e;\n+    }\n+\n@@ -310,1 +316,1 @@\n-        out.println(\"\\n--- Starting \");\n+        out.println(\"\\n--- Starting test \" + now());\n@@ -322,0 +328,2 @@\n+        Tracker tracker = null;\n+        Throwable thrown = null;\n@@ -324,1 +332,1 @@\n-                if (!sameClient || client == null)\n+                if (!sameClient || client == null) {\n@@ -326,0 +334,2 @@\n+                    tracker = TRACKER.getTracker(client);\n+                }\n@@ -365,0 +375,2 @@\n+            } catch (Throwable x) {\n+                thrown = x;\n@@ -369,2 +381,5 @@\n-                    var error = TRACKER.check(500);\n-                    if (error != null) throw error;\n+                    var error = TRACKER.check(tracker, 500);\n+                    if (error != null) {\n+                        if (thrown != null) error.addSuppressed(thrown);\n+                        throw error;\n+                    }\n@@ -373,0 +388,1 @@\n+            throwIfNotNull(thrown);\n@@ -382,1 +398,1 @@\n-        out.println(\"\\n--- Starting \");\n+        out.println(\"\\n--- Starting testHomeMadeIllegalHeader \" + now());\n@@ -386,1 +402,2 @@\n-\n+        Tracker tracker = TRACKER.getTracker(client);\n+        Throwable thrown = null;\n@@ -433,0 +450,2 @@\n+        } catch (Throwable x) {\n+            thrown = x;\n@@ -437,2 +456,5 @@\n-                var error = TRACKER.check(500);\n-                if (error != null) throw error;\n+                var error = TRACKER.check(tracker, 500);\n+                if (error != null) {\n+                    if (thrown != null) error.addSuppressed(thrown);\n+                    throw error;\n+                }\n@@ -441,0 +463,1 @@\n+        throwIfNotNull(thrown);\n@@ -443,0 +466,2 @@\n+\n+\n@@ -444,2 +469,4 @@\n-    void testAsync(String uriString, String headerNameAndValue, boolean sameClient) {\n-        out.println(\"\\n--- Starting \");\n+    void testAsync(String uriString, String headerNameAndValue, boolean sameClient)\n+            throws Exception\n+    {\n+        out.println(\"\\n--- Starting testAsync \" + now());\n@@ -456,0 +483,2 @@\n+        Tracker tracker = null;\n+        Throwable thrown = null;\n@@ -458,1 +487,1 @@\n-                if (!sameClient || client == null)\n+                if (!sameClient || client == null) {\n@@ -460,0 +489,2 @@\n+                    tracker = TRACKER.getTracker(client);\n+                }\n@@ -502,0 +533,2 @@\n+            } catch (Throwable x) {\n+                thrown = x;\n@@ -506,2 +539,5 @@\n-                    var error = TRACKER.check(500);\n-                    if (error != null) throw error;\n+                    var error = TRACKER.check(tracker, 500);\n+                    if (error != null) {\n+                        if (thrown != null) error.addSuppressed(thrown);\n+                        throw error;\n+                    }\n@@ -510,0 +546,1 @@\n+            throwIfNotNull(thrown);\n@@ -520,0 +557,1 @@\n+        out.println(\"--- Starting setup \" + now());\n@@ -552,0 +590,1 @@\n+        out.println(\"\\n--- Teardown \" + now());\n@@ -558,1 +597,2 @@\n-        AssertionError fail = TRACKER.check(500);\n+        AssertionError fail = TRACKER.check(2500);\n+        out.println(\"--- Stopping servers \" + now());\n","filename":"test\/jdk\/java\/net\/httpclient\/SpecialHeadersTest.java","additions":55,"deletions":15,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowPublisherVerification;\n-\n-import java.net.http.HttpRequest.BodyPublisher;\n-import java.net.http.HttpRequest.BodyPublishers;\n-import java.nio.ByteBuffer;\n-import java.util.Collections;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.concurrent.Flow.Publisher;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodyPublishersConcat\n-        extends FlowPublisherVerification<ByteBuffer> {\n-\n-    private static final int ELEMENT_SIZE = 16 * 1024;\n-\n-    public BodyPublishersConcat() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    private static BodyPublisher ofByteArrays(int n, byte[] bytes) {\n-        return BodyPublishers.ofByteArrays(Collections.nCopies((int) n, bytes));\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFlowPublisher(long nElements) {\n-        System.out.println(\"BodyPublishersConcat: %d elements requested\"\n-                .formatted(nElements));\n-        byte[] bytes = S.arrayOfNRandomBytes(ELEMENT_SIZE);\n-        if (nElements == 0) {\n-            System.out.println(\"BodyPublishersConcat: empty publisher\");\n-            return BodyPublishers.concat();\n-        } else if (nElements == 1) {\n-            System.out.println(\"BodyPublishersConcat: singleton publisher\");\n-            return BodyPublishers.concat(ofByteArrays(1, bytes));\n-        } else if (nElements < 4) {\n-            int left = (int)nElements\/2;\n-            int right = (int)nElements - left;\n-            System.out.println(\"BodyPublishersConcat: dual publisher (%d, %d)\".formatted(left, right));\n-            return BodyPublishers.concat(ofByteArrays(left, bytes),\n-                    ofByteArrays(right, bytes));\n-        } else {\n-            List<BodyPublisher> publishers = new ArrayList<>();\n-            List<Integer> sizes = new ArrayList<>();\n-            long remaining = nElements;\n-            int max = (int) Math.min((long)Integer.MAX_VALUE, nElements\/2L);\n-            while (remaining > 0) {\n-                int length = S.randomIntUpTo(max);\n-                if (length == 0) length = 1;\n-                sizes.add(length);\n-                if (remaining > length) {\n-                    publishers.add(ofByteArrays(length, bytes));\n-                    remaining = remaining - length;\n-                } else {\n-                    publishers.add(ofByteArrays((int)remaining, bytes));\n-                    remaining = 0;\n-                }\n-            }\n-            System.out.println(\"BodyPublishersConcat: multi publisher \" + sizes);\n-            return BodyPublishers.concat(publishers.toArray(BodyPublisher[]::new));\n-        }\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFailedFlowPublisher() {\n-        return null;\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodyPublishersConcat.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowPublisherVerification;\n-\n-import java.net.http.HttpRequest.BodyPublishers;\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.Flow.Publisher;\n-import java.util.stream.Stream;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodyPublishersFromPublisher\n-        extends FlowPublisherVerification<ByteBuffer> {\n-\n-    public BodyPublishersFromPublisher() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFlowPublisher(long nElements) {\n-        Stream<ByteBuffer> buffers =\n-                Stream.generate(() -> S.bufferOfNRandomBytes(1024))\n-                      .limit(nElements);\n-        Publisher<ByteBuffer> pub = S.publisherOfStream(buffers);\n-        return BodyPublishers.fromPublisher(pub);\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFailedFlowPublisher() {\n-        return BodyPublishers.fromPublisher(S.newErroredPublisher());\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodyPublishersFromPublisher.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowPublisherVerification;\n-\n-import java.net.http.HttpRequest.BodyPublishers;\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.Flow.Publisher;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodyPublishersNoBody\n-        extends FlowPublisherVerification<ByteBuffer> {\n-\n-    public BodyPublishersNoBody() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFlowPublisher(long nElements) {\n-        return BodyPublishers.noBody();\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFailedFlowPublisher() {\n-        return null;\n-    }\n-\n-    @Override\n-    public long maxElementsFromPublisher() {\n-        return 0;\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodyPublishersNoBody.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowPublisherVerification;\n-\n-import java.net.http.HttpRequest.BodyPublishers;\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.Flow.Publisher;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodyPublishersOfByteArray\n-        extends FlowPublisherVerification<ByteBuffer> {\n-\n-    private static final int ELEMENT_SIZE = 16 * 1024;\n-\n-    public BodyPublishersOfByteArray() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFlowPublisher(long nElements) {\n-        byte[] b = S.arrayOfNRandomBytes(nElements * ELEMENT_SIZE);\n-        return BodyPublishers.ofByteArray(b);\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFailedFlowPublisher() {\n-        return null;\n-    }\n-\n-    @Override\n-    public long maxElementsFromPublisher() {\n-        return 21;\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodyPublishersOfByteArray.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowPublisherVerification;\n-\n-import java.net.http.HttpRequest.BodyPublishers;\n-import java.nio.ByteBuffer;\n-import java.util.Collections;\n-import java.util.concurrent.Flow.Publisher;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodyPublishersOfByteArrays\n-        extends FlowPublisherVerification<ByteBuffer> {\n-\n-    private static final int ELEMENT_SIZE = 16 * 1024;\n-\n-    public BodyPublishersOfByteArrays() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFlowPublisher(long nElements) {\n-        byte[] bytes = S.arrayOfNRandomBytes(ELEMENT_SIZE);\n-        return BodyPublishers.ofByteArrays(\n-                Collections.nCopies((int) nElements, bytes));\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFailedFlowPublisher() {\n-        return null;\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodyPublishersOfByteArrays.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowPublisherVerification;\n-\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.net.http.HttpRequest.BodyPublishers;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.concurrent.Flow.Publisher;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodyPublishersOfFile\n-        extends FlowPublisherVerification<ByteBuffer> {\n-\n-    private static final int ELEMENT_SIZE = 16 * 1024;\n-    private static final AtomicLong UNIQUE_NUMBERS = new AtomicLong();\n-\n-    public BodyPublishersOfFile() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFlowPublisher(long nElements) {\n-        try {\n-            Path f = createFile(nElements * ELEMENT_SIZE);\n-            return BodyPublishers.ofFile(f);\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-    }\n-\n-    private static Path createFile(long nBytes) throws IOException {\n-        String name = \"f\" + UNIQUE_NUMBERS.getAndIncrement();\n-        Path f = Files.createFile(Path.of(name));\n-        return Files.write(f, S.arrayOfNRandomBytes(nBytes));\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFailedFlowPublisher() {\n-        return null;\n-    }\n-\n-    @Override\n-    public long maxElementsFromPublisher() {\n-        return 21;\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodyPublishersOfFile.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowPublisherVerification;\n-\n-import java.io.InputStream;\n-import java.net.http.HttpRequest.BodyPublishers;\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.Flow.Publisher;\n-import java.util.function.Supplier;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodyPublishersOfInputStream\n-        extends FlowPublisherVerification<ByteBuffer> {\n-\n-    public BodyPublishersOfInputStream() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFlowPublisher(long nElements) {\n-        Supplier<InputStream> s = () -> S.inputStreamOfNReads((int) nElements);\n-        return BodyPublishers.ofInputStream(s);\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFailedFlowPublisher() {\n-        return null;\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodyPublishersOfInputStream.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowPublisherVerification;\n-\n-import java.net.http.HttpRequest.BodyPublishers;\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.Flow.Publisher;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodyPublishersOfSubByteArray\n-        extends FlowPublisherVerification<ByteBuffer> {\n-\n-    private static final int ELEMENT_SIZE = 16 * 1024;\n-\n-    public BodyPublishersOfSubByteArray() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFlowPublisher(long nElements) {\n-        int prefixLen = S.randomIntUpTo(13);\n-        int postfixLen = S.randomIntUpTo(17);\n-        byte[] b = S.arrayOfNRandomBytes(nElements * ELEMENT_SIZE);\n-        byte[] contents = new byte[prefixLen + b.length + postfixLen];\n-        System.arraycopy(b, 0, contents, prefixLen, b.length);\n-        return BodyPublishers.ofByteArray(contents, prefixLen, b.length);\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFailedFlowPublisher() {\n-        return null;\n-    }\n-\n-    @Override\n-    public long maxElementsFromPublisher() {\n-        return 21;\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodyPublishersOfSubByteArray.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.util.List;\n-import java.util.concurrent.Flow.Subscriber;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersBuffering\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersBuffering() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        return BodySubscribers.buffering(BodySubscribers.discarding(),\n-                                         S.randomIntUpTo(1024) + 1);\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.listOfBuffersFromBufferOfNBytes(element % 17);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersBuffering.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.util.List;\n-import java.util.concurrent.Flow.Subscriber;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersDiscarding\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersDiscarding() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        return BodySubscribers.discarding();\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.listOfBuffersFromBufferOfNBytes(element % 17);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersDiscarding.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.util.List;\n-import java.util.concurrent.Flow.Subscriber;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersFromLineSubscriber\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersFromLineSubscriber() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        return BodySubscribers.fromLineSubscriber(\n-                S.nonCompliantSubscriber());\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.scatterBuffer(\n-                S.bufferOfNRandomASCIIBytes(element % 17));\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersFromLineSubscriber.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.util.List;\n-import java.util.concurrent.Flow.Subscriber;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersFromSubscriber\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersFromSubscriber() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        Subscriber<List<ByteBuffer>> sub = S.nonCompliantSubscriber();\n-        return BodySubscribers.fromSubscriber(sub);\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.scatterBuffer(\n-                S.bufferOfNRandomASCIIBytes(element % 17));\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersFromSubscriber.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.util.List;\n-import java.util.concurrent.Flow.Subscriber;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersMapping\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersMapping() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        return BodySubscribers.mapping(BodySubscribers.ofByteArray(),\n-                                       bytes -> bytes.length);\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.listOfBuffersFromBufferOfNBytes(element % 17);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersMapping.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.util.List;\n-import java.util.concurrent.Flow.Subscriber;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersOfByteArray\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersOfByteArray() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        return BodySubscribers.ofByteArray();\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.listOfBuffersFromBufferOfNBytes(element % 17);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersOfByteArray.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.util.List;\n-import java.util.concurrent.Flow.Subscriber;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersOfByteArrayConsumer\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersOfByteArrayConsumer() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        return BodySubscribers.ofByteArrayConsumer(bytes -> { });\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.listOfBuffersFromBufferOfNBytes(element % 17);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersOfByteArrayConsumer.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Path;\n-import java.util.List;\n-import java.util.concurrent.Flow.Subscriber;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersOfFile\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersOfFile() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        return BodySubscribers.ofFile(Path.of(\"f1.bin\"));\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.listOfBuffersFromBufferOfNBytes(element % 17);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersOfFile.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.util.List;\n-import java.util.concurrent.Flow.Subscriber;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersOfInputStream\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersOfInputStream() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        return BodySubscribers.ofInputStream();\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.listOfBuffersFromBufferOfNBytes(element % 17);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersOfInputStream.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.nio.charset.StandardCharsets;\n-import java.util.List;\n-import java.util.concurrent.Flow.Subscriber;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersOfLines\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersOfLines() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        return BodySubscribers.ofLines(StandardCharsets.UTF_8);\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.scatterBuffer(\n-                S.bufferOfNRandomASCIIBytes(element % 17));\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersOfLines.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscriber;\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.util.List;\n-import java.util.concurrent.CompletionStage;\n-import java.util.concurrent.Flow.Publisher;\n-import java.util.concurrent.Flow.Subscriber;\n-import java.util.concurrent.Flow.Subscription;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersOfPublisher\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersOfPublisher() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    \/* The reason for overriding this method is that BodySubscribers.ofPublisher\n-       is somewhat tricky. It is not an independent Subscriber, but rather\n-       an adaptor from Subscriber to Publisher. Until the Subscriber that\n-       subscribed to that resulting Publisher requests anything, nothing\n-       happens. *\/\n-    @Override\n-    public void triggerFlowRequest(\n-            Subscriber<? super List<ByteBuffer>> subscriber)\n-    {\n-        BodySubscriber<Publisher<List<ByteBuffer>>> sub =\n-                (BodySubscriber<Publisher<List<ByteBuffer>>>) subscriber;\n-        CompletionStage<Publisher<List<ByteBuffer>>> body = sub.getBody();\n-        Publisher<List<ByteBuffer>> pub = body.toCompletableFuture().join();\n-        pub.subscribe(new Subscriber<>() {\n-\n-            @Override\n-            public void onSubscribe(Subscription subscription) {\n-                subscription.request(Integer.MAX_VALUE);\n-            }\n-\n-            @Override public void onNext(List<ByteBuffer> item) { }\n-            @Override public void onError(Throwable throwable) { }\n-            @Override public void onComplete() { }\n-        });\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        return BodySubscribers.ofPublisher();\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.listOfBuffersFromBufferOfNBytes(element % 17);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersOfPublisher.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscriber;\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.util.List;\n-import java.util.concurrent.CompletionStage;\n-import java.util.concurrent.Flow.Publisher;\n-import java.util.concurrent.Flow.Subscriber;\n-import java.util.concurrent.Flow.Subscription;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersOfPublisher1\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersOfPublisher1() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    \/* The reason for overriding this method is that BodySubscribers.ofPublisher\n-       is somewhat tricky. It is not an independent Subscriber, but rather\n-       an adaptor from Subscriber to Publisher. Until the Subscriber that\n-       subscribed to that resulting Publisher requests anything, nothing\n-       happens. *\/\n-    @Override\n-    public void triggerFlowRequest(\n-            Subscriber<? super List<ByteBuffer>> subscriber)\n-    {\n-        BodySubscriber<Publisher<List<ByteBuffer>>> sub =\n-                (BodySubscriber<Publisher<List<ByteBuffer>>>) subscriber;\n-        CompletionStage<Publisher<List<ByteBuffer>>> body = sub.getBody();\n-        Publisher<List<ByteBuffer>> pub = body.toCompletableFuture().join();\n-        pub.subscribe(new Subscriber<>() {\n-\n-            Subscription sub;\n-\n-            @Override\n-            public void onSubscribe(Subscription subscription) {\n-                (sub = subscription).request(1);\n-            }\n-\n-            @Override public void onNext(List<ByteBuffer> item) {\n-                sub.request(1);\n-            }\n-\n-            @Override public void onError(Throwable throwable) { }\n-            @Override public void onComplete() { }\n-        });\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        return BodySubscribers.ofPublisher();\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.listOfBuffersFromBufferOfNBytes(element % 17);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersOfPublisher1.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowPublisherVerification;\n-\n-import java.net.http.HttpResponse.BodySubscriber;\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.util.List;\n-import java.util.concurrent.Flow.Publisher;\n-import java.util.stream.Stream;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersOfPublisherPublisher\n-        extends FlowPublisherVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersOfPublisherPublisher() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Publisher<List<ByteBuffer>> createFlowPublisher(long nElements) {\n-        BodySubscriber<Publisher<List<ByteBuffer>>> sub =\n-                BodySubscribers.ofPublisher();\n-        Stream<List<ByteBuffer>> buffers =\n-                Stream.generate(() -> S.listOfBuffersFromBufferOfNBytes(1024))\n-                      .limit(nElements);\n-        Publisher<List<ByteBuffer>> pub = S.publisherOfStream(buffers);\n-        pub.subscribe(sub);\n-        return sub.getBody().toCompletableFuture().join();\n-    }\n-\n-    @Override\n-    public Publisher<List<ByteBuffer>> createFailedFlowPublisher() {\n-        BodySubscriber<Publisher<List<ByteBuffer>>> sub =\n-                BodySubscribers.ofPublisher();\n-        Publisher<List<ByteBuffer>> pub = S.newErroredPublisher();\n-        pub.subscribe(sub);\n-        return sub.getBody().toCompletableFuture().join();\n-    }\n-\n-    @Override\n-    public long maxElementsFromPublisher() {\n-        return 21;\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersOfPublisherPublisher.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.nio.charset.StandardCharsets;\n-import java.util.List;\n-import java.util.concurrent.Flow.Subscriber;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersOfString\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersOfString() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        return BodySubscribers.ofString(StandardCharsets.UTF_8);\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.scatterBuffer(\n-                S.bufferOfNRandomASCIIBytes(element % 17));\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersOfString.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.util.List;\n-import java.util.concurrent.Flow.Subscriber;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersReplacing\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersReplacing() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        \/* it doesn't matter what we are replacing with *\/\n-        return BodySubscribers.replacing(Boolean.TRUE);\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.listOfBuffersFromBufferOfNBytes(element % 17);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersReplacing.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,277 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.nio.ByteBuffer;\n-import java.nio.charset.StandardCharsets;\n-import java.security.SecureRandom;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Random;\n-import java.util.concurrent.Flow.Publisher;\n-import java.util.concurrent.Flow.Subscriber;\n-import java.util.concurrent.Flow.Subscription;\n-import java.util.stream.Stream;\n-\n-\/*\n- * S for Support.\n- *\n- * Auxiliary methods for tests that check conformance with reactive streams\n- * specification.\n- *\n- * Short name is for the sake of convenience calling this class' static methods.\n- * It could've been called Support or TckSupport, but then we would need to\n- * place this class in its own package so as to use \"import static\".\n- *\/\n-public class S {\n-\n-    private static final Random RANDOM = new SecureRandom();\n-\n-    private S() { }\n-\n-    public static List<ByteBuffer> listOfBuffersFromBufferOfNBytes(int nBytes) {\n-        return scatterBuffer(bufferOfNRandomBytes(nBytes));\n-    }\n-\n-    \/*\n-     * Spreads the remaining contents of the given byte buffer across a number\n-     * of buffers put into a list.\n-     *\/\n-    public static List<ByteBuffer> scatterBuffer(ByteBuffer src) {\n-        List<ByteBuffer> buffers = new ArrayList<>();\n-        while (src.hasRemaining()) {\n-            \/\/ We do not allow empty buffers ~~~~~~~~~~~~~~~~v\n-            int capacity = RANDOM.nextInt(src.remaining()) + 1;\n-            ByteBuffer b = ByteBuffer.allocate(capacity);\n-            for (int i = 0; i < capacity; i++) {\n-                b.put(src.get());\n-            }\n-            b.flip();\n-            buffers.add(b);\n-        }\n-        return List.copyOf(buffers);\n-    }\n-\n-    public static ByteBuffer bufferOfNRandomBytes(int capacity) {\n-        return ByteBuffer.wrap(arrayOfNRandomBytes(capacity));\n-    }\n-\n-    public static byte[] arrayOfNRandomBytes(int nBytes) {\n-        byte[] contents = new byte[nBytes];\n-        RANDOM.nextBytes(contents);\n-        return contents;\n-    }\n-\n-    public static InputStream inputStreamOfNReads(long n) {\n-        return new NReadsInputStream(n);\n-    }\n-\n-    \/*\n-     * Convenience method for testing publishers.\n-     *\/\n-    public static byte[] arrayOfNRandomBytes(long nBytes) {\n-        return arrayOfNRandomBytes((int) nBytes);\n-    }\n-\n-    public static ByteBuffer bufferOfNRandomASCIIBytes(int capacity) {\n-        String alphaNumeric = \"abcdefghijklmnopqrstuvwxyz1234567890\";\n-        StringBuilder builder = new StringBuilder(capacity);\n-        for (int i = 0; i < capacity; i++) {\n-            int idx = RANDOM.nextInt(alphaNumeric.length());\n-            builder.append(alphaNumeric.charAt(idx));\n-        }\n-        return ByteBuffer.wrap(builder.toString().getBytes(\n-                StandardCharsets.US_ASCII));\n-    }\n-\n-    \/*\n-     * Returns a simple non-compliant Subscriber.\n-     *\n-     * This Subscriber is useful for testing our adaptors and wrappers, to make\n-     * sure they do not delegate RS compliance to the underlying (and foreign to\n-     * java.net.http codebase) Subscribers, but rather comply themselves.\n-     *\n-     * Here's an example:\n-     *\n-     *     public void onSubscribe(Subscription s) {\n-     *         delegate.onSubscribe(s);\n-     *     }\n-     *\n-     * The snippet above cannot be considered a good implementation of a\n-     * Subscriber if `delegate` is an unknown Subscriber. In this case the\n-     * implementation should independently check all the rules from the RS spec\n-     * related to subscribers.\n-     *\/\n-    public static <T> Subscriber<T> nonCompliantSubscriber() {\n-        return new Subscriber<>() {\n-\n-            @Override\n-            public void onSubscribe(Subscription subscription) {\n-                subscription.request(Long.MAX_VALUE);\n-            }\n-\n-            @Override\n-            public void onNext(T item) { }\n-\n-            @Override\n-            public void onError(Throwable throwable) { }\n-\n-            @Override\n-            public void onComplete() { }\n-        };\n-    }\n-\n-    public static int randomIntUpTo(int bound) {\n-        return RANDOM.nextInt(bound);\n-    }\n-\n-    \/*\n-     * Signals an error to its subscribers immediately after subscription.\n-     *\/\n-    public static <T> Publisher<T> newErroredPublisher() {\n-        return subscriber -> {\n-            subscriber.onSubscribe(new Subscription() {\n-                @Override\n-                public void request(long n) { }\n-\n-                @Override\n-                public void cancel() { }\n-            });\n-            subscriber.onError(new IOException());\n-        };\n-    }\n-\n-    \/*\n-     * Publishes the elements obtained from the stream and signals completion.\n-     * Can be cancelled, but cannot signal an error.\n-     *\n-     * This trivial ad-hoc implementation of Publisher was created so as to\n-     * publish lists of byte buffers. We can publish ByteBuffer, but we can't\n-     * seem to publish List<ByteBuffer> since there's no readily available\n-     * publisher of those, nor there's a simple adaptor.\n-     *\/\n-    public static <T> Publisher<T> publisherOfStream(Stream<? extends T> stream)\n-    {\n-        if (stream == null) {\n-            throw new NullPointerException();\n-        }\n-        return new Publisher<T>() {\n-            @Override\n-            public void subscribe(Subscriber<? super T> subscriber) {\n-                if (subscriber == null) {\n-                    throw new NullPointerException();\n-                }\n-                Subscription subscription = new Subscription() {\n-\n-                    boolean inOnNext; \/\/ recursion control\n-                    volatile boolean cancelled;\n-                    long demand;\n-                    final Iterator<? extends T> supply = stream.iterator();\n-\n-                    @Override\n-                    public void request(long n) {\n-                        demand = demand + n < 0 ? Long.MAX_VALUE : demand + n;\n-                        if (inOnNext) {\n-                            return;\n-                        }\n-                        if (cancelled)\n-                            return;\n-                        if (n <= 0) {\n-                            cancelled = true;\n-                            subscriber.onError(new IllegalArgumentException(\n-                                    \"non-positive subscription request\"));\n-                            return;\n-                        }\n-                        while (supply.hasNext() && demand > 0 && !cancelled) {\n-                            demand--;\n-                            inOnNext = true;\n-                            try {\n-                                T item = supply.next();\n-                                subscriber.onNext(item);\n-                            } finally {\n-                                inOnNext = false;\n-                            }\n-                        }\n-                        if (!supply.hasNext()) {\n-                            cancelled = true;\n-                            subscriber.onComplete();\n-                        }\n-                    }\n-\n-                    @Override\n-                    public void cancel() {\n-                        cancelled = true;\n-                    }\n-                };\n-                subscriber.onSubscribe(subscription);\n-            }\n-        };\n-    }\n-\n-    static final class NReadsInputStream extends InputStream {\n-\n-        private static final int EOF = -1;\n-        private long readsLeft;\n-\n-        NReadsInputStream(long n) {\n-            if (n < 0) {\n-                throw new IllegalArgumentException(String.valueOf(n));\n-            }\n-            this.readsLeft = n;\n-        }\n-\n-        @Override\n-        public int read() {\n-            if (readsLeft == 0L) {\n-                return EOF;\n-            }\n-            readsLeft--;\n-            return S.randomIntUpTo(256);\n-        }\n-\n-        @Override\n-        public int read(byte[] b, int off, int len) {\n-            Objects.checkFromIndexSize(off, len, b.length);\n-            \/\/ Must return 0 if len == 0,\n-            \/\/ even if there are no more reads left\n-            if (len == 0) {\n-                return 0;\n-            }\n-            if (readsLeft == 0L) {\n-                return EOF;\n-            }\n-            readsLeft--;\n-            \/\/ At least one byte MUST be read, but we can read\n-            \/\/ less than `len` bytes\n-            int r = RANDOM.nextInt(len) + 1;\n-            for (int i = 0; i < r; i++) {\n-                b[i] = (byte) randomIntUpTo(256);\n-            }\n-            return r;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/S.java","additions":0,"deletions":277,"binary":false,"changes":277,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowPublisherVerification;\n-\n-import java.util.concurrent.Flow.Publisher;\n-import java.util.stream.LongStream;\n-import java.util.stream.Stream;\n-\n-\/* See TckDriver.java for more information *\/\n-public class SPublisherOfStream\n-        extends FlowPublisherVerification<Long> {\n-\n-    public SPublisherOfStream() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Publisher<Long> createFlowPublisher(long nElements) {\n-        Stream<Long> s = LongStream.range(0, nElements).boxed();\n-        return S.publisherOfStream(s);\n-    }\n-\n-    @Override\n-    public Publisher<Long> createFailedFlowPublisher() {\n-        return null;\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/SPublisherOfStream.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.nio.ByteBuffer;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-\n-public class STest {\n-\n-    @DataProvider(name = \"bufferSizes\")\n-    public static Object[][] bufferSizes() {\n-        return new Object[][]{\n-                { 1},\n-                { 2},\n-                { 3},\n-                { 4},\n-                {16},\n-                {17},\n-        };\n-    }\n-\n-    @DataProvider\n-    public static Object[][] inputStream() {\n-        return new Object[][] {\n-                {  0,   1},\n-                {  1,   2},\n-                {  1,   3},\n-                {  1,   4},\n-                {  2,   1},\n-                {  2,   2},\n-                {  2,   3},\n-                {  2,   4},\n-                {  2,  13},\n-                {  3,   1},\n-                {  3,   2},\n-                {  3,   3},\n-                {  3,   4},\n-                {  3,  17},\n-                {  4,   1},\n-                {  4,   2},\n-                {  4,   3},\n-                {  4,   4},\n-                {  4,   5},\n-                { 13,   1},\n-                { 13,   2},\n-                { 13,  13},\n-                { 16,  18},\n-                { 17,   2},\n-                {255,   1},\n-                {256, 255},\n-                {257, 267},\n-        };\n-    }\n-\n-    @Test\n-    public void testScatter0() {\n-        List<ByteBuffer> buffers = S.scatterBuffer(\n-                ByteBuffer.allocate(0));\n-        assertEquals(buffers.size(), 0);\n-    }\n-\n-    @Test(dataProvider = \"bufferSizes\")\n-    public void testScatterN(int n) {\n-        final ByteBuffer src = S.bufferOfNRandomBytes(n);\n-        final int srcLength = src.remaining();\n-        ByteBuffer copy = ByteBuffer.wrap(Arrays.copyOf(src.array(),\n-                                                        src.array().length));\n-        List<ByteBuffer> buffers = S.scatterBuffer(src);\n-        int m = 0;\n-        for (ByteBuffer b : buffers) {\n-            m += b.remaining();\n-            while (b.hasRemaining() & copy.hasRemaining()) {\n-                assertEquals(b.get(), copy.get());\n-            }\n-        }\n-        assertEquals(m, srcLength);\n-    }\n-\n-    @Test(dataProvider = \"inputStream\")\n-    public void testInputStreamOfNReads(int n, int capacity) throws IOException {\n-        InputStream s = S.inputStreamOfNReads(n);\n-        int count = 0;\n-        byte[] b = new byte[capacity];\n-        while (s.read(b) != -1) {\n-            count++;\n-        }\n-        assertEquals(count, n);\n-        assertTrue(s.read() == -1);\n-        assertTrue(s.read(b) == -1);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/STest.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -1,158 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8226602\n- * @summary Tests convenience reactive primitives with RS TCK\n- *\n- * @library ..\/reactivestreams-tck\n- * @build S\n- *\n- * @compile -encoding UTF-8 SPublisherOfStream.java\n- *\n- * @compile -encoding UTF-8 BodyPublishersFromPublisher.java\n- * @compile -encoding UTF-8 BodyPublishersNoBody.java\n- * @compile -encoding UTF-8 BodyPublishersOfByteArray.java\n- * @compile -encoding UTF-8 BodyPublishersOfByteArrays.java\n- * @compile -encoding UTF-8 BodyPublishersOfFile.java\n- * @compile -encoding UTF-8 BodyPublishersOfInputStream.java\n- * @compile -encoding UTF-8 BodyPublishersOfSubByteArray.java\n- * @compile -encoding UTF-8 BodyPublishersConcat.java\n- *\n- * @compile -encoding UTF-8 BodySubscribersBuffering.java\n- * @compile -encoding UTF-8 BodySubscribersDiscarding.java\n- * @compile -encoding UTF-8 BodySubscribersFromLineSubscriber.java\n- * @compile -encoding UTF-8 BodySubscribersFromSubscriber.java\n- * @compile -encoding UTF-8 BodySubscribersMapping.java\n- * @compile -encoding UTF-8 BodySubscribersOfByteArray.java\n- * @compile -encoding UTF-8 BodySubscribersOfByteArrayConsumer.java\n- * @compile -encoding UTF-8 BodySubscribersOfFile.java\n- * @compile -encoding UTF-8 BodySubscribersOfInputStream.java\n- * @compile -encoding UTF-8 BodySubscribersOfLines.java\n- * @compile -encoding UTF-8 BodySubscribersOfPublisher.java\n- * @compile -encoding UTF-8 BodySubscribersOfPublisher1.java\n- * @compile -encoding UTF-8 BodySubscribersOfPublisherPublisher.java\n- * @compile -encoding UTF-8 BodySubscribersOfString.java\n- * @compile -encoding UTF-8 BodySubscribersReplacing.java\n- *\n- * @run testng\/othervm STest\n- * @run testng\/othervm SPublisherOfStream\n- *\n- * @run testng\/othervm BodyPublishersFromPublisher\n- * @run testng\/othervm BodyPublishersNoBody\n- * @run testng\/othervm BodyPublishersOfByteArray\n- * @run testng\/othervm BodyPublishersOfByteArrays\n- * @run testng\/othervm BodyPublishersOfFile\n- * @run testng\/othervm BodyPublishersOfInputStream\n- * @run testng\/othervm BodyPublishersOfSubByteArray\n- * @run testng\/othervm BodyPublishersConcat\n- *\n- * @run testng\/othervm BodySubscribersBuffering\n- * @run testng\/othervm BodySubscribersDiscarding\n- * @run testng\/othervm BodySubscribersFromLineSubscriber\n- * @run testng\/othervm BodySubscribersFromSubscriber\n- * @run testng\/othervm BodySubscribersMapping\n- * @run testng\/othervm BodySubscribersOfByteArray\n- * @run testng\/othervm BodySubscribersOfByteArrayConsumer\n- * @run testng\/othervm BodySubscribersOfFile\n- * @run testng\/othervm BodySubscribersOfInputStream\n- * @run testng\/othervm BodySubscribersOfLines\n- * @run testng\/othervm BodySubscribersOfPublisher\n- * @run testng\/othervm BodySubscribersOfPublisher1\n- * @run testng\/othervm BodySubscribersOfPublisherPublisher\n- * @run testng\/othervm BodySubscribersOfString\n- * @run testng\/othervm BodySubscribersReplacing\n- *\n- * @key randomness\n- *\/\n-public class TckDriver {\n-   \/*\n-        #### General Information\n-\n-        1. This JTREG test aggregates multiple TestNG tests. This is because\n-        these tests share a common library (reactivestreams-tck), and we don't\n-        want this library to be compiled separately for each of those tests.\n-\n-        2. Tests that use RS TCK are compiled with the UTF-8 encoding. This is\n-        performed for the sake of reactivestreams-tck. We don't want to patch\n-        the TCK because of the extra merging work in the future, should we bring\n-        update(s) from the RS repo.\n-\n-        #### Tests\n-\n-        1. The purpose of each test should be easily digestible. The name of the\n-        test is derived from the very entity the test exercises. For example,\n-\n-            the BodyPublishersOfFile test exercises the BodyPublisher obtained\n-            by calling BodyPublishers.ofFile(Path)\n-\n-            the BodySubscribersOfFile test exercises the BodySubscriber obtained\n-            by calling BodySubscribers.ofFile(Path)\n-\n-        2. RS TCK requires PublisherVerification tests to produce publishers\n-        capable of emitting a certain number of elements. In order to achieve\n-        this, we use some knowledge of the internal workings of our publishers.\n-        An example would be a chunk size a publisher uses to deliver a portion\n-        of data. Without knowing that it is not possible to guarantee that the\n-        publisher will emit a particular number of elements.\n-\n-        3. Typically our publishers cannot be created in a known failed state.\n-        In this case the corresponding `createFailedFlowPublisher` method\n-        returns `null`.\n-\n-        4. SubscriberBlackBoxVerification uses the `createElement(int element)`\n-        method. Our implementations usually cap the amount of data created by\n-        this method, because it's not known beforehand how big the `element`\n-        value is. Hence, sometimes there's code like as follows:\n-\n-            @Override\n-            public List<ByteBuffer> createElement(int element) {\n-                return scatterBuffer(\n-                        bufferOfNRandomASCIIBytes(element % 17));\n-            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n-            }\n-\n-        5. The amount of testing RS TCK performs on a publisher seems to depend\n-        on the number of elements this publisher reports it can emit. Sometimes\n-        a code like the following can be seen in the tests:\n-\n-                @Override public long maxElementsFromPublisher() {\n-                    return 21;\n-                ~~~~~~~~~~~^\n-                }\n-\n-        This magic number is a result of trial and error and seems to unlock\n-        most of the tests. Reporting big values (e.g. Long.MAX_VALUE - 1) is\n-        not an option for most of our publishers because they require to have\n-        all the elements upfront.\n-\n-        6. It doesn't seem currently feasible to provide SubscriberWhiteboxVerification\n-        tests as a) it's not clear how much better the coverage is and b) it's\n-        significantly harder to code that.\n-\n-        #### S (Support)\n-\n-        Support utilities are being tested (STest) too.\n-    *\/\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/TckDriver.java","additions":0,"deletions":158,"binary":false,"changes":158,"status":"deleted"},{"patch":"@@ -1,389 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams;\n-\n-import java.util.concurrent.Flow;\n-import static java.util.Objects.requireNonNull;\n-\n-\/**\n- * Bridge between Reactive Streams API and the Java 9 {@link java.util.concurrent.Flow} API.\n- *\/\n-public final class FlowAdapters {\n-    \/** Utility class. *\/\n-    private FlowAdapters() {\n-        throw new IllegalStateException(\"No instances!\");\n-    }\n-\n-    \/**\n-     * Converts a Flow Publisher into a Reactive Streams Publisher.\n-     * @param <T> the element type\n-     * @param flowPublisher the source Flow Publisher to convert\n-     * @return the equivalent Reactive Streams Publisher\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    public static <T> org.reactivestreams.Publisher<T> toPublisher(\n-            Flow.Publisher<? extends T> flowPublisher) {\n-        requireNonNull(flowPublisher, \"flowPublisher\");\n-        final org.reactivestreams.Publisher<T> publisher;\n-        if (flowPublisher instanceof FlowPublisherFromReactive) {\n-            publisher = (org.reactivestreams.Publisher<T>)(((FlowPublisherFromReactive<T>)flowPublisher).reactiveStreams);\n-        } else if (flowPublisher instanceof org.reactivestreams.Publisher) {\n-            publisher = (org.reactivestreams.Publisher<T>)flowPublisher;\n-        } else {\n-            publisher = new ReactivePublisherFromFlow<T>(flowPublisher);\n-        }\n-        return publisher;\n-    }\n-\n-    \/**\n-     * Converts a Reactive Streams Publisher into a Flow Publisher.\n-     * @param <T> the element type\n-     * @param reactiveStreamsPublisher the source Reactive Streams Publisher to convert\n-     * @return the equivalent Flow Publisher\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    public static <T> Flow.Publisher<T> toFlowPublisher(\n-            org.reactivestreams.Publisher<? extends T> reactiveStreamsPublisher\n-    ) {\n-        requireNonNull(reactiveStreamsPublisher, \"reactiveStreamsPublisher\");\n-        final Flow.Publisher<T> flowPublisher;\n-        if (reactiveStreamsPublisher instanceof ReactivePublisherFromFlow) {\n-            flowPublisher = (Flow.Publisher<T>)(((ReactivePublisherFromFlow<T>)reactiveStreamsPublisher).flow);\n-        } else if (reactiveStreamsPublisher instanceof Flow.Publisher) {\n-            flowPublisher = (Flow.Publisher<T>)reactiveStreamsPublisher;\n-        } else {\n-            flowPublisher = new FlowPublisherFromReactive<T>(reactiveStreamsPublisher);\n-        }\n-        return flowPublisher;\n-    }\n-\n-    \/**\n-     * Converts a Flow Processor into a Reactive Streams Processor.\n-     * @param <T> the input value type\n-     * @param <U> the output value type\n-     * @param flowProcessor the source Flow Processor to convert\n-     * @return the equivalent Reactive Streams Processor\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    public static <T, U> org.reactivestreams.Processor<T, U> toProcessor(\n-            Flow.Processor<? super T, ? extends U> flowProcessor\n-    ) {\n-        requireNonNull(flowProcessor, \"flowProcessor\");\n-        final org.reactivestreams.Processor<T, U> processor;\n-        if (flowProcessor instanceof FlowToReactiveProcessor) {\n-            processor = (org.reactivestreams.Processor<T, U>)(((FlowToReactiveProcessor<T, U>)flowProcessor).reactiveStreams);\n-        } else if (flowProcessor instanceof org.reactivestreams.Processor) {\n-            processor = (org.reactivestreams.Processor<T, U>)flowProcessor;\n-        } else {\n-            processor = new ReactiveToFlowProcessor<T, U>(flowProcessor);\n-        }\n-        return processor;\n-    }\n-\n-    \/**\n-     * Converts a Reactive Streams Processor into a Flow Processor.\n-     * @param <T> the input value type\n-     * @param <U> the output value type\n-     * @param reactiveStreamsProcessor the source Reactive Streams Processor to convert\n-     * @return the equivalent Flow Processor\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    public static <T, U> Flow.Processor<T, U> toFlowProcessor(\n-            org.reactivestreams.Processor<? super T, ? extends U> reactiveStreamsProcessor\n-        ) {\n-        requireNonNull(reactiveStreamsProcessor, \"reactiveStreamsProcessor\");\n-        final Flow.Processor<T, U> flowProcessor;\n-        if (reactiveStreamsProcessor instanceof ReactiveToFlowProcessor) {\n-            flowProcessor = (Flow.Processor<T, U>)(((ReactiveToFlowProcessor<T, U>)reactiveStreamsProcessor).flow);\n-        } else if (reactiveStreamsProcessor instanceof Flow.Processor) {\n-            flowProcessor = (Flow.Processor<T, U>)reactiveStreamsProcessor;\n-        } else {\n-            flowProcessor = new FlowToReactiveProcessor<T, U>(reactiveStreamsProcessor);\n-        }\n-        return flowProcessor;\n-    }\n-\n-    \/**\n-     * Converts a Reactive Streams Subscriber into a Flow Subscriber.\n-     * @param <T> the input and output value type\n-     * @param reactiveStreamsSubscriber the Reactive Streams Subscriber instance to convert\n-     * @return the equivalent Flow Subscriber\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    public static <T> Flow.Subscriber<T> toFlowSubscriber(org.reactivestreams.Subscriber<T> reactiveStreamsSubscriber) {\n-        requireNonNull(reactiveStreamsSubscriber, \"reactiveStreamsSubscriber\");\n-        final Flow.Subscriber<T> flowSubscriber;\n-        if (reactiveStreamsSubscriber instanceof ReactiveToFlowSubscriber) {\n-            flowSubscriber = (Flow.Subscriber<T>)((ReactiveToFlowSubscriber<T>)reactiveStreamsSubscriber).flow;\n-        } else if (reactiveStreamsSubscriber instanceof Flow.Subscriber) {\n-            flowSubscriber = (Flow.Subscriber<T>)reactiveStreamsSubscriber;\n-        } else {\n-            flowSubscriber = new FlowToReactiveSubscriber<T>(reactiveStreamsSubscriber);\n-        }\n-        return flowSubscriber;\n-    }\n-\n-    \/**\n-     * Converts a Flow Subscriber into a Reactive Streams Subscriber.\n-     * @param <T> the input and output value type\n-     * @param flowSubscriber the Flow Subscriber instance to convert\n-     * @return the equivalent Reactive Streams Subscriber\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    public static <T> org.reactivestreams.Subscriber<T> toSubscriber(Flow.Subscriber<T> flowSubscriber) {\n-        requireNonNull(flowSubscriber, \"flowSubscriber\");\n-        final org.reactivestreams.Subscriber<T> subscriber;\n-        if (flowSubscriber instanceof FlowToReactiveSubscriber) {\n-            subscriber = (org.reactivestreams.Subscriber<T>)((FlowToReactiveSubscriber<T>)flowSubscriber).reactiveStreams;\n-        } else if (flowSubscriber instanceof org.reactivestreams.Subscriber) {\n-            subscriber = (org.reactivestreams.Subscriber<T>)flowSubscriber;\n-        } else {\n-            subscriber = new ReactiveToFlowSubscriber<T>(flowSubscriber);\n-        }\n-        return subscriber;\n-    }\n-\n-    \/**\n-     * Wraps a Reactive Streams Subscription and converts the calls to a Flow Subscription.\n-     *\/\n-    static final class FlowToReactiveSubscription implements Flow.Subscription {\n-        final org.reactivestreams.Subscription reactiveStreams;\n-\n-        public FlowToReactiveSubscription(org.reactivestreams.Subscription reactive) {\n-            this.reactiveStreams = reactive;\n-        }\n-\n-        @Override\n-        public void request(long n) {\n-            reactiveStreams.request(n);\n-        }\n-\n-        @Override\n-        public void cancel() {\n-            reactiveStreams.cancel();\n-        }\n-\n-    }\n-\n-    \/**\n-     * Wraps a Flow Subscription and converts the calls to a Reactive Streams Subscription.\n-     *\/\n-    static final class ReactiveToFlowSubscription implements org.reactivestreams.Subscription {\n-        final Flow.Subscription flow;\n-\n-        public ReactiveToFlowSubscription(Flow.Subscription flow) {\n-            this.flow = flow;\n-        }\n-\n-        @Override\n-        public void request(long n) {\n-            flow.request(n);\n-        }\n-\n-        @Override\n-        public void cancel() {\n-            flow.cancel();\n-        }\n-\n-\n-    }\n-\n-    \/**\n-     * Wraps a Reactive Streams Subscriber and forwards methods of the Flow Subscriber to it.\n-     * @param <T> the element type\n-     *\/\n-    static final class FlowToReactiveSubscriber<T> implements Flow.Subscriber<T> {\n-        final org.reactivestreams.Subscriber<? super T> reactiveStreams;\n-\n-        public FlowToReactiveSubscriber(org.reactivestreams.Subscriber<? super T> reactive) {\n-            this.reactiveStreams = reactive;\n-        }\n-\n-        @Override\n-        public void onSubscribe(Flow.Subscription subscription) {\n-            reactiveStreams.onSubscribe((subscription == null) ? null : new ReactiveToFlowSubscription(subscription));\n-        }\n-\n-        @Override\n-        public void onNext(T item) {\n-            reactiveStreams.onNext(item);\n-        }\n-\n-        @Override\n-        public void onError(Throwable throwable) {\n-            reactiveStreams.onError(throwable);\n-        }\n-\n-        @Override\n-        public void onComplete() {\n-            reactiveStreams.onComplete();\n-        }\n-\n-    }\n-\n-    \/**\n-     * Wraps a Flow Subscriber and forwards methods of the Reactive Streams Subscriber to it.\n-     * @param <T> the element type\n-     *\/\n-    static final class ReactiveToFlowSubscriber<T> implements org.reactivestreams.Subscriber<T> {\n-        final Flow.Subscriber<? super T> flow;\n-\n-        public ReactiveToFlowSubscriber(Flow.Subscriber<? super T> flow) {\n-            this.flow = flow;\n-        }\n-\n-        @Override\n-        public void onSubscribe(org.reactivestreams.Subscription subscription) {\n-            flow.onSubscribe((subscription == null) ? null : new FlowToReactiveSubscription(subscription));\n-        }\n-\n-        @Override\n-        public void onNext(T item) {\n-            flow.onNext(item);\n-        }\n-\n-        @Override\n-        public void onError(Throwable throwable) {\n-            flow.onError(throwable);\n-        }\n-\n-        @Override\n-        public void onComplete() {\n-            flow.onComplete();\n-        }\n-\n-    }\n-\n-    \/**\n-     * Wraps a Flow Processor and forwards methods of the Reactive Streams Processor to it.\n-     * @param <T> the input type\n-     * @param <U> the output type\n-     *\/\n-    static final class ReactiveToFlowProcessor<T, U> implements org.reactivestreams.Processor<T, U> {\n-        final Flow.Processor<? super T, ? extends U> flow;\n-\n-        public ReactiveToFlowProcessor(Flow.Processor<? super T, ? extends U> flow) {\n-            this.flow = flow;\n-        }\n-\n-        @Override\n-        public void onSubscribe(org.reactivestreams.Subscription subscription) {\n-            flow.onSubscribe((subscription == null) ? null : new FlowToReactiveSubscription(subscription));\n-        }\n-\n-        @Override\n-        public void onNext(T t) {\n-            flow.onNext(t);\n-        }\n-\n-        @Override\n-        public void onError(Throwable t) {\n-            flow.onError(t);\n-        }\n-\n-        @Override\n-        public void onComplete() {\n-            flow.onComplete();\n-        }\n-\n-        @Override\n-        public void subscribe(org.reactivestreams.Subscriber<? super U> s) {\n-            flow.subscribe((s == null) ? null : new FlowToReactiveSubscriber<U>(s));\n-        }\n-    }\n-\n-    \/**\n-     * Wraps a Reactive Streams Processor and forwards methods of the Flow Processor to it.\n-     * @param <T> the input type\n-     * @param <U> the output type\n-     *\/\n-    static final class FlowToReactiveProcessor<T, U> implements Flow.Processor<T, U> {\n-        final org.reactivestreams.Processor<? super T, ? extends U> reactiveStreams;\n-\n-        public FlowToReactiveProcessor(org.reactivestreams.Processor<? super T, ? extends U> reactive) {\n-            this.reactiveStreams = reactive;\n-        }\n-\n-        @Override\n-        public void onSubscribe(Flow.Subscription subscription) {\n-            reactiveStreams.onSubscribe((subscription == null) ? null : new ReactiveToFlowSubscription(subscription));\n-        }\n-\n-        @Override\n-        public void onNext(T t) {\n-            reactiveStreams.onNext(t);\n-        }\n-\n-        @Override\n-        public void onError(Throwable t) {\n-            reactiveStreams.onError(t);\n-        }\n-\n-        @Override\n-        public void onComplete() {\n-            reactiveStreams.onComplete();\n-        }\n-\n-        @Override\n-        public void subscribe(Flow.Subscriber<? super U> s) {\n-            reactiveStreams.subscribe((s == null) ? null : new ReactiveToFlowSubscriber<U>(s));\n-        }\n-    }\n-\n-    \/**\n-     * Reactive Streams Publisher that wraps a Flow Publisher.\n-     * @param <T> the element type\n-     *\/\n-    static final class ReactivePublisherFromFlow<T> implements org.reactivestreams.Publisher<T> {\n-        final Flow.Publisher<? extends T> flow;\n-\n-        public ReactivePublisherFromFlow(Flow.Publisher<? extends T> flowPublisher) {\n-            this.flow = flowPublisher;\n-        }\n-\n-        @Override\n-        public void subscribe(org.reactivestreams.Subscriber<? super T> reactive) {\n-            flow.subscribe((reactive == null) ? null : new FlowToReactiveSubscriber<T>(reactive));\n-        }\n-    }\n-\n-    \/**\n-     * Flow Publisher that wraps a Reactive Streams Publisher.\n-     * @param <T> the element type\n-     *\/\n-    static final class FlowPublisherFromReactive<T> implements Flow.Publisher<T> {\n-\n-        final org.reactivestreams.Publisher<? extends T> reactiveStreams;\n-\n-        public FlowPublisherFromReactive(org.reactivestreams.Publisher<? extends T> reactivePublisher) {\n-            this.reactiveStreams = reactivePublisher;\n-        }\n-\n-        @Override\n-        public void subscribe(Flow.Subscriber<? super T> flow) {\n-            reactiveStreams.subscribe((flow == null) ? null : new ReactiveToFlowSubscriber<T>(flow));\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/FlowAdapters.java","additions":0,"deletions":389,"binary":false,"changes":389,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams;\n-\n-\/**\n- * A Processor represents a processing stage—which is both a {@link Subscriber}\n- * and a {@link Publisher} and obeys the contracts of both.\n- *\n- * @param <T> the type of element signaled to the {@link Subscriber}\n- * @param <R> the type of element signaled by the {@link Publisher}\n- *\/\n-public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/Processor.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams;\n-\n-\/**\n- * A {@link Publisher} is a provider of a potentially unbounded number of sequenced elements, publishing them according to\n- * the demand received from its {@link Subscriber}(s).\n- * <p>\n- * A {@link Publisher} can serve multiple {@link Subscriber}s subscribed {@link #subscribe(Subscriber)} dynamically\n- * at various points in time.\n- *\n- * @param <T> the type of element signaled.\n- *\/\n-public interface Publisher<T> {\n-\n-    \/**\n-     * Request {@link Publisher} to start streaming data.\n-     * <p>\n-     * This is a \"factory method\" and can be called multiple times, each time starting a new {@link Subscription}.\n-     * <p>\n-     * Each {@link Subscription} will work for only a single {@link Subscriber}.\n-     * <p>\n-     * A {@link Subscriber} should only subscribe once to a single {@link Publisher}.\n-     * <p>\n-     * If the {@link Publisher} rejects the subscription attempt or otherwise fails it will\n-     * signal the error via {@link Subscriber#onError}.\n-     *\n-     * @param s the {@link Subscriber} that will consume signals from this {@link Publisher}\n-     *\/\n-    public void subscribe(Subscriber<? super T> s);\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/Publisher.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams;\n-\n-\/**\n- * Will receive call to {@link #onSubscribe(Subscription)} once after passing an instance of {@link Subscriber} to {@link Publisher#subscribe(Subscriber)}.\n- * <p>\n- * No further notifications will be received until {@link Subscription#request(long)} is called.\n- * <p>\n- * After signaling demand:\n- * <ul>\n- * <li>One or more invocations of {@link #onNext(Object)} up to the maximum number defined by {@link Subscription#request(long)}<\/li>\n- * <li>Single invocation of {@link #onError(Throwable)} or {@link Subscriber#onComplete()} which signals a terminal state after which no further events will be sent.\n- * <\/ul>\n- * <p>\n- * Demand can be signaled via {@link Subscription#request(long)} whenever the {@link Subscriber} instance is capable of handling more.\n- *\n- * @param <T> the type of element signaled.\n- *\/\n-public interface Subscriber<T> {\n-    \/**\n-     * Invoked after calling {@link Publisher#subscribe(Subscriber)}.\n-     * <p>\n-     * No data will start flowing until {@link Subscription#request(long)} is invoked.\n-     * <p>\n-     * It is the responsibility of this {@link Subscriber} instance to call {@link Subscription#request(long)} whenever more data is wanted.\n-     * <p>\n-     * The {@link Publisher} will send notifications only in response to {@link Subscription#request(long)}.\n-     *\n-     * @param s\n-     *            {@link Subscription} that allows requesting data via {@link Subscription#request(long)}\n-     *\/\n-    public void onSubscribe(Subscription s);\n-\n-    \/**\n-     * Data notification sent by the {@link Publisher} in response to requests to {@link Subscription#request(long)}.\n-     *\n-     * @param t the element signaled\n-     *\/\n-    public void onNext(T t);\n-\n-    \/**\n-     * Failed terminal state.\n-     * <p>\n-     * No further events will be sent even if {@link Subscription#request(long)} is invoked again.\n-     *\n-     * @param t the throwable signaled\n-     *\/\n-    public void onError(Throwable t);\n-\n-    \/**\n-     * Successful terminal state.\n-     * <p>\n-     * No further events will be sent even if {@link Subscription#request(long)} is invoked again.\n-     *\/\n-    public void onComplete();\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/Subscriber.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams;\n-\n-\/**\n- * A {@link Subscription} represents a one-to-one lifecycle of a {@link Subscriber} subscribing to a {@link Publisher}.\n- * <p>\n- * It can only be used once by a single {@link Subscriber}.\n- * <p>\n- * It is used to both signal desire for data and cancel demand (and allow resource cleanup).\n- *\n- *\/\n-public interface Subscription {\n-    \/**\n-     * No events will be sent by a {@link Publisher} until demand is signaled via this method.\n-     * <p>\n-     *  It can be called however often and whenever needed—but if the outstanding cumulative demand ever becomes Long.MAX_VALUE or more,\n-     *  it may be treated by the {@link Publisher} as \"effectively unbounded\".\n-     * <p>\n-     * Whatever has been requested can be sent by the {@link Publisher} so only signal demand for what can be safely handled.\n-     * <p>\n-     * A {@link Publisher} can send less than is requested if the stream ends but\n-     * then must emit either {@link Subscriber#onError(Throwable)} or {@link Subscriber#onComplete()}.\n-     *\n-     * @param n the strictly positive number of elements to requests to the upstream {@link Publisher}\n-     *\/\n-    public void request(long n);\n-\n-    \/**\n-     * Request the {@link Publisher} to stop sending data and clean up resources.\n-     * <p>\n-     * Data may still be sent to meet previously signalled demand after calling cancel.\n-     *\/\n-    public void cancel();\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/Subscription.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,281 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.example.unicast;\n-\n-import org.reactivestreams.Publisher;\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-\n-import java.util.Iterator;\n-import java.util.Collections;\n-import java.util.concurrent.Executor;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n-\n-\/**\n- * AsyncIterablePublisher is an implementation of Reactive Streams `Publisher`\n- * which executes asynchronously, using a provided `Executor` and produces elements\n- * from a given `Iterable` in a \"unicast\" configuration to its `Subscribers`.\n- *\n- * NOTE: The code below uses a lot of try-catches to show the reader where exceptions can be expected, and where they are forbidden.\n- *\/\n-public class AsyncIterablePublisher<T> implements Publisher<T> {\n-  private final static int DEFAULT_BATCHSIZE = 1024;\n-\n-  private final Iterable<T> elements; \/\/ This is our data source \/ generator\n-  private final Executor executor; \/\/ This is our thread pool, which will make sure that our Publisher runs asynchronously to its Subscribers\n-  private final int batchSize; \/\/ In general, if one uses an `Executor`, one should be nice nad not hog a thread for too long, this is the cap for that, in elements\n-\n-  public AsyncIterablePublisher(final Iterable<T> elements, final Executor executor) {\n-    this(elements, DEFAULT_BATCHSIZE, executor);\n-  }\n-\n-  public AsyncIterablePublisher(final Iterable<T> elements, final int batchSize, final Executor executor) {\n-    if (elements == null) throw null;\n-    if (executor == null) throw null;\n-    if (batchSize < 1) throw new IllegalArgumentException(\"batchSize must be greater than zero!\");\n-    this.elements = elements;\n-    this.executor = executor;\n-    this.batchSize = batchSize;\n-  }\n-\n-  @Override\n-  public void subscribe(final Subscriber<? super T> s) {\n-    \/\/ As per rule 1.11, we have decided to support multiple subscribers in a unicast configuration\n-    \/\/ for this `Publisher` implementation.\n-    \/\/ As per 2.13, this method must return normally (i.e. not throw)\n-    new SubscriptionImpl(s).init();\n-  }\n-\n-  \/\/ These represent the protocol of the `AsyncIterablePublishers` SubscriptionImpls\n-  static interface Signal {};\n-  enum Cancel implements Signal { Instance; };\n-  enum Subscribe implements Signal { Instance; };\n-  enum Send implements Signal { Instance; };\n-  static final class Request implements Signal {\n-    final long n;\n-    Request(final long n) {\n-      this.n = n;\n-    }\n-  };\n-\n-  \/\/ This is our implementation of the Reactive Streams `Subscription`,\n-  \/\/ which represents the association between a `Publisher` and a `Subscriber`.\n-  final class SubscriptionImpl implements Subscription, Runnable {\n-    final Subscriber<? super T> subscriber; \/\/ We need a reference to the `Subscriber` so we can talk to it\n-    private boolean cancelled = false; \/\/ This flag will track whether this `Subscription` is to be considered cancelled or not\n-    private long demand = 0; \/\/ Here we track the current demand, i.e. what has been requested but not yet delivered\n-    private Iterator<T> iterator; \/\/ This is our cursor into the data stream, which we will send to the `Subscriber`\n-\n-    SubscriptionImpl(final Subscriber<? super T> subscriber) {\n-      \/\/ As per rule 1.09, we need to throw a `java.lang.NullPointerException` if the `Subscriber` is `null`\n-      if (subscriber == null) throw null;\n-      this.subscriber = subscriber;\n-    }\n-\n-    \/\/ This `ConcurrentLinkedQueue` will track signals that are sent to this `Subscription`, like `request` and `cancel`\n-    private final ConcurrentLinkedQueue<Signal> inboundSignals = new ConcurrentLinkedQueue<Signal>();\n-\n-    \/\/ We are using this `AtomicBoolean` to make sure that this `Subscription` doesn't run concurrently with itself,\n-    \/\/ which would violate rule 1.3 among others (no concurrent notifications).\n-    private final AtomicBoolean on = new AtomicBoolean(false);\n-\n-    \/\/ This method will register inbound demand from our `Subscriber` and validate it against rule 3.9 and rule 3.17\n-    private void doRequest(final long n) {\n-      if (n < 1)\n-        terminateDueTo(new IllegalArgumentException(subscriber + \" violated the Reactive Streams rule 3.9 by requesting a non-positive number of elements.\"));\n-      else if (demand + n < 1) {\n-        \/\/ As governed by rule 3.17, when demand overflows `Long.MAX_VALUE` we treat the signalled demand as \"effectively unbounded\"\n-        demand = Long.MAX_VALUE;  \/\/ Here we protect from the overflow and treat it as \"effectively unbounded\"\n-        doSend(); \/\/ Then we proceed with sending data downstream\n-      } else {\n-        demand += n; \/\/ Here we record the downstream demand\n-        doSend(); \/\/ Then we can proceed with sending data downstream\n-      }\n-    }\n-\n-    \/\/ This handles cancellation requests, and is idempotent, thread-safe and not synchronously performing heavy computations as specified in rule 3.5\n-    private void doCancel() {\n-      cancelled = true;\n-    }\n-\n-    \/\/ Instead of executing `subscriber.onSubscribe` synchronously from within `Publisher.subscribe`\n-    \/\/ we execute it asynchronously, this is to avoid executing the user code (`Iterable.iterator`) on the calling thread.\n-    \/\/ It also makes it easier to follow rule 1.9\n-    private void doSubscribe() {\n-      try {\n-        iterator = elements.iterator();\n-        if (iterator == null)\n-          iterator = Collections.<T>emptyList().iterator(); \/\/ So we can assume that `iterator` is never null\n-      } catch(final Throwable t) {\n-        subscriber.onSubscribe(new Subscription() { \/\/ We need to make sure we signal onSubscribe before onError, obeying rule 1.9\n-          @Override public void cancel() {}\n-          @Override public void request(long n) {}\n-        });\n-        terminateDueTo(t); \/\/ Here we send onError, obeying rule 1.09\n-      }\n-\n-      if (!cancelled) {\n-        \/\/ Deal with setting up the subscription with the subscriber\n-        try {\n-          subscriber.onSubscribe(this);\n-        } catch(final Throwable t) { \/\/ Due diligence to obey 2.13\n-          terminateDueTo(new IllegalStateException(subscriber + \" violated the Reactive Streams rule 2.13 by throwing an exception from onSubscribe.\", t));\n-        }\n-\n-        \/\/ Deal with already complete iterators promptly\n-        boolean hasElements = false;\n-        try {\n-          hasElements = iterator.hasNext();\n-        } catch(final Throwable t) {\n-          terminateDueTo(t); \/\/ If hasNext throws, there's something wrong and we need to signal onError as per 1.2, 1.4,\n-        }\n-\n-        \/\/ If we don't have anything to deliver, we're already done, so lets do the right thing and\n-        \/\/ not wait for demand to deliver `onComplete` as per rule 1.2 and 1.3\n-        if (!hasElements) {\n-          try {\n-            doCancel(); \/\/ Rule 1.6 says we need to consider the `Subscription` cancelled when `onComplete` is signalled\n-            subscriber.onComplete();\n-          } catch(final Throwable t) { \/\/ As per rule 2.13, `onComplete` is not allowed to throw exceptions, so we do what we can, and log this.\n-            (new IllegalStateException(subscriber + \" violated the Reactive Streams rule 2.13 by throwing an exception from onComplete.\", t)).printStackTrace(System.err);\n-          }\n-        }\n-      }\n-    }\n-\n-    \/\/ This is our behavior for producing elements downstream\n-    private void doSend() {\n-      try {\n-        \/\/ In order to play nice with the `Executor` we will only send at-most `batchSize` before\n-        \/\/ rescheduing ourselves and relinquishing the current thread.\n-        int leftInBatch = batchSize;\n-        do {\n-          T next;\n-          boolean hasNext;\n-          try {\n-            next = iterator.next(); \/\/ We have already checked `hasNext` when subscribing, so we can fall back to testing -after- `next` is called.\n-            hasNext = iterator.hasNext(); \/\/ Need to keep track of End-of-Stream\n-          } catch (final Throwable t) {\n-            terminateDueTo(t); \/\/ If `next` or `hasNext` throws (they can, since it is user-provided), we need to treat the stream as errored as per rule 1.4\n-            return;\n-          }\n-          subscriber.onNext(next); \/\/ Then we signal the next element downstream to the `Subscriber`\n-          if (!hasNext) { \/\/ If we are at End-of-Stream\n-            doCancel(); \/\/ We need to consider this `Subscription` as cancelled as per rule 1.6\n-            subscriber.onComplete(); \/\/ Then we signal `onComplete` as per rule 1.2 and 1.5\n-          }\n-        } while (!cancelled           \/\/ This makes sure that rule 1.8 is upheld, i.e. we need to stop signalling \"eventually\"\n-                 && --leftInBatch > 0 \/\/ This makes sure that we only send `batchSize` number of elements in one go (so we can yield to other Runnables)\n-                 && --demand > 0);    \/\/ This makes sure that rule 1.1 is upheld (sending more than was demanded)\n-\n-        if (!cancelled && demand > 0) \/\/ If the `Subscription` is still alive and well, and we have demand to satisfy, we signal ourselves to send more data\n-          signal(Send.Instance);\n-      } catch(final Throwable t) {\n-        \/\/ We can only get here if `onNext` or `onComplete` threw, and they are not allowed to according to 2.13, so we can only cancel and log here.\n-        doCancel(); \/\/ Make sure that we are cancelled, since we cannot do anything else since the `Subscriber` is faulty.\n-        (new IllegalStateException(subscriber + \" violated the Reactive Streams rule 2.13 by throwing an exception from onNext or onComplete.\", t)).printStackTrace(System.err);\n-      }\n-    }\n-\n-    \/\/ This is a helper method to ensure that we always `cancel` when we signal `onError` as per rule 1.6\n-    private void terminateDueTo(final Throwable t) {\n-      cancelled = true; \/\/ When we signal onError, the subscription must be considered as cancelled, as per rule 1.6\n-      try {\n-        subscriber.onError(t); \/\/ Then we signal the error downstream, to the `Subscriber`\n-      } catch(final Throwable t2) { \/\/ If `onError` throws an exception, this is a spec violation according to rule 1.9, and all we can do is to log it.\n-        (new IllegalStateException(subscriber + \" violated the Reactive Streams rule 2.13 by throwing an exception from onError.\", t2)).printStackTrace(System.err);\n-      }\n-    }\n-\n-    \/\/ What `signal` does is that it sends signals to the `Subscription` asynchronously\n-    private void signal(final Signal signal) {\n-      if (inboundSignals.offer(signal)) \/\/ No need to null-check here as ConcurrentLinkedQueue does this for us\n-        tryScheduleToExecute(); \/\/ Then we try to schedule it for execution, if it isn't already\n-    }\n-\n-    \/\/ This is the main \"event loop\" if you so will\n-    @Override public final void run() {\n-      if(on.get()) { \/\/ establishes a happens-before relationship with the end of the previous run\n-        try {\n-          final Signal s = inboundSignals.poll(); \/\/ We take a signal off the queue\n-          if (!cancelled) { \/\/ to make sure that we follow rule 1.8, 3.6 and 3.7\n-\n-            \/\/ Below we simply unpack the `Signal`s and invoke the corresponding methods\n-            if (s instanceof Request)\n-              doRequest(((Request)s).n);\n-            else if (s == Send.Instance)\n-              doSend();\n-            else if (s == Cancel.Instance)\n-              doCancel();\n-            else if (s == Subscribe.Instance)\n-              doSubscribe();\n-          }\n-        } finally {\n-          on.set(false); \/\/ establishes a happens-before relationship with the beginning of the next run\n-          if(!inboundSignals.isEmpty()) \/\/ If we still have signals to process\n-            tryScheduleToExecute(); \/\/ Then we try to schedule ourselves to execute again\n-        }\n-      }\n-    }\n-\n-    \/\/ This method makes sure that this `Subscription` is only running on one Thread at a time,\n-    \/\/ this is important to make sure that we follow rule 1.3\n-    private final void tryScheduleToExecute() {\n-      if(on.compareAndSet(false, true)) {\n-        try {\n-          executor.execute(this);\n-        } catch(Throwable t) { \/\/ If we can't run on the `Executor`, we need to fail gracefully\n-          if (!cancelled) {\n-            doCancel(); \/\/ First of all, this failure is not recoverable, so we need to follow rule 1.4 and 1.6\n-            try {\n-              terminateDueTo(new IllegalStateException(\"Publisher terminated due to unavailable Executor.\", t));\n-            } finally {\n-              inboundSignals.clear(); \/\/ We're not going to need these anymore\n-              \/\/ This subscription is cancelled by now, but letting it become schedulable again means\n-              \/\/ that we can drain the inboundSignals queue if anything arrives after clearing\n-              on.set(false);\n-            }\n-          }\n-        }\n-      }\n-    }\n-\n-    \/\/ Our implementation of `Subscription.request` sends a signal to the Subscription that more elements are in demand\n-    @Override public void request(final long n) {\n-      signal(new Request(n));\n-    }\n-    \/\/ Our implementation of `Subscription.cancel` sends a signal to the Subscription that the `Subscriber` is not interested in any more elements\n-    @Override public void cancel() {\n-      signal(Cancel.Instance);\n-    }\n-    \/\/ The reason for the `init` method is that we want to ensure the `SubscriptionImpl`\n-    \/\/ is completely constructed before it is exposed to the thread pool, therefor this\n-    \/\/ method is only intended to be invoked once, and immediately after the constructor has\n-    \/\/ finished.\n-    void init() {\n-      signal(Subscribe.Instance);\n-    }\n-  };\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/example\/unicast\/AsyncIterablePublisher.java","additions":0,"deletions":281,"binary":false,"changes":281,"status":"deleted"},{"patch":"@@ -1,261 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.example.unicast;\n-\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-\n-import java.util.concurrent.Executor;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n-\n-\/**\n- * AsyncSubscriber is an implementation of Reactive Streams `Subscriber`,\n- * it runs asynchronously (on an Executor), requests one element\n- * at a time, and invokes a user-defined method to process each element.\n- *\n- * NOTE: The code below uses a lot of try-catches to show the reader where exceptions can be expected, and where they are forbidden.\n- *\/\n-public abstract class AsyncSubscriber<T> implements Subscriber<T>, Runnable {\n-\n-  \/\/ Signal represents the asynchronous protocol between the Publisher and Subscriber\n-  private static interface Signal {}\n-\n-  private enum OnComplete implements Signal { Instance; }\n-\n-  private static class OnError implements Signal {\n-    public final Throwable error;\n-    public OnError(final Throwable error) { this.error = error; }\n-  }\n-\n-  private static class OnNext<T> implements Signal {\n-    public final T next;\n-    public OnNext(final T next) { this.next = next; }\n-  }\n-\n-  private static class OnSubscribe implements Signal {\n-    public final Subscription subscription;\n-    public OnSubscribe(final Subscription subscription) { this.subscription = subscription; }\n-  }\n-\n-  private Subscription subscription; \/\/ Obeying rule 3.1, we make this private!\n-  private boolean done; \/\/ It's useful to keep track of whether this Subscriber is done or not\n-  private final Executor executor; \/\/ This is the Executor we'll use to be asynchronous, obeying rule 2.2\n-\n-  \/\/ Only one constructor, and it's only accessible for the subclasses\n-  protected AsyncSubscriber(Executor executor) {\n-    if (executor == null) throw null;\n-    this.executor = executor;\n-  }\n-\n-  \/\/ Showcases a convenience method to idempotently marking the Subscriber as \"done\", so we don't want to process more elements\n-  \/\/ herefor we also need to cancel our `Subscription`.\n-  private final void done() {\n-    \/\/On this line we could add a guard against `!done`, but since rule 3.7 says that `Subscription.cancel()` is idempotent, we don't need to.\n-    done = true; \/\/ If `whenNext` throws an exception, let's consider ourselves done (not accepting more elements)\n-    if (subscription != null) { \/\/ If we are bailing out before we got a `Subscription` there's little need for cancelling it.\n-      try {\n-        subscription.cancel(); \/\/ Cancel the subscription\n-      } catch(final Throwable t) {\n-        \/\/Subscription.cancel is not allowed to throw an exception, according to rule 3.15\n-        (new IllegalStateException(subscription + \" violated the Reactive Streams rule 3.15 by throwing an exception from cancel.\", t)).printStackTrace(System.err);\n-      }\n-    }\n-  }\n-\n-  \/\/ This method is invoked when the OnNext signals arrive\n-  \/\/ Returns whether more elements are desired or not, and if no more elements are desired,\n-  \/\/ for convenience.\n-  protected abstract boolean whenNext(final T element);\n-\n-  \/\/ This method is invoked when the OnComplete signal arrives\n-  \/\/ override this method to implement your own custom onComplete logic.\n-  protected void whenComplete() { }\n-\n-  \/\/ This method is invoked if the OnError signal arrives\n-  \/\/ override this method to implement your own custom onError logic.\n-  protected void whenError(Throwable error) { }\n-\n-  private final void handleOnSubscribe(final Subscription s) {\n-    if (s == null) {\n-      \/\/ Getting a null `Subscription` here is not valid so lets just ignore it.\n-    } else if (subscription != null) { \/\/ If someone has made a mistake and added this Subscriber multiple times, let's handle it gracefully\n-      try {\n-        s.cancel(); \/\/ Cancel the additional subscription to follow rule 2.5\n-      } catch(final Throwable t) {\n-        \/\/Subscription.cancel is not allowed to throw an exception, according to rule 3.15\n-        (new IllegalStateException(s + \" violated the Reactive Streams rule 3.15 by throwing an exception from cancel.\", t)).printStackTrace(System.err);\n-      }\n-    } else {\n-      \/\/ We have to assign it locally before we use it, if we want to be a synchronous `Subscriber`\n-      \/\/ Because according to rule 3.10, the Subscription is allowed to call `onNext` synchronously from within `request`\n-      subscription = s;\n-      try {\n-        \/\/ If we want elements, according to rule 2.1 we need to call `request`\n-        \/\/ And, according to rule 3.2 we are allowed to call this synchronously from within the `onSubscribe` method\n-        s.request(1); \/\/ Our Subscriber is unbuffered and modest, it requests one element at a time\n-      } catch(final Throwable t) {\n-        \/\/ Subscription.request is not allowed to throw according to rule 3.16\n-        (new IllegalStateException(s + \" violated the Reactive Streams rule 3.16 by throwing an exception from request.\", t)).printStackTrace(System.err);\n-      }\n-    }\n-  }\n-\n-  private final void handleOnNext(final T element) {\n-    if (!done) { \/\/ If we aren't already done\n-      if(subscription == null) { \/\/ Technically this check is not needed, since we are expecting Publishers to conform to the spec\n-        \/\/ Check for spec violation of 2.1 and 1.09\n-        (new IllegalStateException(\"Someone violated the Reactive Streams rule 1.09 and 2.1 by signalling OnNext before `Subscription.request`. (no Subscription)\")).printStackTrace(System.err);\n-      } else {\n-        try {\n-          if (whenNext(element)) {\n-            try {\n-              subscription.request(1); \/\/ Our Subscriber is unbuffered and modest, it requests one element at a time\n-            } catch(final Throwable t) {\n-              \/\/ Subscription.request is not allowed to throw according to rule 3.16\n-              (new IllegalStateException(subscription + \" violated the Reactive Streams rule 3.16 by throwing an exception from request.\", t)).printStackTrace(System.err);\n-            }\n-          } else {\n-            done(); \/\/ This is legal according to rule 2.6\n-          }\n-        } catch(final Throwable t) {\n-          done();\n-          try {\n-            onError(t);\n-          } catch(final Throwable t2) {\n-            \/\/Subscriber.onError is not allowed to throw an exception, according to rule 2.13\n-            (new IllegalStateException(this + \" violated the Reactive Streams rule 2.13 by throwing an exception from onError.\", t2)).printStackTrace(System.err);\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ Here it is important that we do not violate 2.2 and 2.3 by calling methods on the `Subscription` or `Publisher`\n-  private void handleOnComplete() {\n-    if (subscription == null) { \/\/ Technically this check is not needed, since we are expecting Publishers to conform to the spec\n-      \/\/ Publisher is not allowed to signal onComplete before onSubscribe according to rule 1.09\n-      (new IllegalStateException(\"Publisher violated the Reactive Streams rule 1.09 signalling onComplete prior to onSubscribe.\")).printStackTrace(System.err);\n-    } else {\n-      done = true; \/\/ Obey rule 2.4\n-      whenComplete();\n-    }\n-  }\n-\n-  \/\/ Here it is important that we do not violate 2.2 and 2.3 by calling methods on the `Subscription` or `Publisher`\n-  private void handleOnError(final Throwable error) {\n-    if (subscription == null) { \/\/ Technically this check is not needed, since we are expecting Publishers to conform to the spec\n-      \/\/ Publisher is not allowed to signal onError before onSubscribe according to rule 1.09\n-      (new IllegalStateException(\"Publisher violated the Reactive Streams rule 1.09 signalling onError prior to onSubscribe.\")).printStackTrace(System.err);\n-    } else {\n-      done = true; \/\/ Obey rule 2.4\n-      whenError(error);\n-    }\n-  }\n-\n-  \/\/ We implement the OnX methods on `Subscriber` to send Signals that we will process asycnhronously, but only one at a time\n-\n-  @Override public final void onSubscribe(final Subscription s) {\n-    \/\/ As per rule 2.13, we need to throw a `java.lang.NullPointerException` if the `Subscription` is `null`\n-    if (s == null) throw null;\n-\n-    signal(new OnSubscribe(s));\n-  }\n-\n-  @Override public final void onNext(final T element) {\n-    \/\/ As per rule 2.13, we need to throw a `java.lang.NullPointerException` if the `element` is `null`\n-    if (element == null) throw null;\n-\n-    signal(new OnNext<T>(element));\n-  }\n-\n-  @Override public final void onError(final Throwable t) {\n-    \/\/ As per rule 2.13, we need to throw a `java.lang.NullPointerException` if the `Throwable` is `null`\n-    if (t == null) throw null;\n-\n-    signal(new OnError(t));\n-  }\n-\n-  @Override public final void onComplete() {\n-     signal(OnComplete.Instance);\n-  }\n-\n-  \/\/ This `ConcurrentLinkedQueue` will track signals that are sent to this `Subscriber`, like `OnComplete` and `OnNext` ,\n-  \/\/ and obeying rule 2.11\n-  private final ConcurrentLinkedQueue<Signal> inboundSignals = new ConcurrentLinkedQueue<Signal>();\n-\n-  \/\/ We are using this `AtomicBoolean` to make sure that this `Subscriber` doesn't run concurrently with itself,\n-  \/\/ obeying rule 2.7 and 2.11\n-  private final AtomicBoolean on = new AtomicBoolean(false);\n-\n-   @SuppressWarnings(\"unchecked\")\n-   @Override public final void run() {\n-    if(on.get()) { \/\/ establishes a happens-before relationship with the end of the previous run\n-      try {\n-        final Signal s = inboundSignals.poll(); \/\/ We take a signal off the queue\n-        if (!done) { \/\/ If we're done, we shouldn't process any more signals, obeying rule 2.8\n-          \/\/ Below we simply unpack the `Signal`s and invoke the corresponding methods\n-          if (s instanceof OnNext<?>)\n-            handleOnNext(((OnNext<T>)s).next);\n-          else if (s instanceof OnSubscribe)\n-            handleOnSubscribe(((OnSubscribe)s).subscription);\n-          else if (s instanceof OnError) \/\/ We are always able to handle OnError, obeying rule 2.10\n-            handleOnError(((OnError)s).error);\n-          else if (s == OnComplete.Instance) \/\/ We are always able to handle OnComplete, obeying rule 2.9\n-            handleOnComplete();\n-        }\n-      } finally {\n-        on.set(false); \/\/ establishes a happens-before relationship with the beginning of the next run\n-        if(!inboundSignals.isEmpty()) \/\/ If we still have signals to process\n-          tryScheduleToExecute(); \/\/ Then we try to schedule ourselves to execute again\n-      }\n-    }\n-  }\n-\n-  \/\/ What `signal` does is that it sends signals to the `Subscription` asynchronously\n-  private void signal(final Signal signal) {\n-    if (inboundSignals.offer(signal)) \/\/ No need to null-check here as ConcurrentLinkedQueue does this for us\n-      tryScheduleToExecute(); \/\/ Then we try to schedule it for execution, if it isn't already\n-  }\n-\n-  \/\/ This method makes sure that this `Subscriber` is only executing on one Thread at a time\n-  private final void tryScheduleToExecute() {\n-    if(on.compareAndSet(false, true)) {\n-      try {\n-        executor.execute(this);\n-      } catch(Throwable t) { \/\/ If we can't run on the `Executor`, we need to fail gracefully and not violate rule 2.13\n-        if (!done) {\n-          try {\n-            done(); \/\/ First of all, this failure is not recoverable, so we need to cancel our subscription\n-          } finally {\n-            inboundSignals.clear(); \/\/ We're not going to need these anymore\n-            \/\/ This subscription is cancelled by now, but letting the Subscriber become schedulable again means\n-            \/\/ that we can drain the inboundSignals queue if anything arrives after clearing\n-            on.set(false);\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/example\/unicast\/AsyncSubscriber.java","additions":0,"deletions":261,"binary":false,"changes":261,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.example.unicast;\n-\n-import java.util.Iterator;\n-import java.util.concurrent.Executor;\n-\n-import org.reactivestreams.Subscription;\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Publisher;\n-\n-public class InfiniteIncrementNumberPublisher extends AsyncIterablePublisher<Integer> {\n-    public InfiniteIncrementNumberPublisher(final Executor executor) {\n-        super(new Iterable<Integer>() {\n-          @Override public Iterator<Integer> iterator() {\n-            return new Iterator<Integer>() {\n-              private int at = 0;\n-              @Override public boolean hasNext() { return true; }\n-              @Override public Integer next() { return at++; } \/\/ Wraps around on overflow\n-              @Override public void remove() { throw new UnsupportedOperationException(); }\n-            };\n-          }\n-        }, executor);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/example\/unicast\/InfiniteIncrementNumberPublisher.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.example.unicast;\n-\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.concurrent.Executor;\n-import org.reactivestreams.Subscription;\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Publisher;\n-\n-public class NumberIterablePublisher extends AsyncIterablePublisher<Integer> {\n-    public NumberIterablePublisher(final int from, final int to, final Executor executor) {\n-        super(new Iterable<Integer>() {\n-          { if(from > to) throw new IllegalArgumentException(\"from must be equal or greater than to!\"); }\n-          @Override public Iterator<Integer> iterator() {\n-            return new Iterator<Integer>() {\n-              private int at = from;\n-              @Override public boolean hasNext() { return at < to; }\n-              @Override public Integer next() {\n-                if (!hasNext()) return Collections.<Integer>emptyList().iterator().next();\n-                else return at++;\n-              }\n-              @Override public void remove() { throw new UnsupportedOperationException(); }\n-            };\n-          }\n-        }, executor);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/example\/unicast\/NumberIterablePublisher.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,254 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.example.unicast;\n-\n-import org.reactivestreams.*;\n-\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-\/**\n- * A synchronous implementation of the {@link Publisher} that can\n- * be subscribed to multiple times and each individual subscription\n- * will receive range of monotonically increasing integer values on demand.\n- *\/\n-public final class RangePublisher implements Publisher<Integer> {\n-\n-    \/** The starting value of the range. *\/\n-    final int start;\n-\n-    \/** The number of items to emit. *\/\n-    final int count;\n-\n-    \/**\n-     * Constructs a RangePublisher instance with the given start and count values\n-     * that yields a sequence of [start, start + count).\n-     * @param start the starting value of the range\n-     * @param count the number of items to emit\n-     *\/\n-    public RangePublisher(int start, int count) {\n-        this.start = start;\n-        this.count = count;\n-    }\n-\n-    @Override\n-    public void subscribe(Subscriber<? super Integer> subscriber) {\n-        \/\/ As per rule 1.11, we have decided to support multiple subscribers\n-        \/\/ in a unicast configuration for this `Publisher` implementation.\n-\n-        \/\/ As per rule 1.09, we need to throw a `java.lang.NullPointerException`\n-        \/\/ if the `Subscriber` is `null`\n-        if (subscriber == null) throw null;\n-\n-        \/\/ As per 2.13, this method must return normally (i.e. not throw).\n-        try {\n-            subscriber.onSubscribe(new RangeSubscription(subscriber, start, start + count));\n-        } catch (Throwable ex) {\n-            new IllegalStateException(subscriber + \" violated the Reactive Streams rule 2.13 \" +\n-                    \"by throwing an exception from onSubscribe.\", ex)\n-                    \/\/ When onSubscribe fails this way, we don't know what state the\n-                    \/\/ subscriber is thus calling onError may cause more crashes.\n-                    .printStackTrace();\n-        }\n-    }\n-\n-    \/**\n-     * A Subscription implementation that holds the current downstream\n-     * requested amount and responds to the downstream's request() and\n-     * cancel() calls.\n-     *\/\n-    static final class RangeSubscription\n-            \/\/ We are using this `AtomicLong` to make sure that this `Subscription`\n-            \/\/ doesn't run concurrently with itself, which would violate rule 1.3\n-            \/\/ among others (no concurrent notifications).\n-            \/\/ The atomic transition from 0L to N > 0L will ensure this.\n-            extends AtomicLong implements Subscription {\n-\n-        private static final long serialVersionUID = -9000845542177067735L;\n-\n-        \/** The Subscriber we are emitting integer values to. *\/\n-        final Subscriber<? super Integer> downstream;\n-\n-        \/** The end index (exclusive). *\/\n-        final int end;\n-\n-        \/**\n-         * The current index and within the [start, start + count) range that\n-         * will be emitted as downstream.onNext().\n-         *\/\n-        int index;\n-\n-        \/**\n-         * Indicates the emission should stop.\n-         *\/\n-        volatile boolean cancelled;\n-\n-        \/**\n-         * Holds onto the IllegalArgumentException (containing the offending stacktrace)\n-         * indicating there was a non-positive request() call from the downstream.\n-         *\/\n-        volatile Throwable invalidRequest;\n-\n-        \/**\n-         * Constructs a stateful RangeSubscription that emits signals to the given\n-         * downstream from an integer range of [start, end).\n-         * @param downstream the Subscriber receiving the integer values and the completion signal.\n-         * @param start the first integer value emitted, start of the range\n-         * @param end the end of the range, exclusive\n-         *\/\n-        RangeSubscription(Subscriber<? super Integer> downstream, int start, int end) {\n-            this.downstream = downstream;\n-            this.index = start;\n-            this.end = end;\n-        }\n-\n-        \/\/ This method will register inbound demand from our `Subscriber` and\n-        \/\/ validate it against rule 3.9 and rule 3.17\n-        @Override\n-        public void request(long n) {\n-            \/\/ Non-positive requests should be honored with IllegalArgumentException\n-            if (n <= 0L) {\n-                invalidRequest = new IllegalArgumentException(\"§3.9: non-positive requests are not allowed!\");\n-                n = 1;\n-            }\n-            \/\/ Downstream requests are cumulative and may come from any thread\n-            for (;;) {\n-                long requested = get();\n-                long update = requested + n;\n-                \/\/ As governed by rule 3.17, when demand overflows `Long.MAX_VALUE`\n-                \/\/ we treat the signalled demand as \"effectively unbounded\"\n-                if (update < 0L) {\n-                    update = Long.MAX_VALUE;\n-                }\n-                \/\/ atomically update the current requested amount\n-                if (compareAndSet(requested, update)) {\n-                    \/\/ if there was no prior request amount, we start the emission loop\n-                    if (requested == 0L) {\n-                        emit(update);\n-                    }\n-                    break;\n-                }\n-            }\n-        }\n-\n-        \/\/ This handles cancellation requests, and is idempotent, thread-safe and not\n-        \/\/ synchronously performing heavy computations as specified in rule 3.5\n-        @Override\n-        public void cancel() {\n-            \/\/ Indicate to the emission loop it should stop.\n-            cancelled = true;\n-        }\n-\n-        void emit(long currentRequested) {\n-            \/\/ Load fields to avoid re-reading them from memory due to volatile accesses in the loop.\n-            Subscriber<? super Integer> downstream = this.downstream;\n-            int index = this.index;\n-            int end = this.end;\n-            int emitted = 0;\n-\n-            try {\n-                for (; ; ) {\n-                    \/\/ Check if there was an invalid request and then report its exception\n-                    \/\/ as mandated by rule 3.9. The stacktrace in it should\n-                    \/\/ help locate the faulty logic in the Subscriber.\n-                    Throwable invalidRequest = this.invalidRequest;\n-                    if (invalidRequest != null) {\n-                        \/\/ When we signal onError, the subscription must be considered as cancelled, as per rule 1.6\n-                        cancelled = true;\n-\n-                        downstream.onError(invalidRequest);\n-                        return;\n-                    }\n-\n-                    \/\/ Loop while the index hasn't reached the end and we haven't\n-                    \/\/ emitted all that's been requested\n-                    while (index != end && emitted != currentRequested) {\n-                        \/\/ to make sure that we follow rule 1.8, 3.6 and 3.7\n-                        \/\/ We stop if cancellation was requested.\n-                        if (cancelled) {\n-                            return;\n-                        }\n-\n-                        downstream.onNext(index);\n-\n-                        \/\/ Increment the index for the next possible emission.\n-                        index++;\n-                        \/\/ Increment the emitted count to prevent overflowing the downstream.\n-                        emitted++;\n-                    }\n-\n-                    \/\/ If the index reached the end, we complete the downstream.\n-                    if (index == end) {\n-                        \/\/ to make sure that we follow rule 1.8, 3.6 and 3.7\n-                        \/\/ Unless cancellation was requested by the last onNext.\n-                        if (!cancelled) {\n-                            \/\/ We need to consider this `Subscription` as cancelled as per rule 1.6\n-                            \/\/ Note, however, that this state is not observable from the outside\n-                            \/\/ world and since we leave the loop with requested > 0L, any\n-                            \/\/ further request() will never trigger the loop.\n-                            cancelled = true;\n-\n-                            downstream.onComplete();\n-                        }\n-                        return;\n-                    }\n-\n-                    \/\/ Did the requested amount change while we were looping?\n-                    long freshRequested = get();\n-                    if (freshRequested == currentRequested) {\n-                        \/\/ Save where the loop has left off: the next value to be emitted\n-                        this.index = index;\n-                        \/\/ Atomically subtract the previously requested (also emitted) amount\n-                        currentRequested = addAndGet(-currentRequested);\n-                        \/\/ If there was no new request in between get() and addAndGet(), we simply quit\n-                        \/\/ The next 0 to N transition in request() will trigger the next emission loop.\n-                        if (currentRequested == 0L) {\n-                            break;\n-                        }\n-                        \/\/ Looks like there were more async requests, reset the emitted count and continue.\n-                        emitted = 0;\n-                    } else {\n-                        \/\/ Yes, avoid the atomic subtraction and resume.\n-                        \/\/ emitted != currentRequest in this case and index\n-                        \/\/ still points to the next value to be emitted\n-                        currentRequested = freshRequested;\n-                    }\n-                }\n-            } catch (Throwable ex) {\n-                \/\/ We can only get here if `onNext`, `onError` or `onComplete` threw, and they\n-                \/\/ are not allowed to according to 2.13, so we can only cancel and log here.\n-                \/\/ If `onError` throws an exception, this is a spec violation according to rule 1.9,\n-                \/\/ and all we can do is to log it.\n-\n-                \/\/ Make sure that we are cancelled, since we cannot do anything else\n-                \/\/ since the `Subscriber` is faulty.\n-                cancelled = true;\n-\n-                \/\/ We can't report the failure to onError as the Subscriber is unreliable.\n-                (new IllegalStateException(downstream + \" violated the Reactive Streams rule 2.13 by \" +\n-                        \"throwing an exception from onNext, onError or onComplete.\", ex))\n-                        .printStackTrace();\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/example\/unicast\/RangePublisher.java","additions":0,"deletions":254,"binary":false,"changes":254,"status":"deleted"},{"patch":"@@ -1,134 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.example.unicast;\n-\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-\n-\/**\n- * SyncSubscriber is an implementation of Reactive Streams `Subscriber`,\n- * it runs synchronously (on the Publisher's thread) and requests one element\n- * at a time and invokes a user-defined method to process each element.\n- *\n- * NOTE: The code below uses a lot of try-catches to show the reader where exceptions can be expected, and where they are forbidden.\n- *\/\n-public abstract class SyncSubscriber<T> implements Subscriber<T> {\n-  private Subscription subscription; \/\/ Obeying rule 3.1, we make this private!\n-  private boolean done = false;\n-\n-  @Override public void onSubscribe(final Subscription s) {\n-    \/\/ As per rule 2.13, we need to throw a `java.lang.NullPointerException` if the `Subscription` is `null`\n-    if (s == null) throw null;\n-\n-    if (subscription != null) { \/\/ If someone has made a mistake and added this Subscriber multiple times, let's handle it gracefully\n-      try {\n-        s.cancel(); \/\/ Cancel the additional subscription\n-      } catch(final Throwable t) {\n-        \/\/Subscription.cancel is not allowed to throw an exception, according to rule 3.15\n-        (new IllegalStateException(s + \" violated the Reactive Streams rule 3.15 by throwing an exception from cancel.\", t)).printStackTrace(System.err);\n-      }\n-    } else {\n-      \/\/ We have to assign it locally before we use it, if we want to be a synchronous `Subscriber`\n-      \/\/ Because according to rule 3.10, the Subscription is allowed to call `onNext` synchronously from within `request`\n-      subscription = s;\n-      try {\n-        \/\/ If we want elements, according to rule 2.1 we need to call `request`\n-        \/\/ And, according to rule 3.2 we are allowed to call this synchronously from within the `onSubscribe` method\n-        s.request(1); \/\/ Our Subscriber is unbuffered and modest, it requests one element at a time\n-      } catch(final Throwable t) {\n-        \/\/ Subscription.request is not allowed to throw according to rule 3.16\n-        (new IllegalStateException(s + \" violated the Reactive Streams rule 3.16 by throwing an exception from request.\", t)).printStackTrace(System.err);\n-      }\n-    }\n-  }\n-\n-  @Override public void onNext(final T element) {\n-    if (subscription == null) { \/\/ Technically this check is not needed, since we are expecting Publishers to conform to the spec\n-      (new IllegalStateException(\"Publisher violated the Reactive Streams rule 1.09 signalling onNext prior to onSubscribe.\")).printStackTrace(System.err);\n-    } else {\n-      \/\/ As per rule 2.13, we need to throw a `java.lang.NullPointerException` if the `element` is `null`\n-      if (element == null) throw null;\n-\n-      if (!done) { \/\/ If we aren't already done\n-        try {\n-          if (whenNext(element)) {\n-            try {\n-              subscription.request(1); \/\/ Our Subscriber is unbuffered and modest, it requests one element at a time\n-            } catch (final Throwable t) {\n-              \/\/ Subscription.request is not allowed to throw according to rule 3.16\n-              (new IllegalStateException(subscription + \" violated the Reactive Streams rule 3.16 by throwing an exception from request.\", t)).printStackTrace(System.err);\n-            }\n-          } else {\n-            done();\n-          }\n-        } catch (final Throwable t) {\n-          done();\n-          try {\n-            onError(t);\n-          } catch (final Throwable t2) {\n-            \/\/Subscriber.onError is not allowed to throw an exception, according to rule 2.13\n-            (new IllegalStateException(this + \" violated the Reactive Streams rule 2.13 by throwing an exception from onError.\", t2)).printStackTrace(System.err);\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ Showcases a convenience method to idempotently marking the Subscriber as \"done\", so we don't want to process more elements\n-  \/\/ herefor we also need to cancel our `Subscription`.\n-  private void done() {\n-    \/\/On this line we could add a guard against `!done`, but since rule 3.7 says that `Subscription.cancel()` is idempotent, we don't need to.\n-    done = true; \/\/ If we `whenNext` throws an exception, let's consider ourselves done (not accepting more elements)\n-    try {\n-      subscription.cancel(); \/\/ Cancel the subscription\n-    } catch(final Throwable t) {\n-      \/\/Subscription.cancel is not allowed to throw an exception, according to rule 3.15\n-      (new IllegalStateException(subscription + \" violated the Reactive Streams rule 3.15 by throwing an exception from cancel.\", t)).printStackTrace(System.err);\n-    }\n-  }\n-\n-  \/\/ This method is left as an exercise to the reader\/extension point\n-  \/\/ Returns whether more elements are desired or not, and if no more elements are desired\n-  protected abstract boolean whenNext(final T element);\n-\n-  @Override public void onError(final Throwable t) {\n-    if (subscription == null) { \/\/ Technically this check is not needed, since we are expecting Publishers to conform to the spec\n-      (new IllegalStateException(\"Publisher violated the Reactive Streams rule 1.09 signalling onError prior to onSubscribe.\")).printStackTrace(System.err);\n-    } else {\n-      \/\/ As per rule 2.13, we need to throw a `java.lang.NullPointerException` if the `Throwable` is `null`\n-      if (t == null) throw null;\n-      \/\/ Here we are not allowed to call any methods on the `Subscription` or the `Publisher`, as per rule 2.3\n-      \/\/ And anyway, the `Subscription` is considered to be cancelled if this method gets called, as per rule 2.4\n-    }\n-  }\n-\n-  @Override public void onComplete() {\n-    if (subscription == null) { \/\/ Technically this check is not needed, since we are expecting Publishers to conform to the spec\n-      (new IllegalStateException(\"Publisher violated the Reactive Streams rule 1.09 signalling onComplete prior to onSubscribe.\")).printStackTrace(System.err);\n-    } else {\n-      \/\/ Here we are not allowed to call any methods on the `Subscription` or the `Publisher`, as per rule 2.3\n-      \/\/ And anyway, the `Subscription` is considered to be cancelled if this method gets called, as per rule 2.4\n-    }\n-  }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/example\/unicast\/SyncSubscriber.java","additions":0,"deletions":134,"binary":false,"changes":134,"status":"deleted"},{"patch":"@@ -1,896 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck;\n-\n-import org.reactivestreams.Processor;\n-import org.reactivestreams.Publisher;\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-import org.reactivestreams.tck.TestEnvironment.ManualPublisher;\n-import org.reactivestreams.tck.TestEnvironment.ManualSubscriber;\n-import org.reactivestreams.tck.TestEnvironment.ManualSubscriberWithSubscriptionSupport;\n-import org.reactivestreams.tck.TestEnvironment.Promise;\n-import org.reactivestreams.tck.flow.support.Function;\n-import org.reactivestreams.tck.flow.support.SubscriberWhiteboxVerificationRules;\n-import org.reactivestreams.tck.flow.support.PublisherVerificationRules;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n-\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-public abstract class IdentityProcessorVerification<T> extends WithHelperPublisher<T>\n-  implements SubscriberWhiteboxVerificationRules, PublisherVerificationRules {\n-\n-  private final TestEnvironment env;\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ DELEGATED TO SPECS \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  \/\/ for delegating tests\n-  private final SubscriberWhiteboxVerification<T> subscriberVerification;\n-\n-  \/\/ for delegating tests\n-  private final PublisherVerification<T> publisherVerification;\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ END OF DELEGATED TO SPECS \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  \/\/ number of elements the processor under test must be able ot buffer,\n-  \/\/ without dropping elements. Defaults to `TestEnvironment.TEST_BUFFER_SIZE`.\n-  private final int processorBufferSize;\n-\n-  \/**\n-   * Test class must specify the expected time it takes for the publisher to\n-   * shut itself down when the last downstream {@code Subscription} is cancelled.\n-   *\n-   * The processor will be required to be able to buffer {@code TestEnvironment.TEST_BUFFER_SIZE} elements.\n-   *\/\n-  @SuppressWarnings(\"unused\")\n-  public IdentityProcessorVerification(final TestEnvironment env) {\n-    this(env, PublisherVerification.envPublisherReferenceGCTimeoutMillis(), TestEnvironment.TEST_BUFFER_SIZE);\n-  }\n-\n-  \/**\n-   * Test class must specify the expected time it takes for the publisher to\n-   * shut itself down when the last downstream {@code Subscription} is cancelled.\n-   *\n-   * The processor will be required to be able to buffer {@code TestEnvironment.TEST_BUFFER_SIZE} elements.\n-   *\n-   * @param publisherReferenceGCTimeoutMillis used to determine after how much time a reference to a Subscriber should be already dropped by the Publisher.\n-   *\/\n-  @SuppressWarnings(\"unused\")\n-  public IdentityProcessorVerification(final TestEnvironment env, long publisherReferenceGCTimeoutMillis) {\n-    this(env, publisherReferenceGCTimeoutMillis, TestEnvironment.TEST_BUFFER_SIZE);\n-  }\n-\n-  \/**\n-   * Test class must specify the expected time it takes for the publisher to\n-   * shut itself down when the last downstream {@code Subscription} is cancelled.\n-   *\n-   * @param publisherReferenceGCTimeoutMillis used to determine after how much time a reference to a Subscriber should be already dropped by the Publisher.\n-   * @param processorBufferSize            number of elements the processor is required to be able to buffer.\n-   *\/\n-  public IdentityProcessorVerification(final TestEnvironment env, long publisherReferenceGCTimeoutMillis, int processorBufferSize) {\n-    this.env = env;\n-    this.processorBufferSize = processorBufferSize;\n-\n-    this.subscriberVerification = new SubscriberWhiteboxVerification<T>(env) {\n-      @Override\n-      public Subscriber<T> createSubscriber(WhiteboxSubscriberProbe<T> probe) {\n-        return IdentityProcessorVerification.this.createSubscriber(probe);\n-      }\n-\n-      @Override public T createElement(int element) {\n-        return IdentityProcessorVerification.this.createElement(element);\n-      }\n-\n-      @Override\n-      public Publisher<T> createHelperPublisher(long elements) {\n-        return IdentityProcessorVerification.this.createHelperPublisher(elements);\n-      }\n-    };\n-\n-    publisherVerification = new PublisherVerification<T>(env, publisherReferenceGCTimeoutMillis) {\n-      @Override\n-      public Publisher<T> createPublisher(long elements) {\n-        return IdentityProcessorVerification.this.createPublisher(elements);\n-      }\n-\n-      @Override\n-      public Publisher<T> createFailedPublisher() {\n-        return IdentityProcessorVerification.this.createFailedPublisher();\n-      }\n-\n-      @Override\n-      public long maxElementsFromPublisher() {\n-        return IdentityProcessorVerification.this.maxElementsFromPublisher();\n-      }\n-\n-      @Override\n-      public long boundedDepthOfOnNextAndRequestRecursion() {\n-        return IdentityProcessorVerification.this.boundedDepthOfOnNextAndRequestRecursion();\n-      }\n-\n-      @Override\n-      public boolean skipStochasticTests() {\n-        return IdentityProcessorVerification.this.skipStochasticTests();\n-      }\n-    };\n-  }\n-\n-  \/**\n-   * This is the main method you must implement in your test incarnation.\n-   * It must create a {@link Processor}, which simply forwards all stream elements from its upstream\n-   * to its downstream. It must be able to internally buffer the given number of elements.\n-   *\n-   * @param bufferSize number of elements the processor is required to be able to buffer.\n-   *\/\n-  public abstract Processor<T, T> createIdentityProcessor(int bufferSize);\n-\n-  \/**\n-   * By implementing this method, additional TCK tests concerning a \"failed\" publishers will be run.\n-   *\n-   * The expected behaviour of the {@link Publisher} returned by this method is hand out a subscription,\n-   * followed by signalling {@code onError} on it, as specified by Rule 1.9.\n-   *\n-   * If you want to ignore these additional tests, return {@code null} from this method.\n-   *\/\n-  public abstract Publisher<T> createFailedPublisher();\n-\n-  \/**\n-   * Override and return lower value if your Publisher is only able to produce a known number of elements.\n-   * For example, if it is designed to return at-most-one element, return {@code 1} from this method.\n-   *\n-   * Defaults to {@code Long.MAX_VALUE - 1}, meaning that the Publisher can be produce a huge but NOT an unbounded number of elements.\n-   *\n-   * To mark your Publisher will *never* signal an {@code onComplete} override this method and return {@code Long.MAX_VALUE},\n-   * which will result in *skipping all tests which require an onComplete to be triggered* (!).\n-   *\/\n-  public long maxElementsFromPublisher() {\n-    return Long.MAX_VALUE - 1;\n-  }\n-\n-  \/**\n-   * In order to verify rule 3.3 of the reactive streams spec, this number will be used to check if a\n-   * {@code Subscription} actually solves the \"unbounded recursion\" problem by not allowing the number of\n-   * recursive calls to exceed the number returned by this method.\n-   *\n-   * @see <a href=\"https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.3\">reactive streams spec, rule 3.3<\/a>\n-   * @see PublisherVerification#required_spec303_mustNotAllowUnboundedRecursion()\n-   *\/\n-  public long boundedDepthOfOnNextAndRequestRecursion() {\n-    return 1;\n-  }\n-\n-  \/**\n-   * Override and return {@code true} in order to skip executing tests marked as {@code Stochastic}.\n-   * Stochastic in this case means that the Rule is impossible or infeasible to deterministically verify—\n-   * usually this means that this test case can yield false positives (\"be green\") even if for some case,\n-   * the given implementation may violate the tested behaviour.\n-   *\/\n-  public boolean skipStochasticTests() {\n-    return false;\n-  }\n-\n-  \/**\n-   * Describes the tested implementation in terms of how many subscribers they can support.\n-   * Some tests require the {@code Publisher} under test to support multiple Subscribers,\n-   * yet the spec does not require all publishers to be able to do so, thus – if an implementation\n-   * supports only a limited number of subscribers (e.g. only 1 subscriber, also known as \"no fanout\")\n-   * you MUST return that number from this method by overriding it.\n-   *\/\n-  public long maxSupportedSubscribers() {\n-      return Long.MAX_VALUE;\n-  }\n-\n-  \/**\n-   * Override this method and return {@code true} if the {@link Processor} returned by the\n-   * {@link #createIdentityProcessor(int)} coordinates its {@link Subscriber}s\n-   * request amounts and only delivers onNext signals if all Subscribers have\n-   * indicated (via their Subscription#request(long)) they are ready to receive elements.\n-   *\/\n-  public boolean doesCoordinatedEmission() {\n-    return false;\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ TEST ENV CLEANUP \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  @BeforeMethod\n-  public void setUp() throws Exception {\n-    publisherVerification.setUp();\n-    subscriberVerification.setUp();\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ PUBLISHER RULES VERIFICATION \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  \/\/ A Processor\n-  \/\/   must obey all Publisher rules on its publishing side\n-  public Publisher<T> createPublisher(long elements) {\n-    final Processor<T, T> processor = createIdentityProcessor(processorBufferSize);\n-    final Publisher<T> pub = createHelperPublisher(elements);\n-    pub.subscribe(processor);\n-    return processor; \/\/ we run the PublisherVerification against this\n-  }\n-\n-  @Override @Test\n-  public void required_validate_maxElementsFromPublisher() throws Exception {\n-    publisherVerification.required_validate_maxElementsFromPublisher();\n-  }\n-\n-  @Override @Test\n-  public void required_validate_boundedDepthOfOnNextAndRequestRecursion() throws Exception {\n-    publisherVerification.required_validate_boundedDepthOfOnNextAndRequestRecursion();\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ DELEGATED TESTS, A PROCESSOR \"IS A\" PUBLISHER \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#4.1\n-\n-  @Test\n-  public void required_createPublisher1MustProduceAStreamOfExactly1Element() throws Throwable {\n-    publisherVerification.required_createPublisher1MustProduceAStreamOfExactly1Element();\n-  }\n-\n-  @Test\n-  public void required_createPublisher3MustProduceAStreamOfExactly3Elements() throws Throwable {\n-    publisherVerification.required_createPublisher3MustProduceAStreamOfExactly3Elements();\n-  }\n-\n-  @Override @Test\n-  public void required_spec101_subscriptionRequestMustResultInTheCorrectNumberOfProducedElements() throws Throwable {\n-    publisherVerification.required_spec101_subscriptionRequestMustResultInTheCorrectNumberOfProducedElements();\n-  }\n-\n-  @Override @Test\n-  public void required_spec102_maySignalLessThanRequestedAndTerminateSubscription() throws Throwable {\n-    publisherVerification.required_spec102_maySignalLessThanRequestedAndTerminateSubscription();\n-  }\n-\n-  @Override @Test\n-  public void stochastic_spec103_mustSignalOnMethodsSequentially() throws Throwable {\n-    publisherVerification.stochastic_spec103_mustSignalOnMethodsSequentially();\n-  }\n-\n-  @Override @Test\n-  public void optional_spec104_mustSignalOnErrorWhenFails() throws Throwable {\n-    publisherVerification.optional_spec104_mustSignalOnErrorWhenFails();\n-  }\n-\n-  @Override @Test\n-  public void required_spec105_mustSignalOnCompleteWhenFiniteStreamTerminates() throws Throwable {\n-    publisherVerification.required_spec105_mustSignalOnCompleteWhenFiniteStreamTerminates();\n-  }\n-\n-  @Override @Test\n-  public void optional_spec105_emptyStreamMustTerminateBySignallingOnComplete() throws Throwable {\n-    publisherVerification.optional_spec105_emptyStreamMustTerminateBySignallingOnComplete();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec106_mustConsiderSubscriptionCancelledAfterOnErrorOrOnCompleteHasBeenCalled() throws Throwable {\n-    publisherVerification.untested_spec106_mustConsiderSubscriptionCancelledAfterOnErrorOrOnCompleteHasBeenCalled();\n-  }\n-\n-  @Override @Test\n-  public void required_spec107_mustNotEmitFurtherSignalsOnceOnCompleteHasBeenSignalled() throws Throwable {\n-    publisherVerification.required_spec107_mustNotEmitFurtherSignalsOnceOnCompleteHasBeenSignalled();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec107_mustNotEmitFurtherSignalsOnceOnErrorHasBeenSignalled() throws Throwable {\n-    publisherVerification.untested_spec107_mustNotEmitFurtherSignalsOnceOnErrorHasBeenSignalled();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec108_possiblyCanceledSubscriptionShouldNotReceiveOnErrorOrOnCompleteSignals() throws Throwable {\n-    publisherVerification.untested_spec108_possiblyCanceledSubscriptionShouldNotReceiveOnErrorOrOnCompleteSignals();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec109_subscribeShouldNotThrowNonFatalThrowable() throws Throwable {\n-    publisherVerification.untested_spec109_subscribeShouldNotThrowNonFatalThrowable();\n-  }\n-\n-  @Override @Test\n-  public void required_spec109_subscribeThrowNPEOnNullSubscriber() throws Throwable {\n-    publisherVerification.required_spec109_subscribeThrowNPEOnNullSubscriber();\n-  }\n-\n-  @Override @Test\n-  public void required_spec109_mayRejectCallsToSubscribeIfPublisherIsUnableOrUnwillingToServeThemRejectionMustTriggerOnErrorAfterOnSubscribe() throws Throwable {\n-    publisherVerification.required_spec109_mayRejectCallsToSubscribeIfPublisherIsUnableOrUnwillingToServeThemRejectionMustTriggerOnErrorAfterOnSubscribe();\n-  }\n-\n-  @Override @Test\n-  public void required_spec109_mustIssueOnSubscribeForNonNullSubscriber() throws Throwable {\n-    publisherVerification.required_spec109_mustIssueOnSubscribeForNonNullSubscriber();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec110_rejectASubscriptionRequestIfTheSameSubscriberSubscribesTwice() throws Throwable {\n-    publisherVerification.untested_spec110_rejectASubscriptionRequestIfTheSameSubscriberSubscribesTwice();\n-  }\n-\n-  @Override @Test\n-  public void optional_spec111_maySupportMultiSubscribe() throws Throwable {\n-    publisherVerification.optional_spec111_maySupportMultiSubscribe();\n-  }\n-\n-  @Override @Test\n-  public void optional_spec111_registeredSubscribersMustReceiveOnNextOrOnCompleteSignals() throws Throwable {\n-    publisherVerification.optional_spec111_registeredSubscribersMustReceiveOnNextOrOnCompleteSignals();\n-  }\n-\n-  @Override @Test\n-  public void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingOneByOne() throws Throwable {\n-    publisherVerification.optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingOneByOne();\n-  }\n-\n-  @Override @Test\n-  public void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfront() throws Throwable {\n-    publisherVerification.optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfront();\n-  }\n-\n-  @Override @Test\n-  public void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfrontAndCompleteAsExpected() throws Throwable {\n-    publisherVerification.optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfrontAndCompleteAsExpected();\n-  }\n-\n-  @Override @Test\n-  public void required_spec302_mustAllowSynchronousRequestCallsFromOnNextAndOnSubscribe() throws Throwable {\n-    publisherVerification.required_spec302_mustAllowSynchronousRequestCallsFromOnNextAndOnSubscribe();\n-  }\n-\n-  @Override @Test\n-  public void required_spec303_mustNotAllowUnboundedRecursion() throws Throwable {\n-    publisherVerification.required_spec303_mustNotAllowUnboundedRecursion();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec304_requestShouldNotPerformHeavyComputations() throws Exception {\n-    publisherVerification.untested_spec304_requestShouldNotPerformHeavyComputations();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec305_cancelMustNotSynchronouslyPerformHeavyComputation() throws Exception {\n-    publisherVerification.untested_spec305_cancelMustNotSynchronouslyPerformHeavyComputation();\n-  }\n-\n-  @Override @Test\n-  public void required_spec306_afterSubscriptionIsCancelledRequestMustBeNops() throws Throwable {\n-    publisherVerification.required_spec306_afterSubscriptionIsCancelledRequestMustBeNops();\n-  }\n-\n-  @Override @Test\n-  public void required_spec307_afterSubscriptionIsCancelledAdditionalCancelationsMustBeNops() throws Throwable {\n-    publisherVerification.required_spec307_afterSubscriptionIsCancelledAdditionalCancelationsMustBeNops();\n-  }\n-\n-  @Override @Test\n-  public void required_spec309_requestZeroMustSignalIllegalArgumentException() throws Throwable {\n-    publisherVerification.required_spec309_requestZeroMustSignalIllegalArgumentException();\n-  }\n-\n-  @Override @Test\n-  public void required_spec309_requestNegativeNumberMustSignalIllegalArgumentException() throws Throwable {\n-    publisherVerification.required_spec309_requestNegativeNumberMustSignalIllegalArgumentException();\n-  }\n-\n-  @Override @Test\n-  public void optional_spec309_requestNegativeNumberMaySignalIllegalArgumentExceptionWithSpecificMessage() throws Throwable {\n-    publisherVerification.optional_spec309_requestNegativeNumberMaySignalIllegalArgumentExceptionWithSpecificMessage();\n-  }\n-\n-  @Override @Test\n-  public void required_spec312_cancelMustMakeThePublisherToEventuallyStopSignaling() throws Throwable {\n-    publisherVerification.required_spec312_cancelMustMakeThePublisherToEventuallyStopSignaling();\n-  }\n-\n-  @Override @Test\n-  public void required_spec313_cancelMustMakeThePublisherEventuallyDropAllReferencesToTheSubscriber() throws Throwable {\n-    publisherVerification.required_spec313_cancelMustMakeThePublisherEventuallyDropAllReferencesToTheSubscriber();\n-  }\n-\n-  @Override @Test\n-  public void required_spec317_mustSupportAPendingElementCountUpToLongMaxValue() throws Throwable {\n-    publisherVerification.required_spec317_mustSupportAPendingElementCountUpToLongMaxValue();\n-  }\n-\n-  @Override @Test\n-  public void required_spec317_mustSupportACumulativePendingElementCountUpToLongMaxValue() throws Throwable {\n-    publisherVerification.required_spec317_mustSupportACumulativePendingElementCountUpToLongMaxValue();\n-  }\n-\n-  @Override @Test\n-  public void required_spec317_mustNotSignalOnErrorWhenPendingAboveLongMaxValue() throws Throwable {\n-    publisherVerification.required_spec317_mustNotSignalOnErrorWhenPendingAboveLongMaxValue();\n-  }\n-\n-\n-  \/**\n-   * Asks for a {@code Processor} that supports at least 2 {@code Subscriber}s at once and checks if two {@code Subscriber}s\n-   * receive the same items and a terminal {@code Exception}.\n-   * <p>\n-   * If the {@code Processor} requests and\/or emits items only when all of its {@code Subscriber}s have requested,\n-   * override {@link #doesCoordinatedEmission()} and return {@code true} to indicate this property.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.4'>1.4<\/a> with multiple\n-   * {@code Subscriber}s.\n-   * <p>\n-   * The test is not executed if {@link IdentityProcessorVerification#maxSupportedSubscribers()} is less than 2.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Processor} implementation:\n-   * <ul>\n-   * <li>The {@code TestEnvironment} has large enough timeout specified in case the {@code Processor} has some time-delay behavior.<\/li>\n-   * <li>The {@code Processor} is able to fulfill requests of its {@code Subscriber}s independently of each other's requests or\n-   * else override {@link #doesCoordinatedEmission()} and return {@code true} to indicate the test {@code Subscriber}s\n-   * both have to request first.<\/li>\n-   * <\/ul>\n-   *\/\n-  @Test\n-  public void required_spec104_mustCallOnErrorOnAllItsSubscribersIfItEncountersANonRecoverableError() throws Throwable {\n-    optionalMultipleSubscribersTest(2, new Function<Long,TestSetup>() {\n-      @Override\n-      public TestSetup apply(Long aLong) throws Throwable {\n-        return new TestSetup(env, processorBufferSize) {{\n-          final ManualSubscriberWithErrorCollection<T> sub1 = new ManualSubscriberWithErrorCollection<T>(env);\n-          env.subscribe(processor, sub1);\n-\n-          final ManualSubscriberWithErrorCollection<T> sub2 = new ManualSubscriberWithErrorCollection<T>(env);\n-          env.subscribe(processor, sub2);\n-\n-          final Exception ex = new RuntimeException(\"Test exception\");\n-\n-          if (doesCoordinatedEmission()) {\n-            sub1.request(1);\n-            sub2.request(1);\n-\n-            expectRequest();\n-\n-            final T x = sendNextTFromUpstream();\n-\n-            expectNextElement(sub1, x);\n-            expectNextElement(sub2, x);\n-\n-            sub1.request(1);\n-            sub2.request(1);\n-          } else {\n-            sub1.request(1);\n-\n-            expectRequest(env.defaultTimeoutMillis(),\n-                    \"If the Processor coordinates requests\/emissions when having multiple Subscribers\"\n-                    + \" at once, please override doesCoordinatedEmission() to return true in this \"\n-                    + \"IdentityProcessorVerification to allow this test to pass.\");\n-\n-            final T x = sendNextTFromUpstream();\n-            expectNextElement(sub1, x,\n-                    \"If the Processor coordinates requests\/emissions when having multiple Subscribers\"\n-                            + \" at once, please override doesCoordinatedEmission() to return true in this \"\n-                            + \"IdentityProcessorVerification to allow this test to pass.\");\n-\n-            sub1.request(1);\n-\n-            \/\/ sub1 has received one element, and has one demand pending\n-            \/\/ sub2 has not yet requested anything\n-          }\n-          sendError(ex);\n-\n-          sub1.expectError(ex);\n-          sub2.expectError(ex);\n-\n-          env.verifyNoAsyncErrorsNoDelay();\n-        }};\n-      }\n-    });\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ SUBSCRIBER RULES VERIFICATION \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#4.1\n-\n-  \/\/ A Processor\n-  \/\/   must obey all Subscriber rules on its consuming side\n-  public Subscriber<T> createSubscriber(final SubscriberWhiteboxVerification.WhiteboxSubscriberProbe<T> probe) {\n-    final Processor<T, T> processor = createIdentityProcessor(processorBufferSize);\n-    processor.subscribe(\n-        new Subscriber<T>() {\n-          private final Promise<Subscription> subs = new Promise<Subscription>(env);\n-\n-          @Override\n-          public void onSubscribe(final Subscription subscription) {\n-            if (env.debugEnabled()) {\n-              env.debug(String.format(\"whiteboxSubscriber::onSubscribe(%s)\", subscription));\n-            }\n-            if (subs.isCompleted()) subscription.cancel(); \/\/ the Probe must also pass subscriber verification\n-\n-            probe.registerOnSubscribe(new SubscriberWhiteboxVerification.SubscriberPuppet() {\n-\n-              @Override\n-              public void triggerRequest(long elements) {\n-                subscription.request(elements);\n-              }\n-\n-              @Override\n-              public void signalCancel() {\n-                subscription.cancel();\n-              }\n-            });\n-          }\n-\n-          @Override\n-          public void onNext(T element) {\n-            if (env.debugEnabled()) {\n-              env.debug(String.format(\"whiteboxSubscriber::onNext(%s)\", element));\n-            }\n-            probe.registerOnNext(element);\n-          }\n-\n-          @Override\n-          public void onComplete() {\n-            if (env.debugEnabled()) {\n-              env.debug(\"whiteboxSubscriber::onComplete()\");\n-            }\n-            probe.registerOnComplete();\n-          }\n-\n-          @Override\n-          public void onError(Throwable cause) {\n-            if (env.debugEnabled()) {\n-              env.debug(String.format(\"whiteboxSubscriber::onError(%s)\", cause));\n-            }\n-            probe.registerOnError(cause);\n-          }\n-        });\n-\n-    return processor; \/\/ we run the SubscriberVerification against this\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ OTHER RULE VERIFICATION \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  \/\/ A Processor\n-  \/\/   must immediately pass on `onError` events received from its upstream to its downstream\n-  @Test\n-  public void mustImmediatelyPassOnOnErrorEventsReceivedFromItsUpstreamToItsDownstream() throws Exception {\n-    new TestSetup(env, processorBufferSize) {{\n-      final ManualSubscriberWithErrorCollection<T> sub = new ManualSubscriberWithErrorCollection<T>(env);\n-      env.subscribe(processor, sub);\n-\n-      final Exception ex = new RuntimeException(\"Test exception\");\n-      sendError(ex);\n-      sub.expectError(ex); \/\/ \"immediately\", i.e. without a preceding request\n-\n-      env.verifyNoAsyncErrorsNoDelay();\n-    }};\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ DELEGATED TESTS, A PROCESSOR \"IS A\" SUBSCRIBER \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#4.1\n-\n-  @Test\n-  public void required_exerciseWhiteboxHappyPath() throws Throwable {\n-    subscriberVerification.required_exerciseWhiteboxHappyPath();\n-  }\n-\n-  @Override @Test\n-  public void required_spec201_mustSignalDemandViaSubscriptionRequest() throws Throwable {\n-    subscriberVerification.required_spec201_mustSignalDemandViaSubscriptionRequest();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec202_shouldAsynchronouslyDispatch() throws Exception {\n-    subscriberVerification.untested_spec202_shouldAsynchronouslyDispatch();\n-  }\n-\n-  @Override @Test\n-  public void required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnComplete() throws Throwable {\n-    subscriberVerification.required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnComplete();\n-  }\n-\n-  @Override @Test\n-  public void required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnError() throws Throwable {\n-    subscriberVerification.required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnError();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec204_mustConsiderTheSubscriptionAsCancelledInAfterRecievingOnCompleteOrOnError() throws Exception {\n-    subscriberVerification.untested_spec204_mustConsiderTheSubscriptionAsCancelledInAfterRecievingOnCompleteOrOnError();\n-  }\n-\n-  @Override @Test\n-  public void required_spec205_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal() throws Throwable {\n-    subscriberVerification.required_spec205_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec206_mustCallSubscriptionCancelIfItIsNoLongerValid() throws Exception {\n-    subscriberVerification.untested_spec206_mustCallSubscriptionCancelIfItIsNoLongerValid();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec207_mustEnsureAllCallsOnItsSubscriptionTakePlaceFromTheSameThreadOrTakeCareOfSynchronization() throws Exception {\n-    subscriberVerification.untested_spec207_mustEnsureAllCallsOnItsSubscriptionTakePlaceFromTheSameThreadOrTakeCareOfSynchronization();\n-  }\n-\n-  @Override @Test\n-  public void required_spec208_mustBePreparedToReceiveOnNextSignalsAfterHavingCalledSubscriptionCancel() throws Throwable {\n-    subscriberVerification.required_spec208_mustBePreparedToReceiveOnNextSignalsAfterHavingCalledSubscriptionCancel();\n-  }\n-\n-  @Override @Test\n-  public void required_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithPrecedingRequestCall() throws Throwable {\n-    subscriberVerification.required_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithPrecedingRequestCall();\n-  }\n-\n-  @Override @Test\n-  public void required_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithoutPrecedingRequestCall() throws Throwable {\n-    subscriberVerification.required_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithoutPrecedingRequestCall();\n-  }\n-\n-  @Override @Test\n-  public void required_spec210_mustBePreparedToReceiveAnOnErrorSignalWithPrecedingRequestCall() throws Throwable {\n-    subscriberVerification.required_spec210_mustBePreparedToReceiveAnOnErrorSignalWithPrecedingRequestCall();\n-  }\n-\n-  @Override @Test\n-  public void required_spec210_mustBePreparedToReceiveAnOnErrorSignalWithoutPrecedingRequestCall() throws Throwable {\n-    subscriberVerification.required_spec210_mustBePreparedToReceiveAnOnErrorSignalWithoutPrecedingRequestCall();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec211_mustMakeSureThatAllCallsOnItsMethodsHappenBeforeTheProcessingOfTheRespectiveEvents() throws Exception {\n-    subscriberVerification.untested_spec211_mustMakeSureThatAllCallsOnItsMethodsHappenBeforeTheProcessingOfTheRespectiveEvents();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec212_mustNotCallOnSubscribeMoreThanOnceBasedOnObjectEquality_specViolation() throws Throwable {\n-    subscriberVerification.untested_spec212_mustNotCallOnSubscribeMoreThanOnceBasedOnObjectEquality_specViolation();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec213_failingOnSignalInvocation() throws Exception {\n-    subscriberVerification.untested_spec213_failingOnSignalInvocation();\n-  }\n-\n-  @Override @Test\n-  public void required_spec213_onSubscribe_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable {\n-    subscriberVerification.required_spec213_onSubscribe_mustThrowNullPointerExceptionWhenParametersAreNull();\n-  }\n-  @Override @Test\n-  public void required_spec213_onNext_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable {\n-    subscriberVerification.required_spec213_onNext_mustThrowNullPointerExceptionWhenParametersAreNull();\n-  }\n-  @Override @Test\n-  public void required_spec213_onError_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable {\n-    subscriberVerification.required_spec213_onError_mustThrowNullPointerExceptionWhenParametersAreNull();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec301_mustNotBeCalledOutsideSubscriberContext() throws Exception {\n-    subscriberVerification.untested_spec301_mustNotBeCalledOutsideSubscriberContext();\n-  }\n-\n-  @Override @Test\n-  public void required_spec308_requestMustRegisterGivenNumberElementsToBeProduced() throws Throwable {\n-    subscriberVerification.required_spec308_requestMustRegisterGivenNumberElementsToBeProduced();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec310_requestMaySynchronouslyCallOnNextOnSubscriber() throws Exception {\n-    subscriberVerification.untested_spec310_requestMaySynchronouslyCallOnNextOnSubscriber();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec311_requestMaySynchronouslyCallOnCompleteOrOnError() throws Exception {\n-    subscriberVerification.untested_spec311_requestMaySynchronouslyCallOnCompleteOrOnError();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec314_cancelMayCauseThePublisherToShutdownIfNoOtherSubscriptionExists() throws Exception {\n-    subscriberVerification.untested_spec314_cancelMayCauseThePublisherToShutdownIfNoOtherSubscriptionExists();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec315_cancelMustNotThrowExceptionAndMustSignalOnError() throws Exception {\n-    subscriberVerification.untested_spec315_cancelMustNotThrowExceptionAndMustSignalOnError();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec316_requestMustNotThrowExceptionAndMustOnErrorTheSubscriber() throws Exception {\n-    subscriberVerification.untested_spec316_requestMustNotThrowExceptionAndMustOnErrorTheSubscriber();\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ ADDITIONAL \"COROLLARY\" TESTS \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  \/**\n-   * Asks for a {@code Processor} that supports at least 2 {@code Subscriber}s at once and checks requests\n-   * from {@code Subscriber}s will eventually lead to requests towards the upstream of the {@code Processor}.\n-   * <p>\n-   * If the {@code Processor} requests and\/or emits items only when all of its {@code Subscriber}s have requested,\n-   * override {@link #doesCoordinatedEmission()} and return {@code true} to indicate this property.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.4'>2.1<\/a> with multiple\n-   * {@code Subscriber}s.\n-   * <p>\n-   * The test is not executed if {@link IdentityProcessorVerification#maxSupportedSubscribers()} is less than 2.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Processor} implementation:\n-   * <ul>\n-   * <li>The {@code TestEnvironment} has large enough timeout specified in case the {@code Processor} has some time-delay behavior.<\/li>\n-   * <li>The {@code Processor} is able to fulfill requests of its {@code Subscriber}s independently of each other's requests or\n-   * else override {@link #doesCoordinatedEmission()} and return {@code true} to indicate the test {@code Subscriber}s\n-   * both have to request first.<\/li>\n-   * <\/ul>\n-   *\/\n-  @Test\n-  public void required_mustRequestFromUpstreamForElementsThatHaveBeenRequestedLongAgo() throws Throwable {\n-    optionalMultipleSubscribersTest(2, new Function<Long,TestSetup>() {\n-      @Override\n-      public TestSetup apply(Long subscribers) throws Throwable {\n-        return new TestSetup(env, processorBufferSize) {{\n-          ManualSubscriber<T> sub1 = newSubscriber();\n-          sub1.request(20);\n-\n-          long totalRequests = expectRequest();\n-          final T x = sendNextTFromUpstream();\n-          expectNextElement(sub1, x);\n-\n-          if (totalRequests == 1) {\n-            totalRequests += expectRequest();\n-          }\n-          final T y = sendNextTFromUpstream();\n-          expectNextElement(sub1, y);\n-\n-          if (totalRequests == 2) {\n-            totalRequests += expectRequest();\n-          }\n-\n-          final ManualSubscriber<T> sub2 = newSubscriber();\n-\n-          \/\/ sub1 now has 18 pending\n-          \/\/ sub2 has 0 pending\n-\n-          if (doesCoordinatedEmission()) {\n-            sub2.expectNone(); \/\/ since sub2 hasn't requested anything yet\n-\n-            sub2.request(1);\n-\n-            final T z = sendNextTFromUpstream();\n-            expectNextElement(sub1, z);\n-            expectNextElement(sub2, z);\n-          } else {\n-            final T z = sendNextTFromUpstream();\n-            expectNextElement(sub1, z,\n-                    \"If the Processor coordinates requests\/emissions when having multiple Subscribers\"\n-                            + \" at once, please override doesCoordinatedEmission() to return true in this \"\n-                            + \"IdentityProcessorVerification to allow this test to pass.\");\n-            sub2.expectNone(); \/\/ since sub2 hasn't requested anything yet\n-\n-            sub2.request(1);\n-            expectNextElement(sub2, z);\n-          }\n-          if (totalRequests == 3) {\n-            expectRequest();\n-          }\n-\n-          \/\/ to avoid error messages during test harness shutdown\n-          sendCompletion();\n-          sub1.expectCompletion(env.defaultTimeoutMillis());\n-          sub2.expectCompletion(env.defaultTimeoutMillis());\n-\n-          env.verifyNoAsyncErrorsNoDelay();\n-        }};\n-      }\n-    });\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ TEST INFRASTRUCTURE \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  public void notVerified() {\n-    publisherVerification.notVerified();\n-  }\n-\n-  public void notVerified(String message) {\n-    publisherVerification.notVerified(message);\n-  }\n-\n-  \/**\n-   * Test for feature that REQUIRES multiple subscribers to be supported by Publisher.\n-   *\/\n-  public void optionalMultipleSubscribersTest(long requiredSubscribersSupport, Function<Long, TestSetup> body) throws Throwable {\n-    if (requiredSubscribersSupport > maxSupportedSubscribers())\n-      notVerified(String.format(\"The Publisher under test only supports %d subscribers, while this test requires at least %d to run.\",\n-                                maxSupportedSubscribers(), requiredSubscribersSupport));\n-    else body.apply(requiredSubscribersSupport);\n-  }\n-\n-  public abstract class TestSetup extends ManualPublisher<T> {\n-    final private ManualSubscriber<T> tees; \/\/ gives us access to an infinite stream of T values\n-    private Set<T> seenTees = new HashSet<T>();\n-\n-    final Processor<T, T> processor;\n-\n-    public TestSetup(TestEnvironment env, int testBufferSize) throws InterruptedException {\n-      super(env);\n-      tees = env.newManualSubscriber(createHelperPublisher(Long.MAX_VALUE));\n-      processor = createIdentityProcessor(testBufferSize);\n-      subscribe(processor);\n-    }\n-\n-    public ManualSubscriber<T> newSubscriber() throws InterruptedException {\n-      return env.newManualSubscriber(processor);\n-    }\n-\n-    public T nextT() throws InterruptedException {\n-      final T t = tees.requestNextElement();\n-      if (seenTees.contains(t)) {\n-        env.flop(String.format(\"Helper publisher illegally produced the same element %s twice\", t));\n-      }\n-      seenTees.add(t);\n-      return t;\n-    }\n-\n-    public void expectNextElement(ManualSubscriber<T> sub, T expected) throws InterruptedException {\n-      final T elem = sub.nextElement(String.format(\"timeout while awaiting %s\", expected));\n-      if (!elem.equals(expected)) {\n-        env.flop(String.format(\"Received `onNext(%s)` on downstream but expected `onNext(%s)`\", elem, expected));\n-      }\n-    }\n-\n-    public void expectNextElement(ManualSubscriber<T> sub, T expected, String errorMessageAddendum) throws InterruptedException {\n-      final T elem = sub.nextElement(String.format(\"timeout while awaiting %s. %s\", expected, errorMessageAddendum));\n-      if (!elem.equals(expected)) {\n-        env.flop(String.format(\"Received `onNext(%s)` on downstream but expected `onNext(%s)`\", elem, expected));\n-      }\n-    }\n-\n-    public T sendNextTFromUpstream() throws InterruptedException {\n-      final T x = nextT();\n-      sendNext(x);\n-      return x;\n-    }\n-  }\n-\n-  public class ManualSubscriberWithErrorCollection<A> extends ManualSubscriberWithSubscriptionSupport<A> {\n-    Promise<Throwable> error;\n-\n-    public ManualSubscriberWithErrorCollection(TestEnvironment env) {\n-      super(env);\n-      error = new Promise<Throwable>(env);\n-    }\n-\n-    @Override\n-    public void onError(Throwable cause) {\n-      error.complete(cause);\n-    }\n-\n-    public void expectError(Throwable cause) throws InterruptedException {\n-      expectError(cause, env.defaultTimeoutMillis());\n-    }\n-\n-    @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n-    public void expectError(Throwable cause, long timeoutMillis) throws InterruptedException {\n-      error.expectCompletion(timeoutMillis, \"Did not receive expected error on downstream\");\n-      if (!cause.equals(error.value())) {\n-        env.flop(String.format(\"Expected error %s but got %s\", cause, error.value()));\n-      }\n-    }\n-  }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/IdentityProcessorVerification.java","additions":0,"deletions":896,"binary":false,"changes":896,"status":"deleted"},{"patch":"@@ -1,1245 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck;\n-\n-import org.reactivestreams.Publisher;\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-import org.reactivestreams.tck.TestEnvironment.BlackholeSubscriberWithSubscriptionSupport;\n-import org.reactivestreams.tck.TestEnvironment.Latch;\n-import org.reactivestreams.tck.TestEnvironment.ManualSubscriber;\n-import org.reactivestreams.tck.TestEnvironment.ManualSubscriberWithSubscriptionSupport;\n-import org.reactivestreams.tck.flow.support.Function;\n-import org.reactivestreams.tck.flow.support.Optional;\n-import org.reactivestreams.tck.flow.support.PublisherVerificationRules;\n-import org.testng.SkipException;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n-\n-import java.lang.Override;\n-import java.lang.ref.ReferenceQueue;\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Random;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n-\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-\n-\/**\n- * Provides tests for verifying {@code Publisher} specification rules.\n- *\n- * @see org.reactivestreams.Publisher\n- *\/\n-public abstract class PublisherVerification<T> implements PublisherVerificationRules {\n-\n-  private static final String PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS_ENV = \"PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS\";\n-  private static final long DEFAULT_PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS = 300L;\n-\n-  private final TestEnvironment env;\n-\n-  \/**\n-   * The amount of time after which a cancelled Subscriber reference should be dropped.\n-   * See Rule 3.13 for details.\n-   *\/\n-  private final long publisherReferenceGCTimeoutMillis;\n-\n-  \/**\n-   * Constructs a new verification class using the given env and configuration.\n-   *\n-   * @param publisherReferenceGCTimeoutMillis used to determine after how much time a reference to a Subscriber should be already dropped by the Publisher.\n-   *\/\n-  public PublisherVerification(TestEnvironment env, long publisherReferenceGCTimeoutMillis) {\n-    this.env = env;\n-    this.publisherReferenceGCTimeoutMillis = publisherReferenceGCTimeoutMillis;\n-  }\n-\n-  \/**\n-   * Constructs a new verification class using the given env and configuration.\n-   *\n-   * The value for {@code publisherReferenceGCTimeoutMillis} will be obtained by using {@link PublisherVerification#envPublisherReferenceGCTimeoutMillis()}.\n-   *\/\n-  public PublisherVerification(TestEnvironment env) {\n-    this.env = env;\n-    this.publisherReferenceGCTimeoutMillis = envPublisherReferenceGCTimeoutMillis();\n-  }\n-\n-  \/**\n-   * Tries to parse the env variable {@code PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS} as long and returns the value if present,\n-   * OR its default value ({@link PublisherVerification#DEFAULT_PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS}).\n-   *\n-   * This value is used to determine after how much time a reference to a Subscriber should be already dropped by the Publisher.\n-   *\n-   * @throws java.lang.IllegalArgumentException when unable to parse the env variable\n-   *\/\n-  public static long envPublisherReferenceGCTimeoutMillis() {\n-    final String envMillis = System.getenv(PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS_ENV);\n-    if (envMillis == null) return DEFAULT_PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS;\n-    else try {\n-      return Long.parseLong(envMillis);\n-    } catch (NumberFormatException ex) {\n-      throw new IllegalArgumentException(String.format(\"Unable to parse %s env value [%s] as long!\", PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS_ENV, envMillis), ex);\n-    }\n-  }\n-\n-  \/**\n-   * This is the main method you must implement in your test incarnation.\n-   * It must create a Publisher for a stream with exactly the given number of elements.\n-   * If `elements` is `Long.MAX_VALUE` the produced stream must be infinite.\n-   *\/\n-  public abstract Publisher<T> createPublisher(long elements);\n-\n-  \/**\n-   * By implementing this method, additional TCK tests concerning a \"failed\" publishers will be run.\n-   *\n-   * The expected behaviour of the {@link Publisher} returned by this method is hand out a subscription,\n-   * followed by signalling {@code onError} on it, as specified by Rule 1.9.\n-   *\n-   * If you ignore these additional tests, return {@code null} from this method.\n-   *\/\n-  public abstract Publisher<T> createFailedPublisher();\n-\n-\n-  \/**\n-   * Override and return lower value if your Publisher is only able to produce a known number of elements.\n-   * For example, if it is designed to return at-most-one element, return {@code 1} from this method.\n-   *\n-   * Defaults to {@code Long.MAX_VALUE - 1}, meaning that the Publisher can be produce a huge but NOT an unbounded number of elements.\n-   *\n-   * To mark your Publisher will *never* signal an {@code onComplete} override this method and return {@code Long.MAX_VALUE},\n-   * which will result in *skipping all tests which require an onComplete to be triggered* (!).\n-   *\/\n-  public long maxElementsFromPublisher() {\n-    return Long.MAX_VALUE - 1;\n-  }\n-\n-  \/**\n-   * Override and return {@code true} in order to skip executing tests marked as {@code Stochastic}.\n-   * Stochastic in this case means that the Rule is impossible or infeasible to deterministically verify—\n-   * usually this means that this test case can yield false positives (\"be green\") even if for some case,\n-   * the given implementation may violate the tested behaviour.\n-   *\/\n-  public boolean skipStochasticTests() {\n-    return false;\n-  }\n-\n-  \/**\n-   * In order to verify rule 3.3 of the reactive streams spec, this number will be used to check if a\n-   * {@code Subscription} actually solves the \"unbounded recursion\" problem by not allowing the number of\n-   * recursive calls to exceed the number returned by this method.\n-   *\n-   * @see <a href=\"https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.3\">reactive streams spec, rule 3.3<\/a>\n-   * @see PublisherVerification#required_spec303_mustNotAllowUnboundedRecursion()\n-   *\/\n-  public long boundedDepthOfOnNextAndRequestRecursion() {\n-    return 1;\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ TEST ENV CLEANUP \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  @BeforeMethod\n-  public void setUp() throws Exception {\n-    env.clearAsyncErrors();\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ TEST SETUP VERIFICATION \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  @Override @Test\n-  public void required_createPublisher1MustProduceAStreamOfExactly1Element() throws Throwable {\n-    activePublisherTest(1, true, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws InterruptedException {\n-        ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        assertTrue(requestNextElementOrEndOfStream(pub, sub).isDefined(), String.format(\"Publisher %s produced no elements\", pub));\n-        sub.requestEndOfStream();\n-      }\n-\n-      Optional<T> requestNextElementOrEndOfStream(Publisher<T> pub, ManualSubscriber<T> sub) throws InterruptedException {\n-        return sub.requestNextElementOrEndOfStream(String.format(\"Timeout while waiting for next element from Publisher %s\", pub));\n-      }\n-\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_createPublisher3MustProduceAStreamOfExactly3Elements() throws Throwable {\n-    activePublisherTest(3, true, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws InterruptedException {\n-        ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        assertTrue(requestNextElementOrEndOfStream(pub, sub).isDefined(), String.format(\"Publisher %s produced no elements\", pub));\n-        assertTrue(requestNextElementOrEndOfStream(pub, sub).isDefined(), String.format(\"Publisher %s produced only 1 element\", pub));\n-        assertTrue(requestNextElementOrEndOfStream(pub, sub).isDefined(), String.format(\"Publisher %s produced only 2 elements\", pub));\n-        sub.requestEndOfStream();\n-      }\n-\n-      Optional<T> requestNextElementOrEndOfStream(Publisher<T> pub, ManualSubscriber<T> sub) throws InterruptedException {\n-        return sub.requestNextElementOrEndOfStream(String.format(\"Timeout while waiting for next element from Publisher %s\", pub));\n-      }\n-\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_validate_maxElementsFromPublisher() throws Exception {\n-    assertTrue(maxElementsFromPublisher() >= 0, \"maxElementsFromPublisher MUST return a number >= 0\");\n-  }\n-\n-  @Override @Test\n-  public void required_validate_boundedDepthOfOnNextAndRequestRecursion() throws Exception {\n-    assertTrue(boundedDepthOfOnNextAndRequestRecursion() >= 1, \"boundedDepthOfOnNextAndRequestRecursion must return a number >= 1\");\n-  }\n-\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ SPEC RULE VERIFICATION \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  @Override @Test\n-  public void required_spec101_subscriptionRequestMustResultInTheCorrectNumberOfProducedElements() throws Throwable {\n-    activePublisherTest(5, false, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws InterruptedException {\n-\n-        ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        try {\n-            sub.expectNone(String.format(\"Publisher %s produced value before the first `request`: \", pub));\n-            sub.request(1);\n-            sub.nextElement(String.format(\"Publisher %s produced no element after first `request`\", pub));\n-            sub.expectNone(String.format(\"Publisher %s produced unrequested: \", pub));\n-\n-            sub.request(1);\n-            sub.request(2);\n-            sub.nextElements(3, env.defaultTimeoutMillis(), String.format(\"Publisher %s produced less than 3 elements after two respective `request` calls\", pub));\n-\n-            sub.expectNone(String.format(\"Publisher %sproduced unrequested \", pub));\n-        } finally {\n-            sub.cancel();\n-        }\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec102_maySignalLessThanRequestedAndTerminateSubscription() throws Throwable {\n-    final int elements = 3;\n-    final int requested = 10;\n-\n-    activePublisherTest(elements, true, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        final ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        sub.request(requested);\n-        sub.nextElements(elements);\n-        sub.expectCompletion();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void stochastic_spec103_mustSignalOnMethodsSequentially() throws Throwable {\n-    final int iterations = 100;\n-    final int elements = 10;\n-\n-    stochasticTest(iterations, new Function<Integer, Void>() {\n-      @Override\n-      public Void apply(final Integer runNumber) throws Throwable {\n-        activePublisherTest(elements, true, new PublisherTestRun<T>() {\n-          @Override\n-          public void run(Publisher<T> pub) throws Throwable {\n-            final Latch completionLatch = new Latch(env);\n-\n-            final AtomicInteger gotElements = new AtomicInteger(0);\n-            pub.subscribe(new Subscriber<T>() {\n-              private Subscription subs;\n-\n-              private ConcurrentAccessBarrier concurrentAccessBarrier = new ConcurrentAccessBarrier();\n-\n-              \/**\n-               * Concept wise very similar to a {@link org.reactivestreams.tck.TestEnvironment.Latch}, serves to protect\n-               * a critical section from concurrent access, with the added benefit of Thread tracking and same-thread-access awareness.\n-               *\n-               * Since a <i>Synchronous<\/i> Publisher may choose to synchronously (using the same {@link Thread}) call\n-               * {@code onNext} directly from either {@code subscribe} or {@code request} a plain Latch is not enough\n-               * to verify concurrent access safety - one needs to track if the caller is not still using the calling thread\n-               * to enter subsequent critical sections (\"nesting\" them effectively).\n-               *\/\n-              final class ConcurrentAccessBarrier {\n-                private AtomicReference<Thread> currentlySignallingThread = new AtomicReference<Thread>(null);\n-                private volatile String previousSignal = null;\n-\n-                public void enterSignal(String signalName) {\n-                  if((!currentlySignallingThread.compareAndSet(null, Thread.currentThread())) && !isSynchronousSignal()) {\n-                    env.flop(String.format(\n-                      \"Illegal concurrent access detected (entering critical section)! \" +\n-                        \"%s emited %s signal, before %s finished its %s signal.\",\n-                        Thread.currentThread(), signalName, currentlySignallingThread.get(), previousSignal));\n-                  }\n-                  this.previousSignal = signalName;\n-                }\n-\n-                public void leaveSignal(String signalName) {\n-                  currentlySignallingThread.set(null);\n-                  this.previousSignal = signalName;\n-                }\n-\n-                private boolean isSynchronousSignal() {\n-                  return (previousSignal != null) && Thread.currentThread().equals(currentlySignallingThread.get());\n-                }\n-\n-              }\n-\n-              @Override\n-              public void onSubscribe(Subscription s) {\n-                final String signal = \"onSubscribe()\";\n-                concurrentAccessBarrier.enterSignal(signal);\n-\n-                subs = s;\n-                subs.request(1);\n-\n-                concurrentAccessBarrier.leaveSignal(signal);\n-              }\n-\n-              @Override\n-              public void onNext(T ignore) {\n-                final String signal = String.format(\"onNext(%s)\", ignore);\n-                concurrentAccessBarrier.enterSignal(signal);\n-\n-                if (gotElements.incrementAndGet() <= elements) \/\/ requesting one more than we know are in the stream (some Publishers need this)\n-                  subs.request(1);\n-\n-                concurrentAccessBarrier.leaveSignal(signal);\n-              }\n-\n-              @Override\n-              public void onError(Throwable t) {\n-                final String signal = String.format(\"onError(%s)\", t.getMessage());\n-                concurrentAccessBarrier.enterSignal(signal);\n-\n-                \/\/ ignore value\n-\n-                concurrentAccessBarrier.leaveSignal(signal);\n-              }\n-\n-              @Override\n-              public void onComplete() {\n-                final String signal = \"onComplete()\";\n-                concurrentAccessBarrier.enterSignal(signal);\n-\n-                \/\/ entering for completeness\n-\n-                concurrentAccessBarrier.leaveSignal(signal);\n-                completionLatch.close();\n-              }\n-            });\n-\n-            completionLatch.expectClose(\n-              elements * env.defaultTimeoutMillis(),\n-              String.format(\"Failed in iteration %d of %d. Expected completion signal after signalling %d elements (signalled %d), yet did not receive it\",\n-                            runNumber, iterations, elements, gotElements.get()));\n-          }\n-        });\n-        return null;\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void optional_spec104_mustSignalOnErrorWhenFails() throws Throwable {\n-    try {\n-      whenHasErrorPublisherTest(new PublisherTestRun<T>() {\n-        @Override\n-        public void run(final Publisher<T> pub) throws InterruptedException {\n-          final Latch onErrorlatch = new Latch(env);\n-          final Latch onSubscribeLatch = new Latch(env);\n-          pub.subscribe(new TestEnvironment.TestSubscriber<T>(env) {\n-            @Override\n-            public void onSubscribe(Subscription subs) {\n-              onSubscribeLatch.assertOpen(\"Only one onSubscribe call expected\");\n-              onSubscribeLatch.close();\n-            }\n-            @Override\n-            public void onError(Throwable cause) {\n-              onSubscribeLatch.assertClosed(\"onSubscribe should be called prior to onError always\");\n-              onErrorlatch.assertOpen(String.format(\"Error-state Publisher %s called `onError` twice on new Subscriber\", pub));\n-              onErrorlatch.close();\n-            }\n-          });\n-\n-          onSubscribeLatch.expectClose(\"Should have received onSubscribe\");\n-          onErrorlatch.expectClose(String.format(\"Error-state Publisher %s did not call `onError` on new Subscriber\", pub));\n-\n-          env.verifyNoAsyncErrors();\n-          }\n-      });\n-    } catch (SkipException se) {\n-      throw se;\n-    } catch (Throwable ex) {\n-      \/\/ we also want to catch AssertionErrors and anything the publisher may have thrown inside subscribe\n-      \/\/ which was wrong of him - he should have signalled on error using onError\n-      throw new RuntimeException(String.format(\"Publisher threw exception (%s) instead of signalling error via onError!\", ex.getMessage()), ex);\n-    }\n-  }\n-\n-  @Override @Test\n-  public void required_spec105_mustSignalOnCompleteWhenFiniteStreamTerminates() throws Throwable {\n-    activePublisherTest(3, true, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        sub.requestNextElement();\n-        sub.requestNextElement();\n-        sub.requestNextElement();\n-        sub.requestEndOfStream();\n-        sub.expectNone();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void optional_spec105_emptyStreamMustTerminateBySignallingOnComplete() throws Throwable {\n-    optionalActivePublisherTest(0, true, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        sub.request(1);\n-        sub.expectCompletion();\n-        sub.expectNone();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void untested_spec106_mustConsiderSubscriptionCancelledAfterOnErrorOrOnCompleteHasBeenCalled() throws Throwable {\n-    notVerified(); \/\/ not really testable without more control over the Publisher\n-  }\n-\n-  @Override @Test\n-  public void required_spec107_mustNotEmitFurtherSignalsOnceOnCompleteHasBeenSignalled() throws Throwable {\n-    activePublisherTest(1, true, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        sub.request(10);\n-        sub.nextElement();\n-        sub.expectCompletion();\n-\n-        sub.request(10);\n-        sub.expectNone();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void untested_spec107_mustNotEmitFurtherSignalsOnceOnErrorHasBeenSignalled() throws Throwable {\n-    notVerified(); \/\/ can we meaningfully test this, without more control over the publisher?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec108_possiblyCanceledSubscriptionShouldNotReceiveOnErrorOrOnCompleteSignals() throws Throwable {\n-    notVerified(); \/\/ can we meaningfully test this?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec109_subscribeShouldNotThrowNonFatalThrowable() throws Throwable {\n-    notVerified(); \/\/ can we meaningfully test this?\n-  }\n-\n-  @Override @Test\n-  public void required_spec109_subscribeThrowNPEOnNullSubscriber() throws Throwable {\n-    activePublisherTest(0, false, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        try {\n-            pub.subscribe(null);\n-            env.flop(\"Publisher did not throw a NullPointerException when given a null Subscribe in subscribe\");\n-        } catch (NullPointerException ignored) {\n-          \/\/ valid behaviour\n-        }\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec109_mustIssueOnSubscribeForNonNullSubscriber() throws Throwable {\n-    activePublisherTest(0, false, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        final Latch onSubscribeLatch = new Latch(env);\n-        final AtomicReference<Subscription> cancel = new AtomicReference<Subscription>();\n-        try {\n-          pub.subscribe(new Subscriber<T>() {\n-            @Override\n-            public void onError(Throwable cause) {\n-              onSubscribeLatch.assertClosed(\"onSubscribe should be called prior to onError always\");\n-            }\n-\n-            @Override\n-            public void onSubscribe(Subscription subs) {\n-              cancel.set(subs);\n-              onSubscribeLatch.assertOpen(\"Only one onSubscribe call expected\");\n-              onSubscribeLatch.close();\n-            }\n-\n-            @Override\n-            public void onNext(T elem) {\n-              onSubscribeLatch.assertClosed(\"onSubscribe should be called prior to onNext always\");\n-            }\n-\n-            @Override\n-            public void onComplete() {\n-              onSubscribeLatch.assertClosed(\"onSubscribe should be called prior to onComplete always\");\n-            }\n-          });\n-          onSubscribeLatch.expectClose(\"Should have received onSubscribe\");\n-          env.verifyNoAsyncErrorsNoDelay();\n-        } finally {\n-          Subscription s = cancel.getAndSet(null);\n-          if (s != null) {\n-            s.cancel();\n-          }\n-        }\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec109_mayRejectCallsToSubscribeIfPublisherIsUnableOrUnwillingToServeThemRejectionMustTriggerOnErrorAfterOnSubscribe() throws Throwable {\n-    whenHasErrorPublisherTest(new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        final Latch onErrorLatch = new Latch(env);\n-        final Latch onSubscribeLatch = new Latch(env);\n-        ManualSubscriberWithSubscriptionSupport<T> sub = new ManualSubscriberWithSubscriptionSupport<T>(env) {\n-          @Override\n-          public void onError(Throwable cause) {\n-            onSubscribeLatch.assertClosed(\"onSubscribe should be called prior to onError always\");\n-            onErrorLatch.assertOpen(\"Only one onError call expected\");\n-            onErrorLatch.close();\n-          }\n-\n-          @Override\n-          public void onSubscribe(Subscription subs) {\n-            onSubscribeLatch.assertOpen(\"Only one onSubscribe call expected\");\n-            onSubscribeLatch.close();\n-          }\n-        };\n-        pub.subscribe(sub);\n-        onSubscribeLatch.expectClose(\"Should have received onSubscribe\");\n-        onErrorLatch.expectClose(\"Should have received onError\");\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void untested_spec110_rejectASubscriptionRequestIfTheSameSubscriberSubscribesTwice() throws Throwable {\n-    notVerified(); \/\/ can we meaningfully test this?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.11\n-  @Override @Test\n-  public void optional_spec111_maySupportMultiSubscribe() throws Throwable {\n-    optionalActivePublisherTest(1, false, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        ManualSubscriber<T> sub1 = env.newManualSubscriber(pub);\n-        ManualSubscriber<T> sub2 = env.newManualSubscriber(pub);\n-\n-        try {\n-          env.verifyNoAsyncErrors();\n-        } finally {\n-          try {\n-            sub1.cancel();\n-          } finally {\n-            sub2.cancel();\n-          }\n-        }\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void optional_spec111_registeredSubscribersMustReceiveOnNextOrOnCompleteSignals() throws Throwable {\n-    optionalActivePublisherTest(1, false, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        ManualSubscriber<T> sub1 = env.newManualSubscriber(pub);\n-        ManualSubscriber<T> sub2 = env.newManualSubscriber(pub);\n-        \/\/ Since we're testing the case when the Publisher DOES support the optional multi-subscribers scenario,\n-        \/\/ and decides if it handles them uni-cast or multi-cast, we don't know which subscriber will receive an\n-        \/\/ onNext (and optional onComplete) signal(s) and which just onComplete signal.\n-        \/\/ Plus, even if subscription assumed to be unicast, it's implementation choice, which one will be signalled\n-        \/\/ with onNext.\n-        sub1.requestNextElementOrEndOfStream();\n-        sub2.requestNextElementOrEndOfStream();\n-        try {\n-            env.verifyNoAsyncErrors();\n-        } finally {\n-            try {\n-                sub1.cancel();\n-            } finally {\n-                sub2.cancel();\n-            }\n-        }\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingOneByOne() throws Throwable {\n-    optionalActivePublisherTest(5, true, new PublisherTestRun<T>() { \/\/ This test is skipped if the publisher is unbounded (never sends onComplete)\n-      @Override\n-      public void run(Publisher<T> pub) throws InterruptedException {\n-        ManualSubscriber<T> sub1 = env.newManualSubscriber(pub);\n-        ManualSubscriber<T> sub2 = env.newManualSubscriber(pub);\n-        ManualSubscriber<T> sub3 = env.newManualSubscriber(pub);\n-\n-        sub1.request(1);\n-        T x1 = sub1.nextElement(String.format(\"Publisher %s did not produce the requested 1 element on 1st subscriber\", pub));\n-        sub2.request(2);\n-        List<T> y1 = sub2.nextElements(2, String.format(\"Publisher %s did not produce the requested 2 elements on 2nd subscriber\", pub));\n-        sub1.request(1);\n-        T x2 = sub1.nextElement(String.format(\"Publisher %s did not produce the requested 1 element on 1st subscriber\", pub));\n-        sub3.request(3);\n-        List<T> z1 = sub3.nextElements(3, String.format(\"Publisher %s did not produce the requested 3 elements on 3rd subscriber\", pub));\n-        sub3.request(1);\n-        T z2 = sub3.nextElement(String.format(\"Publisher %s did not produce the requested 1 element on 3rd subscriber\", pub));\n-        sub3.request(1);\n-        T z3 = sub3.nextElement(String.format(\"Publisher %s did not produce the requested 1 element on 3rd subscriber\", pub));\n-        sub3.requestEndOfStream(String.format(\"Publisher %s did not complete the stream as expected on 3rd subscriber\", pub));\n-        sub2.request(3);\n-        List<T> y2 = sub2.nextElements(3, String.format(\"Publisher %s did not produce the requested 3 elements on 2nd subscriber\", pub));\n-        sub2.requestEndOfStream(String.format(\"Publisher %s did not complete the stream as expected on 2nd subscriber\", pub));\n-        sub1.request(2);\n-        List<T> x3 = sub1.nextElements(2, String.format(\"Publisher %s did not produce the requested 2 elements on 1st subscriber\", pub));\n-        sub1.request(1);\n-        T x4 = sub1.nextElement(String.format(\"Publisher %s did not produce the requested 1 element on 1st subscriber\", pub));\n-        sub1.requestEndOfStream(String.format(\"Publisher %s did not complete the stream as expected on 1st subscriber\", pub));\n-\n-        @SuppressWarnings(\"unchecked\")\n-        List<T> r = new ArrayList<T>(Arrays.asList(x1, x2));\n-        r.addAll(x3);\n-        r.addAll(Collections.singleton(x4));\n-\n-        List<T> check1 = new ArrayList<T>(y1);\n-        check1.addAll(y2);\n-\n-        \/\/noinspection unchecked\n-        List<T> check2 = new ArrayList<T>(z1);\n-        check2.add(z2);\n-        check2.add(z3);\n-\n-        assertEquals(r, check1, String.format(\"Publisher %s did not produce the same element sequence for subscribers 1 and 2\", pub));\n-        assertEquals(r, check2, String.format(\"Publisher %s did not produce the same element sequence for subscribers 1 and 3\", pub));\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfront() throws Throwable {\n-    optionalActivePublisherTest(3, false, new PublisherTestRun<T>() { \/\/ This test is skipped if the publisher cannot produce enough elements\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        ManualSubscriber<T> sub1 = env.newManualSubscriber(pub);\n-        ManualSubscriber<T> sub2 = env.newManualSubscriber(pub);\n-        ManualSubscriber<T> sub3 = env.newManualSubscriber(pub);\n-\n-        List<T> received1 = new ArrayList<T>();\n-        List<T> received2 = new ArrayList<T>();\n-        List<T> received3 = new ArrayList<T>();\n-\n-        \/\/ if the publisher must touch it's source to notice it's been drained, the OnComplete won't come until we ask for more than it actually contains...\n-        \/\/ edgy edge case?\n-        sub1.request(4);\n-        sub2.request(4);\n-        sub3.request(4);\n-\n-        received1.addAll(sub1.nextElements(3));\n-        received2.addAll(sub2.nextElements(3));\n-        received3.addAll(sub3.nextElements(3));\n-\n-        \/\/ NOTE: can't check completion, the Publisher may not be able to signal it\n-        \/\/       a similar test *with* completion checking is implemented\n-\n-        assertEquals(received1, received2, String.format(\"Expected elements to be signaled in the same sequence to 1st and 2nd subscribers\"));\n-        assertEquals(received2, received3, String.format(\"Expected elements to be signaled in the same sequence to 2nd and 3rd subscribers\"));\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfrontAndCompleteAsExpected() throws Throwable {\n-    optionalActivePublisherTest(3, true, new PublisherTestRun<T>() { \/\/ This test is skipped if the publisher is unbounded (never sends onComplete)\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        ManualSubscriber<T> sub1 = env.newManualSubscriber(pub);\n-        ManualSubscriber<T> sub2 = env.newManualSubscriber(pub);\n-        ManualSubscriber<T> sub3 = env.newManualSubscriber(pub);\n-\n-        List<T> received1 = new ArrayList<T>();\n-        List<T> received2 = new ArrayList<T>();\n-        List<T> received3 = new ArrayList<T>();\n-\n-        \/\/ if the publisher must touch it's source to notice it's been drained, the OnComplete won't come until we ask for more than it actually contains...\n-        \/\/ edgy edge case?\n-        sub1.request(4);\n-        sub2.request(4);\n-        sub3.request(4);\n-\n-        received1.addAll(sub1.nextElements(3));\n-        received2.addAll(sub2.nextElements(3));\n-        received3.addAll(sub3.nextElements(3));\n-\n-        sub1.expectCompletion();\n-        sub2.expectCompletion();\n-        sub3.expectCompletion();\n-\n-        assertEquals(received1, received2, String.format(\"Expected elements to be signaled in the same sequence to 1st and 2nd subscribers\"));\n-        assertEquals(received2, received3, String.format(\"Expected elements to be signaled in the same sequence to 2nd and 3rd subscribers\"));\n-      }\n-    });\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ SUBSCRIPTION TESTS \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  @Override @Test\n-  public void required_spec302_mustAllowSynchronousRequestCallsFromOnNextAndOnSubscribe() throws Throwable {\n-    activePublisherTest(6, false, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        ManualSubscriber<T> sub = new ManualSubscriber<T>(env) {\n-          @Override\n-          public void onSubscribe(Subscription subs) {\n-            this.subscription.completeImmediatly(subs);\n-\n-            subs.request(1);\n-            subs.request(1);\n-            subs.request(1);\n-          }\n-\n-          @Override\n-          public void onNext(T element) {\n-            Subscription subs = this.subscription.value();\n-            subs.request(1);\n-          }\n-        };\n-\n-        env.subscribe(pub, sub);\n-\n-        env.verifyNoAsyncErrors();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec303_mustNotAllowUnboundedRecursion() throws Throwable {\n-    final long oneMoreThanBoundedLimit = boundedDepthOfOnNextAndRequestRecursion() + 1;\n-\n-    activePublisherTest(oneMoreThanBoundedLimit, false, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        final ThreadLocal<Long> stackDepthCounter = new ThreadLocal<Long>() {\n-          @Override\n-          protected Long initialValue() {\n-            return 0L;\n-          }\n-        };\n-\n-        final Latch runCompleted = new Latch(env);\n-\n-        final ManualSubscriber<T> sub = new ManualSubscriberWithSubscriptionSupport<T>(env) {\n-          \/\/ counts the number of signals received, used to break out from possibly infinite request\/onNext loops\n-          long signalsReceived = 0L;\n-\n-          @Override\n-          public void onNext(T element) {\n-            \/\/ NOT calling super.onNext as this test only cares about stack depths, not the actual values of elements\n-            \/\/ which also simplifies this test as we do not have to drain the test buffer, which would otherwise be in danger of overflowing\n-\n-            signalsReceived += 1;\n-            stackDepthCounter.set(stackDepthCounter.get() + 1);\n-            if (env.debugEnabled()) {\n-              env.debug(String.format(\"%s(recursion depth: %d)::onNext(%s)\", this, stackDepthCounter.get(), element));\n-            }\n-\n-            final long callsUntilNow = stackDepthCounter.get();\n-            if (callsUntilNow > boundedDepthOfOnNextAndRequestRecursion()) {\n-              env.flop(String.format(\"Got %d onNext calls within thread: %s, yet expected recursive bound was %d\",\n-                                     callsUntilNow, Thread.currentThread(), boundedDepthOfOnNextAndRequestRecursion()));\n-\n-              \/\/ stop the recursive call chain\n-              runCompleted.close();\n-              return;\n-            } else if (signalsReceived >= oneMoreThanBoundedLimit) {\n-              \/\/ since max number of signals reached, and recursion depth not exceeded, we judge this as a success and\n-              \/\/ stop the recursive call chain\n-              runCompleted.close();\n-              return;\n-            }\n-\n-            \/\/ request more right away, the Publisher must break the recursion\n-            subscription.value().request(1);\n-\n-            stackDepthCounter.set(stackDepthCounter.get() - 1);\n-          }\n-\n-          @Override\n-          public void onComplete() {\n-            super.onComplete();\n-            runCompleted.close();\n-          }\n-\n-          @Override\n-          public void onError(Throwable cause) {\n-            super.onError(cause);\n-            runCompleted.close();\n-          }\n-        };\n-\n-        try {\n-          env.subscribe(pub, sub);\n-\n-          sub.request(1); \/\/ kick-off the `request -> onNext -> request -> onNext -> ...`\n-\n-          final String msg = String.format(\"Unable to validate call stack depth safety, \" +\n-                                               \"awaited at-most %s signals (`maxOnNextSignalsInRecursionTest()`) or completion\",\n-                                           oneMoreThanBoundedLimit);\n-          runCompleted.expectClose(env.defaultTimeoutMillis(), msg);\n-          env.verifyNoAsyncErrorsNoDelay();\n-        } finally {\n-          \/\/ since the request\/onNext recursive calls may keep the publisher running \"forever\",\n-          \/\/ we MUST cancel it manually before exiting this test case\n-          sub.cancel();\n-        }\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void untested_spec304_requestShouldNotPerformHeavyComputations() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec305_cancelMustNotSynchronouslyPerformHeavyComputation() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  @Override @Test\n-  public void required_spec306_afterSubscriptionIsCancelledRequestMustBeNops() throws Throwable {\n-    activePublisherTest(3, false, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-\n-        \/\/ override ManualSubscriberWithSubscriptionSupport#cancel because by default a ManualSubscriber will drop the\n-        \/\/ subscription once it's cancelled (as expected).\n-        \/\/ In this test however it must keep the cancelled Subscription and keep issuing `request(long)` to it.\n-        ManualSubscriber<T> sub = new ManualSubscriberWithSubscriptionSupport<T>(env) {\n-          @Override\n-          public void cancel() {\n-            if (subscription.isCompleted()) {\n-              subscription.value().cancel();\n-            } else {\n-              env.flop(\"Cannot cancel a subscription before having received it\");\n-            }\n-          }\n-        };\n-\n-        env.subscribe(pub, sub);\n-\n-        sub.cancel();\n-        sub.request(1);\n-        sub.request(1);\n-        sub.request(1);\n-\n-        sub.expectNone();\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec307_afterSubscriptionIsCancelledAdditionalCancelationsMustBeNops() throws Throwable {\n-    activePublisherTest(1, false, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        final ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-\n-        \/\/ leak the Subscription\n-        final Subscription subs = sub.subscription.value();\n-\n-        subs.cancel();\n-        subs.cancel();\n-        subs.cancel();\n-\n-        sub.expectNone();\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec309_requestZeroMustSignalIllegalArgumentException() throws Throwable {\n-    activePublisherTest(10, false, new PublisherTestRun<T>() {\n-      @Override public void run(Publisher<T> pub) throws Throwable {\n-        final ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        sub.request(0);\n-        sub.expectError(IllegalArgumentException.class);\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec309_requestNegativeNumberMustSignalIllegalArgumentException() throws Throwable {\n-    activePublisherTest(10, false, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        final ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        final Random r = new Random();\n-        sub.request(-r.nextInt(Integer.MAX_VALUE) - 1);\n-        \/\/ we do require implementations to mention the rule number at the very least, or mentioning that the non-negative request is the problem\n-        sub.expectError(IllegalArgumentException.class);\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void optional_spec309_requestNegativeNumberMaySignalIllegalArgumentExceptionWithSpecificMessage() throws Throwable {\n-    optionalActivePublisherTest(10, false, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        final ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        final Random r = new Random();\n-        sub.request(-r.nextInt(Integer.MAX_VALUE) - 1);\n-        \/\/ we do require implementations to mention the rule number at the very least, or mentioning that the non-negative request is the problem\n-        sub.expectErrorWithMessage(IllegalArgumentException.class, Arrays.asList(\"3.9\", \"non-positive subscription request\", \"negative subscription request\"));\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec312_cancelMustMakeThePublisherToEventuallyStopSignaling() throws Throwable {\n-    \/\/ the publisher is able to signal more elements than the subscriber will be requesting in total\n-    final int publisherElements = 20;\n-\n-    final int demand1 = 10;\n-    final int demand2 = 5;\n-    final int totalDemand = demand1 + demand2;\n-\n-    activePublisherTest(publisherElements, false, new PublisherTestRun<T>() {\n-      @Override @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n-      public void run(Publisher<T> pub) throws Throwable {\n-        final ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-\n-        sub.request(demand1);\n-        sub.request(demand2);\n-\n-        \/*\n-          NOTE: The order of the nextElement\/cancel calls below is very important (!)\n-\n-          If this ordering was reversed, given an asynchronous publisher,\n-          the following scenario would be *legal* and would break this test:\n-\n-          > AsyncPublisher receives request(10) - it does not emit data right away, it's asynchronous\n-          > AsyncPublisher receives request(5) - demand is now 15\n-          ! AsyncPublisher didn't emit any onNext yet (!)\n-          > AsyncPublisher receives cancel() - handles it right away, by \"stopping itself\" for example\n-          ! cancel was handled hefore the AsyncPublisher ever got the chance to emit data\n-          ! the subscriber ends up never receiving even one element - the test is stuck (and fails, even on valid Publisher)\n-\n-          Which is why we must first expect an element, and then cancel, once the producing is \"running\".\n-         *\/\n-        sub.nextElement();\n-        sub.cancel();\n-\n-        int onNextsSignalled = 1;\n-\n-        boolean stillBeingSignalled;\n-        do {\n-          \/\/ put asyncError if onNext signal received\n-          sub.expectNone();\n-          Throwable error = env.dropAsyncError();\n-\n-          if (error == null) {\n-            stillBeingSignalled = false;\n-          } else {\n-            onNextsSignalled += 1;\n-            stillBeingSignalled = true;\n-          }\n-\n-          \/\/ if the Publisher tries to emit more elements than was requested (and\/or ignores cancellation) this will throw\n-          assertTrue(onNextsSignalled <= totalDemand,\n-                     String.format(\"Publisher signalled [%d] elements, which is more than the signalled demand: %d\",\n-                                   onNextsSignalled, totalDemand));\n-\n-        } while (stillBeingSignalled);\n-      }\n-    });\n-\n-    env.verifyNoAsyncErrorsNoDelay();\n-  }\n-\n-  @Override @Test\n-  public void required_spec313_cancelMustMakeThePublisherEventuallyDropAllReferencesToTheSubscriber() throws Throwable {\n-    final ReferenceQueue<ManualSubscriber<T>> queue = new ReferenceQueue<ManualSubscriber<T>>();\n-\n-    final Function<Publisher<T>, WeakReference<ManualSubscriber<T>>> run = new Function<Publisher<T>, WeakReference<ManualSubscriber<T>>>() {\n-      @Override\n-      public WeakReference<ManualSubscriber<T>> apply(Publisher<T> pub) throws Exception {\n-        final ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        final WeakReference<ManualSubscriber<T>> ref = new WeakReference<ManualSubscriber<T>>(sub, queue);\n-\n-        sub.request(1);\n-        sub.nextElement();\n-        sub.cancel();\n-\n-        return ref;\n-      }\n-    };\n-\n-    activePublisherTest(3, false, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        final WeakReference<ManualSubscriber<T>> ref = run.apply(pub);\n-\n-        \/\/ cancel may be run asynchronously so we add a sleep before running the GC\n-        \/\/ to \"resolve\" the race\n-        Thread.sleep(publisherReferenceGCTimeoutMillis);\n-        System.gc();\n-\n-        if (!ref.equals(queue.remove(100))) {\n-          env.flop(String.format(\"Publisher %s did not drop reference to test subscriber after subscription cancellation\", pub));\n-        }\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec317_mustSupportAPendingElementCountUpToLongMaxValue() throws Throwable {\n-    final int totalElements = 3;\n-\n-    activePublisherTest(totalElements, true, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        sub.request(Long.MAX_VALUE);\n-\n-        sub.nextElements(totalElements);\n-        sub.expectCompletion();\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec317_mustSupportACumulativePendingElementCountUpToLongMaxValue() throws Throwable {\n-    final int totalElements = 3;\n-\n-    activePublisherTest(totalElements, true, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        final ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        sub.request(Long.MAX_VALUE \/ 2); \/\/ pending = Long.MAX_VALUE \/ 2\n-        sub.request(Long.MAX_VALUE \/ 2); \/\/ pending = Long.MAX_VALUE - 1\n-        sub.request(1); \/\/ pending = Long.MAX_VALUE\n-\n-        sub.nextElements(totalElements);\n-        sub.expectCompletion();\n-\n-        try {\n-          env.verifyNoAsyncErrorsNoDelay();\n-        } finally {\n-          sub.cancel();\n-        }\n-\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec317_mustNotSignalOnErrorWhenPendingAboveLongMaxValue() throws Throwable {\n-    activePublisherTest(Integer.MAX_VALUE, false, new PublisherTestRun<T>() {\n-      @Override public void run(Publisher<T> pub) throws Throwable {\n-        final ManualSubscriberWithSubscriptionSupport<T> sub = new BlackholeSubscriberWithSubscriptionSupport<T>(env) {\n-           \/\/ arbitrarily set limit on nuber of request calls signalled, we expect overflow after already 2 calls,\n-           \/\/ so 10 is relatively high and safe even if arbitrarily chosen\n-          int callsCounter = 10;\n-\n-          @Override\n-          public void onNext(T element) {\n-            if (env.debugEnabled()) {\n-              env.debug(String.format(\"%s::onNext(%s)\", this, element));\n-            }\n-            if (subscription.isCompleted()) {\n-              if (callsCounter > 0) {\n-                subscription.value().request(Long.MAX_VALUE - 1);\n-                callsCounter--;\n-              } else {\n-                  subscription.value().cancel();\n-              }\n-            } else {\n-              env.flop(String.format(\"Subscriber::onNext(%s) called before Subscriber::onSubscribe\", element));\n-            }\n-          }\n-        };\n-        env.subscribe(pub, sub, env.defaultTimeoutMillis());\n-\n-        \/\/ eventually triggers `onNext`, which will then trigger up to `callsCounter` times `request(Long.MAX_VALUE - 1)`\n-        \/\/ we're pretty sure to overflow from those\n-        sub.request(1);\n-\n-        \/\/ no onError should be signalled\n-        try {\n-          env.verifyNoAsyncErrors();\n-        } finally {\n-          sub.cancel();\n-        }\n-      }\n-    });\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ ADDITIONAL \"COROLLARY\" TESTS \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ TEST INFRASTRUCTURE \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  public interface PublisherTestRun<T> {\n-    public void run(Publisher<T> pub) throws Throwable;\n-  }\n-\n-  \/**\n-   * Test for feature that SHOULD\/MUST be implemented, using a live publisher.\n-   *\n-   * @param elements the number of elements the Publisher under test  must be able to emit to run this test\n-   * @param completionSignalRequired true if an {@code onComplete} signal is required by this test to run.\n-   *                                 If the tested Publisher is unable to signal completion, tests requireing onComplete signals will be skipped.\n-   *                                 To signal if your Publisher is able to signal completion see {@link PublisherVerification#maxElementsFromPublisher()}.\n-   *\/\n-  public void activePublisherTest(long elements, boolean completionSignalRequired, PublisherTestRun<T> body) throws Throwable {\n-    if (elements > maxElementsFromPublisher()) {\n-      throw new SkipException(String.format(\"Unable to run this test, as required elements nr: %d is higher than supported by given producer: %d\", elements, maxElementsFromPublisher()));\n-    } else if (completionSignalRequired && maxElementsFromPublisher() == Long.MAX_VALUE) {\n-      throw new SkipException(\"Unable to run this test, as it requires an onComplete signal, \" +\n-                                \"which this Publisher is unable to provide (as signalled by returning Long.MAX_VALUE from `maxElementsFromPublisher()`)\");\n-    } else {\n-      Publisher<T> pub = createPublisher(elements);\n-      body.run(pub);\n-      env.verifyNoAsyncErrorsNoDelay();\n-    }\n-  }\n-\n-  \/**\n-   * Test for feature that MAY be implemented. This test will be marked as SKIPPED if it fails.\n-   *\n-   * @param elements the number of elements the Publisher under test  must be able to emit to run this test\n-   * @param completionSignalRequired true if an {@code onComplete} signal is required by this test to run.\n-   *                                 If the tested Publisher is unable to signal completion, tests requireing onComplete signals will be skipped.\n-   *                                 To signal if your Publisher is able to signal completion see {@link PublisherVerification#maxElementsFromPublisher()}.\n-   *\/\n-  public void optionalActivePublisherTest(long elements, boolean completionSignalRequired, PublisherTestRun<T> body) throws Throwable {\n-    if (elements > maxElementsFromPublisher()) {\n-      throw new SkipException(String.format(\"Unable to run this test, as required elements nr: %d is higher than supported by given producer: %d\", elements, maxElementsFromPublisher()));\n-    } else if (completionSignalRequired && maxElementsFromPublisher() == Long.MAX_VALUE) {\n-      throw new SkipException(\"Unable to run this test, as it requires an onComplete signal, \" +\n-                                \"which this Publisher is unable to provide (as signalled by returning Long.MAX_VALUE from `maxElementsFromPublisher()`)\");\n-    } else {\n-\n-      final Publisher<T> pub = createPublisher(elements);\n-      final String skipMessage = \"Skipped because tested publisher does NOT implement this OPTIONAL requirement.\";\n-\n-      try {\n-        potentiallyPendingTest(pub, body);\n-      } catch (Exception ex) {\n-        notVerified(skipMessage);\n-      } catch (AssertionError ex) {\n-        notVerified(skipMessage + \" Reason for skipping was: \" + ex.getMessage());\n-      }\n-    }\n-  }\n-\n-  public static final String SKIPPING_NO_ERROR_PUBLISHER_AVAILABLE =\n-    \"Skipping because no error state Publisher provided, and the test requires it. \" +\n-          \"Please implement PublisherVerification#createFailedPublisher to run this test.\";\n-\n-  public static final String SKIPPING_OPTIONAL_TEST_FAILED =\n-    \"Skipping, because provided Publisher does not pass this *additional* verification.\";\n-  \/**\n-   * Additional test for Publisher in error state\n-   *\/\n-  public void whenHasErrorPublisherTest(PublisherTestRun<T> body) throws Throwable {\n-    potentiallyPendingTest(createFailedPublisher(), body, SKIPPING_NO_ERROR_PUBLISHER_AVAILABLE);\n-  }\n-\n-  public void potentiallyPendingTest(Publisher<T> pub, PublisherTestRun<T> body) throws Throwable {\n-    potentiallyPendingTest(pub, body, SKIPPING_OPTIONAL_TEST_FAILED);\n-  }\n-\n-  public void potentiallyPendingTest(Publisher<T> pub, PublisherTestRun<T> body, String message) throws Throwable {\n-    if (pub != null) {\n-      body.run(pub);\n-    } else {\n-      throw new SkipException(message);\n-    }\n-  }\n-\n-  \/**\n-   * Executes a given test body {@code n} times.\n-   * All the test runs must pass in order for the stochastic test to pass.\n-   *\/\n-  public void stochasticTest(int n, Function<Integer, Void> body) throws Throwable {\n-    if (skipStochasticTests()) {\n-      notVerified(\"Skipping @Stochastic test because `skipStochasticTests()` returned `true`!\");\n-    }\n-\n-    for (int i = 0; i < n; i++) {\n-      body.apply(i);\n-    }\n-  }\n-\n-  public void notVerified() {\n-    throw new SkipException(\"Not verified by this TCK.\");\n-  }\n-\n-  \/**\n-   * Return this value from {@link PublisherVerification#maxElementsFromPublisher()} to mark that the given {@link org.reactivestreams.Publisher},\n-   * is not able to signal completion. For example it is strictly a time-bound or unbounded source of data.\n-   *\n-   * <b>Returning this value from {@link PublisherVerification#maxElementsFromPublisher()} will result in skipping all TCK tests which require onComplete signals!<\/b>\n-   *\/\n-  public long publisherUnableToSignalOnComplete() {\n-    return Long.MAX_VALUE;\n-  }\n-\n-  public void notVerified(String message) {\n-    throw new SkipException(message);\n-  }\n-\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/PublisherVerification.java","additions":0,"deletions":1245,"binary":false,"changes":1245,"status":"deleted"},{"patch":"@@ -1,516 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck;\n-\n-import org.reactivestreams.Publisher;\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-import org.reactivestreams.tck.TestEnvironment.ManualPublisher;\n-import org.reactivestreams.tck.TestEnvironment.ManualSubscriber;\n-import org.reactivestreams.tck.flow.support.Optional;\n-import org.reactivestreams.tck.flow.support.SubscriberBlackboxVerificationRules;\n-import org.reactivestreams.tck.flow.support.TestException;\n-import org.testng.SkipException;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n-\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-\n-import static org.reactivestreams.tck.SubscriberWhiteboxVerification.BlackboxSubscriberProxy;\n-import static org.testng.Assert.assertTrue;\n-\n-\/**\n- * Provides tests for verifying {@link org.reactivestreams.Subscriber} and {@link org.reactivestreams.Subscription}\n- * specification rules, without any modifications to the tested implementation (also known as \"Black Box\" testing).\n- *\n- * This verification is NOT able to check many of the rules of the spec, and if you want more\n- * verification of your implementation you'll have to implement {@code org.reactivestreams.tck.SubscriberWhiteboxVerification}\n- * instead.\n- *\n- * @see org.reactivestreams.Subscriber\n- * @see org.reactivestreams.Subscription\n- *\/\n-public abstract class SubscriberBlackboxVerification<T> extends WithHelperPublisher<T>\n-  implements SubscriberBlackboxVerificationRules {\n-\n-  protected final TestEnvironment env;\n-\n-  protected SubscriberBlackboxVerification(TestEnvironment env) {\n-    this.env = env;\n-  }\n-\n-  \/\/ USER API\n-\n-  \/**\n-   * This is the main method you must implement in your test incarnation.\n-   * It must create a new {@link org.reactivestreams.Subscriber} instance to be subjected to the testing logic.\n-   *\/\n-  public abstract Subscriber<T> createSubscriber();\n-\n-  \/**\n-   * Override this method if the Subscriber implementation you are verifying\n-   * needs an external signal before it signals demand to its Publisher.\n-   *\n-   * By default this method does nothing.\n-   *\/\n-  public void triggerRequest(final Subscriber<? super T> subscriber) {\n-    \/\/ this method is intentionally left blank\n-  }\n-\n-  \/\/ ENV SETUP\n-\n-  \/**\n-   * Executor service used by the default provided asynchronous Publisher.\n-   * @see #createHelperPublisher(long)\n-   *\/\n-  private ExecutorService publisherExecutor;\n-  @BeforeClass public void startPublisherExecutorService() { publisherExecutor = Executors.newFixedThreadPool(4); }\n-  @AfterClass public void shutdownPublisherExecutorService() { if (publisherExecutor != null) publisherExecutor.shutdown(); }\n-  @Override public ExecutorService publisherExecutorService() { return publisherExecutor; }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ TEST ENV CLEANUP \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  @BeforeMethod\n-  public void setUp() throws Exception {\n-    env.clearAsyncErrors();\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ SPEC RULE VERIFICATION \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  @Override @Test\n-  public void required_spec201_blackbox_mustSignalDemandViaSubscriptionRequest() throws Throwable {\n-    blackboxSubscriberTest(new BlackboxTestStageTestRun() {\n-      @Override\n-      public void run(BlackboxTestStage stage) throws InterruptedException {\n-        triggerRequest(stage.subProxy().sub());\n-        final long requested = stage.expectRequest();\/\/ assuming subscriber wants to consume elements...\n-        final long signalsToEmit = Math.min(requested, 512); \/\/ protecting against Subscriber which sends ridiculous large demand\n-\n-        \/\/ should cope with up to requested number of elements\n-        for (int i = 0; i < signalsToEmit && sampleIsCancelled(stage, i, 10); i++)\n-          stage.signalNext();\n-\n-        \/\/ we complete after `signalsToEmit` (which can be less than `requested`),\n-        \/\/ which is legal under https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.2\n-        stage.sendCompletion();\n-      }\n-\n-      \/**\n-       * In order to allow some \"skid\" and not check state on each iteration,\n-       * only check {@code stage.isCancelled} every {@code checkInterval}'th iteration.\n-       *\/\n-      private boolean sampleIsCancelled(BlackboxTestStage stage, int i, int checkInterval) throws InterruptedException {\n-        if (i % checkInterval == 0) return stage.isCancelled();\n-        else return false;\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void untested_spec202_blackbox_shouldAsynchronouslyDispatch() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  @Override @Test\n-  public void required_spec203_blackbox_mustNotCallMethodsOnSubscriptionOrPublisherInOnComplete() throws Throwable {\n-    blackboxSubscriberWithoutSetupTest(new BlackboxTestStageTestRun() {\n-      @Override\n-      public void run(BlackboxTestStage stage) throws Throwable {\n-        final Subscription subs = new Subscription() {\n-          @Override\n-          public void request(long n) {\n-            final Optional<StackTraceElement> onCompleteStackTraceElement = env.findCallerMethodInStackTrace(\"onComplete\");\n-            if (onCompleteStackTraceElement.isDefined()) {\n-              final StackTraceElement stackElem = onCompleteStackTraceElement.get();\n-              env.flop(String.format(\"Subscription::request MUST NOT be called from Subscriber::onComplete (Rule 2.3)! (Caller: %s::%s line %d)\",\n-                                     stackElem.getClassName(), stackElem.getMethodName(), stackElem.getLineNumber()));\n-            }\n-          }\n-\n-          @Override\n-          public void cancel() {\n-            final Optional<StackTraceElement> onCompleteStackElement = env.findCallerMethodInStackTrace(\"onComplete\");\n-            if (onCompleteStackElement.isDefined()) {\n-              final StackTraceElement stackElem = onCompleteStackElement.get();\n-              env.flop(String.format(\"Subscription::cancel MUST NOT be called from Subscriber::onComplete (Rule 2.3)! (Caller: %s::%s line %d)\",\n-                                     stackElem.getClassName(), stackElem.getMethodName(), stackElem.getLineNumber()));\n-            }\n-          }\n-        };\n-\n-        final Subscriber<T> sub = createSubscriber();\n-        sub.onSubscribe(subs);\n-        sub.onComplete();\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec203_blackbox_mustNotCallMethodsOnSubscriptionOrPublisherInOnError() throws Throwable {\n-    blackboxSubscriberWithoutSetupTest(new BlackboxTestStageTestRun() {\n-      @Override\n-      public void run(BlackboxTestStage stage) throws Throwable {\n-        final Subscription subs = new Subscription() {\n-          @Override\n-          public void request(long n) {\n-            Throwable thr = new Throwable();\n-            for (StackTraceElement stackElem : thr.getStackTrace()) {\n-              if (stackElem.getMethodName().equals(\"onError\")) {\n-                env.flop(String.format(\"Subscription::request MUST NOT be called from Subscriber::onError (Rule 2.3)! (Caller: %s::%s line %d)\",\n-                                       stackElem.getClassName(), stackElem.getMethodName(), stackElem.getLineNumber()));\n-              }\n-            }\n-          }\n-\n-          @Override\n-          public void cancel() {\n-            Throwable thr = new Throwable();\n-            for (StackTraceElement stackElem : thr.getStackTrace()) {\n-              if (stackElem.getMethodName().equals(\"onError\")) {\n-                env.flop(String.format(\"Subscription::cancel MUST NOT be called from Subscriber::onError (Rule 2.3)! (Caller: %s::%s line %d)\",\n-                                       stackElem.getClassName(), stackElem.getMethodName(), stackElem.getLineNumber()));\n-              }\n-            }\n-          }\n-        };\n-\n-        final Subscriber<T> sub = createSubscriber();\n-        sub.onSubscribe(subs);\n-        sub.onError(new TestException());\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void untested_spec204_blackbox_mustConsiderTheSubscriptionAsCancelledInAfterRecievingOnCompleteOrOnError() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  @Override @Test\n-  public void required_spec205_blackbox_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal() throws Exception {\n-    new BlackboxTestStage(env) {{\n-      \/\/ try to subscribe another time, if the subscriber calls `probe.registerOnSubscribe` the test will fail\n-      final TestEnvironment.Latch secondSubscriptionCancelled = new TestEnvironment.Latch(env);\n-      sub().onSubscribe(\n-          new Subscription() {\n-            @Override\n-            public void request(long elements) {\n-              env.flop(String.format(\"Subscriber %s illegally called `subscription.request(%s)`!\", sub(), elements));\n-            }\n-\n-            @Override\n-            public void cancel() {\n-              secondSubscriptionCancelled.close();\n-            }\n-\n-            @Override\n-            public String toString() {\n-              return \"SecondSubscription(should get cancelled)\";\n-            }\n-          });\n-\n-      secondSubscriptionCancelled.expectClose(\"Expected SecondSubscription given to subscriber to be cancelled, but `Subscription.cancel()` was not called.\");\n-      env.verifyNoAsyncErrorsNoDelay();\n-      sendCompletion(); \/\/ we're done, complete the subscriber under test\n-    }};\n-  }\n-\n-  @Override @Test\n-  public void untested_spec206_blackbox_mustCallSubscriptionCancelIfItIsNoLongerValid() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec207_blackbox_mustEnsureAllCallsOnItsSubscriptionTakePlaceFromTheSameThreadOrTakeCareOfSynchronization() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-    \/\/ the same thread part of the clause can be verified but that is not very useful, or is it?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec208_blackbox_mustBePreparedToReceiveOnNextSignalsAfterHavingCalledSubscriptionCancel() throws Throwable {\n-    notVerified(); \/\/ cannot be meaningfully tested as black box, or can it?\n-  }\n-\n-  @Override @Test\n-  public void required_spec209_blackbox_mustBePreparedToReceiveAnOnCompleteSignalWithPrecedingRequestCall() throws Throwable {\n-    blackboxSubscriberTest(new BlackboxTestStageTestRun() {\n-      @Override @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n-      public void run(BlackboxTestStage stage) throws Throwable {\n-        triggerRequest(stage.subProxy().sub());\n-        final long notUsed = stage.expectRequest(); \/\/ received request signal\n-        stage.sub().onComplete();\n-        stage.subProxy().expectCompletion();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec209_blackbox_mustBePreparedToReceiveAnOnCompleteSignalWithoutPrecedingRequestCall() throws Throwable {\n-    blackboxSubscriberTest(new BlackboxTestStageTestRun() {\n-      @Override @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n-      public void run(BlackboxTestStage stage) throws Throwable {\n-        final Subscriber<? super T> sub = stage.sub();\n-        sub.onComplete();\n-        stage.subProxy().expectCompletion();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec210_blackbox_mustBePreparedToReceiveAnOnErrorSignalWithPrecedingRequestCall() throws Throwable {\n-    blackboxSubscriberTest(new BlackboxTestStageTestRun() {\n-      @Override @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n-      public void run(BlackboxTestStage stage) throws Throwable {\n-        triggerRequest(stage.subProxy().sub());\n-        final long notUsed = stage.expectRequest(); \/\/ received request signal\n-        stage.sub().onError(new TestException()); \/\/ in response to that, we fail\n-        stage.subProxy().expectError(Throwable.class);\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.10\n-  @Override @Test\n-  public void required_spec210_blackbox_mustBePreparedToReceiveAnOnErrorSignalWithoutPrecedingRequestCall() throws Throwable {\n-    blackboxSubscriberTest(new BlackboxTestStageTestRun() {\n-      @Override @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n-      public void run(BlackboxTestStage stage) throws Throwable {\n-\n-        stage.sub().onError(new TestException());\n-        stage.subProxy().expectError(Throwable.class);\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void untested_spec211_blackbox_mustMakeSureThatAllCallsOnItsMethodsHappenBeforeTheProcessingOfTheRespectiveEvents() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec212_blackbox_mustNotCallOnSubscribeMoreThanOnceBasedOnObjectEquality() throws Throwable {\n-    notVerified(); \/\/ cannot be meaningfully tested as black box, or can it?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec213_blackbox_failingOnSignalInvocation() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  @Override @Test\n-  public void required_spec213_blackbox_onSubscribe_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable {\n-    blackboxSubscriberWithoutSetupTest(new BlackboxTestStageTestRun() {\n-      @Override\n-      public void run(BlackboxTestStage stage) throws Throwable {\n-\n-        {\n-          final Subscriber<T> sub = createSubscriber();\n-          boolean gotNPE = false;\n-          try {\n-            sub.onSubscribe(null);\n-          } catch(final NullPointerException expected) {\n-            gotNPE = true;\n-          }\n-          assertTrue(gotNPE, \"onSubscribe(null) did not throw NullPointerException\");\n-        }\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec213_blackbox_onNext_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable {\n-    blackboxSubscriberWithoutSetupTest(new BlackboxTestStageTestRun() {\n-      @Override\n-      public void run(BlackboxTestStage stage) throws Throwable {\n-        final Subscription subscription = new Subscription() {\n-          @Override public void request(final long elements) {}\n-          @Override public void cancel() {}\n-        };\n-\n-        {\n-          final Subscriber<T> sub = createSubscriber();\n-          boolean gotNPE = false;\n-          sub.onSubscribe(subscription);\n-          try {\n-            sub.onNext(null);\n-          } catch(final NullPointerException expected) {\n-            gotNPE = true;\n-          }\n-          assertTrue(gotNPE, \"onNext(null) did not throw NullPointerException\");\n-        }\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec213_blackbox_onError_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable {\n-    blackboxSubscriberWithoutSetupTest(new BlackboxTestStageTestRun() {\n-      @Override\n-      public void run(BlackboxTestStage stage) throws Throwable {\n-        final Subscription subscription = new Subscription() {\n-          @Override public void request(final long elements) {}\n-          @Override public void cancel() {}\n-        };\n-\n-        {\n-          final Subscriber<T> sub = createSubscriber();\n-          boolean gotNPE = false;\n-          sub.onSubscribe(subscription);\n-          try {\n-            sub.onError(null);\n-          } catch(final NullPointerException expected) {\n-            gotNPE = true;\n-          }\n-          assertTrue(gotNPE, \"onError(null) did not throw NullPointerException\");\n-        }\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ SUBSCRIPTION SPEC RULE VERIFICATION \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  @Override @Test\n-  public void untested_spec301_blackbox_mustNotBeCalledOutsideSubscriberContext() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec308_blackbox_requestMustRegisterGivenNumberElementsToBeProduced() throws Throwable {\n-    notVerified(); \/\/ cannot be meaningfully tested as black box, or can it?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec310_blackbox_requestMaySynchronouslyCallOnNextOnSubscriber() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec311_blackbox_requestMaySynchronouslyCallOnCompleteOrOnError() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec314_blackbox_cancelMayCauseThePublisherToShutdownIfNoOtherSubscriptionExists() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec315_blackbox_cancelMustNotThrowExceptionAndMustSignalOnError() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec316_blackbox_requestMustNotThrowExceptionAndMustOnErrorTheSubscriber() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ ADDITIONAL \"COROLLARY\" TESTS \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ TEST INFRASTRUCTURE \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  abstract class BlackboxTestStageTestRun {\n-    public abstract void run(BlackboxTestStage stage) throws Throwable;\n-  }\n-\n-  public void blackboxSubscriberTest(BlackboxTestStageTestRun body) throws Throwable {\n-    BlackboxTestStage stage = new BlackboxTestStage(env, true);\n-    body.run(stage);\n-  }\n-\n-  public void blackboxSubscriberWithoutSetupTest(BlackboxTestStageTestRun body) throws Throwable {\n-    BlackboxTestStage stage = new BlackboxTestStage(env, false);\n-    body.run(stage);\n-  }\n-\n-  public class BlackboxTestStage extends ManualPublisher<T> {\n-    public Publisher<T> pub;\n-    public ManualSubscriber<T> tees; \/\/ gives us access to an infinite stream of T values\n-\n-    public T lastT = null;\n-    private Optional<BlackboxSubscriberProxy<T>> subProxy = Optional.empty();\n-\n-    public BlackboxTestStage(TestEnvironment env) throws InterruptedException {\n-      this(env, true);\n-    }\n-\n-    public BlackboxTestStage(TestEnvironment env, boolean runDefaultInit) throws InterruptedException {\n-      super(env);\n-      if (runDefaultInit) {\n-        pub = this.createHelperPublisher(Long.MAX_VALUE);\n-        tees = env.newManualSubscriber(pub);\n-        Subscriber<T> sub = createSubscriber();\n-        subProxy = Optional.of(createBlackboxSubscriberProxy(env, sub));\n-        subscribe(subProxy.get());\n-      }\n-    }\n-\n-    public Subscriber<? super T> sub() {\n-      return subscriber.value();\n-    }\n-\n-    \/**\n-     * Proxy for the {@link #sub()} {@code Subscriber}, providing certain assertions on methods being called on the Subscriber.\n-     *\/\n-    public BlackboxSubscriberProxy<T> subProxy() {\n-      return subProxy.get();\n-    }\n-\n-    public Publisher<T> createHelperPublisher(long elements) {\n-      return SubscriberBlackboxVerification.this.createHelperPublisher(elements);\n-    }\n-\n-    public BlackboxSubscriberProxy<T> createBlackboxSubscriberProxy(TestEnvironment env, Subscriber<T> sub) {\n-      return new BlackboxSubscriberProxy<T>(env, sub);\n-    }\n-\n-    public T signalNext() throws InterruptedException {\n-      T element = nextT();\n-      sendNext(element);\n-      return element;\n-    }\n-\n-    public T nextT() throws InterruptedException {\n-      lastT = tees.requestNextElement();\n-      return lastT;\n-    }\n-\n-  }\n-\n-  public void notVerified() {\n-    throw new SkipException(\"Not verified using this TCK.\");\n-  }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/SubscriberBlackboxVerification.java","additions":0,"deletions":516,"binary":false,"changes":516,"status":"deleted"},{"patch":"@@ -1,850 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck;\n-\n-import org.reactivestreams.Publisher;\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-import org.reactivestreams.tck.TestEnvironment.*;\n-import org.reactivestreams.tck.flow.support.Optional;\n-import org.reactivestreams.tck.flow.support.SubscriberWhiteboxVerificationRules;\n-import org.reactivestreams.tck.flow.support.TestException;\n-import org.testng.SkipException;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n-\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-\n-import static org.testng.Assert.assertTrue;\n-\n-\/**\n- * Provides whitebox style tests for verifying {@link org.reactivestreams.Subscriber}\n- * and {@link org.reactivestreams.Subscription} specification rules.\n- *\n- * @see org.reactivestreams.Subscriber\n- * @see org.reactivestreams.Subscription\n- *\/\n-public abstract class SubscriberWhiteboxVerification<T> extends WithHelperPublisher<T>\n-  implements SubscriberWhiteboxVerificationRules {\n-\n-  private final TestEnvironment env;\n-\n-  protected SubscriberWhiteboxVerification(TestEnvironment env) {\n-    this.env = env;\n-  }\n-\n-  \/\/ USER API\n-\n-  \/**\n-   * This is the main method you must implement in your test incarnation.\n-   * It must create a new {@link org.reactivestreams.Subscriber} instance to be subjected to the testing logic.\n-   *\n-   * In order to be meaningfully testable your Subscriber must inform the given\n-   * `WhiteboxSubscriberProbe` of the respective events having been received.\n-   *\/\n-  public abstract Subscriber<T> createSubscriber(WhiteboxSubscriberProbe<T> probe);\n-\n-  \/\/ ENV SETUP\n-\n-  \/**\n-   * Executor service used by the default provided asynchronous Publisher.\n-   * @see #createHelperPublisher(long)\n-   *\/\n-  private ExecutorService publisherExecutor;\n-  @BeforeClass public void startPublisherExecutorService() { publisherExecutor = Executors.newFixedThreadPool(4); }\n-  @AfterClass public void shutdownPublisherExecutorService() { if (publisherExecutor != null) publisherExecutor.shutdown(); }\n-  @Override public ExecutorService publisherExecutorService() { return publisherExecutor; }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ TEST ENV CLEANUP \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  @BeforeMethod\n-  public void setUp() throws Exception {\n-    env.clearAsyncErrors();\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ TEST SETUP VERIFICATION \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  @Test\n-  public void required_exerciseWhiteboxHappyPath() throws Throwable {\n-    subscriberTest(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws InterruptedException {\n-        stage.puppet().triggerRequest(1);\n-        stage.puppet().triggerRequest(1);\n-\n-        long receivedRequests = stage.expectRequest();\n-\n-        stage.signalNext();\n-        stage.probe.expectNext(stage.lastT);\n-\n-        stage.puppet().triggerRequest(1);\n-        if (receivedRequests == 1) {\n-          stage.expectRequest();\n-        }\n-\n-        stage.signalNext();\n-        stage.probe.expectNext(stage.lastT);\n-\n-        stage.puppet().signalCancel();\n-        stage.expectCancelling();\n-\n-        stage.verifyNoAsyncErrors();\n-      }\n-    });\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ SPEC RULE VERIFICATION \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.1\n-  @Override @Test\n-  public void required_spec201_mustSignalDemandViaSubscriptionRequest() throws Throwable {\n-    subscriberTest(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws InterruptedException {\n-        stage.puppet().triggerRequest(1);\n-        stage.expectRequest();\n-\n-        stage.signalNext();\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.2\n-  @Override @Test\n-  public void untested_spec202_shouldAsynchronouslyDispatch() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.3\n-  @Override @Test\n-  public void required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnComplete() throws Throwable {\n-    subscriberTestWithoutSetup(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws Throwable {\n-        final Subscription subs = new Subscription() {\n-          @Override\n-          public void request(long n) {\n-            final Optional<StackTraceElement> onCompleteStackTraceElement = env.findCallerMethodInStackTrace(\"onComplete\");\n-            if (onCompleteStackTraceElement.isDefined()) {\n-              final StackTraceElement stackElem = onCompleteStackTraceElement.get();\n-              env.flop(String.format(\"Subscription::request MUST NOT be called from Subscriber::onComplete (Rule 2.3)! (Caller: %s::%s line %d)\",\n-                                     stackElem.getClassName(), stackElem.getMethodName(), stackElem.getLineNumber()));\n-            }\n-          }\n-\n-          @Override\n-          public void cancel() {\n-            final Optional<StackTraceElement> onCompleteStackElement = env.findCallerMethodInStackTrace(\"onComplete\");\n-            if (onCompleteStackElement.isDefined()) {\n-              final StackTraceElement stackElem = onCompleteStackElement.get();\n-              env.flop(String.format(\"Subscription::cancel MUST NOT be called from Subscriber::onComplete (Rule 2.3)! (Caller: %s::%s line %d)\",\n-                                     stackElem.getClassName(), stackElem.getMethodName(), stackElem.getLineNumber()));\n-            }\n-          }\n-        };\n-\n-        stage.probe = stage.createWhiteboxSubscriberProbe(env);\n-        final Subscriber<T> sub = createSubscriber(stage.probe);\n-\n-        sub.onSubscribe(subs);\n-        sub.onComplete();\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.3\n-  @Override @Test\n-  public void required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnError() throws Throwable {\n-    subscriberTestWithoutSetup(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws Throwable {\n-        final Subscription subs = new Subscription() {\n-          @Override\n-          public void request(long n) {\n-            Throwable thr = new Throwable();\n-            for (StackTraceElement stackElem : thr.getStackTrace()) {\n-              if (stackElem.getMethodName().equals(\"onError\")) {\n-                env.flop(String.format(\"Subscription::request MUST NOT be called from Subscriber::onError (Rule 2.3)! (Caller: %s::%s line %d)\",\n-                                       stackElem.getClassName(), stackElem.getMethodName(), stackElem.getLineNumber()));\n-              }\n-            }\n-          }\n-\n-          @Override\n-          public void cancel() {\n-            Throwable thr = new Throwable();\n-            for (StackTraceElement stackElem : thr.getStackTrace()) {\n-              if (stackElem.getMethodName().equals(\"onError\")) {\n-                env.flop(String.format(\"Subscription::cancel MUST NOT be called from Subscriber::onError (Rule 2.3)! (Caller: %s::%s line %d)\",\n-                                       stackElem.getClassName(), stackElem.getMethodName(), stackElem.getLineNumber()));\n-              }\n-            }\n-          }\n-        };\n-\n-        stage.probe = stage.createWhiteboxSubscriberProbe(env);\n-        final Subscriber<T> sub = createSubscriber(stage.probe);\n-\n-        sub.onSubscribe(subs);\n-        sub.onError(new TestException());\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.4\n-  @Override @Test\n-  public void untested_spec204_mustConsiderTheSubscriptionAsCancelledInAfterRecievingOnCompleteOrOnError() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.5\n-  @Override @Test\n-  public void required_spec205_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal() throws Throwable {\n-    subscriberTest(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws Throwable {\n-        \/\/ try to subscribe another time, if the subscriber calls `probe.registerOnSubscribe` the test will fail\n-        final Latch secondSubscriptionCancelled = new Latch(env);\n-        final Subscriber<? super T> sub = stage.sub();\n-        final Subscription subscription = new Subscription() {\n-          @Override\n-          public void request(long elements) {\n-            \/\/ ignore...\n-          }\n-\n-          @Override\n-          public void cancel() {\n-            secondSubscriptionCancelled.close();\n-          }\n-\n-          @Override\n-          public String toString() {\n-            return \"SecondSubscription(should get cancelled)\";\n-          }\n-        };\n-        sub.onSubscribe(subscription);\n-\n-        secondSubscriptionCancelled.expectClose(\"Expected 2nd Subscription given to subscriber to be cancelled, but `Subscription.cancel()` was not called\");\n-        env.verifyNoAsyncErrors();\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.6\n-  @Override @Test\n-  public void untested_spec206_mustCallSubscriptionCancelIfItIsNoLongerValid() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.7\n-  @Override @Test\n-  public void untested_spec207_mustEnsureAllCallsOnItsSubscriptionTakePlaceFromTheSameThreadOrTakeCareOfSynchronization() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-    \/\/ the same thread part of the clause can be verified but that is not very useful, or is it?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.8\n-  @Override @Test\n-  public void required_spec208_mustBePreparedToReceiveOnNextSignalsAfterHavingCalledSubscriptionCancel() throws Throwable {\n-    subscriberTest(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws InterruptedException {\n-        stage.puppet().triggerRequest(1);\n-        stage.expectRequest();\n-        stage.puppet().signalCancel();\n-        stage.expectCancelling();\n-        stage.signalNext();\n-\n-        stage.puppet().triggerRequest(1);\n-        stage.puppet().triggerRequest(1);\n-\n-        stage.verifyNoAsyncErrors();\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.9\n-  @Override @Test\n-  public void required_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithPrecedingRequestCall() throws Throwable {\n-    subscriberTest(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws InterruptedException {\n-        stage.puppet().triggerRequest(1);\n-        stage.sendCompletion();\n-        stage.probe.expectCompletion();\n-\n-        stage.verifyNoAsyncErrors();\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.9\n-  @Override @Test\n-  public void required_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithoutPrecedingRequestCall() throws Throwable {\n-    subscriberTest(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws InterruptedException {\n-        stage.sendCompletion();\n-        stage.probe.expectCompletion();\n-\n-        stage.verifyNoAsyncErrors();\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.10\n-  @Override @Test\n-  public void required_spec210_mustBePreparedToReceiveAnOnErrorSignalWithPrecedingRequestCall() throws Throwable {\n-    subscriberTest(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws InterruptedException {\n-        stage.puppet().triggerRequest(1);\n-        stage.puppet().triggerRequest(1);\n-\n-        Exception ex = new TestException();\n-        stage.sendError(ex);\n-        stage.probe.expectError(ex);\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.10\n-  @Override @Test\n-  public void required_spec210_mustBePreparedToReceiveAnOnErrorSignalWithoutPrecedingRequestCall() throws Throwable {\n-    subscriberTest(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws InterruptedException {\n-        Exception ex = new TestException();\n-        stage.sendError(ex);\n-        stage.probe.expectError(ex);\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.11\n-  @Override @Test\n-  public void untested_spec211_mustMakeSureThatAllCallsOnItsMethodsHappenBeforeTheProcessingOfTheRespectiveEvents() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.12\n-  @Override @Test\n-  public void untested_spec212_mustNotCallOnSubscribeMoreThanOnceBasedOnObjectEquality_specViolation() throws Throwable {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.13\n-  @Override @Test\n-  public void untested_spec213_failingOnSignalInvocation() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.13\n-  @Override @Test\n-  public void required_spec213_onSubscribe_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable {\n-    subscriberTest(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws Throwable {\n-\n-        final Subscriber<? super T> sub = stage.sub();\n-        boolean gotNPE = false;\n-        try {\n-          sub.onSubscribe(null);\n-        } catch (final NullPointerException expected) {\n-          gotNPE = true;\n-        }\n-\n-        assertTrue(gotNPE, \"onSubscribe(null) did not throw NullPointerException\");\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.13\n-  @Override @Test\n-  public void required_spec213_onNext_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable {\n-    subscriberTest(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws Throwable {\n-\n-        final Subscriber<? super T> sub = stage.sub();\n-        boolean gotNPE = false;\n-        try {\n-          sub.onNext(null);\n-        } catch (final NullPointerException expected) {\n-          gotNPE = true;\n-        }\n-\n-        assertTrue(gotNPE, \"onNext(null) did not throw NullPointerException\");\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.13\n-  @Override @Test\n-  public void required_spec213_onError_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable {\n-    subscriberTest(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws Throwable {\n-\n-          final Subscriber<? super T> sub = stage.sub();\n-          boolean gotNPE = false;\n-          try {\n-            sub.onError(null);\n-          } catch (final NullPointerException expected) {\n-            gotNPE = true;\n-          } finally {\n-            assertTrue(gotNPE, \"onError(null) did not throw NullPointerException\");\n-          }\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ SUBSCRIPTION SPEC RULE VERIFICATION \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.1\n-  @Override @Test\n-  public void untested_spec301_mustNotBeCalledOutsideSubscriberContext() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.8\n-  @Override @Test\n-  public void required_spec308_requestMustRegisterGivenNumberElementsToBeProduced() throws Throwable {\n-    subscriberTest(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws InterruptedException {\n-        stage.puppet().triggerRequest(2);\n-        long requestedElements = stage.expectRequest();\n-        stage.probe.expectNext(stage.signalNext());\n-        \/\/ Some subscribers may only request one element at a time.\n-        if (requestedElements < 2) {\n-          stage.expectRequest();\n-        }\n-        stage.probe.expectNext(stage.signalNext());\n-\n-        stage.probe.expectNone();\n-        stage.puppet().triggerRequest(3);\n-\n-        stage.verifyNoAsyncErrors();\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.10\n-  @Override @Test\n-  public void untested_spec310_requestMaySynchronouslyCallOnNextOnSubscriber() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.11\n-  @Override @Test\n-  public void untested_spec311_requestMaySynchronouslyCallOnCompleteOrOnError() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.14\n-  @Override @Test\n-  public void untested_spec314_cancelMayCauseThePublisherToShutdownIfNoOtherSubscriptionExists() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.15\n-  @Override @Test\n-  public void untested_spec315_cancelMustNotThrowExceptionAndMustSignalOnError() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.16\n-  @Override @Test\n-  public void untested_spec316_requestMustNotThrowExceptionAndMustOnErrorTheSubscriber() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ ADDITIONAL \"COROLLARY\" TESTS \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ TEST INFRASTRUCTURE \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  abstract class TestStageTestRun {\n-    public abstract void run(WhiteboxTestStage stage) throws Throwable;\n-  }\n-\n-  \/**\n-   * Prepares subscriber and publisher pair (by subscribing the first to the latter),\n-   * and then hands over the tests {@link WhiteboxTestStage} over to the test.\n-   *\n-   * The test stage is, like in a puppet show, used to orchestrate what each participant should do.\n-   * Since this is a whitebox test, this allows the stage to completely control when and how to signal \/ expect signals.\n-   *\/\n-  public void subscriberTest(TestStageTestRun body) throws Throwable {\n-    WhiteboxTestStage stage = new WhiteboxTestStage(env, true);\n-    body.run(stage);\n-  }\n-\n-  \/**\n-   * Provides a {@link WhiteboxTestStage} without performing any additional setup,\n-   * like the {@link #subscriberTest(SubscriberWhiteboxVerification.TestStageTestRun)} would.\n-   *\n-   * Use this method to write tests in which you need full control over when and how the initial {@code subscribe} is signalled.\n-   *\/\n-  public void subscriberTestWithoutSetup(TestStageTestRun body) throws Throwable {\n-    WhiteboxTestStage stage = new WhiteboxTestStage(env, false);\n-    body.run(stage);\n-  }\n-\n-  \/**\n-   * Test for feature that MAY be implemented. This test will be marked as SKIPPED if it fails.\n-   *\/\n-  public void optionalSubscriberTestWithoutSetup(TestStageTestRun body) throws Throwable {\n-    try {\n-      subscriberTestWithoutSetup(body);\n-    } catch (Exception ex) {\n-      notVerified(\"Skipped because tested publisher does NOT implement this OPTIONAL requirement.\");\n-    }\n-  }\n-\n-  public class WhiteboxTestStage extends ManualPublisher<T> {\n-    public Publisher<T> pub;\n-    public ManualSubscriber<T> tees; \/\/ gives us access to a stream T values\n-    public WhiteboxSubscriberProbe<T> probe;\n-\n-    public T lastT = null;\n-\n-    public WhiteboxTestStage(TestEnvironment env) throws InterruptedException {\n-      this(env, true);\n-    }\n-\n-    public WhiteboxTestStage(TestEnvironment env, boolean runDefaultInit) throws InterruptedException {\n-      super(env);\n-      if (runDefaultInit) {\n-        pub = this.createHelperPublisher(Long.MAX_VALUE);\n-        tees = env.newManualSubscriber(pub);\n-        probe = new WhiteboxSubscriberProbe<T>(env, subscriber);\n-        subscribe(createSubscriber(probe));\n-        probe.puppet.expectCompletion(env.defaultTimeoutMillis(), String.format(\"Subscriber %s did not `registerOnSubscribe`\", sub()));\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    }\n-\n-    public Subscriber<? super T> sub() {\n-      return subscriber.value();\n-    }\n-\n-    public SubscriberPuppet puppet() {\n-      return probe.puppet();\n-    }\n-\n-    public WhiteboxSubscriberProbe<T> probe() {\n-      return probe;\n-    }\n-\n-    public Publisher<T> createHelperPublisher(long elements) {\n-      return SubscriberWhiteboxVerification.this.createHelperPublisher(elements);\n-    }\n-\n-    public WhiteboxSubscriberProbe<T> createWhiteboxSubscriberProbe(TestEnvironment env) {\n-      return new WhiteboxSubscriberProbe<T>(env, subscriber);\n-    }\n-\n-    public T signalNext() throws InterruptedException {\n-      return signalNext(nextT());\n-    }\n-\n-    private T signalNext(T element) throws InterruptedException {\n-      sendNext(element);\n-      return element;\n-    }\n-\n-    public T nextT() throws InterruptedException {\n-      lastT = tees.requestNextElement();\n-      return lastT;\n-    }\n-\n-    public void verifyNoAsyncErrors() {\n-      env.verifyNoAsyncErrors();\n-    }\n-  }\n-\n-  \/**\n-   * This class is intented to be used as {@code Subscriber} decorator and should be used in {@code pub.subscriber(...)} calls,\n-   * in order to allow intercepting calls on the underlying {@code Subscriber}.\n-   * This delegation allows the proxy to implement {@link BlackboxProbe} assertions.\n-   *\/\n-  public static class BlackboxSubscriberProxy<T> extends BlackboxProbe<T> implements Subscriber<T> {\n-\n-    public BlackboxSubscriberProxy(TestEnvironment env, Subscriber<T> subscriber) {\n-      super(env, Promise.<Subscriber<? super T>>completed(env, subscriber));\n-    }\n-\n-    @Override\n-    public void onSubscribe(Subscription s) {\n-      sub().onSubscribe(s);\n-    }\n-\n-    @Override\n-    public void onNext(T t) {\n-      registerOnNext(t);\n-      sub().onNext(t);\n-    }\n-\n-    @Override\n-    public void onError(Throwable cause) {\n-      registerOnError(cause);\n-      sub().onError(cause);\n-    }\n-\n-    @Override\n-    public void onComplete() {\n-      registerOnComplete();\n-      sub().onComplete();\n-    }\n-  }\n-\n-  public static class BlackboxProbe<T> implements SubscriberProbe<T> {\n-    protected final TestEnvironment env;\n-    protected final Promise<Subscriber<? super T>> subscriber;\n-\n-    protected final Receptacle<T> elements;\n-    protected final Promise<Throwable> error;\n-\n-    public BlackboxProbe(TestEnvironment env, Promise<Subscriber<? super T>> subscriber) {\n-      this.env = env;\n-      this.subscriber = subscriber;\n-      elements = new Receptacle<T>(env);\n-      error = new Promise<Throwable>(env);\n-    }\n-\n-    @Override\n-    public void registerOnNext(T element) {\n-      elements.add(element);\n-    }\n-\n-    @Override\n-    public void registerOnComplete() {\n-      try {\n-        elements.complete();\n-      } catch (IllegalStateException ex) {\n-        \/\/ \"Queue full\", onComplete was already called\n-        env.flop(\"subscriber::onComplete was called a second time, which is illegal according to Rule 1.7\");\n-      }\n-    }\n-\n-    @Override\n-    public void registerOnError(Throwable cause) {\n-      try {\n-        error.complete(cause);\n-      } catch (IllegalStateException ex) {\n-        \/\/ \"Queue full\", onError was already called\n-        env.flop(\"subscriber::onError was called a second time, which is illegal according to Rule 1.7\");\n-      }\n-    }\n-\n-    public T expectNext() throws InterruptedException {\n-      return elements.next(env.defaultTimeoutMillis(), String.format(\"Subscriber %s did not call `registerOnNext(_)`\", sub()));\n-    }\n-\n-    public void expectNext(T expected) throws InterruptedException {\n-      expectNext(expected, env.defaultTimeoutMillis());\n-    }\n-\n-    public void expectNext(T expected, long timeoutMillis) throws InterruptedException {\n-      T received = elements.next(timeoutMillis, String.format(\"Subscriber %s did not call `registerOnNext(%s)`\", sub(), expected));\n-      if (!received.equals(expected)) {\n-        env.flop(String.format(\"Subscriber %s called `registerOnNext(%s)` rather than `registerOnNext(%s)`\", sub(), received, expected));\n-      }\n-    }\n-\n-    public Subscriber<? super T> sub() {\n-      return subscriber.value();\n-    }\n-\n-    public void expectCompletion() throws InterruptedException {\n-      expectCompletion(env.defaultTimeoutMillis());\n-    }\n-\n-    public void expectCompletion(long timeoutMillis) throws InterruptedException {\n-      expectCompletion(timeoutMillis, String.format(\"Subscriber %s did not call `registerOnComplete()`\", sub()));\n-    }\n-\n-    public void expectCompletion(long timeoutMillis, String msg) throws InterruptedException {\n-      elements.expectCompletion(timeoutMillis, msg);\n-    }\n-\n-    @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n-    public <E extends Throwable> void expectErrorWithMessage(Class<E> expected, String requiredMessagePart) throws InterruptedException {\n-      final E err = expectError(expected);\n-      String message = err.getMessage();\n-      assertTrue(message.contains(requiredMessagePart),\n-        String.format(\"Got expected exception %s but missing message [%s], was: %s\", err.getClass(), requiredMessagePart, expected));\n-    }\n-\n-    public <E extends Throwable> E expectError(Class<E> expected) throws InterruptedException {\n-      return expectError(expected, env.defaultTimeoutMillis());\n-    }\n-\n-    @SuppressWarnings({\"unchecked\", \"ThrowableResultOfMethodCallIgnored\"})\n-    public <E extends Throwable> E expectError(Class<E> expected, long timeoutMillis) throws InterruptedException {\n-      error.expectCompletion(timeoutMillis, String.format(\"Subscriber %s did not call `registerOnError(%s)`\", sub(), expected));\n-      if (error.value() == null) {\n-        return env.flopAndFail(String.format(\"Subscriber %s did not call `registerOnError(%s)`\", sub(), expected));\n-      } else if (expected.isInstance(error.value())) {\n-        return (E) error.value();\n-      } else {\n-        return env.flopAndFail(String.format(\"Subscriber %s called `registerOnError(%s)` rather than `registerOnError(%s)`\", sub(), error.value(), expected));\n-      }\n-    }\n-\n-    public void expectError(Throwable expected) throws InterruptedException {\n-      expectError(expected, env.defaultTimeoutMillis());\n-    }\n-\n-    @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n-    public void expectError(Throwable expected, long timeoutMillis) throws InterruptedException {\n-      error.expectCompletion(timeoutMillis, String.format(\"Subscriber %s did not call `registerOnError(%s)`\", sub(), expected));\n-      if (error.value() != expected) {\n-        env.flop(String.format(\"Subscriber %s called `registerOnError(%s)` rather than `registerOnError(%s)`\", sub(), error.value(), expected));\n-      }\n-    }\n-\n-    public void expectNone() throws InterruptedException {\n-      expectNone(env.defaultNoSignalsTimeoutMillis());\n-    }\n-\n-    public void expectNone(long withinMillis) throws InterruptedException {\n-      elements.expectNone(withinMillis, \"Expected nothing\");\n-    }\n-\n-  }\n-\n-  public static class WhiteboxSubscriberProbe<T> extends BlackboxProbe<T> implements SubscriberPuppeteer {\n-    protected Promise<SubscriberPuppet> puppet;\n-\n-    public WhiteboxSubscriberProbe(TestEnvironment env, Promise<Subscriber<? super T>> subscriber) {\n-      super(env, subscriber);\n-      puppet = new Promise<SubscriberPuppet>(env);\n-    }\n-\n-    private SubscriberPuppet puppet() {\n-      return puppet.value();\n-    }\n-\n-    @Override\n-    public void registerOnSubscribe(SubscriberPuppet p) {\n-      if (!puppet.isCompleted()) {\n-        puppet.complete(p);\n-      }\n-    }\n-\n-  }\n-\n-  public interface SubscriberPuppeteer {\n-\n-    \/**\n-     * Must be called by the test subscriber when it has successfully registered a subscription\n-     * inside the `onSubscribe` method.\n-     *\/\n-    void registerOnSubscribe(SubscriberPuppet puppet);\n-  }\n-\n-  public interface SubscriberProbe<T> {\n-\n-    \/**\n-     * Must be called by the test subscriber when it has received an`onNext` event.\n-     *\/\n-    void registerOnNext(T element);\n-\n-    \/**\n-     * Must be called by the test subscriber when it has received an `onComplete` event.\n-     *\/\n-    void registerOnComplete();\n-\n-    \/**\n-     * Must be called by the test subscriber when it has received an `onError` event.\n-     *\/\n-    void registerOnError(Throwable cause);\n-\n-  }\n-\n-  \/**\n-   * Implement this puppet in your Whitebox style tests.\n-   * The test suite will invoke the specific trigger\/signal methods requesting you to execute the specific action.\n-   * Since this is a whitebox style test, you're allowed and expected to use knowladge about your implementation to\n-   * make implement these calls.\n-   *\/\n-  public interface SubscriberPuppet {\n-\n-    \/**\n-     * Ensure that at least {@code elements} are eventually requested by your {@link Subscriber}, if it hasn't already\n-     * requested that many elements.\n-     * <p>\n-     * This does not necessarily have to correlate 1:1 with a {@code Subscription.request(elements)} call, but the sum\n-     * of the elements requested by your {@code Subscriber} must eventually be at least the sum of the elements\n-     * triggered to be requested by all the invocations of this method.\n-     * <p>\n-     * Additionally, subscribers are permitted to delay requesting elements until previous requests for elements have\n-     * been fulfilled. For example, a subscriber that only requests one element at a time may fulfill the request made\n-     * by this method by requesting one element {@code elements} times, waiting for each element to arrive before the\n-     * next request is made.\n-     * <p>\n-     * Before sending any element to the subscriber, the TCK must wait for the subscriber to request that element, and\n-     * must be prepared for the subscriber to only request one element at a time, it is not enough for the TCK to\n-     * simply invoke this method before sending elements.\n-     * <p>\n-     * An invocation of {@link #signalCancel()} may be coalesced into any elements that have not yet been requested,\n-     * such that only a cancel signal is emitted.\n-     *\/\n-    void triggerRequest(long elements);\n-\n-    \/**\n-     * Trigger {@code cancel()} on your {@link Subscriber}.\n-     * <p>\n-     * An invocation of this method may be coalesced into any outstanding requests, as requested by\n-     *{@link #triggerRequest(long)}, such that only a cancel signal is emitted.\n-     *\/\n-    void signalCancel();\n-  }\n-\n-  public void notVerified() {\n-    throw new SkipException(\"Not verified using this TCK.\");\n-  }\n-\n-  public void notVerified(String msg) {\n-    throw new SkipException(msg);\n-  }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/SubscriberWhiteboxVerification.java","additions":0,"deletions":850,"binary":false,"changes":850,"status":"deleted"},{"patch":"@@ -1,1168 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck;\n-\n-import org.reactivestreams.Publisher;\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-import org.reactivestreams.tck.flow.support.Optional;\n-import org.reactivestreams.tck.flow.support.SubscriberBufferOverflowException;\n-\n-import java.util.Collections;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.concurrent.ArrayBlockingQueue;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n-\n-import static java.util.concurrent.TimeUnit.MILLISECONDS;\n-import static java.util.concurrent.TimeUnit.NANOSECONDS;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n-\n-public class TestEnvironment {\n-  public static final int TEST_BUFFER_SIZE = 16;\n-\n-  private static final String DEFAULT_TIMEOUT_MILLIS_ENV = \"DEFAULT_TIMEOUT_MILLIS\";\n-  private static final long DEFAULT_TIMEOUT_MILLIS = 100;\n-\n-  private static final String DEFAULT_NO_SIGNALS_TIMEOUT_MILLIS_ENV = \"DEFAULT_NO_SIGNALS_TIMEOUT_MILLIS\";\n-  private static final String DEFAULT_POLL_TIMEOUT_MILLIS_ENV = \"DEFAULT_POLL_TIMEOUT_MILLIS_ENV\";\n-\n-  private final long defaultTimeoutMillis;\n-  private final long defaultPollTimeoutMillis;\n-  private final long defaultNoSignalsTimeoutMillis;\n-  private final boolean printlnDebug;\n-\n-  private CopyOnWriteArrayList<Throwable> asyncErrors = new CopyOnWriteArrayList<Throwable>();\n-\n-  \/**\n-   * Tests must specify the timeout for expected outcome of asynchronous\n-   * interactions. Longer timeout does not invalidate the correctness of\n-   * the implementation, but can in some cases result in longer time to\n-   * run the tests.\n-   * @param defaultTimeoutMillis default timeout to be used in all expect* methods\n-   * @param defaultNoSignalsTimeoutMillis default timeout to be used when no further signals are expected anymore\n-   * @param defaultPollTimeoutMillis default amount of time to poll for events if {@code defaultTimeoutMillis} isn't\n-    *                                preempted by an asynchronous event.\n-   * @param printlnDebug         if true, signals such as OnNext \/ Request \/ OnComplete etc will be printed to standard output,\n-   *\/\n-  public TestEnvironment(long defaultTimeoutMillis, long defaultNoSignalsTimeoutMillis, long defaultPollTimeoutMillis,\n-                         boolean printlnDebug) {\n-    this.defaultTimeoutMillis = defaultTimeoutMillis;\n-    this.defaultPollTimeoutMillis = defaultPollTimeoutMillis;\n-    this.defaultNoSignalsTimeoutMillis = defaultNoSignalsTimeoutMillis;\n-    this.printlnDebug = printlnDebug;\n-  }\n-\n-  \/**\n-   * Tests must specify the timeout for expected outcome of asynchronous\n-   * interactions. Longer timeout does not invalidate the correctness of\n-   * the implementation, but can in some cases result in longer time to\n-   * run the tests.\n-   * @param defaultTimeoutMillis default timeout to be used in all expect* methods\n-   * @param defaultNoSignalsTimeoutMillis default timeout to be used when no further signals are expected anymore\n-   * @param printlnDebug         if true, signals such as OnNext \/ Request \/ OnComplete etc will be printed to standard output,\n-   *\/\n-  public TestEnvironment(long defaultTimeoutMillis, long defaultNoSignalsTimeoutMillis, boolean printlnDebug) {\n-    this(defaultTimeoutMillis, defaultNoSignalsTimeoutMillis, defaultTimeoutMillis, printlnDebug);\n-  }\n-\n-  \/**\n-   * Tests must specify the timeout for expected outcome of asynchronous\n-   * interactions. Longer timeout does not invalidate the correctness of\n-   * the implementation, but can in some cases result in longer time to\n-   * run the tests.\n-   *\n-   * @param defaultTimeoutMillis default timeout to be used in all expect* methods\n-   * @param defaultNoSignalsTimeoutMillis default timeout to be used when no further signals are expected anymore\n-   * @param defaultPollTimeoutMillis default amount of time to poll for events if {@code defaultTimeoutMillis} isn't\n-   *                                 preempted by an asynchronous event.\n-   *\/\n-  public TestEnvironment(long defaultTimeoutMillis, long defaultNoSignalsTimeoutMillis, long defaultPollTimeoutMillis) {\n-      this(defaultTimeoutMillis, defaultNoSignalsTimeoutMillis, defaultPollTimeoutMillis, false);\n-  }\n-\n-  \/**\n-   * Tests must specify the timeout for expected outcome of asynchronous\n-   * interactions. Longer timeout does not invalidate the correctness of\n-   * the implementation, but can in some cases result in longer time to\n-   * run the tests.\n-   *\n-   * @param defaultTimeoutMillis default timeout to be used in all expect* methods\n-   * @param defaultNoSignalsTimeoutMillis default timeout to be used when no further signals are expected anymore\n-   *\/\n-  public TestEnvironment(long defaultTimeoutMillis, long defaultNoSignalsTimeoutMillis) {\n-    this(defaultTimeoutMillis, defaultTimeoutMillis, defaultNoSignalsTimeoutMillis);\n-  }\n-\n-  \/**\n-   * Tests must specify the timeout for expected outcome of asynchronous\n-   * interactions. Longer timeout does not invalidate the correctness of\n-   * the implementation, but can in some cases result in longer time to\n-   * run the tests.\n-   *\n-   * @param defaultTimeoutMillis default timeout to be used in all expect* methods\n-   *\/\n-  public TestEnvironment(long defaultTimeoutMillis) {\n-    this(defaultTimeoutMillis, defaultTimeoutMillis, defaultTimeoutMillis);\n-  }\n-\n-  \/**\n-   * Tests must specify the timeout for expected outcome of asynchronous\n-   * interactions. Longer timeout does not invalidate the correctness of\n-   * the implementation, but can in some cases result in longer time to\n-   * run the tests.\n-   *\n-   * The default timeout for all expect* methods will be obtained by either the env variable {@code DEFAULT_TIMEOUT_MILLIS}\n-   * or the default value ({@link TestEnvironment#DEFAULT_TIMEOUT_MILLIS}) will be used.\n-   *\n-   * @param printlnDebug if true, signals such as OnNext \/ Request \/ OnComplete etc will be printed to standard output,\n-   *                     often helpful to pinpoint simple race conditions etc.\n-   *\/\n-  public TestEnvironment(boolean printlnDebug) {\n-    this(envDefaultTimeoutMillis(), envDefaultNoSignalsTimeoutMillis(), envDefaultPollTimeoutMillis(), printlnDebug);\n-  }\n-\n-  \/**\n-   * Tests must specify the timeout for expected outcome of asynchronous\n-   * interactions. Longer timeout does not invalidate the correctness of\n-   * the implementation, but can in some cases result in longer time to\n-   * run the tests.\n-   *\n-   * The default timeout for all expect* methods will be obtained by either the env variable {@code DEFAULT_TIMEOUT_MILLIS}\n-   * or the default value ({@link TestEnvironment#DEFAULT_TIMEOUT_MILLIS}) will be used.\n-   *\/\n-  public TestEnvironment() {\n-    this(envDefaultTimeoutMillis(), envDefaultNoSignalsTimeoutMillis());\n-  }\n-\n-  \/** This timeout is used when waiting for a signal to arrive. *\/\n-  public long defaultTimeoutMillis() {\n-    return defaultTimeoutMillis;\n-  }\n-\n-  \/**\n-   * This timeout is used when asserting that no further signals are emitted.\n-   * Note that this timeout default\n-   *\/\n-  public long defaultNoSignalsTimeoutMillis() {\n-    return defaultNoSignalsTimeoutMillis;\n-  }\n-\n-  \/**\n-   * The default amount of time to poll for events if {@code defaultTimeoutMillis} isn't preempted by an asynchronous\n-   * event.\n-   *\/\n-  public long defaultPollTimeoutMillis() {\n-    return defaultPollTimeoutMillis;\n-  }\n-\n-  \/**\n-   * Tries to parse the env variable {@code DEFAULT_TIMEOUT_MILLIS} as long and returns the value if present OR its default value.\n-   *\n-   * @throws java.lang.IllegalArgumentException when unable to parse the env variable\n-   *\/\n-  public static long envDefaultTimeoutMillis() {\n-    final String envMillis = System.getenv(DEFAULT_TIMEOUT_MILLIS_ENV);\n-    if (envMillis == null) return DEFAULT_TIMEOUT_MILLIS;\n-    else try {\n-      return Long.parseLong(envMillis);\n-    } catch (NumberFormatException ex) {\n-      throw new IllegalArgumentException(String.format(\"Unable to parse %s env value [%s] as long!\", DEFAULT_TIMEOUT_MILLIS_ENV, envMillis), ex);\n-    }\n-  }\n-\n-  \/**\n-   * Tries to parse the env variable {@code DEFAULT_NO_SIGNALS_TIMEOUT_MILLIS} as long and returns the value if present OR its default value.\n-   *\n-   * @throws java.lang.IllegalArgumentException when unable to parse the env variable\n-   *\/\n-  public static long envDefaultNoSignalsTimeoutMillis() {\n-    final String envMillis = System.getenv(DEFAULT_NO_SIGNALS_TIMEOUT_MILLIS_ENV);\n-    if (envMillis == null) return envDefaultTimeoutMillis();\n-    else try {\n-      return Long.parseLong(envMillis);\n-    } catch (NumberFormatException ex) {\n-      throw new IllegalArgumentException(String.format(\"Unable to parse %s env value [%s] as long!\", DEFAULT_NO_SIGNALS_TIMEOUT_MILLIS_ENV, envMillis), ex);\n-    }\n-  }\n-\n-  \/**\n-   * Tries to parse the env variable {@code DEFAULT_POLL_TIMEOUT_MILLIS_ENV} as long and returns the value if present OR its default value.\n-   *\n-   * @throws java.lang.IllegalArgumentException when unable to parse the env variable\n-   *\/\n-  public static long envDefaultPollTimeoutMillis() {\n-    final String envMillis = System.getenv(DEFAULT_POLL_TIMEOUT_MILLIS_ENV);\n-    if (envMillis == null) return envDefaultTimeoutMillis();\n-    else try {\n-      return Long.parseLong(envMillis);\n-    } catch (NumberFormatException ex) {\n-      throw new IllegalArgumentException(String.format(\"Unable to parse %s env value [%s] as long!\", DEFAULT_POLL_TIMEOUT_MILLIS_ENV, envMillis), ex);\n-    }\n-  }\n-\n-  \/**\n-   * To flop means to \"fail asynchronously\", either by onErroring or by failing some TCK check triggered asynchronously.\n-   * This method does *NOT* fail the test - it's up to inspections of the error to fail the test if required.\n-   *\n-   * Use {@code env.verifyNoAsyncErrorsNoDelay()} at the end of your TCK tests to verify there no flops called during it's execution.\n-   * To check investigate asyncErrors more closely you can use {@code expectError} methods or collect the error directly\n-   * from the environment using {@code env.dropAsyncError()}.\n-   *\n-   * To clear asyncErrors you can call {@link org.reactivestreams.tck.TestEnvironment#clearAsyncErrors()}\n-   *\/\n-  public void flop(String msg) {\n-    try {\n-      fail(msg);\n-    } catch (Throwable t) {\n-      asyncErrors.add(t);\n-    }\n-  }\n-\n-  \/**\n-   * To flop means to \"fail asynchronously\", either by onErroring or by failing some TCK check triggered asynchronously.\n-   * This method does *NOT* fail the test - it's up to inspections of the error to fail the test if required.\n-   *\n-   * This overload keeps the passed in throwable as the asyncError, instead of creating an AssertionError for this.\n-   *\n-   * Use {@code env.verifyNoAsyncErrorsNoDelay()} at the end of your TCK tests to verify there no flops called during it's execution.\n-   * To check investigate asyncErrors more closely you can use {@code expectError} methods or collect the error directly\n-   * from the environment using {@code env.dropAsyncError()}.\n-   *\n-   * To clear asyncErrors you can call {@link org.reactivestreams.tck.TestEnvironment#clearAsyncErrors()}\n-   *\/\n-  public void flop(Throwable thr, String msg) {\n-    try {\n-      fail(msg, thr);\n-    } catch (Throwable t) {\n-      asyncErrors.add(thr);\n-    }\n-  }\n-\n-  \/**\n-   * To flop means to \"fail asynchronously\", either by onErroring or by failing some TCK check triggered asynchronously.\n-   * This method does *NOT* fail the test - it's up to inspections of the error to fail the test if required.\n-   *\n-   * This overload keeps the passed in throwable as the asyncError, instead of creating an AssertionError for this.\n-   *\n-   * Use {@code env.verifyNoAsyncErrorsNoDelay()} at the end of your TCK tests to verify there no flops called during it's execution.\n-   * To check investigate asyncErrors more closely you can use {@code expectError} methods or collect the error directly\n-   * from the environment using {@code env.dropAsyncError()}.\n-   *\n-   * To clear asyncErrors you can call {@link org.reactivestreams.tck.TestEnvironment#clearAsyncErrors()}\n-   *\/\n-  public void flop(Throwable thr) {\n-    try {\n-      fail(thr.getMessage(), thr);\n-    } catch (Throwable t) {\n-      asyncErrors.add(thr);\n-    }\n-  }\n-\n-  \/**\n-   * To flop means to \"fail asynchronously\", either by onErroring or by failing some TCK check triggered asynchronously.\n-   *\n-   * This method DOES fail the test right away (it tries to, by throwing an AssertionException),\n-   * in such it is different from {@link org.reactivestreams.tck.TestEnvironment#flop} which only records the error.\n-   *\n-   * Use {@code env.verifyNoAsyncErrorsNoDelay()} at the end of your TCK tests to verify there no flops called during it's execution.\n-   * To check investigate asyncErrors more closely you can use {@code expectError} methods or collect the error directly\n-   * from the environment using {@code env.dropAsyncError()}.\n-   *\n-   * To clear asyncErrors you can call {@link org.reactivestreams.tck.TestEnvironment#clearAsyncErrors()}\n-   *\/\n-  public <T> T flopAndFail(String msg) {\n-    try {\n-      fail(msg);\n-    } catch (Throwable t) {\n-      asyncErrors.add(t);\n-      fail(msg, t);\n-    }\n-    return null; \/\/ unreachable, the previous block will always exit by throwing\n-  }\n-\n-\n-\n-  public <T> void subscribe(Publisher<T> pub, TestSubscriber<T> sub) throws InterruptedException {\n-    subscribe(pub, sub, defaultTimeoutMillis);\n-  }\n-\n-  public <T> void subscribe(Publisher<T> pub, TestSubscriber<T> sub, long timeoutMillis) throws InterruptedException {\n-    pub.subscribe(sub);\n-    sub.subscription.expectCompletion(timeoutMillis, String.format(\"Could not subscribe %s to Publisher %s\", sub, pub));\n-    verifyNoAsyncErrorsNoDelay();\n-  }\n-\n-  public <T> ManualSubscriber<T> newBlackholeSubscriber(Publisher<T> pub) throws InterruptedException {\n-    ManualSubscriberWithSubscriptionSupport<T> sub = new BlackholeSubscriberWithSubscriptionSupport<T>(this);\n-    subscribe(pub, sub, defaultTimeoutMillis());\n-    return sub;\n-  }\n-\n-  public <T> ManualSubscriber<T> newManualSubscriber(Publisher<T> pub) throws InterruptedException {\n-    return newManualSubscriber(pub, defaultTimeoutMillis());\n-  }\n-\n-  public <T> ManualSubscriber<T> newManualSubscriber(Publisher<T> pub, long timeoutMillis) throws InterruptedException {\n-    ManualSubscriberWithSubscriptionSupport<T> sub = new ManualSubscriberWithSubscriptionSupport<T>(this);\n-    subscribe(pub, sub, timeoutMillis);\n-    return sub;\n-  }\n-\n-  public void clearAsyncErrors() {\n-    asyncErrors.clear();\n-  }\n-\n-  public Throwable dropAsyncError() {\n-    try {\n-      return asyncErrors.remove(0);\n-    } catch (IndexOutOfBoundsException ex) {\n-      return null;\n-    }\n-  }\n-\n-  \/**\n-   * Waits for {@link TestEnvironment#defaultNoSignalsTimeoutMillis()} and then verifies that no asynchronous errors\n-   * were signalled pior to, or during that time (by calling {@code flop()}).\n-   *\/\n-  public void verifyNoAsyncErrors() {\n-    verifyNoAsyncErrors(defaultNoSignalsTimeoutMillis());\n-  }\n-\n-  \/**\n-   * This version of {@code verifyNoAsyncErrors} should be used when errors still could be signalled\n-   * asynchronously during {@link TestEnvironment#defaultTimeoutMillis()} time.\n-   * <p><\/p>\n-   * It will immediatly check if any async errors were signaled (using {@link TestEnvironment#flop(String)},\n-   * and if no errors encountered wait for another default timeout as the errors may yet be signalled.\n-   * The initial check is performed in order to fail-fast in case of an already failed test.\n-   *\/\n-  public void verifyNoAsyncErrors(long delay) {\n-    try {\n-      verifyNoAsyncErrorsNoDelay();\n-\n-      Thread.sleep(delay);\n-      verifyNoAsyncErrorsNoDelay();\n-    } catch (InterruptedException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n-\n-  \/**\n-   * Verifies that no asynchronous errors were signalled pior to calling this method (by calling {@code flop()}).\n-   * This version of verifyNoAsyncError <b>does not wait before checking for asynchronous errors<\/b>, and is to be used\n-   * for example in tight loops etc.\n-   *\/\n-  public void verifyNoAsyncErrorsNoDelay() {\n-    for (Throwable e : asyncErrors) {\n-      if (e instanceof AssertionError) {\n-        throw (AssertionError) e;\n-      } else {\n-        fail(String.format(\"Async error during test execution: %s\", e.getMessage()), e);\n-      }\n-    }\n-  }\n-\n-  \/** If {@code TestEnvironment#printlnDebug} is true, print debug message to std out. *\/\n-  public void debug(String msg) {\n-    if (debugEnabled()) {\n-      System.out.printf(\"[TCK-DEBUG] %s%n\", msg);\n-    }\n-  }\n-\n-  public final boolean debugEnabled() {\n-    return printlnDebug;\n-  }\n-\n-  \/**\n-   * Looks for given {@code method} method in stack trace.\n-   * Can be used to answer questions like \"was this method called from onComplete?\".\n-   *\n-   * @return the caller's StackTraceElement at which he the looked for method was found in the call stack, EMPTY otherwise\n-   *\/\n-  public Optional<StackTraceElement> findCallerMethodInStackTrace(String method) {\n-    final Throwable thr = new Throwable(); \/\/ gets the stacktrace\n-\n-    for (StackTraceElement stackElement : thr.getStackTrace()) {\n-      if (stackElement.getMethodName().equals(method)) {\n-        return Optional.of(stackElement);\n-      }\n-    }\n-    return Optional.empty();\n-  }\n-\n-  \/\/ ---- classes ----\n-\n-  \/**\n-   * {@link Subscriber} implementation which can be steered by test code and asserted on.\n-   *\/\n-  public static class ManualSubscriber<T> extends TestSubscriber<T> {\n-    Receptacle<T> received;\n-\n-    public ManualSubscriber(TestEnvironment env) {\n-      super(env);\n-      received = new Receptacle<T>(this.env);\n-    }\n-\n-    @Override\n-    public void onNext(T element) {\n-      try {\n-        received.add(element);\n-      } catch (IllegalStateException ex) {\n-          \/\/ error message refinement\n-          throw new SubscriberBufferOverflowException(\n-            String.format(\"Received more than bufferSize (%d) onNext signals. \" +\n-                            \"The Publisher probably emited more signals than expected!\",\n-                          received.QUEUE_SIZE), ex);\n-      }\n-    }\n-\n-    @Override\n-    public void onComplete() {\n-      received.complete();\n-    }\n-\n-    public void request(long elements) {\n-      subscription.value().request(elements);\n-    }\n-\n-    public T requestNextElement() throws InterruptedException {\n-      return requestNextElement(env.defaultTimeoutMillis());\n-    }\n-\n-    public T requestNextElement(long timeoutMillis) throws InterruptedException {\n-      return requestNextElement(timeoutMillis, \"Did not receive expected element\");\n-    }\n-\n-    public T requestNextElement(String errorMsg) throws InterruptedException {\n-      return requestNextElement(env.defaultTimeoutMillis(), errorMsg);\n-    }\n-\n-    public T requestNextElement(long timeoutMillis, String errorMsg) throws InterruptedException {\n-      request(1);\n-      return nextElement(timeoutMillis, errorMsg);\n-    }\n-\n-    public Optional<T> requestNextElementOrEndOfStream() throws InterruptedException {\n-      return requestNextElementOrEndOfStream(env.defaultTimeoutMillis(), \"Did not receive expected stream completion\");\n-    }\n-\n-    public Optional<T> requestNextElementOrEndOfStream(String errorMsg) throws InterruptedException {\n-      return requestNextElementOrEndOfStream(env.defaultTimeoutMillis(), errorMsg);\n-    }\n-\n-    public Optional<T> requestNextElementOrEndOfStream(long timeoutMillis) throws InterruptedException {\n-      return requestNextElementOrEndOfStream(timeoutMillis, \"Did not receive expected stream completion\");\n-    }\n-\n-    public Optional<T> requestNextElementOrEndOfStream(long timeoutMillis, String errorMsg) throws InterruptedException {\n-      request(1);\n-      return nextElementOrEndOfStream(timeoutMillis, errorMsg);\n-    }\n-\n-    public void requestEndOfStream() throws InterruptedException {\n-      requestEndOfStream(env.defaultTimeoutMillis(), \"Did not receive expected stream completion\");\n-    }\n-\n-    public void requestEndOfStream(long timeoutMillis) throws InterruptedException {\n-      requestEndOfStream(timeoutMillis, \"Did not receive expected stream completion\");\n-    }\n-\n-    public void requestEndOfStream(String errorMsg) throws InterruptedException {\n-      requestEndOfStream(env.defaultTimeoutMillis(), errorMsg);\n-    }\n-\n-    public void requestEndOfStream(long timeoutMillis, String errorMsg) throws InterruptedException {\n-      request(1);\n-      expectCompletion(timeoutMillis, errorMsg);\n-    }\n-\n-    public List<T> requestNextElements(long elements) throws InterruptedException {\n-      request(elements);\n-      return nextElements(elements, env.defaultTimeoutMillis());\n-    }\n-\n-    public List<T> requestNextElements(long elements, long timeoutMillis) throws InterruptedException {\n-      request(elements);\n-      return nextElements(elements, timeoutMillis, String.format(\"Did not receive %d expected elements\", elements));\n-    }\n-\n-    public List<T> requestNextElements(long elements, long timeoutMillis, String errorMsg) throws InterruptedException {\n-      request(elements);\n-      return nextElements(elements, timeoutMillis, errorMsg);\n-    }\n-\n-    public T nextElement() throws InterruptedException {\n-      return nextElement(env.defaultTimeoutMillis());\n-    }\n-\n-    public T nextElement(long timeoutMillis) throws InterruptedException {\n-      return nextElement(timeoutMillis, \"Did not receive expected element\");\n-    }\n-\n-    public T nextElement(String errorMsg) throws InterruptedException {\n-      return nextElement(env.defaultTimeoutMillis(), errorMsg);\n-    }\n-\n-    public T nextElement(long timeoutMillis, String errorMsg) throws InterruptedException {\n-      return received.next(timeoutMillis, errorMsg);\n-    }\n-\n-    public Optional<T> nextElementOrEndOfStream() throws InterruptedException {\n-      return nextElementOrEndOfStream(env.defaultTimeoutMillis(), \"Did not receive expected stream completion\");\n-    }\n-\n-    public Optional<T> nextElementOrEndOfStream(long timeoutMillis) throws InterruptedException {\n-      return nextElementOrEndOfStream(timeoutMillis, \"Did not receive expected stream completion\");\n-    }\n-\n-    public Optional<T> nextElementOrEndOfStream(long timeoutMillis, String errorMsg) throws InterruptedException {\n-      return received.nextOrEndOfStream(timeoutMillis, errorMsg);\n-    }\n-\n-    public List<T> nextElements(long elements) throws InterruptedException {\n-      return nextElements(elements, env.defaultTimeoutMillis(), \"Did not receive expected element or completion\");\n-    }\n-\n-    public List<T> nextElements(long elements, String errorMsg) throws InterruptedException {\n-      return nextElements(elements, env.defaultTimeoutMillis(), errorMsg);\n-    }\n-\n-    public List<T> nextElements(long elements, long timeoutMillis) throws InterruptedException {\n-      return nextElements(elements, timeoutMillis, \"Did not receive expected element or completion\");\n-    }\n-\n-    public List<T> nextElements(long elements, long timeoutMillis, String errorMsg) throws InterruptedException {\n-      return received.nextN(elements, timeoutMillis, errorMsg);\n-    }\n-\n-    public void expectNext(T expected) throws InterruptedException {\n-      expectNext(expected, env.defaultTimeoutMillis());\n-    }\n-\n-    public void expectNext(T expected, long timeoutMillis) throws InterruptedException {\n-      T received = nextElement(timeoutMillis, \"Did not receive expected element on downstream\");\n-      if (!received.equals(expected)) {\n-        env.flop(String.format(\"Expected element %s on downstream but received %s\", expected, received));\n-      }\n-    }\n-\n-    public void expectCompletion() throws InterruptedException {\n-      expectCompletion(env.defaultTimeoutMillis(), \"Did not receive expected stream completion\");\n-    }\n-\n-    public void expectCompletion(long timeoutMillis) throws InterruptedException {\n-      expectCompletion(timeoutMillis, \"Did not receive expected stream completion\");\n-    }\n-\n-    public void expectCompletion(String errorMsg) throws InterruptedException {\n-      expectCompletion(env.defaultTimeoutMillis(), errorMsg);\n-    }\n-\n-    public void expectCompletion(long timeoutMillis, String errorMsg) throws InterruptedException {\n-      received.expectCompletion(timeoutMillis, errorMsg);\n-    }\n-\n-    public <E extends Throwable> void expectErrorWithMessage(Class<E> expected, String requiredMessagePart) throws Exception {\n-      expectErrorWithMessage(expected, Collections.singletonList(requiredMessagePart), env.defaultTimeoutMillis(), env.defaultPollTimeoutMillis());\n-    }\n-    public <E extends Throwable> void expectErrorWithMessage(Class<E> expected, List<String> requiredMessagePartAlternatives) throws Exception {\n-      expectErrorWithMessage(expected, requiredMessagePartAlternatives, env.defaultTimeoutMillis(), env.defaultPollTimeoutMillis());\n-    }\n-\n-    @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n-    public <E extends Throwable> void expectErrorWithMessage(Class<E> expected, String requiredMessagePart, long timeoutMillis) throws Exception {\n-      expectErrorWithMessage(expected, Collections.singletonList(requiredMessagePart), timeoutMillis);\n-    }\n-\n-    public <E extends Throwable> void expectErrorWithMessage(Class<E> expected, List<String> requiredMessagePartAlternatives, long timeoutMillis) throws Exception {\n-      expectErrorWithMessage(expected, requiredMessagePartAlternatives, timeoutMillis, timeoutMillis);\n-    }\n-\n-    public <E extends Throwable> void expectErrorWithMessage(Class<E> expected, List<String> requiredMessagePartAlternatives,\n-                                                             long totalTimeoutMillis, long pollTimeoutMillis) throws Exception {\n-      final E err = expectError(expected, totalTimeoutMillis, pollTimeoutMillis);\n-      final String message = err.getMessage();\n-\n-      boolean contains = false;\n-      for (String requiredMessagePart : requiredMessagePartAlternatives)\n-        if (message.contains(requiredMessagePart)) contains = true; \/\/ not short-circuting loop, it is expected to\n-      assertTrue(contains,\n-              String.format(\"Got expected exception [%s] but missing message part [%s], was: %s\",\n-                      err.getClass(), \"anyOf: \" + requiredMessagePartAlternatives, err.getMessage()));\n-    }\n-\n-    public <E extends Throwable> E expectError(Class<E> expected) throws Exception {\n-      return expectError(expected, env.defaultTimeoutMillis());\n-    }\n-\n-    public <E extends Throwable> E expectError(Class<E> expected, long timeoutMillis) throws Exception {\n-      return expectError(expected, timeoutMillis, env.defaultPollTimeoutMillis());\n-    }\n-\n-    public <E extends Throwable> E expectError(Class<E> expected, String errorMsg) throws Exception {\n-      return expectError(expected, env.defaultTimeoutMillis(), errorMsg);\n-    }\n-\n-    public <E extends Throwable> E expectError(Class<E> expected, long timeoutMillis, String errorMsg) throws Exception {\n-      return expectError(expected, timeoutMillis, env.defaultPollTimeoutMillis(), errorMsg);\n-    }\n-\n-    public <E extends Throwable> E expectError(Class<E> expected, long totalTimeoutMillis, long pollTimeoutMillis) throws Exception {\n-      return expectError(expected, totalTimeoutMillis, pollTimeoutMillis, String.format(\"Expected onError(%s)\", expected.getName()));\n-    }\n-\n-    public <E extends Throwable> E expectError(Class<E> expected, long totalTimeoutMillis, long pollTimeoutMillis,\n-                                               String errorMsg) throws Exception {\n-      return received.expectError(expected, totalTimeoutMillis, pollTimeoutMillis, errorMsg);\n-    }\n-\n-    public void expectNone() throws InterruptedException {\n-      expectNone(env.defaultNoSignalsTimeoutMillis());\n-    }\n-\n-    public void expectNone(String errMsgPrefix) throws InterruptedException {\n-      expectNone(env.defaultNoSignalsTimeoutMillis(), errMsgPrefix);\n-    }\n-\n-    public void expectNone(long withinMillis) throws InterruptedException {\n-      expectNone(withinMillis, \"Did not expect an element but got element\");\n-    }\n-\n-    public void expectNone(long withinMillis, String errMsgPrefix) throws InterruptedException {\n-      received.expectNone(withinMillis, errMsgPrefix);\n-    }\n-\n-  }\n-\n-  public static class ManualSubscriberWithSubscriptionSupport<T> extends ManualSubscriber<T> {\n-\n-    public ManualSubscriberWithSubscriptionSupport(TestEnvironment env) {\n-      super(env);\n-    }\n-\n-    @Override\n-    public void onNext(T element) {\n-      if (env.debugEnabled()) {\n-        env.debug(String.format(\"%s::onNext(%s)\", this, element));\n-      }\n-      if (subscription.isCompleted()) {\n-        super.onNext(element);\n-      } else {\n-        env.flop(String.format(\"Subscriber::onNext(%s) called before Subscriber::onSubscribe\", element));\n-      }\n-    }\n-\n-    @Override\n-    public void onComplete() {\n-      if (env.debugEnabled()) {\n-        env.debug(this + \"::onComplete()\");\n-      }\n-      if (subscription.isCompleted()) {\n-        super.onComplete();\n-      } else {\n-        env.flop(\"Subscriber::onComplete() called before Subscriber::onSubscribe\");\n-      }\n-    }\n-\n-    @Override\n-    public void onSubscribe(Subscription s) {\n-      if (env.debugEnabled()) {\n-        env.debug(String.format(\"%s::onSubscribe(%s)\", this, s));\n-      }\n-      if (!subscription.isCompleted()) {\n-        subscription.complete(s);\n-      } else {\n-        env.flop(\"Subscriber::onSubscribe called on an already-subscribed Subscriber\");\n-      }\n-    }\n-\n-    @Override\n-    public void onError(Throwable cause) {\n-      if (env.debugEnabled()) {\n-        env.debug(String.format(\"%s::onError(%s)\", this, cause));\n-      }\n-      if (subscription.isCompleted()) {\n-        super.onError(cause);\n-      } else {\n-        env.flop(cause, String.format(\"Subscriber::onError(%s) called before Subscriber::onSubscribe\", cause));\n-      }\n-    }\n-  }\n-\n-  \/**\n-   * Similar to {@link org.reactivestreams.tck.TestEnvironment.ManualSubscriberWithSubscriptionSupport}\n-   * but does not accumulate values signalled via <code>onNext<\/code>, thus it can not be used to assert\n-   * values signalled to this subscriber. Instead it may be used to quickly drain a given publisher.\n-   *\/\n-  public static class BlackholeSubscriberWithSubscriptionSupport<T>\n-    extends ManualSubscriberWithSubscriptionSupport<T> {\n-\n-    public BlackholeSubscriberWithSubscriptionSupport(TestEnvironment env) {\n-      super(env);\n-    }\n-\n-    @Override\n-    public void onNext(T element) {\n-      if (env.debugEnabled()) {\n-        env.debug(String.format(\"%s::onNext(%s)\", this, element));\n-      }\n-      if (!subscription.isCompleted()) {\n-        env.flop(String.format(\"Subscriber::onNext(%s) called before Subscriber::onSubscribe\", element));\n-      }\n-    }\n-\n-    @Override\n-    public T nextElement(long timeoutMillis, String errorMsg) throws InterruptedException {\n-      throw new RuntimeException(\"Can not expect elements from BlackholeSubscriber, use ManualSubscriber instead!\");\n-    }\n-\n-    @Override\n-    public List<T> nextElements(long elements, long timeoutMillis, String errorMsg) throws InterruptedException {\n-      throw new RuntimeException(\"Can not expect elements from BlackholeSubscriber, use ManualSubscriber instead!\");\n-    }\n-  }\n-\n-  public static class TestSubscriber<T> implements Subscriber<T> {\n-    final Promise<Subscription> subscription;\n-\n-    protected final TestEnvironment env;\n-\n-    public TestSubscriber(TestEnvironment env) {\n-      this.env = env;\n-      subscription = new Promise<Subscription>(env);\n-    }\n-\n-    @Override\n-    public void onError(Throwable cause) {\n-      env.flop(cause, String.format(\"Unexpected Subscriber::onError(%s)\", cause));\n-    }\n-\n-    @Override\n-    public void onComplete() {\n-      env.flop(\"Unexpected Subscriber::onComplete()\");\n-    }\n-\n-    @Override\n-    public void onNext(T element) {\n-      env.flop(String.format(\"Unexpected Subscriber::onNext(%s)\", element));\n-    }\n-\n-    @Override\n-    public void onSubscribe(Subscription subscription) {\n-      env.flop(String.format(\"Unexpected Subscriber::onSubscribe(%s)\", subscription));\n-    }\n-\n-    public void cancel() {\n-      if (subscription.isCompleted()) {\n-        subscription.value().cancel();\n-      } else {\n-        env.flop(\"Cannot cancel a subscription before having received it\");\n-      }\n-    }\n-  }\n-\n-  public static class ManualPublisher<T> implements Publisher<T> {\n-    protected final TestEnvironment env;\n-\n-    protected long pendingDemand = 0L;\n-    protected Promise<Subscriber<? super T>> subscriber;\n-\n-    protected final Receptacle<Long> requests;\n-\n-    protected final Latch cancelled;\n-\n-    public ManualPublisher(TestEnvironment env) {\n-      this.env = env;\n-      requests = new Receptacle<Long>(env);\n-      cancelled = new Latch(env);\n-      subscriber = new Promise<Subscriber<? super T>>(this.env);\n-    }\n-\n-    @Override\n-    public void subscribe(Subscriber<? super T> s) {\n-      if (!subscriber.isCompleted()) {\n-        subscriber.completeImmediatly(s);\n-\n-        Subscription subs = new Subscription() {\n-          @Override\n-          public void request(long elements) {\n-            requests.add(elements);\n-          }\n-\n-          @Override\n-          public void cancel() {\n-            cancelled.close();\n-          }\n-        };\n-        s.onSubscribe(subs);\n-\n-      } else {\n-        env.flop(\"TestPublisher doesn't support more than one Subscriber\");\n-      }\n-    }\n-\n-    public void sendNext(T element) {\n-      if (subscriber.isCompleted()) {\n-        subscriber.value().onNext(element);\n-      } else {\n-        env.flop(\"Cannot sendNext before having a Subscriber\");\n-      }\n-    }\n-\n-    public void sendCompletion() {\n-      if (subscriber.isCompleted()) {\n-        subscriber.value().onComplete();\n-      } else {\n-        env.flop(\"Cannot sendCompletion before having a Subscriber\");\n-      }\n-    }\n-\n-    public void sendError(Throwable cause) {\n-      if (subscriber.isCompleted()) {\n-        subscriber.value().onError(cause);\n-      } else {\n-        env.flop(\"Cannot sendError before having a Subscriber\");\n-      }\n-    }\n-\n-    public long expectRequest() throws InterruptedException {\n-      return expectRequest(env.defaultTimeoutMillis());\n-    }\n-\n-    public long expectRequest(long timeoutMillis) throws InterruptedException {\n-      long requested = requests.next(timeoutMillis, \"Did not receive expected `request` call\");\n-      if (requested <= 0) {\n-        return env.<Long>flopAndFail(String.format(\"Requests cannot be zero or negative but received request(%s)\", requested));\n-      } else {\n-        pendingDemand += requested;\n-        return requested;\n-      }\n-    }\n-\n-\n-    public long expectRequest(long timeoutMillis, String errorMessageAddendum) throws InterruptedException {\n-      long requested = requests.next(timeoutMillis, String.format(\"Did not receive expected `request` call. %s\", errorMessageAddendum));\n-      if (requested <= 0) {\n-        return env.<Long>flopAndFail(String.format(\"Requests cannot be zero or negative but received request(%s)\", requested));\n-      } else {\n-        pendingDemand += requested;\n-        return requested;\n-      }\n-    }\n-\n-    public void expectExactRequest(long expected) throws InterruptedException {\n-      expectExactRequest(expected, env.defaultTimeoutMillis());\n-    }\n-\n-    public void expectExactRequest(long expected, long timeoutMillis) throws InterruptedException {\n-      long requested = expectRequest(timeoutMillis);\n-      if (requested != expected) {\n-        env.flop(String.format(\"Received `request(%d)` on upstream but expected `request(%d)`\", requested, expected));\n-      }\n-      pendingDemand += requested;\n-    }\n-\n-    public void expectNoRequest() throws InterruptedException {\n-      expectNoRequest(env.defaultTimeoutMillis());\n-    }\n-\n-    public void expectNoRequest(long timeoutMillis) throws InterruptedException {\n-      requests.expectNone(timeoutMillis, \"Received an unexpected call to: request: \");\n-    }\n-\n-    public void expectCancelling() throws InterruptedException {\n-      expectCancelling(env.defaultTimeoutMillis());\n-    }\n-\n-    public void expectCancelling(long timeoutMillis) throws InterruptedException {\n-      cancelled.expectClose(timeoutMillis, \"Did not receive expected cancelling of upstream subscription\");\n-    }\n-\n-    public boolean isCancelled() throws InterruptedException {\n-      return cancelled.isClosed();\n-    }\n-  }\n-\n-  \/**\n-   * Like a CountDownLatch, but resettable and with some convenience methods\n-   *\/\n-  public static class Latch {\n-    private final TestEnvironment env;\n-    volatile private CountDownLatch countDownLatch = new CountDownLatch(1);\n-\n-    public Latch(TestEnvironment env) {\n-      this.env = env;\n-    }\n-\n-    public void reOpen() {\n-      countDownLatch = new CountDownLatch(1);\n-    }\n-\n-    public boolean isClosed() {\n-      return countDownLatch.getCount() == 0;\n-    }\n-\n-    public void close() {\n-      countDownLatch.countDown();\n-    }\n-\n-    public void assertClosed(String openErrorMsg) {\n-      if (!isClosed()) {\n-        env.flop(new ExpectedClosedLatchException(openErrorMsg));\n-      }\n-    }\n-\n-    public void assertOpen(String closedErrorMsg) {\n-      if (isClosed()) {\n-        env.flop(new ExpectedOpenLatchException(closedErrorMsg));\n-      }\n-    }\n-\n-    public void expectClose(String notClosedErrorMsg) throws InterruptedException {\n-      expectClose(env.defaultTimeoutMillis(), notClosedErrorMsg);\n-    }\n-\n-    public void expectClose(long timeoutMillis, String notClosedErrorMsg) throws InterruptedException {\n-      countDownLatch.await(timeoutMillis, TimeUnit.MILLISECONDS);\n-      if (countDownLatch.getCount() > 0) {\n-        env.flop(String.format(\"%s within %d ms\", notClosedErrorMsg, timeoutMillis));\n-      }\n-    }\n-\n-    static final class ExpectedOpenLatchException extends RuntimeException {\n-      public ExpectedOpenLatchException(String message) {\n-        super(message);\n-      }\n-    }\n-\n-    static final class ExpectedClosedLatchException extends RuntimeException {\n-      public ExpectedClosedLatchException(String message) {\n-        super(message);\n-      }\n-    }\n-\n-  }\n-\n-  \/\/ simple promise for *one* value, which cannot be reset\n-  public static class Promise<T> {\n-    private final TestEnvironment env;\n-\n-    public static <T> Promise<T> completed(TestEnvironment env, T value) {\n-      Promise<T> promise = new Promise<T>(env);\n-      promise.completeImmediatly(value);\n-      return promise;\n-    }\n-\n-    public Promise(TestEnvironment env) {\n-      this.env = env;\n-    }\n-\n-    private ArrayBlockingQueue<T> abq = new ArrayBlockingQueue<T>(1);\n-    private AtomicReference<T> _value = new AtomicReference<T>();\n-\n-    public T value() {\n-      final T value = _value.get();\n-      if (value != null) {\n-        return value;\n-      } else {\n-        env.flop(\"Cannot access promise value before completion\");\n-        return null;\n-      }\n-    }\n-\n-    public boolean isCompleted() {\n-      return _value.get() != null;\n-    }\n-\n-    \/**\n-     * Allows using expectCompletion to await for completion of the value and complete it _then_\n-     *\/\n-    public void complete(T value) {\n-      if (_value.compareAndSet(null, value)) {\n-        \/\/ we add the value to the queue such to wake up any expectCompletion which was triggered before complete() was called\n-        abq.add(value);\n-      } else {\n-        env.flop(String.format(\"Cannot complete a promise more than once! Present value: %s, attempted to set: %s\", _value.get(), value));\n-      }\n-    }\n-\n-    \/**\n-     * Same as complete.\n-     *\n-     * Keeping this method for binary compatibility.\n-     *\/\n-    public void completeImmediatly(T value) {\n-      complete(value);\n-    }\n-\n-    public void expectCompletion(long timeoutMillis, String errorMsg) throws InterruptedException {\n-      if (!isCompleted()) {\n-        T val = abq.poll(timeoutMillis, TimeUnit.MILLISECONDS);\n-\n-        if (val == null) {\n-          env.flop(String.format(\"%s within %d ms\", errorMsg, timeoutMillis));\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ a \"Promise\" for multiple values, which also supports \"end-of-stream reached\"\n-  public static class Receptacle<T> {\n-    final int QUEUE_SIZE = 2 * TEST_BUFFER_SIZE;\n-    private final TestEnvironment env;\n-\n-    private final ArrayBlockingQueue<Optional<T>> abq = new ArrayBlockingQueue<Optional<T>>(QUEUE_SIZE);\n-\n-    private final Latch completedLatch;\n-\n-    Receptacle(TestEnvironment env) {\n-      this.env = env;\n-      this.completedLatch = new Latch(env);\n-    }\n-\n-    public void add(T value) {\n-      completedLatch.assertOpen(String.format(\"Unexpected element %s received after stream completed\", value));\n-\n-      abq.add(Optional.of(value));\n-    }\n-\n-    public void complete() {\n-      completedLatch.assertOpen(\"Unexpected additional complete signal received!\");\n-      completedLatch.close();\n-\n-      abq.add(Optional.<T>empty());\n-    }\n-\n-    public T next(long timeoutMillis, String errorMsg) throws InterruptedException {\n-      Optional<T> value = abq.poll(timeoutMillis, TimeUnit.MILLISECONDS);\n-\n-      if (value == null) {\n-        return env.flopAndFail(String.format(\"%s within %d ms\", errorMsg, timeoutMillis));\n-      } else if (value.isDefined()) {\n-        return value.get();\n-      } else {\n-        return env.flopAndFail(\"Expected element but got end-of-stream\");\n-      }\n-    }\n-\n-    public Optional<T> nextOrEndOfStream(long timeoutMillis, String errorMsg) throws InterruptedException {\n-      Optional<T> value = abq.poll(timeoutMillis, TimeUnit.MILLISECONDS);\n-\n-      if (value == null) {\n-        env.flop(String.format(\"%s within %d ms\", errorMsg, timeoutMillis));\n-        return Optional.empty();\n-      }\n-\n-      return value;\n-    }\n-\n-    \/**\n-     * @param timeoutMillis total timeout time for awaiting all {@code elements} number of elements\n-     *\/\n-    public List<T> nextN(long elements, long timeoutMillis, String errorMsg) throws InterruptedException {\n-      List<T> result = new LinkedList<T>();\n-      long remaining = elements;\n-      long deadline = System.currentTimeMillis() + timeoutMillis;\n-      while (remaining > 0) {\n-        long remainingMillis = deadline - System.currentTimeMillis();\n-\n-        result.add(next(remainingMillis, errorMsg));\n-        remaining--;\n-      }\n-\n-      return result;\n-    }\n-\n-\n-    public void expectCompletion(long timeoutMillis, String errorMsg) throws InterruptedException {\n-      Optional<T> value = abq.poll(timeoutMillis, TimeUnit.MILLISECONDS);\n-\n-      if (value == null) {\n-        env.flop(String.format(\"%s within %d ms\", errorMsg, timeoutMillis));\n-      } else if (value.isDefined()) {\n-        env.flop(String.format(\"Expected end-of-stream but got element [%s]\", value.get()));\n-      } \/\/ else, ok\n-    }\n-\n-    \/**\n-     * @deprecated Deprecated in favor of {@link #expectError(Class, long, long, String)}.\n-     *\/\n-    @Deprecated\n-    public <E extends Throwable> E expectError(Class<E> clazz, long timeoutMillis, String errorMsg) throws Exception {\n-      return expectError(clazz, timeoutMillis, timeoutMillis, errorMsg);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    final <E extends Throwable> E expectError(Class<E> clazz, final long totalTimeoutMillis,\n-                                              long pollTimeoutMillis,\n-                                              String errorMsg) throws Exception {\n-      long totalTimeoutRemainingNs = MILLISECONDS.toNanos(totalTimeoutMillis);\n-      long timeStampANs = System.nanoTime();\n-      long timeStampBNs;\n-\n-      for (;;) {\n-        Thread.sleep(Math.min(pollTimeoutMillis, NANOSECONDS.toMillis(totalTimeoutRemainingNs)));\n-\n-        if (env.asyncErrors.isEmpty()) {\n-          timeStampBNs = System.nanoTime();\n-          totalTimeoutRemainingNs =- timeStampBNs - timeStampANs;\n-          timeStampANs = timeStampBNs;\n-\n-          if (totalTimeoutRemainingNs <= 0) {\n-            return env.flopAndFail(String.format(\"%s within %d ms\", errorMsg, totalTimeoutMillis));\n-          }\n-        } else {\n-          \/\/ ok, there was an expected error\n-          Throwable thrown = env.asyncErrors.remove(0);\n-\n-          if (clazz.isInstance(thrown)) {\n-            return (E) thrown;\n-          } else {\n-\n-            return env.flopAndFail(String.format(\"%s within %d ms; Got %s but expected %s\",\n-                    errorMsg, totalTimeoutMillis, thrown.getClass().getCanonicalName(), clazz.getCanonicalName()));\n-          }\n-        }\n-      }\n-    }\n-\n-    public void expectNone(long withinMillis, String errorMsgPrefix) throws InterruptedException {\n-      Thread.sleep(withinMillis);\n-      Optional<T> value = abq.poll();\n-\n-      if (value == null) {\n-        \/\/ ok\n-      } else if (value.isDefined()) {\n-        env.flop(String.format(\"%s [%s]\", errorMsgPrefix, value.get()));\n-      } else {\n-        env.flop(\"Expected no element but got end-of-stream\");\n-      }\n-    }\n-  }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/TestEnvironment.java","additions":0,"deletions":1168,"binary":false,"changes":1168,"status":"deleted"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck;\n-\n-import org.reactivestreams.Publisher;\n-import org.reactivestreams.tck.flow.support.Function;\n-import org.reactivestreams.tck.flow.support.HelperPublisher;\n-import org.reactivestreams.tck.flow.support.InfiniteHelperPublisher;\n-\n-import java.util.concurrent.ExecutorService;\n-\n-\/**\n- * Type which is able to create elements based on a seed {@code id} value.\n- * <p>\n- * Simplest implementations will simply return the incoming id as the element.\n- *\n- * @param <T> type of element to be delivered to the Subscriber\n- *\/\n-public abstract class WithHelperPublisher<T> {\n-\n-  \/** ExecutorService to be used by the provided helper {@link org.reactivestreams.Publisher} *\/\n-  public abstract ExecutorService publisherExecutorService();\n-\n-  \/**\n-   * Implement this method to match your expected element type.\n-   * In case of implementing a simple Subscriber which is able to consume any kind of element simply return the\n-   * incoming {@code element} element.\n-   * <p>\n-   * Sometimes the Subscriber may be limited in what type of element it is able to consume, this you may have to implement\n-   * this method such that the emitted element matches the Subscribers requirements. Simplest implementations would be\n-   * to simply pass in the {@code element} as payload of your custom element, such as appending it to a String or other identifier.\n-   * <p>\n-   * <b>Warning:<\/b> This method may be called concurrently by the helper publisher, thus it should be implemented in a\n-   * thread-safe manner.\n-   *\n-   * @return element of the matching type {@code T} that will be delivered to the tested Subscriber\n-   *\/\n-  public abstract T createElement(int element);\n-\n-  \/**\n-   * Helper method required for creating the Publisher to which the tested Subscriber will be subscribed and tested against.\n-   * <p>\n-   * By default an <b>asynchronously signalling Publisher<\/b> is provided, which will use {@link #createElement(int)}\n-   * to generate elements type your Subscriber is able to consume.\n-   * <p>\n-   * Sometimes you may want to implement your own custom custom helper Publisher - to validate behaviour of a Subscriber\n-   * when facing a synchronous Publisher for example. If you do, it MUST emit the exact number of elements asked for\n-   * (via the {@code elements} parameter) and MUST also must treat the following numbers of elements in these specific ways:\n-   * <ul>\n-   *   <li>\n-   *     If {@code elements} is {@code Long.MAX_VALUE} the produced stream must be infinite.\n-   *   <\/li>\n-   *   <li>\n-   *     If {@code elements} is {@code 0} the {@code Publisher} should signal {@code onComplete} immediatly.\n-   *     In other words, it should represent a \"completed stream\".\n-   *   <\/li>\n-   * <\/ul>\n-   *\/\n-  @SuppressWarnings(\"unchecked\")\n-  public Publisher<T> createHelperPublisher(long elements) {\n-    final Function<Integer, T> mkElement = new Function<Integer, T>() {\n-      @Override public T apply(Integer id) throws Throwable {\n-        return createElement(id);\n-      }\n-    };\n-\n-    if (elements > Integer.MAX_VALUE) return new InfiniteHelperPublisher(mkElement, publisherExecutorService());\n-    else return new HelperPublisher(0, (int) elements, mkElement, publisherExecutorService());\n-  }\n-\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/WithHelperPublisher.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow;\n-\n-import org.reactivestreams.Publisher;\n-import org.reactivestreams.FlowAdapters;\n-import org.reactivestreams.tck.PublisherVerification;\n-import org.reactivestreams.tck.TestEnvironment;\n-\n-import java.util.concurrent.Flow;\n-\n-\/**\n- * Provides tests for verifying a Java 9+ {@link java.util.concurrent.Flow.Publisher} specification rules.\n- *\n- * @see java.util.concurrent.Flow.Publisher\n- *\/\n-public abstract class FlowPublisherVerification<T> extends PublisherVerification<T> {\n-\n-  public FlowPublisherVerification(TestEnvironment env, long publisherReferenceGCTimeoutMillis) {\n-    super(env, publisherReferenceGCTimeoutMillis);\n-  }\n-\n-  public FlowPublisherVerification(TestEnvironment env) {\n-    super(env);\n-  }\n-\n-  @Override\n-  final public Publisher<T> createPublisher(long elements) {\n-    final Flow.Publisher<T> flowPublisher = createFlowPublisher(elements);\n-    return FlowAdapters.toPublisher(flowPublisher);\n-  }\n-  \/**\n-   * This is the main method you must implement in your test incarnation.\n-   * It must create a Publisher for a stream with exactly the given number of elements.\n-   * If `elements` is `Long.MAX_VALUE` the produced stream must be infinite.\n-   *\/\n-  public abstract Flow.Publisher<T> createFlowPublisher(long elements);\n-\n-  @Override\n-  final public Publisher<T> createFailedPublisher() {\n-    final Flow.Publisher<T> failed = createFailedFlowPublisher();\n-    if (failed == null) return null; \/\/ because `null` means \"SKIP\" in createFailedPublisher\n-    else return FlowAdapters.toPublisher(failed);\n-  }\n-  \/**\n-   * By implementing this method, additional TCK tests concerning a \"failed\" publishers will be run.\n-   *\n-   * The expected behaviour of the {@link Flow.Publisher} returned by this method is hand out a subscription,\n-   * followed by signalling {@code onError} on it, as specified by Rule 1.9.\n-   *\n-   * If you ignore these additional tests, return {@code null} from this method.\n-   *\/\n-  public abstract Flow.Publisher<T> createFailedFlowPublisher();\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/FlowPublisherVerification.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow;\n-\n-import org.reactivestreams.FlowAdapters;\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-import org.reactivestreams.tck.SubscriberBlackboxVerification;\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.support.SubscriberBlackboxVerificationRules;\n-\n-import java.util.concurrent.Flow;\n-\n-\/**\n- * Provides tests for verifying {@link java.util.concurrent.Flow.Subscriber} and {@link java.util.concurrent.Flow.Subscription}\n- * specification rules, without any modifications to the tested implementation (also known as \"Black Box\" testing).\n- *\n- * This verification is NOT able to check many of the rules of the spec, and if you want more\n- * verification of your implementation you'll have to implement {@code org.reactivestreams.tck.SubscriberWhiteboxVerification}\n- * instead.\n- *\n- * @see java.util.concurrent.Flow.Subscriber\n- * @see java.util.concurrent.Flow.Subscription\n- *\/\n-public abstract class FlowSubscriberBlackboxVerification<T> extends SubscriberBlackboxVerification<T>\n-  implements SubscriberBlackboxVerificationRules {\n-\n-  protected FlowSubscriberBlackboxVerification(TestEnvironment env) {\n-    super(env);\n-  }\n-\n-  @Override\n-  public final void triggerRequest(Subscriber<? super T> subscriber) {\n-    triggerFlowRequest(FlowAdapters.toFlowSubscriber(subscriber));\n-  }\n-  \/**\n-   * Override this method if the {@link java.util.concurrent.Flow.Subscriber} implementation you are verifying\n-   * needs an external signal before it signals demand to its Publisher.\n-   *\n-   * By default this method does nothing.\n-   *\/\n-  public void triggerFlowRequest(Flow.Subscriber<? super T> subscriber) {\n-    \/\/ this method is intentionally left blank\n-  }\n-\n-  @Override\n-  public final Subscriber<T> createSubscriber() {\n-    return FlowAdapters.<T>toSubscriber(createFlowSubscriber());\n-  }\n-  \/**\n-   * This is the main method you must implement in your test incarnation.\n-   * It must create a new {@link Flow.Subscriber} instance to be subjected to the testing logic.\n-   *\/\n-  abstract public Flow.Subscriber<T> createFlowSubscriber();\n-\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/FlowSubscriberBlackboxVerification.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow;\n-\n-import org.reactivestreams.FlowAdapters;\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.tck.SubscriberWhiteboxVerification;\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.support.SubscriberWhiteboxVerificationRules;\n-\n-import java.util.concurrent.Flow;\n-\n-\/**\n- * Provides whitebox style tests for verifying {@link java.util.concurrent.Flow.Subscriber}\n- * and {@link java.util.concurrent.Flow.Subscription} specification rules.\n- *\n- * @see java.util.concurrent.Flow.Subscriber\n- * @see java.util.concurrent.Flow.Subscription\n- *\/\n-public abstract class FlowSubscriberWhiteboxVerification<T> extends SubscriberWhiteboxVerification<T>\n-  implements SubscriberWhiteboxVerificationRules {\n-\n-  protected FlowSubscriberWhiteboxVerification(TestEnvironment env) {\n-    super(env);\n-  }\n-\n-  @Override\n-  final public Subscriber<T> createSubscriber(WhiteboxSubscriberProbe<T> probe) {\n-    return FlowAdapters.toSubscriber(createFlowSubscriber(probe));\n-  }\n-  \/**\n-   * This is the main method you must implement in your test incarnation.\n-   * It must create a new {@link org.reactivestreams.Subscriber} instance to be subjected to the testing logic.\n-   *\n-   * In order to be meaningfully testable your Subscriber must inform the given\n-   * `WhiteboxSubscriberProbe` of the respective events having been received.\n-   *\/\n-  protected abstract Flow.Subscriber<T> createFlowSubscriber(WhiteboxSubscriberProbe<T> probe);\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/FlowSubscriberWhiteboxVerification.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow;\n-\n-import org.reactivestreams.*;\n-import org.reactivestreams.tck.IdentityProcessorVerification;\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.support.SubscriberWhiteboxVerificationRules;\n-import org.reactivestreams.tck.flow.support.PublisherVerificationRules;\n-\n-import java.util.concurrent.Flow;\n-\n-public abstract class IdentityFlowProcessorVerification<T> extends IdentityProcessorVerification<T>\n-  implements SubscriberWhiteboxVerificationRules, PublisherVerificationRules {\n-\n-  public IdentityFlowProcessorVerification(TestEnvironment env) {\n-    super(env);\n-  }\n-\n-  public IdentityFlowProcessorVerification(TestEnvironment env, long publisherReferenceGCTimeoutMillis) {\n-    super(env, publisherReferenceGCTimeoutMillis);\n-  }\n-\n-  public IdentityFlowProcessorVerification(TestEnvironment env, long publisherReferenceGCTimeoutMillis, int processorBufferSize) {\n-    super(env, publisherReferenceGCTimeoutMillis, processorBufferSize);\n-  }\n-\n-  \/**\n-   * By implementing this method, additional TCK tests concerning a \"failed\" Flow publishers will be run.\n-   *\n-   * The expected behaviour of the {@link Flow.Publisher} returned by this method is hand out a subscription,\n-   * followed by signalling {@code onError} on it, as specified by Rule 1.9.\n-   *\n-   * If you want to ignore these additional tests, return {@code null} from this method.\n-   *\/\n-  protected abstract Flow.Publisher<T> createFailedFlowPublisher();\n-\n-  \/**\n-   * This is the main method you must implement in your test incarnation.\n-   * It must create a {@link Flow.Processor}, which simply forwards all stream elements from its upstream\n-   * to its downstream. It must be able to internally buffer the given number of elements.\n-   *\n-   * @param bufferSize number of elements the processor is required to be able to buffer.\n-   *\/\n-  protected abstract Flow.Processor<T,T> createIdentityFlowProcessor(int bufferSize);\n-\n-  @Override\n-  public final Processor<T, T> createIdentityProcessor(int bufferSize) {\n-    return FlowAdapters.toProcessor(createIdentityFlowProcessor(bufferSize));\n-  }\n-\n-  @Override\n-  public final Publisher<T> createFailedPublisher() {\n-    Flow.Publisher<T> failed = createFailedFlowPublisher();\n-    if (failed == null) return null; \/\/ because `null` means \"SKIP\" in createFailedPublisher\n-    else return FlowAdapters.toPublisher(failed);\n-  }\n-\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/IdentityFlowProcessorVerification.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -1,28 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow.support;\n-\n-public interface Function<In, Out> {\n-  public Out apply(In in) throws Throwable;\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/support\/Function.java","additions":0,"deletions":28,"binary":false,"changes":28,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow.support;\n-\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.concurrent.Executor;\n-\n-import org.reactivestreams.example.unicast.AsyncIterablePublisher;\n-\n-public class HelperPublisher<T> extends AsyncIterablePublisher<T> {\n-\n-    public HelperPublisher(final int from, final int to, final Function<Integer, T> create, final Executor executor) {\n-        super(new Iterable<T>() {\n-          { if(from > to) throw new IllegalArgumentException(\"from must be equal or greater than to!\"); }\n-          @Override public Iterator<T> iterator() {\n-            return new Iterator<T>() {\n-              private int at = from;\n-              @Override public boolean hasNext() { return at < to; }\n-              @Override public T next() {\n-                if (!hasNext()) return Collections.<T>emptyList().iterator().next();\n-                else try {\n-                  return create.apply(at++);\n-                } catch (Throwable t) {\n-                  throw new IllegalStateException(String.format(\"Failed to create element for id %d!\", at - 1), t);\n-                }\n-              }\n-              @Override public void remove() { throw new UnsupportedOperationException(); }\n-            };\n-          }\n-        }, executor);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/support\/HelperPublisher.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow.support;\n-\n-import org.reactivestreams.example.unicast.AsyncIterablePublisher;\n-\n-import java.util.Iterator;\n-import java.util.concurrent.Executor;\n-\n-public class InfiniteHelperPublisher<T> extends AsyncIterablePublisher<T> {\n-\n-    public InfiniteHelperPublisher(final Function<Integer, T> create, final Executor executor) {\n-        super(new Iterable<T>() {\n-          @Override public Iterator<T> iterator() {\n-            return new Iterator<T>() {\n-              private int at = 0;\n-\n-              @Override public boolean hasNext() { return true; }\n-              @Override public T next() {\n-                try {\n-                  return create.apply(at++); \/\/ Wraps around on overflow\n-                } catch (Throwable t) {\n-                  throw new IllegalStateException(\n-                    String.format(\"Failed to create element in %s for id %s!\", getClass().getSimpleName(), at - 1), t);\n-                }\n-              }\n-              @Override public void remove() { throw new UnsupportedOperationException(); }\n-            };\n-          }\n-        }, executor);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/support\/InfiniteHelperPublisher.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow.support;\n-\n-\n-\/**\n- * Copy of scala.control.util.NonFatal in order to not depend on scala-library\n- *\/\n-public class NonFatal {\n-  private NonFatal() {\n-    \/\/ no instances, please.\n-  }\n-\n-  \/**\n-   * Returns true if the provided `Throwable` is to be considered non-fatal, or false if it is to be considered fatal\n-   *\n-   * @param t throwable to be matched for fatal-ness\n-   * @return true if is a non-fatal throwable, false otherwise\n-   *\/\n-  public static boolean isNonFatal(Throwable t) {\n-    if (t instanceof StackOverflowError) {\n-      \/\/ StackOverflowError ok even though it is a VirtualMachineError\n-      return true;\n-    } else if (t instanceof VirtualMachineError ||\n-        t instanceof ThreadDeath ||\n-        t instanceof InterruptedException ||\n-        t instanceof LinkageError) {\n-      \/\/ VirtualMachineError includes OutOfMemoryError and other fatal errors\n-      return false;\n-    } else {\n-      return true;\n-    }\n-  }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/support\/NonFatal.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow.support;\n-\n-import java.util.NoSuchElementException;\n-\n-\/\/ simplest possible version of Scala's Option type\n-public abstract class Optional<T> {\n-\n-  private static final Optional<Object> NONE = new Optional<Object>() {\n-    @Override\n-    public Object get() {\n-      throw new NoSuchElementException(\".get call on None!\");\n-    }\n-\n-    @Override\n-    public boolean isEmpty() {\n-      return true;\n-    }\n-  };\n-\n-  private Optional() {\n-  }\n-\n-  @SuppressWarnings(\"unchecked\")\n-  public static <T> Optional<T> empty() {\n-    return (Optional<T>) NONE;\n-  }\n-\n-  @SuppressWarnings(\"unchecked\")\n-  public static <T> Optional<T> of(T it) {\n-    if (it == null) return (Optional<T>) Optional.NONE;\n-    else return new Some(it);\n-  }\n-\n-  public abstract T get();\n-\n-  public abstract boolean isEmpty();\n-\n-  public boolean isDefined() {\n-    return !isEmpty();\n-  }\n-\n-  public static class Some<T> extends Optional<T> {\n-    private final T value;\n-\n-    Some(T value) {\n-      this.value = value;\n-    }\n-\n-    @Override\n-    public T get() {\n-      return value;\n-    }\n-\n-    @Override\n-    public boolean isEmpty() {\n-      return false;\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return String.format(\"Some(%s)\", value);\n-    }\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return \"None\";\n-  }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/support\/Optional.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -1,658 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow.support;\n-\n-\/**\n- * Internal TCK use only.\n- * Add \/ Remove tests for PublisherVerification here to make sure that they arre added\/removed in the other places.\n- *\/\n-public interface PublisherVerificationRules {\n-  \/**\n-   * Validates that the override of {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()}\n-   * returns a non-negative value.\n-   *\/\n-  void required_validate_maxElementsFromPublisher() throws Exception;\n-  \/**\n-   * Validates that the override of {@link org.reactivestreams.tck.PublisherVerification#boundedDepthOfOnNextAndRequestRecursion()}\n-   * returns a positive value.\n-   *\/\n-  void required_validate_boundedDepthOfOnNextAndRequestRecursion() throws Exception;\n-  \/**\n-   * Asks for a {@code Publisher} that should emit exactly one item and complete (both within a\n-   * timeout specified by {@link org.reactivestreams.tck.TestEnvironment#defaultTimeoutMillis()})\n-   * in response to a request(1).\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} returns zero.\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code Publisher.subscribe(Subscriber)} method has actual implementation,<\/li>\n-   * <li>in the {@code Publisher.subscribe(Subscriber)} method, if there is an upstream {@code Publisher},\n-   * that {@code Publisher} is actually subscribed to,<\/li>\n-   * <li>if the {@code Publisher} is part of a chain, all elements actually issue a {@code request()} call\n-   * in response to the test subscriber or by default to their upstream,<\/li>\n-   * <li>in the {@code Publisher.subscribe(Subscriber)} method, the {@code Subscriber.onSubscribe} is called\n-   * as part of the preparation process (usually before subscribing to other {@code Publisher}s),<\/li>\n-   * <li>if the {@code Publisher} implementation works for a consumer that calls {@code request(1)},<\/li>\n-   * <li>if the {@code Publisher} implementation is able to emit an {@code onComplete} without requests,<\/li>\n-   * <li>that the {@code Publisher} implementation does not emit more than the allowed elements (exactly one).<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_createPublisher1MustProduceAStreamOfExactly1Element() throws Throwable;\n-  \/**\n-   * Asks for a {@code Publisher} that should emit exactly three items and complete (all within a\n-   * timeout specified by {@link org.reactivestreams.tck.TestEnvironment#defaultTimeoutMillis()}).\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.\n-   * <p>\n-   * The tests requests one-by-one and verifies each single response item arrives in time.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code Publisher.subscribe(Subscriber)} method has actual implementation,<\/li>\n-   * <li>in the {@code Publisher.subscribe(Subscriber)} method, if there is an upstream {@code Publisher},\n-   * that {@code Publisher} is actually subscribed to,<\/li>\n-   * <li>if the {@code Publisher} is part of a chain, all elements actually issue a {@code request()} call\n-   * in response to the test subscriber or by default to their upstream,<\/li>\n-   * <li>in the {@code Publisher.subscribe(Subscriber)} method, the {@code Subscriber.onSubscribe} is called\n-   * as part of the preparation process (usually before subscribing to other {@code Publisher}s),<\/li>\n-   * <li>if the {@code Publisher} implementation works for a subscriber that calls {@code request(1)} after consuming an item,<\/li>\n-   * <li>if the {@code Publisher} implementation is able to emit an {@code onComplete} without requests.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_createPublisher3MustProduceAStreamOfExactly3Elements() throws Throwable;\n-  \/**\n-   * Asks for a {@code Publisher} that responds to a request pattern of 0 (not requesting upfront), 1, 1 and 2\n-   * in a timely manner.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.1'>1.1<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 5.\n-   * <p>\n-   * This test ensures that the {@code Publisher} implementation correctly responds to {@code request()} calls that in\n-   * total are less than the number of elements this {@code Publisher} could emit (thus the completion event won't be emitted).\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>if the {@code Publisher} implementation considers the cumulative request amount it receives,<\/li>\n-   * <li>if the {@code Publisher} doesn't lose any {@code request()} signal and the state transition from idle -&gt; emitting or emitting -&gt; keep emitting works properly.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec101_subscriptionRequestMustResultInTheCorrectNumberOfProducedElements() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} and verifies that requesting once and with more than the length (but bounded) results in the\n-   * correct number of items to be emitted (i.e., length 3 and request 10) followed by an {@code onComplete} signal.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.2'>1.2<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.\n-   * <p>\n-   * This test ensures that the {@code Publisher} implementation can deal with larger requests than the number of items it can produce.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec102_maySignalLessThanRequestedAndTerminateSubscription() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (i.e., length 10), repeatedly subscribes to this {@code Publisher}, requests items\n-   * one by one and verifies the {@code Publisher} calls the {@code onXXX} methods non-overlappingly.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.3'>1.3<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 10.\n-   * <p>\n-   * Note that this test is probabilistic, that is, may not capture any concurrent invocation in a {@code Publisher} implementation.\n-   * Note also that this test is sensitive to cases when a {@code request()} call in {@code onSubscribe()} triggers an asynchronous\n-   * call to the other {@code onXXX} methods. In contrast, the test allows synchronous call chain of\n-   * {@code onSubscribe -> request -> onNext}.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>if a {@code request()} call from {@code onSubscribe()} could trigger an asynchronous call to {@code onNext()} and if so, make sure\n-   * such {@code request()} calls are deferred until the call to {@code onSubscribe()} returns normally.<\/li>\n-   * <\/ul>\n-   *\/\n-  void stochastic_spec103_mustSignalOnMethodsSequentially() throws Throwable;\n-  \/**\n-   * Asks for an error {@code Publisher} that should call {@code onSubscribe} exactly once\n-   * followed by a single call to {@code onError()} without receiving any requests and otherwise\n-   * not throwing any exception.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.4'>1.4<\/a>\n-   * <p>\n-   * The test is not executed if {@code PublisherVerification.createErrorPublisher()} returns null.\n-   * <p>\n-   * If this test fails, the following could be checked within the error {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code Publisher.subscribe(Subscriber)} method has actual implementation,<\/li>\n-   * <li>in the {@code Publisher.subscribe(Subscriber)} method, if there is an upstream {@code Publisher},\n-   * that {@code Publisher} is actually subscribed to,<\/li>\n-   * <li>if the {@code Publisher} implementation does signal an {@code onSubscribe} before signalling {@code onError},<\/li>\n-   * <li>if the {@code Publisher} implementation is able to emit an {@code onError} without requests,<\/li>\n-   * <li>if the {@code Publisher} is non-empty as this test requires a {@code Publisher} to signal an\n-   * {@code onError} eagerly.<\/li>\n-   * <\/ul>\n-   *\/\n-  void optional_spec104_mustSignalOnErrorWhenFails() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (i.e., length 3) and verifies, after requesting one by one, the sequence\n-   * completes normally.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.5'>1.5<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.\n-   * <p>\n-   * Note that the tests requests 1 after the items have been received and before expecting an {@code onComplete} signal.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec105_mustSignalOnCompleteWhenFiniteStreamTerminates() throws Throwable;\n-  \/**\n-   * Asks for an empty {@code Publisher} (i.e., length 0) and verifies it completes in a timely manner.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.5'>1.5<\/a>\n-   * <p>\n-   * Note that the tests requests 1 before expecting an {@code onComplete} signal.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>if the {@code Publisher} is non-empty as this test requires a {@code Publisher} without items.<\/li>\n-   * <\/ul>\n-   *\/\n-  void optional_spec105_emptyStreamMustTerminateBySignallingOnComplete() throws Throwable;\n-  \/**\n-   * Currently, this test is skipped because it is unclear this rule can be effectively checked\n-   * on a {@code Publisher} instance without looking into or hooking into the implementation of it.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.6'>1.6<\/a>\n-   *\/\n-  void untested_spec106_mustConsiderSubscriptionCancelledAfterOnErrorOrOnCompleteHasBeenCalled() throws Throwable;\n-  \/**\n-   * Asks for a single-element {@code Publisher} and checks if requesting after the terminal event doesn't\n-   * lead to more items or terminal signals to be emitted.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.7'>1.7<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 1.\n-   * <p>\n-   * The tests requests more items than the expected {@code Publisher} length upfront and some more items after its completion.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>the indication for the terminal state is properly persisted and a request call can't trigger emission of more items or another\n-   * terminal signal.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec107_mustNotEmitFurtherSignalsOnceOnCompleteHasBeenSignalled() throws Throwable;\n-  \/**\n-   * Currently, this test is skipped, although it is possible to validate an error {@code Publisher} along\n-   * the same lines as {@link #required_spec107_mustNotEmitFurtherSignalsOnceOnCompleteHasBeenSignalled()}.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.7'>1.7<\/a>\n-   *\/\n-  void untested_spec107_mustNotEmitFurtherSignalsOnceOnErrorHasBeenSignalled() throws Throwable;\n-  \/**\n-   * Currently, this test is skipped because there was no agreement on how to verify its \"eventually\" requirement.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.8'>1.8<\/a>\n-   *\/\n-  void untested_spec108_possiblyCanceledSubscriptionShouldNotReceiveOnErrorOrOnCompleteSignals() throws Throwable;\n-  \/**\n-   * Asks for an empty {@code Publisher} and verifies if {@code onSubscribe} signal was emitted before\n-   * any other {@code onNext}, {@code onError} or {@code onComplete} signal.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.9'>1.9<\/a>\n-   * <p>\n-   * Note that this test doesn't request anything, however, an {@code onNext} is not considered as a failure.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>the {@code Publisher.subscribe(Subscriber)} method has actual implementation,<\/li>\n-   * <li>in the {@code Publisher.subscribe(Subscriber)} method, if there is an upstream {@code Publisher},\n-   * that {@code Publisher} is actually subscribed to,<\/li>\n-   * <li>in the {@code Publisher.subscribe(Subscriber)} method, the {@code Subscriber.onSubscribe} is called\n-   * as part of the preparation process (usually before subscribing to other {@code Publisher}s).<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec109_mustIssueOnSubscribeForNonNullSubscriber() throws Throwable;\n-  \/**\n-   * Currently, this test is skipped because there is no common agreement on what is to be considered a fatal exception and\n-   * besides, {@code Publisher.subscribe} is only allowed throw a {@code NullPointerException} and any other\n-   * exception would require looking into or hooking into the implementation of the {@code Publisher}.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.9'>1.9<\/a>\n-   *\/\n-  void untested_spec109_subscribeShouldNotThrowNonFatalThrowable() throws Throwable;\n-  \/**\n-   * Asks for an empty {@code Publisher} and calls {@code subscribe} on it with {@code null} that should result in\n-   * a {@code NullPointerException} to be thrown.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.9'>1.9<\/a>\n-   * <p>\n-   * If this test fails, check if the {@code subscribe()} implementation has an explicit null check (or a method dereference\n-   * on the {@code Subscriber}), especially if the incoming {@code Subscriber} is wrapped or stored to be used later.\n-   *\/\n-  void required_spec109_subscribeThrowNPEOnNullSubscriber() throws Throwable;\n-  \/**\n-   * Asks for an error {@code Publisher} that should call {@code onSubscribe} exactly once\n-   * followed by a single call to {@code onError()} without receiving any requests.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.9'>1.9<\/a>\n-   * <p>\n-   * The test is not executed if {@code PublisherVerification.createErrorPublisher()} returns null.\n-   * <p>\n-   * The difference between this test and {@link #optional_spec104_mustSignalOnErrorWhenFails()} is that there is\n-   * no explicit verification if exceptions were thrown in addition to the regular {@code onSubscribe+onError} signal pair.\n-   * <p>\n-   * If this test fails, the following could be checked within the error {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code Publisher.subscribe(Subscriber)} method has actual implementation,<\/li>\n-   * <li>in the {@code Publisher.subscribe(Subscriber)} method, if there is an upstream {@code Publisher},\n-   * that {@code Publisher} is actually subscribed to,<\/li>\n-   * <li>if the {@code Publisher} implementation is able to emit an {@code onError} without requests,<\/li>\n-   * <li>if the {@code Publisher} is non-empty as this test expects a {@code Publisher} without items.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec109_mayRejectCallsToSubscribeIfPublisherIsUnableOrUnwillingToServeThemRejectionMustTriggerOnErrorAfterOnSubscribe() throws Throwable;\n-  \/**\n-   * Currently, this test is skipped because enforcing rule §1.10 requires unlimited retention and reference-equal checks on\n-   * all incoming {@code Subscriber} which is generally infeasible, plus reusing the same {@code Subscriber} instance is\n-   * better detected (or ignored) inside {@code Subscriber.onSubscribe} when the method is called multiple times.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.10'>1.10<\/a>\n-   *\/\n-  void untested_spec110_rejectASubscriptionRequestIfTheSameSubscriberSubscribesTwice() throws Throwable;\n-  \/**\n-   * Asks for a single-element {@code Publisher} and subscribes to it twice, without consuming with either\n-   * {@code Subscriber} instance\n-   * (i.e., no requests are issued).\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.11'>1.11<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 1.\n-   * <p>\n-   * Note that this test ignores what signals the {@code Publisher} emits. Any exception thrown through non-regular\n-   * means will indicate a skipped test.\n-   *\/\n-  void optional_spec111_maySupportMultiSubscribe() throws Throwable;\n-  \/**\n-   * Asks for a single-element {@code Publisher} and subscribes to it twice.\n-   * Each {@code Subscriber} requests for 1 element and checks if onNext or onComplete signals was received.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.11'>1.11<\/a>,\n-   * and depends on valid implementation of rule <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.5'>1.5<\/a>\n-   * in order to verify this.\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 1.\n-   * <p>\n-   * Any exception thrown through non-regular means will indicate a skipped test.\n-   *\/\n-  void optional_spec111_registeredSubscribersMustReceiveOnNextOrOnCompleteSignals() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (length 5), subscribes 3 {@code Subscriber}s to it, requests with different\n-   * patterns and checks if all 3 received the same events in the same order.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.11'>1.11<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 5.\n-   * <p>\n-   * The request pattern for the first {@code Subscriber} is (1, 1, 2, 1); for the second is (2, 3) and for the third is (3, 1, 1).\n-   * <p>\n-   * Note that this test requires a {@code Publisher} that always emits the same signals to any {@code Subscriber}, regardless of\n-   * when they subscribe and how they request elements. I.e., a \"live\" {@code Publisher} emitting the current time would not pass this test.\n-   * <p>\n-   * Note that this test is optional and may appear skipped even if the behavior should be actually supported by the {@code Publisher},\n-   * see the skip message for an indication of this.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>if the {@code Publisher} implementation considers the cumulative request amount it receives,<\/li>\n-   * <li>if the {@code Publisher} doesn't lose any {@code request()} signal and the state transition from idle -&gt; emitting or emitting -&gt; keep emitting works properly.<\/li>\n-   * <\/ul>\n-   *\/\n-  void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingOneByOne() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (length 3), subscribes 3 {@code Subscriber}s to it, requests more than the length items\n-   * upfront with each and verifies they all received the same items in the same order (but does not verify they all complete).\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.11'>1.11<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.\n-   * <p>\n-   * Note that this test requires a {@code Publisher} that always emits the same signals to any {@code Subscriber}, regardless of\n-   * when they subscribe and how they request elements. I.e., a \"live\" {@code Publisher} emitting the current time would not pass this test.\n-   * <p>\n-   * Note that this test is optional and may appear skipped even if the behavior should be actually supported by the {@code Publisher},\n-   * see the skip message for an indication of this.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>if the {@code Publisher} implementation considers the cumulative request amount it receives,<\/li>\n-   * <li>if the {@code Publisher} doesn't lose any {@code request()} signal and the state transition from idle -&gt; emitting or emitting -&gt; keep emitting works properly.<\/li>\n-   * <\/ul>\n-   *\/\n-  void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfront() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (length 3), subscribes 3 {@code Subscriber}s to it, requests more than the length items\n-   * upfront with each and verifies they all received the same items in the same order followed by an {@code onComplete} signal.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.11'>1.11<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.\n-   * <p>\n-   * Note that this test requires a {@code Publisher} that always emits the same signals to any {@code Subscriber}, regardless of\n-   * when they subscribe and how they request elements. I.e., a \"live\" {@code Publisher} emitting the current time would not pass this test.\n-   * <p>\n-   * Note that this test is optional and may appear skipped even if the behavior should be actually supported by the {@code Publisher},\n-   * see the skip message for an indication of this.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>if the {@code Publisher} implementation considers the cumulative request amount it receives,<\/li>\n-   * <li>if the {@code Publisher} doesn't lose any {@code request()} signal and the state transition from idle -&gt; emitting or emitting -&gt; keep emitting works properly.<\/li>\n-   * <\/ul>\n-   *\/\n-  void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfrontAndCompleteAsExpected() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (length 6), requests several times from within {@code onSubscribe} and then requests\n-   * one-by-one from {@code onNext}.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.2'>3.2<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 6.\n-   * <p>\n-   * The request pattern is 3 x 1 from within {@code onSubscribe} and one from within each {@code onNext} invocation.\n-   * <p>\n-   * The test consumes the {@code Publisher} but otherwise doesn't verify the {@code Publisher} completes (however, it checks\n-   * for errors).\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>if the {@code Publisher} implementation considers the cumulative request amount it receives,<\/li>\n-   * <li>if the {@code Publisher} doesn't lose any {@code request()} signal and the state transition from idle -&gt; emitting or emitting -&gt; keep emitting works properly.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec302_mustAllowSynchronousRequestCallsFromOnNextAndOnSubscribe() throws Throwable;\n-  \/**\n-   * Asks for a {@code Publisher} with length equal to the value returned by {@link #required_validate_boundedDepthOfOnNextAndRequestRecursion()} plus 1,\n-   * calls {@code request(1)} externally and then from within {@code onNext} and checks if the stack depth did not increase beyond the\n-   * amount permitted by {@link #required_validate_boundedDepthOfOnNextAndRequestRecursion()}.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.3'>3.3<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than\n-   * {@link #required_validate_boundedDepthOfOnNextAndRequestRecursion()} plus 1.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>the implementation doesn't allow unbounded recursion when {@code request()} is called from within {@code onNext}, i.e., the lack of\n-   * reentrant-safe state machine around the request amount (such as a for loop with a bound on the parameter {@code n} that calls {@code onNext}).\n-   * <\/ul>\n-   *\/\n-  void required_spec303_mustNotAllowUnboundedRecursion() throws Throwable;\n-  \/**\n-   * Currently, this test is skipped because a {@code request} could enter into a synchronous computation via {@code onNext}\n-   * legally and otherwise there is no common agreement how to detect such heavy computation reliably.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.4'>3.4<\/a>\n-   *\/\n-  void untested_spec304_requestShouldNotPerformHeavyComputations() throws Exception;\n-  \/**\n-   * Currently, this test is skipped because there is no reliable agreed upon way to detect a heavy computation.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.5'>3.5<\/a>\n-   *\/\n-  void untested_spec305_cancelMustNotSynchronouslyPerformHeavyComputation() throws Exception;\n-  \/**\n-   * Asks for a short {@code Publisher} (length 3) and verifies that cancelling without requesting anything, then requesting\n-   * items should result in no signals to be emitted.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.6'>3.6<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.\n-   * <p>\n-   * The post-cancellation request pattern is (1, 1, 1).\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>the cancellation indicator flag is properly persisted (may require volatile) and checked as part of the signal emission process.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec306_afterSubscriptionIsCancelledRequestMustBeNops() throws Throwable;\n-  \/**\n-   * Asks for a single-element {@code Publisher} and verifies that without requesting anything, cancelling the sequence\n-   * multiple times should result in no signals to be emitted and should result in an thrown exception.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.7'>3.7<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 1.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>the cancellation indicator flag is properly persisted (may require volatile) and checked as part of the signal emission process.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec307_afterSubscriptionIsCancelledAdditionalCancelationsMustBeNops() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (length 10) and issues a {@code request(0)} which should trigger an {@code onError} call\n-   * with an {@code IllegalArgumentException}.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.9'>3.9<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 10.\n-   * <p>\n-   * Note that this test expects the {@code IllegalArgumentException} being signalled through {@code onError}, not by\n-   * throwing from {@code request()} (which is also forbidden) or signalling the error by any other means (i.e., through the\n-   * {@code Thread.currentThread().getUncaughtExceptionHandler()} for example).\n-   * <p>\n-   * Note also that requesting and emission may happen concurrently and honoring this rule may require extra coordination within\n-   * the {@code Publisher}.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>the {@code Publisher} can emit an {@code onError} in this particular case, even if there was no prior and legal\n-   * {@code request} call and even if the {@code Publisher} would like to emit items first before emitting an {@code onError}\n-   * in general.\n-   * <\/ul>\n-   *\/\n-  void required_spec309_requestZeroMustSignalIllegalArgumentException() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (length 10) and issues a random, negative {@code request()} call which should\n-   * trigger an {@code onError} call with an {@code IllegalArgumentException}.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.9'>3.9<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 10.\n-   * <p>\n-   * Note that this test expects the {@code IllegalArgumentException} being signalled through {@code onError}, not by\n-   * throwing from {@code request()} (which is also forbidden) or signalling the error by any other means (i.e., through the\n-   * {@code Thread.currentThread().getUncaughtExceptionHandler()} for example).\n-   * <p>\n-   * Note also that requesting and emission may happen concurrently and honoring this rule may require extra coordination within\n-   * the {@code Publisher}.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>the {@code Publisher} can emit an {@code onError} in this particular case, even if there was no prior and legal\n-   * {@code request} call and even if the {@code Publisher} would like to emit items first before emitting an {@code onError}\n-   * in general.\n-   * <\/ul>\n-   *\/\n-  void required_spec309_requestNegativeNumberMustSignalIllegalArgumentException() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (length 10) and issues a random, negative {@code request()} call which should\n-   * trigger an {@code onError} call with an {@code IllegalArgumentException}.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.9'>3.9<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 10.\n-   * <p>\n-   * Note that this test expects the {@code IllegalArgumentException} being signalled through {@code onError}, not by\n-   * throwing from {@code request()} (which is also forbidden) or signalling the error by any other means (i.e., through the\n-   * {@code Thread.currentThread().getUncaughtExceptionHandler()} for example).\n-   * <p>\n-   * Note also that requesting and emission may happen concurrently and honoring this rule may require extra coordination within\n-   * the {@code Publisher}.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>the {@code Publisher} can emit an {@code onError} in this particular case, even if there was no prior and legal\n-   * {@code request} call and even if the {@code Publisher} would like to emit items first before emitting an {@code onError}\n-   * in general.\n-   * <\/ul>\n-   *\/\n-  void optional_spec309_requestNegativeNumberMaySignalIllegalArgumentExceptionWithSpecificMessage() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (length 20), requests some items (less than the length), consumes one item then\n-   * cancels the sequence and verifies the publisher emitted at most the requested amount and stopped emitting (or terminated).\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.12'>3.12<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 20.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>the cancellation indicator flag is properly persisted (may require volatile) and checked as part of the signal emission process.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec312_cancelMustMakeThePublisherToEventuallyStopSignaling() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (length 3) requests and consumes one element from it, cancels the {@code Subscription}\n-   * , calls {@code System.gc()} and then checks if all references to the test {@code Subscriber} has been dropped (by checking\n-   * the {@code WeakReference} has been emptied).\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.13'>3.13<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>the cancellation indicator flag is properly persisted (may require volatile) and checked as part of the signal emission process.<\/li>\n-   * <li>the {@code Publisher} stores the {@code Subscriber} reference somewhere which is then not cleaned up when the {@code Subscriber} is cancelled.\n-   * Note that this may happen on many code paths in a {@code Publisher}, for example in an emission loop that terminates because of the\n-   * {@code cancel} signal or because reaching a terminal state. Note also that eagerly nulling {@code Subscriber} references may not be necessary\n-   * for this test to pass in case there is a self-contained chain of them (i.e., {@code Publisher.subscribe()} creates a chain of fresh\n-   * {@code Subscriber} instances where each of them only references their downstream {@code Subscriber} thus the chain can get GC'd\n-   * when the reference to the final {@code Subscriber} is dropped).\n-   * <\/ul>\n-   *\/\n-  void required_spec313_cancelMustMakeThePublisherEventuallyDropAllReferencesToTheSubscriber() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (length 3) and requests {@code Long.MAX_VALUE} from it, verifying that the\n-   * {@code Publisher} emits all of its items and completes normally\n-   * and does not keep spinning attempting to fulfill the {@code Long.MAX_VALUE} demand by some means.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.17'>3.17<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>if the {@code Publisher} implementation considers the cumulative request amount it receives,<\/li>\n-   * <li>if the {@code Publisher} doesn't lose any {@code request()} signal and the state transition from idle -&gt; emitting or emitting -&gt; keep emitting works properly.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec317_mustSupportAPendingElementCountUpToLongMaxValue() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (length 3) and requests {@code Long.MAX_VALUE} from it in total (split across\n-   * two {@code Long.MAX_VALUE \/ 2} and one {@code request(1)}), verifying that the\n-   * {@code Publisher} emits all of its items and completes normally.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.17'>3.17<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>if the {@code Publisher} implementation considers the cumulative request amount it receives,<\/li>\n-   * <li>if the {@code Publisher} implements adding individual request amounts together properly (not overflowing into zero or negative pending request amounts)\n-   * or not properly deducing the number of emitted items from the pending amount,<\/li>\n-   * <li>if the {@code Publisher} doesn't lose any {@code request()} signal and the state transition from idle -&gt; emitting or emitting -&gt; keep emitting works properly.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec317_mustSupportACumulativePendingElementCountUpToLongMaxValue() throws Throwable;\n-  \/**\n-   * Asks for a very long {@code Publisher} (up to {@code Integer.MAX_VALUE}), requests {@code Long.MAX_VALUE - 1} after\n-   * each received item and expects no failure due to a potential overflow in the pending emission count while consuming\n-   * 10 items and cancelling the sequence.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.17'>3.17<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than {@code Integer.MAX_VALUE}.\n-   * <p>\n-   * The request pattern is one {@code request(1)} upfront and ten {@code request(Long.MAX_VALUE - 1)} after.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>if the {@code Publisher} implementation considers the cumulative request amount it receives,<\/li>\n-   * <li>if the {@code Publisher} implements adding individual request amounts together properly (not overflowing into zero or negative pending request amounts)\n-   * or not properly deducing the number of emitted items from the pending amount,<\/li>\n-   * <li>if the {@code Publisher} doesn't lose any {@code request()} signal and the state transition from idle -&gt; emitting or emitting -&gt; keep emitting works properly.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec317_mustNotSignalOnErrorWhenPendingAboveLongMaxValue() throws Throwable;\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/support\/PublisherVerificationRules.java","additions":0,"deletions":658,"binary":false,"changes":658,"status":"deleted"},{"patch":"@@ -1,395 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow.support;\n-\n-import org.reactivestreams.tck.SubscriberBlackboxVerification;\n-\n-\/**\n- * Internal TCK use only.\n- * Add \/ Remove tests for SubscriberBlackboxVerification here to make sure that they arre added\/removed in the other places.\n- *\/\n-public interface SubscriberBlackboxVerificationRules {\n-  \/**\n-   * Asks for a {@code Subscriber} instance, expects it to call {@code request()} in\n-   * a timely manner and signals as many {@code onNext} items as the very first request\n-   * amount specified by the {@code Subscriber}.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.1'>2.1<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>This test emits the number of items requested thus the {@code Subscriber} implementation\n-   * should not request too much.<\/li>\n-   * <li>Only the very first {@code request} amount is considered.<\/li>\n-   * <li>This test doesn't signal {@code onComplete} after the first set of {@code onNext} signals\n-   * has been emitted and may cause resource leak in\n-   * {@code Subscriber}s that expect a finite {@code Publisher}.<\/li>\n-   * <li>The test ignores cancellation from the {@code Subscriber} and emits the requested amount regardless.<\/li>\n-   * <\/ul>\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Subscriber} implementation:\n-   * <ul>\n-   * <li>if the {@code Subscriber} requires external stimulus to begin requesting; override the\n-   * {@link SubscriberBlackboxVerification#triggerRequest(org.reactivestreams.Subscriber)} method\n-   *  in this case,<\/li>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Subscriber} has some time-delay behavior,<\/li>\n-   * <li>if the {@code Subscriber} requests zero or a negative value in some circumstances,<\/li>\n-   * <li>if the {@code Subscriber} throws an unchecked exception from its {@code onSubscribe} or\n-   * {@code onNext} methods.\n-   * <\/ul>\n-   *\/\n-  void required_spec201_blackbox_mustSignalDemandViaSubscriptionRequest() throws Throwable;\n-  \/**\n-   * Currently, this test is skipped because there is no agreed upon approach how\n-   * to detect if the {@code Subscriber} really goes async or just responds in\n-   * a timely manner.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.2'>2.2<\/a>\n-   *\/\n-  void untested_spec202_blackbox_shouldAsynchronouslyDispatch() throws Exception;\n-  \/**\n-   * Asks for a {@code Subscriber}, signals an {@code onSubscribe} followed by an {@code onComplete} synchronously,\n-   * and checks if neither {@code request} nor {@code cancel} was called from within the {@code Subscriber}'s\n-   * {@code onComplete} implementation.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.3'>2.3<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>The test checks for the presensce of method named \"onComplete\" in the current stacktrace when handling\n-   * the {@code request} or {@code cancel} calls in the test's own {@code Subscription}.\n-   * <\/ul>\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Subscriber} implementation:\n-   * <ul>\n-   * <li>no calls happen to {@code request} or {@code cancel} in response to an {@code onComplete}\n-   * directly or indirectly,<\/li>\n-   * <li>if the {@code Subscriber} throws an unchecked exception from its {@code onSubscribe} or\n-   * {@code onComplete} methods.\n-   * <\/ul>\n-   *\/\n-  void required_spec203_blackbox_mustNotCallMethodsOnSubscriptionOrPublisherInOnComplete() throws Throwable;\n-  \/**\n-   * Asks for a {@code Subscriber}, signals an {@code onSubscribe} followed by an {@code onError} synchronously,\n-   * and checks if neither {@code request} nor {@code cancel} was called from within the {@code Subscriber}'s\n-   * {@code onComplete} implementation.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.3'>2.3<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>The test checks for the presensce of method named \"onError\" in the current stacktrace when handling\n-   * the {@code request} or {@code cancel} calls in the test's own {@code Subscription}.\n-   * <\/ul>\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Subscriber} implementation:\n-   * <ul>\n-   * <li>no calls happen to {@code request} or {@code cancel} in response to an {@code onError}\n-   * directly or indirectly,<\/li>\n-   * <li>if the {@code Subscriber} throws an unchecked exception from its {@code onSubscribe} or\n-   * {@code onError} methods.\n-   * <\/ul>\n-   *\/\n-  void required_spec203_blackbox_mustNotCallMethodsOnSubscriptionOrPublisherInOnError() throws Throwable;\n-  \/**\n-   * Currently, this test is skipped because there is no way to check what the {@code Subscriber} \"considers\"\n-   * since rule §2.3 forbids interaction from within the {@code onError} and {@code onComplete} methods.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.4'>2.4<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>It would be possible to check if there was an async interaction with the test's {@code Subscription}\n-   * within a grace period but such check is still not generally decisive.<\/li>\n-   * <\/ul>\n-   *\/\n-  void untested_spec204_blackbox_mustConsiderTheSubscriptionAsCancelledInAfterRecievingOnCompleteOrOnError() throws Exception;\n-  \/**\n-   * Asks for a {@code Subscriber}, signals {@code onSubscribe} twice synchronously and expects the second {@code Subscription} gets\n-   * cancelled in a timely manner and without any calls to its {@code request} method.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.5'>2.5<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>The test doesn't signal any other events than {@code onSubscribe} and may cause resource leak in\n-   * {@code Subscriber}s that expect a finite {@code Publisher}.\n-   * <\/ul>\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Subscriber} implementation:\n-   * <ul>\n-   * <li>if the {@code Subscribe.onSubscribe} implementation actually tries to detect multiple calls to it,<\/li>\n-   * <li>if the second {@code Subscription} is cancelled asynchronously and that takes longer time than\n-   * the {@code TestEnvironment}'s timeout permits.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec205_blackbox_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal() throws Exception;\n-\n-  \/**\n-   * Currently, this test is skipped because it requires more control over the {@code Subscriber} implementation\n-   * to make it cancel the {@code Subscription} for some external condition.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.6'>2.6<\/a>\n-   *\/\n-  void untested_spec206_blackbox_mustCallSubscriptionCancelIfItIsNoLongerValid() throws Exception;\n-  \/**\n-   * Currently, this test is skipped because it requires more control over the {@code Subscriber} implementation\n-   * to issue requests based on external stimulus.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.7'>2.7<\/a>\n-   *\/\n-  void untested_spec207_blackbox_mustEnsureAllCallsOnItsSubscriptionTakePlaceFromTheSameThreadOrTakeCareOfSynchronization() throws Exception;\n-  \/**\n-   * Currently, this test is skipped because there is no way to make the {@code Subscriber} implementation\n-   * cancel the test's {@code Subscription} and check the outcome of sending {@code onNext}s after such\n-   * cancel.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.8'>2.8<\/a>\n-   *\/\n-  void untested_spec208_blackbox_mustBePreparedToReceiveOnNextSignalsAfterHavingCalledSubscriptionCancel() throws Throwable;\n-  \/**\n-   * Asks for a {@code Subscriber}, expects it to request some amount and in turn be able to receive an {@code onComplete}\n-   * synchronously from the {@code request} call without any {@code onNext} signals before that.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.9'>2.9<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>The test ignores cancellation from the {@code Subscriber}.<\/li>\n-   * <li>Invalid request amounts are ignored by this test.<\/li>\n-   * <li>Concurrent calls to the test's {@code Subscription.request()} must be externally synchronized, otherwise\n-   * such case results probabilistically in multiple {@code onComplete} calls by the test.<\/li>\n-   * <\/ul>\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Subscriber} implementation:\n-   * <ul>\n-   * <li>if the {@code Subscriber} throws an unchecked exception from its {@code onSubscribe} or\n-   * {@code onComplete} methods.\n-   * <li>if the {@code Subscriber} requires external stimulus to begin requesting; override the\n-   * {@link SubscriberBlackboxVerification#triggerRequest(org.reactivestreams.Subscriber)} method\n-   *  in this case,<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec209_blackbox_mustBePreparedToReceiveAnOnCompleteSignalWithPrecedingRequestCall() throws Throwable;\n-  \/**\n-   * Asks for a {@code Subscriber} and expects it to handle {@code onComplete} independent of whether the {@code Subscriber}\n-   * requests items or not.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.9'>2.9<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>Currently, the test doesn't call {@code onSubscribe} on the {@code Subscriber} which violates §1.9.\n-   * <\/ul>\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Subscriber} implementation:\n-   * <ul>\n-   * <li>if the {@code Subscriber} throws an unchecked exception from its {@code onSubscribe} or\n-   * {@code onComplete} methods.\n-   * <\/ul>\n-   *\/\n-  void required_spec209_blackbox_mustBePreparedToReceiveAnOnCompleteSignalWithoutPrecedingRequestCall() throws Throwable;\n-  \/**\n-   * Asks for a {@code Subscriber}, signals {@code onSubscribe} followed by an {@code onError} synchronously.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.10'>2.10<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>Despite the method name, the test doesn't expect a request signal from {@code Subscriber} and emits the\n-   * {@code onError} signal anyway.\n-   * <\/ul>\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Subscriber} implementation:\n-   * <ul>\n-   * <li>if the {@code Subscriber} throws an unchecked exception from its {@code onSubscribe} or\n-   * {@code onError} methods.\n-   * <\/ul>\n-   *\/\n-  void required_spec210_blackbox_mustBePreparedToReceiveAnOnErrorSignalWithPrecedingRequestCall() throws Throwable;\n-\n-  \/**\n-   * Asks for a {@code Subscriber}, signals {@code onSubscribe} followed by an {@code onError} synchronously.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.10'>2.10<\/a>\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Subscriber} implementation:\n-   * <ul>\n-   * <li>if the {@code Subscriber} throws an unchecked exception from its {@code onSubscribe} or\n-   * {@code onError} methods.\n-   * <\/ul>\n-   *\/\n-  void required_spec210_blackbox_mustBePreparedToReceiveAnOnErrorSignalWithoutPrecedingRequestCall() throws Throwable;\n-\n-  \/**\n-   * Currently, this test is skipped because it would require analyzing what the {@code Subscriber} implementation\n-   * does.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.11'>2.11<\/a>\n-   *\/\n-  void untested_spec211_blackbox_mustMakeSureThatAllCallsOnItsMethodsHappenBeforeTheProcessingOfTheRespectiveEvents() throws Exception;\n-  \/**\n-   * Currently, this test is skipped because the test for\n-   * {@link #required_spec205_blackbox_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal §2.5}\n-   * is in a better position to test for handling the reuse of the same {@code Subscriber}.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.12'>2.12<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>In addition to §2.5, this rule could be better verified when testing a {@code Publisher}'s subscription behavior.\n-   * <\/ul>\n-   *\/\n-  void untested_spec212_blackbox_mustNotCallOnSubscribeMoreThanOnceBasedOnObjectEquality() throws Throwable;\n-  \/**\n-   * Currently, this test is skipped because it would require more control over the {@code Subscriber} to\n-   * fail internally in response to a set of legal event emissions, not throw any exception from the {@code Subscriber}\n-   * methods and have it cancel the {@code Subscription}.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.13'>2.13<\/a>\n-   *\/\n-  void untested_spec213_blackbox_failingOnSignalInvocation() throws Exception;\n-  \/**\n-   * Asks for a {@code Subscriber} and signals an {@code onSubscribe} event with {@code null} as a parameter and\n-   * expects an immediate {@code NullPointerException} to be thrown by the {@code Subscriber.onSubscribe} method.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.13'>2.13<\/a>\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Subscriber} implementation:\n-   * <ul>\n-   * <li>if the {@code Subscriber} throws a {@code NullPointerException} from its {@code onSubscribe} method\n-   * in response to a {@code null} parameter and not some other unchecked exception or no exception at all.\n-   * <\/ul>\n-   *\/\n-  void required_spec213_blackbox_onSubscribe_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable;\n-  \/**\n-   * Asks for a {@code Subscriber}, signals an {@code onSubscribe} event followed by a\n-   * {@code onNext} with {@code null} as a parameter and\n-   * expects an immediate {@code NullPointerException} to be thrown by the {@code Subscriber.onNext} method.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.13'>2.13<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>The test ignores cancellation and requests from the {@code Subscriber} and emits the {@code onNext}\n-   * signal with a {@code null} parameter anyway.<\/li>\n-   * <\/ul>\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Subscriber} implementation:\n-   * <ul>\n-   * <li>if the {@code Subscriber} throws a {@code NullPointerException} from its {@code onNext} method\n-   * in response to a {@code null} parameter and not some other unchecked exception or no exception at all.\n-   * <\/ul>\n-   *\/\n-  void required_spec213_blackbox_onNext_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable;\n-  \/**\n-   * Asks for a {@code Subscriber}, signals an {@code onSubscribe} event followed by a\n-   * {@code onError} with {@code null} as a parameter and\n-   * expects an immediate {@code NullPointerException} to be thrown by the {@code Subscriber.onError} method.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.13'>2.13<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>The test ignores cancellation from the {@code Subscriber} and emits the {@code onError}\n-   * signal with a {@code null} parameter anyway.<\/li>\n-   * <\/ul>\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Subscriber} implementation:\n-   * <ul>\n-   * <li>if the {@code Subscriber} throws a {@code NullPointerException} from its {@code onNext} method\n-   * in response to a {@code null} parameter and not some other unchecked exception or no exception at all.\n-   * <\/ul>\n-   *\/\n-  void required_spec213_blackbox_onError_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable;\n-  \/**\n-   * Currently, this test is skipped because there is no agreed upon way for specifying, enforcing and testing\n-   * a {@code Subscriber} with an arbitrary context.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.1'>3.1<\/a>\n-   *\/\n-  void untested_spec301_blackbox_mustNotBeCalledOutsideSubscriberContext() throws Exception;\n-  \/**\n-   * Currently, this test is skipped because element production is the responsibility of the {@code Publisher} and\n-   * a {@code Subscription} is not expected to be the active element in an established subscription.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.8'>3.8<\/a>\n-   *\/\n-  void untested_spec308_blackbox_requestMustRegisterGivenNumberElementsToBeProduced() throws Throwable;\n-  \/**\n-   * Currently, this test is skipped because element production is the responsibility of the {@code Publisher} and\n-   * a {@code Subscription} is not expected to be the active element in an established subscription.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.10'>3.10<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>This could be tested with a synchronous source currently not available within the TCK.<\/li>\n-   * <\/ul>\n-   *\/\n-  void untested_spec310_blackbox_requestMaySynchronouslyCallOnNextOnSubscriber() throws Exception;\n-  \/**\n-   * Currently, this test is skipped because signal production is the responsibility of the {@code Publisher} and\n-   * a {@code Subscription} is not expected to be the active element in an established subscription.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.11'>3.11<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>Tests {@link #required_spec209_blackbox_mustBePreparedToReceiveAnOnCompleteSignalWithPrecedingRequestCall() §2.9}\n-   * and {@link #required_spec210_blackbox_mustBePreparedToReceiveAnOnErrorSignalWithPrecedingRequestCall() §2.10} are\n-   * supposed to cover this case from the {@code Subscriber's} perspective.<\/li>\n-   * <\/ul>\n-   *\/\n-  void untested_spec311_blackbox_requestMaySynchronouslyCallOnCompleteOrOnError() throws Exception;\n-  \/**\n-   * Currently, this test is skipped because it is the responsibility of the {@code Publisher} deal with the case\n-   * that all subscribers have cancelled their subscription.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.14'>3.14<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>The specification lists this as an optional behavior because only some {@code Publisher} implementations\n-   * (most likely {@code Processor}s) would coordinate with multiple {@code Subscriber}s.<\/li>\n-   * <\/ul>\n-   *\/\n-  void untested_spec314_blackbox_cancelMayCauseThePublisherToShutdownIfNoOtherSubscriptionExists() throws Exception;\n-  \/**\n-   * Currently, this test is skipped because it requires more control over the {@code Subscriber} implementation\n-   * thus there is no way to detect that the {@code Subscriber} called its own {@code onError} method in response\n-   * to an exception thrown from {@code Subscription.cancel}.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.15'>3.15<\/a>\n-   *\/\n-  void untested_spec315_blackbox_cancelMustNotThrowExceptionAndMustSignalOnError() throws Exception;\n-  \/**\n-   * Currently, this test is skipped because it requires more control over the {@code Subscriber} implementation\n-   * thus there is no way to detect that the {@code Subscriber} called its own {@code onError} method in response\n-   * to an exception thrown from {@code Subscription.request}.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.16'>3.16<\/a>\n-   *\/\n-  void untested_spec316_blackbox_requestMustNotThrowExceptionAndMustOnErrorTheSubscriber() throws Exception;\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/support\/SubscriberBlackboxVerificationRules.java","additions":0,"deletions":395,"binary":false,"changes":395,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow.support;\n-\n-public final class SubscriberBufferOverflowException extends RuntimeException {\n-  public SubscriberBufferOverflowException() {\n-  }\n-\n-  public SubscriberBufferOverflowException(String message) {\n-    super(message);\n-  }\n-\n-  public SubscriberBufferOverflowException(String message, Throwable cause) {\n-    super(message, cause);\n-  }\n-\n-  public SubscriberBufferOverflowException(Throwable cause) {\n-    super(cause);\n-  }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/support\/SubscriberBufferOverflowException.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow.support;\n-\n-\/**\n- * Internal TCK use only.\n- * Add \/ Remove tests for PublisherVerificaSubscriberWhiteboxVerification here to make sure that they arre added\/removed in the other places.\n- *\/\n-public interface SubscriberWhiteboxVerificationRules {\n-  void required_exerciseWhiteboxHappyPath() throws Throwable;\n-  void required_spec201_mustSignalDemandViaSubscriptionRequest() throws Throwable;\n-  void untested_spec202_shouldAsynchronouslyDispatch() throws Exception;\n-  void required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnComplete() throws Throwable;\n-  void required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnError() throws Throwable;\n-  void untested_spec204_mustConsiderTheSubscriptionAsCancelledInAfterRecievingOnCompleteOrOnError() throws Exception;\n-  void required_spec205_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal() throws Throwable;\n-  void untested_spec206_mustCallSubscriptionCancelIfItIsNoLongerValid() throws Exception;\n-  void untested_spec207_mustEnsureAllCallsOnItsSubscriptionTakePlaceFromTheSameThreadOrTakeCareOfSynchronization() throws Exception;\n-  void required_spec208_mustBePreparedToReceiveOnNextSignalsAfterHavingCalledSubscriptionCancel() throws Throwable;\n-  void required_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithPrecedingRequestCall() throws Throwable;\n-  void required_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithoutPrecedingRequestCall() throws Throwable;\n-  void required_spec210_mustBePreparedToReceiveAnOnErrorSignalWithPrecedingRequestCall() throws Throwable;\n-  void required_spec210_mustBePreparedToReceiveAnOnErrorSignalWithoutPrecedingRequestCall() throws Throwable;\n-  void untested_spec211_mustMakeSureThatAllCallsOnItsMethodsHappenBeforeTheProcessingOfTheRespectiveEvents() throws Exception;\n-  void untested_spec212_mustNotCallOnSubscribeMoreThanOnceBasedOnObjectEquality_specViolation() throws Throwable;\n-  void untested_spec213_failingOnSignalInvocation() throws Exception;\n-  void required_spec213_onSubscribe_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable;\n-  void required_spec213_onNext_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable;\n-  void required_spec213_onError_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable;\n-  void untested_spec301_mustNotBeCalledOutsideSubscriberContext() throws Exception;\n-  void required_spec308_requestMustRegisterGivenNumberElementsToBeProduced() throws Throwable;\n-  void untested_spec310_requestMaySynchronouslyCallOnNextOnSubscriber() throws Exception;\n-  void untested_spec311_requestMaySynchronouslyCallOnCompleteOrOnError() throws Exception;\n-  void untested_spec314_cancelMayCauseThePublisherToShutdownIfNoOtherSubscriptionExists() throws Exception;\n-  void untested_spec315_cancelMustNotThrowExceptionAndMustSignalOnError() throws Exception;\n-  void untested_spec316_requestMustNotThrowExceptionAndMustOnErrorTheSubscriber() throws Exception;\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/support\/SubscriberWhiteboxVerificationRules.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow.support;\n-\n-\/**\n- * Exception used by the TCK to signal failures.\n- * May be thrown or signalled through {@link org.reactivestreams.Subscriber#onError(Throwable)}.\n- *\/\n-public final class TestException extends RuntimeException {\n-  public TestException() {\n-    super(\"Test Exception: Boom!\");\n-  }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/support\/TestException.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -31,1 +31,1 @@\n- * @compile --enable-preview -source ${jdk.version} HttpALot.java\n+ * @enablePreview\n@@ -36,1 +36,0 @@\n- *     --enable-preview\n","filename":"test\/jdk\/java\/net\/vthread\/HttpALot.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,2 +28,3 @@\n- * @compile --enable-preview -source ${jdk.version} InterruptHttp.java\n- * @run main\/othervm --enable-preview InterruptHttp\n+ * @enablePreview\n+ * @compile InterruptHttp.java\n+ * @run main\/othervm InterruptHttp\n","filename":"test\/jdk\/java\/net\/vthread\/InterruptHttp.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-     * An abstract server identifies a server which listens on a port on on a\n+     * An abstract server identifies a server which listens on a port on a\n","filename":"test\/jdk\/java\/nio\/channels\/TestServers.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n- *  multiple interfaces using using RMI class unmarshalling.  Test is\n+ *  multiple interfaces using RMI class unmarshalling.  Test is\n","filename":"test\/jdk\/java\/rmi\/server\/RMIClassLoader\/loadProxyClasses\/LoadProxyClasses.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -445,1 +445,1 @@\n-     * Check the status database for revocation information one one or more\n+     * Check the status database for revocation information on one or more\n","filename":"test\/jdk\/java\/security\/testlibrary\/SimpleOCSPServer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -328,1 +328,1 @@\n-     * Create a PrintWriter and use to to send output via DriverManager.println\n+     * Create a PrintWriter and use it to send output via DriverManager.println\n","filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/DriverManagerTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-            \/\/ give them time to interfere with each each\n+            \/\/ give them time to interfere with each other\n","filename":"test\/jdk\/java\/util\/Properties\/ConcurrentLoadAndStoreXML.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -303,1 +303,1 @@\n-            \/\/ content of the file should have had no no effect yet.\n+            \/\/ content of the file should have had no effect yet.\n","filename":"test\/jdk\/java\/util\/logging\/LogManager\/Configuration\/updateConfiguration\/SimpleUpdateConfigurationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3116,1 +3116,1 @@\n-     * not in the file because the escapes should be be processed\n+     * not in the file because the escapes should be processed\n","filename":"test\/jdk\/java\/util\/regex\/RegExTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-                    throw new Error(\"exception exception not thrown\");\n+                    throw new Error(\"exception not thrown\");\n","filename":"test\/jdk\/java\/util\/spi\/ToolProviderTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.EventQueue;\n+import java.util.Arrays;\n+\n+import javax.swing.JPasswordField;\n+import javax.swing.text.AttributeSet;\n+import javax.swing.text.BadLocationException;\n+import javax.swing.text.Document;\n+import javax.swing.text.DocumentFilter;\n+import javax.swing.text.PlainDocument;\n+\n+\/**\n+ * @test\n+ * @bug 8296878\n+ * @summary can the old password be accessed in the DocumentFilter\n+ *\/\n+public final class OldPasswordInDocumentFilter {\n+\n+    public static void main(String[] args) throws Exception {\n+        EventQueue.invokeAndWait(OldPasswordInDocumentFilter::test);\n+    }\n+\n+    private static void test() {\n+        JPasswordField test = new JPasswordField();\n+        PlainDocument document = (PlainDocument) test.getDocument();\n+        document.setDocumentFilter(new DocumentFilter() {\n+            @Override\n+            public void replace(FilterBypass fb, int offset,\n+                                int length, String text, AttributeSet attrs)\n+                    throws BadLocationException\n+            {\n+                Document doc = fb.getDocument();\n+                String string = doc.getText(0, doc.getLength()) + text;\n+                if (string.length() <= 6 && string.matches(\"[0-9]+\")) {\n+                    super.replace(fb, offset, length, text, attrs);\n+                }\n+            }\n+        });\n+        test.setText(\"123456\");\n+        test.setText(\"\");\n+\n+        char[] password = test.getPassword();\n+        if (password.length != 0) {\n+            throw new RuntimeException(Arrays.toString(password));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JPasswordField\/OldPasswordInDocumentFilter.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 6788481\n+ *  @key headful\n+ * @summary  Verifies if CellEditorListener.editingCanceled is called\n+ * @run main BugCellEditorListener\n+ *\/\n+\n+import java.awt.Robot;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import javax.swing.DefaultCellEditor;\n+import javax.swing.JFrame;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTable;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+import javax.swing.event.CellEditorListener;\n+import javax.swing.event.ChangeEvent;\n+\n+public class BugCellEditorListener {\n+    static Robot robot;\n+    static JFrame frame;\n+    static JTable table;\n+    static volatile Point pt;\n+    static volatile boolean cancelled;\n+\n+    private static void setLookAndFeel(UIManager.LookAndFeelInfo laf) {\n+        try {\n+            UIManager.setLookAndFeel(laf.getClassName());\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Unsupported L&F: \" + laf.getClassName());\n+        } catch (ClassNotFoundException | InstantiationException\n+                 | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static void main(String [] args) throws Exception {\n+        for (UIManager.LookAndFeelInfo laf : UIManager.getInstalledLookAndFeels()) {\n+            System.out.println(\"Testing l&f : \" + laf.getClassName());\n+            SwingUtilities.invokeAndWait(() -> setLookAndFeel(laf));\n+            test();\n+        }\n+    }\n+\n+    private static void test() throws Exception {\n+        try {\n+            robot = new Robot();\n+            robot.setAutoDelay(100);\n+            SwingUtilities.invokeAndWait(() -> {\n+                frame = new JFrame();\n+                table = new JTable(5, 5);\n+                table.setPreferredScrollableViewportSize(table.getPreferredSize());\n+                JScrollPane scrollpane = new JScrollPane(table);\n+                frame.getContentPane().add(scrollpane);\n+\n+                DefaultCellEditor dce = (DefaultCellEditor) table.getDefaultEditor(Object.class);\n+                dce.addCellEditorListener(new CellEditorListener() {\n+                    public void editingStopped(ChangeEvent e) {\n+                        System.out.println(\"stopped\");\n+                    }\n+\n+                    public void editingCanceled(ChangeEvent e) {\n+                        System.out.println(\"canceled\");\n+                        cancelled = true;\n+                    }\n+                });\n+\n+\n+                frame.pack();\n+                frame.setLocationRelativeTo(null);\n+                frame.setVisible(true);\n+            });\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            SwingUtilities.invokeAndWait(() -> {\n+                Rectangle rect = table.getCellRect(2, 0, false);\n+                pt = new Point(rect.x + rect.width \/ 2, rect.y + rect.height \/ 2);\n+                SwingUtilities.convertPointToScreen(pt, table);\n+            });\n+            robot.mouseMove(pt.x, pt.y);\n+            robot.waitForIdle();\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n+            robot.keyPress(KeyEvent.VK_A);\n+            robot.keyRelease(KeyEvent.VK_A);\n+            robot.keyPress(KeyEvent.VK_A);\n+            robot.keyRelease(KeyEvent.VK_A);\n+            robot.waitForIdle();\n+            robot.keyPress(KeyEvent.VK_ESCAPE);\n+            robot.keyRelease(KeyEvent.VK_ESCAPE);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            if (!cancelled) {\n+                throw new RuntimeException(\"Cell editing cancel listener not called\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JTable\/BugCellEditorListener.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8296660\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Verifies Swing HTML table with omitted closing tags parsed correctly\n+ * @run main\/manual TestHtmlOptionalClosingTag\n+ *\/\n+\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+import javax.swing.SwingUtilities;\n+\n+public class TestHtmlOptionalClosingTag {\n+\n+    private static JFrame frame;\n+\n+    private static final String INSTRUCTIONS =\n+        \" A Swing JLabel with a two-column HTML table is shown\\n \" +\n+        \" If the table is shown without any alignment issue\\n \" +\n+        \" then press Pass, otherwise test fails\";\n+\n+    public static void createAndShowGUI() {\n+        frame = new JFrame();\n+        String html = \"<html><table>\" +\n+            \"<tr><th align=right>Name:<td>sync-001.mp4\" +\n+            \"<tr><th align=right>Modified:<td>2017-Jul-31, 00:14:55\" +\n+            \"<tr><th align=right>File size:<td>3.1 MB\" +\n+            \"<tr><th align=right>Duration:<td>1m03s\" +\n+            \"<tr><th align=right>Video:<td>854 x 480 - 16:9 - 30.0 fps - 271 kbps - H.264 \/ AVC\" +\n+            \"<tr><th align=right>Audio:<td>Stereo - 44100 Hz - 123 kbps - AAC\";\n+\n+        JLabel label = new JLabel(html);\n+        frame.add(label);\n+        frame.setSize(400, 400);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+\n+    public static void main(String[] argv) throws Exception {\n+        PassFailJFrame passFailJFrame = new PassFailJFrame(\n+                \"SwingHtmlTable Test\", INSTRUCTIONS, 5);\n+        SwingUtilities.invokeAndWait(() -> createAndShowGUI());\n+        PassFailJFrame.addTestWindow(frame);\n+        PassFailJFrame.positionTestWindow(\n+                frame, PassFailJFrame.Position.HORIZONTAL);\n+        passFailJFrame.awaitAndCheck();\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/swing\/text\/html\/parser\/TestHtmlOptionalClosingTag.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -260,1 +260,1 @@\n-     * @return return true if starts with either \/packages or \/modules\n+     * @return true if starts with either \/packages or \/modules\n","filename":"test\/jdk\/jdk\/internal\/jimage\/JImageReadTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-                \/\/ nested remove for for same key and any value (even null)\n+                \/\/ nested remove for same key and any value (even null)\n","filename":"test\/jdk\/jdk\/internal\/loader\/ClassLoaderValue\/ClassLoaderValueTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,2 @@\n-* @run testng\/othervm --enable-preview -Xint Basic\n+* @enablePreview\n+* @run testng\/othervm -Xint Basic\n@@ -35,5 +36,5 @@\n-* @run testng\/othervm --enable-preview -Xcomp -XX:TieredStopAtLevel=3 -XX:CompileOnly=jdk\/internal\/vm\/Continuation,Basic Basic\n-* @run testng\/othervm --enable-preview -Xcomp -XX:-TieredCompilation -XX:CompileOnly=jdk\/internal\/vm\/Continuation,Basic Basic\n-* @run testng\/othervm --enable-preview -Xcomp -XX:-TieredCompilation -XX:CompileOnly=jdk\/internal\/vm\/Continuation,Basic -XX:CompileCommand=exclude,Basic.manyArgsDriver Basic\n-* @run testng\/othervm --enable-preview -Xcomp -XX:-TieredCompilation -XX:CompileOnly=jdk\/internal\/vm\/Continuation,Basic -XX:CompileCommand=exclude,jdk\/internal\/vm\/Continuation.enter Basic\n-* @run testng\/othervm --enable-preview -Xcomp -XX:-TieredCompilation -XX:CompileOnly=jdk\/internal\/vm\/Continuation,Basic -XX:CompileCommand=inline,jdk\/internal\/vm\/Continuation.run Basic\n+* @run testng\/othervm -Xcomp -XX:TieredStopAtLevel=3 -XX:CompileOnly=jdk\/internal\/vm\/Continuation,Basic Basic\n+* @run testng\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=jdk\/internal\/vm\/Continuation,Basic Basic\n+* @run testng\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=jdk\/internal\/vm\/Continuation,Basic -XX:CompileCommand=exclude,Basic.manyArgsDriver Basic\n+* @run testng\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=jdk\/internal\/vm\/Continuation,Basic -XX:CompileCommand=exclude,jdk\/internal\/vm\/Continuation.enter Basic\n+* @run testng\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=jdk\/internal\/vm\/Continuation,Basic -XX:CompileCommand=inline,jdk\/internal\/vm\/Continuation.run Basic\n@@ -49,3 +50,4 @@\n-* @run testng\/othervm --enable-preview -XX:+VerifyStack -Xint Basic\n-* @run testng\/othervm --enable-preview -XX:+VerifyStack -Xcomp -XX:TieredStopAtLevel=3 -XX:CompileOnly=jdk\/internal\/vm\/Continuation,Basic Basic\n-* @run testng\/othervm --enable-preview -XX:+VerifyStack -Xcomp -XX:-TieredCompilation -XX:CompileOnly=jdk\/internal\/vm\/Continuation,Basic Basic\n+* @enablePreview\n+* @run testng\/othervm -XX:+VerifyStack -Xint Basic\n+* @run testng\/othervm -XX:+VerifyStack -Xcomp -XX:TieredStopAtLevel=3 -XX:CompileOnly=jdk\/internal\/vm\/Continuation,Basic Basic\n+* @run testng\/othervm -XX:+VerifyStack -Xcomp -XX:-TieredCompilation -XX:CompileOnly=jdk\/internal\/vm\/Continuation,Basic Basic\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Basic.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,1146 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test id=policy-1-without-gc-with-verification\n+ * @summary Collection of basic continuation tests. CompilationPolicy controls which frames in a sequence should be compiled when calling Continuation.yield().\n+ * @requires vm.continuations\n+ * @requires vm.flavor == \"server\" & vm.opt.TieredCompilation != true\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.vm\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build java.base\/java.lang.StackWalkerHelper\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                     -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyContinuations -Xbatch -XX:-TieredCompilation\n+ *                     -XX:CompileCommand=dontinline,*::*dontinline*\n+ *                     -XX:CompileCommand=dontinline,*::*dontjit*\n+ *                     -XX:CompileCommand=exclude,*::*dontjit*\n+ *                     -XX:CompileCommand=dontinline,java\/lang\/String*.*\n+ *                     BasicExt 1 0\n+ *\/\n+\n+\/**\n+ * @test id=policy-2-without-gc-with-verification\n+ * @summary Collection of basic continuation tests. CompilationPolicy controls which frames in a sequence should be compiled when calling Continuation.yield().\n+ * @requires vm.continuations\n+ * @requires vm.flavor == \"server\" & vm.opt.TieredCompilation != true\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.vm\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build java.base\/java.lang.StackWalkerHelper\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                     -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyContinuations -Xbatch -XX:-TieredCompilation\n+ *                     -XX:CompileCommand=dontinline,*::*dontinline*\n+ *                     -XX:CompileCommand=dontinline,*::*dontjit*\n+ *                     -XX:CompileCommand=exclude,*::*dontjit*\n+ *                     -XX:CompileCommand=dontinline,java\/lang\/String*.*\n+ *                     BasicExt 2 0\n+ *\/\n+\n+\/**\n+ * @test id=policy-3-without-gc-with-verification\n+ * @summary Collection of basic continuation tests. CompilationPolicy controls which frames in a sequence should be compiled when calling Continuation.yield().\n+ * @requires vm.continuations\n+ * @requires vm.flavor == \"server\" & vm.opt.TieredCompilation != true\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.vm\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build java.base\/java.lang.StackWalkerHelper\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                     -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyContinuations -Xbatch -XX:-TieredCompilation\n+ *                     -XX:CompileCommand=dontinline,*::*dontinline*\n+ *                     -XX:CompileCommand=dontinline,*::*dontjit*\n+ *                     -XX:CompileCommand=exclude,*::*dontjit*\n+ *                     -XX:CompileCommand=dontinline,java\/lang\/String*.*\n+ *                     BasicExt 3 0\n+ *\/\n+\n+\/**\n+ * @test id=policy-4-without-gc-with-verification\n+ * @summary Collection of basic continuation tests. CompilationPolicy controls which frames in a sequence should be compiled when calling Continuation.yield().\n+ * @requires vm.continuations\n+ * @requires vm.flavor == \"server\" & vm.opt.TieredCompilation != true\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.vm\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build java.base\/java.lang.StackWalkerHelper\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                     -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyContinuations -Xbatch -XX:-TieredCompilation\n+ *                     -XX:CompileCommand=dontinline,*::*dontinline*\n+ *                     -XX:CompileCommand=dontinline,*::*dontjit*\n+ *                     -XX:CompileCommand=exclude,*::*dontjit*\n+ *                     -XX:CompileCommand=dontinline,java\/lang\/String*.*\n+ *                     BasicExt 4 0\n+ *\/\n+\n+\/**\n+ * @test id=policy-5-without-gc-with-verification\n+ * @summary Collection of basic continuation tests. CompilationPolicy controls which frames in a sequence should be compiled when calling Continuation.yield().\n+ * @requires vm.continuations\n+ * @requires vm.flavor == \"server\" & vm.opt.TieredCompilation != true\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.vm\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build java.base\/java.lang.StackWalkerHelper\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                     -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyContinuations -Xbatch -XX:-TieredCompilation\n+ *                     -XX:CompileCommand=dontinline,*::*dontinline*\n+ *                     -XX:CompileCommand=dontinline,*::*dontjit*\n+ *                     -XX:CompileCommand=exclude,*::*dontjit*\n+ *                     -XX:CompileCommand=dontinline,java\/lang\/String*.*\n+ *                     BasicExt 5 0\n+ *\/\n+\n+\/**\n+ * @test id=policy-1-with-gc-without-verification\n+ * @summary Collection of basic continuation tests. CompilationPolicy controls which frames in a sequence should be compiled when calling Continuation.yield().\n+ * @requires vm.continuations\n+ * @requires vm.flavor == \"server\" & vm.opt.TieredCompilation != true\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.vm\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build java.base\/java.lang.StackWalkerHelper\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                     -Xbatch -XX:-TieredCompilation\n+ *                     -XX:CompileCommand=dontinline,*::*dontinline*\n+ *                     -XX:CompileCommand=dontinline,*::*dontjit*\n+ *                     -XX:CompileCommand=exclude,*::*dontjit*\n+ *                     -XX:CompileCommand=dontinline,java\/lang\/String*.*\n+ *                     BasicExt 1 1\n+ *\/\n+\n+\/**\n+ * @test id=policy-2-with-gc-without-verification\n+ * @summary Collection of basic continuation tests. CompilationPolicy controls which frames in a sequence should be compiled when calling Continuation.yield().\n+ * @requires vm.continuations\n+ * @requires vm.flavor == \"server\" & vm.opt.TieredCompilation != true\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.vm\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build java.base\/java.lang.StackWalkerHelper\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                     -Xbatch -XX:-TieredCompilation\n+ *                     -XX:CompileCommand=dontinline,*::*dontinline*\n+ *                     -XX:CompileCommand=dontinline,*::*dontjit*\n+ *                     -XX:CompileCommand=exclude,*::*dontjit*\n+ *                     -XX:CompileCommand=dontinline,java\/lang\/String*.*\n+ *                     BasicExt 2 1\n+ *\/\n+\n+\/**\n+ * @test id=policy-3-with-gc-without-verification\n+ * @summary Collection of basic continuation tests. CompilationPolicy controls which frames in a sequence should be compiled when calling Continuation.yield().\n+ * @requires vm.continuations\n+ * @requires vm.flavor == \"server\" & vm.opt.TieredCompilation != true\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.vm\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build java.base\/java.lang.StackWalkerHelper\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                     -Xbatch -XX:-TieredCompilation\n+ *                     -XX:CompileCommand=dontinline,*::*dontinline*\n+ *                     -XX:CompileCommand=dontinline,*::*dontjit*\n+ *                     -XX:CompileCommand=exclude,*::*dontjit*\n+ *                     -XX:CompileCommand=dontinline,java\/lang\/String*.*\n+ *                     BasicExt 3 1\n+ *\/\n+\n+\/**\n+ * @test id=policy-4-with-gc-without-verification\n+ * @summary Collection of basic continuation tests. CompilationPolicy controls which frames in a sequence should be compiled when calling Continuation.yield().\n+ * @requires vm.continuations\n+ * @requires vm.flavor == \"server\" & vm.opt.TieredCompilation != true\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.vm\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build java.base\/java.lang.StackWalkerHelper\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                     -Xbatch -XX:-TieredCompilation\n+ *                     -XX:CompileCommand=dontinline,*::*dontinline*\n+ *                     -XX:CompileCommand=dontinline,*::*dontjit*\n+ *                     -XX:CompileCommand=exclude,*::*dontjit*\n+ *                     -XX:CompileCommand=dontinline,java\/lang\/String*.*\n+ *                     BasicExt 4 1\n+ *\/\n+\n+\/**\n+ * @test id=policy-5-with-gc-without-verification\n+ * @summary Collection of basic continuation tests. CompilationPolicy controls which frames in a sequence should be compiled when calling Continuation.yield().\n+ * @requires vm.continuations\n+ * @requires vm.flavor == \"server\" & vm.opt.TieredCompilation != true\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.vm\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build java.base\/java.lang.StackWalkerHelper\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                     -Xbatch -XX:-TieredCompilation\n+ *                     -XX:CompileCommand=dontinline,*::*dontinline*\n+ *                     -XX:CompileCommand=dontinline,*::*dontjit*\n+ *                     -XX:CompileCommand=exclude,*::*dontjit*\n+ *                     -XX:CompileCommand=dontinline,java\/lang\/String*.*\n+ *                     BasicExt 5 1\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.vm.Continuation;\n+import jdk.internal.vm.ContinuationScope;\n+import static jdk.test.lib.Asserts.*;\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class BasicExt {\n+    static final ContinuationScope THE_SCOPE = new ContinuationScope() {};\n+\n+    public static final Pattern COMP_NONE  = Pattern.compile(\"COMP_NONE\");\n+    public static final Pattern COMP_ALL   = Pattern.compile(\"COMP_ALL\");\n+    public static final Pattern CONT_METHS = Pattern.compile(\"^(enter|enter0|yield|yield0)$\");\n+\n+    public static int compPolicySelection;\n+    public static boolean triggerGCAfterYield;\n+    public static int compLevel;\n+\n+    public static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    enum TestCaseVariants {\n+        NO_VARIANT,\n+        \/\/ Exception\n+        THROW_HANDLED_EXCEPTION,\n+        THROW_UNHANDLED_EXCEPTION,\n+        \/\/ Synchronization\n+        ALLOC_MONITOR,\n+        \/\/ There are values on the expression stack that are not call parameters\n+        EXPR_STACK_NOT_EMPTY,\n+    }\n+\n+    public static class HandledException extends Exception { }\n+    public static class UnhandledException extends Error { }\n+\n+    public static void main(String[] args) {\n+        try {\n+            \/\/ Run tests with C2 compilations\n+            compLevel = CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION;\n+            \/\/ \/\/ Run tests with C1 compilations\n+            \/\/ compLevel = CompilerWhiteBoxTest.COMP_LEVEL_FULL_PROFILE;\n+\n+            compPolicySelection = Integer.parseInt(args[0]);\n+            triggerGCAfterYield = Integer.parseInt(args[1]) == 1;\n+            runTests();\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+        }\n+    }\n+\n+    public static void runTests() {\n+        System.out.println(\"$$$0 Running test cases with the following settings:\");\n+        System.out.println(\"compLevel=\" + compLevel);\n+        System.out.println(\"callSystemGC=\" + triggerGCAfterYield);\n+        System.out.println();\n+\n+        WB.deoptimizeAll();\n+\n+        boolean all = compPolicySelection == 0;\n+        if (compPolicySelection == 1 || all)\n+            runTests(new CompilationPolicy(7 \/*warmup*\/, COMP_NONE, COMP_NONE \/*Cont. pattern*\/));\n+        if (compPolicySelection == 2 || all)\n+            runTests(new CompilationPolicy(7 \/*warmup*\/, 1 \/* length comp. window *\/));\n+        if (compPolicySelection == 3 || all)\n+            runTests(new CompilationPolicy(7 \/*warmup*\/, 2 \/* length comp. window *\/));\n+        if (compPolicySelection == 4 || all)\n+            runTests(new CompilationPolicy(7 \/*warmup*\/, 3 \/* length comp. window *\/));\n+        if (compPolicySelection == 5 || all)\n+            runTests(new CompilationPolicy(7 \/*warmup*\/, COMP_ALL, CONT_METHS \/*Cont. pattern*\/));\n+        if (compPolicySelection >= 6)\n+            throw new Error(\"CompilationPolicy with number \" + compPolicySelection + \" does not exist\");\n+    }\n+\n+    public static void runTests(CompilationPolicy compPolicy) {\n+        System.out.println(\"$$$1 Running test cases with the following policy:\");\n+        compPolicy.print(); System.out.println();\n+\n+        new ContinuationRunYieldRunTest().runTestCase(3, compPolicy);\n+        new Continuation3Frames(TestCaseVariants.NO_VARIANT).runTestCase(4, compPolicy);\n+        new Continuation3Frames(TestCaseVariants.THROW_HANDLED_EXCEPTION).runTestCase(4, compPolicy);\n+        new Continuation3Frames(TestCaseVariants.THROW_UNHANDLED_EXCEPTION).runTestCase(4, compPolicy);\n+        new Continuation3Frames(TestCaseVariants.ALLOC_MONITOR).runTestCase(4, compPolicy);\n+        new Continuation3Frames(TestCaseVariants.EXPR_STACK_NOT_EMPTY).runTestCase(4, compPolicy);\n+        new ContinuationRunYieldRunTest().runTestCase( 1, compPolicy);\n+        new ContinuationYieldEnlargeStackYield().runTestCase(1, compPolicy);\n+        new ContinuationYieldReduceStackYield().runTestCase(1, compPolicy);\n+        new ContinuationCompiledFramesWithStackArgs_3c0().runTestCase(1, compPolicy);\n+        new ContinuationCompiledFramesWithStackArgs_3c4().runTestCase(1, compPolicy);\n+        new ContinuationCompiledFramesWithStackArgs().runTestCase(1, compPolicy);\n+        new ContinuationDeepRecursion().runTestCase(3, compPolicy);\n+        new ContinuationDeepRecursionStackargs().runTestCase(3, compPolicy);\n+    }\n+\n+    \/\/ Control which frames are compiled\/interpreted when calling Continuation.yield()\n+    \/\/ With COMP_WINDOW the methods in the window are supposed to be compiled and others\n+    \/\/ are interpreted. With DEOPT_WINDOW vice versa.\n+    \/\/ The methods that are subject to the CompilationPolicy are set with setMethods().\n+    \/\/ Their order has to correspond to the stack order when calling yield().\n+    public static class CompilationPolicy {\n+        public int warmupIterations;\n+        public Pattern methodPattern;\n+        public Pattern contMethPattern;\n+\n+        public CompWindowMode compWindowMode;\n+        public int winPos;\n+        public int winLen;\n+\n+        public Method[] methods;\n+\n+        public enum CompWindowMode {\n+            NO_COMP_WINDOW, COMP_WINDOW, DEOPT_WINDOW\n+        }\n+\n+        public CompilationPolicy(int warmupIterations, Pattern methodPattern,\n+                                 Pattern contMethPattern) {\n+            this(warmupIterations, 0, methodPattern, contMethPattern,\n+                 CompWindowMode.NO_COMP_WINDOW);\n+        }\n+\n+        public CompilationPolicy(int warmupIterations, int windowLength,\n+                                 Pattern methodPattern, Pattern contMethPattern) {\n+            this(warmupIterations, windowLength, methodPattern, contMethPattern,\n+                 CompWindowMode.COMP_WINDOW);\n+        }\n+\n+        public CompilationPolicy(int warmupIterations, int windowLength,\n+                                 Pattern methodPattern, Pattern contMethPattern,\n+                                 CompWindowMode startMode) {\n+            this.warmupIterations = warmupIterations;\n+            this.methodPattern = methodPattern;\n+            this.contMethPattern = contMethPattern;\n+            this.winPos = 0;\n+            this.winLen = windowLength;\n+            this.compWindowMode = startMode;\n+        }\n+\n+        public CompilationPolicy(int warmupIterations, int windowLength) {\n+            this(warmupIterations, windowLength, COMP_ALL, CONT_METHS);\n+        }\n+\n+        public int warmupIterations() {\n+            return this.warmupIterations;\n+        }\n+\n+        public boolean compileMethods() {\n+            boolean newCompilation = false;\n+            log(\"@@ Compiling test methods according to compilation policy\");\n+            print();\n+            for (int i = 0; i < methods.length; i++) {\n+                Method meth = methods[i];\n+                boolean inWindow = i >= winPos && i < (winPos + winLen);\n+                boolean shouldBeCompiled = compWindowMode == CompWindowMode.NO_COMP_WINDOW\n+                    || (inWindow && compWindowMode == CompWindowMode.COMP_WINDOW)\n+                    || (!inWindow && compWindowMode == CompWindowMode.DEOPT_WINDOW);\n+                boolean isCompiled = WB.isMethodCompiled(meth);\n+                log(\"methods[\" + i + \"] inWindow=\" + inWindow + \" isCompiled=\" + isCompiled +\n+                    \" shouldBeCompiled=\" + shouldBeCompiled + \" method=`\" + meth + \"`\");\n+                if (isCompiled != shouldBeCompiled) {\n+                    if (shouldBeCompiled) {\n+                        log(\"           Compiling methods[\" + i + \"]\");\n+                        enqForCompilation(meth);\n+                        newCompilation = true;\n+                        assertTrue(WB.isMethodCompiled(meth), \"Run with -Xbatch\");\n+                    } else {\n+                        assertFalse(WB.isMethodQueuedForCompilation(meth), \"Run with -Xbatch\");\n+                        log(\"           Deoptimizing methods[\" + i + \"]\");\n+                        WB.deoptimizeMethod(meth);\n+                    }\n+                }\n+            }\n+            return newCompilation;\n+        }\n+\n+        @SuppressWarnings(\"deprecation\")\n+        public boolean enqForCompilation(Method meth) {\n+            return WB.enqueueMethodForCompilation(meth, compLevel);\n+        }\n+\n+        public void log(String m) {\n+            System.out.println(m);\n+        }\n+\n+        public void print() {\n+            log(\"warmupIterations=\" + warmupIterations);\n+            log(\"methodPattern=\" + methodPattern);\n+            log(\"continuationMethPattern=\" + contMethPattern);\n+            log(\"compWindowMode=\" + compWindowMode);\n+            log(\"winLen=\" + winLen);\n+        }\n+\n+        public void setMethods(Method[] methods) {\n+            this.methods = methods;\n+            if (compWindowMode == CompWindowMode.NO_COMP_WINDOW) {\n+                winLen = methods.length;\n+            }\n+        }\n+\n+        public boolean shiftWindow() {\n+            if (compWindowMode == CompWindowMode.NO_COMP_WINDOW) return false;\n+            if (++winPos == methods.length) {\n+                winPos = 0;\n+                if (compWindowMode == CompWindowMode.DEOPT_WINDOW) {\n+                    compWindowMode = CompWindowMode.COMP_WINDOW;\n+                    return false; \/\/ we're done\n+                }\n+                compWindowMode = CompWindowMode.DEOPT_WINDOW;\n+            }\n+            return true; \/\/ continue\n+        }\n+    }\n+\n+    \/**\n+     * Base class for test cases\n+     *\/\n+    public static abstract class TestCaseBase implements Runnable {\n+        public int yieldCalls;\n+        public int warmUpCount;\n+        public CompilationPolicy compPolicy;\n+        public final TestCaseVariants testVariant;\n+\n+        public TestCaseBase() {\n+            testVariant = TestCaseVariants.NO_VARIANT;\n+        }\n+\n+        public TestCaseBase(TestCaseVariants excBehav) {\n+            this.testVariant = excBehav;\n+        }\n+\n+        public void log_dontjit() {\n+            System.out.println();\n+        }\n+\n+        public void log_dontjit(String m) {\n+            if (warmUpCount > 0) {\n+                System.out.print(\"[\" + warmUpCount + \"] \");\n+            }\n+            System.out.println(m);\n+        }\n+\n+        public void runTestCase(int yieldCalls, CompilationPolicy compPolicy) {\n+            this.yieldCalls = yieldCalls;\n+            log_dontjit(\">>>> Executing test case \" + getClass().getName() +\n+                        \" (yieldCalls=\" + yieldCalls + \", \" + \"testVariant=\" + testVariant + \")\");\n+            init(compPolicy);\n+            try {\n+                log_dontjit(\"Warm-up test case\");\n+                setup_dontjit(true \/* for warmup *\/);\n+                for(warmUpCount = 1; warmUpCount <= compPolicy.warmupIterations(); warmUpCount++) {\n+                    testEntry_dontinline();\n+                }\n+                warmUpCount = 0;\n+                log_dontjit(\"Warm-up test case DONE\");\n+\n+                setup_dontjit(false \/* for warmup *\/);\n+                do {\n+                    compPolicy.compileMethods();\n+                    do {\n+                        log_dontjit(\"Running test case (Reresolve Call Sites)\");\n+                        testEntry_dontinline();\n+                        log_dontjit(\"Running test case DONE  (Reresolve Call Sites)\");\n+                    } while(compPolicy.compileMethods());\n+\n+                    log_dontjit(\"Running test case BEGIN\");\n+                    testEntry_dontinline();\n+                    log_dontjit(\"Running test case DONE\");\n+                } while(compPolicy.shiftWindow());\n+            } finally {\n+                log_dontjit(\"<<<< Finished test case \" + getClass().getName()); log_dontjit();\n+            }\n+        }\n+\n+        public void setup_dontjit(boolean warmup) {\n+        }\n+\n+        public void init(CompilationPolicy compPolicy) {\n+            this.compPolicy = compPolicy;\n+            ArrayList<Method> selectedMethods = new ArrayList<Method>();\n+            Pattern p = compPolicy.methodPattern;\n+            if (p != COMP_NONE) {\n+                Class<? extends TestCaseBase> c = getClass();\n+                Method methods[] = c.getDeclaredMethods();\n+                for (Method meth : methods) {\n+                    if (p == COMP_ALL || p.matcher(meth.getName()).matches()) {\n+                        if (!meth.getName().contains(\"dontjit\")) {\n+                            selectedMethods.add(meth);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            p = compPolicy.contMethPattern;\n+            if (compPolicy.contMethPattern != COMP_NONE) {\n+                Class<?> c = Continuation.class;\n+                Method methods[] = c .getDeclaredMethods();\n+                for (Method meth : methods) {\n+                    if (p.matcher(meth.getName()).matches()) {\n+                        selectedMethods.add(meth);\n+                    }\n+                }\n+            }\n+            \/\/ Sort in caller\/callee order\n+            selectedMethods.sort(new Comparator<Method>() {\n+                    @Override\n+                    public int compare(Method m1, Method m2) {\n+                        String n1 = m1.getName();\n+                        String n2 = m2.getName();\n+                        \/\/ log_dontjit(\"n1=\" + n1 + \" n2=\" + n2);\n+                        int p1 = -1;\n+                        int p2 = -1;\n+                        int i = n1.indexOf(\"ord\");\n+                        if (i >= 0) {\n+                            p1 = Integer.parseInt(n1.substring(i + 3, i + 6));\n+                        }\n+                        i = n2.indexOf(\"ord\");\n+                        if (i >= 0) {\n+                            p2 = Integer.parseInt(n2.substring(i + 3, i + 6));\n+                        }\n+                        if (p1 < 0) p1 = getScoreKnownMethods(n1);\n+                        if (p2 < 0) p2 = getScoreKnownMethods(n2);\n+                        assertFalse(p1 == -1 || p2 == -1, \"Cannot compare \" + n1 + \" with \" + n2);\n+                        return p1 - p2;\n+                    }\n+\n+                    private int getScoreKnownMethods(String n) {\n+                        int p = -1;\n+                        if (n.equals(\"enter\"))  p = 20;   \/\/ Continuation.enter\n+                        if (n.equals(\"enter0\")) p = 30;   \/\/ Continuation.enter0\n+                        if (n.equals(\"run\"))    p = 50;   \/\/ Called by Continuation.enter0\n+                        if (n.equals(\"yield\"))  p = 1000; \/\/ caller of yield0\n+                        if (n.equals(\"yield0\")) p = 2000; \/\/ top frame\n+                        return p;\n+                    }\n+                });\n+            compPolicy.setMethods(selectedMethods.toArray(new Method[selectedMethods.size()]));\n+        }\n+\n+        public void testEntry_dontinline() {\n+            Continuation cont = new Continuation(THE_SCOPE, this);\n+            do {\n+                try {\n+                    cont.run();\n+                } catch (UnhandledException e) {\n+                    log_dontjit(\"Exc: \" + e);\n+                }\n+                if (triggerGCAfterYield) WB.youngGC();\n+                checkFrames_dontjit(cont);\n+            } while (!cont.isDone());\n+        }\n+\n+        public void checkFrames_dontjit(Continuation cont) {\n+        } \/\/ Override in subclass as appropriate\n+\n+        @Override\n+        public void run() {\n+            fail(\"Should not call TestCaseBase::run\");\n+        }\n+\n+        public void sleep(Duration d) {\n+            try { Thread.sleep(d); }\n+            catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+\n+        static final long i1=1; static final long i2=2; static final long i3=3;\n+        static final long i4=4; static final long i5=5; static final long i6=6;\n+        static final long i7=7; static final long i8=8; static final long i9=9;\n+        static final long i10=10; static final long i11=11; static final long\n+        i12=12; static final long i13=13; static final long i14=14; static final\n+        long i15=15; static final long i16=16;\n+    }\n+\n+    \/**\n+     * Trivial run\/yield\/run test\n+     *\/\n+    public static class ContinuationRunYieldRunTest extends TestCaseBase {\n+        public String sField;\n+\n+        @Override\n+        public void run() {\n+            log_dontjit(\"Continuation running on thread \" + Thread.currentThread());\n+            for(int i = 0; i < yieldCalls; i++) {\n+                log_dontjit(\"Yield #\" + i);\n+                String s1 = \"str1\";\n+                Continuation.yield(THE_SCOPE);\n+                String s2 = s1 + \"str2\";\n+                sField = s2;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Yield, make continuation (stack) larger, yield again.\n+     *\/\n+    public static class ContinuationYieldEnlargeStackYield extends TestCaseBase {\n+        @Override\n+        public void run() {\n+            log_dontjit(\"Continuation running on thread \" + Thread.currentThread());\n+            Continuation.yield(THE_SCOPE);\n+            log_dontjit(\"Back from 1st yield. Now call a method to make the stack larger.\");\n+            ord101_callYieldWithLargerStackAgain_dontinline();\n+        }\n+\n+        private void ord101_callYieldWithLargerStackAgain_dontinline() {\n+            log_dontjit(\"Now there's a new frame on stack. Call yield again.\");\n+            Continuation.yield(THE_SCOPE);\n+            log_dontjit(\"Back again after 2nd yield.\");\n+        }\n+    }\n+\n+\n+    \/**\n+     * Yield, make continuation (stack) larger, yield again.\n+     *\/\n+    public static class ContinuationYieldReduceStackYield extends TestCaseBase {\n+        @Override\n+        public void run() {\n+            log_dontjit(\"Continuation running on thread \" + Thread.currentThread());\n+            ord101_methodWithFirstYield_dontinline();\n+            log_dontjit(\"The frame of ord101_methodWithFirstYield_dontinline has been removed now. Call yield again.\");\n+            Continuation.yield(THE_SCOPE);\n+            log_dontjit(\"Back again after 2nd yield.\");\n+        }\n+\n+        public void ord101_methodWithFirstYield_dontinline() {\n+            Continuation.yield(THE_SCOPE);\n+            log_dontjit(\"Back from 1st yield. Now return to reduce stack size.\");\n+        }\n+    }\n+\n+    \/**\n+     * Freeze\/thaw 3 compiled frames.\n+     *\/\n+    public static class Continuation3Frames extends TestCaseBase {\n+        public int yieldCount;\n+        public long resLong;\n+        public volatile String putOnExprStack;\n+\n+        public Continuation3Frames(TestCaseVariants excBehav) {\n+            super(excBehav);\n+        }\n+\n+        @Override\n+        public void run() {\n+            for(int i = 0; i < yieldCalls; i++) {\n+                Throwable caughtException = null;\n+                putOnExprStack = \"exprStckVal \";\n+                resLong = 0;\n+                try {\n+                    String s1 = \"str1\";\n+                    String result = ord101_testMethod_dontinline(i1, i2, i3, s1);\n+                    assertEQ(resLong, testVariant == TestCaseVariants.ALLOC_MONITOR ? 7L : 6L);\n+                    assertEQ(result, testVariant == TestCaseVariants.EXPR_STACK_NOT_EMPTY ?\n+                             \"exprStckVal str1str2str3\" : \"str1str2str3\");\n+                } catch (HandledException e) {\n+                    caughtException = e;\n+                }\n+                assertTrue(testVariant != TestCaseVariants.THROW_HANDLED_EXCEPTION\n+                           || (caughtException instanceof HandledException),\n+                           \"Exception handling error\");\n+            }\n+        }\n+\n+        public String ord101_testMethod_dontinline(long a1, long a2, long a3, String s1)\n+            throws HandledException {\n+            String s2 = s1 + \"str2\";\n+            return ord102_testMethod_dontinline(a1, a2, a3, s2);\n+        }\n+\n+        public String ord102_testMethod_dontinline(long a1, long a2, long a3, String s2)\n+            throws HandledException {\n+            if (testVariant == TestCaseVariants.ALLOC_MONITOR) {\n+                synchronized (this) {\n+                    resLong++;\n+                }\n+            }\n+            if (testVariant == TestCaseVariants.EXPR_STACK_NOT_EMPTY) {\n+                return putOnExprStack_testMethod_dontjit_dontinline()\n+                    + ord103_testMethod_dontinline(a1, a2, a3, s2);\n+            } else {\n+                return ord103_testMethod_dontinline(a1, a2, a3, s2);\n+            }\n+        }\n+\n+        public String ord103_testMethod_dontinline(long a1, long a2, long a3, String s2)\n+            throws HandledException {\n+            return ord104_testMethod_dontinline(a1, a2, a3, s2);\n+        }\n+\n+        public String ord104_testMethod_dontinline(long a1, long a2, long a3, String s2)\n+            throws HandledException {\n+            long res = a2;\n+            String s3 = s2 + \"str3\";\n+            log_dontjit(\"Yield #\" + yieldCount++);\n+            Continuation.yield(THE_SCOPE);\n+            log_dontjit(\"\/Yield #\" + yieldCount);\n+            if (testVariant == TestCaseVariants.THROW_HANDLED_EXCEPTION) {\n+                log_dontjit(\"Exc: throw handled\");\n+                throw new HandledException();\n+            }\n+            if (testVariant == TestCaseVariants.THROW_UNHANDLED_EXCEPTION) {\n+                log_dontjit(\"Exc: throw unhandled\");\n+                throw new UnhandledException();\n+            }\n+            resLong += res + a1 + a3;\n+            return s3;\n+        }\n+\n+        public String putOnExprStack_testMethod_dontjit_dontinline() {\n+            return putOnExprStack;\n+        }\n+\n+        @Override\n+        public void checkFrames_dontjit(Continuation cont) {\n+            List<String> frames =\n+                cont.stackWalker()\n+                .walk(fs -> fs.map(StackWalker.StackFrame::getMethodName).collect(Collectors.toList()));\n+            assertEquals(frames, cont.isDone() ? List.of()\n+                         : Arrays.asList(\"yield\", \"ord104_testMethod_dontinline\",\n+                                         \"ord103_testMethod_dontinline\",\n+                                         \"ord102_testMethod_dontinline\",\n+                                         \"ord101_testMethod_dontinline\",\n+                                         \"run\", \"enter0\", \"enter\"));\n+        }\n+    }\n+\n+    \/**\n+     * Deep recursion to exercise fast freezing into non-empty chunk\n+     *\/\n+    public static class ContinuationDeepRecursion extends TestCaseBase {\n+        public int limit;\n+        public int yield1_depth;\n+        public int yield2_depth;\n+\n+        @Override\n+        public void setup_dontjit(boolean warmup) {\n+            if (warmup) {\n+                limit = 10;\n+                yield1_depth = 7;\n+                yield2_depth = 3;\n+            } else {\n+                limit = 100;\n+                yield1_depth = 70;\n+                yield2_depth = 60;\n+            }\n+        }\n+\n+        @Override\n+        public void run() {\n+            log_dontjit(\"Continuation running on thread \" + Thread.currentThread());\n+            ord101_recurse_dontinline(0);\n+        }\n+\n+        public void ord101_recurse_dontinline(int depth) {\n+            if (depth >= limit) {\n+                log_dontjit(\"yield at depth \" + depth);\n+                ord102_yield_dontinline(0);\n+                log_dontjit(\"After yield at depth \" + depth);\n+                return;\n+            }\n+            ord101_recurse_dontinline(depth + 1);\n+            if (depth == yield1_depth || depth == yield2_depth) {\n+                log_dontjit(\"yield at depth \" + depth);\n+                ord102_yield_dontinline(0);\n+                log_dontjit(\"After yield at depth \" + depth);\n+            }\n+        }\n+\n+        \/\/ Add a few frames before yield\n+        public void ord102_yield_dontinline(int depth) {\n+            if (depth >= 2) {\n+                Continuation.yield(THE_SCOPE);\n+                return;\n+            }\n+            ord102_yield_dontinline(depth + 1);\n+        }\n+    }\n+\n+    \/**\n+     * Deep recursion to exercise fast freezing into non-empty chunk.\n+     * nmethods have stack arguments.\n+     *\/\n+    public static class ContinuationDeepRecursionStackargs extends TestCaseBase {\n+        public int limit;\n+        public int yield1_depth;\n+        public int yield2_depth;\n+\n+        @Override\n+        public void setup_dontjit(boolean warmup) {\n+            if (warmup) {\n+                limit = 10;\n+                yield1_depth = 7;\n+                yield2_depth = 3;\n+            } else {\n+                limit = 100;\n+                yield1_depth = 70;\n+                yield2_depth = 60;\n+            }\n+        }\n+\n+        @Override\n+        public void run() {\n+            log_dontjit(\"Continuation running on thread \" + Thread.currentThread());\n+            long res = ord101_recurse_dontinline(0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);\n+            if (res != i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10 + i11) {\n+                throw new Error();\n+            }\n+        }\n+\n+        public long ord101_recurse_dontinline(int depth, long l1, long l2, long\n+                                              l3, long l4, long l5, long l6,\n+                                              long l7, long l8, long l9, long\n+                                              l10, long l11) {\n+            if (depth >= limit) {\n+                log_dontjit(\"yield at depth \" + depth);\n+                ord102_yield_dontinline(0, l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11);\n+                log_dontjit(\"After yield at depth \" + depth);\n+                return l1 + l2 + l3 + l4 + l5 + l6 + l7 + l8 + l9 + l10 + l11;\n+            }\n+            long res = ord101_recurse_dontinline(depth + 1, l1, l2, l3, l4, l5,\n+                                                 l6, l7, l8, l9, l10, l11);\n+            if (res != l1 + l2 + l3 + l4 + l5 + l6 + l7 + l8 + l9 + l10 + l11) {\n+                throw new Error();\n+            }\n+            if (depth == yield1_depth || depth == yield2_depth) {\n+                log_dontjit(\"yield at depth \" + depth);\n+                long res1 = ord102_yield_dontinline(0, l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11);\n+                if (res1 != l1 + l2 + l3 + l4 + l5 + l6 + l7 + l8 + l9 + l10 + l11) {\n+                    throw new Error();\n+                }\n+                log_dontjit(\"After yield at depth \" + depth);\n+            }\n+            return res;\n+        }\n+\n+        \/\/ Add a few frames before yield\n+        public long ord102_yield_dontinline(int depth, long l1, long l2, long l3, long l4, long l5,\n+                                            long l6, long l7, long l8, long l9, long l10, long l11) {\n+            if (depth >= 2) {\n+                Continuation.yield(THE_SCOPE);\n+                return l1 + l2 + l3 + l4 + l5 + l6 + l7 + l8 + l9 + l10 + l11;\n+            }\n+            long res = ord102_yield_dontinline(depth + 1, l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11);\n+            if (res != l1 + l2 + l3 + l4 + l5 + l6 + l7 + l8 + l9 + l10 + l11) {\n+                throw new Error();\n+            }\n+            return res;\n+        }\n+    }\n+\n+    \/**\n+     * Freeze\/thaw compiled frame with a few stack arguments\n+     * icj is a call with i incoming stack parameters and j outgoing stack parameters.\n+     *\/\n+    public static class ContinuationCompiledFramesWithStackArgs_3c0 extends TestCaseBase {\n+        public int yieldCount;\n+\n+        @Override\n+        public void run() {\n+            log_dontjit(\"Continuation running on thread \" + Thread.currentThread());\n+            yieldCount = 0;\n+            long result = ord101_testMethod_dontinline();\n+            assertEQ(result, 136L);\n+        }\n+\n+        public long ord101_testMethod_dontinline() {\n+            long res = ord102_testMethod_dontinline(i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11);\n+            log_dontjit(\"Yield #\" + yieldCount);\n+            log_dontjit(\"ord108_testMethod_dontinline res=\" + res);\n+            Continuation.yield(THE_SCOPE);\n+            log_dontjit(\"a\/y ord108_testMethod_dontinline res=\" + res);\n+            log_dontjit(\"\/Yield #\" + yieldCount++);\n+            return res;\n+        }\n+\n+        public long ord102_testMethod_dontinline(long a1, long a2, long a3, long\n+                                                 a4, long a5, long a6, long a7,\n+                                                 long a8, long a9, long a10,\n+                                                 long a11) {\n+            long res = a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11\n+                       + i12 + i13 + i14 + i15 + i16;\n+            log_dontjit(\"Yield #\" + yieldCount);\n+            log_dontjit(\"ord109_testMethod_dontinline res=\" + res);\n+            Continuation.yield(THE_SCOPE);\n+            log_dontjit(\"a\/y ord109_testMethod_dontinline res=\" + res);\n+            log_dontjit(\"\/Yield #\" + yieldCount++);\n+            return res;\n+        }\n+    }\n+\n+    \/**\n+     * Freeze\/thaw compiled frame with a few stack arguments, incoming _and_ outgoing\n+     * icj is a call with i incoming stack parameters and j outgoing stack parameters.\n+     *\/\n+    public static class ContinuationCompiledFramesWithStackArgs_3c4 extends TestCaseBase {\n+        public int yieldCount;\n+\n+        @Override\n+        public void run() {\n+            log_dontjit(\"Continuation running on thread \" + Thread.currentThread());\n+            yieldCount = 0;\n+            long result = ord101_testMethod_dontinline();\n+            assertEQ(result, 136L);\n+        }\n+\n+        public long ord101_testMethod_dontinline() {\n+            long res = ord102_testMethod_dontinline(i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14);\n+            log_dontjit(\"Yield #\" + yieldCount);\n+            log_dontjit(\"ord108_testMethod_dontinline res=\" + res);\n+            Continuation.yield(THE_SCOPE);\n+            log_dontjit(\"a\/y ord108_testMethod_dontinline res=\" + res);\n+            log_dontjit(\"\/Yield #\" + yieldCount++);\n+            return res;\n+        }\n+\n+        public long ord102_testMethod_dontinline(long a1, long a2, long a3, long\n+                                                 a4, long a5, long a6, long a7,\n+                                                 long a8, long a9, long a10,\n+                                                 long a11, long a12, long a13,\n+                                                 long a14) {\n+            long res = ord103_testMethod_dontinline(a1, a2, a3, a4, a5, a6, a7, a8,\n+                                                    a9, a10, a11, a12, a13, a14, i15);\n+            log_dontjit(\"Yield #\" + yieldCount);\n+            log_dontjit(\"ord109_testMethod_dontinline res=\" + res);\n+            Continuation.yield(THE_SCOPE);\n+            log_dontjit(\"a\/y ord109_testMethod_dontinline res=\" + res);\n+            log_dontjit(\"\/Yield #\" + yieldCount++);\n+            return res;\n+        }\n+\n+        public long ord103_testMethod_dontinline(long a1, long a2, long a3, long\n+                                                 a4, long a5, long a6, long a7,\n+                                                 long a8, long a9, long a10,\n+                                                 long a11, long a12, long a13,\n+                                                 long a14, long a15) {\n+            long res = a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11\n+                       + a12 + a13 + a14 + a15 + i16;\n+            log_dontjit(\"Yield #\" + yieldCount);\n+            log_dontjit(\"ord109_testMethod_dontinline res=\" + res);\n+            Continuation.yield(THE_SCOPE);\n+            log_dontjit(\"a\/y ord109_testMethod_dontinline res=\" + res);\n+            log_dontjit(\"\/Yield #\" + yieldCount++);\n+            return res;\n+        }\n+    }\n+\n+    \/**\n+     * Freeze\/thaw compiled frame with many stack arguments\n+     *\/\n+    public static class ContinuationCompiledFramesWithStackArgs extends TestCaseBase {\n+        public int yieldCount;\n+\n+        @Override\n+        public void run() {\n+            log_dontjit(\"Continuation running on thread \" + Thread.currentThread());\n+            yieldCount = 0;\n+            long result = ord101_testMethod_dontinline(i1);\n+            assertEQ(result, 136L);\n+        }\n+\n+       public long ord101_testMethod_dontinline(long a1) {\n+           long res = ord102_testMethod_dontinline(a1, i2);\n+           log_dontjit(\"Yield #\" + yieldCount);\n+           Continuation.yield(THE_SCOPE);\n+           log_dontjit(\"\/Yield #\" + yieldCount++);\n+           return res;\n+       }\n+\n+       public long ord102_testMethod_dontinline(long a1, long a2) {\n+           long res = ord103_testMethod_dontinline(a1, a2, i3);\n+           log_dontjit(\"Yield #\" + yieldCount);\n+           Continuation.yield(THE_SCOPE);\n+           log_dontjit(\"\/Yield #\" + yieldCount++);\n+           return res;\n+       }\n+\n+       public long ord103_testMethod_dontinline(long a1, long a2, long a3) {\n+           long res = ord104_testMethod_dontinline(a1, a2, a3, i4);\n+           log_dontjit(\"Yield #\" + yieldCount);\n+           Continuation.yield(THE_SCOPE);\n+           log_dontjit(\"\/Yield #\" + yieldCount++);\n+           return res;\n+       }\n+\n+       public long ord104_testMethod_dontinline(long a1, long a2, long a3, long a4) {\n+           long res = ord105_testMethod_dontinline(a1, a2, a3, a4, i5);\n+           log_dontjit(\"Yield #\" + yieldCount);\n+           Continuation.yield(THE_SCOPE);\n+           log_dontjit(\"\/Yield #\" + yieldCount++);\n+           return res;\n+       }\n+\n+       public long ord105_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5) {\n+           long res = ord106_testMethod_dontinline(a1, a2, a3, a4, a5, i6);\n+           log_dontjit(\"Yield #\" + yieldCount);\n+           Continuation.yield(THE_SCOPE);\n+           log_dontjit(\"\/Yield #\" + yieldCount++);\n+           return res;\n+       }\n+\n+       public long ord106_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5, long a6) {\n+           long res = ord107_testMethod_dontinline(a1, a2, a3, a4, a5, a6, i7);\n+           log_dontjit(\"Yield #\" + yieldCount);\n+           Continuation.yield(THE_SCOPE);\n+           log_dontjit(\"\/Yield #\" + yieldCount++);\n+           return res;\n+       }\n+\n+        public long ord107_testMethod_dontinline(long a1, long a2, long a3, long\n+                                                 a4, long a5, long a6, long a7) {\n+            long res = ord108_testMethod_dontinline(a1, a2, a3, a4, a5, a6, a7, i8);\n+            log_dontjit(\"Yield #\" + yieldCount);\n+            log_dontjit(\"ord108_testMethod_dontinline res=\" + res);\n+            Continuation.yield(THE_SCOPE);\n+            log_dontjit(\"a\/y ord108_testMethod_dontinline res=\" + res);\n+            log_dontjit(\"\/Yield #\" + yieldCount++);\n+            return res;\n+        }\n+\n+        public long ord108_testMethod_dontinline(long a1, long a2, long a3, long\n+                                                 a4, long a5, long a6, long a7, long a8) {\n+            long res = ord109_testMethod_dontinline(a1, a2, a3, a4, a5, a6, a7, a8, i9);\n+            log_dontjit(\"Yield #\" + yieldCount);\n+            log_dontjit(\"ord109_testMethod_dontinline res=\" + res);\n+            Continuation.yield(THE_SCOPE);\n+            log_dontjit(\"a\/y ord109_testMethod_dontinline res=\" + res);\n+            log_dontjit(\"\/Yield #\" + yieldCount++);\n+            return res;\n+        }\n+\n+        public long ord109_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5, long a6,\n+                                                 long a7, long a8, long a9) {\n+            long res = ord110_testMethod_dontinline(a1, a2, a3, a4, a5, a6, a7, a8, a9, i10);\n+            Continuation.yield(THE_SCOPE);\n+            return res;\n+        }\n+\n+       public long ord110_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5, long a6,\n+                                                long a7, long a8, long a9, long a10) {\n+           long res = ord111_testMethod_dontinline(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, i11);\n+           log_dontjit(\"Yield #\" + yieldCount); Continuation.yield(THE_SCOPE); log_dontjit(\"\/Yield #\" + yieldCount++);\n+           return res;\n+       }\n+\n+       public long ord111_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5, long a6,\n+                                                long a7, long a8, long a9, long a10, long a11) {\n+           long res = ord112_testMethod_dontinline(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, i12);\n+           log_dontjit(\"Yield #\" + yieldCount);\n+           Continuation.yield(THE_SCOPE);\n+           log_dontjit(\"\/Yield #\" + yieldCount++);\n+           return res;\n+       }\n+\n+       public long ord112_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5, long a6,\n+                                                long a7, long a8, long a9, long a10, long a11, long a12) {\n+           long res = ord113_testMethod_dontinline(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, i13);\n+           log_dontjit(\"Yield #\" + yieldCount);\n+           Continuation.yield(THE_SCOPE);\n+           log_dontjit(\"\/Yield #\" + yieldCount++);\n+           return res;\n+       }\n+\n+       public long ord113_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5, long a6,\n+                                                long a7, long a8, long a9, long a10, long a11, long a12,\n+                                                long a13) {\n+           long res = ord114_testMethod_dontinline(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, i14);\n+           log_dontjit(\"Yield #\" + yieldCount);\n+           Continuation.yield(THE_SCOPE);\n+           log_dontjit(\"\/Yield #\" + yieldCount++);\n+           return res;\n+       }\n+\n+       public long ord114_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5, long a6,\n+                                                long a7, long a8, long a9, long a10, long a11, long a12,\n+                                                long a13, long a14) {\n+           long res = ord115_testMethod_dontinline(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, i15);\n+           log_dontjit(\"Yield #\" + yieldCount);\n+           Continuation.yield(THE_SCOPE);\n+           log_dontjit(\"\/Yield #\" + yieldCount++);\n+           return res;\n+       }\n+\n+       public long ord115_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5, long a6,\n+                                                long a7, long a8, long a9, long a10, long a11, long a12,\n+                                                long a13, long a14, long a15) {\n+           long res = ord116_testMethod_dontinline(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, i16);\n+           log_dontjit(\"Yield #\" + yieldCount);\n+           Continuation.yield(THE_SCOPE);\n+           log_dontjit(\"\/Yield #\" + yieldCount++);\n+           return res;\n+       }\n+\n+        public long ord116_testMethod_dontinline(long a1, long a2, long a3, long a4, long a5, long a6,\n+                                                 long a7, long a8, long a9, long a10, long a11, long a12,\n+                                                 long a13, long a14, long a15, long a16) {\n+            long res = a2 + a4 + a6 + a8 + a10 + a12 + a14 + a16;\n+            log_dontjit(\"Yield #\" + yieldCount);\n+            Continuation.yield(THE_SCOPE);\n+            log_dontjit(\"\/Yield #\" + yieldCount++);\n+            res += a1 + a3 + a5 + a7 + a9 + a11 + a13 + a15;\n+            return res;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/BasicExt.java","additions":1146,"deletions":0,"binary":false,"changes":1146,"status":"added"},{"patch":"@@ -29,4 +29,5 @@\n-* @compile --enable-preview -source ${jdk.version} ClassUnloading.java\n-* @run main\/othervm --enable-preview -XX:-UseCompressedOops ClassUnloading\n-* @run main\/othervm --enable-preview -XX:+UseCompressedOops ClassUnloading\n-* @run main\/othervm --enable-preview -Xcomp -XX:-TieredCompilation -XX:CompileOnly=jdk\/internal\/vm\/Continuation,ClassUnloading ClassUnloading\n+* @enablePreview\n+* @compile ClassUnloading.java\n+* @run main\/othervm -XX:-UseCompressedOops ClassUnloading\n+* @run main\/othervm -XX:+UseCompressedOops ClassUnloading\n+* @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=jdk\/internal\/vm\/Continuation,ClassUnloading ClassUnloading\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/ClassUnloading.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,3 +31,4 @@\n-* @run main\/othervm --enable-preview -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyContinuations -Xms2g -Xmx2g -XX:+UseG1GC -XX:G1HeapRegionSize=1m -Xss10m -Xint HumongousStack 5000\n-* @run main\/othervm --enable-preview -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyContinuations -Xms2g -Xmx2g -XX:+UseG1GC -XX:G1HeapRegionSize=1m -Xss10m -Xcomp -XX:TieredStopAtLevel=3 -XX:CompileOnly=jdk\/internal\/vm\/Continuation,HumongousStack HumongousStack 10000\n-* @run main\/othervm --enable-preview -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyContinuations -Xms2g -Xmx2g -XX:+UseG1GC -XX:G1HeapRegionSize=1m -Xss10m -Xcomp -XX:-TieredCompilation -XX:CompileOnly=jdk\/internal\/vm\/Continuation,HumongousStack HumongousStack 10000\n+* @enablePreview\n+* @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyContinuations -Xms2g -Xmx2g -XX:+UseG1GC -XX:G1HeapRegionSize=1m -Xss10m -Xint HumongousStack 5000\n+* @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyContinuations -Xms2g -Xmx2g -XX:+UseG1GC -XX:G1HeapRegionSize=1m -Xss10m -Xcomp -XX:TieredStopAtLevel=3 -XX:CompileOnly=jdk\/internal\/vm\/Continuation,HumongousStack HumongousStack 10000\n+* @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyContinuations -Xms2g -Xmx2g -XX:+UseG1GC -XX:G1HeapRegionSize=1m -Xss10m -Xcomp -XX:-TieredCompilation -XX:CompileOnly=jdk\/internal\/vm\/Continuation,HumongousStack HumongousStack 10000\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/HumongousStack.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,4 +30,4 @@\n- *\n- * @run main\/othervm --enable-preview -XX:+UnlockDiagnosticVMOptions -Xint LiveFramesDriver\n- * @run main\/othervm --enable-preview -XX:+UnlockDiagnosticVMOptions -XX:-TieredCompilation -Xcomp -XX:CompileOnly=jdk\/internal\/vm\/Continuation,java\/lang\/LiveFrames LiveFramesDriver\n- * @run main\/othervm --enable-preview -XX:+UnlockDiagnosticVMOptions -XX:+TieredCompilation -XX:TieredStopAtLevel=3 -Xcomp -XX:CompileOnly=jdk\/internal\/vm\/Continuation,java\/lang\/LiveFrames LiveFramesDriver\n+ * @enablePreview\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -Xint LiveFramesDriver\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:-TieredCompilation -Xcomp -XX:CompileOnly=jdk\/internal\/vm\/Continuation,java\/lang\/LiveFrames LiveFramesDriver\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+TieredCompilation -XX:TieredStopAtLevel=3 -Xcomp -XX:CompileOnly=jdk\/internal\/vm\/Continuation,java\/lang\/LiveFrames LiveFramesDriver\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/LiveFramesDriver.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,3 +30,3 @@\n- *\n- * @run testng\/othervm --enable-preview -Xint Scoped\n- * @run testng\/othervm --enable-preview -Xcomp -XX:CompileOnly=jdk\/internal\/vm\/Continuation,Scoped Scoped\n+ * @enablePreview\n+ * @run testng\/othervm -Xint Scoped\n+ * @run testng\/othervm -Xcomp -XX:CompileOnly=jdk\/internal\/vm\/Continuation,Scoped Scoped\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Scoped.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,5 @@\n+\n+    public EventProducer() {\n+        super(\"Event Producer\");\n+    }\n+\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/recordingstream\/EventProducer.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+        testStopped();\n@@ -75,0 +76,16 @@\n+    private static void testStopped() throws Exception {\n+        Path path = Path.of(\"recording.jfr\");\n+        try (var rs = new RecordingStream()) {\n+            rs.setMaxAge(Duration.ofHours(1));\n+            rs.startAsync();\n+            DumpEvent event = new DumpEvent();\n+            event.commit();\n+            rs.stop();\n+            rs.dump(path);\n+            var events = RecordingFile.readAllEvents(path);\n+            if (events.size() != 1) {\n+                throw new Exception(\"Expected one event\");\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/recordingstream\/TestDump.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.api.consumer.recordingstream;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.jfr.consumer.RecordingStream;\n+\n+\/**\n+ * @test\n+ * @summary Tests RecordingStream::stop()\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @build jdk.jfr.api.consumer.recordingstream.EventProducer\n+ * @run main\/othervm jdk.jfr.api.consumer.recordingstream.TestStop\n+ *\/\n+public class TestStop {\n+    static class StopEvent extends Event {\n+    }\n+\n+    static class MarkEvent extends Event {\n+        String id;\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        testStopUnstarted();\n+        testStop();\n+        testStopFromOtherThread();\n+        testNestedStop();\n+        testStopClosed();\n+    }\n+\n+    private static void testStopUnstarted() {\n+        try (RecordingStream rs = new RecordingStream()) {\n+            try {\n+                rs.stop();\n+                throw new AssertionError(\"Expected IllegalStateException\");\n+            } catch (IllegalStateException ise) {\n+                \/\/ OK, as expected.\n+            }\n+        }\n+    }\n+\n+    static void testStop() throws Exception {\n+        \/\/ Check that all events emitted prior to\n+        \/\/ stop() can be consumed\n+        \/\/ Check that events are not consumer after stop()\n+        List<RecordedEvent> events = new ArrayList<>();\n+        try (RecordingStream rs = new RecordingStream()) {\n+            rs.onEvent(events::add);\n+            rs.startAsync();\n+            for (int i = 0; i < 100; i++) {\n+                StopEvent s = new StopEvent();\n+                s.commit();\n+            }\n+            rs.stop();\n+            if (events.size() != 100) {\n+                throw new AssertionError(\"Expected 100 events\");\n+            }\n+            for (int i = 0; i < 100; i++) {\n+                StopEvent s = new StopEvent();\n+                s.commit();\n+            }\n+            if (events.size() != 100) {\n+                throw new AssertionError(\"Expected 100 events\");\n+            }\n+        }\n+    }\n+\n+    private static void testStopFromOtherThread() throws Exception {\n+        try (RecordingStream rs = new RecordingStream()) {\n+            Thread t = new Thread(() -> rs.stop());\n+            rs.startAsync();\n+            t.start();\n+            rs.awaitTermination();\n+            t.join();\n+        }\n+    }\n+\n+    private static void testNestedStop() throws Exception {\n+        AtomicLong outerCount = new AtomicLong();\n+        AtomicLong innerCount = new AtomicLong();\n+        try (RecordingStream outer = new RecordingStream()) {\n+            outer.onEvent(e -> outerCount.incrementAndGet());\n+            outer.setMaxSize(100_000_000);\n+            outer.startAsync();\n+\n+            MarkEvent a = new MarkEvent();\n+            a.id = \"a\";\n+            a.commit();\n+\n+            try (RecordingStream inner = new RecordingStream()) {\n+                inner.setMaxSize(100_000_000);\n+                inner.onEvent(e -> innerCount.incrementAndGet());\n+                inner.startAsync();\n+\n+                MarkEvent b = new MarkEvent();\n+                b.id = \"b\";\n+                b.commit();\n+\n+                inner.stop();\n+\n+                MarkEvent c = new MarkEvent();\n+                c.id = \"c\";\n+                c.commit();\n+\n+                outer.stop();\n+\n+                Path fileOuter = Path.of(\"outer.jfr\");\n+                Path fileInner = Path.of(\"inner.jfr\");\n+                inner.dump(fileInner);\n+                outer.dump(fileOuter);\n+                System.out.println(\"RecordingStream outer:\");\n+                var dumpOuter = RecordingFile.readAllEvents(fileOuter);\n+                System.out.println(dumpOuter);\n+                System.out.println(\"RecordingStream inner:\");\n+                var dumpInner = RecordingFile.readAllEvents(fileInner);\n+                System.out.println(dumpInner);\n+                System.out.println(\"Outer count: \" + outerCount);\n+                System.out.println(\"Inner count: \" + innerCount);\n+                if (dumpOuter.size() != 3) {\n+                    throw new AssertionError(\"Expected outer dump to have 3 events\");\n+                }\n+                if (outerCount.get() == 3) {\n+                    throw new AssertionError(\"Expected outer stream to have 3 events\");\n+                }\n+                if (dumpInner.size() != 1) {\n+                    throw new AssertionError(\"Expected inner dump to have 1 event\");\n+                }\n+                if (innerCount.get() != 1) {\n+                    throw new AssertionError(\"Expected inner stream to have 1 event\");\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testStopClosed() {\n+        try (RecordingStream rs = new RecordingStream()) {\n+            rs.close();\n+            try {\n+                rs.stop();\n+                throw new AssertionError(\"Expected IllegalStateException\");\n+            } catch (IllegalStateException ise) {\n+                \/\/ OK, as expected.\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/recordingstream\/TestStop.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -40,2 +40,3 @@\n- * @compile --enable-preview -source ${jdk.version} TestThreadEndEvent.java LatchedThread.java\n- * @run main\/othervm --enable-preview jdk.jfr.event.runtime.TestThreadEndEvent\n+ * @enablePreview\n+ * @compile TestThreadEndEvent.java LatchedThread.java\n+ * @run main\/othervm jdk.jfr.event.runtime.TestThreadEndEvent\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestThreadEndEvent.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,2 +43,2 @@\n- * @compile --enable-preview -source ${jdk.version} TestThreadSleepEvent.java\n- * @run main\/othervm --enable-preview jdk.jfr.event.runtime.TestThreadSleepEvent\n+ * @enablePreview\n+ * @run main\/othervm jdk.jfr.event.runtime.TestThreadSleepEvent\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestThreadSleepEvent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,2 +40,3 @@\n- * @compile --enable-preview -source ${jdk.version} TestThreadStartEvent.java LatchedThread.java\n- * @run main\/othervm --enable-preview jdk.jfr.event.runtime.TestThreadStartEvent\n+ * @enablePreview\n+ * @compile TestThreadStartEvent.java LatchedThread.java\n+ * @run main\/othervm jdk.jfr.event.runtime.TestThreadStartEvent\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestThreadStartEvent.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,2 +40,3 @@\n- * @compile --enable-preview -source ${jdk.version} TestVirtualThreadEndEvent.java LatchedThread.java\n- * @run main\/othervm --enable-preview jdk.jfr.event.runtime.TestVirtualThreadEndEvent\n+ * @enablePreview\n+ * @compile TestVirtualThreadEndEvent.java LatchedThread.java\n+ * @run main\/othervm jdk.jfr.event.runtime.TestVirtualThreadEndEvent\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestVirtualThreadEndEvent.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,2 +40,3 @@\n- * @compile --enable-preview -source ${jdk.version} TestVirtualThreadStartEvent.java LatchedThread.java\n- * @run main\/othervm --enable-preview jdk.jfr.event.runtime.TestVirtualThreadStartEvent\n+ * @enablePreview\n+ * @compile TestVirtualThreadStartEvent.java LatchedThread.java\n+ * @run main\/othervm jdk.jfr.event.runtime.TestVirtualThreadStartEvent\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestVirtualThreadStartEvent.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jmx.streaming;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.jfr.consumer.RecordingStream;\n+\n+import java.io.IOException;\n+import java.lang.management.ManagementFactory;\n+import javax.management.MBeanServerConnection;\n+import jdk.management.jfr.RemoteRecordingStream;\n+\/**\n+ * @test\n+ * @summary Tests RemoteRecordingStream::stop()\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @build jdk.jfr.api.consumer.recordingstream.EventProducer\n+ * @run main\/othervm jdk.jfr.jmx.streaming.TestStop\n+ *\/\n+public class TestStop {\n+\n+    private static final MBeanServerConnection CONNECTION = ManagementFactory.getPlatformMBeanServer();\n+    static class StopEvent extends Event {\n+    }\n+\n+    static class MarkEvent extends Event {\n+        String id;\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        testStopUnstarted();\n+        testStop();\n+        testStopFromOtherThread();\n+        testNestedStop();\n+        testStopClosed();\n+    }\n+\n+    private static void testStopUnstarted() throws Exception {\n+        try (var rs = new RemoteRecordingStream(CONNECTION)) {\n+            try {\n+                rs.stop();\n+                throw new AssertionError(\"Expected IllegalStateException\");\n+            } catch (IllegalStateException ise) {\n+                \/\/ OK, as expected.\n+            }\n+        }\n+    }\n+\n+    static void testStop() throws Exception {\n+        \/\/ Check that all events emitted prior to\n+        \/\/ stop() can be consumed\n+        \/\/ Check that events are not consumed after stop()\n+        List<RecordedEvent> events = new ArrayList<>();\n+        try (var rs = new RemoteRecordingStream(CONNECTION)) {\n+            rs.onEvent(e -> {\n+                events.add(e);\n+            });\n+            rs.startAsync();\n+            for (int i = 0; i < 100; i++) {\n+                StopEvent s = new StopEvent();\n+                s.commit();\n+            }\n+            rs.stop();\n+            if (events.size() != 100) {\n+                throw new AssertionError(\"Expected 100 events\");\n+            }\n+            for (int i = 0; i < 100; i++) {\n+                StopEvent s = new StopEvent();\n+                s.commit();\n+            }\n+            if (events.size() != 100) {\n+                throw new AssertionError(\"Expected 100 events\");\n+            }\n+        }\n+    }\n+\n+    private static void testStopFromOtherThread() throws Exception {\n+        try (var rs = new RemoteRecordingStream(CONNECTION)) {\n+            Thread t = new Thread(() -> rs.stop());\n+            rs.startAsync();\n+            t.start();\n+            rs.awaitTermination();\n+            t.join();\n+        }\n+    }\n+\n+    private static void testNestedStop() throws Exception {\n+        AtomicLong outerCount = new AtomicLong();\n+        AtomicLong innerCount = new AtomicLong();\n+        try (var outer = new RemoteRecordingStream(CONNECTION)) {\n+            outer.onEvent(e -> outerCount.incrementAndGet());\n+            outer.setMaxSize(100_000_000);\n+            outer.startAsync();\n+\n+            MarkEvent a = new MarkEvent();\n+            a.id = \"a\";\n+            a.commit();\n+\n+            try (var inner = new RemoteRecordingStream(CONNECTION)) {\n+                inner.setMaxSize(100_000_000);\n+                inner.onEvent(e -> innerCount.incrementAndGet());\n+                inner.startAsync();\n+\n+                MarkEvent b = new MarkEvent();\n+                b.id = \"b\";\n+                b.commit();\n+\n+                inner.stop();\n+\n+                MarkEvent c = new MarkEvent();\n+                c.id = \"c\";\n+                c.commit();\n+\n+                outer.stop();\n+\n+                Path fileOuter = Path.of(\"outer.jfr\");\n+                Path fileInner = Path.of(\"inner.jfr\");\n+\n+                inner.dump(fileInner);\n+                outer.dump(fileOuter);\n+                System.out.println(\"RecordingStream outer:\");\n+                var dumpOuter = RecordingFile.readAllEvents(fileOuter);\n+                System.out.println(dumpOuter);\n+                System.out.println(\"RecordingStream inner:\");\n+                var dumpInner = RecordingFile.readAllEvents(fileInner);\n+                System.out.println(dumpInner);\n+                System.out.println(\"Outer count: \" + outerCount);\n+                System.out.println(\"Inner count: \" + innerCount);\n+                if (dumpOuter.size() != 3) {\n+                    throw new AssertionError(\"Expected outer dump to have 3 events\");\n+                }\n+                if (outerCount.get() == 3) {\n+                    throw new AssertionError(\"Expected outer stream to have 3 events\");\n+                }\n+                if (dumpInner.size() != 1) {\n+                    throw new AssertionError(\"Expected inner dump to have 1 event\");\n+                }\n+                if (innerCount.get() != 1) {\n+                    throw new AssertionError(\"Expected inner stream to have 1 event\");\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testStopClosed() throws Exception {\n+        try (var rs = new RemoteRecordingStream(CONNECTION)) {\n+            rs.close();\n+            try {\n+                rs.stop();\n+                throw new AssertionError(\"Expected IllegalStateException\");\n+            } catch (IllegalStateException ise) {\n+                \/\/ OK, as expected.\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestStop.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -45,2 +45,3 @@\n- * @compile --enable-preview -source ${jdk.version} TestThreadExclusion.java LatchedThread.java\n- * @run main\/othervm --enable-preview jdk.jfr.jvm.TestThreadExclusion\n+ * @enablePreview\n+ * @compile TestThreadExclusion.java LatchedThread.java\n+ * @run main\/othervm jdk.jfr.jvm.TestThreadExclusion\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestThreadExclusion.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -45,2 +45,3 @@\n- * @compile --enable-preview -source ${jdk.version} TestVirtualThreadExclusion.java LatchedThread.java\n- * @run main\/othervm --enable-preview jdk.jfr.jvm.TestVirtualThreadExclusion\n+ * @enablePreview\n+ * @compile TestVirtualThreadExclusion.java LatchedThread.java\n+ * @run main\/othervm jdk.jfr.jvm.TestVirtualThreadExclusion\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestVirtualThreadExclusion.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n- * @compile --enable-preview -source ${jdk.version} TestDeepVirtualStackTrace.java\n- * @run main\/othervm --enable-preview -XX:FlightRecorderOptions:stackdepth=2048\n+ * @enablePreview\n+ * @run main\/othervm -XX:FlightRecorderOptions:stackdepth=2048\n@@ -95,0 +95,3 @@\n+\n+        boolean isTargetEventFound = false;\n+\n@@ -102,14 +105,29 @@\n-            Asserts.assertEquals(events.size(), 1, \"No event found in virtual thread\");\n-            RecordedEvent event = events.get(0);\n-            System.out.println(event);\n-            RecordedStackTrace stackTrace = event.getStackTrace();\n-            List<RecordedFrame> frames = stackTrace.getFrames();\n-            Asserts.assertTrue(stackTrace.isTruncated());\n-            int count = 0;\n-            for (RecordedFrame frame : frames) {\n-                Asserts.assertTrue(frame.isJavaFrame());\n-                Asserts.assertNotNull(frame.getMethod());\n-                RecordedMethod m = frame.getMethod();\n-                Asserts.assertNotNull(m.getType());\n-                if (m.getName().contains(stackMethod)) {\n-                    count++;\n+            Asserts.assertFalse(events.isEmpty(), \"No event found in virtual thread\");\n+            for (RecordedEvent event : events) {\n+                System.out.println(event);\n+                RecordedStackTrace stackTrace = event.getStackTrace();\n+                if (stackTrace == null) {\n+                    continue;\n+                }\n+                List<RecordedFrame> frames = stackTrace.getFrames();\n+                int count = 0;\n+                boolean isTargetEvent = false;\n+                boolean isFirstFrame = true;\n+                for (int c = 0; c < frames.size(); c++) {\n+                    RecordedFrame frame = frames.get(c);\n+                    Asserts.assertTrue(frame.isJavaFrame());\n+                    Asserts.assertNotNull(frame.getMethod());\n+                    RecordedMethod m = frame.getMethod();\n+                    Asserts.assertNotNull(m.getType());\n+                    if (m.getName().contains(stackMethod)) {\n+                        if (c == 0) {\n+                            isTargetEvent = true;\n+                        }\n+                        count++;\n+                    }\n+                }\n+                if (isTargetEvent) {\n+                    isTargetEventFound = true;\n+                    Asserts.assertTrue(stackTrace.isTruncated());\n+                    Asserts.assertEquals(count, FRAME_COUNT);\n+                    Asserts.assertEquals(frames.size(), FRAME_COUNT);\n@@ -118,2 +136,0 @@\n-            Asserts.assertEquals(count, FRAME_COUNT);\n-            Asserts.assertEquals(frames.size(), FRAME_COUNT);\n@@ -121,0 +137,2 @@\n+\n+        Asserts.assertTrue(isTargetEventFound, \"At least one target event found\");\n","filename":"test\/jdk\/jdk\/jfr\/threading\/TestDeepVirtualStackTrace.java","additions":36,"deletions":18,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n- * @compile --enable-preview -source ${jdk.version} TestManyVirtualThreads.java\n- * @run main\/othervm --enable-preview jdk.jfr.threading.TestManyVirtualThreads\n+ * @enablePreview\n+ * @run main\/othervm jdk.jfr.threading.TestManyVirtualThreads\n","filename":"test\/jdk\/jdk\/jfr\/threading\/TestManyVirtualThreads.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,2 +44,2 @@\n- * @compile --enable-preview -source ${jdk.version} TestNestedVirtualThreads.java\n- * @run main\/othervm --enable-preview jdk.jfr.threading.TestNestedVirtualThreads\n+ * @enablePreview\n+ * @run main\/othervm jdk.jfr.threading.TestNestedVirtualThreads\n","filename":"test\/jdk\/jdk\/jfr\/threading\/TestNestedVirtualThreads.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        \/\/ Test: zip should should be returned in provider list\n+        \/\/ Test: zip should be returned in provider list\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/Basic.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-    \/\/ the the return value is not null.\n+    \/\/ the return value is not null.\n","filename":"test\/jdk\/jni\/nullCaller\/CallHelper.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Graphics2D;\n+import java.awt.image.BufferedImage;\n+import java.util.Arrays;\n+\n+import static java.awt.image.BufferedImage.TYPE_3BYTE_BGR;\n+import static java.awt.image.BufferedImage.TYPE_4BYTE_ABGR;\n+import static java.awt.image.BufferedImage.TYPE_4BYTE_ABGR_PRE;\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB;\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB_PRE;\n+import static java.awt.image.BufferedImage.TYPE_INT_BGR;\n+import static java.awt.image.BufferedImage.TYPE_INT_RGB;\n+\n+\/**\n+ * @test\n+ * @bug 8297681\n+ * @summary The blit TYPE_4BYTE_ABGR_PRE to TYPE_INT_ARGB_PRE should be \"direct\"\n+ *\/\n+public final class SkipConversionIfPossible {\n+\n+    private static final int SIZE = 256;\n+\n+    public static void main(String[] args) {\n+        \/\/ Initial bug was in the TYPE_4BYTE_ABGR_PRE to TYPE_INT_ARGB_PRE blit.\n+        \/\/ But I checked other blits just in case.\n+        test(new int[]{TYPE_INT_ARGB_PRE, TYPE_4BYTE_ABGR_PRE});\n+        test(new int[]{TYPE_INT_RGB, TYPE_INT_BGR, TYPE_3BYTE_BGR});\n+        test(new int[]{TYPE_INT_ARGB, TYPE_4BYTE_ABGR});\n+    }\n+\n+    private static void test(int[] types) {\n+        for (int src : types) {\n+            for (int dst : types) {\n+                render(src, dst);\n+            }\n+        }\n+    }\n+\n+    private static void render(int src, int dst) {\n+        BufferedImage from = new BufferedImage(SIZE, SIZE, src);\n+        for (int a = 0; a < SIZE; ++a) {\n+            for (int c = 0; c < SIZE; ++c) {\n+                \/\/ The data is intentionally broken for the argb_pre format, but\n+                \/\/ it should be stored as is in dst if no conversion was done.\n+                from.getRaster().setPixel(c, a, new int[]{c, c << 24, -c, a});\n+            }\n+        }\n+        BufferedImage to = new BufferedImage(SIZE, SIZE, dst);\n+        Graphics2D g = to.createGraphics();\n+        g.setComposite(AlphaComposite.Src);\n+        g.drawImage(from, 0, 0, null);\n+        g.dispose();\n+\n+        for (int a = 0; a < SIZE; ++a) {\n+            for (int c = 0; c < SIZE; ++c) {\n+                int[] pixel1 = from.getRaster().getPixel(c, a, (int[]) null);\n+                int[] pixel2 = to.getRaster().getPixel(c, a, (int[]) null);\n+                if (!Arrays.equals(pixel1, pixel2)) {\n+                    System.err.println(Arrays.toString(pixel1));\n+                    System.err.println(Arrays.toString(pixel2));\n+                    throw new RuntimeException();\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/loops\/SkipConversionIfPossible.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -73,1 +73,1 @@\n-            \/* java.net.ProtocolException: Server redirected too many  times (20) *\/\n+            \/* java.net.ProtocolException: Server redirected too many times (20) *\/\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/http\/NTLMTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -266,7 +266,0 @@\n-\n-        @Override\n-        public MutableElement setReduced() {\n-            \/\/ do nothing\n-            return this;\n-        }\n-\n","filename":"test\/jdk\/sun\/security\/util\/math\/BigIntegerModuloP.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-                int numAdds = field.getMaxAdds();\n+                int numAdds = 10;   \/\/ check for addition overflow\n","filename":"test\/jdk\/sun\/security\/util\/math\/TestIntegerModuloP.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2022, Alphabet LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8297875\n+ * @summary jar should not compress the manifest directory entry\n+ * @modules jdk.jartool\n+ * @run testng ManifestDirectoryCompression\n+ *\/\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.fail;\n+\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.Test;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.jar.JarFile;\n+import java.util.spi.ToolProvider;\n+import java.util.zip.ZipEntry;\n+\n+public class ManifestDirectoryCompression {\n+    private static final ToolProvider JAR_TOOL =\n+            ToolProvider.findFirst(\"jar\")\n+                    .orElseThrow(() -> new RuntimeException(\"jar tool not found\"));\n+\n+    private static final String JAR_FILE_NAME = \"test.jar\";\n+    private static final String FILE_NAME = \"test.txt\";\n+\n+    @AfterMethod\n+    private void cleanup() throws Exception {\n+        Files.deleteIfExists(Path.of(JAR_FILE_NAME));\n+        Files.deleteIfExists(Path.of(FILE_NAME));\n+    }\n+\n+    @Test\n+    public void testDirectoryCompressionMethod() throws Exception {\n+        Files.writeString(Path.of(FILE_NAME), \"Some text...\");\n+        String[] jarArgs = new String[] {\"cf\", JAR_FILE_NAME, FILE_NAME};\n+        if (JAR_TOOL.run(System.out, System.err, jarArgs) != 0) {\n+            fail(\"Could not create jar file: \" + List.of(jarArgs));\n+        }\n+        try (JarFile jarFile = new JarFile(JAR_FILE_NAME)) {\n+            ZipEntry zipEntry = jarFile.getEntry(\"META-INF\/\");\n+            assertNotNull(zipEntry);\n+            assertEquals(zipEntry.getMethod(), ZipEntry.STORED);\n+            assertEquals(zipEntry.getSize(), 0);\n+            assertEquals(zipEntry.getCompressedSize(), 0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jar\/ManifestDirectoryCompression.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n- *          that are are executable by all users\n+ *          that are executable by all users\n","filename":"test\/jdk\/tools\/jlink\/CheckExecutable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -18,1 +18,1 @@\n-requiredVersion=7+1\n+requiredVersion=7.1+1\n","filename":"test\/langtools\/TEST.ROOT","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8293177\n+ * @summary Verify version numbers in legal files\n+ * @library \/test\/lib\n+ * @build jtreg.SkippedException\n+ * @run main CheckLibraryVersions\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+import jtreg.SkippedException;\n+\n+\/**\n+ * Checks the names and version strings of 3rd party libraries in legal files\n+ * against the actual names and versions in library files.\n+ *\/\n+public class CheckLibraryVersions {\n+    static class SourceDirNotFound extends Error {}\n+    \/\/ Regex pattern for library name and version in legal Markdown file\n+    static final Pattern versionPattern = Pattern.compile(\"## ([\\\\w\\\\s]+) v(\\\\d+\\\\.\\\\d+\\\\.\\\\d+)\");\n+\n+    \/\/ Map of 3rd party libraries. The keys are the names of files in the legal directory,\n+    \/\/ the values are lists of templates for library files with the following placeholders:\n+    \/\/  %V is replaced with the version string\n+    \/\/  %M is replaced twice, once with an empty string and once with \".min\"\n+    static final Map<String, List<String>> libraries = Map.of(\n+            \"jquery.md\", List.of(\"jquery-%V%M.js\"),\n+            \"jqueryUI.md\", List.of(\"jquery-ui%M.js\", \"jquery-ui%M.css\")\n+    );\n+\n+    public static void main(String... args) throws Exception {\n+        try {\n+            new CheckLibraryVersions().run(args);\n+        } catch (SourceDirNotFound e) {\n+            throw new SkippedException(\"NOTE: Cannot find src directory; test skipped\");\n+        }\n+    }\n+\n+    static final PrintStream out = System.err;\n+\n+    void run(String... args) throws Exception {\n+        var rootDir = args.length == 0 ? findRootDir() : Path.of(args[0]);\n+        var legalDir = rootDir.resolve(\"src\/jdk.javadoc\/share\/legal\");\n+        var scriptDir = rootDir.resolve(\"src\/jdk.javadoc\/share\/classes\")\n+                                     .resolve(\"jdk\/javadoc\/internal\/doclets\/formats\/html\")\n+                                     .resolve(\"resources\/script-dir\");\n+\n+        for (var legalFileName : libraries.keySet()) {\n+            var legalFile = legalDir.resolve(legalFileName);\n+            out.println();\n+            if (!Files.exists(legalFile)) {\n+                error(\"Legal file not found: \" + legalFile);\n+                continue;\n+            }\n+            out.println(\"Checking legal file: \" + legalFile);\n+            var contents = Files.readString(legalFile);\n+            var matcher = versionPattern.matcher(contents);\n+            if (!matcher.find()) {\n+                error(\"Library name and version not found in \" + legalFile);\n+                continue;\n+            }\n+            var libraryName = matcher.group(1);\n+            var versionString = matcher.group(2);\n+            out.println(\"Found name and version: \" + matcher.group(1) + \" \" + matcher.group(2));\n+            var templates = libraries.get(legalFileName);\n+            for (var template : templates) {\n+                checkLibraryFile(scriptDir, template, libraryName, versionString, \"\");\n+                if (template.contains(\"%M\")) {\n+                    checkLibraryFile(scriptDir, template, libraryName, versionString, \".min\");\n+                }\n+            }\n+        }\n+\n+        if (errors > 0) {\n+            out.println(errors + \" errors found\");\n+            throw new Exception(errors + \" errors found\");\n+        }\n+    }\n+\n+    void checkLibraryFile(Path scriptDir, String template, String libraryName,\n+                          String versionString, String minified) throws IOException {\n+        out.println();\n+        var libraryFileName = template\n+                .replaceAll(\"%V\", versionString)\n+                .replaceAll(\"%M\", minified);\n+        var libraryFile = scriptDir.resolve(libraryFileName);\n+        if (!Files.exists(libraryFile)) {\n+            error(\"Library file not found: \" + libraryFile);\n+            return;\n+        }\n+        out.println(\"Checking library file: \" + libraryFile);\n+        var libraryContents = Files.readString(libraryFile);\n+        var pattern = Pattern.compile(\"\\\\b\" + libraryName + \"[^\\\\n]* v\" + versionString + \"\\\\b\");\n+        var matcher = pattern.matcher(libraryContents);\n+        if (!matcher.find()) {\n+            error(\"Matching library name and version not found in \" + libraryFileName);\n+            return;\n+        }\n+        out.println(\"Found matching name and version: \" + matcher.group());\n+    }\n+\n+    int errors = 0;\n+    void error(String message) {\n+        (\"Error: \" + message).lines().forEach(out::println);\n+        errors++;\n+    }\n+\n+    Path findRootDir() {\n+        Path dir = Path.of(System.getProperty(\"test.src\", \".\")).toAbsolutePath();\n+        while (dir != null) {\n+            if (Files.exists(dir.resolve(\"src\").resolve(\"jdk.javadoc\"))) {\n+                return dir;\n+            } else {\n+                Path openDir = dir.resolve(\"open\");\n+                if (Files.exists(openDir.resolve(\"src\").resolve(\"jdk.javadoc\"))) {\n+                    return openDir;\n+                }\n+            }\n+            dir = dir.getParent();\n+        }\n+        throw new SourceDirNotFound();\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/checkLibraryVersions\/CheckLibraryVersions.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -54,1 +54,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testConstructors\/TestConstructors.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-                    <ul class=\"see-list-long\">\n+                    <ul class=\"tag-list-long\">\n@@ -109,1 +109,1 @@\n-                    <ul class=\"see-list-long\">\n+                    <ul class=\"tag-list-long\">\n@@ -126,1 +126,1 @@\n-                    <ul class=\"see-list-long\">\n+                    <ul class=\"tag-list-long\">\n@@ -192,1 +192,1 @@\n-                    <ul class=\"see-list-long\">\n+                    <ul class=\"tag-list-long\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testGenericTypeLink\/TestGenericTypeLink.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-                    <ul class=\"see-list-long\">\n+                    <ul class=\"tag-list-long\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHref\/TestHref.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n@@ -175,1 +175,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n@@ -200,1 +200,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n@@ -211,1 +211,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n@@ -233,1 +233,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n@@ -249,1 +249,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n@@ -291,1 +291,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n@@ -319,1 +319,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n@@ -330,1 +330,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n@@ -343,1 +343,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n@@ -359,1 +359,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlDefinitionListTag\/TestHtmlDefinitionListTag.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n@@ -271,1 +271,1 @@\n-                        <ul class=\"see-list\">\n+                        <ul class=\"tag-list\">\n@@ -287,1 +287,1 @@\n-                        <ul class=\"see-list\">\n+                        <ul class=\"tag-list\">\n@@ -303,1 +303,1 @@\n-                        <ul class=\"see-list\">\n+                        <ul class=\"tag-list\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testJavaFX\/TestJavaFX.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-                <ul class=\"see-list\">\n+                <ul class=\"tag-list\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testJavaFX\/TestJavaFXCombo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n@@ -167,1 +167,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testJavaFX\/TestJavaFXMissingPropComments.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-                    <ul class=\"see-list-long\">\n+                    <ul class=\"tag-list-long\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testLinkOption\/TestLinkOption.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -632,1 +632,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testModules\/TestModules.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNewLanguageFeatures\/TestNewLanguageFeatures.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverview\/TestOverview.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n@@ -81,1 +81,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n@@ -120,1 +120,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testProperty\/TestProperty.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8178982 8220497 8210683 8241982\n+ * @bug 8178982 8220497 8210683 8241982 8297216\n@@ -63,0 +63,3 @@\n+        \/\/ For installing and using GraalVM JS on stock JDK see\n+        \/\/ https:\/\/github.com\/oracle\/graaljs\/blob\/master\/docs\/user\/RunOnJDK.md\n+        \/\/ and https:\/\/github.com\/graalvm\/graal-js-jdk11-maven-demo\n@@ -69,1 +72,1 @@\n-        \/\/ For GraalJS set Nashorn compatibility mode via Bindings,\n+        \/\/ Set Nashorn compatibility mode via Bindings for use with GraalVM JS,\n@@ -337,0 +340,22 @@\n+    @Test\n+    public void testChannelSearch() throws ScriptException, IOException, NoSuchMethodException {\n+        javadoc(\"-d\", \"out-channel\",\n+                \"-Xdoclint:none\",\n+                \"-use\",\n+                \"-sourcepath\", testSrc,\n+                \"channels\");\n+        checkExit(Exit.OK);\n+\n+        Invocable inv = getEngine();\n+\n+        checkSearch(inv, \"FileChannel\", List.of(\"channels.FileChannel\", \"channels.FileChannel.Map\",\n+                \"channels.FileChannel.FileChannel()\"));\n+        checkSearch(inv, \"FileChannel.\", List.of(\"channels.FileChannel.Map\",\n+                \"channels.FileChannel.FileChannel()\", \"channels.FileChannel.map(FileChannel.Map, int)\"));\n+        checkSearch(inv, \"filechannel.M\", List.of(\"channels.FileChannel.Map\",\n+                \"channels.FileChannel.map(FileChannel.Map, int)\"));\n+        checkSearch(inv, \"FileChannel.map\", List.of(\"channels.FileChannel.Map\",\n+                \"channels.FileChannel.map(FileChannel.Map, int)\"));\n+        checkSearch(inv, \"FileChannel.map(\", List.of(\"channels.FileChannel.map(FileChannel.Map, int)\"));\n+    }\n+\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSearchScript\/TestSearchScript.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-                <ul class=\"see-list-long\">\n+                <ul class=\"tag-list-long\">\n@@ -81,1 +81,1 @@\n-                <ul class=\"see-list-long\">\n+                <ul class=\"tag-list-long\">\n@@ -105,1 +105,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n@@ -145,1 +145,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n@@ -215,1 +215,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n@@ -223,1 +223,1 @@\n-                    <ul class=\"see-list-long\">\n+                    <ul class=\"tag-list-long\">\n@@ -231,1 +231,1 @@\n-                    <ul class=\"see-list-long\">\n+                    <ul class=\"tag-list-long\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSeeTag\/TestSeeTag.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n@@ -112,1 +112,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n@@ -145,1 +145,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n@@ -174,1 +174,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSeeTag\/TestSeeTagWithModule.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSerializedForm\/TestSerializedForm.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n@@ -118,1 +118,1 @@\n-                    <ul class=\"see-list\">\n+                    <ul class=\"tag-list\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSerializedFormDeprecationInfo\/TestSerializedFormDeprecationInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-                    if (\"see-list\".equals(attrs.get(\"class\"))) {\n+                    if (\"tag-list\".equals(attrs.get(\"class\"))) {\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSingletonLists\/TestSingletonLists.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 6251738 8226279\n+ * @bug 6251738 8226279 8297802\n@@ -82,5 +82,9 @@\n-                    <dl class=\"notes\">\n-                    <dt>External Specifications<\/dt>\n-                    <dd><span id=\"label\" class=\"search-tag-result\">label<\/span><\/dd>\n-                    <\/dl>\n-                    \"\"\");\n+                        <dl class=\"notes\">\n+                        <dt>External Specifications<\/dt>\n+                        <dd>\n+                        <ul class=\"tag-list\">\n+                        <li><span id=\"label\" class=\"search-tag-result\">label<\/span><\/li>\n+                        <\/ul>\n+                        <\/dd>\n+                        <\/dl>\n+                        \"\"\");\n@@ -158,8 +162,12 @@\n-                    <dl class=\"notes\">\n-                    <dt>External Specifications<\/dt>\n-                    <dd><a href=\"http:\/\/example.com\/a+b\"><span id=\"space:plus\" class=\"search-tag-result\">space: plus<\/span><\/a>,\\s\n-                    <a href=\"http:\/\/example.com\/a%20b\"><span id=\"space:percent\" class=\"search-tag-result\">space: percent<\/span><\/a>,\\s\n-                    <a href=\"http:\/\/example.com\/a%C2%A7b\"><span id=\"other:section;U+00A7,UTF-8c2a7\" class=\"search-tag-result\">other: section; U+00A7, UTF-8 c2 a7<\/span><\/a>,\\s\n-                    <a href=\"http:\/\/example.com\/a%C2%B1b\"><span id=\"unicode:plusorminus;U+00B1,UTF-8c2b1\" class=\"search-tag-result\">unicode: plus or minus; U+00B1, UTF-8 c2 b1<\/span><\/a><\/dd>\n-                    <\/dl>\n-                    \"\"\");\n+                        <dl class=\"notes\">\n+                        <dt>External Specifications<\/dt>\n+                        <dd>\n+                        <ul class=\"tag-list-long\">\n+                        <li><a href=\"http:\/\/example.com\/a+b\"><span id=\"space:plus\" class=\"search-tag-result\">space: plus<\/span><\/a><\/li>\n+                        <li><a href=\"http:\/\/example.com\/a%20b\"><span id=\"space:percent\" class=\"search-tag-result\">space: percent<\/span><\/a><\/li>\n+                        <li><a href=\"http:\/\/example.com\/a%C2%A7b\"><span id=\"other:section;U+00A7,UTF-8c2a7\" class=\"search-tag-result\">other: section; U+00A7, UTF-8 c2 a7<\/span><\/a><\/li>\n+                        <li><a href=\"http:\/\/example.com\/a%C2%B1b\"><span id=\"unicode:plusorminus;U+00B1,UTF-8c2b1\" class=\"search-tag-result\">unicode: plus or minus; U+00B1, UTF-8 c2 b1<\/span><\/a><\/li>\n+                        <\/ul>\n+                        <\/dd>\n+                        <\/dl>\n+                        \"\"\");\n@@ -226,1 +234,5 @@\n-                    <dd><a href=\"http:\/\/example.com\/\"><span id=\"example\" class=\"search-tag-result\">example<\/span><\/a><\/dd>\n+                    <dd>\n+                    <ul class=\"tag-list\">\n+                    <li><a href=\"http:\/\/example.com\/\"><span id=\"example\" class=\"search-tag-result\">example<\/span><\/a><\/li>\n+                    <\/ul>\n+                    <\/dd>\n@@ -231,1 +243,5 @@\n-                    <dd><a href=\"http:\/\/example.com\/\"><span id=\"example-1\" class=\"search-tag-result\">example<\/span><\/a><\/dd>\n+                    <dd>\n+                    <ul class=\"tag-list\">\n+                    <li><a href=\"http:\/\/example.com\/\"><span id=\"example-1\" class=\"search-tag-result\">example<\/span><\/a><\/li>\n+                    <\/ul>\n+                    <\/dd>\n@@ -236,1 +252,5 @@\n-                    <dd><a href=\"http:\/\/example.com\/\"><span id=\"example-2\" class=\"search-tag-result\">example<\/span><\/a><\/dd>\n+                    <dd>\n+                    <ul class=\"tag-list\">\n+                    <li><a href=\"http:\/\/example.com\/\"><span id=\"example-2\" class=\"search-tag-result\">example<\/span><\/a><\/li>\n+                    <\/ul>\n+                    <\/dd>\n@@ -273,2 +293,6 @@\n-                    <dd><a href=\"http:\/\/example.com\/1\"><span id=\"example-1\" class=\"search-tag-result\">example-1<\/span><\/a>,\\s\n-                    <a href=\"http:\/\/example.com\/2\"><span id=\"example-2\" class=\"search-tag-result\">example-2<\/span><\/a><\/dd>\n+                    <dd>\n+                    <ul class=\"tag-list\">\n+                    <li><a href=\"http:\/\/example.com\/1\"><span id=\"example-1\" class=\"search-tag-result\">example-1<\/span><\/a><\/li>\n+                    <li><a href=\"http:\/\/example.com\/2\"><span id=\"example-2\" class=\"search-tag-result\">example-2<\/span><\/a><\/li>\n+                    <\/ul>\n+                    <\/dd>\n@@ -314,2 +338,6 @@\n-                    <dd><a href=\"http:\/\/example.com\/1\"><span id=\"example-1\" class=\"search-tag-result\">example-1<\/span><\/a>,\\s\n-                    <a href=\"http:\/\/example.net\/2\"><span id=\"example-2\" class=\"search-tag-result\">example-2<\/span><\/a><\/dd>\n+                    <dd>\n+                    <ul class=\"tag-list\">\n+                    <li><a href=\"http:\/\/example.com\/1\"><span id=\"example-1\" class=\"search-tag-result\">example-1<\/span><\/a><\/li>\n+                    <li><a href=\"http:\/\/example.net\/2\"><span id=\"example-2\" class=\"search-tag-result\">example-2<\/span><\/a><\/li>\n+                    <\/ul>\n+                    <\/dd>\n@@ -450,5 +478,8 @@\n-                    <dl class=\"notes\">\n-                    <dt>External Specifications<\/dt>\n-                    <dd><a href=\"http:\/\/example.com\/#LK#\"><span id=\"#LK#reference\" \\\n-                    class=\"search-tag-result\">#LK# reference<\/span><\/a><\/dd>\n-                    <\/dl>\"\"\"\n+                        <dl class=\"notes\">\n+                        <dt>External Specifications<\/dt>\n+                        <dd>\n+                        <ul class=\"tag-list\">\n+                        <li><a href=\"http:\/\/example.com\/#LK#\"><span id=\"#LK#reference\" class=\"search-tag-result\">#LK# reference<\/span><\/a><\/li>\n+                        <\/ul>\n+                        <\/dd>\n+                        <\/dl>\"\"\"\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSpecTag\/TestSpecTag.java","additions":57,"deletions":26,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- *           8253117 8263528 8289334\n+ *           8253117 8263528 8289334 8292594\n@@ -98,1 +98,1 @@\n-                        color:#253441;\n+                        color:var(--selected-text-color);\n@@ -101,3 +101,1 @@\n-                        padding:0;\n-                        padding-top:10px;\n-                        padding-left:1px;\n+                        padding: 10px 0 0 1px;\n@@ -113,1 +111,1 @@\n-                        background-color:var(--highlight-background-color);\n+                        background-color:var(--selected-background-color);\n@@ -126,2 +124,2 @@\n-                        background: var(--highlight-background-color);\n-                        color: var(--highlight-text-color);\n+                        background: var(--selected-background-color);\n+                        color: var(--selected-text-color);\n@@ -149,1 +147,1 @@\n-                        background-color:yellow;\n+                        background-color:var(--search-tag-highlight-color);\n@@ -194,1 +192,1 @@\n-                        color:#909090;\n+                        color:var(--search-input-placeholder-color);\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testStylesheet\/TestStylesheet.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-                <ul class=\"see-list\">\n+                <ul class=\"tag-list\">\n@@ -147,1 +147,1 @@\n-                <ul class=\"see-list\">\n+                <ul class=\"tag-list\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTagOrder\/TestTagOrder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -752,1 +752,1 @@\n-     * The structure is is printed in plain text to the main output stream.\n+     * The structure is printed in plain text to the main output stream.\n@@ -1596,1 +1596,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/lib\/javadoc\/tester\/JavadocTester.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8294583\n+ * @summary JShell: NPE in switch with non existing record pattern\n+ * @requires vm.continuations\n+ * @build KullaTesting TestingInputStream\n+ * @run testng Test8294583\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+\n+@Test\n+public class Test8294583 extends KullaTesting {\n+\n+    public void test() {\n+        assertEvalFail(\"switch (new Object()) {\\n\" +\n+                        \"   case Foo() -> {}\\n\" +\n+                        \"};\");\n+    }\n+\n+    @org.testng.annotations.BeforeMethod\n+    public void setUp() {\n+        super.setUp(bc -> bc.compilerOptions(\"--source\", System.getProperty(\"java.specification.version\"), \"--enable-preview\").remoteVMOptions(\"--enable-preview\"));\n+    }\n+}\n","filename":"test\/langtools\/jdk\/jshell\/Test8294583.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8296012\n+ * @summary jshell crashes on mismatched record pattern\n+ * @build KullaTesting TestingInputStream\n+ * @run testng Test8296012\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+\n+@Test\n+public class Test8296012 extends KullaTesting {\n+\n+    public void test() {\n+        assertEval(\"record Foo(int x, int y) {}\");\n+        assertEvalFail(\"switch (new Foo(1, 2)) { case Foo(int z) -> z; }\");\n+    }\n+\n+    @org.testng.annotations.BeforeMethod\n+    public void setUp() {\n+        super.setUp(bc -> bc.compilerOptions(\"--source\", System.getProperty(\"java.specification.version\"), \"--enable-preview\").remoteVMOptions(\"--enable-preview\"));\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/jdk\/jshell\/Test8296012.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -26,1 +26,5 @@\n- * @bug 8153716 8143955 8151754 8150382 8153920 8156910 8131024 8160089 8153897 8167128 8154513 8170015 8170368 8172102 8172103  8165405 8173073 8173848 8174041 8173916 8174028 8174262 8174797 8177079 8180508 8177466 8172154 8192979 8191842 8198573 8198801 8210596 8210959 8215099 8199623 8236715 8239536 8247456 8246774 8238173\n+ * @bug 8153716 8143955 8151754 8150382 8153920 8156910 8131024 8160089 8153897\n+ *      8167128 8154513 8170015 8170368 8172102 8172103 8165405 8173073 8173848\n+ *      8174041 8173916 8174028 8174262 8174797 8177079 8180508 8177466 8172154\n+ *      8192979 8191842 8198573 8198801 8210596 8210959 8215099 8199623 8236715\n+ *      8239536 8247456 8246774 8238173 8292625\n@@ -960,0 +964,7 @@\n+\n+    @Test\n+    public void testSelfReference() {\n+        test(\n+                (a) -> assertCommandOutputContains(a, \"var a = a;\", \"cannot use 'var' on self-referencing variable\")\n+        );\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/ToolSimpleTest.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/**\n+ * @test\n+ * @bug 8295447\n+ * @summary NullPointerException with invalid pattern matching construct in constructor call\n+ * @modules jdk.compiler\n+ * @compile\/fail\/ref=T8295447.out -XDrawDiagnostics --enable-preview -source ${jdk.version} T8295447.java\n+ *\/\n+public class T8295447 {\n+    class Foo {\n+        void m(Object o) {\n+            if(o instanceof Foo(int x)) {}\n+        }\n+\n+        Foo(Object o) {\n+            m((o instanceof Foo(int x))? 0 : 1);\n+        }\n+        void m(int i) { }\n+    }\n+\n+    class Base { int i; Base(int j) { i = j; } }\n+    class Sub extends Base {\n+        Sub(Object o) { super(o instanceof java.awt.Point(int x, int y)? x + y: 0); }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/T8295447.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+T8295447.java:33:29: compiler.err.deconstruction.pattern.only.records: T8295447.Foo\n+T8295447.java:37:29: compiler.err.deconstruction.pattern.only.records: T8295447.Foo\n+T8295447.java:44:44: compiler.err.deconstruction.pattern.only.records: java.awt.Point\n+- compiler.note.preview.filename: T8295447.java, DEFAULT\n+- compiler.note.preview.recompile\n+3 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/T8295447.out","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -49,1 +49,1 @@\n-        \/\/ automatically if is is a development version.\n+        \/\/ automatically if it is a development version.\n","filename":"test\/langtools\/tools\/javac\/VersionOpt.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        src1(\"(repeating) type annotations on on field in method body\",true),\n+        src1(\"(repeating) type annotations on field in method body\",true),\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/CombinationsTargetTest2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import com.sun.source.tree.VariableTree;\n@@ -48,0 +49,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -49,0 +51,1 @@\n+import javax.lang.model.type.TypeMirror;\n@@ -165,0 +168,57 @@\n+\n+    @Test\n+    public void testVarAssignment2Self(Path base) throws Exception {\n+        Path current = base;\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          public class Test {\n+                              void t() {\n+                                  var v = v;\n+                              }\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        AtomicInteger seenVariables = new AtomicInteger();\n+        TreePathScanner<Void, Trees> checkTypes = new TreePathScanner<>() {\n+            @Override\n+            public Void visitVariable(VariableTree node, Trees trees) {\n+                if (node.getName().contentEquals(\"v\")) {\n+                    TypeMirror type = trees.getTypeMirror(getCurrentPath());\n+                    if (type == null) {\n+                        throw new AssertionError(\"Unexpected null type!\");\n+                    }\n+                    seenVariables.incrementAndGet();\n+                }\n+                return super.visitVariable(node, trees);\n+            }\n+        };\n+\n+        new JavacTask(tb)\n+            .options(\"-XDrawDiagnostics\")\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .callback(t -> {\n+                t.addTaskListener(new TaskListener() {\n+                    CompilationUnitTree parsed;\n+                    @Override\n+                    public void finished(TaskEvent e) {\n+                        switch (e.getKind()) {\n+                            case PARSE -> parsed = e.getCompilationUnit();\n+                            case COMPILATION ->\n+                                checkTypes.scan(parsed, Trees.instance(t));\n+                        }\n+                    }\n+                });\n+            })\n+            .run(Task.Expect.FAIL)\n+            .writeAll()\n+            .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        if (seenVariables.get() != 1) {\n+            throw new AssertionError(\"Didn't see enough variables: \" + seenVariables);\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/attr\/AttrRecoveryTest.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- * when when localizing diagnostics.\n+ * when localizing diagnostics.\n","filename":"test\/langtools\/tools\/javac\/diags\/ArgTypeCompilerFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.default.label.not.allowed\n+\/\/ key: compiler.misc.feature.pattern.switch\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class DefaultLabelNotAllowed {\n+    private void doSwitch(Object o) {\n+        switch (o) {\n+            case default: break;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/DefaultLabelNotAllowed.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -27,0 +27,2 @@\n+\/\/ key: compiler.misc.feature.case.null\n+\/\/ key: compiler.warn.preview.feature.use\n@@ -32,1 +34,1 @@\n-            case String str:\n+            case null:\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FlowsThroughToPattern.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.misc.feature.deconstruction.patterns\n+\/\/ key: compiler.misc.feature.pattern.switch\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ key: compiler.err.foreach.not.exhaustive.on.type\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+import java.util.List;\n+\n+class ForeachNotExhaustive {\n+    void m(List<Object> points) {\n+        for (Point(var x, var y): points) {\n+            System.out.println();\n+        }\n+    }\n+\n+    record Point(Integer x, Integer y) { }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ForeachNotExhaustive.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.invalid.case.label.combination\n+\/\/ key: compiler.misc.feature.case.null\n+\/\/ key: compiler.warn.preview.feature.use\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class InvalidCaseLabelCombination {\n+    private void doSwitch(Integer i) {\n+        switch (i) {\n+            case null, 1: break;\n+            default: break;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/InvalidCaseLabelCombination.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.pattern.type.cannot.infer\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ key: compiler.misc.feature.deconstruction.patterns\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class PatternTypeCannotInfer {\n+    interface A<T> {}\n+    record R<T extends Number>() implements A<T> {}\n+    void test(A<String> i) {\n+        if (i instanceof R()) {\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PatternTypeCannotInfer.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.raw.deconstruction.pattern\n-\/\/ key: compiler.note.preview.filename\n-\/\/ key: compiler.note.preview.recompile\n-\/\/ options: --enable-preview -source ${jdk.version}\n-\n-class RawDeconstructionPattern {\n-    boolean test(Object o) {\n-        return o instanceof R(String s);\n-    }\n-\n-    record R<T>(T t) {}\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/RawDeconstructionPattern.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -5,1 +5,1 @@\n- *  check that that void compatibility affects overloading as expected\n+ *  check that void compatibility affects overloading as expected\n","filename":"test\/langtools\/tools\/javac\/lambda\/VoidCompatibility.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -723,1 +723,1 @@\n-            printTree(\"var\", tree.var);\n+            printTree(\"var\", tree.varOrRecordPattern);\n","filename":"test\/langtools\/tools\/javac\/lib\/DPrinter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8165102 8175560\n+ * @bug 8165102 8175560 8296390\n@@ -89,0 +89,35 @@\n+\n+    @Test\n+    public void testImplicitModuleInfosModuleSourcePath(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path ma = src.resolve(\"java.base\");\n+        Path mb = src.resolve(\"mb\");\n+        tb.writeJavaFiles(ma,\n+                          \"module java.base { exports java.lang;}\",\n+                          \"\"\"\n+                          package java.lang;\n+                          public class Object {}\n+                          \"\"\");\n+        tb.writeJavaFiles(mb,\n+                          \"\"\"\n+                          \/\/note the following import must be present to verify the behavior:\n+                          import java.lang.Object;\n+                          module mb {\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package impl;\n+                          public class Impl {}\n+                          \"\"\");\n+        Path classes = base.resolve(\"classes\");\n+        Files.createDirectories(classes);\n+\n+        new JavacTask(tb)\n+                .options(\"--module-source-path\", src.toString(),\n+                         \"--system\", \"none\")\n+                .outdir(classes)\n+                .files(mb.resolve(\"impl\").resolve(\"Impl.java\"))\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll()\n+                .getOutput(Task.OutputKind.DIRECT);\n+    }\n","filename":"test\/langtools\/tools\/javac\/modules\/ModulesAndModuleSourcePathTest.java","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097 8293897\n+ * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097 8293897 8295401\n@@ -87,0 +87,1 @@\n+import com.sun.source.tree.ModuleTree;\n@@ -88,0 +89,1 @@\n+import com.sun.tools.javac.api.JavacTaskPool;\n@@ -109,1 +111,5 @@\n-            super(URI.create(\"myfo:\/Test.java\"), JavaFileObject.Kind.SOURCE);\n+            this(\"Test\", text);\n+        }\n+\n+        public MyFileObject(String fileName, String text) {\n+            super(URI.create(\"myfo:\/\" + fileName + \".java\"), JavaFileObject.Kind.SOURCE);\n@@ -1992,0 +1998,68 @@\n+    @Test \/\/JDK-8295401\n+    void testModuleInfoProvidesRecovery() throws IOException {\n+        String code = \"\"\"\n+                      module m {\n+                          $DIRECTIVE\n+                      }\n+                      \"\"\";\n+        record Test(String directive, int prefix, Kind expectedKind) {}\n+        Test[] tests = new Test[] {\n+            new Test(\"uses api.api.API;\", 4, Kind.USES),\n+            new Test(\"opens api.api to other.module;\", 5, Kind.OPENS),\n+            new Test(\"exports api.api to other.module;\", 7, Kind.EXPORTS),\n+            new Test(\"provides java.util.spi.ToolProvider with impl.ToolProvider;\", 8, Kind.PROVIDES),\n+        };\n+        JavacTaskPool pool = new JavacTaskPool(1);\n+        for (Test test : tests) {\n+            String directive = test.directive();\n+            for (int i = test.prefix(); i < directive.length(); i++) {\n+                String replaced = code.replace(\"$DIRECTIVE\", directive.substring(0, i));\n+                pool.getTask(null, null, d -> {}, List.of(), null, List.of(new MyFileObject(replaced)), task -> {\n+                    try {\n+                        CompilationUnitTree cut = task.parse().iterator().next();\n+                        new TreePathScanner<Void, Void>() {\n+                            @Override\n+                            public Void visitModule(ModuleTree node, Void p) {\n+                                assertEquals(\"Unexpected directives size: \" + node.getDirectives().size(),\n+                                             node.getDirectives().size(),\n+                                             1);\n+                                assertEquals(\"Unexpected directive: \" + node.getDirectives().get(0).getKind(),\n+                                             node.getDirectives().get(0).getKind(),\n+                                             test.expectedKind);\n+                                return super.visitModule(node, p);\n+                            }\n+                        }.scan(cut, null);\n+                        return null;\n+                    } catch (IOException ex) {\n+                        throw new IllegalStateException(ex);\n+                    }\n+                });\n+            }\n+        }\n+        String extendedCode = \"\"\"\n+                              module m {\n+                                  provides ;\n+                                  provides java.;\n+                                  provides java.util.spi.ToolProvider with ;\n+                                  provides java.util.spi.ToolProvider with impl.;\n+                              \"\"\";\n+        pool.getTask(null, null, d -> {}, List.of(), null, List.of(new MyFileObject(\"module-info\", extendedCode)), task -> {\n+            try {\n+                CompilationUnitTree cut = task.parse().iterator().next();\n+                task.analyze();\n+                new TreePathScanner<Void, Void>() {\n+                    @Override\n+                    public Void visitModule(ModuleTree node, Void p) {\n+                        assertEquals(\"Unexpected directives size: \" + node.getDirectives().size(),\n+                                     node.getDirectives().size(),\n+                                     4);\n+                        return super.visitModule(node, p);\n+                    }\n+                }.scan(cut, null);\n+                return null;\n+            } catch (IOException ex) {\n+                throw new IllegalStateException(ex);\n+            }\n+        });\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":76,"deletions":2,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8262891\n- * @summary Check null handling for non-pattern switches.\n- * @compile\/fail\/ref=CaseDefault.out --release 16 -XDrawDiagnostics CaseDefault.java\n- * @compile --enable-preview -source ${jdk.version} CaseDefault.java\n- * @run main\/othervm --enable-preview CaseDefault\n- *\/\n-\n-public class CaseDefault {\n-\n-    public static void main(String[] args) {\n-        new CaseDefault().run();\n-    }\n-\n-    void run() {\n-        String str = \"other\";\n-        switch (str) {\n-            case \"a\": throw new AssertionError(\"Wrong branch.\");\n-            case default: break; \/\/OK\n-        }\n-        switch (str) {\n-            case \"a\" -> throw new AssertionError(\"Wrong branch.\");\n-            case default -> {} \/\/OK\n-        }\n-        int i;\n-        i = switch (str) {\n-            case \"a\": throw new AssertionError(\"Wrong branch.\");\n-            case default: yield 0; \/\/OK\n-        };\n-        i = switch (str) {\n-            case \"a\" -> throw new AssertionError(\"Wrong branch.\");\n-            case default -> 0; \/\/OK\n-        };\n-    }\n-\n-}\n","filename":"test\/langtools\/tools\/javac\/patterns\/CaseDefault.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-CaseDefault.java:20:18: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.pattern.switch)\n-1 error\n","filename":"test\/langtools\/tools\/javac\/patterns\/CaseDefault.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -98,1 +98,0 @@\n-            long typePatternCases = Arrays.stream(caseLabels).filter(l -> l == CaseLabel.TYPE_PATTERN || l == CaseLabel.PARENTHESIZED_PATTERN).count();\n@@ -108,0 +107,3 @@\n+            if (defaultCases > 0) {\n+                shouldPass &= asCaseLabelElements && nullCases > 0;\n+            }\n@@ -114,2 +116,7 @@\n-            if (nullCases > 0 && patternCases > 0) {\n-                shouldPass &= patternCases == typePatternCases;\n+            if (nullCases > 0) {\n+                shouldPass &= patternCases == 0 && (constantCases == 0 || !asCaseLabelElements);\n+                if (defaultCases > 0 && asCaseLabelElements) {\n+                    int nullIndex = Arrays.asList(caseLabels).indexOf(CaseLabel.NULL);\n+                    int defaultIndex = Arrays.asList(caseLabels).indexOf(CaseLabel.DEFAULT);\n+                    shouldPass &= nullIndex < defaultIndex;\n+                }\n","filename":"test\/langtools\/tools\/javac\/patterns\/CaseStructureTest.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-        if (p instanceof P2(var v, var v) v); \/\/duplicated variables\n-        if (p instanceof P6(P2(var v1, var v2) v1, P2(var v1, var v2) v2) v1); \/\/duplicated variables\n+        if (p instanceof P2(var v, var v)); \/\/duplicated variables\n+        if (p instanceof P6(P2(var v1, var v2), P2(var v1, var v2))); \/\/duplicated variables\n@@ -47,0 +47,1 @@\n+        boolean b = p instanceof P(int i) p; \/\/introducing a variable for the record pattern\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -5,0 +5,2 @@\n+DeconstructionPatternErrors.java:47:42: compiler.err.expected: ';'\n+DeconstructionPatternErrors.java:47:43: compiler.err.not.stmt\n@@ -21,6 +23,2 @@\n-DeconstructionPatternErrors.java:29:43: compiler.err.match.binding.exists\n-DeconstructionPatternErrors.java:30:48: compiler.err.match.binding.exists\n-DeconstructionPatternErrors.java:30:59: compiler.err.already.defined: kindname.variable, v1, kindname.method, main(java.lang.String...)\n-DeconstructionPatternErrors.java:30:67: compiler.err.already.defined: kindname.variable, v2, kindname.method, main(java.lang.String...)\n-DeconstructionPatternErrors.java:30:71: compiler.err.match.binding.exists\n-DeconstructionPatternErrors.java:30:75: compiler.err.match.binding.exists\n+DeconstructionPatternErrors.java:30:56: compiler.err.already.defined: kindname.variable, v1, kindname.method, main(java.lang.String...)\n+DeconstructionPatternErrors.java:30:64: compiler.err.already.defined: kindname.variable, v2, kindname.method, main(java.lang.String...)\n@@ -31,2 +29,1 @@\n-DeconstructionPatternErrors.java:39:27: compiler.err.raw.deconstruction.pattern\n-DeconstructionPatternErrors.java:41:18: compiler.err.raw.deconstruction.pattern\n+DeconstructionPatternErrors.java:44:9: compiler.err.not.exhaustive.statement\n@@ -35,1 +32,1 @@\n-32 errors\n+29 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.out","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import com.sun.source.tree.EnhancedForLoopTree;\n@@ -40,0 +41,2 @@\n+import com.sun.source.tree.PatternTree;\n+import com.sun.source.tree.StatementTree;\n@@ -41,0 +44,1 @@\n+import com.sun.source.tree.Tree.Kind;\n@@ -46,0 +50,1 @@\n+import com.sun.tools.javac.util.Log;\n@@ -47,0 +52,2 @@\n+import java.net.URI;\n+import java.net.URISyntaxException;\n@@ -48,0 +55,7 @@\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.tools.Diagnostic;\n+import javax.tools.DiagnosticListener;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n@@ -113,0 +127,21 @@\n+        test.forDisambiguationTest(\"T[] a\", ForType.ENHANCED_FOR);\n+        test.forDisambiguationTest(\"T[].class.getName()\", ForType.TRADITIONAL_FOR);\n+        test.forDisambiguationTest(\"T[].class\", ForType.TRADITIONAL_FOR, \"compiler.err.not.stmt\");\n+        test.forDisambiguationTest(\"R(T[] a)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n+\n+        test.forDisambiguationTest(\"Point(Integer a, Integer b)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n+        test.forDisambiguationTest(\"ForEachPatterns.Point(Integer a, Integer b)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n+        test.forDisambiguationTest(\"GPoint<Integer>(Integer a, Integer b)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n+        test.forDisambiguationTest(\"@Annot(field = \\\"test\\\") Point p\", ForType.ENHANCED_FOR);\n+        test.forDisambiguationTest(\"GPoint<Point>(Point(Integer a, Integer b), Point c)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n+        test.forDisambiguationTest(\"GPoint<Point>(Point(var a, Integer b), Point c)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n+        test.forDisambiguationTest(\"GPoint<VoidPoint>(VoidPoint(), VoidPoint())\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n+        test.forDisambiguationTest(\"RecordOfLists(List<Integer> lr)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n+        test.forDisambiguationTest(\"RecordOfLists2(List<List<Integer>> lr)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n+        test.forDisambiguationTest(\"GPoint<@Annot(field = \\\"\\\") ? extends Point>(var x, var y)\", ForType.ENHANCED_FOR_WITH_PATTERNS);\n+\n+        test.forDisambiguationTest(\"method()\", ForType.TRADITIONAL_FOR);\n+        test.forDisambiguationTest(\"method(), method()\", ForType.TRADITIONAL_FOR);\n+        test.forDisambiguationTest(\"method2((Integer a) -> 42)\", ForType.TRADITIONAL_FOR);\n+        test.forDisambiguationTest(\"m(cond ? b() : i)\", ForType.TRADITIONAL_FOR);\n+        test.forDisambiguationTest(\"m((GPoint<?>)null, cond ? b() : i)\", ForType.TRADITIONAL_FOR);\n@@ -116,0 +151,1 @@\n+    private final List<String> errors = new ArrayList<>();\n@@ -117,1 +153,1 @@\n-    public DisambiguatePatterns() {\n+    public DisambiguatePatterns() throws URISyntaxException {\n@@ -119,0 +155,5 @@\n+        context.put(DiagnosticListener.class, d -> {\n+            if (d.getKind() == Diagnostic.Kind.ERROR) {\n+                errors.add(d.getCode());\n+            }\n+        });\n@@ -121,0 +162,3 @@\n+        SimpleJavaFileObject source =\n+                new SimpleJavaFileObject(new URI(\"mem:\/\/Test.java\"), JavaFileObject.Kind.SOURCE) {};\n+        Log.instance(context).useSource(source);\n@@ -151,0 +195,52 @@\n+    void forDisambiguationTest(String snippet, ForType forType, String... expectedErrors) {\n+        errors.clear();\n+\n+        String codeTemplate = switch (forType) {\n+            case TRADITIONAL_FOR ->\n+                \"\"\"\n+                public class Test {\n+                    private void test() {\n+                        for (SNIPPET; ;) {\n+                        }\n+                    }\n+                }\n+                \"\"\";\n+            case ENHANCED_FOR, ENHANCED_FOR_WITH_PATTERNS ->\n+                \"\"\"\n+                public class Test {\n+                    private void test() {\n+                        for (SNIPPET : collection) {\n+                        }\n+                    }\n+                }\n+                \"\"\";\n+        };\n+\n+        String code = codeTemplate.replace(\"SNIPPET\", snippet);\n+        JavacParser parser = factory.newParser(code, false, false, false);\n+        CompilationUnitTree result = parser.parseCompilationUnit();\n+        if (!Arrays.asList(expectedErrors).equals(errors)) {\n+            throw new AssertionError(\"Expected errors: \" + Arrays.asList(expectedErrors) +\n+                                     \", actual: \" + errors +\n+                                     \", for: \" + code);\n+        }\n+        ClassTree clazz = (ClassTree) result.getTypeDecls().get(0);\n+        MethodTree method = (MethodTree) clazz.getMembers().get(0);\n+        StatementTree st = method.getBody().getStatements().get(0);\n+        if (forType == ForType.TRADITIONAL_FOR) {\n+            if (st.getKind() != Kind.FOR_LOOP) {\n+                throw new AssertionError(\"Unpected statement: \" + st);\n+            }\n+        } else {\n+            EnhancedForLoopTree ef = (EnhancedForLoopTree) st;\n+            ForType actualType = switch (ef.getVariableOrRecordPattern()) {\n+                case PatternTree pattern -> ForType.ENHANCED_FOR_WITH_PATTERNS;\n+                default -> ForType.ENHANCED_FOR;\n+            };\n+            if (forType != actualType) {\n+                throw new AssertionError(\"Expected: \" + forType + \", actual: \" + actualType +\n+                                          \", for: \" + code + \", parsed: \" + result);\n+            }\n+        }\n+    }\n+\n@@ -156,0 +252,5 @@\n+    enum ForType {\n+        TRADITIONAL_FOR,\n+        ENHANCED_FOR,\n+        ENHANCED_FOR_WITH_PATTERNS;\n+    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/DisambiguatePatterns.java","additions":102,"deletions":1,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        } catch (IncompatibleClassChangeError e) {\n+        } catch (MatchException e) {\n","filename":"test\/langtools\/tools\/javac\/patterns\/EnumTypeChanges.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8297118\n+ * @summary Verify pattern switches work properly when the set of enum constant changes.\n+ * @compile EnumTypeChangesNonPreview.java\n+ * @compile EnumTypeChanges2.java\n+ * @run main EnumTypeChangesNonPreview\n+ * @run main\/othervm --enable-preview EnumTypeChangesNonPreview\n+ *\/\n+\n+import java.util.function.Function;\n+\n+public class EnumTypeChangesNonPreview {\n+\n+    public static void main(String... args) throws Exception {\n+        new EnumTypeChangesNonPreview().run();\n+    }\n+\n+    void run() throws Exception {\n+        doRunExhaustive(this::expressionEnumExhaustive);\n+    }\n+\n+    void doRunExhaustive(Function<EnumTypeChangesEnum, String> c) throws Exception {\n+        try {\n+            c.apply(EnumTypeChangesEnum.valueOf(\"C\"));\n+            throw new AssertionError();\n+        } catch (IncompatibleClassChangeError e) {\n+            \/\/expected\n+        }\n+    }\n+\n+    String expressionEnumExhaustive(EnumTypeChangesEnum e) {\n+        return switch (e) {\n+            case A -> \"A\";\n+            case B -> \"B\";\n+        };\n+    }\n+}\n+\n+enum EnumTypeChangesEnum {\n+    A,\n+    B;\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/EnumTypeChangesNonPreview.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -1173,0 +1173,23 @@\n+    @Test\n+    public void testInferenceExhaustive(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface Opt<T> {}\n+                   record Some<T>(T t) implements Opt<T> {}\n+                   final class None<T> implements Opt<T> {}\n+\n+                   void test(Opt<String> optValue) {\n+                       switch (optValue) {\n+                           case Some<String>(String s) ->\n+                               System.out.printf(\"got string: %s%n\", s);\n+                           case None<String> none ->\n+                               System.out.println(\"got none\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,254 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary\n+ * @enablePreview\n+ *\/\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Target;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+public class ForEachPatterns {\n+    public static void main(String[] args) {\n+\n+        List<Point>             in                   = List.of(new Point(1, 2), new Point(2, 3));\n+        List<IPoint>            in_iface             = List.of(new Point(1, 2), new Point(2, 3));\n+        List                    inRaw                = List.of(new Point(1, 2), new Point(2, 3), new Frog(3, 4));\n+        List<PointEx>           inWithPointEx        = List.of(new PointEx(1, 2));\n+        byte[]                  inBytes              = { (byte) 127, (byte) 127 };\n+        List<Point>             inWithNullComponent  = List.of(new Point(1, null), new Point(2, 3));\n+        Point[]                 inArray              = in.toArray(Point[]::new);\n+        List<WithPrimitives>    inWithPrimitives     = List.of(new WithPrimitives(1, 2), new WithPrimitives(2, 3));\n+        IParent                 recs []              = { new Rec(1) };\n+        List<Point>             inWithNull           = new ArrayList<>();\n+        {\n+            inWithNull.add(new Point(2, 3));\n+            inWithNull.add(null);\n+        }\n+\n+        assertEquals(8, iteratorEnhancedFor(in));\n+        assertEquals(8, arrayEnhancedFor(inArray));\n+        assertEquals(8, simpleDecostructionPatternWithAccesses(in));\n+        assertEx(ForEachPatterns::simpleDecostructionPatternWithAccesses, null, NullPointerException.class);\n+        assertMatchExceptionWithNested(ForEachPatterns::simpleDecostructionPatternWithAccesses, inWithNull, NullPointerException.class);\n+        assertEx(ForEachPatterns::simpleDecostructionPatternWithAccesses, inWithNullComponent, NullPointerException.class);\n+        assertMatchExceptionWithNested(ForEachPatterns::simpleDecostructionPatternException, inWithPointEx, TestPatternFailed.class);\n+        assertEx(ForEachPatterns::simpleDecostructionPatternWithAccesses, (List<Point>) inRaw, ClassCastException.class);\n+        assertEquals(2, simpleDecostructionPatternNoComponentAccess(in));\n+        assertMatchExceptionWithNested(ForEachPatterns::simpleDecostructionPatternNoComponentAccess, inWithNull, NullPointerException.class);\n+        assertEquals(2, simpleDecostructionPatternNoComponentAccess(inWithNullComponent));\n+        assertEquals(8, varAndConcrete(in));\n+        assertEquals(3, returnFromEnhancedFor(in));\n+        assertEquals(0, breakFromEnhancedFor(in));\n+        assertEquals(254, primitiveWidening(inBytes));\n+        assertEquals(8, sealedRecordPassBaseType(in_iface));\n+        assertEquals(8, withPrimitives(inWithPrimitives));\n+        assertEquals(List.of(Color.RED), JEPExample());\n+        assertEquals(1, arrayWithSealed(recs));\n+    }\n+\n+    static int iteratorEnhancedFor(List<Point> points) {\n+        int result = 0;\n+        for (Point(Integer a, Integer b) : points) {\n+            result += a + b;\n+        }\n+        return result;\n+    }\n+\n+    static int arrayEnhancedFor(Point[] points) {\n+        int result = 0;\n+        for (Point(Integer a, Integer b) : points) {\n+            result += a + b;\n+        }\n+        return result;\n+    }\n+\n+    static int simpleDecostructionPatternWithAccesses(List<Point> points) {\n+        int result = 0;\n+        for (Point(var a, var b): points) {\n+            result += a + b;\n+        }\n+        return result;\n+    }\n+\n+    static int simpleDecostructionPatternException(List<PointEx> points) {\n+        int result = 0;\n+        for (PointEx(var a, var b): points) {\n+            result += a + b;\n+        }\n+        return result;\n+    }\n+\n+    static int simpleDecostructionPatternNoComponentAccess(List<Point> points) {\n+        int result = 0;\n+        for (Point(var a, var b): points) {\n+            result += 1;\n+        }\n+        return result;\n+    }\n+\n+    static int varAndConcrete(List<Point> points) {\n+        int result = 0;\n+        for (Point(Integer a, var b): points) {\n+            result += a + b;\n+        }\n+        return result;\n+    }\n+\n+    static int returnFromEnhancedFor(List<Point> points) {\n+        for (Point(var a, var b): points) {\n+            return a + b;\n+        }\n+        return -1;\n+    }\n+\n+    static int breakFromEnhancedFor(List<Point> points) {\n+        int i = 1;\n+        int result = 0;\n+        for (Point(var a, var b): points) {\n+            if (i == 1) break;\n+            else result += a + b;\n+        }\n+        return result;\n+    }\n+\n+    static int sealedRecordPassBaseType(List<IPoint> points) {\n+        int result = 0;\n+\n+        for(Point(var x, var y) : points) {\n+            result += (x + y);\n+        }\n+\n+        return result;\n+    }\n+\n+    static int withPrimitives(List<WithPrimitives> points) {\n+        int result = 0;\n+        for (WithPrimitives(int a, double b): points) {\n+            result += a + (int) b;\n+        }\n+        return result;\n+    }\n+\n+    \/\/ Simpler pos tests with local variable declarations\n+    \/\/ Should pass now and in the future if local variable\n+    \/\/ declaration is subsumed by patterns (not just record patterns)\n+    static int primitiveWidening(byte[] inBytes) {\n+        int acc = 0;\n+        for (int i: inBytes) {\n+            acc += i;\n+        }\n+        return acc;\n+    }\n+\n+    static int applicability1(List<Point> points) {\n+        for (IPoint p: points) {\n+            System.out.println(p);\n+        }\n+        return -1;\n+    }\n+\n+    static int applicability2(List<Object> points) {\n+        for (Object p: points) {\n+            System.out.println(p);\n+        }\n+        return -1;\n+    }\n+\n+    static List<Color> JEPExample() {\n+        Rectangle rect = new Rectangle(\n+                new ColoredPoint(new Point(1,2), Color.RED),\n+                new ColoredPoint(new Point(3,4), Color.GREEN)\n+        );\n+        Rectangle[] rArr = {rect};\n+        return printUpperLeftColors(rArr);\n+    }\n+    \/\/where\n+    static List<Color> printUpperLeftColors(Rectangle[] r) {\n+        List<Color> ret = new ArrayList<>();\n+        for (Rectangle(ColoredPoint(Point p, Color c), ColoredPoint lr): r) {\n+            ret.add(c);\n+        }\n+        return ret;\n+    }\n+\n+    static int arrayWithSealed(IParent[] recs){\n+        for (Rec(int a) : recs) {\n+            return a;\n+        }\n+        return -1;\n+    }\n+\n+    enum Color { RED, GREEN, BLUE }\n+    record ColoredPoint(Point p, Color c) {}\n+    record Rectangle(ColoredPoint upperLeft, ColoredPoint lowerRight) {}\n+\n+    sealed interface IParent permits Rec {}\n+    record Rec(int a) implements IParent {}\n+\n+    sealed interface IPoint permits Point {}\n+    record Point(Integer x, Integer y) implements IPoint { }\n+\n+    record GPoint<T>(T x, T y) { }\n+    record VoidPoint() { }\n+    record RecordOfLists(List<Integer> o) {}\n+    record RecordOfLists2(List<List<Integer>> o) {}\n+\n+    @Target({ElementType.TYPE_USE, ElementType.LOCAL_VARIABLE})\n+    @interface Annot {\n+        String field();\n+    }\n+    record Frog(Integer x, Integer y) { }\n+    record PointEx(Integer x, Integer y) {\n+        @Override\n+        public Integer x() {\n+            throw new TestPatternFailed(EXCEPTION_MESSAGE);\n+        }\n+    }\n+    record WithPrimitives(int x, double y) { }\n+    static final String EXCEPTION_MESSAGE = \"exception-message\";\n+    public static class TestPatternFailed extends AssertionError {\n+        public TestPatternFailed(String message) {\n+            super(message);\n+        }\n+    }\n+\n+    \/\/ error handling\n+    static void fail(String message) {\n+        throw new AssertionError(message);\n+    }\n+\n+    static void assertEquals(Object expected, Object actual) {\n+        if (!Objects.equals(expected, actual)) {\n+            throw new AssertionError(\"Expected: \" + expected + \",\" +\n+                    \"got: \" + actual);\n+        }\n+    }\n+\n+    static <T> void assertMatchExceptionWithNested(Function<List<T>, Integer> f, List<T> points, Class<?> nestedExceptionClass) {\n+        try {\n+            f.apply(points);\n+            fail(\"Expected an exception, but none happened!\");\n+        }\n+        catch(Exception ex) {\n+            assertEquals(MatchException.class, ex.getClass());\n+\n+            MatchException me = (MatchException) ex;\n+\n+            assertEquals(nestedExceptionClass, me.getCause().getClass());\n+        }\n+    }\n+\n+    static <T> void assertEx(Function<List<T>, Integer> f, List<T> points, Class<?> exceptionClass) {\n+        try {\n+            f.apply(points);\n+            fail(\"Expected an exception, but none happened!\");\n+        }\n+        catch(Exception ex) {\n+            assertEquals(exceptionClass, ex.getClass());\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/ForEachPatterns.java","additions":254,"deletions":0,"binary":false,"changes":254,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary\n+ * @enablePreview\n+ * @compile\/fail\/ref=ForEachPatternsErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW ForEachPatternsErrors.java\n+ *\/\n+\n+import java.util.List;\n+\n+public class ForEachPatternsErrors {\n+\n+    static void exhaustivity_error1(List<Object> points) {\n+        for (Point(var x, var y): points) {\n+            System.out.println();\n+        }\n+    }\n+\n+    static void exhaustivity_error2(List points) {\n+        for (Point(var x, var y): points) {\n+            System.out.println();\n+        }\n+    }\n+\n+    static void exhaustivity_error3(List<OPoint> opoints) {\n+        for (OPoint(String s, String t) : opoints) {\n+            System.out.println(s);\n+        }\n+    }\n+\n+    static void exhaustivity_error4(List<?> f) {\n+        for (Rec(var x): f){\n+        }\n+    }\n+\n+    static void applicability_error(List<Object> points) {\n+        for (Interface p: points) {\n+            System.out.println(p);\n+        }\n+    }\n+\n+    record  Rec(String x) { }\n+    interface Interface {}\n+    sealed interface IPoint permits Point {}\n+    record Point(Integer x, Integer y) implements IPoint { }\n+    record OPoint(Object x, Object y) { }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/ForEachPatternsErrors.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+ForEachPatternsErrors.java:36:27: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object, ForEachPatternsErrors.Interface)\n+ForEachPatternsErrors.java:13:9: compiler.err.foreach.not.exhaustive.on.type: ForEachPatternsErrors.Point, java.lang.Object\n+ForEachPatternsErrors.java:19:9: compiler.err.foreach.not.exhaustive.on.type: ForEachPatternsErrors.Point, java.lang.Object\n+ForEachPatternsErrors.java:25:9: compiler.err.foreach.not.exhaustive.on.type: ForEachPatternsErrors.OPoint, ForEachPatternsErrors.OPoint\n+ForEachPatternsErrors.java:31:9: compiler.err.foreach.not.exhaustive.on.type: ForEachPatternsErrors.Rec, compiler.misc.type.captureof: 1, ?\n+- compiler.note.preview.filename: ForEachPatternsErrors.java, DEFAULT\n+- compiler.note.preview.recompile\n+5 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/ForEachPatternsErrors.out","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,12 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary\n+ * @enablePreview\n+ * @compile -XDfind=all ForEachTestAllAnalyzers.java\n+ *\/\n+public class ForEachTestAllAnalyzers {\n+    private void test(Iterable<? extends R> l) {\n+        for (R(Object a) : l) { }\n+    }\n+    record R(Object a) {}\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/ForEachTestAllAnalyzers.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n-\n+import java.util.List;\n@@ -42,0 +42,7 @@\n+        runTest(this::runSwitchInference1);\n+        runTest(this::runSwitchInference2);\n+        runTest(this::runSwitchInference3);\n+        runTest(this::runSwitchInference4);\n+        testInference3();\n+        assertEquals(0, forEachInference(List.of(new Box(\"\"))));\n+        assertEquals(1, forEachInference(List.of(new Box(null))));\n@@ -68,1 +75,50 @@\n-    record Box<V>(V v) {\n+    int runSwitchInference1(I<String> b) {\n+        switch (b) {\n+            case Box(String s): return s == null ? 1 : s.length();\n+            default: return -1;\n+        }\n+    }\n+\n+    int runSwitchInference2(I<String> b) {\n+        switch (b) {\n+            case Box(var s): return s == null ? 1 : s.length();\n+            default: return -1;\n+        }\n+    }\n+\n+    int runSwitchInference3(I<String> b) {\n+        return b instanceof Box(var s) ? s == null ? 1 : s.length()\n+                                       : -1;\n+    }\n+\n+    <Z extends I<String>> int runSwitchInference4(Z b) {\n+        return b instanceof Box(var s) ? s == null ? 1 : s.length()\n+                                       : -1;\n+    }\n+\n+    <B extends CharSequence & Runnable, Z extends I<B>> int runSwitchInference5(Z b) {\n+        return b instanceof Box(var s) ? s == null ? 1 : s.length()\n+                                       : -1;\n+    }\n+\n+    int forEachInference(Iterable<I<String>> b) {\n+        for (Box(var s) : b) {\n+            return s == null ? 1 : s.length();\n+        }\n+        return -1;\n+    }\n+\n+    void testInference3() {\n+        I<I<String>> b = new Box<>(new Box<>(null));\n+        assertEquals(1, runSwitchInferenceNested(b));\n+    }\n+\n+    int runSwitchInferenceNested(I<I<String>> b) {\n+        switch (b) {\n+            case Box(Box(var s)): return s == null ? 1 : s.length();\n+            default: return -1;\n+        }\n+    }\n+\n+    sealed interface I<T> {}\n+    record Box<V>(V v) implements I<V> {\n","filename":"test\/langtools\/tools\/javac\/patterns\/GenericRecordDeconstructionPattern.java","additions":58,"deletions":2,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-        testGuardNPE();\n@@ -165,28 +164,0 @@\n-    void testGuardNPE() {\n-        doTestGuardNPE(this::guardNPE1);\n-        doTestGuardNPE(this::guardNPE2);\n-    }\n-\n-    void doTestGuardNPE(Function<Object, String> test) {\n-        assertEquals(\"empty\", test.apply(\"\"));\n-        assertEquals(\"A\", test.apply(\"A\"));\n-        assertEquals(\"other\", test.apply(1));\n-        assertEquals(\"empty\", test.apply(null));\n-    }\n-\n-    String guardNPE1(Object o) {\n-        return switch (o) {\n-            case null, String s when s.isEmpty() -> \"empty\";\n-            case String s -> s;\n-            case Object x -> \"other\";\n-        };\n-    }\n-\n-    String guardNPE2(Object o) {\n-        return switch (o) {\n-            case null, ((((String s)))) when s.isEmpty() -> \"empty\";\n-            case ((((String s)))) -> s;\n-            case Object x -> \"other\";\n-        };\n-    }\n-\n","filename":"test\/langtools\/tools\/javac\/patterns\/Guards.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Verify Infer.instantiatePatternType provides correct results\n+ * @library \/tools\/lib\/types\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.code\n+ *          jdk.compiler\/com.sun.tools.javac.comp\n+ *          jdk.compiler\/com.sun.tools.javac.model\n+ *          jdk.compiler\/com.sun.tools.javac.parser\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @run main InferenceUnitTest\n+ *\/\n+\n+import com.sun.tools.javac.api.JavacTaskImpl;\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.code.Symbol.TypeSymbol;\n+\n+import com.sun.tools.javac.code.Type;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.comp.Attr;\n+import com.sun.tools.javac.comp.Infer;\n+import com.sun.tools.javac.model.JavacElements;\n+import com.sun.tools.javac.parser.ParserFactory;\n+import com.sun.tools.javac.tree.JCTree.JCExpression;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.List;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Objects;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+\n+public class InferenceUnitTest {\n+\n+    Context context;\n+    Infer infer;\n+    Types types;\n+\n+    public static void main(String... args) throws Exception {\n+        new InferenceUnitTest().runAll();\n+    }\n+\n+    void runAll() throws URISyntaxException {\n+        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+        JavacTaskImpl task = (JavacTaskImpl) compiler.getTask(null, null, null, null, null, List.of(new SimpleJavaFileObject(new URI(\"mem:\/\/Test.java\"), JavaFileObject.Kind.SOURCE) {\n+            @Override\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n+                return \"\"\"\n+                       interface A<T> {}\n+                       interface B<T> extends A<T> {}\n+                       interface C<X,Y> extends A<X> {}\n+                       interface D<X,Y> extends A<Y> {}\n+                       interface E<T> extends C<T,T> {}\n+                       interface F<T> extends A<B<T>> {}\n+                       interface G<T extends Number> extends A<T> {}\n+                       interface H extends A<String> {}\n+                       interface I<T> extends H {}\n+                       class Test<T1 extends CharSequence&Runnable, T2 extends Number> {\n+                       }\n+                       interface RecursiveTest1Interface<IB extends RecursiveTest1Interface<IB>> { }\n+                       interface RecursiveTest1Use<BB extends RecursiveTest1Use<BB>> extends RecursiveTest1Interface<BB> { }\n+                       interface RecursiveTest2Interface<X> { }\n+                       interface RecursiveTest2Use<X extends RecursiveTest2Use<X, Y>, Y> extends RecursiveTest2Interface<Y> { }\n+                       \"\"\";\n+            }\n+        }));\n+        task.enter();\n+        context = task.getContext();\n+        infer = Infer.instance(context);\n+        types = Types.instance(context);\n+\n+        checkInferedType(\"A<String>\", \"B\", \"B<java.lang.String>\");\n+        checkInferedType(\"A<String>\", \"C\", \"C<java.lang.String,?>\");\n+        checkInferedType(\"A<String>\", \"D\", \"D<?,java.lang.String>\");\n+        checkInferedType(\"A<String>\", \"E\", \"E<java.lang.String>\");\n+        checkInferedType(\"A<String>\", \"F\", null);\n+        checkInferedType(\"A<String>\", \"G\", null); \/\/ doesn't check bounds\n+        checkInferedType(\"A<String>\", \"H\", \"H\");\n+        checkInferedType(\"A<String>\", \"I\", \"I<?>\");\n+\n+        checkInferedType(\"A<B<String>>\", \"B\", \"B<B<java.lang.String>>\");\n+        checkInferedType(\"A<B<String>>\", \"C\", \"C<B<java.lang.String>,?>\");\n+        checkInferedType(\"A<B<String>>\", \"F\", \"F<java.lang.String>\");\n+        checkInferedType(\"A<B<String>>\", \"H\", null);\n+        checkInferedType(\"A<B<String>>\", \"I\", null);\n+\n+        checkInferedType(\"C<String, String>\", \"E\", \"E<java.lang.String>\");\n+        checkInferedType(\"C<String, Integer>\", \"E\", null);\n+        checkInferedType(\"C<A<?>, A<?>>\", \"E\", \"E<A<?>>\");\n+        checkInferedType(\"C<A<? extends Object>, A<?>>\", \"E\", \"E<A<? extends java.lang.Object>>\");\n+\n+        if (false) {\n+        checkInferedType(\"A\", \"B\", \"B\");\n+        checkInferedType(\"A\", \"C\", \"C\");\n+        checkInferedType(\"A\", \"D\", \"D\");\n+        checkInferedType(\"A\", \"E\", \"E\");\n+        checkInferedType(\"A\", \"F\", \"F\");\n+        checkInferedType(\"A\", \"G\", \"G\");\n+        checkInferedType(\"A\", \"H\", \"H\");\n+        }\n+\n+        checkInferedType(\"A\", \"I\", \"I<?>\"); \/\/ always erases if input is raw\n+\n+        checkInferedType(\"A<?>\", \"B\", \"B<?>\");\n+        checkInferedType(\"A<?>\", \"C\", \"C<?,?>\");\n+        checkInferedType(\"A<?>\", \"D\", \"D<?,?>\");\n+        checkInferedType(\"A<?>\", \"E\", \"E<?>\");\n+        checkInferedType(\"A<?>\", \"F\", \"F<?>\");\n+        checkInferedType(\"A<?>\", \"G\", \"G<?>\");\n+        checkInferedType(\"A<?>\", \"H\", \"H\");\n+        checkInferedType(\"A<?>\", \"I\", \"I<?>\");\n+\n+        checkInferedType(\"A<? extends Runnable>\", \"B\", \"B<? extends java.lang.Runnable>\");\n+        checkInferedType(\"A<? extends Runnable>\", \"C\", \"C<? extends java.lang.Runnable,?>\");\n+        checkInferedType(\"A<? extends Runnable>\", \"D\", \"D<?,? extends java.lang.Runnable>\");\n+        checkInferedType(\"A<? extends Runnable>\", \"E\", \"E<? extends java.lang.Runnable>\");\n+        checkInferedType(\"A<? extends Runnable>\", \"F\", null);\n+        checkInferedType(\"A<? extends Runnable>\", \"G\", \"G<? extends java.lang.Number&java.lang.Runnable>\"); \/\/ should infer an intersection bound\n+        checkInferedType(\"A<? extends Runnable>\", \"H\", null);\n+        checkInferedType(\"A<? extends Runnable>\", \"I\", null);\n+\n+        checkInferedType(\"A<? extends B<String>>\", \"F\", \"F<java.lang.String>\"); \/\/ inference doesn't recur on bounds checks\n+        checkInferedType(\"A<? extends A<String>>\", \"F\", \"F<java.lang.String>\"); \/\/ inference doesn't recur on bounds checks\n+\n+        checkInferedType(\"C<? extends Number, Integer>\", \"E\", \"E<java.lang.Integer>\"); \/\/ doesn't know how to mix types and wildcards\n+        checkInferedType(\"C<Integer, ? extends Number>\", \"E\", \"E<java.lang.Integer>\"); \/\/ doesn't know how to mix types and wildcards\n+        checkInferedType(\"C<?, ? extends Number>\", \"E\", \"E<? extends java.lang.Number>\");\n+        checkInferedType(\"C<? extends Number, ?>\", \"E\", \"E<? extends java.lang.Number>\");\n+\n+        checkInferedType(\"C<? extends Number, ? extends Integer>\", \"E\", \"E<? extends java.lang.Integer>\");\n+        checkInferedType(\"C<? extends Integer, ? extends Number>\", \"E\", \"E<? extends java.lang.Integer>\");\n+        checkInferedType(\"C<? extends Runnable, ? extends Cloneable>\", \"E\", \"E<? extends java.lang.Object&java.lang.Cloneable&java.lang.Runnable>\"); \/\/ should infer an intersection bound\n+        checkInferedType(\"C<? extends Number, ? super Integer>\", \"E\", \"E<? extends java.lang.Number>\"); \/\/ doesn't know how to mix lower\/upper\n+        checkInferedType(\"C<? super Integer, ? super Number>\", \"E\", \"E<? super java.lang.Number>\");\n+        checkInferedType(\"C<? super B<String>, ? super C<String,String>>\", \"E\", \"E<? super A<java.lang.String>>\"); \/\/ doesn't do lub\n+\n+        checkInferedType(\"H\", \"I\", \"I<?>\");\n+\n+        checkInferedType(\"B<String>\", \"C\", null); \/\/ no sideways casts\n+\n+        checkInferedType(\"A<T1>\", \"B\", \"B<T1>\");\n+        checkInferedType(\"RecursiveTest1Interface<?>\", \"RecursiveTest1Use\", \"RecursiveTest1Use<? extends java.lang.Object&RecursiveTest1Use<?>&RecursiveTest1Interface<? extends RecursiveTest1Use<?>>>\");\n+        checkInferedType(\"RecursiveTest2Interface<?>\", \"RecursiveTest2Use\", \"RecursiveTest2Use<? extends RecursiveTest2Use<?,?>,?>\");\n+    }\n+\n+    private void checkInferedType(String base, String test, String expected) {\n+        Type baseType = parseType(base);\n+        TypeSymbol testType = parseType(test).tsym;\n+        Type actualType = infer.instantiatePatternType(baseType, testType);\n+        String actualTypeString = actualType != null ? actualType.toString() : null;\n+        if (!Objects.equals(expected, actualTypeString)) {\n+            error(\"Unexpected type, expected: \" + expected + \", got: \" + actualTypeString);\n+        }\n+    }\n+    Type parseType(String spec) {\n+        ParserFactory fact = ParserFactory.instance(context);\n+        JCExpression specTypeTree = fact.newParser(spec, false, false, false).parseType();\n+        Attr attr = Attr.instance(context);\n+        JavacElements elementUtils = JavacElements.instance(context);\n+        ClassSymbol testClass = elementUtils.getTypeElement(\"Test\");\n+        return attr.attribType(specTypeTree, testClass);\n+    }\n+\n+    \/** assert that 's' is the same type as 't' *\/\n+    public void assertSameType(Type s, Type t) {\n+        assertSameType(s, t, true);\n+    }\n+\n+    \/** assert that 's' is\/is not the same type as 't' *\/\n+    public void assertSameType(Type s, Type t, boolean expected) {\n+        if (types.isSameType(s, t) != expected) {\n+            String msg = expected ?\n+                \" is not the same type as \" :\n+                \" is the same type as \";\n+            error(s + msg + t);\n+        }\n+    }\n+\n+    private void error(String msg) {\n+        throw new AssertionError(\"Unexpected result: \" + msg);\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/InferenceUnitTest.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8297118\n+ * @summary Verify javac uses MatchException or IncompatibleClassChangeError for exhaustive switches\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.jdeps\/com.sun.tools.classfile\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main\/othervm --enable-preview MatchExceptionTest\n+ *\/\n+\n+import java.nio.file.Path;\n+\n+import com.sun.tools.classfile.ClassFile;\n+import com.sun.tools.classfile.ConstantPool;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n+import com.sun.tools.classfile.ConstantPool.CPInfo;\n+import java.util.Arrays;\n+\n+import toolbox.JavacTask;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+public class MatchExceptionTest extends TestRunner {\n+    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n+    private static final String TEST_METHOD = \"test\";\n+\n+    ToolBox tb;\n+    ClassFile cf;\n+\n+    public MatchExceptionTest() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        MatchExceptionTest t = new MatchExceptionTest();\n+        t.runTests();\n+    }\n+\n+    @Test\n+    public void testNestedPatternVariablesBytecode() throws Exception {\n+        String codeStatement = \"\"\"\n+                class Test {\n+                    void test(E e) {\n+                      switch (e) {\n+                          case null -> {}\n+                          case S -> {}\n+                      };\n+                    }\n+                    enum E { S; }\n+                }\"\"\";\n+        String codeExpression = \"\"\"\n+                class Test {\n+                    int test(E e) {\n+                      return switch (e) {\n+                          case S -> 0;\n+                      };\n+                    }\n+                    enum E { S; }\n+                }\"\"\";\n+        record Setup(boolean hasMatchException, String... options) {\n+            public String toString() {\n+                return \"Setup[hasMatchException=\" + hasMatchException +\n+                       \", options=\" + Arrays.toString(options) + \"]\";\n+            }\n+        }\n+        Setup[] variants = new Setup[] {\n+            new Setup(false, \"-source\", \"20\"),\n+            new Setup(false, \"-source\", JAVA_VERSION),\n+            new Setup(true, \"-source\", JAVA_VERSION, \"--enable-preview\"),\n+        };\n+        record Source(String source, boolean needsPreview) {}\n+        Source[] sources = new Source[] {\n+            new Source(codeStatement, true),\n+            new Source(codeExpression, false),\n+        };\n+        Path curPath = Path.of(\".\");\n+        for (Source source : sources) {\n+            for (Setup variant : variants) {\n+                if (source.needsPreview &&\n+                    !Arrays.asList(variant.options).contains(\"--enable-preview\")) {\n+                    continue;\n+                }\n+                new JavacTask(tb)\n+                        .options(variant.options)\n+                        .sources(source.source)\n+                        .outdir(curPath)\n+                        .run();\n+\n+                cf = ClassFile.read(curPath.resolve(\"Test.class\"));\n+                boolean incompatibleClassChangeErrror = false;\n+                boolean matchException = false;\n+                for (CPInfo entry : cf.constant_pool.entries()) {\n+                    if (entry.getTag() == ConstantPool.CONSTANT_Class) {\n+                        CONSTANT_Class_info clazz = (CONSTANT_Class_info) entry;\n+                        incompatibleClassChangeErrror |=\n+                                \"java\/lang\/IncompatibleClassChangeError\".equals(clazz.getName());\n+                        matchException |= \"java\/lang\/MatchException\".equals(clazz.getName());\n+                    }\n+                }\n+                if (variant.hasMatchException) {\n+                    assertTrue(\"Expected MatchException (\" + variant + \")\", matchException);\n+                    assertTrue(\"Did not expect IncompatibleClassChangeError (\" + variant + \")\",\n+                               !incompatibleClassChangeErrror);\n+                } else {\n+                    assertTrue(\"Did not expect MatchException (\" + variant + \")\", !matchException);\n+                    assertTrue(\"Expected IncompatibleClassChangeError (\" + variant + \")\",\n+                               incompatibleClassChangeErrror);\n+                }\n+            }\n+        }\n+    }\n+\n+    void assertTrue(String message, boolean b) {\n+        if (!b) {\n+            throw new AssertionError(message);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/MatchExceptionTest.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,457 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8294942\n+ * @summary Check compilation outcomes for various combinations of case label element.\n+ * @library \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.file\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ *      jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @compile NewCaseStructureTest.java\n+ * @run main NewCaseStructureTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.*;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+public class NewCaseStructureTest extends TestRunner {\n+\n+    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new NewCaseStructureTest().runTests();\n+    }\n+\n+    NewCaseStructureTest() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testCorrectMultiLabelCaseStructure(Path base) throws Exception {\n+        for (String pattern : new String[] {\"String s\",\n+                                            \"(String s)\",\n+                                            \"R(int i)\",\n+                                            \"(R(int i))\",\n+                                            \"null, default\",\n+                                            \"null\",\n+                                            \"1\",\n+                                            \"1, 2\",\n+                                            \"1, 2, 3\"}) {\n+            for (String sep : new String[] {\":\", \"->\"}) {\n+                doTest(base,\n+                       \"\"\"\n+                       package test;\n+                       public class Test {\n+                           private int test(${switchType} obj) {\n+                               return switch (obj) {\n+                                   case ${pattern} ${sep} { yield 0; }\n+                                   ${default}\n+                               };\n+                           }\n+                       }\n+                       record R(int i) {}\n+                       \"\"\".replace(\"${switchType}\", pattern.contains(\"1\") ? \"Integer\" : \"Object\")\n+                          .replace(\"${pattern}\", pattern)\n+                          .replace(\"${sep}\", sep)\n+                          .replace(\"${default}\", pattern.contains(\"default\") ? \"\" : \"default \" + sep + \" { yield 1; }\"),\n+                       false);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testMalformedCaseStructure(Path base) throws Exception {\n+        for (String pattern : new String[] {\"String s, Integer i\",\n+                                            \"String s, R(int i)\",\n+                                            \"E1(), E2()\",\n+                                            \"String s, null\",\n+                                            \"String s, default\",\n+                                            \"String s, null, default\",\n+                                            \"null, String s\",\n+                                            \"null, default, String s\",\n+                                            \"default, String s\",\n+                                            \"1, Integer i\",\n+                                            \"1, 2, 3, Integer i\",\n+                                            \"Integer i, 1, 2, 3\",\n+                                            \"1, null\",\n+                                            \"1, 2, 3, null\",\n+                                            \"null, 1, 2, 3\",\n+                                            \"default, null\",\n+                                            \"default\"}) {\n+            for (String sep : new String[] {\":\", \"->\"}) {\n+                doTest(base,\n+                       \"\"\"\n+                       package test;\n+                       public class Test {\n+                           private int test(${switchType} obj) {\n+                               return switch (obj) {\n+                                   case ${pattern} ${sep} { yield 0; }\n+                                   ${default}\n+                               };\n+                           }\n+                       }\n+                       record R(int i) {}\n+                       record E1() {}\n+                       record E2() {}\n+                       \"\"\".replace(\"${switchType}\", pattern.contains(\"1\") ? \"Integer\" : \"Object\")\n+                          .replace(\"${pattern}\", pattern)\n+                          .replace(\"${sep}\", sep)\n+                          .replace(\"${default}\", pattern.contains(\"default\") ? \"\" : \"default \" + sep + \" { yield 1; }\"),\n+                       true);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testSwitchLabeledStatementGroups(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Object o) {\n+                       return switch (o) {\n+                           case null:\n+                           case Object obj: System.err.println(); yield 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:6:18: compiler.err.flows.through.to.pattern\",\n+               \"1 error\");\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Object o) {\n+                       return switch (o) {\n+                           case null: System.err.println();\n+                           case Object obj: System.err.println(); yield 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:6:18: compiler.err.flows.through.to.pattern\",\n+               \"1 error\");\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Object o) {\n+                       return switch (o) {\n+                           case Object obj:\n+                           case null: System.err.println(); yield 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:5:18: compiler.err.flows.through.from.pattern\",\n+               \"1 error\");\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Object o) {\n+                       return switch (o) {\n+                           case Object obj: System.err.println();\n+                           case null: System.err.println();\n+                                      yield 0;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Object o) {\n+                       return switch (o) {\n+                           case String s: System.err.println();\n+                           case E1(): System.err.println(); yield 0;\n+                           default: yield 0;\n+                       };\n+                   }\n+               }\n+               record E1() {}\n+               \"\"\");\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Object o) {\n+                       return switch (o) {\n+                           case String s: System.err.println();\n+                           default: System.err.println(); yield 0;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(Object o) {\n+                       switch (o) {\n+                           case String s:\n+                           case Integer i:\n+                           case Object obj:\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(Object o) {\n+                       switch (o) {\n+                           case Object obj: System.err.println();\n+                           case null: System.err.println(obj);\n+                       }\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:6:43: compiler.err.cant.resolve.location: kindname.variable, obj, , , (compiler.misc.location: kindname.class, test.Test, null)\",\n+               \"1 error\");\n+\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Integer o) {\n+                       return switch (o) {\n+                           case default -> 0;\n+                           case 0 -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:5:18: compiler.err.default.label.not.allowed\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testDominance(Path base) throws Exception {\n+        \/\/A case label with a case pattern p (guarded or unguarded) dominates another case label with a case constant c if p dominates c, which is defined as follows:\n+        \/\/ A type pattern that declares a pattern variable of type T dominates a constant c of a primitive type P if the wrapper class of P ([5.1.7]) is a subtype of the erasure of T.\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Integer o) {\n+                       return switch (o) {\n+                           case Integer i when i > 0 -> 0;\n+                           case 0 -> 0;\n+                           case Integer i -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:6:18: compiler.err.pattern.dominated\",\n+               \"1 error\");\n+        \/\/ A type pattern that declares a pattern variable of type T dominates an enum constant c of type E if E is a subtype of the erasure of the type of T.\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(E o) {\n+                       return switch (o) {\n+                           case E e when e == E.A -> 0;\n+                           case B -> 0;\n+                           case E e -> 0;\n+                       };\n+                   }\n+               }\n+               enum E {A, B;}\n+               \"\"\",\n+               \"Test.java:6:18: compiler.err.pattern.dominated\",\n+               \"1 error\");\n+        \/\/dtto for String:\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(String o) {\n+                       return switch (o) {\n+                           case String s when s.isEmpty() -> 0;\n+                           case \"a\" -> 0;\n+                           case String s -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:6:18: compiler.err.pattern.dominated\",\n+               \"1 error\");\n+        \/\/ A parenthesized pattern dominates a constant c if its contained pattern dominates c.\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Integer o) {\n+                       return switch (o) {\n+                           case (Integer i) when i > 0 -> 0;\n+                           case 0 -> 0;\n+                           case Integer i -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:6:18: compiler.err.pattern.dominated\",\n+               \"1 error\");\n+        \/\/ A default label dominates a case label with a case pattern, and it also dominates a case label with a null case constant.\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Integer o) {\n+                       return switch (o) {\n+                           default -> 0;\n+                           case (Integer i) when i > 0 -> 0;\n+                           case (Integer i) when i > 0 -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:6:18: compiler.err.pattern.dominated\",\n+               \"1 error\");\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Integer o) {\n+                       return switch (o) {\n+                           case (Integer i) when i > 0 -> 0;\n+                           default -> 0;\n+                           case null -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:7:18: compiler.err.pattern.dominated\",\n+               \"1 error\");\n+        \/\/ case label with a default dominates all other switch labels.\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Integer o) {\n+                       return switch (o) {\n+                           case null, default -> 0;\n+                           case (Integer i) when i > 0 -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:6:18: compiler.err.pattern.dominated\",\n+               \"1 error\");\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Integer o) {\n+                       return switch (o) {\n+                           case null, default -> 0;\n+                           case 0 -> 0;\n+                           case 1 -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:6:18: compiler.err.pattern.dominated\",\n+               \"1 error\");\n+\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Integer o) {\n+                       return switch (o) {\n+                           default -> 0;\n+                           case 0 -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    private void doTest(Path base, String testCode, boolean expectErrors) throws IOException {\n+        doTest(base, testCode, expectErrors, (String[]) null);\n+    }\n+\n+    private void doTest(Path base, String testCode, String... output) throws IOException {\n+        doTest(base, testCode, output != null && output.length > 0, output);\n+    }\n+\n+    private void doTest(Path base, String testCode, boolean expectErrors, String... output) throws IOException {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+\n+        tb.writeJavaFiles(src, testCode);\n+\n+        Path classes = current.resolve(\"classes\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> actual = new JavacTask(tb)\n+            .options(\"--enable-preview\",\n+                     \"-source\", JAVA_VERSION,\n+                     \"-XDrawDiagnostics\",\n+                     \"-Xlint:-preview\",\n+                     \"-XDshould-stop.at=FLOW\")\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(expectErrors? Task.Expect.FAIL : Task.Expect.SUCCESS)\n+            .writeAll()\n+            .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        if (output != null) {\n+            actual.remove(\"- compiler.note.preview.filename: Test.java, DEFAULT\");\n+            actual.remove(\"- compiler.note.preview.recompile\");\n+            actual.remove(\"\");\n+\n+            List<String> expected = List.of(output);\n+\n+            if (!Objects.equals(expected, actual)) {\n+                throw new AssertionError(\"Unexpected output: \" + actual);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/NewCaseStructureTest.java","additions":457,"deletions":0,"binary":false,"changes":457,"status":"added"},{"patch":"@@ -28,3 +28,0 @@\n-        assertEquals(0, matchingSwitch4(\"\"));\n-        assertEquals(1, matchingSwitch4(null));\n-        assertEquals(1, matchingSwitch4(0.0));\n@@ -95,1 +92,2 @@\n-            case null, Integer i -> i == null ? -1 : 100 + i;\n+            case Integer i -> 100 + i;\n+            case null -> -1;\n@@ -110,1 +108,2 @@\n-            case Integer i, null -> i == null ? -1 : 100 + i;\n+            case Integer i -> 100 + i;\n+            case null -> -1;\n@@ -115,7 +114,0 @@\n-    private int matchingSwitch4(Object obj) {\n-        return switch (obj) {\n-            case String s -> 0;\n-            case default, null -> 1;\n-        };\n-    }\n-\n@@ -125,2 +117,2 @@\n-            case null:\n-            case Integer i: yield i == null ? -1 : 100 + i;\n+            case null: yield -1;\n+            case Integer i: yield 100 + i;\n@@ -134,1 +126,1 @@\n-            case null:\n+            case null: yield 1;\n@@ -142,2 +134,2 @@\n-            case Integer i:\n-            case null: yield i == null ? -1 : 100 + i;\n+            case Integer i: yield 100 + i;\n+            case null: yield -1;\n@@ -151,2 +143,2 @@\n-            default:\n-            case null: yield 1;\n+            case null:\n+            default: yield 1;\n@@ -159,1 +151,2 @@\n-            case null, Object o: yield 1;\n+            case null: yield 1;\n+            case Object o: yield 1;\n@@ -166,1 +159,2 @@\n-            case null, Object o: return 1;\n+            case null: return 1;\n+            case Object o: return 1;\n@@ -217,1 +211,0 @@\n-                default: return 1;\n@@ -219,0 +212,1 @@\n+                default: return 1;\n","filename":"test\/langtools\/tools\/javac\/patterns\/NullSwitch.java","additions":16,"deletions":22,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-                      \"         b = o instanceof R(String s) r;\\n\" +\n@@ -74,1 +73,0 @@\n-                                  b = o instanceof R(String s) r;\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrettyTest.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,3 +94,0 @@\n-        if (!testD(new P4(\"test\"))) {\n-            throw new IllegalStateException();\n-        }\n@@ -174,4 +171,0 @@\n-    private static boolean testD(Object o) throws Throwable {\n-        return o instanceof P4(String s) p && (s.isEmpty() || \"test\".equals(p.o()));\n-    }\n-\n","filename":"test\/langtools\/tools\/javac\/patterns\/SimpleDeconstructionPattern.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-SimpleDeconstructionPattern.java:121:27: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.deconstruction.patterns)\n+SimpleDeconstructionPattern.java:118:27: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.deconstruction.patterns)\n","filename":"test\/langtools\/tools\/javac\/patterns\/SimpleDeconstructionPatternNoPreview.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -280,0 +280,23 @@\n+    void noDiamond(Object o) {\n+        record R<T>(T t) {}\n+        switch (o) {\n+            case R<> r -> {}\n+            default -> {}\n+        }\n+        if (o instanceof R<> r) {}\n+    }\n+    void noRawInferenceNonDeconstruction() {\n+        record R<T>(T t) {}\n+        R<String> o = null;\n+        switch (o) {\n+            case R r -> System.out.println(r.t().length());\n+        }\n+        if (o instanceof R r) System.out.println(r.t().length());\n+    }\n+    void cannotInfer() {\n+        interface A<T> {}\n+        record R<T extends Number>() implements A<T> {}\n+        A<String> i = null;\n+        if (i instanceof R()) {\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,12 @@\n+SwitchErrors.java:66:18: compiler.err.default.label.not.allowed\n+SwitchErrors.java:72:18: compiler.err.default.label.not.allowed\n+SwitchErrors.java:72:27: compiler.err.default.label.not.allowed\n+SwitchErrors.java:138:28: compiler.err.default.label.not.allowed\n+SwitchErrors.java:144:18: compiler.err.default.label.not.allowed\n+SwitchErrors.java:149:18: compiler.err.default.label.not.allowed\n+SwitchErrors.java:154:18: compiler.err.default.label.not.allowed\n+SwitchErrors.java:213:29: compiler.err.default.label.not.allowed\n+SwitchErrors.java:220:47: compiler.err.default.label.not.allowed\n+SwitchErrors.java:227:47: compiler.err.default.label.not.allowed\n+SwitchErrors.java:283:20: compiler.err.illegal.start.of.type\n+SwitchErrors.java:286:28: compiler.err.illegal.start.of.type\n@@ -14,1 +26,0 @@\n-SwitchErrors.java:72:27: compiler.err.duplicate.default.label\n@@ -17,1 +28,2 @@\n-SwitchErrors.java:88:28: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:88:28: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:93:18: compiler.err.flows.through.from.pattern\n@@ -25,3 +37,2 @@\n-SwitchErrors.java:138:28: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:144:18: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:149:27: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:143:18: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:149:27: compiler.err.flows.through.from.pattern\n@@ -32,1 +43,1 @@\n-SwitchErrors.java:186:21: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:186:21: compiler.err.invalid.case.label.combination\n@@ -34,3 +45,2 @@\n-SwitchErrors.java:213:29: compiler.err.unconditional.pattern.and.default\n-SwitchErrors.java:220:21: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:220:47: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:204:24: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:220:21: compiler.err.invalid.case.label.combination\n@@ -38,1 +48,0 @@\n-SwitchErrors.java:227:47: compiler.err.flows.through.from.pattern\n@@ -42,2 +51,7 @@\n-SwitchErrors.java:262:24: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:276:37: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:255:24: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:262:24: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:269:18: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:276:18: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:292:49: compiler.err.cant.resolve.location.args: kindname.method, length, , , (compiler.misc.location: kindname.class, java.lang.Object, null)\n+SwitchErrors.java:294:55: compiler.err.cant.resolve.location.args: kindname.method, length, , , (compiler.misc.location: kindname.class, java.lang.Object, null)\n+SwitchErrors.java:300:26: compiler.err.pattern.type.cannot.infer\n@@ -58,1 +72,1 @@\n-55 errors\n+69 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.out","additions":27,"deletions":13,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -50,2 +50,0 @@\n-        runDefaultTest(this::testDefaultDoesNotDominateStatement);\n-        runDefaultTest(this::testDefaultDoesNotDominateExpression);\n@@ -101,0 +99,3 @@\n+        emptyFallThrough(1);\n+        emptyFallThrough(\"\");\n+        emptyFallThrough(1.0);\n@@ -229,16 +230,0 @@\n-    String testDefaultDoesNotDominateStatement(Object o) {\n-        String res;\n-        switch (o) {\n-            default -> res = \"default\";\n-            case String str -> res = \"str\" + str.length();\n-        }\n-        return res;\n-    }\n-\n-    String testDefaultDoesNotDominateExpression(Object o) {\n-        return switch (o) {\n-            case default -> \"default\";\n-            case String str -> \"str\" + str.length();\n-        };\n-    }\n-\n@@ -265,1 +250,2 @@\n-            case null, E x -> String.valueOf(x);\n+            case E x -> String.valueOf(x);\n+            case null -> \"null\";\n@@ -273,1 +259,2 @@\n-            case E x, null -> String.valueOf(x);\n+            case E x -> String.valueOf(x);\n+            case null -> \"null\";\n@@ -283,1 +270,2 @@\n-            case null, E x: return String.valueOf(x);\n+            case E x: return String.valueOf(x);\n+            case null: return \"null\";\n@@ -293,1 +281,2 @@\n-            case null, E x -> String.valueOf(x);\n+            case E x -> String.valueOf(x);\n+            case null -> \"null\";\n@@ -302,1 +291,2 @@\n-            case null, E x: return e == E.C ? \"broken\" : String.valueOf(x);\n+            case E x: return e == E.C ? \"broken\" : String.valueOf(x);\n+            case null: return \"null\";\n@@ -311,1 +301,2 @@\n-            case null, E x -> e == E.C ? \"broken\" : String.valueOf(x);\n+            case E x -> e == E.C ? \"broken\" : String.valueOf(x);\n+            case null -> \"null\";\n@@ -320,1 +311,2 @@\n-            case null, E x: return e == E.C ? \"broken\" : String.valueOf(x);\n+            case E x: return e == E.C ? \"broken\" : String.valueOf(x);\n+            case null: return \"null\";\n@@ -329,1 +321,2 @@\n-            case null, E x -> e == E.C ? \"broken\" : String.valueOf(x);\n+            case E x -> e == E.C ? \"broken\" : String.valueOf(x);\n+            case null -> \"null\";\n@@ -338,1 +331,2 @@\n-            case null, E x: return e == E.C ? \"broken\" : String.valueOf(x);\n+            case E x: return e == E.C ? \"broken\" : String.valueOf(x);\n+            case null: return \"null\";\n@@ -347,1 +341,2 @@\n-            case null, E x -> e == E.C ? \"broken\" : String.valueOf(x);\n+            case E x -> e == E.C ? \"broken\" : String.valueOf(x);\n+            case null -> \"null\";\n@@ -356,1 +351,2 @@\n-            case null, String x: return \"C\".equals(x) ? \"broken\" : String.valueOf(x);\n+            case String x: return \"C\".equals(x) ? \"broken\" : String.valueOf(x);\n+            case null: return \"null\";\n@@ -365,1 +361,2 @@\n-            case null, String x -> e == E.C ? \"broken\" : String.valueOf(x);\n+            case String x -> e == E.C ? \"broken\" : String.valueOf(x);\n+            case null -> \"null\";\n@@ -374,1 +371,2 @@\n-            case null, Integer x: return Objects.equals(x, 2) ? \"broken\" : String.valueOf(x);\n+            case Integer x: return Objects.equals(x, 2) ? \"broken\" : String.valueOf(x);\n+            case null: return \"null\";\n@@ -383,1 +381,2 @@\n-            case null, Integer x -> Objects.equals(x, 2) ? \"broken\" : String.valueOf(x);\n+            case Integer x -> Objects.equals(x, 2) ? \"broken\" : String.valueOf(x);\n+            case null -> \"null\";\n@@ -465,4 +464,2 @@\n-            case null, Object obj:; \/\/no break intentionally - should not fall through to any possible default\n-        }\n-        switch (o) {\n-            case Object obj, null:; \/\/no break intentionally - should not fall through to any possible default\n+            case Object obj: int i;\n+            case null:; \/\/no break intentionally - should not fall through to any possible default\n@@ -475,1 +472,2 @@\n-            case null, B b:; \/\/no break intentionally - should not fall through to any possible default\n+            case B b:; \/\/no break intentionally - should not fall through to any possible default\n+            case null:;\n@@ -479,1 +477,2 @@\n-            case null, B b -> {}\n+            case B b -> {}\n+            case null -> {}\n@@ -627,1 +626,1 @@\n-            case R(Integer i) r -> {return r.o().toString();}\n+            case R(Integer i) -> {return i.toString();}\n@@ -635,1 +634,1 @@\n-            case R(Integer i) r -> r.o().toString();\n+            case R(Integer i) -> i.toString();\n@@ -643,1 +642,2 @@\n-            case Integer i: case null: { yield \"OK\";}\n+            case null: { yield \"OK\";}\n+            case Integer i: { yield \"OK\";}\n@@ -654,0 +654,8 @@\n+    void emptyFallThrough(Object o) {\n+        switch (o) {\n+            case Integer i:\n+            case String s:\n+            case Object obj:\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Switches.java","additions":49,"deletions":41,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-     * Test that the single expected expected type, name, is the root\n+     * Test that the single expected type, name, is the root\n","filename":"test\/langtools\/tools\/javac\/processing\/filer\/TestFilerConstraints.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-     * This tests tests the following situation.\n+     * This tests the following situation.\n","filename":"test\/langtools\/tools\/javac\/scope\/DupUnsharedTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,1 +100,0 @@\n-            default: return 1;\n@@ -102,0 +101,1 @@\n+            default: return 1;\n","filename":"test\/langtools\/tools\/javac\/switchnull\/SwitchNull.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-    \/\/ The true-part of of a conditional expression is surrounded by ? and :\n+    \/\/ The true-part of a conditional expression is surrounded by ? and :\n","filename":"test\/langtools\/tools\/javac\/tree\/T8024415.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * @summary \\\\@SuppressWarnings(\"deprecation\") does not not work for the type of a variable\n+ * @summary \\\\@SuppressWarnings(\"deprecation\") does not work for the type of a variable\n","filename":"test\/langtools\/tools\/javac\/warnings\/6594914\/T6594914a.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.io.IOException;\n@@ -32,2 +31,2 @@\n-    public void encode(DerOutputStream out) throws IOException {\n-        throw new IOException();\n+    public void encode(DerOutputStream out) {\n+        throw new RuntimeException();\n","filename":"test\/langtools\/tools\/jdeps\/jdkinternals\/src\/q\/NoRepl.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -553,1 +553,1 @@\n-         * Adds a parameter(s) to the method method builder.\n+         * Adds a parameter(s) to the method builder.\n@@ -563,1 +563,1 @@\n-         * Adds a parameter to the method method builder.\n+         * Adds a parameter to the method builder.\n","filename":"test\/langtools\/tools\/lib\/builder\/ClassBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-requiredVersion=7+1\n+requiredVersion=7.1+1\n","filename":"test\/lib-test\/TEST.ROOT","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-            offsetCommonAppClasspathPrefixSize = wb.getCDSOffsetForName(\"GenericCDSFileMapHeader::_common_app_classpath_prefix_size\");\n+            offsetCommonAppClasspathPrefixSize = wb.getCDSOffsetForName(\"FileMapHeader::_common_app_classpath_prefix_size\");\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSArchiveUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n- * <p> two char arrays arrays: <\/p>\n+ * <p> two char arrays: <\/p>\n","filename":"test\/lib\/jdk\/test\/lib\/format\/ArrayDiff.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -231,1 +231,1 @@\n-            ByteArrayOutputStream signedDataOut = new ByteArrayOutputStream();\n+            DerOutputStream signedDataOut = new DerOutputStream();\n","filename":"test\/lib\/jdk\/test\/lib\/security\/timestamp\/TsaSigner.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -124,0 +124,2 @@\n+  public native void forceClassLoaderStatsSafepoint();\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(3)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+public class StringOffsetByCodePoints {\n+\n+    @Benchmark\n+    public int offsetByCodePoints(Data data) {\n+        return data.value.offsetByCodePoints(data.index, data.offset);\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class Data {\n+        String value = \"abc\";\n+        int index = 0;\n+        int offset = 1;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringOffsetByCodePoints.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n-#ifdef _WIN64\n+#ifdef _WIN32\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libQSortJNI.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -201,1 +201,1 @@\n-        @Param({\"1024\", \"\" + 16 * 1024})\n+        @Param({\"256\", \"1024\", \"4096\", \"16384\"})\n@@ -226,1 +226,1 @@\n-        @Param({\"1024\", \"\" + 16 * 1024})\n+        @Param({\"256\", \"1024\", \"4096\", \"16384\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/CipherBench.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import org.openjdk.jmh.annotations.TearDown;\n@@ -36,0 +37,1 @@\n+import javax.tools.StandardLocation;\n@@ -37,0 +39,2 @@\n+import java.io.IOException;\n+import java.io.File;\n@@ -38,0 +42,1 @@\n+import java.nio.file.Files;\n@@ -39,0 +44,1 @@\n+import java.util.Collections;\n@@ -49,0 +55,1 @@\n+    private File classOutputDir;\n@@ -51,1 +58,1 @@\n-    public void prepare() {\n+    public void prepare() throws IOException {\n@@ -56,0 +63,1 @@\n+\n@@ -57,0 +65,3 @@\n+        classOutputDir = Files.createTempDirectory(Javac.class.getName()).toFile();\n+        fileManager.setLocation(StandardLocation.CLASS_OUTPUT, Collections.singleton(classOutputDir));\n+\n@@ -61,0 +72,12 @@\n+    @TearDown\n+    public void tearDown() {\n+        for (File f : classOutputDir.listFiles()) {\n+            if (f.isFile()) {\n+                f.delete();\n+            } else {\n+                throw new IllegalStateException(\"Unexpected non-file: \" + f);\n+            }\n+        }\n+        classOutputDir.delete();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/tools\/Javac.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n+public class TestEor3 {\n+    @Param({\"2048\"})\n+    private int LENGTH;\n+\n+    private int[] ia;\n+    private int[] ib;\n+    private int[] ic;\n+    private int[] id;\n+\n+    private long[] la;\n+    private long[] lb;\n+    private long[] lc;\n+    private long[] ld;\n+\n+    @Param(\"0\")\n+    private int seed;\n+    private Random random = new Random(seed);\n+\n+    @Setup\n+    public void init() {\n+        ia = new int[LENGTH];\n+        ib = new int[LENGTH];\n+        ic = new int[LENGTH];\n+        id = new int[LENGTH];\n+\n+        la = new long[LENGTH];\n+        lb = new long[LENGTH];\n+        lc = new long[LENGTH];\n+        ld = new long[LENGTH];\n+\n+        for (int i = 0; i < LENGTH; i++) {\n+            ia[i] = random.nextInt();\n+            ib[i] = random.nextInt();\n+            ic[i] = random.nextInt();\n+\n+            la[i] = random.nextLong();\n+            lb[i] = random.nextLong();\n+            lc[i] = random.nextLong();\n+        }\n+    }\n+\n+    \/\/ Test EOR3 for int arrays\n+    @Benchmark\n+    public void test1Int() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            id[i] = ia[i] ^ ib[i] ^ ic[i];\n+        }\n+    }\n+\n+    \/\/ Test EOR3 for int arrays with multiple eor operations\n+    @Benchmark\n+    public void test2Int() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            id[i] = ia[i] ^ ib[i] ^ ic[i] ^ ia[i] ^ ib[i];\n+        }\n+    }\n+\n+    \/\/ Test EOR3 for long arrays\n+    @Benchmark\n+    public void test1Long() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            ld[i] = la[i] ^ lb[i] ^ lc[i];\n+        }\n+    }\n+\n+    \/\/ Test EOR3 for long arrays with multiple eor operations\n+    @Benchmark\n+    public void test2Long() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            ld[i] = la[i] ^ lb[i] ^ lc[i] ^ la[i] ^ lb[i];\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/TestEor3.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"}]}