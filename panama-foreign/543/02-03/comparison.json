{"files":[{"patch":"@@ -1491,0 +1491,5 @@\n+\n+            @Override\n+            public Class<?>[] exceptionTypes(MethodHandle handle) {\n+                return VarHandles.exceptionTypes(handle);\n+            }\n@@ -1962,9 +1967,10 @@\n-            MH_cast                  = 0,\n-            MH_selectAlternative     = 1,\n-            MH_countedLoopPred       = 2,\n-            MH_countedLoopStep       = 3,\n-            MH_initIterator          = 4,\n-            MH_iteratePred           = 5,\n-            MH_iterateNext           = 6,\n-            MH_Array_newInstance     = 7,\n-            MH_LIMIT                 = 8;\n+            MH_cast                               = 0,\n+            MH_selectAlternative                  = 1,\n+            MH_countedLoopPred                    = 2,\n+            MH_countedLoopStep                    = 3,\n+            MH_initIterator                       = 4,\n+            MH_iteratePred                        = 5,\n+            MH_iterateNext                        = 6,\n+            MH_Array_newInstance                  = 7,\n+            MH_VarHandles_handleCheckedExceptions = 8,\n+            MH_LIMIT                              = 9;\n@@ -2020,0 +2026,3 @@\n+                case MH_VarHandles_handleCheckedExceptions:\n+                    return IMPL_LOOKUP.findStatic(VarHandles.class, \"handleCheckedExceptions\",\n+                            MethodType.methodType(void.class, Throwable.class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":18,"deletions":9,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.reflect.Parameter;\n@@ -37,1 +36,0 @@\n-import java.util.LinkedHashMap;\n@@ -39,1 +37,0 @@\n-import java.util.Map;\n@@ -48,2 +45,0 @@\n-import static java.util.stream.Collectors.joining;\n-import static java.util.stream.Collectors.toList;\n@@ -362,1 +357,1 @@\n-    public static VarHandle filterValue(VarHandle target, MethodHandle filterToTarget, MethodHandle filterFromTarget) {\n+    public static VarHandle filterValue(VarHandle target, MethodHandle pFilterToTarget, MethodHandle pFilterFromTarget) {\n@@ -364,2 +359,2 @@\n-        Objects.requireNonNull(filterToTarget);\n-        Objects.requireNonNull(filterFromTarget);\n+        Objects.requireNonNull(pFilterToTarget);\n+        Objects.requireNonNull(pFilterFromTarget);\n@@ -367,2 +362,2 @@\n-        noCheckedExceptions(filterToTarget);\n-        noCheckedExceptions(filterFromTarget);\n+        MethodHandle filterToTarget = adaptForCheckedExceptions(pFilterToTarget);\n+        MethodHandle filterFromTarget = adaptForCheckedExceptions(pFilterFromTarget);\n@@ -476,2 +471,3 @@\n-            noCheckedExceptions(filters[i]);\n-            MethodType filterType = filters[i].type();\n+            MethodHandle filter = Objects.requireNonNull(filters[i]);\n+            filter = adaptForCheckedExceptions(filter);\n+            MethodType filterType = filter.type();\n@@ -567,1 +563,1 @@\n-    public static VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle filter) {\n+    public static VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle pFilter) {\n@@ -569,2 +565,2 @@\n-        Objects.requireNonNull(filter);\n-        noCheckedExceptions(filter);\n+        Objects.requireNonNull(pFilter);\n+        MethodHandle filter = adaptForCheckedExceptions(pFilter);\n@@ -607,1 +603,23 @@\n-    private static void noCheckedExceptions(MethodHandle handle) {\n+    private static MethodHandle adaptForCheckedExceptions(MethodHandle target) {\n+        Class<?>[] exceptionTypes = exceptionTypes(target);\n+        if (exceptionTypes != null) { \/\/ exceptions known\n+            if (Stream.of(exceptionTypes).anyMatch(VarHandles::isCheckedException)) {\n+                throw newIllegalArgumentException(\"Cannot adapt a var handle with a method handle which throws checked exceptions\");\n+            }\n+            return target; \/\/ no adaptation needed\n+        } else {\n+            MethodHandle handler = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_VarHandles_handleCheckedExceptions);\n+            MethodHandle zero = MethodHandles.zero(target.type().returnType()); \/\/ dead branch\n+            handler = MethodHandles.collectArguments(zero, 0, handler);\n+            return MethodHandles.catchException(target, Throwable.class, handler);\n+        }\n+    }\n+\n+    static void handleCheckedExceptions(Throwable throwable) throws Throwable {\n+        if (isCheckedException(throwable.getClass())) {\n+            throw new IllegalStateException(\"Adapter handle threw checked exception\", throwable);\n+        }\n+        throw throwable;\n+    }\n+\n+    static Class<?>[] exceptionTypes(MethodHandle handle) {\n@@ -614,1 +632,0 @@\n-            final Class<?>[] exceptionTypes;\n@@ -616,1 +633,1 @@\n-                exceptionTypes = info.reflectAs(Method.class, MethodHandles.Lookup.IMPL_LOOKUP)\n+                return info.reflectAs(Method.class, MethodHandles.Lookup.IMPL_LOOKUP)\n@@ -619,1 +636,1 @@\n-                exceptionTypes = null;\n+                return new Class<?>[0];\n@@ -621,1 +638,1 @@\n-                exceptionTypes = info.reflectAs(Constructor.class, MethodHandles.Lookup.IMPL_LOOKUP)\n+                return info.reflectAs(Constructor.class, MethodHandles.Lookup.IMPL_LOOKUP)\n@@ -626,5 +643,0 @@\n-            if (exceptionTypes != null) {\n-                if (Stream.of(exceptionTypes).anyMatch(VarHandles::isCheckedException)) {\n-                    throw newIllegalArgumentException(\"Cannot adapt a var handle with a method handle which throws checked exceptions\");\n-                }\n-            }\n@@ -632,10 +644,3 @@\n-            noCheckedExceptions(((DelegatingMethodHandle)handle).getTarget());\n-        } else {\n-            \/\/bound\n-            BoundMethodHandle boundHandle = (BoundMethodHandle)handle;\n-            for (int i = 0 ; i < boundHandle.fieldCount() ; i++) {\n-                Object arg = boundHandle.arg(i);\n-                if (arg instanceof MethodHandle){\n-                    noCheckedExceptions((MethodHandle) arg);\n-                }\n-            }\n+            return exceptionTypes(((DelegatingMethodHandle)handle).getTarget());\n+        } else if (handle instanceof NativeMethodHandle) {\n+            return new Class<?>[0];\n@@ -643,0 +648,4 @@\n+\n+        assert handle instanceof BoundMethodHandle : \"Unecpexted handle type: \" + handle;\n+        \/\/ unknown\n+        return null;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":44,"deletions":35,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -142,0 +142,7 @@\n+\n+    \/**\n+     * A best-effort method that tries to find any exceptions thrown by the given method handle.\n+     * @param handle the handle to check\n+     * @return an array of exceptions, or {@code null}.\n+     *\/\n+    Class<?>[] exceptionTypes(MethodHandle handle);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -240,1 +240,2 @@\n-     * @throws IllegalArgumentException if the target's method type and the function descriptor mismatch.\n+     * @throws IllegalArgumentException if the target's method type and the function descriptor mismatch, or\n+     *         if it is determined that the target method handle can throw an exception.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -332,0 +332,3 @@\n+     * If the boxing and unboxing filters throw any checked exceptions when invoked, the resulting var handle will\n+     * throw an {@link IllegalStateException}.\n+     * <p>\n@@ -341,1 +344,1 @@\n-     * or if either {@code filterFromTarget} or {@code filterToTarget} throws any checked exceptions.\n+     * or if it's determined that either {@code filterFromTarget} or {@code filterToTarget} throws any checked exceptions.\n@@ -359,0 +362,3 @@\n+     * If any of the filters throws a checked exception when invoked, the resulting var handle will\n+     * throw an {@link IllegalStateException}.\n+     * <p>\n@@ -371,1 +377,1 @@\n-     * or if any of the filters throws any checked exceptions.\n+     * or if it's determined that any of the filters throws any checked exceptions.\n@@ -467,0 +473,3 @@\n+     * If any of the filters throws a checked exception when invoked, the resulting var handle will\n+     * throw an {@link IllegalStateException}.\n+     * <p>\n@@ -479,1 +488,1 @@\n-     * or if {@code filter} throws any checked exceptions.\n+     * or if it's determined that {@code filter} throws any checked exceptions.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryHandles.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.internal.access.JavaLangInvokeAccess;\n@@ -55,0 +56,1 @@\n+import java.util.Arrays;\n@@ -78,0 +80,1 @@\n+    private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n@@ -433,0 +436,7 @@\n+    public static void checkExceptions(MethodHandle target) {\n+        Class<?>[] exceptions = JLIA.exceptionTypes(target);\n+        if (exceptions != null && exceptions.length != 0) {\n+            throw new IllegalArgumentException(\"Target handle may throw exceptions: \" + Arrays.toString(exceptions));\n+        }\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+        SharedUtils.checkExceptions(target);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Linker.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -110,0 +110,1 @@\n+        SharedUtils.checkExceptions(target);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+        SharedUtils.checkExceptions(target);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n+    @Test(expectedExceptions = IllegalStateException.class)\n@@ -195,1 +195,6 @@\n-        MemoryHandles.filterValue(intHandle, S2I, I2S_EX);\n+        VarHandle vh = MemoryHandles.filterValue(intHandle, S2I, I2S_EX);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment seg = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT, scope);\n+            vh.set(seg, \"42\");\n+            String x = (String) vh.get(seg); \/\/ should throw\n+        }\n@@ -198,1 +203,1 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n+    @Test(expectedExceptions = IllegalStateException.class)\n@@ -201,1 +206,5 @@\n-        MemoryHandles.filterValue(intHandle, S2I_EX, I2S);\n+        VarHandle vh = MemoryHandles.filterValue(intHandle, S2I_EX, I2S);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment seg = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT, scope);\n+            vh.set(seg, \"42\"); \/\/ should throw\n+        }\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -36,0 +36,3 @@\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -64,0 +67,8 @@\n+    @Test(expectedExceptions = IllegalArgumentException.class,\n+          expectedExceptionsMessageRegExp = \".*Target handle may throw exceptions.*\")\n+    public void testEagerExceptionBlocked() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            CLinker.getInstance().upcallStub(ThrowingUpcall.MH_throwException, FunctionDescriptor.ofVoid(), scope);\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestUpcallException.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    private static final MethodHandle MH_throwException;\n+    public static final MethodHandle MH_throwException;\n@@ -80,0 +80,4 @@\n+        MethodHandle handle = MH_throwException;\n+        MethodHandle invoker = MethodHandles.exactInvoker(MethodType.methodType(void.class));\n+        handle = MethodHandles.insertArguments(invoker, 0, handle);\n+\n@@ -81,1 +85,1 @@\n-            MemoryAddress stub = CLinker.getInstance().upcallStub(MH_throwException, FunctionDescriptor.ofVoid(), scope);\n+            MemoryAddress stub = CLinker.getInstance().upcallStub(handle, FunctionDescriptor.ofVoid(), scope);\n@@ -83,1 +87,1 @@\n-            downcall.invokeExact(stub); \/\/ should call System.exit(1);\n+            downcall.invokeExact(stub); \/\/ should call Shutdown.exit(1);\n","filename":"test\/jdk\/java\/foreign\/ThrowingUpcall.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"}]}