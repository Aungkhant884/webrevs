{"files":[{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n@@ -42,1 +40,0 @@\n-import java.util.Optional;\n@@ -117,0 +114,7 @@\n+    \/**\n+     * The value returned by the process when the target of an upcall throws an exception.\n+     *\n+     * @see CLinker#upcallStub(MethodHandle, FunctionDescriptor, ResourceScope)\n+     *\/\n+    int ERR_UNCAUGHT_EXCEPTION = 1;\n+\n@@ -227,1 +231,2 @@\n-     * <p>The returned memory address is associated with the provided scope. When such scope is closed,\n+     * <p>\n+     * The returned memory address is associated with the provided scope. When such scope is closed,\n@@ -230,0 +235,4 @@\n+     * The target method handle should not throw any exceptions. If the target method handle does throw an exception,\n+     * it will be handle by calling {@link System#exit System.exit(ERR_UNCAUGHT_EXCEPTION)}.\n+     * (See {@link #ERR_UNCAUGHT_EXCEPTION})\n+     * <p>\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -298,0 +298,3 @@\n+        } catch(Throwable t) {\n+            SharedUtils.handleUncaughtException(t);\n+            return null;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+    private static final MethodHandle MH_HANDLE_UNCAUGHT_EXCEPTION;\n@@ -100,0 +101,2 @@\n+            MH_HANDLE_UNCAUGHT_EXCEPTION = lookup.findStatic(SharedUtils.class, \"handleUncaughtException\",\n+                    methodType(void.class, Throwable.class));\n@@ -362,0 +365,7 @@\n+    static void handleUncaughtException(Throwable t) {\n+        if (t != null) {\n+            t.printStackTrace();\n+            System.exit(ERR_UNCAUGHT_EXCEPTION);\n+        }\n+    }\n+\n@@ -369,1 +379,5 @@\n-            closer = empty(methodType(void.class, Throwable.class)); \/\/ (Throwable) -> void\n+            if (!upcall) {\n+                closer = empty(methodType(void.class, Throwable.class)); \/\/ (Throwable) -> void\n+            } else {\n+                closer = MH_HANDLE_UNCAUGHT_EXCEPTION;\n+            }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run testng\/othervm\n+ * @run testng\/othervm\/timeout=720\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build ThrowingUpcall TestUpcallException\n+ *\n+ * @run testng\/othervm\/native\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   TestUpcallException\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import org.testng.annotations.Test;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.file.Paths;\n+\n+import static jdk.incubator.foreign.CLinker.ERR_UNCAUGHT_EXCEPTION;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.fail;\n+\n+public class TestUpcallException {\n+\n+    @Test\n+    public void testExceptionInterpreted() throws InterruptedException, IOException {\n+        boolean useSpec = false;\n+        run(useSpec);\n+    }\n+\n+    @Test\n+    public void testExceptionSpecialized() throws IOException, InterruptedException {\n+        boolean useSpec = true;\n+        run(useSpec);\n+    }\n+\n+    private void run(boolean useSpec) throws IOException, InterruptedException {\n+        Process process = new ProcessBuilder()\n+            .command(\n+                Paths.get(Utils.TEST_JDK)\n+                     .resolve(\"bin\")\n+                     .resolve(\"java\")\n+                     .toAbsolutePath()\n+                     .toString(),\n+                \"--add-modules\", \"jdk.incubator.foreign\",\n+                \"--enable-native-access=ALL-UNNAMED\",\n+                \"-Djava.library.path=\" + System.getProperty(\"java.library.path\"),\n+                \"-Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=\" + useSpec,\n+                \"-cp\", Utils.TEST_CLASS_PATH,\n+                \"ThrowingUpcall\")\n+            .start();\n+\n+        int result = process.waitFor();\n+        assertEquals(result, ERR_UNCAUGHT_EXCEPTION);\n+        assertOutputContains(process.getErrorStream(), \"Testing upcall exceptions\");\n+    }\n+\n+    private static void assertOutputContains(InputStream stream, String str) throws IOException {\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(stream))) {\n+            String line;\n+            while ((line = reader.readLine()) != null) {\n+                if (line.contains(str)) {\n+                    return;\n+                }\n+            }\n+        }\n+        fail(\"Did not find '\" + str + \"' in stream\");\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestUpcallException.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SymbolLookup;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n+\n+public class ThrowingUpcall {\n+\n+    private static final MethodHandle downcall;\n+    private static final MethodHandle MH_throwException;\n+\n+    static {\n+        System.loadLibrary(\"TestUpcall\");\n+        SymbolLookup lookup = SymbolLookup.loaderLookup();\n+        downcall = CLinker.getInstance().downcallHandle(\n+            lookup.lookup(\"f0_V__\").orElseThrow(),\n+            MethodType.methodType(void.class, MemoryAddress.class),\n+            FunctionDescriptor.ofVoid(C_POINTER)\n+        );\n+\n+        try {\n+            MH_throwException = MethodHandles.lookup().findStatic(ThrowingUpcall.class, \"throwException\",\n+                    MethodType.methodType(void.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    public static void throwException() throws Throwable {\n+        throw new Throwable(\"Testing upcall exceptions\");\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        test();\n+    }\n+\n+    public static void test() throws Throwable {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemoryAddress stub = CLinker.getInstance().upcallStub(MH_throwException, FunctionDescriptor.ofVoid(), scope);\n+\n+            downcall.invokeExact(stub); \/\/ should call System.exit(1);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/ThrowingUpcall.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"}]}