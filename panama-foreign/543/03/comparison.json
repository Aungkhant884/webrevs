{"files":[{"patch":"@@ -2355,0 +2355,5 @@\n+\n+            @Override\n+            public void exit(int statusCode) {\n+                Shutdown.exit(statusCode);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1491,0 +1491,5 @@\n+\n+            @Override\n+            public Class<?>[] exceptionTypes(MethodHandle handle) {\n+                return VarHandles.exceptionTypes(handle);\n+            }\n@@ -1962,9 +1967,10 @@\n-            MH_cast                  = 0,\n-            MH_selectAlternative     = 1,\n-            MH_countedLoopPred       = 2,\n-            MH_countedLoopStep       = 3,\n-            MH_initIterator          = 4,\n-            MH_iteratePred           = 5,\n-            MH_iterateNext           = 6,\n-            MH_Array_newInstance     = 7,\n-            MH_LIMIT                 = 8;\n+            MH_cast                               = 0,\n+            MH_selectAlternative                  = 1,\n+            MH_countedLoopPred                    = 2,\n+            MH_countedLoopStep                    = 3,\n+            MH_initIterator                       = 4,\n+            MH_iteratePred                        = 5,\n+            MH_iterateNext                        = 6,\n+            MH_Array_newInstance                  = 7,\n+            MH_VarHandles_handleCheckedExceptions = 8,\n+            MH_LIMIT                              = 9;\n@@ -2020,0 +2026,3 @@\n+                case MH_VarHandles_handleCheckedExceptions:\n+                    return IMPL_LOOKUP.findStatic(VarHandles.class, \"handleCheckedExceptions\",\n+                            MethodType.methodType(void.class, Throwable.class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":18,"deletions":9,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.reflect.Parameter;\n@@ -37,1 +36,0 @@\n-import java.util.LinkedHashMap;\n@@ -39,1 +37,0 @@\n-import java.util.Map;\n@@ -48,2 +45,0 @@\n-import static java.util.stream.Collectors.joining;\n-import static java.util.stream.Collectors.toList;\n@@ -362,1 +357,1 @@\n-    public static VarHandle filterValue(VarHandle target, MethodHandle filterToTarget, MethodHandle filterFromTarget) {\n+    public static VarHandle filterValue(VarHandle target, MethodHandle pFilterToTarget, MethodHandle pFilterFromTarget) {\n@@ -364,2 +359,2 @@\n-        Objects.requireNonNull(filterToTarget);\n-        Objects.requireNonNull(filterFromTarget);\n+        Objects.requireNonNull(pFilterToTarget);\n+        Objects.requireNonNull(pFilterFromTarget);\n@@ -367,2 +362,2 @@\n-        noCheckedExceptions(filterToTarget);\n-        noCheckedExceptions(filterFromTarget);\n+        MethodHandle filterToTarget = adaptForCheckedExceptions(pFilterToTarget);\n+        MethodHandle filterFromTarget = adaptForCheckedExceptions(pFilterFromTarget);\n@@ -476,2 +471,3 @@\n-            noCheckedExceptions(filters[i]);\n-            MethodType filterType = filters[i].type();\n+            MethodHandle filter = Objects.requireNonNull(filters[i]);\n+            filter = adaptForCheckedExceptions(filter);\n+            MethodType filterType = filter.type();\n@@ -567,1 +563,1 @@\n-    public static VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle filter) {\n+    public static VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle pFilter) {\n@@ -569,2 +565,2 @@\n-        Objects.requireNonNull(filter);\n-        noCheckedExceptions(filter);\n+        Objects.requireNonNull(pFilter);\n+        MethodHandle filter = adaptForCheckedExceptions(pFilter);\n@@ -607,1 +603,23 @@\n-    private static void noCheckedExceptions(MethodHandle handle) {\n+    private static MethodHandle adaptForCheckedExceptions(MethodHandle target) {\n+        Class<?>[] exceptionTypes = exceptionTypes(target);\n+        if (exceptionTypes != null) { \/\/ exceptions known\n+            if (Stream.of(exceptionTypes).anyMatch(VarHandles::isCheckedException)) {\n+                throw newIllegalArgumentException(\"Cannot adapt a var handle with a method handle which throws checked exceptions\");\n+            }\n+            return target; \/\/ no adaptation needed\n+        } else {\n+            MethodHandle handler = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_VarHandles_handleCheckedExceptions);\n+            MethodHandle zero = MethodHandles.zero(target.type().returnType()); \/\/ dead branch\n+            handler = MethodHandles.collectArguments(zero, 0, handler);\n+            return MethodHandles.catchException(target, Throwable.class, handler);\n+        }\n+    }\n+\n+    static void handleCheckedExceptions(Throwable throwable) throws Throwable {\n+        if (isCheckedException(throwable.getClass())) {\n+            throw new IllegalStateException(\"Adapter handle threw checked exception\", throwable);\n+        }\n+        throw throwable;\n+    }\n+\n+    static Class<?>[] exceptionTypes(MethodHandle handle) {\n@@ -614,1 +632,0 @@\n-            final Class<?>[] exceptionTypes;\n@@ -616,1 +633,1 @@\n-                exceptionTypes = info.reflectAs(Method.class, MethodHandles.Lookup.IMPL_LOOKUP)\n+                return info.reflectAs(Method.class, MethodHandles.Lookup.IMPL_LOOKUP)\n@@ -619,1 +636,1 @@\n-                exceptionTypes = null;\n+                return new Class<?>[0];\n@@ -621,1 +638,1 @@\n-                exceptionTypes = info.reflectAs(Constructor.class, MethodHandles.Lookup.IMPL_LOOKUP)\n+                return info.reflectAs(Constructor.class, MethodHandles.Lookup.IMPL_LOOKUP)\n@@ -626,5 +643,0 @@\n-            if (exceptionTypes != null) {\n-                if (Stream.of(exceptionTypes).anyMatch(VarHandles::isCheckedException)) {\n-                    throw newIllegalArgumentException(\"Cannot adapt a var handle with a method handle which throws checked exceptions\");\n-                }\n-            }\n@@ -632,10 +644,3 @@\n-            noCheckedExceptions(((DelegatingMethodHandle)handle).getTarget());\n-        } else {\n-            \/\/bound\n-            BoundMethodHandle boundHandle = (BoundMethodHandle)handle;\n-            for (int i = 0 ; i < boundHandle.fieldCount() ; i++) {\n-                Object arg = boundHandle.arg(i);\n-                if (arg instanceof MethodHandle){\n-                    noCheckedExceptions((MethodHandle) arg);\n-                }\n-            }\n+            return exceptionTypes(((DelegatingMethodHandle)handle).getTarget());\n+        } else if (handle instanceof NativeMethodHandle) {\n+            return new Class<?>[0];\n@@ -643,0 +648,4 @@\n+\n+        assert handle instanceof BoundMethodHandle : \"Unecpexted handle type: \" + handle;\n+        \/\/ unknown\n+        return null;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":44,"deletions":35,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -387,0 +387,6 @@\n+\n+    \/**\n+     * Direct access to Shutdown.exit to avoid security manager checks\n+     * @param statusCode the status code\n+     *\/\n+    void exit(int statusCode);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -142,0 +142,7 @@\n+\n+    \/**\n+     * A best-effort method that tries to find any exceptions thrown by the given method handle.\n+     * @param handle the handle to check\n+     * @return an array of exceptions, or {@code null}.\n+     *\/\n+    Class<?>[] exceptionTypes(MethodHandle handle);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n@@ -42,1 +40,0 @@\n-import java.util.Optional;\n@@ -227,1 +224,2 @@\n-     * <p>The returned memory address is associated with the provided scope. When such scope is closed,\n+     * <p>\n+     * The returned memory address is associated with the provided scope. When such scope is closed,\n@@ -230,0 +228,3 @@\n+     * The target method handle should not throw any exceptions. If the target method handle does throw an exception,\n+     * the VM will exit with a non-zero exit code.\n+     * <p>\n@@ -239,1 +240,2 @@\n-     * @throws IllegalArgumentException if the target's method type and the function descriptor mismatch.\n+     * @throws IllegalArgumentException if the target's method type and the function descriptor mismatch, or\n+     *         if it is determined that the target method handle can throw an exception.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -332,0 +332,3 @@\n+     * If the boxing and unboxing filters throw any checked exceptions when invoked, the resulting var handle will\n+     * throw an {@link IllegalStateException}.\n+     * <p>\n@@ -341,1 +344,1 @@\n-     * or if either {@code filterFromTarget} or {@code filterToTarget} throws any checked exceptions.\n+     * or if it's determined that either {@code filterFromTarget} or {@code filterToTarget} throws any checked exceptions.\n@@ -359,0 +362,3 @@\n+     * If any of the filters throws a checked exception when invoked, the resulting var handle will\n+     * throw an {@link IllegalStateException}.\n+     * <p>\n@@ -371,1 +377,1 @@\n-     * or if any of the filters throws any checked exceptions.\n+     * or if it's determined that any of the filters throws any checked exceptions.\n@@ -467,0 +473,3 @@\n+     * If any of the filters throws a checked exception when invoked, the resulting var handle will\n+     * throw an {@link IllegalStateException}.\n+     * <p>\n@@ -479,1 +488,1 @@\n-     * or if {@code filter} throws any checked exceptions.\n+     * or if it's determined that {@code filter} throws any checked exceptions.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryHandles.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.internal.foreign.abi.SharedUtils;\n+import sun.security.action.GetPropertyAction;\n@@ -31,0 +31,1 @@\n+import static sun.security.action.GetPropertyAction.privilegedGetProperty;\n@@ -40,2 +41,2 @@\n-        String arch = System.getProperty(\"os.arch\");\n-        String os = System.getProperty(\"os.name\");\n+        String arch = privilegedGetProperty(\"os.arch\");\n+        String os = privilegedGetProperty(\"os.name\");\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/CABI.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -298,0 +298,3 @@\n+        } catch(Throwable t) {\n+            SharedUtils.handleUncaughtException(t);\n+            return null;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,3 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -53,0 +56,1 @@\n+import java.util.Arrays;\n@@ -75,0 +79,3 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+    private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n+\n@@ -82,0 +89,1 @@\n+    private static final MethodHandle MH_HANDLE_UNCAUGHT_EXCEPTION;\n@@ -100,0 +108,2 @@\n+            MH_HANDLE_UNCAUGHT_EXCEPTION = lookup.findStatic(SharedUtils.class, \"handleUncaughtException\",\n+                    methodType(void.class, Throwable.class));\n@@ -362,0 +372,7 @@\n+    static void handleUncaughtException(Throwable t) {\n+        if (t != null) {\n+            t.printStackTrace();\n+            JLA.exit(1);\n+        }\n+    }\n+\n@@ -369,1 +386,5 @@\n-            closer = empty(methodType(void.class, Throwable.class)); \/\/ (Throwable) -> void\n+            if (!upcall) {\n+                closer = empty(methodType(void.class, Throwable.class)); \/\/ (Throwable) -> void\n+            } else {\n+                closer = MH_HANDLE_UNCAUGHT_EXCEPTION;\n+            }\n@@ -415,0 +436,7 @@\n+    public static void checkExceptions(MethodHandle target) {\n+        Class<?>[] exceptions = JLIA.exceptionTypes(target);\n+        if (exceptions != null && exceptions.length != 0) {\n+            throw new IllegalArgumentException(\"Target handle may throw exceptions: \" + Arrays.toString(exceptions));\n+        }\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+        SharedUtils.checkExceptions(target);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Linker.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -110,0 +110,1 @@\n+        SharedUtils.checkExceptions(target);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+        SharedUtils.checkExceptions(target);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n+    @Test(expectedExceptions = IllegalStateException.class)\n@@ -195,1 +195,6 @@\n-        MemoryHandles.filterValue(intHandle, S2I, I2S_EX);\n+        VarHandle vh = MemoryHandles.filterValue(intHandle, S2I, I2S_EX);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment seg = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT, scope);\n+            vh.set(seg, \"42\");\n+            String x = (String) vh.get(seg); \/\/ should throw\n+        }\n@@ -198,1 +203,1 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n+    @Test(expectedExceptions = IllegalStateException.class)\n@@ -201,1 +206,5 @@\n-        MemoryHandles.filterValue(intHandle, S2I_EX, I2S);\n+        VarHandle vh = MemoryHandles.filterValue(intHandle, S2I_EX, I2S);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment seg = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT, scope);\n+            vh.set(seg, \"42\"); \/\/ should throw\n+        }\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run testng\/othervm\n+ * @run testng\/othervm\/timeout=720\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build ThrowingUpcall TestUpcallException\n+ *\n+ * @run testng\/othervm\/native\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   TestUpcallException\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.test.lib.Utils;\n+import org.testng.annotations.Test;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestUpcallException {\n+\n+    @Test\n+    public void testExceptionInterpreted() throws InterruptedException, IOException {\n+        boolean useSpec = false;\n+        run(useSpec);\n+    }\n+\n+    @Test\n+    public void testExceptionSpecialized() throws IOException, InterruptedException {\n+        boolean useSpec = true;\n+        run(useSpec);\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class,\n+          expectedExceptionsMessageRegExp = \".*Target handle may throw exceptions.*\")\n+    public void testEagerExceptionBlocked() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            CLinker.getInstance().upcallStub(ThrowingUpcall.MH_throwException, FunctionDescriptor.ofVoid(), scope);\n+        }\n+    }\n+\n+    private void run(boolean useSpec) throws IOException, InterruptedException {\n+        Process process = new ProcessBuilder()\n+            .command(\n+                Paths.get(Utils.TEST_JDK)\n+                     .resolve(\"bin\")\n+                     .resolve(\"java\")\n+                     .toAbsolutePath()\n+                     .toString(),\n+                \"--add-modules\", \"jdk.incubator.foreign\",\n+                \"--enable-native-access=ALL-UNNAMED\",\n+                \"-Djava.library.path=\" + System.getProperty(\"java.library.path\"),\n+                \"-Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=\" + useSpec,\n+                \"-cp\", Utils.TEST_CLASS_PATH,\n+                \/\/ security manager to block normal System.exit\n+                \"-Djava.security.manager=allow\",\n+                \"ThrowingUpcall\")\n+            .start();\n+\n+        int result = process.waitFor();\n+        assertNotEquals(result, 0);\n+\n+        List<String> outLines = linesFromStream(process.getInputStream());\n+        outLines.forEach(System.out::println);\n+        List<String> errLines = linesFromStream(process.getErrorStream());\n+        errLines.forEach(System.err::println);\n+\n+        \/\/ Exception message would be found in stack trace\n+        String shouldInclude = \"Testing upcall exceptions\";\n+        assertTrue(linesContain(errLines, shouldInclude), \"Did not find '\" + shouldInclude + \"' in stderr\");\n+\n+        \/\/ If the VM crashes with an uncaught IllegalStateException from the security manager\n+        \/\/ the crash log should include the exception message.\n+        \/\/ Make sure that is _not_ the case.\n+        String shouldNotInclude = \"Can not use exitVM\";\n+        assertFalse(linesContain(outLines, shouldNotInclude), \"Found '\" + shouldNotInclude + \"' in stdout\");\n+    }\n+\n+    private boolean linesContain(List<String> errLines, String shouldInclude) {\n+        return errLines.stream().anyMatch(line -> line.contains(shouldInclude));\n+    }\n+\n+    private static List<String> linesFromStream(InputStream stream) throws IOException {\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(stream))) {\n+            return reader.lines().toList();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestUpcallException.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SymbolLookup;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.security.Permission;\n+\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n+\n+public class ThrowingUpcall {\n+\n+    private static final MethodHandle downcall;\n+    public static final MethodHandle MH_throwException;\n+\n+    static {\n+        System.setSecurityManager(new SecurityManager() {\n+            @Override\n+            public void checkExit(int status) {\n+                throw new IllegalStateException(\"Can not use exitVM\");\n+            }\n+\n+            @Override\n+            public void checkPermission(Permission perm) {\n+                \/\/ do nothing\n+            }\n+        });\n+\n+        System.loadLibrary(\"TestUpcall\");\n+        SymbolLookup lookup = SymbolLookup.loaderLookup();\n+        downcall = CLinker.getInstance().downcallHandle(\n+            lookup.lookup(\"f0_V__\").orElseThrow(),\n+            MethodType.methodType(void.class, MemoryAddress.class),\n+            FunctionDescriptor.ofVoid(C_POINTER)\n+        );\n+\n+        try {\n+            MH_throwException = MethodHandles.lookup().findStatic(ThrowingUpcall.class, \"throwException\",\n+                    MethodType.methodType(void.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    public static void throwException() throws Throwable {\n+        throw new Throwable(\"Testing upcall exceptions\");\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        test();\n+    }\n+\n+    public static void test() throws Throwable {\n+        MethodHandle handle = MH_throwException;\n+        MethodHandle invoker = MethodHandles.exactInvoker(MethodType.methodType(void.class));\n+        handle = MethodHandles.insertArguments(invoker, 0, handle);\n+\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemoryAddress stub = CLinker.getInstance().upcallStub(handle, FunctionDescriptor.ofVoid(), scope);\n+\n+            downcall.invokeExact(stub); \/\/ should call Shutdown.exit(1);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/ThrowingUpcall.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"}]}