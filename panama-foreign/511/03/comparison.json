{"files":[{"patch":"@@ -118,1 +118,1 @@\n- * <h2>Scope handles<\/h2>\n+ * <h2>Resource scope handles<\/h2>\n@@ -130,1 +130,2 @@\n-try (ResourceScope.Handle segmentHandle = segment.scope().acquire()) {\n+ResourceScope.Handle segmentHandle = segment.scope().acquire()\n+try {\n@@ -132,1 +133,3 @@\n-} \/\/ release scope handle\n+} finally {\n+   segment.scope().release(segmentHandle);\n+}\n@@ -135,0 +138,5 @@\n+ * Acquiring implicit resource scopes is also possible, but it is often unnecessary: since resources associated with\n+ * an implicit scope will only be released when the scope becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>,\n+ * clients can use e.g. {@link java.lang.ref.Reference#reachabilityFence(Object)} to make sure that resources associated\n+ * with implicit scopes are not released prematurely. That said, the above code snippet works (trivially) for implicit scopes too.\n+ *\n@@ -192,4 +200,7 @@\n-     * Make this resource scope non-closeable by acquiring a new resource scope handle. This scope cannot be closed unless all its\n-     * acquired handles have been closed first. Additionally, a resource scope handle maintains a strong reference\n-     * to its resource scope; in other words, resources associated with an implicit resource scopes cannot be released\n-     * until <em>all<\/em> the handles acquired from the implicit scope become <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n+     * If this resource scope is explicit, this method acquires a new resource scope handle, associated with this\n+     * resource scope; an explicit resource scope cannot be {@link #close() closed}\n+     * until all the resource scope handles acquired from it have been {@link #release(Handle)} released}.\n+     * <p>\n+     * If this scope is an {@link #isImplicit()} implicit} scope, calling this method will always return the\n+     * <em>implicit<\/em> resource scope handle. The implicit resource scope handle is associated with the\n+     * {@link ResourceScope#globalScope() global scope}.\n@@ -201,3 +212,12 @@\n-     * An abstraction modelling resource scope handle. A resource scope handle is typically acquired by clients (see\n-     * {@link #acquire()} in order to prevent the resource scope from being closed while executing a certain operation.\n-     * A resource scope handle features a method (see {@link #close()}) which can be used by clients to release the handle.\n+     * Release the provided resource scope handle. This method is idempotent, that is, releasing the same handle\n+     * multiple times has no effect.\n+     * @throws IllegalArgumentException if this resource scope is explicit and the provided handle is not associated\n+     * with this scope.\n+     *\/\n+    void release(Handle handle);\n+\n+    \/**\n+     * An abstraction modelling a resource scope handle. A resource scope handle is typically {@link #acquire() acquired} by clients\n+     * in order to prevent an explicit resource scope from being closed while executing a certain operation.\n+     * Once obtained, resource scope handles can be {@link #release(Handle)} released}; an explicit resource scope can\n+     * be closed only <em>after<\/em> all the resource scope handles acquired from it have been released.\n@@ -205,1 +225,1 @@\n-    interface Handle extends AutoCloseable {\n+    interface Handle {\n@@ -208,2 +228,4 @@\n-         * Release this handle on the resource scope associated with this instance. This method is idempotent,\n-         * that is, closing an already closed handle has no effect.\n+         * Returns the resource scope associated with this handle, or the {@link ResourceScope#globalScope()}\n+         * if this handle is the implicit resource scope handle.\n+         * @return the resource scope associated with this handle, or the {@link ResourceScope#globalScope()}\n+         * if this handle is the implicit resource scope handle.\n@@ -211,2 +233,1 @@\n-        @Override\n-        void close();\n+        ResourceScope scope();\n@@ -254,3 +275,5 @@\n-     * Create a new implicit, shared resource scope. Since implicit scopes can only be closed implicitly by the garbage collector,\n-     * it is recommended that implicit scopes are only used in cases where deallocation performance is not a critical concern,\n-     * to avoid unnecessary memory pressure.\n+     * Create a new <em>implicit scope<\/em>. The implicit scope is a managed, shared, and non-closeable scope which only features\n+     * <a href=\"ResourceScope.html#implicit-closure\"><em>implicit closure<\/em><\/a>.\n+     * Since implicit scopes can only be closed implicitly by the garbage collector, it is recommended that implicit\n+     * scopes are only used in cases where deallocation performance is not a critical concern, to avoid unnecessary\n+     * memory pressure.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ResourceScope.java","additions":41,"deletions":18,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -115,1 +116,1 @@\n-    final class ConfinedHandle implements Handle {\n+    final class ConfinedHandle implements HandleImpl {\n@@ -118,0 +119,5 @@\n+        @Override\n+        public ResourceScope scope() {\n+            return ConfinedScope.this;\n+        }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ConfinedScope.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.internal.vm.annotation.Stable;\n@@ -103,1 +102,1 @@\n-        return new NonCloseableSharedScope(CleanerFactory.cleaner());\n+        return new ImplicitScopeImpl(CleanerFactory.cleaner());\n@@ -127,0 +126,25 @@\n+    @Override\n+    public final void release(Handle handle) {\n+        try {\n+            Objects.requireNonNull(handle);\n+            if (!checkHandle(handle)) {\n+                throw new IllegalArgumentException(\"Cannot release an handle acquired from another scope\");\n+            }\n+            ((HandleImpl) handle).close();\n+        } finally {\n+            Reference.reachabilityFence(this);\n+        }\n+    }\n+\n+    boolean checkHandle(Handle handle) {\n+        return handle.scope() == this;\n+    }\n+\n+    \/**\n+     * Internal interface used to implement resource scope handles.\n+     *\/\n+    interface HandleImpl extends Handle, AutoCloseable {\n+        @Override\n+        void close();\n+    }\n+\n@@ -196,1 +220,1 @@\n-    static class NonCloseableSharedScope extends SharedScope {\n+    static class ImplicitScopeImpl extends SharedScope {\n@@ -198,4 +222,1 @@\n-        @Stable\n-        private Handle handle;\n-\n-        public NonCloseableSharedScope(Cleaner cleaner) {\n+        public ImplicitScopeImpl(Cleaner cleaner) {\n@@ -207,5 +228,1 @@\n-            if (handle == null) {\n-                \/\/ capture 'this'\n-                handle = () -> Reference.reachabilityFence(NonCloseableSharedScope.this);\n-            }\n-            return handle;\n+            return implicitHandle;\n@@ -223,0 +240,17 @@\n+\n+        @Override\n+        boolean checkHandle(Handle handle) {\n+            return handle == implicitHandle;\n+        }\n+\n+        private final static HandleImpl implicitHandle = new HandleImpl() {\n+            @Override\n+            public void close() {\n+                \/\/ do nothing\n+            }\n+\n+            @Override\n+            public ResourceScope scope() {\n+                return GLOBAL;\n+            }\n+        };\n@@ -226,1 +260,1 @@\n-     * The global, always alive, non-closeable, shared scope. This is like a {@link NonCloseableSharedScope non-closeable scope},\n+     * The global, always alive, non-closeable, shared scope. This is like a {@link ImplicitScopeImpl non-closeable scope},\n@@ -230,1 +264,1 @@\n-    public static ResourceScopeImpl GLOBAL = new NonCloseableSharedScope( null) {\n+    public static ResourceScopeImpl GLOBAL = new ImplicitScopeImpl( null) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ResourceScopeImpl.java","additions":48,"deletions":14,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -173,1 +174,1 @@\n-    class SharedHandle implements Handle {\n+    class SharedHandle implements HandleImpl {\n@@ -176,0 +177,5 @@\n+        @Override\n+        public ResourceScope scope() {\n+            return SharedScope.this;\n+        }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SharedScope.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-            scopeHandle.close();\n+            resourceScope.release(scopeHandle);\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-        addDefaultMapping(ResourceScope.class, ResourceScope.newConfinedScope());\n+        addDefaultMapping(ResourceScope.class, ResourceScope.newImplicitScope());\n@@ -164,0 +164,1 @@\n+        addDefaultMapping(ResourceScope.Handle.class, ResourceScope.globalScope().acquire());\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -172,3 +172,3 @@\n-                handle.close();\n-                handle.close(); \/\/ make sure it's idempotent\n-                handle.close(); \/\/ make sure it's idempotent\n+                scope.release(handle);\n+                scope.release(handle); \/\/ make sure it's idempotent\n+                scope.release(handle); \/\/ make sure it's idempotent\n@@ -190,3 +190,3 @@\n-                    handle.close();\n-                    handle.close(); \/\/ make sure it's idempotent\n-                    handle.close(); \/\/ make sure it's idempotent\n+                    scope.release(handle);\n+                    scope.release(handle); \/\/ make sure it's idempotent\n+                    scope.release(handle); \/\/ make sure it's idempotent\n@@ -221,1 +221,2 @@\n-        ResourceScope.Handle handle = ResourceScope.newConfinedScope().acquire();\n+        ResourceScope scope = ResourceScope.newConfinedScope();\n+        ResourceScope.Handle handle = scope.acquire();\n@@ -225,3 +226,3 @@\n-                handle.close();\n-                handle.close(); \/\/ make sure it's idempotent\n-                handle.close(); \/\/ make sure it's idempotent\n+                scope.release(handle);\n+                scope.release(handle); \/\/ make sure it's idempotent\n+                scope.release(handle); \/\/ make sure it's idempotent\n@@ -260,3 +261,3 @@\n-        handle.close();\n-        handle.close(); \/\/ make sure it's idempotent\n-        handle.close(); \/\/ make sure it's idempotent\n+        scope.release(handle);\n+        scope.release(handle); \/\/ make sure it's idempotent\n+        scope.release(handle); \/\/ make sure it's idempotent\n","filename":"test\/jdk\/java\/foreign\/TestResourceScope.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -94,1 +94,4 @@\n-            ScopedOperation.ofScope(scope -> scope.acquire().close(), \"ResourceScope::lock\");\n+            ScopedOperation.ofScope(scope -> {\n+                ResourceScope.Handle handle = scope.acquire();\n+                scope.release(handle);\n+            }, \"ResourceScope::lock\");\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-            handle.close();\n+            mismatchSegmentLarge1.scope().release(handle);\n@@ -164,1 +164,1 @@\n-            handle.close();\n+            mismatchSegmentLarge1.scope().release(handle);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/BulkMismatchAcquire.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}