{"files":[{"patch":"@@ -110,1 +110,1 @@\n- * <h2>Scope handles<\/h2>\n+ * <h2>Resource scope handles<\/h2>\n@@ -112,4 +112,4 @@\n- * Resource scopes can be made <em>non-closeable<\/em> by acquiring one or more resource scope <em>handles<\/em> (see\n- * {@link #acquire()}. A resource scope handle can be used to make sure that its corresponding scope cannot be closed\n- * (either explicitly, or implicitly) for a certain period of time - e.g. when one or more resources associated with\n- * the parent scope need to be accessed. A resource scope can be acquired multiple times; the resource scope can only be\n+ * Explicit resource scopes can be made <em>non-closeable<\/em> by (see {@link #acquire() acquiring} one or more resource\n+ * scope <em>handles<\/em>. A resource scope handle can be used to make sure that its corresponding scope cannot be\n+ * {@link #close()} closed} for a certain period of time - e.g. when one or more resources associated with\n+ * the parent scope need to be accessed. An explicit resource scope can be acquired multiple times; the resource scope can only be\n@@ -122,1 +122,2 @@\n-try (ResourceScope.Handle segmentHandle = segment.scope().acquire()) {\n+ResourceScope.Handle segmentHandle = segment.scope().acquire()\n+try {\n@@ -124,1 +125,3 @@\n-} \/\/ release scope handle\n+} finally {\n+   segment.scope().release(segmentHandle);\n+}\n@@ -127,0 +130,5 @@\n+ * Acquiring implicit resource scopes is also possible, but it is often unnecessary: since resources associated with\n+ * an implicit scope will only be released when the scope becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>,\n+ * clients can use e.g. {@link java.lang.ref.Reference#reachabilityFence(Object)} to make sure that resources associated\n+ * with implicit scopes are not released prematurely. That said, the above code snippet works (trivially) for implicit scopes too.\n+ *\n@@ -184,5 +192,7 @@\n-     * Make this resource scope non-closeable by acquiring a new resource scope handle. This scope cannot be closed unless all its\n-     * acquired handles have been closed first. Additionally, a resource scope handle maintains a strong reference\n-     * to its resource scope; this means that if a resource scope features\n-     * <a href=\"ResourceScope.html#implicit-closure\"><em>implicit closure<\/em><\/a>, the scope cannot be implicitly closed\n-     * until all its acquired handles becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n+     * If this resource scope is explicit, this method acquires a new resource scope handle, associated with this\n+     * resource scope; an explicit resource scope cannot be {@link #close() closed}\n+     * until all the resource scope handles acquired from it have been {@link #release(Handle)} released}.\n+     * <p>\n+     * If this scope is an {@link #isImplicit()} implicit} scope, calling this method will always return the\n+     * <em>implicit<\/em> resource scope handle. The implicit resource scope handle is associated with the\n+     * {@link ResourceScope#globalScope() global scope}.\n@@ -194,3 +204,12 @@\n-     * An abstraction modelling resource scope handle. A resource scope handle is typically acquired by clients (see\n-     * {@link #acquire()} in order to prevent the resource scope from being closed while executing a certain operation.\n-     * A resource scope handle features a method (see {@link #close()}) which can be used by clients to release the handle.\n+     * Release the provided resource scope handle. This method is idempotent, that is, releasing the same handle\n+     * multiple times has no effect.\n+     * @throws IllegalArgumentException if this resource scope is explicit and the provided handle is not associated\n+     * with this scope.\n+     *\/\n+    void release(Handle handle);\n+\n+    \/**\n+     * An abstraction modelling a resource scope handle. A resource scope handle is typically {@link #acquire() acquired} by clients\n+     * {@link #acquire()} in order to prevent an explicit resource scope from being closed while executing a certain operation.\n+     * Once obtained, resource scope handles can be {@link #release(Handle)} released}; an explicit resource scope can\n+     * be closed only <em>after<\/em> all the resource scope handles acquired from it have been released.\n@@ -198,1 +217,1 @@\n-    interface Handle extends AutoCloseable {\n+    interface Handle {\n@@ -201,2 +220,4 @@\n-         * Release this handle on the resource scope associated with this instance. This method is idempotent,\n-         * that is, closing an already closed handle has no effect.\n+         * Returns the resource scope associated with this handle, or the {@link ResourceScope#globalScope()}\n+         * if this handle is the implicit resource scope handle.\n+         * @return the resource scope associated with this handle, or the {@link ResourceScope#globalScope()}\n+         * if this handle is the implicit resource scope handle.\n@@ -204,2 +225,1 @@\n-        @Override\n-        void close();\n+        ResourceScope scope();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ResourceScope.java","additions":40,"deletions":20,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -115,1 +116,1 @@\n-    final class ConfinedHandle implements Handle {\n+    final class ConfinedHandle implements HandleImpl {\n@@ -118,0 +119,5 @@\n+        @Override\n+        public ResourceScope scope() {\n+            return ConfinedScope.this;\n+        }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ConfinedScope.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -127,0 +127,17 @@\n+    @Override\n+    public void release(Handle handle) {\n+        Objects.requireNonNull(handle);\n+        if (!isImplicit() && handle.scope() != this) {\n+            throw new IllegalArgumentException(\"Cannot release an handle acquired from another scope\");\n+        }\n+        ((HandleImpl)handle).close();\n+    }\n+\n+    \/**\n+     * Internal interface used to implement resource scope handles.\n+     *\/\n+    interface HandleImpl extends Handle, AutoCloseable {\n+        @Override\n+        void close();\n+    }\n+\n@@ -198,3 +215,0 @@\n-        @Stable\n-        private Handle handle;\n-\n@@ -207,5 +221,1 @@\n-            if (handle == null) {\n-                \/\/ capture 'this'\n-                handle = () -> Reference.reachabilityFence(NonCloseableSharedScope.this);\n-            }\n-            return handle;\n+            return implicitHandle;\n@@ -223,0 +233,12 @@\n+\n+        private final static HandleImpl implicitHandle = new HandleImpl() {\n+            @Override\n+            public void close() {\n+                \/\/ do nothing\n+            }\n+\n+            @Override\n+            public ResourceScope scope() {\n+                return GLOBAL;\n+            }\n+        };\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ResourceScopeImpl.java","additions":30,"deletions":8,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -173,1 +174,1 @@\n-    class SharedHandle implements Handle {\n+    class SharedHandle implements HandleImpl {\n@@ -176,0 +177,5 @@\n+        @Override\n+        public ResourceScope scope() {\n+            return SharedScope.this;\n+        }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SharedScope.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-            scopeHandle.close();\n+            resourceScope.release(scopeHandle);\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-        addDefaultMapping(ResourceScope.class, ResourceScope.newConfinedScope());\n+        addDefaultMapping(ResourceScope.class, ResourceScope.newImplicitScope());\n@@ -164,0 +164,1 @@\n+        addDefaultMapping(ResourceScope.Handle.class, ResourceScope.globalScope().acquire());\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -172,3 +172,3 @@\n-                handle.close();\n-                handle.close(); \/\/ make sure it's idempotent\n-                handle.close(); \/\/ make sure it's idempotent\n+                scope.release(handle);\n+                scope.release(handle); \/\/ make sure it's idempotent\n+                scope.release(handle); \/\/ make sure it's idempotent\n@@ -190,3 +190,3 @@\n-                    handle.close();\n-                    handle.close(); \/\/ make sure it's idempotent\n-                    handle.close(); \/\/ make sure it's idempotent\n+                    scope.release(handle);\n+                    scope.release(handle); \/\/ make sure it's idempotent\n+                    scope.release(handle); \/\/ make sure it's idempotent\n@@ -221,1 +221,2 @@\n-        ResourceScope.Handle handle = ResourceScope.newConfinedScope().acquire();\n+        ResourceScope scope = ResourceScope.newConfinedScope();\n+        ResourceScope.Handle handle = scope.acquire();\n@@ -225,3 +226,3 @@\n-                handle.close();\n-                handle.close(); \/\/ make sure it's idempotent\n-                handle.close(); \/\/ make sure it's idempotent\n+                scope.release(handle);\n+                scope.release(handle); \/\/ make sure it's idempotent\n+                scope.release(handle); \/\/ make sure it's idempotent\n@@ -260,3 +261,3 @@\n-        handle.close();\n-        handle.close(); \/\/ make sure it's idempotent\n-        handle.close(); \/\/ make sure it's idempotent\n+        scope.release(handle);\n+        scope.release(handle); \/\/ make sure it's idempotent\n+        scope.release(handle); \/\/ make sure it's idempotent\n","filename":"test\/jdk\/java\/foreign\/TestResourceScope.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -94,1 +94,4 @@\n-            ScopedOperation.ofScope(scope -> scope.acquire().close(), \"ResourceScope::lock\");\n+            ScopedOperation.ofScope(scope -> {\n+                ResourceScope.Handle handle = scope.acquire();\n+                scope.release(handle);\n+            }, \"ResourceScope::lock\");\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-            handle.close();\n+            mismatchSegmentLarge1.scope().release(handle);\n@@ -164,1 +164,1 @@\n-            handle.close();\n+            mismatchSegmentLarge1.scope().release(handle);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/BulkMismatchAcquire.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}