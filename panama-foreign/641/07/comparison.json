{"files":[{"patch":"@@ -160,1 +160,1 @@\n-#define SCOPE PKG_FOREIGN \"ResourceScope;\"\n+#define SCOPE PKG_FOREIGN \"MemorySession;\"\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -62,1 +62,1 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -2479,1 +2479,1 @@\n-    \/\/ A resource scope which keeps this loader reachable. Useful when returning\n+    \/\/ A memory session which keeps this loader reachable. Useful when returning\n@@ -2481,1 +2481,1 @@\n-    private final ResourceScope loaderScope = ResourceScopeImpl.heapScope(this);\n+    private final MemorySession loaderScope = MemorySessionImpl.heapSession(this);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n- * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, ResourceScope) Creating an upcall stub} requires a method\n+ * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, MemorySession) Creating an upcall stub} requires a method\n@@ -106,1 +106,1 @@\n- * when no longer required, they can be {@link ResourceScope#close() released}, via their {@linkplain NativeSymbol#scope() scope}.\n+ * when no longer required, they can be {@link MemorySession#close() released}, via their associated {@linkplain MemorySession session}.\n@@ -122,1 +122,1 @@\n- *     <li>The resource scope of {@code R} is {@linkplain ResourceScope#isAlive() alive}. Otherwise, the invocation throws\n+ *     <li>The memory session of {@code R} is {@linkplain MemorySession#isAlive() alive}. Otherwise, the invocation throws\n@@ -124,3 +124,3 @@\n- *     <li>The invocation occurs in same thread as the one {@link ResourceScope#ownerThread() owning} the resource scope of {@code R},\n- *     if said scope is confined. Otherwise, the invocation throws {@link IllegalStateException}; and<\/li>\n- *     <li>The scope of {@code R} is {@linkplain ResourceScope#keepAlive(ResourceScope) kept alive} (and cannot be closed) during the invocation.\n+ *     <li>The invocation occurs in same thread as the one {@link MemorySession#ownerThread() owning} the memory session of {@code R},\n+ *     if said session is confined. Otherwise, the invocation throws {@link IllegalStateException}; and<\/li>\n+ *     <li>The memory session of {@code R} is {@linkplain MemorySession#whileAlive(Runnable) kept alive} (and cannot be closed) during the invocation.\n@@ -219,3 +219,3 @@\n-     * Allocates a native stub with given scope which can be passed to other foreign functions (as a function pointer);\n-     * calling such a function pointer from native code will result in the execution of the provided method handle.\n-     *\n+     * Allocates a native stub which can be passed to other foreign functions (as a function pointer), with given\n+     * memory session. Calling such a function pointer from native code will result in the execution of the provided\n+     * method handle.\n@@ -223,1 +223,1 @@\n-     * The returned function pointer is associated with the provided scope. When such scope is closed,\n+     * The returned function pointer is associated with the provided memory session. When such session is closed,\n@@ -234,1 +234,1 @@\n-     * @param scope the upcall stub scope.\n+     * @param session the upcall stub memory session.\n@@ -239,2 +239,2 @@\n-     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n-     * than the thread owning {@code scope}.\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}, or if access occurs from\n+     * a thread other than the thread {@linkplain MemorySession#ownerThread() owning} {@code session}.\n@@ -242,1 +242,1 @@\n-    NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope);\n+    NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, MemorySession session);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/CLinker.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- *     <li>By the invocation of an {@linkplain CLinker#upcallStub(MethodHandle, FunctionDescriptor, ResourceScope) upcall stub} which accepts a pointer.\n+ *     <li>By the invocation of an {@linkplain CLinker#upcallStub(MethodHandle, FunctionDescriptor, MemorySession) upcall stub} which accepts a pointer.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryAddress.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import jdk.internal.foreign.Scoped;\n@@ -45,1 +46,0 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n@@ -57,1 +57,1 @@\n- * and temporal bounds (e.g. a {@link ResourceScope}). Spatial bounds ensure that memory access operations on a memory segment cannot affect a memory location\n+ * and temporal bounds (e.g. a {@link MemorySession}). Spatial bounds ensure that memory access operations on a memory segment cannot affect a memory location\n@@ -59,1 +59,1 @@\n- * operations on a segment cannot occur <em>after<\/em> the resource scope associated with a memory segment has been closed (see {@link ResourceScope#close()}).\n+ * operations on a segment cannot occur after the memory session associated with a memory segment has been closed (see {@link MemorySession#close()}).\n@@ -74,2 +74,2 @@\n- * be allocated using one of the many factory methods provided (see {@link MemorySegment#allocateNative(MemoryLayout, ResourceScope)},\n- * {@link MemorySegment#allocateNative(long, ResourceScope)} and {@link MemorySegment#allocateNative(long, long, ResourceScope)}). Memory segments obtained\n+ * be allocated using one of the many factory methods provided (see {@link MemorySegment#allocateNative(MemoryLayout, MemorySession)},\n+ * {@link MemorySegment#allocateNative(long, MemorySession)} and {@link MemorySegment#allocateNative(long, long, MemorySession)}). Memory segments obtained\n@@ -93,1 +93,1 @@\n- * {@link MemorySegment#mapFile(Path, long, long, FileChannel.MapMode, ResourceScope)}. Such native memory segments are\n+ * {@link MemorySegment#mapFile(Path, long, long, FileChannel.MapMode, MemorySession)}. Such native memory segments are\n@@ -105,1 +105,1 @@\n- * {@link MemoryAddress#ofLong(long)} and {@link MemorySegment#ofAddress(MemoryAddress, long, ResourceScope)}.\n+ * {@link MemoryAddress#ofLong(long)} and {@link MemorySegment#ofAddress(MemoryAddress, long, MemorySession)}.\n@@ -110,2 +110,2 @@\n- * full spatial, temporal and confinement bounds. To do this, clients can {@link #ofAddress(MemoryAddress, long, ResourceScope) obtain}\n- * a native segment <em>unsafely<\/em> from a give memory address, by providing the segment size, as well as the segment {@linkplain ResourceScope scope}.\n+ * full spatial, temporal and confinement bounds. To do this, clients can {@link #ofAddress(MemoryAddress, long, MemorySession) obtain}\n+ * a native segment <em>unsafely<\/em> from a give memory address, by providing the segment size, as well as the segment {@linkplain MemorySession session}.\n@@ -194,4 +194,3 @@\n- * Memory segments are associated with a resource scope (see {@link ResourceScope}), which can be accessed using\n- * the {@link #scope()} method. As for all resources associated with a resource scope, a segment cannot be\n- * accessed after its corresponding scope has been closed. For instance, the following code will result in an\n- * exception:\n+ * Memory segments are associated with a {@link MemorySegment#session() memory session}. As for all resources associated\n+ * with a memory session, a segment cannot be accessed after its underlying session has been closed. For instance,\n+ * the following code will result in an exception:\n@@ -200,2 +199,2 @@\n- * try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n- *     segment = MemorySegment.allocateNative(8, scope);\n+ * try (MemorySession session = MemorySession.openConfined()) {\n+ *     segment = MemorySegment.allocateNative(8, session);\n@@ -205,3 +204,3 @@\n- * Additionally, access to a memory segment is subject to the thread-confinement checks enforced by the owning scope; that is,\n- * if the segment is associated with a shared scope, it can be accessed by multiple threads; if it is associated with a confined\n- * scope, it can only be accessed by the thread which owns the scope.\n+ * Additionally, access to a memory segment is subject to the thread-confinement checks enforced by the owning memory\n+ * session; that is, if the segment is associated with a shared session, it can be accessed by multiple threads;\n+ * if it is associated with a confined session, it can only be accessed by the thread which owns the memory session.\n@@ -209,1 +208,1 @@\n- * Heap and buffer segments are always associated with a <em>global<\/em>, shared scope. This scope cannot be closed,\n+ * Heap and buffer segments are always associated with a <em>global<\/em>, shared memory session. This session cannot be closed,\n@@ -222,1 +221,1 @@\n- * Temporal bounds of the original segment are inherited by the views; that is, when the scope associated with a segment\n+ * Temporal bounds of the original segment are inherited by the views; that is, when the memory session associated with a segment\n@@ -234,1 +233,1 @@\n- * (to do this, the segment has to be associated with a shared scope). The following code can be used to sum all int\n+ * (to do this, the segment has to be associated with a shared memory session). The following code can be used to sum all int\n@@ -238,1 +237,1 @@\n- * try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+ * try (MemorySession session = MemorySession.openShared()) {\n@@ -240,1 +239,1 @@\n- *     MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT, scope);\n+ *     MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT, session);\n@@ -258,2 +257,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -273,1 +272,1 @@\n-     * are associated with the same scope as this segment.\n+     * are associated with the same memory session as this segment.\n@@ -304,1 +303,1 @@\n-     * {@return the resource scope associated with this memory segment}\n+     * {@return a non-closeable view of the memory session associated with this memory segment}\n@@ -306,1 +305,1 @@\n-    ResourceScope scope();\n+    MemorySession session();\n@@ -361,1 +360,1 @@\n-     * created using the {@link #allocateNative(long, ResourceScope)} (and related) factory, or a buffer segment\n+     * created using the {@link #allocateNative(long, MemorySession)} (and related) factory, or a buffer segment\n@@ -370,1 +369,1 @@\n-     * created using the {@link #mapFile(Path, long, long, FileChannel.MapMode, ResourceScope)} factory, or a buffer segment\n+     * created using the {@link #mapFile(Path, long, long, FileChannel.MapMode, MemorySession)} factory, or a buffer segment\n@@ -433,2 +432,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -450,3 +449,4 @@\n-     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n-     * with this segment have been already closed, or if access occurs from a thread other than the thread owning either\n-     * scopes.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code src} is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -479,3 +479,4 @@\n-     * @throws IllegalStateException if either the scope associated with this segment or the scope associated\n-     * with the {@code other} segment have been already closed, or if access occurs from a thread other than the thread\n-     * owning either scopes.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code other} is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -503,2 +504,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -518,2 +519,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -533,2 +534,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -560,2 +561,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -581,1 +582,1 @@\n-     * after the scope associated with this segment has been closed (see {@link ResourceScope#close()}), will throw an {@link IllegalStateException}.\n+     * after the memory session associated with this segment has been closed (see {@link MemorySession#close()}), will throw an {@link IllegalStateException}.\n@@ -583,1 +584,1 @@\n-     * If this segment is associated with a confined scope, calling read\/write I\/O operations on the resulting buffer\n+     * If this segment is associated with a confined memory session, calling read\/write I\/O operations on the resulting buffer\n@@ -603,2 +604,3 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link byte[]} instance,\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n+     * @throws IllegalStateException if this segment's contents cannot be copied into a {@link byte[]} instance,\n@@ -614,2 +616,3 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link short[]} instance,\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n+     * @throws IllegalStateException if this segment's contents cannot be copied into a {@link short[]} instance,\n@@ -625,2 +628,3 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link char[]} instance,\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n+     * @throws IllegalStateException if this segment's contents cannot be copied into a {@link char[]} instance,\n@@ -636,2 +640,3 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link int[]} instance,\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n+     * @throws IllegalStateException if this segment's contents cannot be copied into a {@link int[]} instance,\n@@ -647,2 +652,3 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link float[]} instance,\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n+     * @throws IllegalStateException if this segment's contents cannot be copied into a {@link float[]} instance,\n@@ -658,2 +664,3 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link long[]} instance,\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n+     * @throws IllegalStateException if this segment's contents cannot be copied into a {@link long[]} instance,\n@@ -669,2 +676,3 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link double[]} instance,\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n+     * @throws IllegalStateException if this segment's contents cannot be copied into a {@link double[]} instance,\n@@ -687,2 +695,3 @@\n-     * @throws IllegalStateException if the size of the native string is greater than the size of this segment,\n-     * or if the scope associated with this segment has been closed, or if access occurs from a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the size of the native string is greater than the size of this segment.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -705,3 +714,3 @@\n-     * @throws IllegalStateException if the size of the native string is greater than the size of this segment,\n-     * or if the scope associated with this segment has been closed, or if access occurs from a thread other than the thread owning that scope.\n-     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}.\n+     * @throws IllegalStateException if the size of the native string is greater than the size of this segment.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -720,3 +729,3 @@\n-     * {@link ByteBuffer#isReadOnly() read-only}. The scope associated with this segment can either be the\n-     * {@linkplain ResourceScope#globalScope() global} resource scope, in case the buffer has been created independently,\n-     * or some other resource scope, in case the buffer has been obtained using {@link #asByteBuffer()}.\n+     * {@link ByteBuffer#isReadOnly() read-only}. The memory session associated with this segment can either be the\n+     * {@linkplain MemorySession#global() global} memory session, in case the buffer has been created independently,\n+     * or some other memory session, in case the buffer has been obtained using {@link #asByteBuffer()}.\n@@ -735,1 +744,1 @@\n-     * The returned segment is associated with the {@linkplain ResourceScope#globalScope() global} resource scope.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n@@ -746,1 +755,1 @@\n-     * The returned segment is associated with the {@linkplain ResourceScope#globalScope() global} resource scope.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n@@ -757,1 +766,1 @@\n-     * The returned segment is associated with the {@linkplain ResourceScope#globalScope() global} resource scope.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n@@ -768,1 +777,1 @@\n-     * The returned segment is associated with the {@linkplain ResourceScope#globalScope() global} resource scope.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n@@ -779,1 +788,1 @@\n-     * The returned segment is associated with the {@linkplain ResourceScope#globalScope() global} resource scope.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n@@ -790,1 +799,1 @@\n-     * The returned segment is associated with the {@linkplain ResourceScope#globalScope() global} resource scope.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n@@ -801,1 +810,1 @@\n-     * The returned segment is associated with the {@linkplain ResourceScope#globalScope() global} resource scope.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n@@ -812,1 +821,1 @@\n-     * Creates a new native memory segment with given size and resource scope, and whose base address is the given address.\n+     * Creates a new native memory segment with given size, base address, and memory session.\n@@ -817,1 +826,1 @@\n-     * provided resource scope.\n+     * provided memory session.\n@@ -831,2 +840,2 @@\n-     * @param scope the native segment scope.\n-     * @return a new native memory segment with given base address, size and scope.\n+     * @param session the native segment memory session.\n+     * @return a new native memory segment with given base address, size and memory session.\n@@ -834,2 +843,2 @@\n-     * @throws IllegalStateException if the provided scope has been already closed,\n-     * or if access occurs from a thread other than the thread owning the scope.\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}, or if access occurs from\n+     * a thread other than the thread {@linkplain MemorySession#ownerThread() owning} {@code session}.\n@@ -841,1 +850,1 @@\n-    static MemorySegment ofAddress(MemoryAddress address, long bytesSize, ResourceScope scope) {\n+    static MemorySegment ofAddress(MemoryAddress address, long bytesSize, MemorySession session) {\n@@ -844,1 +853,1 @@\n-        Objects.requireNonNull(scope);\n+        Objects.requireNonNull(session);\n@@ -848,1 +857,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, bytesSize, (ResourceScopeImpl)scope);\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, bytesSize, Scoped.toSessionImpl(session));\n@@ -853,1 +862,1 @@\n-     * and resource scope. A client is responsible make sure that the resource scope associated with the returned segment is closed\n+     * and memory session. A client is responsible make sure that the memory session associated with the returned segment is closed\n@@ -858,1 +867,1 @@\n-     * allocateNative(layout.bytesSize(), layout.bytesAlignment(), scope);\n+     * allocateNative(layout.bytesSize(), layout.bytesAlignment(), session);\n@@ -864,1 +873,1 @@\n-     * @param scope the segment scope.\n+     * @param session the segment memory session.\n@@ -867,2 +876,2 @@\n-     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n-     * than the thread owning {@code scope}.\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}, or if access occurs from\n+     * a thread other than the thread {@linkplain MemorySession#ownerThread() owning} {@code session}.\n@@ -870,2 +879,2 @@\n-    static MemorySegment allocateNative(MemoryLayout layout, ResourceScope scope) {\n-        Objects.requireNonNull(scope);\n+    static MemorySegment allocateNative(MemoryLayout layout, MemorySession session) {\n+        Objects.requireNonNull(session);\n@@ -873,1 +882,1 @@\n-        return allocateNative(layout.byteSize(), layout.byteAlignment(), scope);\n+        return allocateNative(layout.byteSize(), layout.byteAlignment(), Scoped.toSessionImpl(session));\n@@ -878,1 +887,1 @@\n-     * and resource scope. A client is responsible make sure that the resource scope associated with the returned segment is closed\n+     * and memory session. A client is responsible make sure that the memory session associated with the returned segment is closed\n@@ -883,1 +892,1 @@\n-     * allocateNative(bytesSize, 1, scope);\n+     * allocateNative(bytesSize, 1, session);\n@@ -889,1 +898,1 @@\n-     * @param scope the segment scope.\n+     * @param session the segment temporal bounds.\n@@ -892,2 +901,2 @@\n-     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n-     * than the thread owning {@code scope}.\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}, or if access occurs from\n+     * a thread other than the thread {@linkplain MemorySession#ownerThread() owning} {@code session}.\n@@ -895,2 +904,2 @@\n-    static MemorySegment allocateNative(long bytesSize, ResourceScope scope) {\n-        return allocateNative(bytesSize, 1, scope);\n+    static MemorySegment allocateNative(long bytesSize, MemorySession session) {\n+        return allocateNative(bytesSize, 1, session);\n@@ -901,2 +910,2 @@\n-     * (in bytes), alignment constraint (in bytes) and resource scope. A client is responsible make sure that the resource\n-     * scope associated with the returned segment is closed when the segment is no longer in use.\n+     * (in bytes), alignment constraint (in bytes) and memory session. A client is responsible make sure that the memory\n+     * session associated with the returned segment is closed when the segment is no longer in use.\n@@ -909,1 +918,1 @@\n-     * @param scope the segment scope.\n+     * @param session the segment memory session.\n@@ -913,2 +922,2 @@\n-     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n-     * than the thread owning {@code scope}.\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}, or if access occurs from\n+     * a thread other than the thread {@linkplain MemorySession#ownerThread() owning} {@code session}.\n@@ -916,2 +925,2 @@\n-    static MemorySegment allocateNative(long bytesSize, long alignmentBytes, ResourceScope scope) {\n-        Objects.requireNonNull(scope);\n+    static MemorySegment allocateNative(long bytesSize, long alignmentBytes, MemorySession session) {\n+        Objects.requireNonNull(session);\n@@ -927,1 +936,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, alignmentBytes, (ResourceScopeImpl) scope);\n+        return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, alignmentBytes, Scoped.toSessionImpl(session));\n@@ -931,1 +940,2 @@\n-     * Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.\n+     * Creates a new mapped memory segment that models a memory-mapped region of a file from a given path,\n+     * size, offset and memory session.\n@@ -958,1 +968,1 @@\n-     * @param scope the segment scope.\n+     * @param session the segment memory session.\n@@ -962,2 +972,2 @@\n-     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n-     * than the thread owning {@code scope}.\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}, or if access occurs from\n+     * a thread other than the thread {@linkplain MemorySession#ownerThread() owning} {@code session}.\n@@ -971,3 +981,3 @@\n-    static MemorySegment mapFile(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode, ResourceScope scope) throws IOException {\n-        Objects.requireNonNull(scope);\n-        return MappedMemorySegmentImpl.makeMappedSegment(path, bytesOffset, bytesSize, mapMode, (ResourceScopeImpl) scope);\n+    static MemorySegment mapFile(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode, MemorySession session) throws IOException {\n+        Objects.requireNonNull(session);\n+        return MappedMemorySegmentImpl.makeMappedSegment(path, bytesOffset, bytesSize, mapMode, Scoped.toSessionImpl(session));\n@@ -999,3 +1009,4 @@\n-     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n-     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n-     * owning either scopes.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code srcSegment} is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code dstSegment} is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1041,3 +1052,4 @@\n-     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n-     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n-     * owning either scopes.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code srcSegment} is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code dstSegment} is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1073,1 +1085,1 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.scope(), dstImpl.scope(),\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n@@ -1077,1 +1089,1 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.scope(), dstImpl.scope(),\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n@@ -1090,2 +1102,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1109,2 +1121,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1129,2 +1141,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1148,2 +1160,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1168,2 +1180,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1187,2 +1199,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1207,2 +1219,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1226,2 +1238,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1246,2 +1258,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1265,2 +1277,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1285,2 +1297,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1304,2 +1316,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1324,2 +1336,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1343,2 +1355,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1363,2 +1375,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1382,2 +1394,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1402,2 +1414,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1421,2 +1433,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1441,2 +1453,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1463,2 +1475,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1486,2 +1498,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1508,2 +1520,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1531,2 +1543,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1553,2 +1565,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1576,2 +1588,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1598,2 +1610,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1621,2 +1633,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1643,2 +1655,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1666,2 +1678,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1688,2 +1700,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1711,2 +1723,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1733,2 +1745,2 @@\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1761,0 +1773,2 @@\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code srcSegment} is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1787,1 +1801,1 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.scope(), null,\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), null,\n@@ -1791,1 +1805,1 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.scope(), null,\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), null,\n@@ -1808,0 +1822,2 @@\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code dstSegment} is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -1834,1 +1850,1 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(null, destImpl.scope(),\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(null, destImpl.sessionImpl(),\n@@ -1838,1 +1854,1 @@\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(null, destImpl.scope(),\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(null, destImpl.sessionImpl(),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":208,"deletions":192,"binary":false,"changes":400,"status":"modified"},{"patch":"@@ -0,0 +1,258 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.foreign;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.ref.Cleaner;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+\n+import jdk.internal.foreign.MemorySessionImpl;\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A memory session manages the lifecycle of one or more resources. Resources (e.g. {@link MemorySegment}) associated\n+ * with a memory session can only be accessed while the memory session is {@linkplain #isAlive() alive},\n+ * and by the {@linkplain #ownerThread() thread} associated with the memory session (if any).\n+ * <p>\n+ * Memory sessions can be closed, either implicitly (e.g. when a session is no longer reachable), or explicitly.\n+ * When a memory session is closed, it is no longer {@link #isAlive() alive}, and subsequent operations on resources\n+ * associated with that session (e.g. attempting to access a {@link MemorySegment} instance) will fail with {@link IllegalStateException}.\n+ * <p>\n+ * When a memory session is closed (either explicitly, or implicitly), all the {@linkplain #addCloseAction(Runnable) close actions} associated with that session will be called.\n+ * and underlying memory resources associated with said session might be released; for instance:\n+ * <ul>\n+ *     <li>closing the memory session associated with a {@linkplain MemorySegment#allocateNative(long, long, MemorySession) native memory segment}\n+ *     results in <em>freeing<\/em> the native memory associated with it;<\/li>\n+ *     <li>closing the memory session associated with a {@linkplain MemorySegment#mapFile(Path, long, long, FileChannel.MapMode, MemorySession) mapped memory segment}\n+ *     results in the backing memory-mapped file to be unmapped;<\/li>\n+ *     <li>closing the memory session associated with an {@linkplain CLinker#upcallStub(MethodHandle, FunctionDescriptor, MemorySession) upcall stub}\n+ *     results in releasing the stub;<\/li>\n+ *     <li>closing the memory session associated with a {@linkplain VaList variable arity list} results in releasing the memory\n+ *     associated with that variable arity list instance.<\/li>\n+ * <\/ul>\n+ *\n+ * <h2><a id = \"thread-confinement\">Thread confinement<\/a><\/h2>\n+ *\n+ * Memory sessions can be divided into two categories: <em>thread-confined<\/em> memory sessions, and <em>shared<\/em>\n+ * memory sessions.\n+ * <p>\n+ * Confined memory sessions, support strong thread-confinement guarantees. Upon creation,\n+ * they are assigned an {@linkplain #ownerThread() owner thread}, typically the thread which initiated the creation operation.\n+ * After creating a confined memory session, only the owner thread will be allowed to directly manipulate the resources\n+ * associated with this memory session. Any attempt to perform resource access from a thread other than the\n+ * owner thread will result in a runtime failure.\n+ * <p>\n+ * Shared memory sessions, on the other hand, have no owner thread; as such, resources associated with shared memory sessions\n+ * can be accessed by multiple threads. This might be useful when multiple threads need to access the same resource concurrently\n+ * (e.g. in the case of parallel processing).\n+ *\n+ * <h2>Deterministic deallocation<\/h2>\n+ *\n+ * When a session is associated with off-heap resources, it is often desirable for said resources to be released in a timely fashion,\n+ * rather than waiting for the session to be deemed <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>\n+ * by the garbage collector. In this scenario, a client might consider using a {@linkplain #isCloseable() <em>closeable<\/em>} memory session.\n+ * Closeable memory sessions are memory sessions that can be {@link MemorySession#close() closed} explicitly, as demonstrated\n+ * in the following example:\n+ *\n+ * {@snippet lang=java :\n+ * try (MemorySession session = MemorySession.openConfined()) {\n+ *    MemorySegment segment1 = MemorySegment.allocateNative(100);\n+ *    MemorySegment segment1 = MemorySegment.allocateNative(200);\n+ *    ...\n+ * } \/\/ all memory released here\n+ * }\n+ *\n+ * The above code creates a confined, closeable session. Then it allocates two segments associated with that session.\n+ * When the session is {@linkplain #close() closed} (above, this is done implicitly, using the <em>try-with-resources construct<\/em>),\n+ * all memory allocated within the session will be released\n+ * <p>\n+ * Closeable memory sessions, while powerful, must be used with caution. Clients must remember to\n+ * {@linkplain MemorySession#close() close} a closeable memory session explicitly, when the session\n+ * is no longer in use. A failure to do so might result in memory leaks. To mitigate this problem,\n+ * closeable memory sessions can be associated with a {@link Cleaner} instance, so that they are also closed automatically,\n+ * once the session instance becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n+ * This can be useful to allow for predictable, deterministic resource deallocation, while still preventing accidental\n+ * native memory leaks. In case a managed memory session is closed explicitly, no further action will be taken when\n+ * the session becomes unreachable; that is, {@linkplain #addCloseAction(Runnable) close actions} associated with a\n+ * memory session, whether managed or not, are called <em>exactly once<\/em>.\n+ *\n+ * <h2><a id = \"global-session\">Global session<\/a><\/h2>\n+ *\n+ * An important memory session is the so called {@linkplain #global() global session}; the global session is\n+ * a memory session that cannot be closed, either explicitly or implicitly. As a result, the global session will never\n+ * attempt to release resources associated with it. Examples of resources associated with the global memory session are\n+ * {@linkplain MemorySegment#ofArray(int[]) heap segments}.\n+ *\n+ * @implSpec\n+ * Implementations of this interface are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ *\n+ * @since 19\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+public sealed interface MemorySession extends AutoCloseable, SegmentAllocator permits MemorySessionImpl, MemorySessionImpl.NonCloseableView {\n+\n+    \/**\n+     * {@return {@code true}, if this memory session is alive}\n+     *\/\n+    boolean isAlive();\n+\n+    \/**\n+     * {@return {@code true}, if this session can be {@linkplain #close() closed} explicitly}\n+     *\/\n+    boolean isCloseable();\n+\n+    \/**\n+     * {@return the owner thread associated with this memory session (if any)}\n+     *\/\n+    Thread ownerThread();\n+\n+    \/**\n+     * Run a critical action while this memory session is kept alive.\n+     * @param action the action to be run.\n+     *\/\n+    void whileAlive(Runnable action);\n+\n+    \/**\n+     * Add a custom cleanup action which will be executed when the memory session is closed.\n+     * The order in which custom cleanup actions are invoked once the memory session is closed is unspecified.\n+     * @apiNote The provided action should not keep a strong reference to this memory session, so that implicitly\n+     * closed sessions can be handled correctly by a {@link Cleaner} instance.\n+     * @param runnable the custom cleanup action to be associated with this memory session.\n+     * @throws IllegalStateException if this memory session is not {@linkplain #isAlive() alive}, or if access occurs from\n+     * a thread other than the thread {@linkplain #ownerThread() owning} this memory session.\n+     *\/\n+    void addCloseAction(Runnable runnable);\n+\n+    \/**\n+     * Closes this memory session. As a side effect, if this operation completes without exceptions, this session\n+     * will be marked as <em>not alive<\/em>, the {@linkplain #addCloseAction(Runnable) close actions} associated\n+     * with this session will be executed, and all the resources associated with this session will be released.\n+     *\n+     * @apiNote This operation is not idempotent; that is, closing an already closed memory session <em>always<\/em> results in an\n+     * exception being thrown. This reflects a deliberate design choice: memory session state transitions should be\n+     * manifest in the client code; a failure in any of these transitions reveals a bug in the underlying application\n+     * logic.\n+     *\n+     * @see MemorySession#isAlive()\n+     *\n+     * @throws IllegalStateException if this memory session is not {@linkplain #isAlive() alive}, or if access occurs from\n+     * a thread other than the thread {@linkplain #ownerThread() owning} this memory session.\n+     * @throws IllegalStateException this memory session is shared and a resource associated with this session is accessed while this method is called.\n+     * @throws UnsupportedOperationException if this memory session is not {@linkplain #isCloseable() closeable}.\n+     *\/\n+    void close();\n+\n+    \/**\n+     * Compares the specified object with this memory session for equality. Returns {@code true} if and only if the specified\n+     * object is also a memory session, and it refers to the same memory session as this memory session. This method\n+     * is especially useful when operating on non-closeable views of memory sessions, such as the ones returned\n+     * by {@link MemorySegment#session()}.\n+     *\n+     * @param that the object to be compared for equality with this memory session.\n+     * @return {@code true} if the specified object is equal to this memory session.\n+     *\/\n+    @Override\n+    boolean equals(Object that);\n+\n+    \/**\n+     * {@return the hash code value for this memory session}\n+     *\/\n+    @Override\n+    int hashCode();\n+\n+    \/**\n+     * Allocates a new native segment, using this session. Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * MemorySegment.allocateNative(size, align, this);\n+     * }\n+     *\n+     * @throws IllegalStateException if this memory session is not {@linkplain #isAlive() alive}, or if access occurs from\n+     * a thread other than the thread {@linkplain #ownerThread() owning} this memory session.\n+     * @return a new native segment, associated with this session.\n+     *\/\n+    @Override\n+    default MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+        return MemorySegment.allocateNative(bytesSize, bytesAlignment, this);\n+    }\n+\n+    \/**\n+     * Creates a new closeable confined memory session.\n+     * @return a new closeable confined memory session.\n+     *\/\n+    static MemorySession openConfined() {\n+        return MemorySessionImpl.createConfined(Thread.currentThread(), null);\n+    }\n+\n+    \/**\n+     * Creates a new closeable confined memory session, managed by the provided cleaner instance.\n+     * @param cleaner the cleaner to be associated with the returned memory session.\n+     * @return a new closeable confined memory session, managed by {@code cleaner}.\n+     *\/\n+    static MemorySession openConfined(Cleaner cleaner) {\n+        Objects.requireNonNull(cleaner);\n+        return MemorySessionImpl.createConfined(Thread.currentThread(), cleaner);\n+    }\n+\n+    \/**\n+     * Creates a new closeable shared memory session.\n+     * @return a new closeable shared memory session.\n+     *\/\n+    static MemorySession openShared() {\n+        return MemorySessionImpl.createShared(null);\n+    }\n+\n+    \/**\n+     * Creates a new closeable shared memory session, managed by the provided cleaner instance.\n+     * @param cleaner the cleaner to be associated with the returned memory session.\n+     * @return a new closeable shared memory session, managed by {@code cleaner}.\n+     *\/\n+    static MemorySession openShared(Cleaner cleaner) {\n+        Objects.requireNonNull(cleaner);\n+        return MemorySessionImpl.createShared(cleaner);\n+    }\n+\n+    \/**\n+     * Creates a new non-closeable shared memory session, managed by a private {@link Cleaner} instance.\n+     * Equivalent to (but likely more efficient than) the following code:\n+     * {@snippet lang=java :\n+     * openShared(Cleaner.create());\n+     * }\n+     * @return a non-closeable shared memory session, managed by a private {@link Cleaner} instance.\n+     *\/\n+    static MemorySession openImplicit() {\n+        return MemorySessionImpl.createImplicit();\n+    }\n+\n+    \/**\n+     * Returns the <a href=\"MemorySession.html#global-session\"><em>global memory session<\/em><\/a>.\n+     * @return the <a href=\"MemorySession.html#global-session\"><em>global memory session<\/em><\/a>.\n+     *\/\n+    static MemorySession global() {\n+        return MemorySessionImpl.GLOBAL;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySession.java","additions":258,"deletions":0,"binary":false,"changes":258,"status":"added"},{"patch":"@@ -30,0 +30,2 @@\n+\n+import jdk.internal.foreign.Scoped;\n@@ -37,1 +39,1 @@\n- * A native symbol has a name, and is associated with a scope, which governs the native symbol's lifecycle.\n+ * A native symbol has a name, and is associated with a memory session, which governs the native symbol's lifecycle.\n@@ -40,1 +42,1 @@\n- * <em>anonymous<\/em> native symbol, in the form of an {@linkplain CLinker#upcallStub(MethodHandle, FunctionDescriptor, ResourceScope) upcall stub},\n+ * <em>anonymous<\/em> native symbol, in the form of an {@linkplain CLinker#upcallStub(MethodHandle, FunctionDescriptor, MemorySession) upcall stub},\n@@ -53,5 +55,0 @@\n-    \/**\n-     * {@return the resource scope associated with this symbol}\n-     *\/\n-    ResourceScope scope();\n-\n@@ -60,2 +57,2 @@\n-     * @throws IllegalStateException if the scope associated with this symbol has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this native symbol is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -67,1 +64,6 @@\n-     * Creates a new symbol from given name, address and scope.\n+     * {@return a non-closeable view of the memory session associated with this native symbol}\n+     *\/\n+    MemorySession session();\n+\n+    \/**\n+     * Creates a new symbol from given name, address and memory session.\n@@ -75,2 +77,4 @@\n-     * @param scope the symbol scope.\n-     * @return A new symbol from given name, address and scope.\n+     * @param session the symbol memory session.\n+     * @return A new symbol from given name, address and memory session.\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}, or if access occurs from\n+     * a thread other than the thread {@linkplain MemorySession#ownerThread() owning} {@code session}.\n@@ -82,1 +86,1 @@\n-    static NativeSymbol ofAddress(String name, MemoryAddress address, ResourceScope scope) {\n+    static NativeSymbol ofAddress(String name, MemoryAddress address, MemorySession session) {\n@@ -86,2 +90,2 @@\n-        Objects.requireNonNull(scope);\n-        return new NativeSymbolImpl(name, address, scope);\n+        Objects.requireNonNull(session);\n+        return new NativeSymbolImpl(name, address, Scoped.toSessionImpl(session));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/NativeSymbol.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1,259 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.foreign;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.ref.Cleaner;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.FileChannel;\n-import java.nio.file.Path;\n-import java.util.Objects;\n-import java.util.Spliterator;\n-import jdk.internal.foreign.ResourceScopeImpl;\n-import jdk.internal.javac.PreviewFeature;\n-import jdk.internal.ref.CleanerFactory;\n-\n-\/**\n- * A resource scope manages the lifecycle of one or more resources. Resources (e.g. {@link MemorySegment}) associated\n- * with a resource scope can only be accessed while the resource scope is {@linkplain #isAlive() alive},\n- * and by the {@linkplain #ownerThread() thread} associated with the resource scope (if any).\n- *\n- * <h2>Deterministic deallocation<\/h2>\n- *\n- * Resource scopes support <em>deterministic deallocation<\/em>; that is, they can be {@linkplain ResourceScope#close() closed}\n- * explicitly. When a resource scope is closed, it is no longer {@link #isAlive() alive}, and subsequent\n- * operations on resources associated with that scope (e.g. attempting to access a {@link MemorySegment} instance)\n- * will fail with {@link IllegalStateException}.\n- * <p>\n- * Closing a resource scope will cause all the {@linkplain #addCloseAction(Runnable) close actions} associated with that scope to be called.\n- * Moreover, closing a resource scope might trigger the releasing of the underlying memory resources associated with said scope; for instance:\n- * <ul>\n- *     <li>closing the scope associated with a {@linkplain MemorySegment#allocateNative(long, long, ResourceScope) native memory segment}\n- *     results in <em>freeing<\/em> the native memory associated with it;<\/li>\n- *     <li>closing the scope associated with a {@linkplain MemorySegment#mapFile(Path, long, long, FileChannel.MapMode, ResourceScope) mapped memory segment}\n- *     results in the backing memory-mapped file to be unmapped;<\/li>\n- *     <li>closing the scope associated with an {@linkplain CLinker#upcallStub(MethodHandle, FunctionDescriptor, ResourceScope) upcall stub}\n- *     results in releasing the stub;<\/li>\n- *     <li>closing the scope associated with a {@linkplain VaList variable arity list} results in releasing the memory\n- *     associated with that variable arity list instance.<\/li>\n- * <\/ul>\n- *\n- * <h2>Implicit deallocation<\/h2>\n- *\n- * Resource scopes can be associated with a {@link Cleaner} instance, so that they are also closed automatically,\n- * once the scope instance becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n- * This can be useful to allow for predictable, deterministic resource deallocation, while still preventing accidental\n- * native memory leaks. In case a managed resource scope is closed explicitly, no further action will be taken when\n- * the scope becomes unreachable; that is, {@linkplain #addCloseAction(Runnable) close actions} associated with a\n- * resource scope, whether managed or not, are called <em>exactly once<\/em>.\n- *\n- * <h2><a id = \"global-scope\">Global scope<\/a><\/h2>\n- *\n- * An important implicit resource scope is the so called {@linkplain #globalScope() global scope}; the global scope is\n- * a resource scope that cannot be closed, either explicitly or implicitly. As a result, the global scope will never\n- * attempt to release resources associated with it. Examples of resources associated with the global scope are:\n- * <ul>\n- *     <li>heap segments created from {@linkplain MemorySegment#ofArray(int[]) arrays} or\n- *     {@linkplain MemorySegment#ofByteBuffer(ByteBuffer) buffers};<\/li>\n- *     <li>variable arity lists {@linkplain VaList#ofAddress(MemoryAddress, ResourceScope) obtained} from raw memory addresses;\n- *     <li>native symbols obtained from {@linkplain ClassLoader#findNative(String)}, or from {@link CLinker#lookup(String)}.<\/li>\n- * <\/ul>\n- * In other words, the global scope is used to indicate that the lifecycle of one or more resources must, where\n- * needed, be managed independently by clients.\n- *\n- * <h2><a id = \"thread-confinement\">Thread confinement<\/a><\/h2>\n- *\n- * Resource scopes can be divided into two categories: <em>thread-confined<\/em> resource scopes, and <em>shared<\/em>\n- * resource scopes.\n- * <p>\n- * {@linkplain #newConfinedScope() Confined resource scopes}, support strong thread-confinement guarantees. Upon creation,\n- * they are assigned an {@linkplain #ownerThread() owner thread}, typically the thread which initiated the creation operation.\n- * After creating a confined resource scope, only the owner thread will be allowed to directly manipulate the resources\n- * associated with this resource scope. Any attempt to perform resource access from a thread other than the\n- * owner thread will result in a runtime failure.\n- * <p>\n- * {@linkplain #newSharedScope() Shared resource scopes}, on the other hand, have no owner thread;\n- * as such, resources associated with shared resource scopes can be accessed by multiple threads.\n- * This might be useful when multiple threads need to access the same resource concurrently (e.g. in the case of parallel processing).\n- * For instance, a client might obtain a {@link Spliterator} from a segment backed by a shared scope, which can then be used to slice the\n- * segment and allow multiple threads to work in parallel on disjoint segment slices. The following code can be used to sum\n- * all int values in a memory segment in parallel:\n- *\n- * {@snippet lang=java :\n- * try (ResourceScope scope = ResourceScope.newSharedScope()) {\n- *     SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_INT);\n- *     MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT, scope);\n- *     int sum = segment.elements(ValueLayout.JAVA_INT).parallel()\n- *                      .mapToInt(s -> s.get(ValueLayout.JAVA_INT, 0))\n- *                      .sum();\n- * }\n- * }\n- *\n- * <p>\n- * Shared resource scopes, while powerful, must be used with caution: if one or more threads accesses\n- * a resource associated with a shared scope while the scope is being closed from another thread, an exception might occur on both\n- * the accessing and the closing threads. Clients should refrain from attempting to close a shared resource scope repeatedly\n- * (e.g. keep calling {@link #close()} until no exception is thrown). Instead, clients of shared resource scopes\n- * should always ensure that proper synchronization mechanisms (e.g. using temporal dependencies, see below) are put in place\n- * so that threads closing shared resource scopes can never race against threads accessing resources managed by same scopes.\n- *\n- * <h2>Temporal dependencies<\/h2>\n- *\n- * Resource scopes can depend on each other. More specifically, a scope can feature\n- * {@linkplain #keepAlive(ResourceScope) temporal dependencies} on one or more other resource scopes.\n- * Such a resource scope cannot be closed (either implicitly or explicitly) until <em>all<\/em> the scopes it depends on\n- * have also been closed.\n- * <p>\n- * This can be useful when clients need to perform a critical operation on a memory segment, during which they have\n- * to ensure that the scope associated with that segment will not be closed; this can be done as follows:\n- *\n- * {@snippet lang=java :\n- * MemorySegment segment = ...\n- * try (ResourceScope criticalScope = ResourceScope.newConfinedScope()) {\n- *     criticalScope.keepAlive(segment.scope());\n- *     <critical operation on segment>\n- * }\n- * }\n- *\n- * Note that a resource scope does not become <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>\n- * until all the scopes it depends on have been closed.\n- *\n- * @implSpec\n- * Implementations of this interface are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n- *\n- * @since 19\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-public sealed interface ResourceScope extends AutoCloseable permits ResourceScopeImpl {\n-    \/**\n-     * {@return {@code true}, if this resource scope is alive}\n-     * @see ResourceScope#close()\n-     *\/\n-    boolean isAlive();\n-\n-    \/**\n-     * The thread owning this resource scope.\n-     * @return the thread owning this resource scope, or {@code null} if this resource scope is shared.\n-     *\/\n-    Thread ownerThread();\n-\n-    \/**\n-     * Closes this resource scope. As a side effect, if this operation completes without exceptions, this scope will be marked\n-     * as <em>not alive<\/em>, and subsequent operations on resources associated with this scope will fail with {@link IllegalStateException}.\n-     * Additionally, upon successful closure, all native resources associated with this resource scope will be released.\n-     *\n-     * @apiNote This operation is not idempotent; that is, closing an already closed resource scope <em>always<\/em> results in an\n-     * exception being thrown. This reflects a deliberate design choice: resource scope state transitions should be\n-     * manifest in the client code; a failure in any of these transitions reveals a bug in the underlying application\n-     * logic.\n-     *\n-     * @throws IllegalStateException if one of the following condition is met:\n-     * <ul>\n-     *     <li>this resource scope is not <em>alive<\/em>\n-     *     <li>this resource scope is confined, and this method is called from a thread other than the thread owning this resource scope<\/li>\n-     *     <li>this resource scope is shared and a resource associated with this scope is accessed while this method is called<\/li>\n-     *     <li>one or more scopes which {@linkplain #keepAlive(ResourceScope) depend} on this resource scope have not been closed.\n-     * <\/ul>\n-     * @throws UnsupportedOperationException if this resource scope is the {@linkplain #globalScope() global scope}.\n-     *\/\n-    void close();\n-\n-    \/**\n-     * Add a custom cleanup action which will be executed when the resource scope is closed.\n-     * The order in which custom cleanup actions are invoked once the scope is closed is unspecified.\n-     * @param runnable the custom cleanup action to be associated with this scope.\n-     * @throws IllegalStateException if this scope has been closed, or if access occurs from\n-     * a thread other than the thread owning this scope.\n-     *\/\n-    void addCloseAction(Runnable runnable);\n-\n-    \/**\n-     * Creates a temporal dependency between this scope and the target scope. As a result, the target scope cannot\n-     * be {@linkplain #close() closed} <em>before<\/em> this scope.\n-     * @implNote A given scope can support up to {@link Integer#MAX_VALUE} pending keep alive requests.\n-     * @param target the scope that needs to be kept alive.\n-     * @throws IllegalArgumentException if {@code target == this}.\n-     * @throws IllegalStateException if this scope or {@code target} have been closed, or if access occurs from\n-     * a thread other than the thread owning this scope or {@code target}.\n-     *\/\n-    void keepAlive(ResourceScope target);\n-\n-    \/**\n-     * Creates a new confined scope.\n-     * @return a new confined scope.\n-     *\/\n-    static ResourceScope newConfinedScope() {\n-        return ResourceScopeImpl.createConfined(Thread.currentThread(), null);\n-    }\n-\n-    \/**\n-     * Creates a new confined scope, managed by the provided cleaner instance.\n-     * @param cleaner the cleaner to be associated with the returned scope.\n-     * @return a new confined scope, managed by {@code cleaner}.\n-     *\/\n-    static ResourceScope newConfinedScope(Cleaner cleaner) {\n-        Objects.requireNonNull(cleaner);\n-        return ResourceScopeImpl.createConfined(Thread.currentThread(), cleaner);\n-    }\n-\n-    \/**\n-     * Creates a new shared scope.\n-     * @return a new shared scope.\n-     *\/\n-    static ResourceScope newSharedScope() {\n-        return ResourceScopeImpl.createShared(null);\n-    }\n-\n-    \/**\n-     * Creates a new shared scope, managed by the provided cleaner instance.\n-     * @param cleaner the cleaner to be associated with the returned scope.\n-     * @return a new shared scope, managed by {@code cleaner}.\n-     *\/\n-    static ResourceScope newSharedScope(Cleaner cleaner) {\n-        Objects.requireNonNull(cleaner);\n-        return ResourceScopeImpl.createShared(cleaner);\n-    }\n-\n-    \/**\n-     * Creates a new shared scope, managed by a private {@link Cleaner} instance. Equivalent to (but likely more efficient than)\n-     * the following code:\n-     * {@snippet lang=java :\n-     * newSharedScope(Cleaner.create());\n-     * }\n-     * @return a shared scope, managed by a private {@link Cleaner} instance.\n-     *\/\n-    static ResourceScope newImplicitScope() {\n-        return newSharedScope(CleanerFactory.cleaner());\n-    }\n-\n-    \/**\n-     * Returns the <a href=\"ResourceScope.html#global-scope\"><em>global scope<\/em><\/a>.\n-     * @return the <a href=\"ResourceScope.html#global-scope\"><em>global scope<\/em><\/a>.\n-     *\/\n-    static ResourceScope globalScope() {\n-        return ResourceScopeImpl.GLOBAL;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ResourceScope.java","additions":0,"deletions":259,"binary":false,"changes":259,"status":"deleted"},{"patch":"@@ -36,1 +36,1 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.Scoped;\n@@ -45,1 +45,1 @@\n- * {@linkplain MemorySegment#allocateNative(long, long, ResourceScope) creating} native segments;\n+ * {@linkplain MemorySegment#allocateNative(long, long, MemorySession) creating} native segments;\n@@ -51,3 +51,1 @@\n- *     <li>{@link #nativeAllocator(ResourceScope)} creates an allocator which\n- *     {@linkplain MemorySegment#allocateNative(long, long, ResourceScope) allocates} native segments, backed by a given scope;<\/li>\n- *     <li>{@link #newNativeArena(ResourceScope)} creates a more efficient arena-style native allocator, where memory\n+ *     <li>{@link #newNativeArena(MemorySession)} creates a more efficient arena-style native allocator, where memory\n@@ -342,1 +340,1 @@\n-     * associated with the provided scope. Equivalent to the following code:\n+     * associated with the provided memory session. Equivalent to the following code:\n@@ -344,1 +342,1 @@\n-     * SegmentAllocator.newNativeArena(Long.MAX_VALUE, predefinedBlockSize, scope);\n+     * SegmentAllocator.newNativeArena(Long.MAX_VALUE, predefinedBlockSize, session);\n@@ -347,1 +345,1 @@\n-     * @param scope the scope associated with the segments returned by the arena-based allocator.\n+     * @param session the memory session associated with the segments returned by the arena-based allocator.\n@@ -349,2 +347,2 @@\n-     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n-     * than the thread owning {@code scope}.\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}, or if access occurs from\n+     * a thread other than the thread {@linkplain MemorySession#ownerThread() owning} {@code session}.\n@@ -352,2 +350,2 @@\n-    static SegmentAllocator newNativeArena(ResourceScope scope) {\n-        return newNativeArena(Long.MAX_VALUE, ArenaAllocator.DEFAULT_BLOCK_SIZE, scope);\n+    static SegmentAllocator newNativeArena(MemorySession session) {\n+        return newNativeArena(Long.MAX_VALUE, ArenaAllocator.DEFAULT_BLOCK_SIZE, session);\n@@ -358,1 +356,1 @@\n-     * the provided scope, with given arena size. Equivalent to the following code:\n+     * the provided memory session, with given arena size. Equivalent to the following code:\n@@ -360,1 +358,1 @@\n-     * SegmentAllocator.newNativeArena(arenaSize, arenaSize, scope);\n+     * SegmentAllocator.newNativeArena(arenaSize, arenaSize, session);\n@@ -364,1 +362,1 @@\n-     * @param scope the scope associated with the segments returned by the arena-based allocator.\n+     * @param session the memory session associated with the segments returned by the arena-based allocator.\n@@ -367,2 +365,2 @@\n-     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n-     * than the thread owning {@code scope}.\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}, or if access occurs from\n+     * a thread other than the thread {@linkplain MemorySession#ownerThread() owning} {@code session}.\n@@ -370,2 +368,2 @@\n-    static SegmentAllocator newNativeArena(long arenaSize, ResourceScope scope) {\n-        return newNativeArena(arenaSize, arenaSize, scope);\n+    static SegmentAllocator newNativeArena(long arenaSize, MemorySession session) {\n+        return newNativeArena(arenaSize, arenaSize, session);\n@@ -375,1 +373,2 @@\n-     * Returns a native arena-based allocator, associated with the provided scope, with given arena size and block size.\n+     * Returns a native arena-based allocator, associated with the provided memory session,\n+     * with given arena size and block size.\n@@ -377,1 +376,1 @@\n-     * The returned allocator {@linkplain MemorySegment#allocateNative(long, ResourceScope) allocates} a memory segment\n+     * The returned allocator {@linkplain MemorySegment#allocateNative(long, MemorySession) allocates} a memory segment\n@@ -398,1 +397,1 @@\n-     * @param scope the scope associated with the segments returned by the arena-based allocator.\n+     * @param session the memory session associated with the segments returned by the arena-based allocator.\n@@ -401,2 +400,2 @@\n-     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n-     * than the thread owning {@code scope}.\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}, or if access occurs from\n+     * a thread other than the thread {@linkplain MemorySession#ownerThread() owning} {@code session}.\n@@ -404,2 +403,2 @@\n-    static SegmentAllocator newNativeArena(long arenaSize, long blockSize, ResourceScope scope) {\n-        Objects.requireNonNull(scope);\n+    static SegmentAllocator newNativeArena(long arenaSize, long blockSize, MemorySession session) {\n+        Objects.requireNonNull(session);\n@@ -412,1 +411,1 @@\n-        return new ArenaAllocator(blockSize, arenaSize, scope);\n+        return new ArenaAllocator(blockSize, arenaSize, Scoped.toSessionImpl(session));\n@@ -441,17 +440,1 @@\n-     * Returns a native allocator, associated with the provided scope. Equivalent to (but likely more efficient than)\n-     * the following code:\n-     * {@snippet lang=java :\n-     * ResourceScope scope = ...\n-     * SegmentAllocator nativeAllocator = (size, align) -> MemorySegment.allocateNative(size, align, scope);\n-     * }\n-     *\n-     * @param scope the scope associated with the returned allocator.\n-     * @return a native allocator, associated with the provided scope.\n-     *\/\n-    static SegmentAllocator nativeAllocator(ResourceScope scope) {\n-        Objects.requireNonNull(scope);\n-        return (ResourceScopeImpl)scope;\n-    }\n-\n-    \/**\n-     * Returns a native allocator which allocates segments in independent {@linkplain ResourceScope#newImplicitScope() implicit scopes}.\n+     * Returns a native allocator which allocates segments in independent {@linkplain MemorySession#openImplicit() implicit memory sessions}.\n@@ -460,1 +443,1 @@\n-     * SegmentAllocator implicitAllocator = (size, align) -> MemorySegment.allocateNative(size, align, ResourceScope.newImplicitScope());\n+     * SegmentAllocator implicitAllocator = (size, align) -> MemorySegment.allocateNative(size, align, MemorySession.openImplicit());\n@@ -463,1 +446,1 @@\n-     * @return a native allocator which allocates segments in independent {@linkplain ResourceScope#newImplicitScope() implicit scopes}.\n+     * @return a native allocator which allocates segments in independent {@linkplain MemorySession#openImplicit() implicit memory sessions}.\n@@ -468,1 +451,1 @@\n-                    MemorySegment.allocateNative(size, align, ResourceScope.newImplicitScope());\n+                    MemorySegment.allocateNative(size, align, MemorySession.openImplicit());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":30,"deletions":47,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+\n+import jdk.internal.foreign.Scoped;\n@@ -54,1 +56,1 @@\n- * (regardless of the scope associated with the variable arity list).\n+ * (regardless of the memory session associated with the variable arity list).\n@@ -64,0 +66,5 @@\n+    \/**\n+     * {@return a non-closeable view of the memory session associated with this variable argument list}\n+     *\/\n+    MemorySession session();\n+\n@@ -70,2 +77,2 @@\n-     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this variable argument list is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -81,2 +88,2 @@\n-     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this variable argument list is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -92,2 +99,2 @@\n-     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this variable argument list is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -103,2 +110,2 @@\n-     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this variable argument list is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -123,2 +130,2 @@\n-     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this variable argument list is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -132,2 +139,2 @@\n-     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this variable argument list is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -137,5 +144,0 @@\n-    \/**\n-     * {@return the resource scope associated with this variable argument list}\n-     *\/\n-    ResourceScope scope();\n-\n@@ -144,1 +146,1 @@\n-     * with the same scope as this variable argument list. The behavior of this method is equivalent to the C\n+     * with the same memory session as this variable argument list. The behavior of this method is equivalent to the C\n@@ -152,2 +154,2 @@\n-     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this variable argument list is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -159,2 +161,2 @@\n-     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this variable argument list is not\n+     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n@@ -167,1 +169,1 @@\n-     * with given resource scope.\n+     * with given memory session.\n@@ -175,1 +177,1 @@\n-     * @param scope the resource scope to be associated with the returned variable argument list.\n+     * @param session the memory session to be associated with the returned variable argument list.\n@@ -177,2 +179,2 @@\n-     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n-     * than the thread owning {@code scope}.\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}, or if access occurs from\n+     * a thread other than the thread {@linkplain MemorySession#ownerThread() owning} {@code session}.\n@@ -184,1 +186,1 @@\n-    static VaList ofAddress(MemoryAddress address, ResourceScope scope) {\n+    static VaList ofAddress(MemoryAddress address, MemorySession session) {\n@@ -187,2 +189,2 @@\n-        Objects.requireNonNull(scope);\n-        return SharedUtils.newVaListOfAddress(address, scope);\n+        Objects.requireNonNull(session);\n+        return SharedUtils.newVaListOfAddress(address, Scoped.toSessionImpl(session));\n@@ -192,1 +194,2 @@\n-     * Constructs a new variable argument list using a builder (see {@link Builder}), with a given resource scope.\n+     * Constructs a new variable argument list using a builder (see {@link Builder}), with given\n+     * memory session.\n@@ -195,1 +198,1 @@\n-     * {@linkplain ResourceScope resource scope}, and will be released when the resource scope is {@linkplain ResourceScope#close closed}.\n+     * memory session, and will be released when the memory session is {@linkplain MemorySession#close closed}.\n@@ -202,1 +205,1 @@\n-     * @param scope scope the scope to be associated with the new variable arity list.\n+     * @param session the memory session to be associated with the new variable arity list.\n@@ -204,2 +207,2 @@\n-     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n-     * than the thread owning {@code scope}.\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}, or if access occurs from\n+     * a thread other than the thread {@linkplain MemorySession#ownerThread() owning} {@code session}.\n@@ -207,1 +210,1 @@\n-    static VaList make(Consumer<Builder> actions, ResourceScope scope) {\n+    static VaList make(Consumer<Builder> actions, MemorySession session) {\n@@ -209,2 +212,2 @@\n-        Objects.requireNonNull(scope);\n-        return SharedUtils.newVaList(actions, scope);\n+        Objects.requireNonNull(session);\n+        return SharedUtils.newVaList(actions, Scoped.toSessionImpl(session));\n@@ -214,3 +217,3 @@\n-     * Returns an empty variable argument list, associated with the {@linkplain ResourceScope#globalScope() global}\n-     * scope. The resulting variable argument list does not contain any argument, and throws {@link UnsupportedOperationException}\n-     * on all operations, except for {@link #scope()}, {@link #copy()} and {@link #address()}.\n+     * Returns an empty variable argument list, associated with the {@linkplain MemorySession#global() global}\n+     * memory session. The resulting variable argument list does not contain any argument, and throws {@link UnsupportedOperationException}\n+     * on all operations, except for {@link VaList#address()}, {@link VaList#copy()} and {@link VaList#session()}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/VaList.java","additions":44,"deletions":41,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n- * MemorySegment segment = MemorySegment.allocateNative(10 * 4, ResourceScope.newImplicitScope());\n+ * MemorySegment segment = MemorySegment.allocateNative(10 * 4, MemorySession.openImplicit());\n@@ -70,1 +70,1 @@\n- * with a memory segment. This can be done, using the {@link java.lang.foreign.ResourceScope} abstraction, as shown below:\n+ * with a memory segment. This can be done, using the {@link java.lang.foreign.MemorySession} abstraction, as shown below:\n@@ -73,2 +73,2 @@\n- * try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n- *     MemorySegment segment = MemorySegment.allocateNative(10 * 4, scope);\n+ * try (MemorySession session = MemorySession.openConfined()) {\n+ *     MemorySegment segment = MemorySegment.allocateNative(10 * 4, session);\n@@ -81,1 +81,1 @@\n- * This example is almost identical to the prior one; this time we first create a so called <em>resource scope<\/em>,\n+ * This example is almost identical to the prior one; this time we first create a so called <em>memory session<\/em>,\n@@ -95,1 +95,1 @@\n- * the resource scope associated with the segment being accessed has not been closed prematurely.\n+ * the memory session associated with the segment being accessed has not been closed prematurely.\n@@ -100,1 +100,1 @@\n- * The key abstractions introduced to support foreign function access are {@link java.lang.foreign.MemoryAddress} and\n+ * The key abstractions introduced to support foreign function access are {@link java.lang.foreign.NativeSymbol} and\n@@ -117,2 +117,2 @@\n- * try (var scope = ResourceScope.newConfinedScope()) {\n- *     var cString = MemorySegment.allocateNative(5 + 1, scope);\n+ * try (var session = MemorySession.openConfined()) {\n+ *     var cString = MemorySegment.allocateNative(5 + 1, session);\n@@ -157,1 +157,1 @@\n- * {@linkplain java.lang.foreign.MemorySegment#ofAddress(java.lang.foreign.MemoryAddress, long, java.lang.foreign.ResourceScope) create}\n+ * {@linkplain java.lang.foreign.MemorySegment#ofAddress(java.lang.foreign.MemoryAddress, long, java.lang.foreign.MemorySession) create}\n@@ -163,1 +163,1 @@\n- * ResourceScope scope = ... \/\/ initialize a resource scope object\n+ * MemorySession session = ... \/\/ initialize a memory session object\n@@ -165,1 +165,1 @@\n- * MemorySegment segment = MemorySegment.ofAddress(addr, 4, scope); \/\/ segment is 4 bytes long\n+ * MemorySegment segment = MemorySegment.ofAddress(addr, 4, session); \/\/ segment is 4 bytes long\n@@ -202,1 +202,1 @@\n- * ResourceScope scope = ...\n+ * MemorySession session = ...\n@@ -204,1 +204,1 @@\n- *     intCompareHandle, intCompareDescriptor, scope);\n+ *     intCompareHandle, intCompareDescriptor, session);\n@@ -209,1 +209,1 @@\n- * {@linkplain java.lang.foreign.CLinker#upcallStub(java.lang.invoke.MethodHandle, java.lang.foreign.FunctionDescriptor, java.lang.foreign.ResourceScope) create}\n+ * {@linkplain java.lang.foreign.CLinker#upcallStub(java.lang.invoke.MethodHandle, java.lang.foreign.FunctionDescriptor, java.lang.foreign.MemorySession) create}\n@@ -212,2 +212,2 @@\n- * The lifecycle of the upcall stub returned by is tied to the {@linkplain java.lang.foreign.ResourceScope resource scope}\n- * provided when the upcall stub is created. This same scope is made available by the {@link java.lang.foreign.NativeSymbol}\n+ * The lifecycle of the upcall stub is tied to the {@linkplain java.lang.foreign.MemorySession memory session}\n+ * provided when the upcall stub is created. This same session is made available by the {@link java.lang.foreign.NativeSymbol}\n@@ -220,1 +220,1 @@\n- * the restricted method {@link java.lang.foreign.MemorySegment#ofAddress(MemoryAddress, long, ResourceScope)}\n+ * the restricted method {@link java.lang.foreign.MemorySegment#ofAddress(MemoryAddress, long, MemorySession)}\n@@ -224,1 +224,1 @@\n- * For instance, in the case of {@link java.lang.foreign.MemorySegment#ofAddress(MemoryAddress, long, ResourceScope)},\n+ * For instance, in the case of {@link java.lang.foreign.MemorySegment#ofAddress(MemoryAddress, long, MemorySession)},\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n@@ -35,1 +36,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -615,1 +616,1 @@\n-        static ResourceScope scope(ByteBuffer bb) {\n+        static MemorySession session(ByteBuffer bb) {\n@@ -618,1 +619,1 @@\n-                    segment.scope() : null;\n+                    ((AbstractMemorySegmentImpl)segment).sessionImpl() : null;\n@@ -641,1 +642,1 @@\n-            $rawType$ rawValue = SCOPED_MEMORY_ACCESS.get$RawType$Unaligned(scope(bb),\n+            $rawType$ rawValue = SCOPED_MEMORY_ACCESS.get$RawType$Unaligned(session(bb),\n@@ -647,1 +648,1 @@\n-            return SCOPED_MEMORY_ACCESS.get$Type$Unaligned(scope(bb),\n+            return SCOPED_MEMORY_ACCESS.get$Type$Unaligned(session(bb),\n@@ -659,1 +660,1 @@\n-            SCOPED_MEMORY_ACCESS.put$RawType$Unaligned(scope(bb),\n+            SCOPED_MEMORY_ACCESS.put$RawType$Unaligned(session(bb),\n@@ -665,1 +666,1 @@\n-            SCOPED_MEMORY_ACCESS.put$Type$Unaligned(scope(bb),\n+            SCOPED_MEMORY_ACCESS.put$Type$Unaligned(session(bb),\n@@ -678,1 +679,1 @@\n-                              SCOPED_MEMORY_ACCESS.get$RawType$Volatile(scope(bb),\n+                              SCOPED_MEMORY_ACCESS.get$RawType$Volatile(session(bb),\n@@ -687,1 +688,1 @@\n-            SCOPED_MEMORY_ACCESS.put$RawType$Volatile(scope(bb),\n+            SCOPED_MEMORY_ACCESS.put$RawType$Volatile(session(bb),\n@@ -698,1 +699,1 @@\n-                              SCOPED_MEMORY_ACCESS.get$RawType$Acquire(scope(bb),\n+                              SCOPED_MEMORY_ACCESS.get$RawType$Acquire(session(bb),\n@@ -707,1 +708,1 @@\n-            SCOPED_MEMORY_ACCESS.put$RawType$Release(scope(bb),\n+            SCOPED_MEMORY_ACCESS.put$RawType$Release(session(bb),\n@@ -718,1 +719,1 @@\n-                              SCOPED_MEMORY_ACCESS.get$RawType$Opaque(scope(bb),\n+                              SCOPED_MEMORY_ACCESS.get$RawType$Opaque(session(bb),\n@@ -727,1 +728,1 @@\n-            SCOPED_MEMORY_ACCESS.put$RawType$Opaque(scope(bb),\n+            SCOPED_MEMORY_ACCESS.put$RawType$Opaque(session(bb),\n@@ -739,1 +740,1 @@\n-            return SCOPED_MEMORY_ACCESS.compareAndSetReference(scope(bb),\n+            return SCOPED_MEMORY_ACCESS.compareAndSetReference(session(bb),\n@@ -744,1 +745,1 @@\n-            return SCOPED_MEMORY_ACCESS.compareAndSet$RawType$(scope(bb),\n+            return SCOPED_MEMORY_ACCESS.compareAndSet$RawType$(session(bb),\n@@ -756,1 +757,1 @@\n-                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$(scope(bb),\n+                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$(session(bb),\n@@ -767,1 +768,1 @@\n-                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Acquire(scope(bb),\n+                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Acquire(session(bb),\n@@ -778,1 +779,1 @@\n-                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Release(scope(bb),\n+                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Release(session(bb),\n@@ -788,1 +789,1 @@\n-            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Plain(scope(bb),\n+            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Plain(session(bb),\n@@ -798,1 +799,1 @@\n-            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(scope(bb),\n+            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(session(bb),\n@@ -808,1 +809,1 @@\n-            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Acquire(scope(bb),\n+            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Acquire(session(bb),\n@@ -818,1 +819,1 @@\n-            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Release(scope(bb),\n+            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Release(session(bb),\n@@ -830,1 +831,1 @@\n-                              SCOPED_MEMORY_ACCESS.getAndSetReference(scope(bb),\n+                              SCOPED_MEMORY_ACCESS.getAndSetReference(session(bb),\n@@ -836,1 +837,1 @@\n-                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$(scope(bb),\n+                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$(session(bb),\n@@ -848,1 +849,1 @@\n-                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$Acquire(scope(bb),\n+                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$Acquire(session(bb),\n@@ -859,1 +860,1 @@\n-                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$Release(scope(bb),\n+                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$Release(session(bb),\n@@ -872,1 +873,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$(scope(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$(session(bb),\n@@ -886,1 +887,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Acquire(scope(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Acquire(session(bb),\n@@ -900,1 +901,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Release(scope(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Release(session(bb),\n@@ -915,1 +916,1 @@\n-                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(scope(bb), base, offset);\n+                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(session(bb), base, offset);\n@@ -929,1 +930,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$(scope(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$(session(bb),\n@@ -943,1 +944,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Release(scope(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Release(session(bb),\n@@ -957,1 +958,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Acquire(scope(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Acquire(session(bb),\n@@ -972,1 +973,1 @@\n-                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(scope(bb), base, offset);\n+                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(session(bb), base, offset);\n@@ -984,1 +985,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$(scope(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$(session(bb),\n@@ -998,1 +999,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Release(scope(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Release(session(bb),\n@@ -1012,1 +1013,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Acquire(scope(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Acquire(session(bb),\n@@ -1027,1 +1028,1 @@\n-                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(scope(bb), base, offset);\n+                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(session(bb), base, offset);\n@@ -1040,1 +1041,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$(scope(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$(session(bb),\n@@ -1054,1 +1055,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Release(scope(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Release(session(bb),\n@@ -1068,1 +1069,1 @@\n-                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Acquire(scope(bb),\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Acquire(session(bb),\n@@ -1083,1 +1084,1 @@\n-                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(scope(bb), base, offset);\n+                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(session(bb), base, offset);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleByteArrayView.java.template","additions":43,"deletions":42,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-        $rawType$ rawValue = SCOPED_MEMORY_ACCESS.get$RawType$Unaligned(bb.scope(),\n+        $rawType$ rawValue = SCOPED_MEMORY_ACCESS.get$RawType$Unaligned(bb.sessionImpl(),\n@@ -138,1 +138,1 @@\n-        return SCOPED_MEMORY_ACCESS.get$Type$(bb.scope(),\n+        return SCOPED_MEMORY_ACCESS.get$Type$(bb.sessionImpl(),\n@@ -142,1 +142,1 @@\n-        return SCOPED_MEMORY_ACCESS.get$Type$Unaligned(bb.scope(),\n+        return SCOPED_MEMORY_ACCESS.get$Type$Unaligned(bb.sessionImpl(),\n@@ -155,1 +155,1 @@\n-        SCOPED_MEMORY_ACCESS.put$RawType$Unaligned(bb.scope(),\n+        SCOPED_MEMORY_ACCESS.put$RawType$Unaligned(bb.sessionImpl(),\n@@ -162,1 +162,1 @@\n-        SCOPED_MEMORY_ACCESS.put$Type$(bb.scope(),\n+        SCOPED_MEMORY_ACCESS.put$Type$(bb.sessionImpl(),\n@@ -167,1 +167,1 @@\n-        SCOPED_MEMORY_ACCESS.put$Type$Unaligned(bb.scope(),\n+        SCOPED_MEMORY_ACCESS.put$Type$Unaligned(bb.sessionImpl(),\n@@ -181,1 +181,1 @@\n-                          SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.scope(),\n+                          SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),\n@@ -190,1 +190,1 @@\n-        SCOPED_MEMORY_ACCESS.put$RawType$Volatile(bb.scope(),\n+        SCOPED_MEMORY_ACCESS.put$RawType$Volatile(bb.sessionImpl(),\n@@ -201,1 +201,1 @@\n-                          SCOPED_MEMORY_ACCESS.get$RawType$Acquire(bb.scope(),\n+                          SCOPED_MEMORY_ACCESS.get$RawType$Acquire(bb.sessionImpl(),\n@@ -210,1 +210,1 @@\n-        SCOPED_MEMORY_ACCESS.put$RawType$Release(bb.scope(),\n+        SCOPED_MEMORY_ACCESS.put$RawType$Release(bb.sessionImpl(),\n@@ -221,1 +221,1 @@\n-                          SCOPED_MEMORY_ACCESS.get$RawType$Opaque(bb.scope(),\n+                          SCOPED_MEMORY_ACCESS.get$RawType$Opaque(bb.sessionImpl(),\n@@ -230,1 +230,1 @@\n-        SCOPED_MEMORY_ACCESS.put$RawType$Opaque(bb.scope(),\n+        SCOPED_MEMORY_ACCESS.put$RawType$Opaque(bb.sessionImpl(),\n@@ -241,1 +241,1 @@\n-        return SCOPED_MEMORY_ACCESS.compareAndSet$RawType$(bb.scope(),\n+        return SCOPED_MEMORY_ACCESS.compareAndSet$RawType$(bb.sessionImpl(),\n@@ -252,1 +252,1 @@\n-                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$(bb.scope(),\n+                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$(bb.sessionImpl(),\n@@ -263,1 +263,1 @@\n-                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Acquire(bb.scope(),\n+                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Acquire(bb.sessionImpl(),\n@@ -274,1 +274,1 @@\n-                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Release(bb.scope(),\n+                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Release(bb.sessionImpl(),\n@@ -284,1 +284,1 @@\n-        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Plain(bb.scope(),\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Plain(bb.sessionImpl(),\n@@ -294,1 +294,1 @@\n-        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.scope(),\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),\n@@ -304,1 +304,1 @@\n-        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Acquire(bb.scope(),\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Acquire(bb.sessionImpl(),\n@@ -314,1 +314,1 @@\n-        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Release(bb.scope(),\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Release(bb.sessionImpl(),\n@@ -325,1 +325,1 @@\n-                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$(bb.scope(),\n+                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$(bb.sessionImpl(),\n@@ -336,1 +336,1 @@\n-                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Acquire(bb.scope(),\n+                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Acquire(bb.sessionImpl(),\n@@ -347,1 +347,1 @@\n-                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Release(bb.scope(),\n+                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Release(bb.sessionImpl(),\n@@ -360,1 +360,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$(bb.scope(),\n+            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$(bb.sessionImpl(),\n@@ -374,1 +374,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Acquire(bb.scope(),\n+            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Acquire(bb.sessionImpl(),\n@@ -388,1 +388,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Release(bb.scope(),\n+            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Release(bb.sessionImpl(),\n@@ -402,1 +402,1 @@\n-            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.scope(),base, offset);\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n@@ -404,1 +404,1 @@\n-        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.scope(),base, offset,\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n@@ -416,1 +416,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$(bb.scope(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$(bb.sessionImpl(),\n@@ -430,1 +430,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Release(bb.scope(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Release(bb.sessionImpl(),\n@@ -444,1 +444,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Acquire(bb.scope(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Acquire(bb.sessionImpl(),\n@@ -458,1 +458,1 @@\n-            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.scope(),base, offset);\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n@@ -460,1 +460,1 @@\n-        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.scope(),base, offset,\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n@@ -470,1 +470,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$(bb.scope(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$(bb.sessionImpl(),\n@@ -484,1 +484,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Release(bb.scope(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Release(bb.sessionImpl(),\n@@ -498,1 +498,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Acquire(bb.scope(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Acquire(bb.sessionImpl(),\n@@ -512,1 +512,1 @@\n-            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.scope(),base, offset);\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n@@ -514,1 +514,1 @@\n-        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.scope(),base, offset,\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n@@ -525,1 +525,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$(bb.scope(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$(bb.sessionImpl(),\n@@ -539,1 +539,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Release(bb.scope(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Release(bb.sessionImpl(),\n@@ -553,1 +553,1 @@\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Acquire(bb.scope(),\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Acquire(bb.sessionImpl(),\n@@ -567,1 +567,1 @@\n-            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.scope(),base, offset);\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n@@ -569,1 +569,1 @@\n-        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.scope(),base, offset,\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleMemoryAccess.java.template","additions":43,"deletions":43,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -39,1 +40,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -760,1 +761,1 @@\n-    final ResourceScope scope() {\n+    final MemorySession session() {\n@@ -762,1 +763,1 @@\n-            return segment.scope();\n+            return ((AbstractMemorySegmentImpl)segment).sessionImpl();\n@@ -768,3 +769,3 @@\n-    final void checkScope() {\n-        ResourceScope scope = scope();\n-        if (scope != null) {\n+    final void checkSession() {\n+        MemorySession session = session();\n+        if (session != null) {\n@@ -772,1 +773,1 @@\n-                ((ResourceScopeImpl)scope).checkValidState();\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -828,3 +829,3 @@\n-                public Runnable acquireScope(Buffer buffer, boolean async) {\n-                    var scope = buffer.scope();\n-                    if (scope == null) {\n+                public Runnable acquireSession(Buffer buffer, boolean async) {\n+                    var session = buffer.session();\n+                    if (session == null) {\n@@ -833,2 +834,2 @@\n-                    if (async && scope.ownerThread() != null) {\n-                        throw new IllegalStateException(\"Confined scope not supported\");\n+                    if (async && session.ownerThread() != null) {\n+                        throw new IllegalStateException(\"Confined session not supported\");\n@@ -836,2 +837,2 @@\n-                    ((ResourceScopeImpl)scope).acquire0();\n-                    return ((ResourceScopeImpl) scope)::release0;\n+                    ((MemorySessionImpl)session).acquire0();\n+                    return ((MemorySessionImpl) session)::release0;\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.session(), b.session(),\n@@ -66,1 +66,1 @@\n-            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.session(), b.session(),\n@@ -86,1 +86,1 @@\n-            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.session(), b.session(),\n@@ -106,1 +106,1 @@\n-            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.session(), b.session(),\n@@ -125,1 +125,1 @@\n-                i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n+                i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.session(), b.session(),\n@@ -164,1 +164,1 @@\n-            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.session(), b.session(),\n@@ -182,1 +182,1 @@\n-                i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n+                i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.session(), b.session(),\n","filename":"src\/java.base\/share\/classes\/java\/nio\/BufferMismatch.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-        $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(scope(), bb.hb, byteOffset(nextGetIndex()),\n+        $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(session(), bb.hb, byteOffset(nextGetIndex()),\n@@ -139,1 +139,1 @@\n-        $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(scope(), bb.hb, byteOffset(checkIndex(i)),\n+        $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(session(), bb.hb, byteOffset(checkIndex(i)),\n@@ -157,1 +157,1 @@\n-        SCOPED_MEMORY_ACCESS.put$Memtype$Unaligned(scope(), bb.hb, byteOffset(nextPutIndex()), y,\n+        SCOPED_MEMORY_ACCESS.put$Memtype$Unaligned(session(), bb.hb, byteOffset(nextPutIndex()), y,\n@@ -168,1 +168,1 @@\n-        SCOPED_MEMORY_ACCESS.put$Memtype$Unaligned(scope(), bb.hb, byteOffset(checkIndex(i)), y,\n+        SCOPED_MEMORY_ACCESS.put$Memtype$Unaligned(session(), bb.hb, byteOffset(checkIndex(i)), y,\n","filename":"src\/java.base\/share\/classes\/java\/nio\/ByteBufferAs-X-Buffer.java.template","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-            $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(scope(), null, a, bigEndian);\n+            $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(session(), null, a, bigEndian);\n@@ -65,1 +65,1 @@\n-            SCOPED_MEMORY_ACCESS.put$Memtype$Unaligned(scope(), null, a, y, bigEndian);\n+            SCOPED_MEMORY_ACCESS.put$Memtype$Unaligned(session(), null, a, y, bigEndian);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer-bin.java.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -35,1 +35,1 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -303,4 +303,4 @@\n-        ResourceScope scope = scope();\n-        if (scope != null) {\n-            if (scope.ownerThread() == null) {\n-                throw new UnsupportedOperationException(\"ByteBuffer derived from shared segments not supported\");\n+        MemorySession session = session();\n+        if (session != null) {\n+            if (session.ownerThread() == null && session.isCloseable()) {\n+                throw new UnsupportedOperationException(\"ByteBuffer derived from closeable shared segments not supported\");\n@@ -309,1 +309,1 @@\n-                ((ResourceScopeImpl)scope).checkValidState();\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -323,1 +323,1 @@\n-            return $fromBits$($swap$(SCOPED_MEMORY_ACCESS.get$Swaptype$(scope(), null, ix(nextGetIndex()))));\n+            return $fromBits$($swap$(SCOPED_MEMORY_ACCESS.get$Swaptype$(session(), null, ix(nextGetIndex()))));\n@@ -331,1 +331,1 @@\n-            return $fromBits$($swap$(SCOPED_MEMORY_ACCESS.get$Swaptype$(scope(), null, ix(checkIndex(i)))));\n+            return $fromBits$($swap$(SCOPED_MEMORY_ACCESS.get$Swaptype$(session(), null, ix(checkIndex(i)))));\n@@ -351,1 +351,1 @@\n-            SCOPED_MEMORY_ACCESS.put$Swaptype$(scope(), null, ix(nextPutIndex()), $swap$($toBits$(x)));\n+            SCOPED_MEMORY_ACCESS.put$Swaptype$(session(), null, ix(nextPutIndex()), $swap$($toBits$(x)));\n@@ -364,1 +364,1 @@\n-            SCOPED_MEMORY_ACCESS.put$Swaptype$(scope(), null, ix(checkIndex(i)), $swap$($toBits$(x)));\n+            SCOPED_MEMORY_ACCESS.put$Swaptype$(session(), null, ix(checkIndex(i)), $swap$($toBits$(x)));\n@@ -381,2 +381,2 @@\n-            \/\/ null is passed as destination ResourceScope to avoid checking scope() twice\n-            SCOPED_MEMORY_ACCESS.copyMemory(scope(), null, null,\n+            \/\/ null is passed as destination MemorySession to avoid checking session() twice\n+            SCOPED_MEMORY_ACCESS.copyMemory(session(), null, null,\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-        checkScope();\n+        checkSession();\n@@ -190,1 +190,1 @@\n-        checkScope();\n+        checkSession();\n@@ -227,1 +227,1 @@\n-        checkScope();\n+        checkSession();\n@@ -242,1 +242,1 @@\n-        checkScope();\n+        checkSession();\n@@ -252,1 +252,1 @@\n-        checkScope();\n+        checkSession();\n@@ -262,1 +262,1 @@\n-        checkScope();\n+        checkSession();\n@@ -276,1 +276,1 @@\n-        checkScope();\n+        checkSession();\n@@ -331,1 +331,1 @@\n-        return SCOPED_MEMORY_ACCESS.getCharUnaligned(scope(), hb, byteOffset(nextGetIndex(2)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getCharUnaligned(session(), hb, byteOffset(nextGetIndex(2)), bigEndian);\n@@ -335,1 +335,1 @@\n-        return SCOPED_MEMORY_ACCESS.getCharUnaligned(scope(), hb, byteOffset(checkIndex(i, 2)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getCharUnaligned(session(), hb, byteOffset(checkIndex(i, 2)), bigEndian);\n@@ -342,1 +342,1 @@\n-        SCOPED_MEMORY_ACCESS.putCharUnaligned(scope(), hb, byteOffset(nextPutIndex(2)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putCharUnaligned(session(), hb, byteOffset(nextPutIndex(2)), x, bigEndian);\n@@ -351,1 +351,1 @@\n-        SCOPED_MEMORY_ACCESS.putCharUnaligned(scope(), hb, byteOffset(checkIndex(i, 2)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putCharUnaligned(session(), hb, byteOffset(checkIndex(i, 2)), x, bigEndian);\n@@ -383,1 +383,1 @@\n-        return SCOPED_MEMORY_ACCESS.getShortUnaligned(scope(), hb, byteOffset(nextGetIndex(2)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getShortUnaligned(session(), hb, byteOffset(nextGetIndex(2)), bigEndian);\n@@ -387,1 +387,1 @@\n-        return SCOPED_MEMORY_ACCESS.getShortUnaligned(scope(), hb, byteOffset(checkIndex(i, 2)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getShortUnaligned(session(), hb, byteOffset(checkIndex(i, 2)), bigEndian);\n@@ -394,1 +394,1 @@\n-        SCOPED_MEMORY_ACCESS.putShortUnaligned(scope(), hb, byteOffset(nextPutIndex(2)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putShortUnaligned(session(), hb, byteOffset(nextPutIndex(2)), x, bigEndian);\n@@ -403,1 +403,1 @@\n-        SCOPED_MEMORY_ACCESS.putShortUnaligned(scope(), hb, byteOffset(checkIndex(i, 2)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putShortUnaligned(session(), hb, byteOffset(checkIndex(i, 2)), x, bigEndian);\n@@ -435,1 +435,1 @@\n-        return SCOPED_MEMORY_ACCESS.getIntUnaligned(scope(), hb, byteOffset(nextGetIndex(4)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getIntUnaligned(session(), hb, byteOffset(nextGetIndex(4)), bigEndian);\n@@ -439,1 +439,1 @@\n-        return SCOPED_MEMORY_ACCESS.getIntUnaligned(scope(), hb, byteOffset(checkIndex(i, 4)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getIntUnaligned(session(), hb, byteOffset(checkIndex(i, 4)), bigEndian);\n@@ -446,1 +446,1 @@\n-        SCOPED_MEMORY_ACCESS.putIntUnaligned(scope(), hb, byteOffset(nextPutIndex(4)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(session(), hb, byteOffset(nextPutIndex(4)), x, bigEndian);\n@@ -455,1 +455,1 @@\n-        SCOPED_MEMORY_ACCESS.putIntUnaligned(scope(), hb, byteOffset(checkIndex(i, 4)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(session(), hb, byteOffset(checkIndex(i, 4)), x, bigEndian);\n@@ -487,1 +487,1 @@\n-        return SCOPED_MEMORY_ACCESS.getLongUnaligned(scope(), hb, byteOffset(nextGetIndex(8)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getLongUnaligned(session(), hb, byteOffset(nextGetIndex(8)), bigEndian);\n@@ -491,1 +491,1 @@\n-        return SCOPED_MEMORY_ACCESS.getLongUnaligned(scope(), hb, byteOffset(checkIndex(i, 8)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getLongUnaligned(session(), hb, byteOffset(checkIndex(i, 8)), bigEndian);\n@@ -498,1 +498,1 @@\n-        SCOPED_MEMORY_ACCESS.putLongUnaligned(scope(), hb, byteOffset(nextPutIndex(8)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(session(), hb, byteOffset(nextPutIndex(8)), x, bigEndian);\n@@ -507,1 +507,1 @@\n-        SCOPED_MEMORY_ACCESS.putLongUnaligned(scope(), hb, byteOffset(checkIndex(i, 8)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(session(), hb, byteOffset(checkIndex(i, 8)), x, bigEndian);\n@@ -539,1 +539,1 @@\n-        int x = SCOPED_MEMORY_ACCESS.getIntUnaligned(scope(), hb, byteOffset(nextGetIndex(4)), bigEndian);\n+        int x = SCOPED_MEMORY_ACCESS.getIntUnaligned(session(), hb, byteOffset(nextGetIndex(4)), bigEndian);\n@@ -544,1 +544,1 @@\n-        int x = SCOPED_MEMORY_ACCESS.getIntUnaligned(scope(), hb, byteOffset(checkIndex(i, 4)), bigEndian);\n+        int x = SCOPED_MEMORY_ACCESS.getIntUnaligned(session(), hb, byteOffset(checkIndex(i, 4)), bigEndian);\n@@ -553,1 +553,1 @@\n-        SCOPED_MEMORY_ACCESS.putIntUnaligned(scope(), hb, byteOffset(nextPutIndex(4)), y, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(session(), hb, byteOffset(nextPutIndex(4)), y, bigEndian);\n@@ -563,1 +563,1 @@\n-        SCOPED_MEMORY_ACCESS.putIntUnaligned(scope(), hb, byteOffset(checkIndex(i, 4)), y, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(session(), hb, byteOffset(checkIndex(i, 4)), y, bigEndian);\n@@ -595,1 +595,1 @@\n-        long x = SCOPED_MEMORY_ACCESS.getLongUnaligned(scope(), hb, byteOffset(nextGetIndex(8)), bigEndian);\n+        long x = SCOPED_MEMORY_ACCESS.getLongUnaligned(session(), hb, byteOffset(nextGetIndex(8)), bigEndian);\n@@ -600,1 +600,1 @@\n-        long x = SCOPED_MEMORY_ACCESS.getLongUnaligned(scope(), hb, byteOffset(checkIndex(i, 8)), bigEndian);\n+        long x = SCOPED_MEMORY_ACCESS.getLongUnaligned(session(), hb, byteOffset(checkIndex(i, 8)), bigEndian);\n@@ -609,1 +609,1 @@\n-        SCOPED_MEMORY_ACCESS.putLongUnaligned(scope(), hb, byteOffset(nextPutIndex(8)), y, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(session(), hb, byteOffset(nextPutIndex(8)), y, bigEndian);\n@@ -619,1 +619,1 @@\n-        SCOPED_MEMORY_ACCESS.putLongUnaligned(scope(), hb, byteOffset(checkIndex(i, 8)), y, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(session(), hb, byteOffset(checkIndex(i, 8)), y, bigEndian);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Heap-X-Buffer.java.template","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-        return SCOPED_MEMORY_ACCESS.isLoaded(scope(), address, isSync, capacity());\n+        return SCOPED_MEMORY_ACCESS.isLoaded(session(), address, isSync, capacity());\n@@ -209,1 +209,1 @@\n-            SCOPED_MEMORY_ACCESS.load(scope(), address, isSync, capacity());\n+            SCOPED_MEMORY_ACCESS.load(session(), address, isSync, capacity());\n@@ -309,1 +309,1 @@\n-            SCOPED_MEMORY_ACCESS.force(scope(), fd, address, isSync, index, length);\n+            SCOPED_MEMORY_ACCESS.force(session(), fd, address, isSync, index, length);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/MappedByteBuffer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -928,1 +928,1 @@\n-                            scope(), null, base(), bufAddr,\n+                            session(), null, base(), bufAddr,\n@@ -933,1 +933,1 @@\n-                            scope(), null, base(), bufAddr,\n+                            session(), null, base(), bufAddr,\n@@ -1098,1 +1098,1 @@\n-                            src.scope(), scope(), srcBase, srcAddr,\n+                            src.session(), session(), srcBase, srcAddr,\n@@ -1103,1 +1103,1 @@\n-                            src.scope(), scope(), srcBase, srcAddr,\n+                            src.session(), session(), srcBase, srcAddr,\n@@ -1318,1 +1318,1 @@\n-                            null, scope(), src, srcOffset,\n+                            null, session(), src, srcOffset,\n@@ -1323,1 +1323,1 @@\n-                            null, scope(), src, srcOffset,\n+                            null, session(), src, srcOffset,\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -89,4 +89,4 @@\n-     * Used by I\/O operations to make a buffer's resource scope non-closeable\n-     * (for the duration of the I\/O operation) by acquiring a new resource\n-     * scope handle. Null is returned if the buffer has no scope, or\n-     * acquiring is not required to guarantee safety.\n+     * Used by I\/O operations to make a buffer's session non-closeable\n+     * (for the duration of the I\/O operation) by acquiring the session.\n+     * Null is returned if the buffer has no scope, or acquiring is not\n+     * required to guarantee safety.\n@@ -94,1 +94,1 @@\n-    Runnable acquireScope(Buffer buffer, boolean async);\n+    Runnable acquireSession(Buffer buffer, boolean async);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -55,1 +56,1 @@\n- * than the owner thread. See {@link ResourceScopeImpl} for more details on management of temporal bounds. Subclasses\n+ * than the owner thread. See {@link MemorySessionImpl} for more details on management of temporal bounds. Subclasses\n@@ -72,1 +73,1 @@\n-    final ResourceScopeImpl scope;\n+    final MemorySessionImpl session;\n@@ -75,1 +76,1 @@\n-    AbstractMemorySegmentImpl(long length, int mask, ResourceScopeImpl scope) {\n+    AbstractMemorySegmentImpl(long length, int mask, MemorySessionImpl session) {\n@@ -78,1 +79,1 @@\n-        this.scope = scope;\n+        this.session = session;\n@@ -85,1 +86,1 @@\n-    abstract AbstractMemorySegmentImpl dup(long offset, long size, int mask, ResourceScopeImpl scope);\n+    abstract AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemorySessionImpl session);\n@@ -91,1 +92,1 @@\n-        return dup(0, length, mask | READ_ONLY, scope);\n+        return dup(0, length, mask | READ_ONLY, session);\n@@ -112,1 +113,1 @@\n-        return dup(offset, newSize, mask, scope);\n+        return dup(offset, newSize, mask, session);\n@@ -140,1 +141,1 @@\n-        SCOPED_MEMORY_ACCESS.setMemory(scope, base(), min(), length, value);\n+        SCOPED_MEMORY_ACCESS.setMemory(session, base(), min(), length, value);\n@@ -167,1 +168,1 @@\n-            i = vectorizedMismatchLargeForBytes(scope, that.scope,\n+            i = vectorizedMismatchLargeForBytes(session, that.session,\n@@ -189,1 +190,1 @@\n-    private static long vectorizedMismatchLargeForBytes(ResourceScopeImpl aScope, ResourceScopeImpl bScope,\n+    private static long vectorizedMismatchLargeForBytes(MemorySessionImpl aSession, MemorySessionImpl bSession,\n@@ -204,1 +205,1 @@\n-            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(aScope, bScope,\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(aSession, bSession,\n@@ -228,1 +229,1 @@\n-            \/\/scope is IMMUTABLE - obtain a RO byte buffer\n+            \/\/session is IMMUTABLE - obtain a RO byte buffer\n@@ -239,8 +240,0 @@\n-    public final boolean isAlive() {\n-        return scope.isAlive();\n-    }\n-\n-    public Thread ownerThread() {\n-        return scope.ownerThread();\n-    }\n-\n@@ -354,2 +347,2 @@\n-    void checkValidState() {\n-        scope.checkValidStateSlow();\n+    public void checkValidState() {\n+        session.checkValidStateSlow();\n@@ -401,2 +394,7 @@\n-    public ResourceScopeImpl scope() {\n-        return scope;\n+    public MemorySessionImpl sessionImpl() {\n+        return session;\n+    }\n+\n+    @Override\n+    public MemorySession session() {\n+        return new MemorySessionImpl.NonCloseableView(sessionImpl());\n@@ -507,1 +505,1 @@\n-        final ResourceScopeImpl bufferScope;\n+        final MemorySessionImpl bufferSession;\n@@ -510,1 +508,1 @@\n-            bufferScope = bufferSegment.scope;\n+            bufferSession = bufferSegment.session;\n@@ -513,1 +511,1 @@\n-            bufferScope = ResourceScopeImpl.heapScope(bb);\n+            bufferSession = MemorySessionImpl.heapSession(bb);\n@@ -522,1 +520,1 @@\n-            return new NativeMemorySegmentImpl(bbAddress + pos, size, modes, bufferScope);\n+            return new NativeMemorySegmentImpl(bbAddress + pos, size, modes, bufferSession);\n@@ -524,1 +522,1 @@\n-            return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, modes, bufferScope);\n+            return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, modes, bufferSession);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":27,"deletions":29,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -42,1 +42,1 @@\n-    private final ResourceScope scope;\n+    private final MemorySession session;\n@@ -44,1 +44,1 @@\n-    public ArenaAllocator(long blockSize, long arenaSize, ResourceScope scope) {\n+    public ArenaAllocator(long blockSize, long arenaSize, MemorySession session) {\n@@ -47,1 +47,1 @@\n-        this.scope = scope;\n+        this.session = session;\n@@ -63,4 +63,0 @@\n-    public ResourceScope scope() {\n-        return scope;\n-    }\n-\n@@ -73,1 +69,1 @@\n-        return MemorySegment.allocateNative(bytesSize, bytesAlignment, scope);\n+        return MemorySegment.allocateNative(bytesSize, bytesAlignment, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ArenaAllocator.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,121 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.foreign;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.lang.ref.Cleaner;\n-\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-\/**\n- * A confined scope, which features an owner thread. The liveness check features an additional\n- * confinement check - that is, calling any operation on this scope from a thread other than the\n- * owner thread will result in an exception. Because of this restriction, checking the liveness bit\n- * can be performed in plain mode.\n- *\/\n-final class ConfinedScope extends ResourceScopeImpl {\n-\n-    private int asyncReleaseCount = 0;\n-\n-    static final VarHandle ASYNC_RELEASE_COUNT;\n-\n-    static {\n-        try {\n-            ASYNC_RELEASE_COUNT = MethodHandles.lookup().findVarHandle(ConfinedScope.class, \"asyncReleaseCount\", int.class);\n-        } catch (Throwable ex) {\n-            throw new ExceptionInInitializerError(ex);\n-        }\n-    }\n-\n-    public ConfinedScope(Thread owner, Cleaner cleaner) {\n-        super(owner, new ConfinedResourceList(), cleaner);\n-    }\n-\n-    @Override\n-    public boolean isAlive() {\n-        return state != CLOSED;\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public void acquire0() {\n-        checkValidStateSlow();\n-        if (state == MAX_FORKS) {\n-            throw new IllegalStateException(\"Scope keep alive limit exceeded\");\n-        }\n-        state++;\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public void release0() {\n-        if (Thread.currentThread() == owner) {\n-            state--;\n-        } else {\n-            \/\/ It is possible to end up here in two cases: this scope was kept alive by some other confined scope\n-            \/\/ which is implicitly released (in which case the release call comes from the cleaner thread). Or,\n-            \/\/ this scope might be kept alive by a shared scope, which means the release call can come from any\n-            \/\/ thread.\n-            ASYNC_RELEASE_COUNT.getAndAdd(this, 1);\n-        }\n-    }\n-\n-    void justClose() {\n-        checkValidStateSlow();\n-        if (state == 0 || state - ((int)ASYNC_RELEASE_COUNT.getVolatile(this)) == 0) {\n-            state = CLOSED;\n-        } else {\n-            throw new IllegalStateException(\"Scope is kept alive by \" + state + \" scopes\");\n-        }\n-    }\n-\n-    \/**\n-     * A confined resource list; no races are possible here.\n-     *\/\n-    static final class ConfinedResourceList extends ResourceList {\n-        @Override\n-        void add(ResourceCleanup cleanup) {\n-            if (fst != ResourceCleanup.CLOSED_LIST) {\n-                cleanup.next = fst;\n-                fst = cleanup;\n-            } else {\n-                throw new IllegalStateException(\"Already closed!\");\n-            }\n-        }\n-\n-        @Override\n-        void cleanup() {\n-            if (fst != ResourceCleanup.CLOSED_LIST) {\n-                ResourceCleanup prev = fst;\n-                fst = ResourceCleanup.CLOSED_LIST;\n-                cleanup(prev);\n-            } else {\n-                throw new IllegalStateException(\"Attempt to cleanup an already closed resource list\");\n-            }\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ConfinedScope.java","additions":0,"deletions":121,"binary":false,"changes":121,"status":"deleted"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.ref.Cleaner;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * A confined session, which features an owner thread. The liveness check features an additional\n+ * confinement check - that is, calling any operation on this session from a thread other than the\n+ * owner thread will result in an exception. Because of this restriction, checking the liveness bit\n+ * can be performed in plain mode.\n+ *\/\n+final class ConfinedSession extends MemorySessionImpl {\n+\n+    private int asyncReleaseCount = 0;\n+\n+    static final VarHandle ASYNC_RELEASE_COUNT;\n+\n+    static {\n+        try {\n+            ASYNC_RELEASE_COUNT = MethodHandles.lookup().findVarHandle(ConfinedSession.class, \"asyncReleaseCount\", int.class);\n+        } catch (Throwable ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n+    public ConfinedSession(Thread owner, Cleaner cleaner) {\n+        super(owner, new ConfinedResourceList(), cleaner);\n+    }\n+\n+    @Override\n+    public boolean isAlive() {\n+        return state != CLOSED;\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public void acquire0() {\n+        checkValidStateSlow();\n+        if (state == MAX_FORKS) {\n+            throw new IllegalStateException(\"Session keep alive limit exceeded\");\n+        }\n+        state++;\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public void release0() {\n+        if (Thread.currentThread() == owner) {\n+            state--;\n+        } else {\n+            \/\/ It is possible to end up here in two cases: this session was kept alive by some other confined session\n+            \/\/ which is implicitly released (in which case the release call comes from the cleaner thread). Or,\n+            \/\/ this session might be kept alive by a shared session, which means the release call can come from any\n+            \/\/ thread.\n+            ASYNC_RELEASE_COUNT.getAndAdd(this, 1);\n+        }\n+    }\n+\n+    void justClose() {\n+        checkValidStateSlow();\n+        if (state == 0 || state - ((int)ASYNC_RELEASE_COUNT.getVolatile(this)) == 0) {\n+            state = CLOSED;\n+        } else {\n+            throw new IllegalStateException(\"Session is acquired by \" + state + \" clients\");\n+        }\n+    }\n+\n+    \/**\n+     * A confined resource list; no races are possible here.\n+     *\/\n+    static final class ConfinedResourceList extends ResourceList {\n+        @Override\n+        void add(ResourceCleanup cleanup) {\n+            if (fst != ResourceCleanup.CLOSED_LIST) {\n+                cleanup.next = fst;\n+                fst = cleanup;\n+            } else {\n+                throw new IllegalStateException(\"Already closed!\");\n+            }\n+        }\n+\n+        @Override\n+        void cleanup() {\n+            if (fst != ResourceCleanup.CLOSED_LIST) {\n+                ResourceCleanup prev = fst;\n+                fst = ResourceCleanup.CLOSED_LIST;\n+                cleanup(prev);\n+            } else {\n+                throw new IllegalStateException(\"Attempt to cleanup an already closed resource list\");\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ConfinedSession.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -46,1 +46,1 @@\n- * such as the elimination of store barriers in methods like {@link HeapMemorySegmentImpl#dup(long, long, int, ResourceScopeImpl)}.\n+ * such as the elimination of store barriers in methods like {@link HeapMemorySegmentImpl#dup(long, long, int, MemorySessionImpl)}.\n@@ -63,1 +63,1 @@\n-        super(length, mask, ResourceScopeImpl.GLOBAL);\n+        super(length, mask, MemorySessionImpl.GLOBAL);\n@@ -77,1 +77,1 @@\n-    abstract HeapMemorySegmentImpl dup(long offset, long size, int mask, ResourceScopeImpl scope);\n+    abstract HeapMemorySegmentImpl dup(long offset, long size, int mask, MemorySessionImpl session);\n@@ -97,1 +97,1 @@\n-        OfByte dup(long offset, long size, int mask, ResourceScopeImpl scope) {\n+        OfByte dup(long offset, long size, int mask, MemorySessionImpl session) {\n@@ -125,1 +125,1 @@\n-        OfChar dup(long offset, long size, int mask, ResourceScopeImpl scope) {\n+        OfChar dup(long offset, long size, int mask, MemorySessionImpl session) {\n@@ -153,1 +153,1 @@\n-        OfShort dup(long offset, long size, int mask, ResourceScopeImpl scope) {\n+        OfShort dup(long offset, long size, int mask, MemorySessionImpl session) {\n@@ -181,1 +181,1 @@\n-        OfInt dup(long offset, long size, int mask, ResourceScopeImpl scope) {\n+        OfInt dup(long offset, long size, int mask, MemorySessionImpl session) {\n@@ -209,1 +209,1 @@\n-        OfLong dup(long offset, long size, int mask, ResourceScopeImpl scope) {\n+        OfLong dup(long offset, long size, int mask, MemorySessionImpl session) {\n@@ -237,1 +237,1 @@\n-        OfFloat dup(long offset, long size, int mask, ResourceScopeImpl scope) {\n+        OfFloat dup(long offset, long size, int mask, MemorySessionImpl session) {\n@@ -265,1 +265,1 @@\n-        OfDouble dup(long offset, long size, int mask, ResourceScopeImpl scope) {\n+        OfDouble dup(long offset, long size, int mask, MemorySessionImpl session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n-    MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, int mask, ResourceScopeImpl scope) {\n-        super(min, length, mask, scope);\n+    MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, int mask, MemorySessionImpl session) {\n+        super(min, length, mask, session);\n@@ -63,1 +63,1 @@\n-                scope == ResourceScopeImpl.GLOBAL ? null : this);\n+                session == MemorySessionImpl.GLOBAL ? null : this);\n@@ -67,2 +67,2 @@\n-    MappedMemorySegmentImpl dup(long offset, long size, int mask, ResourceScopeImpl scope) {\n-        return new MappedMemorySegmentImpl(min + offset, unmapper, size, mask, scope);\n+    MappedMemorySegmentImpl dup(long offset, long size, int mask, MemorySessionImpl session) {\n+        return new MappedMemorySegmentImpl(min + offset, unmapper, size, mask, session);\n@@ -91,1 +91,1 @@\n-        SCOPED_MEMORY_ACCESS.load(scope, min, unmapper.isSync(), length);\n+        SCOPED_MEMORY_ACCESS.load(session, min, unmapper.isSync(), length);\n@@ -95,1 +95,1 @@\n-        SCOPED_MEMORY_ACCESS.unload(scope, min, unmapper.isSync(), length);\n+        SCOPED_MEMORY_ACCESS.unload(session, min, unmapper.isSync(), length);\n@@ -99,1 +99,1 @@\n-        return SCOPED_MEMORY_ACCESS.isLoaded(scope, min, unmapper.isSync(), length);\n+        return SCOPED_MEMORY_ACCESS.isLoaded(session, min, unmapper.isSync(), length);\n@@ -103,1 +103,1 @@\n-        SCOPED_MEMORY_ACCESS.force(scope, unmapper.fileDescriptor(), min, unmapper.isSync(), 0, length);\n+        SCOPED_MEMORY_ACCESS.force(session, unmapper.fileDescriptor(), min, unmapper.isSync(), 0, length);\n@@ -108,1 +108,1 @@\n-    public static MemorySegment makeMappedSegment(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode, ResourceScopeImpl scope) throws IOException {\n+    public static MemorySegment makeMappedSegment(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode, MemorySessionImpl session) throws IOException {\n@@ -111,1 +111,1 @@\n-        scope.checkValidStateSlow();\n+        session.checkValidStateSlow();\n@@ -127,2 +127,2 @@\n-                        modes, scope);\n-                scope.addOrCleanupIfFail(new ResourceScopeImpl.ResourceList.ResourceCleanup() {\n+                        modes, session);\n+                session.addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n@@ -136,1 +136,1 @@\n-                return new EmptyMappedMemorySegmentImpl(modes, scope);\n+                return new EmptyMappedMemorySegmentImpl(modes, session);\n@@ -156,2 +156,2 @@\n-        public EmptyMappedMemorySegmentImpl(int modes, ResourceScopeImpl scope) {\n-            super(0, null, 0, modes, scope);\n+        public EmptyMappedMemorySegmentImpl(int modes, MemorySessionImpl session) {\n+            super(0, null, 0, modes, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.foreign.ResourceScope;\n@@ -89,2 +88,2 @@\n-    public static MemorySegment ofLongUnchecked(long value, long byteSize, ResourceScopeImpl resourceScope) {\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize, resourceScope);\n+    public static MemorySegment ofLongUnchecked(long value, long byteSize, MemorySessionImpl session) {\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize, session);\n@@ -94,1 +93,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize, ResourceScopeImpl.GLOBAL);\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize, MemorySessionImpl.GLOBAL);\n@@ -98,2 +97,2 @@\n-    public ResourceScope scope() {\n-        return ResourceScopeImpl.GLOBAL;\n+    public MemorySessionImpl sessionImpl() {\n+        return MemorySessionImpl.GLOBAL;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,430 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.ref.Cleaner;\n+import java.lang.ref.Reference;\n+import java.util.Objects;\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.ref.CleanerFactory;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * This class manages the temporal bounds associated with a memory segment as well\n+ * as thread confinement. A session has a liveness bit, which is updated when the session is closed\n+ * (this operation is triggered by {@link MemorySession#close()}). This bit is consulted prior\n+ * to memory access (see {@link #checkValidState()}).\n+ * There are two kinds of memory session: confined memory session and shared memory session.\n+ * A confined memory session has an associated owner thread that confines some operations to\n+ * associated owner thread such as {@link #close()} or {@link #checkValidState()}.\n+ * Shared sessions do not feature an owner thread - meaning their operations can be called, in a racy\n+ * manner, by multiple threads. To guarantee temporal safety in the presence of concurrent thread,\n+ * shared sessions use a more sophisticated synchronization mechanism, which guarantees that no concurrent\n+ * access is possible when a session is being closed (see {@link jdk.internal.misc.ScopedMemoryAccess}).\n+ *\/\n+public abstract non-sealed class MemorySessionImpl implements MemorySession, Scoped, SegmentAllocator {\n+    final ResourceList resourceList;\n+    final Cleaner.Cleanable cleanable;\n+    final Thread owner;\n+\n+    static final int OPEN = 0;\n+    static final int CLOSING = -1;\n+    static final int CLOSED = -2;\n+\n+    int state = OPEN;\n+\n+    static final VarHandle STATE;\n+\n+    static {\n+        try {\n+            STATE = MethodHandles.lookup().findVarHandle(MemorySessionImpl.class, \"state\", int.class);\n+        } catch (Throwable ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n+    static final int MAX_FORKS = Integer.MAX_VALUE;\n+\n+    @Override\n+    public void addCloseAction(Runnable runnable) {\n+        Objects.requireNonNull(runnable);\n+        addInternal(ResourceList.ResourceCleanup.ofRunnable(runnable));\n+    }\n+\n+    public MemorySessionImpl sessionImpl() {\n+        return this;\n+    }\n+\n+    \/**\n+     * Add a cleanup action. If a failure occurred (because of a add vs. close race), call the cleanup action.\n+     * This semantics is useful when allocating new memory segments, since we first do a malloc\/mmap and _then_\n+     * we register the cleanup (free\/munmap) against the session; so, if registration fails, we still have to\n+     * cleanup memory. From the perspective of the client, such a failure would manifest as a factory\n+     * returning a segment that is already \"closed\" - which is always possible anyway (e.g. if the session\n+     * is closed _after_ the cleanup for the segment is registered but _before_ the factory returns the\n+     * new segment to the client). For this reason, it's not worth adding extra complexity to the segment\n+     * initialization logic here - and using an optimistic logic works well in practice.\n+     *\/\n+    public void addOrCleanupIfFail(ResourceList.ResourceCleanup resource) {\n+        try {\n+            addInternal(resource);\n+        } catch (Throwable ex) {\n+            resource.cleanup();\n+        }\n+    }\n+\n+    void addInternal(ResourceList.ResourceCleanup resource) {\n+        try {\n+            checkValidStateSlow();\n+            resourceList.add(resource);\n+        } catch (ScopedMemoryAccess.ScopedAccessError err) {\n+            throw new IllegalStateException(\"Already closed\");\n+        }\n+    }\n+\n+    protected MemorySessionImpl(Thread owner, ResourceList resourceList, Cleaner cleaner) {\n+        this.owner = owner;\n+        this.resourceList = resourceList;\n+        cleanable = (cleaner != null) ?\n+            cleaner.register(this, resourceList) : null;\n+    }\n+\n+    public static MemorySession createConfined(Thread thread, Cleaner cleaner) {\n+        return new ConfinedSession(thread, cleaner);\n+    }\n+\n+    public static MemorySession createShared(Cleaner cleaner) {\n+        return new SharedSession(cleaner);\n+    }\n+\n+    public static MemorySessionImpl createImplicit() {\n+        return new ImplicitSession();\n+    }\n+\n+    @Override\n+    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+        return MemorySegment.allocateNative(bytesSize, bytesAlignment, this);\n+    }\n+\n+    public abstract void release0();\n+\n+    public abstract void acquire0();\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        return (o instanceof MemorySession other) &&\n+            ((Scoped)other).sessionImpl() == this;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return super.hashCode();\n+    }\n+\n+    @Override\n+    public void whileAlive(Runnable action) {\n+        Objects.requireNonNull(action);\n+        acquire0();\n+        try {\n+            action.run();\n+        } finally {\n+            release0();\n+        }\n+    }\n+\n+    \/**\n+     * Returns \"owner\" thread of this session.\n+     * @return owner thread (or null for a shared session)\n+     *\/\n+    public final Thread ownerThread() {\n+        return owner;\n+    }\n+\n+    \/**\n+     * Returns true, if this session is still open. This method may be called in any thread.\n+     * @return {@code true} if this session is not closed yet.\n+     *\/\n+    public abstract boolean isAlive();\n+\n+    \/**\n+     * This is a faster version of {@link #checkValidStateSlow()}, which is called upon memory access, and which\n+     * relies on invariants associated with the memory session implementations (volatile access\n+     * to the closed state bit is replaced with plain access). This method should be monomorphic,\n+     * to avoid virtual calls in the memory access hot path. This method is not intended as general purpose method\n+     * and should only be used in the memory access handle hot path; for liveness checks triggered by other API methods,\n+     * please use {@link #checkValidStateSlow()}.\n+     *\/\n+    @ForceInline\n+    public final void checkValidState() {\n+        if (owner != null && owner != Thread.currentThread()) {\n+            throw new IllegalStateException(\"Attempted access outside owning thread\");\n+        }\n+        if (state < OPEN) {\n+            throw ScopedMemoryAccess.ScopedAccessError.INSTANCE;\n+        }\n+    }\n+\n+    \/**\n+     * Checks that this session is still alive (see {@link #isAlive()}).\n+     * @throws IllegalStateException if this session is already closed or if this is\n+     * a confined session and this method is called outside of the owner thread.\n+     *\/\n+    public final void checkValidStateSlow() {\n+        if (owner != null && Thread.currentThread() != owner) {\n+            throw new IllegalStateException(\"Attempted access outside owning thread\");\n+        } else if (!isAlive()) {\n+            throw new IllegalStateException(\"Already closed\");\n+        }\n+    }\n+\n+    @Override\n+    protected Object clone() throws CloneNotSupportedException {\n+        throw new CloneNotSupportedException();\n+    }\n+\n+    @Override\n+    public boolean isCloseable() {\n+        return true;\n+    }\n+\n+    \/**\n+     * Closes this session, executing any cleanup action (where provided).\n+     * @throws IllegalStateException if this session is already closed or if this is\n+     * a confined session and this method is called outside of the owner thread.\n+     *\/\n+    @Override\n+    public void close() {\n+        try {\n+            justClose();\n+            if (cleanable != null) {\n+                cleanable.clean();\n+            } else {\n+                resourceList.cleanup();\n+            }\n+        } finally {\n+            Reference.reachabilityFence(this);\n+        }\n+    }\n+\n+    abstract void justClose();\n+\n+    \/**\n+     * The global, non-closeable, shared session. Similar to a shared session, but its {@link #close()} method throws unconditionally.\n+     * Adding new resources to the global session, does nothing: as the session can never become not-alive, there is nothing to track.\n+     * Acquiring and or releasing a memory session similarly does nothing.\n+     *\/\n+    static class GlobalSessionImpl extends MemorySessionImpl {\n+\n+        final Object ref;\n+\n+        public GlobalSessionImpl(Object ref) {\n+            super(null, null ,null);\n+            this.ref = ref;\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void release0() {\n+            \/\/ do nothing\n+        }\n+\n+        @Override\n+        public boolean isCloseable() {\n+            return false;\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void acquire0() {\n+            \/\/ do nothing\n+        }\n+\n+        @Override\n+        void addInternal(ResourceList.ResourceCleanup resource) {\n+            \/\/ do nothing\n+        }\n+\n+        @Override\n+        public boolean isAlive() {\n+            return true;\n+        }\n+\n+        @Override\n+        public void justClose() {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    public static final MemorySessionImpl GLOBAL = new GlobalSessionImpl(null);\n+\n+    public static MemorySessionImpl heapSession(Object ref) {\n+        return new GlobalSessionImpl(ref);\n+    }\n+\n+    static class ImplicitSession extends SharedSession {\n+\n+        public ImplicitSession() {\n+            super(CleanerFactory.cleaner());\n+        }\n+\n+        @Override\n+        public void release0() {\n+            Reference.reachabilityFence(this);\n+        }\n+\n+        @Override\n+        public void acquire0() {\n+            \/\/ do nothing\n+        }\n+\n+        @Override\n+        public boolean isCloseable() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isAlive() {\n+            return true;\n+        }\n+\n+        @Override\n+        public void justClose() {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    \/**\n+     * This is a non-closeable view of another memory session. Instances of this class are used in resource session\n+     * accessors (see {@link MemorySegment#session()}). This class forwards all session methods to the underlying\n+     * \"root\" session implementation, and throws {@link UnsupportedOperationException} on close.\n+     *\/\n+    public final static class NonCloseableView implements MemorySession, Scoped {\n+        final MemorySessionImpl session;\n+\n+        public NonCloseableView(MemorySessionImpl session) {\n+            this.session = session;\n+        }\n+\n+        public MemorySessionImpl sessionImpl() {\n+            return session;\n+        }\n+\n+        @Override\n+        public boolean isAlive() {\n+            return session.isAlive();\n+        }\n+\n+        @Override\n+        public boolean isCloseable() {\n+            return false;\n+        }\n+\n+        @Override\n+        public Thread ownerThread() {\n+            return session.ownerThread();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            return session.equals(o);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return session.hashCode();\n+        }\n+\n+        @Override\n+        public void whileAlive(Runnable action) {\n+            session.whileAlive(action);\n+        }\n+\n+        @Override\n+        public void addCloseAction(Runnable runnable) {\n+            session.addCloseAction(runnable);\n+        }\n+\n+        @Override\n+        public void close() {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    \/**\n+     * A list of all cleanup actions associated with a memory session. Cleanup actions are modelled as instances\n+     * of the {@link ResourceCleanup} class, and, together, form a linked list. Depending on whether a session\n+     * is shared or confined, different implementations of this class will be used, see {@link ConfinedSession.ConfinedResourceList}\n+     * and {@link SharedSession.SharedResourceList}.\n+     *\/\n+    public abstract static class ResourceList implements Runnable {\n+        ResourceCleanup fst;\n+\n+        abstract void add(ResourceCleanup cleanup);\n+\n+        abstract void cleanup();\n+\n+        public final void run() {\n+            cleanup(); \/\/ cleaner interop\n+        }\n+\n+        static void cleanup(ResourceCleanup first) {\n+            ResourceCleanup current = first;\n+            while (current != null) {\n+                current.cleanup();\n+                current = current.next;\n+            }\n+        }\n+\n+        public abstract static class ResourceCleanup {\n+            ResourceCleanup next;\n+\n+            public abstract void cleanup();\n+\n+            static final ResourceCleanup CLOSED_LIST = new ResourceCleanup() {\n+                @Override\n+                public void cleanup() {\n+                    throw new IllegalStateException(\"This resource list has already been closed!\");\n+                }\n+            };\n+\n+            static ResourceCleanup ofRunnable(Runnable cleanupAction) {\n+                return new ResourceCleanup() {\n+                    @Override\n+                    public void cleanup() {\n+                        cleanupAction.run();\n+                    }\n+                };\n+            }\n+        }\n+\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":430,"deletions":0,"binary":false,"changes":430,"status":"added"},{"patch":"@@ -43,1 +43,1 @@\n-    public static final MemorySegment EVERYTHING = new NativeMemorySegmentImpl(0, Long.MAX_VALUE, 0, ResourceScopeImpl.GLOBAL) {\n+    public static final MemorySegment EVERYTHING = new NativeMemorySegmentImpl(0, Long.MAX_VALUE, 0, MemorySessionImpl.GLOBAL) {\n@@ -50,1 +50,1 @@\n-        NativeMemorySegmentImpl dup(long offset, long size, int mask, ResourceScopeImpl scope) {\n+        NativeMemorySegmentImpl dup(long offset, long size, int mask, MemorySessionImpl scope) {\n@@ -66,2 +66,2 @@\n-    NativeMemorySegmentImpl(long min, long length, int mask, ResourceScopeImpl scope) {\n-        super(length, mask, scope);\n+    NativeMemorySegmentImpl(long min, long length, int mask, MemorySessionImpl session) {\n+        super(length, mask, session);\n@@ -79,2 +79,2 @@\n-    NativeMemorySegmentImpl dup(long offset, long size, int mask, ResourceScopeImpl scope) {\n-        return new NativeMemorySegmentImpl(min + offset, size, mask, scope);\n+    NativeMemorySegmentImpl dup(long offset, long size, int mask, MemorySessionImpl session) {\n+        return new NativeMemorySegmentImpl(min + offset, size, mask, session);\n@@ -86,1 +86,1 @@\n-                scope == ResourceScopeImpl.GLOBAL ? null : this);\n+                session == MemorySessionImpl.GLOBAL ? null : this);\n@@ -111,2 +111,2 @@\n-    public static MemorySegment makeNativeSegment(long bytesSize, long alignmentBytes, ResourceScopeImpl scope) {\n-        scope.checkValidStateSlow();\n+    public static MemorySegment makeNativeSegment(long bytesSize, long alignmentBytes, MemorySessionImpl session) {\n+        session.checkValidStateSlow();\n@@ -128,2 +128,2 @@\n-                DEFAULT_MODES, scope);\n-        scope.addOrCleanupIfFail(new ResourceScopeImpl.ResourceList.ResourceCleanup() {\n+                DEFAULT_MODES, session);\n+        session.addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n@@ -143,3 +143,3 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, ResourceScopeImpl scope) {\n-        scope.checkValidStateSlow();\n-        AbstractMemorySegmentImpl segment = new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, DEFAULT_MODES, scope);\n+    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, MemorySessionImpl session) {\n+        session.checkValidStateSlow();\n+        AbstractMemorySegmentImpl segment = new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, DEFAULT_MODES, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -30,1 +31,0 @@\n-import java.lang.foreign.ResourceScope;\n@@ -32,1 +32,1 @@\n-public record NativeSymbolImpl(String name, MemoryAddress address, ResourceScope scope) implements NativeSymbol, Scoped {\n+public record NativeSymbolImpl(String name, MemoryAddress address, MemorySessionImpl sessionImpl) implements NativeSymbol, Scoped {\n@@ -35,1 +35,1 @@\n-        ((ResourceScopeImpl)scope).checkValidStateSlow();\n+        sessionImpl.checkValidStateSlow();\n@@ -38,0 +38,5 @@\n+\n+    @Override\n+    public MemorySession session() {\n+        return new MemorySessionImpl.NonCloseableView(sessionImpl());\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeSymbolImpl.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,311 +0,0 @@\n-\/*\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package jdk.internal.foreign;\n-\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ResourceScope;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.lang.ref.Cleaner;\n-import java.lang.ref.Reference;\n-import java.util.Objects;\n-import jdk.internal.misc.ScopedMemoryAccess;\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-\/**\n- * This class manages the temporal bounds associated with a memory segment as well\n- * as thread confinement. A scope has a liveness bit, which is updated when the scope is closed\n- * (this operation is triggered by {@link ResourceScope#close()}). This bit is consulted prior\n- * to memory access (see {@link #checkValidState()}).\n- * There are two kinds of memory scope: confined memory scope and shared memory scope.\n- * A confined memory scope has an associated owner thread that confines some operations to\n- * associated owner thread such as {@link #close()} or {@link #checkValidState()}.\n- * Shared scopes do not feature an owner thread - meaning their operations can be called, in a racy\n- * manner, by multiple threads. To guarantee temporal safety in the presence of concurrent thread,\n- * shared scopes use a more sophisticated synchronization mechanism, which guarantees that no concurrent\n- * access is possible when a scope is being closed (see {@link jdk.internal.misc.ScopedMemoryAccess}).\n- *\/\n-public abstract non-sealed class ResourceScopeImpl implements ResourceScope, SegmentAllocator {\n-\n-    final ResourceList resourceList;\n-    final Cleaner.Cleanable cleanable;\n-    final Thread owner;\n-\n-    static final int ALIVE = 0;\n-    static final int CLOSING = -1;\n-    static final int CLOSED = -2;\n-\n-    int state = ALIVE;\n-\n-    static final VarHandle STATE;\n-\n-    static {\n-        try {\n-            STATE = MethodHandles.lookup().findVarHandle(ResourceScopeImpl.class, \"state\", int.class);\n-        } catch (Throwable ex) {\n-            throw new ExceptionInInitializerError(ex);\n-        }\n-    }\n-\n-    static final int MAX_FORKS = Integer.MAX_VALUE;\n-\n-    @Override\n-    public void addCloseAction(Runnable runnable) {\n-        Objects.requireNonNull(runnable);\n-        addInternal(ResourceList.ResourceCleanup.ofRunnable(runnable));\n-    }\n-\n-    \/**\n-     * Add a cleanup action. If a failure occurred (because of a add vs. close race), call the cleanup action.\n-     * This semantics is useful when allocating new memory segments, since we first do a malloc\/mmap and _then_\n-     * we register the cleanup (free\/munmap) against the scope; so, if registration fails, we still have to\n-     * cleanup memory. From the perspective of the client, such a failure would manifest as a factory\n-     * returning a segment that is already \"closed\" - which is always possible anyway (e.g. if the scope\n-     * is closed _after_ the cleanup for the segment is registered but _before_ the factory returns the\n-     * new segment to the client). For this reason, it's not worth adding extra complexity to the segment\n-     * initialization logic here - and using an optimistic logic works well in practice.\n-     *\/\n-    public void addOrCleanupIfFail(ResourceList.ResourceCleanup resource) {\n-        try {\n-            addInternal(resource);\n-        } catch (Throwable ex) {\n-            resource.cleanup();\n-        }\n-    }\n-\n-    void addInternal(ResourceList.ResourceCleanup resource) {\n-        try {\n-            checkValidStateSlow();\n-            resourceList.add(resource);\n-        } catch (ScopedMemoryAccess.ScopedAccessError err) {\n-            throw new IllegalStateException(\"Already closed\");\n-        }\n-    }\n-\n-    protected ResourceScopeImpl(Thread owner, ResourceList resourceList, Cleaner cleaner) {\n-        this.owner = owner;\n-        this.resourceList = resourceList;\n-        cleanable = (cleaner != null) ?\n-            cleaner.register(this, resourceList) : null;\n-    }\n-\n-    public static ResourceScopeImpl createConfined(Thread thread, Cleaner cleaner) {\n-        return new ConfinedScope(thread, cleaner);\n-    }\n-\n-    public static ResourceScopeImpl createShared(Cleaner cleaner) {\n-        return new SharedScope(cleaner);\n-    }\n-\n-    @Override\n-    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-        return MemorySegment.allocateNative(bytesSize, bytesAlignment, this);\n-    }\n-\n-    public abstract void release0();\n-\n-    public abstract void acquire0();\n-\n-    @Override\n-    public void keepAlive(ResourceScope target) {\n-        Objects.requireNonNull(target);\n-        if (target == this) {\n-            throw new IllegalArgumentException(\"Invalid target scope.\");\n-        }\n-        ResourceScopeImpl targetImpl = (ResourceScopeImpl)target;\n-        targetImpl.acquire0();\n-        addCloseAction(targetImpl::release0);\n-    }\n-\n-    \/**\n-     * Closes this scope, executing any cleanup action (where provided).\n-     * @throws IllegalStateException if this scope is already closed or if this is\n-     * a confined scope and this method is called outside of the owner thread.\n-     *\/\n-    public void close() {\n-        try {\n-            justClose();\n-            if (cleanable != null) {\n-                cleanable.clean();\n-            } else {\n-                resourceList.cleanup();\n-            }\n-        } finally {\n-            Reference.reachabilityFence(this);\n-        }\n-    }\n-\n-    abstract void justClose();\n-\n-    \/**\n-     * Returns \"owner\" thread of this scope.\n-     * @return owner thread (or null for a shared scope)\n-     *\/\n-    public final Thread ownerThread() {\n-        return owner;\n-    }\n-\n-    \/**\n-     * Returns true, if this scope is still alive. This method may be called in any thread.\n-     * @return {@code true} if this scope is not closed yet.\n-     *\/\n-    public abstract boolean isAlive();\n-\n-    \/**\n-     * This is a faster version of {@link #checkValidStateSlow()}, which is called upon memory access, and which\n-     * relies on invariants associated with the memory scope implementations (volatile access\n-     * to the closed state bit is replaced with plain access). This method should be monomorphic,\n-     * to avoid virtual calls in the memory access hot path. This method is not intended as general purpose method\n-     * and should only be used in the memory access handle hot path; for liveness checks triggered by other API methods,\n-     * please use {@link #checkValidStateSlow()}.\n-     *\/\n-    @ForceInline\n-    public final void checkValidState() {\n-        if (owner != null && owner != Thread.currentThread()) {\n-            throw new IllegalStateException(\"Attempted access outside owning thread\");\n-        }\n-        if (state < ALIVE) {\n-            throw ScopedMemoryAccess.ScopedAccessError.INSTANCE;\n-        }\n-    }\n-\n-    \/**\n-     * Checks that this scope is still alive (see {@link #isAlive()}).\n-     * @throws IllegalStateException if this scope is already closed or if this is\n-     * a confined scope and this method is called outside of the owner thread.\n-     *\/\n-    public final void checkValidStateSlow() {\n-        if (owner != null && Thread.currentThread() != owner) {\n-            throw new IllegalStateException(\"Attempted access outside owning thread\");\n-        } else if (!isAlive()) {\n-            throw new IllegalStateException(\"Already closed\");\n-        }\n-    }\n-\n-    @Override\n-    protected Object clone() throws CloneNotSupportedException {\n-        throw new CloneNotSupportedException();\n-    }\n-\n-    \/**\n-     * The global, always alive, non-closeable, shared scope. Similar to a shared scope, but its {@link #close()} method throws unconditionally.\n-     * Adding new resources to the global scope, does nothing: as the scope can never become not-alive, there is nothing to track.\n-     * Acquiring and or releasing a resource scope similarly does nothing.\n-     *\/\n-    static class GlobalScopeImpl extends SharedScope {\n-\n-        final Object ref;\n-\n-        public GlobalScopeImpl(Object ref) {\n-            super(null);\n-            this.ref = ref;\n-        }\n-\n-        @Override\n-        public void close() {\n-            throw new UnsupportedOperationException(\"Scope cannot be closed\");\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public void release0() {\n-            \/\/ do nothing\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public void acquire0() {\n-            \/\/ do nothing\n-        }\n-\n-        @Override\n-        void addInternal(ResourceList.ResourceCleanup resource) {\n-            \/\/ do nothing\n-        }\n-\n-        @Override\n-        public boolean isAlive() {\n-            return true;\n-        }\n-    }\n-\n-    public static final ResourceScopeImpl GLOBAL = new GlobalScopeImpl(null);\n-\n-    public static ResourceScopeImpl heapScope(Object ref) {\n-        return new GlobalScopeImpl(ref);\n-    }\n-\n-    \/**\n-     * A list of all cleanup actions associated with a resource scope. Cleanup actions are modelled as instances\n-     * of the {@link ResourceCleanup} class, and, together, form a linked list. Depending on whether a scope\n-     * is shared or confined, different implementations of this class will be used, see {@link ConfinedScope.ConfinedResourceList}\n-     * and {@link SharedScope.SharedResourceList}.\n-     *\/\n-    public abstract static class ResourceList implements Runnable {\n-        ResourceCleanup fst;\n-\n-        abstract void add(ResourceCleanup cleanup);\n-\n-        abstract void cleanup();\n-\n-        public final void run() {\n-            cleanup(); \/\/ cleaner interop\n-        }\n-\n-        static void cleanup(ResourceCleanup first) {\n-            ResourceCleanup current = first;\n-            while (current != null) {\n-                current.cleanup();\n-                current = current.next;\n-            }\n-        }\n-\n-        public abstract static class ResourceCleanup {\n-            ResourceCleanup next;\n-\n-            public abstract void cleanup();\n-\n-            static final ResourceCleanup CLOSED_LIST = new ResourceCleanup() {\n-                @Override\n-                public void cleanup() {\n-                    throw new IllegalStateException(\"This resource list has already been closed!\");\n-                }\n-            };\n-\n-            static ResourceCleanup ofRunnable(Runnable cleanupAction) {\n-                return new ResourceCleanup() {\n-                    @Override\n-                    public void cleanup() {\n-                        cleanupAction.run();\n-                    }\n-                };\n-            }\n-        }\n-\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ResourceScopeImpl.java","additions":0,"deletions":311,"binary":false,"changes":311,"status":"deleted"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -31,1 +31,5 @@\n-    ResourceScope scope();\n+    MemorySessionImpl sessionImpl();\n+\n+    static MemorySessionImpl toSessionImpl(MemorySession session) {\n+        return ((Scoped)session).sessionImpl();\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Scoped.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,151 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.foreign;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.lang.ref.Cleaner;\n-import jdk.internal.misc.ScopedMemoryAccess;\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-\/**\n- * A shared scope, which can be shared across multiple threads. Closing a shared scope has to ensure that\n- * (i) only one thread can successfully close a scope (e.g. in a close vs. close race) and that\n- * (ii) no other thread is accessing the memory associated with this scope while the segment is being\n- * closed. To ensure the former condition, a CAS is performed on the liveness bit. Ensuring the latter\n- * is trickier, and require a complex synchronization protocol (see {@link jdk.internal.misc.ScopedMemoryAccess}).\n- * Since it is the responsibility of the closing thread to make sure that no concurrent access is possible,\n- * checking the liveness bit upon access can be performed in plain mode, as in the confined case.\n- *\/\n-class SharedScope extends ResourceScopeImpl {\n-\n-    private static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n-\n-    SharedScope(Cleaner cleaner) {\n-        super(null, new SharedResourceList(), cleaner);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public void acquire0() {\n-        int value;\n-        do {\n-            value = (int) STATE.getVolatile(this);\n-            if (value < ALIVE) {\n-                \/\/segment is not alive!\n-                throw new IllegalStateException(\"Already closed\");\n-            } else if (value == MAX_FORKS) {\n-                \/\/overflow\n-                throw new IllegalStateException(\"Scope keep alive limit exceeded\");\n-            }\n-        } while (!STATE.compareAndSet(this, value, value + 1));\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public void release0() {\n-        int value;\n-        do {\n-            value = (int) STATE.getVolatile(this);\n-            if (value <= ALIVE) {\n-                \/\/cannot get here - we can't close segment twice\n-                throw new IllegalStateException(\"Already closed\");\n-            }\n-        } while (!STATE.compareAndSet(this, value, value - 1));\n-    }\n-\n-    void justClose() {\n-        int prevState = (int) STATE.compareAndExchange(this, ALIVE, CLOSING);\n-        if (prevState < 0) {\n-            throw new IllegalStateException(\"Already closed\");\n-        } else if (prevState != ALIVE) {\n-            throw new IllegalStateException(\"Scope is kept alive by \" + prevState + \" scopes\");\n-        }\n-        boolean success = SCOPED_MEMORY_ACCESS.closeScope(this);\n-        STATE.setVolatile(this, success ? CLOSED : ALIVE);\n-        if (!success) {\n-            throw new IllegalStateException(\"Cannot close while another thread is accessing the segment\");\n-        }\n-    }\n-\n-    @Override\n-    public boolean isAlive() {\n-        return (int) STATE.getVolatile(this) != CLOSED;\n-    }\n-\n-    \/**\n-     * A shared resource list; this implementation has to handle add vs. add races, as well as add vs. cleanup races.\n-     *\/\n-    static class SharedResourceList extends ResourceList {\n-\n-        static final VarHandle FST;\n-\n-        static {\n-            try {\n-                FST = MethodHandles.lookup().findVarHandle(ResourceList.class, \"fst\", ResourceCleanup.class);\n-            } catch (Throwable ex) {\n-                throw new ExceptionInInitializerError();\n-            }\n-        }\n-\n-        @Override\n-        void add(ResourceCleanup cleanup) {\n-            while (true) {\n-                ResourceCleanup prev = (ResourceCleanup) FST.getVolatile(this);\n-                if (prev == ResourceCleanup.CLOSED_LIST) {\n-                    \/\/ too late\n-                    throw new IllegalStateException(\"Already closed\");\n-                }\n-                cleanup.next = prev;\n-                if (FST.compareAndSet(this, prev, cleanup)) {\n-                    return; \/\/victory\n-                }\n-                \/\/ keep trying\n-            }\n-        }\n-\n-        void cleanup() {\n-            \/\/ At this point we are only interested about add vs. close races - not close vs. close\n-            \/\/ (because MemoryScope::justClose ensured that this thread won the race to close the scope).\n-            \/\/ So, the only \"bad\" thing that could happen is that some other thread adds to this list\n-            \/\/ while we're closing it.\n-            if (FST.getAcquire(this) != ResourceCleanup.CLOSED_LIST) {\n-                \/\/ok now we're really closing down\n-                ResourceCleanup prev = null;\n-                while (true) {\n-                    prev = (ResourceCleanup) FST.getVolatile(this);\n-                    \/\/ no need to check for DUMMY, since only one thread can get here!\n-                    if (FST.compareAndSet(this, prev, ResourceCleanup.CLOSED_LIST)) {\n-                        break;\n-                    }\n-                }\n-                cleanup(prev);\n-            } else {\n-                throw new IllegalStateException(\"Attempt to cleanup an already closed resource list\");\n-            }\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedScope.java","additions":0,"deletions":151,"binary":false,"changes":151,"status":"deleted"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.ref.Cleaner;\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * A shared session, which can be shared across multiple threads. Closing a shared session has to ensure that\n+ * (i) only one thread can successfully close a session (e.g. in a close vs. close race) and that\n+ * (ii) no other thread is accessing the memory associated with this session while the segment is being\n+ * closed. To ensure the former condition, a CAS is performed on the liveness bit. Ensuring the latter\n+ * is trickier, and require a complex synchronization protocol (see {@link jdk.internal.misc.ScopedMemoryAccess}).\n+ * Since it is the responsibility of the closing thread to make sure that no concurrent access is possible,\n+ * checking the liveness bit upon access can be performed in plain mode, as in the confined case.\n+ *\/\n+class SharedSession extends MemorySessionImpl {\n+\n+    private static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n+    SharedSession(Cleaner cleaner) {\n+        super(null, new SharedResourceList(), cleaner);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public void acquire0() {\n+        int value;\n+        do {\n+            value = (int) STATE.getVolatile(this);\n+            if (value < OPEN) {\n+                \/\/segment is not open!\n+                throw new IllegalStateException(\"Already closed\");\n+            } else if (value == MAX_FORKS) {\n+                \/\/overflow\n+                throw new IllegalStateException(\"Session acquire limit exceeded\");\n+            }\n+        } while (!STATE.compareAndSet(this, value, value + 1));\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public void release0() {\n+        int value;\n+        do {\n+            value = (int) STATE.getVolatile(this);\n+            if (value <= OPEN) {\n+                \/\/cannot get here - we can't close segment twice\n+                throw new IllegalStateException(\"Already closed\");\n+            }\n+        } while (!STATE.compareAndSet(this, value, value - 1));\n+    }\n+\n+    void justClose() {\n+        int prevState = (int) STATE.compareAndExchange(this, OPEN, CLOSING);\n+        if (prevState < 0) {\n+            throw new IllegalStateException(\"Already closed\");\n+        } else if (prevState != OPEN) {\n+            throw new IllegalStateException(\"Session is acquired by \" + prevState + \" clients\");\n+        }\n+        boolean success = SCOPED_MEMORY_ACCESS.closeScope(this);\n+        STATE.setVolatile(this, success ? CLOSED : OPEN);\n+        if (!success) {\n+            throw new IllegalStateException(\"Cannot close while another thread is accessing the segment\");\n+        }\n+    }\n+\n+    @Override\n+    public boolean isAlive() {\n+        return (int) STATE.getVolatile(this) != CLOSED;\n+    }\n+\n+    \/**\n+     * A shared resource list; this implementation has to handle add vs. add races, as well as add vs. cleanup races.\n+     *\/\n+    static class SharedResourceList extends ResourceList {\n+\n+        static final VarHandle FST;\n+\n+        static {\n+            try {\n+                FST = MethodHandles.lookup().findVarHandle(ResourceList.class, \"fst\", ResourceCleanup.class);\n+            } catch (Throwable ex) {\n+                throw new ExceptionInInitializerError();\n+            }\n+        }\n+\n+        @Override\n+        void add(ResourceCleanup cleanup) {\n+            while (true) {\n+                ResourceCleanup prev = (ResourceCleanup) FST.getVolatile(this);\n+                if (prev == ResourceCleanup.CLOSED_LIST) {\n+                    \/\/ too late\n+                    throw new IllegalStateException(\"Already closed\");\n+                }\n+                cleanup.next = prev;\n+                if (FST.compareAndSet(this, prev, cleanup)) {\n+                    return; \/\/victory\n+                }\n+                \/\/ keep trying\n+            }\n+        }\n+\n+        void cleanup() {\n+            \/\/ At this point we are only interested about add vs. close races - not close vs. close\n+            \/\/ (because MemorySessionImpl::justClose ensured that this thread won the race to close the session).\n+            \/\/ So, the only \"bad\" thing that could happen is that some other thread adds to this list\n+            \/\/ while we're closing it.\n+            if (FST.getAcquire(this) != ResourceCleanup.CLOSED_LIST) {\n+                \/\/ok now we're really closing down\n+                ResourceCleanup prev = null;\n+                while (true) {\n+                    prev = (ResourceCleanup) FST.getVolatile(this);\n+                    \/\/ no need to check for DUMMY, since only one thread can get here!\n+                    if (FST.compareAndSet(this, prev, ResourceCleanup.CLOSED_LIST)) {\n+                        break;\n+                    }\n+                }\n+                cleanup(prev);\n+            } else {\n+                throw new IllegalStateException(\"Attempt to cleanup an already closed resource list\");\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedSession.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -77,1 +77,1 @@\n-                ADDRESS.byteSize() * numSymbols, ResourceScope.globalScope());\n+                ADDRESS.byteSize() * numSymbols, MemorySession.global());\n@@ -80,1 +80,1 @@\n-                .map(symbol -> NativeSymbol.ofAddress(symbol.name(), funcs.getAtIndex(ADDRESS, symbol.ordinal()), ResourceScope.globalScope()));\n+                .map(symbol -> NativeSymbol.ofAddress(symbol.name(), funcs.getAtIndex(ADDRESS, symbol.ordinal()), MemorySession.global()));\n@@ -97,1 +97,1 @@\n-                        Optional.of(NativeSymbol.ofAddress(name, MemoryAddress.ofLong(addr), ResourceScope.globalScope()));\n+                        Optional.of(NativeSymbol.ofAddress(name, MemoryAddress.ofLong(addr), MemorySession.global()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.foreign.Scoped;\n@@ -34,0 +35,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -35,1 +37,0 @@\n-import java.lang.foreign.ResourceScope;\n@@ -63,2 +64,2 @@\n-    public NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n-        Objects.requireNonNull(scope);\n+    public NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, MemorySession session) {\n+        Objects.requireNonNull(session);\n@@ -73,1 +74,1 @@\n-        NativeSymbol symb =  arrangeUpcall(target, target.type(), function, scope);\n+        NativeSymbol symb =  arrangeUpcall(target, target.type(), function, Scoped.toSessionImpl(session));\n@@ -78,1 +79,1 @@\n-                                                  FunctionDescriptor function, ResourceScope scope);\n+                                                  FunctionDescriptor function, MemorySession session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -44,1 +44,1 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -208,1 +208,1 @@\n-     * the allocation operation, or {@link ToSegment} bindings, by providing the {@link ResourceScope} that\n+     * the allocation operation, or {@link ToSegment} bindings, by providing the {@link MemorySession} that\n@@ -213,1 +213,1 @@\n-        private final ResourceScope scope;\n+        private final MemorySession session;\n@@ -215,1 +215,1 @@\n-        private Context(SegmentAllocator allocator, ResourceScope scope) {\n+        private Context(SegmentAllocator allocator, MemorySession session) {\n@@ -217,1 +217,1 @@\n-            this.scope = scope;\n+            this.session = session;\n@@ -224,2 +224,2 @@\n-        public ResourceScope scope() {\n-            return scope;\n+        public MemorySession session() {\n+            return session;\n@@ -230,1 +230,1 @@\n-            scope().close();\n+            session().close();\n@@ -234,1 +234,1 @@\n-         * Create a binding context from given native scope.\n+         * Create a binding context from given native session.\n@@ -237,2 +237,2 @@\n-            ResourceScope scope = ResourceScope.newConfinedScope();\n-            return new Context(SegmentAllocator.newNativeArena(size, scope), scope);\n+            MemorySession session = MemorySession.openConfined();\n+            return new Context(SegmentAllocator.newNativeArena(size, session), session);\n@@ -243,1 +243,1 @@\n-         * the context's scope is accessed.\n+         * the context's session is accessed.\n@@ -248,1 +248,1 @@\n-                public ResourceScope scope() {\n+                public MemorySession session() {\n@@ -255,1 +255,1 @@\n-         * Create a binding context from given scope. The resulting context will throw when\n+         * Create a binding context from given session. The resulting context will throw when\n@@ -258,3 +258,3 @@\n-        public static Context ofScope() {\n-            ResourceScope scope = ResourceScope.newConfinedScope();\n-            return new Context(null, scope) {\n+        public static Context ofSession() {\n+            MemorySession session = MemorySession.openConfined();\n+            return new Context(null, session) {\n@@ -267,1 +267,1 @@\n-         * Dummy binding context. Throws exceptions when attempting to access scope, return a throwing allocator, and has\n+         * Dummy binding context. Throws exceptions when attempting to access session, return a throwing allocator, and has\n@@ -277,1 +277,1 @@\n-            public ResourceScope scope() {\n+            public MemorySession session() {\n@@ -901,1 +901,1 @@\n-            return MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size, (ResourceScopeImpl) context.scope);\n+            return MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size, (MemorySessionImpl) context.session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -49,0 +49,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -50,1 +51,0 @@\n-import java.lang.foreign.ResourceScope;\n@@ -82,1 +82,1 @@\n-    private static final String OF_SCOPE_DESC = methodType(Binding.Context.class).descriptorString();\n+    private static final String OF_SESSION_DESC = methodType(Binding.Context.class).descriptorString();\n@@ -84,1 +84,2 @@\n-    private static final String SCOPE_DESC = methodType(ResourceScope.class).descriptorString();\n+    private static final String SESSION_DESC = methodType(MemorySession.class).descriptorString();\n+    private static final String SESSION_IMPL_DESC = methodType(MemorySessionImpl.class).descriptorString();\n@@ -90,1 +91,1 @@\n-    private static final String OF_LONG_UNCHECKED_DESC = methodType(MemorySegment.class, long.class, long.class, ResourceScopeImpl.class).descriptorString();\n+    private static final String OF_LONG_UNCHECKED_DESC = methodType(MemorySegment.class, long.class, long.class, MemorySessionImpl.class).descriptorString();\n@@ -275,1 +276,1 @@\n-            emitInvokeStatic(Binding.Context.class, \"ofScope\", OF_SCOPE_DESC);\n+            emitInvokeStatic(Binding.Context.class, \"ofSession\", OF_SESSION_DESC);\n@@ -455,1 +456,1 @@\n-        emitInvokeInterface(Scoped.class, \"scope\", SCOPE_DESC);\n+        emitInvokeInterface(Scoped.class, \"sessionImpl\", SESSION_IMPL_DESC);\n@@ -472,2 +473,2 @@\n-        emitCheckCast(ResourceScopeImpl.class);\n-        emitInvokeVirtual(ResourceScopeImpl.class, \"acquire0\", ACQUIRE0_DESC); \/\/ call acquire on the other\n+        emitCheckCast(MemorySessionImpl.class);\n+        emitInvokeVirtual(MemorySessionImpl.class, \"acquire0\", ACQUIRE0_DESC); \/\/ call acquire on the other\n@@ -492,2 +493,2 @@\n-            emitCheckCast(ResourceScopeImpl.class);\n-            emitInvokeVirtual(ResourceScopeImpl.class, \"release0\", RELEASE0_DESC);\n+            emitCheckCast(MemorySessionImpl.class);\n+            emitInvokeVirtual(MemorySessionImpl.class, \"release0\", RELEASE0_DESC);\n@@ -519,1 +520,1 @@\n-    private void emitLoadInternalScope() {\n+    private void emitLoadInternalSession() {\n@@ -522,1 +523,1 @@\n-        emitInvokeVirtual(Binding.Context.class, \"scope\", SCOPE_DESC);\n+        emitInvokeVirtual(Binding.Context.class, \"session\", SESSION_DESC);\n@@ -543,2 +544,2 @@\n-        emitLoadInternalScope();\n-        emitCheckCast(ResourceScopeImpl.class);\n+        emitLoadInternalSession();\n+        emitCheckCast(MemorySessionImpl.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -32,1 +33,0 @@\n-import java.lang.foreign.ResourceScope;\n@@ -41,1 +41,0 @@\n-import static java.lang.invoke.MethodHandles.dropArguments;\n@@ -66,1 +65,1 @@\n-    public static NativeSymbol make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence, ResourceScope scope) {\n+    public static NativeSymbol make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence, MemorySession session) {\n@@ -98,1 +97,1 @@\n-        return UpcallStubs.makeUpcall(entryPoint, scope);\n+        return UpcallStubs.makeUpcall(entryPoint, session);\n@@ -135,1 +134,1 @@\n-                : Binding.Context.ofScope();\n+                : Binding.Context.ofSession();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -45,0 +46,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -46,1 +48,0 @@\n-import java.lang.foreign.ResourceScope;\n@@ -381,1 +382,1 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, MemorySession session) {\n@@ -383,4 +384,4 @@\n-            case Win64 -> Windowsx64Linker.newVaList(actions, scope);\n-            case SysV -> SysVx64Linker.newVaList(actions, scope);\n-            case LinuxAArch64 -> LinuxAArch64Linker.newVaList(actions, scope);\n-            case MacOsAArch64 -> MacOsAArch64Linker.newVaList(actions, scope);\n+            case Win64 -> Windowsx64Linker.newVaList(actions, session);\n+            case SysV -> SysVx64Linker.newVaList(actions, session);\n+            case LinuxAArch64 -> LinuxAArch64Linker.newVaList(actions, session);\n+            case MacOsAArch64 -> MacOsAArch64Linker.newVaList(actions, session);\n@@ -390,1 +391,1 @@\n-    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n+    public static VaList newVaListOfAddress(MemoryAddress ma, MemorySession session) {\n@@ -392,4 +393,4 @@\n-            case Win64 -> Windowsx64Linker.newVaListOfAddress(ma, scope);\n-            case SysV -> SysVx64Linker.newVaListOfAddress(ma, scope);\n-            case LinuxAArch64 -> LinuxAArch64Linker.newVaListOfAddress(ma, scope);\n-            case MacOsAArch64 -> MacOsAArch64Linker.newVaListOfAddress(ma, scope);\n+            case Win64 -> Windowsx64Linker.newVaListOfAddress(ma, session);\n+            case SysV -> SysVx64Linker.newVaListOfAddress(ma, session);\n+            case LinuxAArch64 -> LinuxAArch64Linker.newVaListOfAddress(ma, session);\n+            case MacOsAArch64 -> MacOsAArch64Linker.newVaListOfAddress(ma, session);\n@@ -479,2 +480,2 @@\n-        public ResourceScope scope() {\n-            return ResourceScope.globalScope();\n+        public MemorySessionImpl sessionImpl() {\n+            return (MemorySessionImpl)MemorySession.global();\n@@ -492,0 +493,5 @@\n+\n+        @Override\n+        public MemorySession session() {\n+            return MemorySessionImpl.GLOBAL;\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":19,"deletions":13,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -29,1 +29,3 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n+\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -31,1 +33,0 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n@@ -51,2 +52,2 @@\n-    static NativeSymbol makeUpcall(long entry, ResourceScope scope) {\n-        ((ResourceScopeImpl)scope).addOrCleanupIfFail(new ResourceScopeImpl.ResourceList.ResourceCleanup() {\n+    static NativeSymbol makeUpcall(long entry, MemorySession session) {\n+        ((MemorySessionImpl)session).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n@@ -58,1 +59,1 @@\n-        return new NativeSymbolImpl(\"upcall:\" + Long.toHexString(entry), MemoryAddress.ofLong(entry), scope);\n+        return new NativeSymbolImpl(\"upcall:\" + Long.toHexString(entry), MemoryAddress.ofLong(entry), ((MemorySessionImpl)session));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -158,1 +158,1 @@\n-    public NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n+    public NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, MemorySession session) {\n@@ -165,1 +165,1 @@\n-        return ProgrammableUpcallHandler.make(C, target, bindings.callingSequence,scope);\n+        return ProgrammableUpcallHandler.make(C, target, bindings.callingSequence,session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -62,2 +62,2 @@\n-    protected NativeSymbol arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, ResourceScope scope) {\n-        return CallArranger.LINUX.arrangeUpcall(target, targetType, function, scope);\n+    protected NativeSymbol arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession session) {\n+        return CallArranger.LINUX.arrangeUpcall(target, targetType, function, session);\n@@ -66,2 +66,2 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n-        LinuxAArch64VaList.Builder builder = LinuxAArch64VaList.builder(scope);\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, MemorySession session) {\n+        LinuxAArch64VaList.Builder builder = LinuxAArch64VaList.builder(session);\n@@ -72,2 +72,2 @@\n-    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n-        return LinuxAArch64VaList.ofAddress(ma, scope);\n+    public static VaList newVaListOfAddress(MemoryAddress ma, MemorySession session) {\n+        return LinuxAArch64VaList.ofAddress(ma, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -41,1 +41,2 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n+\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n@@ -43,0 +44,1 @@\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -119,1 +121,1 @@\n-    private static LinuxAArch64VaList readFromSegment(MemorySegment segment) {\n+    private static LinuxAArch64VaList readFromSegment(MemorySegment segment, MemorySession session) {\n@@ -121,1 +123,1 @@\n-                MAX_GP_OFFSET, segment.scope());\n+                MAX_GP_OFFSET, session);\n@@ -124,1 +126,1 @@\n-                MAX_FP_OFFSET, segment.scope());\n+                MAX_FP_OFFSET, session);\n@@ -130,2 +132,2 @@\n-        ResourceScope scope = ResourceScope.newImplicitScope();\n-        scope.addCloseAction(() -> U.freeMemory(ptr));\n+        MemorySession session = MemorySession.openImplicit();\n+        session.addCloseAction(() -> U.freeMemory(ptr));\n@@ -133,1 +135,1 @@\n-                LAYOUT.byteSize(), scope);\n+                LAYOUT.byteSize(), session);\n@@ -255,1 +257,1 @@\n-                    MemorySegment slice = MemorySegment.ofAddress(stackPtr(), layout.byteSize(), scope());\n+                    MemorySegment slice = MemorySegment.ofAddress(stackPtr(), layout.byteSize(), sessionImpl());\n@@ -263,1 +265,1 @@\n-                    MemorySegment slice = MemorySegment.ofAddress(stackPtr(), layout.byteSize(), scope());\n+                    MemorySegment slice = MemorySegment.ofAddress(stackPtr(), layout.byteSize(), sessionImpl());\n@@ -305,1 +307,1 @@\n-                    MemorySegment slice = MemorySegment.ofAddress(ptr, layout.byteSize(), scope());\n+                    MemorySegment slice = MemorySegment.ofAddress(ptr, layout.byteSize(), sessionImpl());\n@@ -329,1 +331,1 @@\n-        ((ResourceScopeImpl)segment.scope()).checkValidStateSlow();\n+        ((AbstractMemorySegmentImpl)segment).checkValidState();\n@@ -346,2 +348,6 @@\n-    static LinuxAArch64VaList.Builder builder(ResourceScope scope) {\n-        return new LinuxAArch64VaList.Builder(scope);\n+    static LinuxAArch64VaList.Builder builder(MemorySession session) {\n+        return new LinuxAArch64VaList.Builder(session);\n+    }\n+\n+    public static VaList ofAddress(MemoryAddress ma, MemorySession session) {\n+        return readFromSegment(MemorySegment.ofAddress(ma, LAYOUT.byteSize(), session), session);\n@@ -350,2 +356,3 @@\n-    public static VaList ofAddress(MemoryAddress ma, ResourceScope scope) {\n-        return readFromSegment(MemorySegment.ofAddress(ma, LAYOUT.byteSize(), scope));\n+    @Override\n+    public MemorySessionImpl sessionImpl() {\n+        return Scoped.toSessionImpl(segment.session());\n@@ -355,2 +362,2 @@\n-    public ResourceScope scope() {\n-        return segment.scope();\n+    public MemorySession session() {\n+        return new MemorySessionImpl.NonCloseableView(sessionImpl());\n@@ -361,1 +368,1 @@\n-        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.scope());\n+        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, sessionImpl());\n@@ -398,1 +405,1 @@\n-        private final ResourceScope scope;\n+        private final MemorySession session;\n@@ -406,4 +413,4 @@\n-        Builder(ResourceScope scope) {\n-            this.scope = scope;\n-            this.gpRegs = MemorySegment.allocateNative(LAYOUT_GP_REGS, scope);\n-            this.fpRegs = MemorySegment.allocateNative(LAYOUT_FP_REGS, scope);\n+        Builder(MemorySession session) {\n+            this.session = session;\n+            this.gpRegs = MemorySegment.allocateNative(LAYOUT_GP_REGS, session);\n+            this.fpRegs = MemorySegment.allocateNative(LAYOUT_FP_REGS, session);\n@@ -502,1 +509,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(session);\n@@ -525,2 +532,2 @@\n-            assert gpRegs.scope().ownerThread() == vaListSegment.scope().ownerThread();\n-            assert fpRegs.scope().ownerThread() == vaListSegment.scope().ownerThread();\n+            assert gpRegs.session().ownerThread() == vaListSegment.session().ownerThread();\n+            assert fpRegs.session().ownerThread() == vaListSegment.session().ownerThread();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":34,"deletions":27,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -62,2 +62,2 @@\n-    protected NativeSymbol arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, ResourceScope scope) {\n-        return CallArranger.MACOS.arrangeUpcall(target, targetType, function, scope);\n+    protected NativeSymbol arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession session) {\n+        return CallArranger.MACOS.arrangeUpcall(target, targetType, function, session);\n@@ -66,2 +66,2 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n-        MacOsAArch64VaList.Builder builder = MacOsAArch64VaList.builder(scope);\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, MemorySession session) {\n+        MacOsAArch64VaList.Builder builder = MacOsAArch64VaList.builder(session);\n@@ -72,2 +72,2 @@\n-    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n-        return MacOsAArch64VaList.ofAddress(ma, scope);\n+    public static VaList newVaListOfAddress(MemoryAddress ma, MemorySession session) {\n+        return MacOsAArch64VaList.ofAddress(ma, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -42,1 +42,2 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n+\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n@@ -44,0 +45,1 @@\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -63,1 +65,0 @@\n-    private final ResourceScope scope;\n@@ -65,1 +66,1 @@\n-    private MacOsAArch64VaList(MemorySegment segment, ResourceScope scope) {\n+    private MacOsAArch64VaList(MemorySegment segment) {\n@@ -67,1 +68,0 @@\n-        this.scope = scope;\n@@ -112,1 +112,1 @@\n-                    MemorySegment struct = MemorySegment.ofAddress(structAddr, layout.byteSize(), scope());\n+                    MemorySegment struct = MemorySegment.ofAddress(structAddr, layout.byteSize(), sessionImpl());\n@@ -137,1 +137,1 @@\n-        ((ResourceScopeImpl)scope).checkValidStateSlow();\n+        ((AbstractMemorySegmentImpl)segment).checkValidState();\n@@ -148,3 +148,7 @@\n-    static MacOsAArch64VaList ofAddress(MemoryAddress addr, ResourceScope scope) {\n-        MemorySegment segment = MemorySegment.ofAddress(addr, Long.MAX_VALUE, scope);\n-        return new MacOsAArch64VaList(segment, scope);\n+    static MacOsAArch64VaList ofAddress(MemoryAddress addr, MemorySession session) {\n+        MemorySegment segment = MemorySegment.ofAddress(addr, Long.MAX_VALUE, session);\n+        return new MacOsAArch64VaList(segment);\n+    }\n+\n+    static Builder builder(MemorySession session) {\n+        return new Builder(session);\n@@ -153,2 +157,3 @@\n-    static Builder builder(ResourceScope scope) {\n-        return new Builder(scope);\n+    @Override\n+    public MemorySessionImpl sessionImpl() {\n+        return Scoped.toSessionImpl(segment.session());\n@@ -158,2 +163,2 @@\n-    public ResourceScope scope() {\n-        return scope;\n+    public MemorySession session() {\n+        return new MemorySessionImpl.NonCloseableView(sessionImpl());\n@@ -164,2 +169,2 @@\n-        ((ResourceScopeImpl)scope).checkValidStateSlow();\n-        return new MacOsAArch64VaList(segment, scope);\n+        ((AbstractMemorySegmentImpl)segment).checkValidState();\n+        return new MacOsAArch64VaList(segment);\n@@ -175,1 +180,1 @@\n-        private final ResourceScope scope;\n+        private final MemorySession session;\n@@ -178,3 +183,3 @@\n-        public Builder(ResourceScope scope) {\n-            ((ResourceScopeImpl)scope).checkValidStateSlow();\n-            this.scope = scope;\n+        public Builder(MemorySession session) {\n+            ((MemorySessionImpl)session).checkValidStateSlow();\n+            this.session = session;\n@@ -220,1 +225,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(session);\n@@ -253,1 +258,1 @@\n-            return new MacOsAArch64VaList(segment, scope);\n+            return new MacOsAArch64VaList(segment);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":27,"deletions":22,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -134,1 +134,1 @@\n-    public static NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n+    public static NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, MemorySession session) {\n@@ -141,1 +141,1 @@\n-        return ProgrammableUpcallHandler.make(CSysV, target, bindings.callingSequence, scope);\n+        return ProgrammableUpcallHandler.make(CSysV, target, bindings.callingSequence, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -41,1 +41,2 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n+\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n@@ -43,0 +44,1 @@\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -133,2 +135,2 @@\n-        ResourceScope scope = ResourceScope.newImplicitScope();\n-        scope.addCloseAction(() -> U.freeMemory(ptr));\n+        MemorySession session = MemorySession.openImplicit();\n+        session.addCloseAction(() -> U.freeMemory(ptr));\n@@ -136,1 +138,1 @@\n-                LAYOUT.byteSize(), scope);\n+                LAYOUT.byteSize(), session);\n@@ -178,1 +180,1 @@\n-                LAYOUT_REG_SAVE_AREA.byteSize(), segment.scope());\n+                LAYOUT_REG_SAVE_AREA.byteSize(), segment.session());\n@@ -229,1 +231,1 @@\n-                    MemorySegment slice = MemorySegment.ofAddress(stackPtr(), layout.byteSize(), scope());\n+                    MemorySegment slice = MemorySegment.ofAddress(stackPtr(), layout.byteSize(), sessionImpl());\n@@ -237,2 +239,2 @@\n-                    try (ResourceScope localScope = ResourceScope.newConfinedScope()) {\n-                        MemorySegment slice = MemorySegment.ofAddress(stackPtr(), layout.byteSize(), localScope);\n+                    try (MemorySession localSession = MemorySession.openConfined()) {\n+                        MemorySegment slice = MemorySegment.ofAddress(stackPtr(), layout.byteSize(), localSession);\n@@ -284,1 +286,1 @@\n-        ((ResourceScopeImpl)segment.scope()).checkValidStateSlow();\n+        ((AbstractMemorySegmentImpl)segment).checkValidState();\n@@ -298,2 +300,6 @@\n-    static SysVVaList.Builder builder(ResourceScope scope) {\n-        return new SysVVaList.Builder(scope);\n+    static SysVVaList.Builder builder(MemorySession session) {\n+        return new SysVVaList.Builder(session);\n+    }\n+\n+    public static VaList ofAddress(MemoryAddress ma, MemorySession session) {\n+        return readFromSegment(MemorySegment.ofAddress(ma, LAYOUT.byteSize(), session));\n@@ -302,2 +308,3 @@\n-    public static VaList ofAddress(MemoryAddress ma, ResourceScope scope) {\n-        return readFromSegment(MemorySegment.ofAddress(ma, LAYOUT.byteSize(), scope));\n+    @Override\n+    public MemorySessionImpl sessionImpl() {\n+        return Scoped.toSessionImpl(segment.session());\n@@ -307,2 +314,2 @@\n-    public ResourceScope scope() {\n-        return segment.scope();\n+    public MemorySession session() {\n+        return new MemorySessionImpl.NonCloseableView(sessionImpl());\n@@ -313,1 +320,1 @@\n-        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.scope());\n+        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, sessionImpl());\n@@ -339,1 +346,1 @@\n-        private final ResourceScope scope;\n+        private final MemorySession session;\n@@ -345,3 +352,3 @@\n-        public Builder(ResourceScope scope) {\n-            this.scope = scope;\n-            this.reg_save_area = MemorySegment.allocateNative(LAYOUT_REG_SAVE_AREA, scope);\n+        public Builder(MemorySession session) {\n+            this.session = session;\n+            this.reg_save_area = MemorySegment.allocateNative(LAYOUT_REG_SAVE_AREA, session);\n@@ -426,1 +433,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(session);\n@@ -451,1 +458,1 @@\n-            assert reg_save_area.scope().ownerThread() == vaListSegment.scope().ownerThread();\n+            assert reg_save_area.session().ownerThread() == vaListSegment.session().ownerThread();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":30,"deletions":23,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -66,2 +66,2 @@\n-    protected NativeSymbol arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, ResourceScope scope) {\n-        return CallArranger.arrangeUpcall(target, targetType, function, scope);\n+    protected NativeSymbol arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession session) {\n+        return CallArranger.arrangeUpcall(target, targetType, function, session);\n@@ -70,2 +70,2 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n-        SysVVaList.Builder builder = SysVVaList.builder(scope);\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, MemorySession session) {\n+        SysVVaList.Builder builder = SysVVaList.builder(session);\n@@ -76,2 +76,2 @@\n-    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n-        return SysVVaList.ofAddress(ma, scope);\n+    public static VaList newVaListOfAddress(MemoryAddress ma, MemorySession session) {\n+        return SysVVaList.ofAddress(ma, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -134,1 +134,1 @@\n-    public static NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n+    public static NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, MemorySession session) {\n@@ -141,1 +141,1 @@\n-        return ProgrammableUpcallHandler.make(CWindows, target, bindings.callingSequence, scope);\n+        return ProgrammableUpcallHandler.make(CWindows, target, bindings.callingSequence, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -42,1 +42,2 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n+\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n@@ -44,0 +45,1 @@\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -72,1 +74,0 @@\n-    private final ResourceScope scope;\n@@ -74,1 +75,1 @@\n-    private WinVaList(MemorySegment segment, ResourceScope scope) {\n+    private WinVaList(MemorySegment segment) {\n@@ -76,1 +77,0 @@\n-        this.scope = scope;\n@@ -121,1 +121,1 @@\n-                    MemorySegment struct = MemorySegment.ofAddress(structAddr, layout.byteSize(), scope());\n+                    MemorySegment struct = MemorySegment.ofAddress(structAddr, layout.byteSize(), session());\n@@ -141,1 +141,1 @@\n-        ((ResourceScopeImpl)scope).checkValidStateSlow();\n+        ((AbstractMemorySegmentImpl)segment).checkValidState();\n@@ -146,3 +146,7 @@\n-    static WinVaList ofAddress(MemoryAddress addr, ResourceScope scope) {\n-        MemorySegment segment = MemorySegment.ofAddress(addr, Long.MAX_VALUE, scope);\n-        return new WinVaList(segment, scope);\n+    static WinVaList ofAddress(MemoryAddress addr, MemorySession session) {\n+        MemorySegment segment = MemorySegment.ofAddress(addr, Long.MAX_VALUE, session);\n+        return new WinVaList(segment);\n+    }\n+\n+    static Builder builder(MemorySession session) {\n+        return new Builder(session);\n@@ -151,2 +155,3 @@\n-    static Builder builder(ResourceScope scope) {\n-        return new Builder(scope);\n+    @Override\n+    public MemorySessionImpl sessionImpl() {\n+        return Scoped.toSessionImpl(segment.session());\n@@ -156,2 +161,2 @@\n-    public ResourceScope scope() {\n-        return scope;\n+    public MemorySession session() {\n+        return new MemorySessionImpl.NonCloseableView(sessionImpl());\n@@ -162,2 +167,2 @@\n-        ((ResourceScopeImpl)scope).checkValidStateSlow();\n-        return new WinVaList(segment, scope);\n+        ((AbstractMemorySegmentImpl)segment).checkValidState();\n+        return new WinVaList(segment);\n@@ -173,1 +178,1 @@\n-        private final ResourceScope scope;\n+        private final MemorySession session;\n@@ -176,3 +181,3 @@\n-        public Builder(ResourceScope scope) {\n-            ((ResourceScopeImpl)scope).checkValidStateSlow();\n-            this.scope = scope;\n+        public Builder(MemorySession session) {\n+            ((MemorySessionImpl)session).checkValidStateSlow();\n+            this.session = session;\n@@ -217,1 +222,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(session);\n@@ -245,1 +250,1 @@\n-            return new WinVaList(segment, scope);\n+            return new WinVaList(segment);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":27,"deletions":22,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -65,2 +65,2 @@\n-    protected NativeSymbol arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, ResourceScope scope) {\n-        return CallArranger.arrangeUpcall(target, targetType, function, scope);\n+    protected NativeSymbol arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession session) {\n+        return CallArranger.arrangeUpcall(target, targetType, function, session);\n@@ -69,2 +69,2 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n-        WinVaList.Builder builder = WinVaList.builder(scope);\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, MemorySession session) {\n+        WinVaList.Builder builder = WinVaList.builder(session);\n@@ -75,2 +75,2 @@\n-    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n-        return WinVaList.ofAddress(ma, scope);\n+    public static VaList newVaListOfAddress(MemoryAddress ma, MemorySession session) {\n+        return WinVaList.ofAddress(ma, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-    public $type$ get$Type$(ResourceScope scope, Object base, long offset) {\n+    public $type$ get$Type$(MemorySession session, Object base, long offset) {\n@@ -4,1 +4,1 @@\n-            return get$Type$Internal(scope, base, offset);\n+            return get$Type$Internal(session, base, offset);\n@@ -11,1 +11,1 @@\n-    private $type$ get$Type$Internal(ResourceScope scope, Object base, long offset) {\n+    private $type$ get$Type$Internal(MemorySession session, Object base, long offset) {\n@@ -13,2 +13,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -18,1 +18,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -23,1 +23,1 @@\n-    public void put$Type$(ResourceScope scope, Object base, long offset, $type$ value) {\n+    public void put$Type$(MemorySession session, Object base, long offset, $type$ value) {\n@@ -25,1 +25,1 @@\n-            put$Type$Internal(scope, base, offset, value);\n+            put$Type$Internal(session, base, offset, value);\n@@ -32,1 +32,1 @@\n-    private void put$Type$Internal(ResourceScope scope, Object base, long offset, $type$ value) {\n+    private void put$Type$Internal(MemorySession session, Object base, long offset, $type$ value) {\n@@ -34,2 +34,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -39,1 +39,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -45,1 +45,1 @@\n-    public $type$ get$Type$Unaligned(ResourceScope scope, Object base, long offset, boolean be) {\n+    public $type$ get$Type$Unaligned(MemorySession session, Object base, long offset, boolean be) {\n@@ -47,1 +47,1 @@\n-            return get$Type$UnalignedInternal(scope, base, offset, be);\n+            return get$Type$UnalignedInternal(session, base, offset, be);\n@@ -54,1 +54,1 @@\n-    private $type$ get$Type$UnalignedInternal(ResourceScope scope, Object base, long offset, boolean be) {\n+    private $type$ get$Type$UnalignedInternal(MemorySession session, Object base, long offset, boolean be) {\n@@ -56,2 +56,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -61,1 +61,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -66,1 +66,1 @@\n-    public void put$Type$Unaligned(ResourceScope scope, Object base, long offset, $type$ value, boolean be) {\n+    public void put$Type$Unaligned(MemorySession session, Object base, long offset, $type$ value, boolean be) {\n@@ -68,1 +68,1 @@\n-            put$Type$UnalignedInternal(scope, base, offset, value, be);\n+            put$Type$UnalignedInternal(session, base, offset, value, be);\n@@ -75,1 +75,1 @@\n-    private void put$Type$UnalignedInternal(ResourceScope scope, Object base, long offset, $type$ value, boolean be) {\n+    private void put$Type$UnalignedInternal(MemorySession session, Object base, long offset, $type$ value, boolean be) {\n@@ -77,2 +77,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -82,1 +82,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -88,1 +88,1 @@\n-    public $type$ get$Type$Volatile(ResourceScope scope, Object base, long offset) {\n+    public $type$ get$Type$Volatile(MemorySession session, Object base, long offset) {\n@@ -90,1 +90,1 @@\n-            return get$Type$VolatileInternal(scope, base, offset);\n+            return get$Type$VolatileInternal(session, base, offset);\n@@ -97,1 +97,1 @@\n-    private $type$ get$Type$VolatileInternal(ResourceScope scope, Object base, long offset) {\n+    private $type$ get$Type$VolatileInternal(MemorySession session, Object base, long offset) {\n@@ -99,2 +99,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -104,1 +104,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -109,1 +109,1 @@\n-    public void put$Type$Volatile(ResourceScope scope, Object base, long offset, $type$ value) {\n+    public void put$Type$Volatile(MemorySession session, Object base, long offset, $type$ value) {\n@@ -111,1 +111,1 @@\n-            put$Type$VolatileInternal(scope, base, offset, value);\n+            put$Type$VolatileInternal(session, base, offset, value);\n@@ -118,1 +118,1 @@\n-    private void put$Type$VolatileInternal(ResourceScope scope, Object base, long offset, $type$ value) {\n+    private void put$Type$VolatileInternal(MemorySession session, Object base, long offset, $type$ value) {\n@@ -120,2 +120,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -125,1 +125,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -130,1 +130,1 @@\n-    public $type$ get$Type$Acquire(ResourceScope scope, Object base, long offset) {\n+    public $type$ get$Type$Acquire(MemorySession session, Object base, long offset) {\n@@ -132,1 +132,1 @@\n-            return get$Type$AcquireInternal(scope, base, offset);\n+            return get$Type$AcquireInternal(session, base, offset);\n@@ -139,1 +139,1 @@\n-    private $type$ get$Type$AcquireInternal(ResourceScope scope, Object base, long offset) {\n+    private $type$ get$Type$AcquireInternal(MemorySession session, Object base, long offset) {\n@@ -141,2 +141,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -146,1 +146,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -151,1 +151,1 @@\n-    public void put$Type$Release(ResourceScope scope, Object base, long offset, $type$ value) {\n+    public void put$Type$Release(MemorySession session, Object base, long offset, $type$ value) {\n@@ -153,1 +153,1 @@\n-            put$Type$ReleaseInternal(scope, base, offset, value);\n+            put$Type$ReleaseInternal(session, base, offset, value);\n@@ -160,1 +160,1 @@\n-    private void put$Type$ReleaseInternal(ResourceScope scope, Object base, long offset, $type$ value) {\n+    private void put$Type$ReleaseInternal(MemorySession session, Object base, long offset, $type$ value) {\n@@ -162,2 +162,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -167,1 +167,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -172,1 +172,1 @@\n-    public $type$ get$Type$Opaque(ResourceScope scope, Object base, long offset) {\n+    public $type$ get$Type$Opaque(MemorySession session, Object base, long offset) {\n@@ -174,1 +174,1 @@\n-            return get$Type$OpaqueInternal(scope, base, offset);\n+            return get$Type$OpaqueInternal(session, base, offset);\n@@ -181,1 +181,1 @@\n-    private $type$ get$Type$OpaqueInternal(ResourceScope scope, Object base, long offset) {\n+    private $type$ get$Type$OpaqueInternal(MemorySession session, Object base, long offset) {\n@@ -183,2 +183,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -188,1 +188,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -192,1 +192,1 @@\n-    public void put$Type$Opaque(ResourceScope scope, Object base, long offset, $type$ value) {\n+    public void put$Type$Opaque(MemorySession session, Object base, long offset, $type$ value) {\n@@ -194,1 +194,1 @@\n-            put$Type$OpaqueInternal(scope, base, offset, value);\n+            put$Type$OpaqueInternal(session, base, offset, value);\n@@ -201,1 +201,1 @@\n-    private void put$Type$OpaqueInternal(ResourceScope scope, Object base, long offset, $type$ value) {\n+    private void put$Type$OpaqueInternal(MemorySession session, Object base, long offset, $type$ value) {\n@@ -203,2 +203,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -208,1 +208,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -213,1 +213,1 @@\n-    public boolean compareAndSet$Type$(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    public boolean compareAndSet$Type$(MemorySession session, Object base, long offset, $type$ expected, $type$ value) {\n@@ -215,1 +215,1 @@\n-            return compareAndSet$Type$Internal(scope, base, offset, expected, value);\n+            return compareAndSet$Type$Internal(session, base, offset, expected, value);\n@@ -222,1 +222,1 @@\n-    private boolean compareAndSet$Type$Internal(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    private boolean compareAndSet$Type$Internal(MemorySession session, Object base, long offset, $type$ expected, $type$ value) {\n@@ -224,2 +224,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -229,1 +229,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -234,1 +234,1 @@\n-    public $type$ compareAndExchange$Type$(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    public $type$ compareAndExchange$Type$(MemorySession session, Object base, long offset, $type$ expected, $type$ value) {\n@@ -236,1 +236,1 @@\n-            return compareAndExchange$Type$Internal(scope, base, offset, expected, value);\n+            return compareAndExchange$Type$Internal(session, base, offset, expected, value);\n@@ -243,1 +243,1 @@\n-    private $type$ compareAndExchange$Type$Internal(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    private $type$ compareAndExchange$Type$Internal(MemorySession session, Object base, long offset, $type$ expected, $type$ value) {\n@@ -245,2 +245,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -250,1 +250,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -255,1 +255,1 @@\n-    public $type$ compareAndExchange$Type$Acquire(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    public $type$ compareAndExchange$Type$Acquire(MemorySession session, Object base, long offset, $type$ expected, $type$ value) {\n@@ -257,1 +257,1 @@\n-            return compareAndExchange$Type$AcquireInternal(scope, base, offset, expected, value);\n+            return compareAndExchange$Type$AcquireInternal(session, base, offset, expected, value);\n@@ -264,1 +264,1 @@\n-    private $type$ compareAndExchange$Type$AcquireInternal(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    private $type$ compareAndExchange$Type$AcquireInternal(MemorySession session, Object base, long offset, $type$ expected, $type$ value) {\n@@ -266,2 +266,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -271,1 +271,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -276,1 +276,1 @@\n-    public $type$ compareAndExchange$Type$Release(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    public $type$ compareAndExchange$Type$Release(MemorySession session, Object base, long offset, $type$ expected, $type$ value) {\n@@ -278,1 +278,1 @@\n-            return compareAndExchange$Type$ReleaseInternal(scope, base, offset, expected, value);\n+            return compareAndExchange$Type$ReleaseInternal(session, base, offset, expected, value);\n@@ -285,1 +285,1 @@\n-    private $type$ compareAndExchange$Type$ReleaseInternal(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    private $type$ compareAndExchange$Type$ReleaseInternal(MemorySession session, Object base, long offset, $type$ expected, $type$ value) {\n@@ -287,2 +287,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -292,1 +292,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -297,1 +297,1 @@\n-    public boolean weakCompareAndSet$Type$Plain(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    public boolean weakCompareAndSet$Type$Plain(MemorySession session, Object base, long offset, $type$ expected, $type$ value) {\n@@ -299,1 +299,1 @@\n-            return weakCompareAndSet$Type$PlainInternal(scope, base, offset, expected, value);\n+            return weakCompareAndSet$Type$PlainInternal(session, base, offset, expected, value);\n@@ -306,1 +306,1 @@\n-    private boolean weakCompareAndSet$Type$PlainInternal(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    private boolean weakCompareAndSet$Type$PlainInternal(MemorySession session, Object base, long offset, $type$ expected, $type$ value) {\n@@ -308,2 +308,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -313,1 +313,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -318,1 +318,1 @@\n-    public boolean weakCompareAndSet$Type$(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    public boolean weakCompareAndSet$Type$(MemorySession session, Object base, long offset, $type$ expected, $type$ value) {\n@@ -320,1 +320,1 @@\n-            return weakCompareAndSet$Type$Internal(scope, base, offset, expected, value);\n+            return weakCompareAndSet$Type$Internal(session, base, offset, expected, value);\n@@ -327,1 +327,1 @@\n-    private boolean weakCompareAndSet$Type$Internal(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    private boolean weakCompareAndSet$Type$Internal(MemorySession session, Object base, long offset, $type$ expected, $type$ value) {\n@@ -329,2 +329,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -334,1 +334,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -339,1 +339,1 @@\n-    public boolean weakCompareAndSet$Type$Acquire(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    public boolean weakCompareAndSet$Type$Acquire(MemorySession session, Object base, long offset, $type$ expected, $type$ value) {\n@@ -341,1 +341,1 @@\n-            return weakCompareAndSet$Type$AcquireInternal(scope, base, offset, expected, value);\n+            return weakCompareAndSet$Type$AcquireInternal(session, base, offset, expected, value);\n@@ -348,1 +348,1 @@\n-    private boolean weakCompareAndSet$Type$AcquireInternal(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    private boolean weakCompareAndSet$Type$AcquireInternal(MemorySession session, Object base, long offset, $type$ expected, $type$ value) {\n@@ -350,2 +350,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -355,1 +355,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -360,1 +360,1 @@\n-    public boolean weakCompareAndSet$Type$Release(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    public boolean weakCompareAndSet$Type$Release(MemorySession session, Object base, long offset, $type$ expected, $type$ value) {\n@@ -362,1 +362,1 @@\n-            return weakCompareAndSet$Type$ReleaseInternal(scope, base, offset, expected, value);\n+            return weakCompareAndSet$Type$ReleaseInternal(session, base, offset, expected, value);\n@@ -369,1 +369,1 @@\n-    private boolean weakCompareAndSet$Type$ReleaseInternal(ResourceScope scope, Object base, long offset, $type$ expected, $type$ value) {\n+    private boolean weakCompareAndSet$Type$ReleaseInternal(MemorySession session, Object base, long offset, $type$ expected, $type$ value) {\n@@ -371,2 +371,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -376,1 +376,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -381,1 +381,1 @@\n-    public $type$ getAndSet$Type$(ResourceScope scope, Object base, long offset, $type$ value) {\n+    public $type$ getAndSet$Type$(MemorySession session, Object base, long offset, $type$ value) {\n@@ -383,1 +383,1 @@\n-            return getAndSet$Type$Internal(scope, base, offset, value);\n+            return getAndSet$Type$Internal(session, base, offset, value);\n@@ -390,1 +390,1 @@\n-    private $type$ getAndSet$Type$Internal(ResourceScope scope, Object base, long offset, $type$ value) {\n+    private $type$ getAndSet$Type$Internal(MemorySession session, Object base, long offset, $type$ value) {\n@@ -392,2 +392,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -397,1 +397,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -402,1 +402,1 @@\n-    public $type$ getAndSet$Type$Acquire(ResourceScope scope, Object base, long offset, $type$ value) {\n+    public $type$ getAndSet$Type$Acquire(MemorySession session, Object base, long offset, $type$ value) {\n@@ -404,1 +404,1 @@\n-            return getAndSet$Type$AcquireInternal(scope, base, offset, value);\n+            return getAndSet$Type$AcquireInternal(session, base, offset, value);\n@@ -411,1 +411,1 @@\n-    private $type$ getAndSet$Type$AcquireInternal(ResourceScope scope, Object base, long offset, $type$ value) {\n+    private $type$ getAndSet$Type$AcquireInternal(MemorySession session, Object base, long offset, $type$ value) {\n@@ -413,2 +413,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -418,1 +418,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -423,1 +423,1 @@\n-    public $type$ getAndSet$Type$Release(ResourceScope scope, Object base, long offset, $type$ value) {\n+    public $type$ getAndSet$Type$Release(MemorySession session, Object base, long offset, $type$ value) {\n@@ -425,1 +425,1 @@\n-            return getAndSet$Type$ReleaseInternal(scope, base, offset, value);\n+            return getAndSet$Type$ReleaseInternal(session, base, offset, value);\n@@ -432,1 +432,1 @@\n-    private $type$ getAndSet$Type$ReleaseInternal(ResourceScope scope, Object base, long offset, $type$ value) {\n+    private $type$ getAndSet$Type$ReleaseInternal(MemorySession session, Object base, long offset, $type$ value) {\n@@ -434,2 +434,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -439,1 +439,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -446,1 +446,1 @@\n-    public $type$ getAndAdd$Type$(ResourceScope scope, Object base, long offset, $type$ delta) {\n+    public $type$ getAndAdd$Type$(MemorySession session, Object base, long offset, $type$ delta) {\n@@ -448,1 +448,1 @@\n-            return getAndAdd$Type$Internal(scope, base, offset, delta);\n+            return getAndAdd$Type$Internal(session, base, offset, delta);\n@@ -455,1 +455,1 @@\n-    private $type$ getAndAdd$Type$Internal(ResourceScope scope, Object base, long offset, $type$ delta) {\n+    private $type$ getAndAdd$Type$Internal(MemorySession session, Object base, long offset, $type$ delta) {\n@@ -457,2 +457,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -462,1 +462,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -467,1 +467,1 @@\n-    public $type$ getAndAdd$Type$Acquire(ResourceScope scope, Object base, long offset, $type$ delta) {\n+    public $type$ getAndAdd$Type$Acquire(MemorySession session, Object base, long offset, $type$ delta) {\n@@ -469,1 +469,1 @@\n-            return getAndAdd$Type$AcquireInternal(scope, base, offset, delta);\n+            return getAndAdd$Type$AcquireInternal(session, base, offset, delta);\n@@ -476,1 +476,1 @@\n-    private $type$ getAndAdd$Type$AcquireInternal(ResourceScope scope, Object base, long offset, $type$ delta) {\n+    private $type$ getAndAdd$Type$AcquireInternal(MemorySession session, Object base, long offset, $type$ delta) {\n@@ -478,2 +478,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -483,1 +483,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -488,1 +488,1 @@\n-    public $type$ getAndAdd$Type$Release(ResourceScope scope, Object base, long offset, $type$ delta) {\n+    public $type$ getAndAdd$Type$Release(MemorySession session, Object base, long offset, $type$ delta) {\n@@ -490,1 +490,1 @@\n-            return getAndAdd$Type$ReleaseInternal(scope, base, offset, delta);\n+            return getAndAdd$Type$ReleaseInternal(session, base, offset, delta);\n@@ -497,1 +497,1 @@\n-    private $type$ getAndAdd$Type$ReleaseInternal(ResourceScope scope, Object base, long offset, $type$ delta) {\n+    private $type$ getAndAdd$Type$ReleaseInternal(MemorySession session, Object base, long offset, $type$ delta) {\n@@ -499,2 +499,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -504,1 +504,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -511,1 +511,1 @@\n-    public $type$ getAndBitwiseOr$Type$(ResourceScope scope, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseOr$Type$(MemorySession session, Object base, long offset, $type$ value) {\n@@ -513,1 +513,1 @@\n-            return getAndBitwiseOr$Type$Internal(scope, base, offset, value);\n+            return getAndBitwiseOr$Type$Internal(session, base, offset, value);\n@@ -520,1 +520,1 @@\n-    private $type$ getAndBitwiseOr$Type$Internal(ResourceScope scope, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseOr$Type$Internal(MemorySession session, Object base, long offset, $type$ value) {\n@@ -522,2 +522,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -527,1 +527,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -532,1 +532,1 @@\n-    public $type$ getAndBitwiseOr$Type$Acquire(ResourceScope scope, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseOr$Type$Acquire(MemorySession session, Object base, long offset, $type$ value) {\n@@ -534,1 +534,1 @@\n-            return getAndBitwiseOr$Type$AcquireInternal(scope, base, offset, value);\n+            return getAndBitwiseOr$Type$AcquireInternal(session, base, offset, value);\n@@ -541,1 +541,1 @@\n-    private $type$ getAndBitwiseOr$Type$AcquireInternal(ResourceScope scope, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseOr$Type$AcquireInternal(MemorySession session, Object base, long offset, $type$ value) {\n@@ -543,2 +543,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -548,1 +548,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -553,1 +553,1 @@\n-    public $type$ getAndBitwiseOr$Type$Release(ResourceScope scope, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseOr$Type$Release(MemorySession session, Object base, long offset, $type$ value) {\n@@ -555,1 +555,1 @@\n-            return getAndBitwiseOr$Type$ReleaseInternal(scope, base, offset, value);\n+            return getAndBitwiseOr$Type$ReleaseInternal(session, base, offset, value);\n@@ -562,1 +562,1 @@\n-    private $type$ getAndBitwiseOr$Type$ReleaseInternal(ResourceScope scope, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseOr$Type$ReleaseInternal(MemorySession session, Object base, long offset, $type$ value) {\n@@ -564,2 +564,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -569,1 +569,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -574,1 +574,1 @@\n-    public $type$ getAndBitwiseAnd$Type$(ResourceScope scope, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseAnd$Type$(MemorySession session, Object base, long offset, $type$ value) {\n@@ -576,1 +576,1 @@\n-            return getAndBitwiseAnd$Type$Internal(scope, base, offset, value);\n+            return getAndBitwiseAnd$Type$Internal(session, base, offset, value);\n@@ -583,1 +583,1 @@\n-    private $type$ getAndBitwiseAnd$Type$Internal(ResourceScope scope, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseAnd$Type$Internal(MemorySession session, Object base, long offset, $type$ value) {\n@@ -585,2 +585,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -590,1 +590,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -595,1 +595,1 @@\n-    public $type$ getAndBitwiseAnd$Type$Acquire(ResourceScope scope, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseAnd$Type$Acquire(MemorySession session, Object base, long offset, $type$ value) {\n@@ -597,1 +597,1 @@\n-            return getAndBitwiseAnd$Type$AcquireInternal(scope, base, offset, value);\n+            return getAndBitwiseAnd$Type$AcquireInternal(session, base, offset, value);\n@@ -604,1 +604,1 @@\n-    private $type$ getAndBitwiseAnd$Type$AcquireInternal(ResourceScope scope, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseAnd$Type$AcquireInternal(MemorySession session, Object base, long offset, $type$ value) {\n@@ -606,2 +606,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -611,1 +611,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -616,1 +616,1 @@\n-    public $type$ getAndBitwiseAnd$Type$Release(ResourceScope scope, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseAnd$Type$Release(MemorySession session, Object base, long offset, $type$ value) {\n@@ -618,1 +618,1 @@\n-            return getAndBitwiseAnd$Type$ReleaseInternal(scope, base, offset, value);\n+            return getAndBitwiseAnd$Type$ReleaseInternal(session, base, offset, value);\n@@ -625,1 +625,1 @@\n-    private $type$ getAndBitwiseAnd$Type$ReleaseInternal(ResourceScope scope, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseAnd$Type$ReleaseInternal(MemorySession session, Object base, long offset, $type$ value) {\n@@ -627,2 +627,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -632,1 +632,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -637,1 +637,1 @@\n-    public $type$ getAndBitwiseXor$Type$(ResourceScope scope, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseXor$Type$(MemorySession session, Object base, long offset, $type$ value) {\n@@ -639,1 +639,1 @@\n-            return getAndBitwiseXor$Type$Internal(scope, base, offset, value);\n+            return getAndBitwiseXor$Type$Internal(session, base, offset, value);\n@@ -646,1 +646,1 @@\n-    private $type$ getAndBitwiseXor$Type$Internal(ResourceScope scope, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseXor$Type$Internal(MemorySession session, Object base, long offset, $type$ value) {\n@@ -648,2 +648,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -653,1 +653,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -658,1 +658,1 @@\n-    public $type$ getAndBitwiseXor$Type$Acquire(ResourceScope scope, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseXor$Type$Acquire(MemorySession session, Object base, long offset, $type$ value) {\n@@ -660,1 +660,1 @@\n-            return getAndBitwiseXor$Type$AcquireInternal(scope, base, offset, value);\n+            return getAndBitwiseXor$Type$AcquireInternal(session, base, offset, value);\n@@ -667,1 +667,1 @@\n-    private $type$ getAndBitwiseXor$Type$AcquireInternal(ResourceScope scope, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseXor$Type$AcquireInternal(MemorySession session, Object base, long offset, $type$ value) {\n@@ -669,2 +669,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -674,1 +674,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -679,1 +679,1 @@\n-    public $type$ getAndBitwiseXor$Type$Release(ResourceScope scope, Object base, long offset, $type$ value) {\n+    public $type$ getAndBitwiseXor$Type$Release(MemorySession session, Object base, long offset, $type$ value) {\n@@ -681,1 +681,1 @@\n-            return getAndBitwiseXor$Type$ReleaseInternal(scope, base, offset, value);\n+            return getAndBitwiseXor$Type$ReleaseInternal(session, base, offset, value);\n@@ -688,1 +688,1 @@\n-    private $type$ getAndBitwiseXor$Type$ReleaseInternal(ResourceScope scope, Object base, long offset, $type$ value) {\n+    private $type$ getAndBitwiseXor$Type$ReleaseInternal(MemorySession session, Object base, long offset, $type$ value) {\n@@ -690,2 +690,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -695,1 +695,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess-bin.java.template","additions":198,"deletions":198,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -41,1 +41,2 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -50,1 +51,1 @@\n- * class accept one or more {@link ResourceScope} parameter, which is used to validate as to whether access to memory\n+ * class accept one or more {@link MemorySession} parameter, which is used to validate as to whether access to memory\n@@ -61,3 +62,3 @@\n- * {@link ResourceScope#close()} method. This method initiates thread-local handshakes with all the other VM threads,\n- * which are then stopped one by one. If any thread is found accessing memory that is associated to the very scope\n- * object being closed, that thread execution is asynchronously interrupted with a {@link ScopedAccessError}.\n+ * {@link MemorySession#close()} method. This method initiates thread-local handshakes with all the other VM threads,\n+ * which are then stopped one by one. If any thread is found accessing a resource associated to the very memory session\n+ * being closed, the handshake fails, and {@link MemorySession#close()} throws an exception (leaving the session open).\n@@ -66,2 +67,2 @@\n- * validity of the scope associated with that memory region - that is, a thread that wants to perform memory access will be\n- * suspended either <em>before<\/em> a scope check or <em>after<\/em> the memory access. To ensure this atomicity,\n+ * validity of the session associated with that memory region - that is, a thread that wants to perform memory access will be\n+ * suspended either <em>before<\/em> a liveness check or <em>after<\/em> the memory access. To ensure this atomicity,\n@@ -70,1 +71,1 @@\n- * operations. Additionally, to make sure that the scope object(s) of the memory being accessed is always\n+ * operations. Additionally, to make sure that the session object(s) of the memory being accessed is always\n@@ -87,2 +88,2 @@\n-    public boolean closeScope(ResourceScope scope) {\n-        return closeScope0(scope);\n+    public boolean closeScope(MemorySession session) {\n+        return closeScope0(session);\n@@ -91,1 +92,1 @@\n-    native boolean closeScope0(ResourceScope scope);\n+    native boolean closeScope0(MemorySession session);\n@@ -117,1 +118,1 @@\n-    public void copyMemory(ResourceScope srcScope, ResourceScope dstScope,\n+    public void copyMemory(MemorySession srcScope, MemorySession dstScope,\n@@ -129,1 +130,1 @@\n-    private void copyMemoryInternal(ResourceScope srcScope, ResourceScope dstScope,\n+    private void copyMemoryInternal(MemorySession srcScope, MemorySession dstScope,\n@@ -135,1 +136,1 @@\n-                ((ResourceScopeImpl)srcScope).checkValidState();\n+                ((MemorySessionImpl)srcScope).checkValidState();\n@@ -138,1 +139,1 @@\n-                ((ResourceScopeImpl)dstScope).checkValidState();\n+                ((MemorySessionImpl)dstScope).checkValidState();\n@@ -148,1 +149,1 @@\n-    public void copySwapMemory(ResourceScope srcScope, ResourceScope dstScope,\n+    public void copySwapMemory(MemorySession srcScope, MemorySession dstScope,\n@@ -160,1 +161,1 @@\n-    private void copySwapMemoryInternal(ResourceScope srcScope, ResourceScope dstScope,\n+    private void copySwapMemoryInternal(MemorySession srcScope, MemorySession dstScope,\n@@ -166,1 +167,1 @@\n-                ((ResourceScopeImpl)srcScope).checkValidState();\n+                ((MemorySessionImpl)srcScope).checkValidState();\n@@ -169,1 +170,1 @@\n-                ((ResourceScopeImpl)dstScope).checkValidState();\n+                ((MemorySessionImpl)dstScope).checkValidState();\n@@ -179,1 +180,1 @@\n-    public void setMemory(ResourceScope scope, Object o, long offset, long bytes, byte value) {\n+    public void setMemory(MemorySession session, Object o, long offset, long bytes, byte value) {\n@@ -181,1 +182,1 @@\n-            setMemoryInternal(scope, o, offset, bytes, value);\n+            setMemoryInternal(session, o, offset, bytes, value);\n@@ -188,1 +189,1 @@\n-    private void setMemoryInternal(ResourceScope scope, Object o, long offset, long bytes, byte value) {\n+    private void setMemoryInternal(MemorySession session, Object o, long offset, long bytes, byte value) {\n@@ -190,2 +191,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -195,1 +196,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -200,1 +201,1 @@\n-    public int vectorizedMismatch(ResourceScope aScope, ResourceScope bScope,\n+    public int vectorizedMismatch(MemorySession aScope, MemorySession bScope,\n@@ -213,1 +214,1 @@\n-    private int vectorizedMismatchInternal(ResourceScope aScope, ResourceScope bScope,\n+    private int vectorizedMismatchInternal(MemorySession aScope, MemorySession bScope,\n@@ -220,1 +221,1 @@\n-                ((ResourceScopeImpl)aScope).checkValidState();\n+                ((MemorySessionImpl)aScope).checkValidState();\n@@ -223,1 +224,1 @@\n-                ((ResourceScopeImpl)bScope).checkValidState();\n+                ((MemorySessionImpl)bScope).checkValidState();\n@@ -233,1 +234,1 @@\n-    public boolean isLoaded(ResourceScope scope, long address, boolean isSync, long size) {\n+    public boolean isLoaded(MemorySession session, long address, boolean isSync, long size) {\n@@ -235,1 +236,1 @@\n-            return isLoadedInternal(scope, address, isSync, size);\n+            return isLoadedInternal(session, address, isSync, size);\n@@ -242,1 +243,1 @@\n-    public boolean isLoadedInternal(ResourceScope scope, long address, boolean isSync, long size) {\n+    public boolean isLoadedInternal(MemorySession session, long address, boolean isSync, long size) {\n@@ -244,2 +245,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -249,1 +250,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -254,1 +255,1 @@\n-    public void load(ResourceScope scope, long address, boolean isSync, long size) {\n+    public void load(MemorySession session, long address, boolean isSync, long size) {\n@@ -256,1 +257,1 @@\n-            loadInternal(scope, address, isSync, size);\n+            loadInternal(session, address, isSync, size);\n@@ -263,1 +264,1 @@\n-    public void loadInternal(ResourceScope scope, long address, boolean isSync, long size) {\n+    public void loadInternal(MemorySession session, long address, boolean isSync, long size) {\n@@ -265,2 +266,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -270,1 +271,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -275,1 +276,1 @@\n-    public void unload(ResourceScope scope, long address, boolean isSync, long size) {\n+    public void unload(MemorySession session, long address, boolean isSync, long size) {\n@@ -277,1 +278,1 @@\n-            unloadInternal(scope, address, isSync, size);\n+            unloadInternal(session, address, isSync, size);\n@@ -284,1 +285,1 @@\n-    public void unloadInternal(ResourceScope scope, long address, boolean isSync, long size) {\n+    public void unloadInternal(MemorySession session, long address, boolean isSync, long size) {\n@@ -286,2 +287,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -291,1 +292,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -296,1 +297,1 @@\n-    public void force(ResourceScope scope, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n+    public void force(MemorySession session, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n@@ -298,1 +299,1 @@\n-            forceInternal(scope, fd, address, isSync, index, length);\n+            forceInternal(session, fd, address, isSync, index, length);\n@@ -305,1 +306,1 @@\n-    public void forceInternal(ResourceScope scope, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n+    public void forceInternal(MemorySession session, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n@@ -307,2 +308,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -312,1 +313,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -345,1 +346,1 @@\n-        static ResourceScope scope(ByteBuffer bb) {\n+        static MemorySession session(ByteBuffer bb) {\n@@ -348,1 +349,1 @@\n-                    segment.scope() : null;\n+                    ((AbstractMemorySegmentImpl)segment).sessionImpl() : null;\n@@ -366,1 +367,1 @@\n-                    BufferAccess.scope(bb),\n+                    BufferAccess.session(bb),\n@@ -380,1 +381,1 @@\n-    V loadFromByteBufferScoped(ResourceScope scope,\n+    V loadFromByteBufferScoped(MemorySession session,\n@@ -386,2 +387,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -397,1 +398,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -410,1 +411,1 @@\n-                    BufferAccess.scope(bb),\n+                    BufferAccess.session(bb),\n@@ -425,1 +426,1 @@\n-    V loadFromByteBufferMaskedScoped(ResourceScope scope, Class<? extends V> vmClass,\n+    V loadFromByteBufferMaskedScoped(MemorySession session, Class<? extends V> vmClass,\n@@ -431,2 +432,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -440,1 +441,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -453,1 +454,1 @@\n-                    BufferAccess.scope(bb),\n+                    BufferAccess.session(bb),\n@@ -467,1 +468,1 @@\n-    void storeIntoByteBufferScoped(ResourceScope scope,\n+    void storeIntoByteBufferScoped(MemorySession session,\n@@ -473,2 +474,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -485,1 +486,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n@@ -498,1 +499,1 @@\n-                    BufferAccess.scope(bb),\n+                    BufferAccess.session(bb),\n@@ -512,1 +513,1 @@\n-    void storeIntoByteBufferMaskedScoped(ResourceScope scope,\n+    void storeIntoByteBufferMaskedScoped(MemorySession session,\n@@ -518,2 +519,2 @@\n-            if (scope != null) {\n-                ((ResourceScopeImpl)scope).checkValidState();\n+            if (session != null) {\n+                ((MemorySessionImpl)session).checkValidState();\n@@ -528,1 +529,1 @@\n-            Reference.reachabilityFence(scope);\n+            Reference.reachabilityFence(session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":77,"deletions":76,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -478,1 +478,1 @@\n-        return NIO_ACCESS.acquireScope(bb, async);\n+        return NIO_ACCESS.acquireSession(bb, async);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOUtil.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -385,1 +385,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n+            MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.openImplicit());\n@@ -389,1 +389,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(1, ResourceScope.newImplicitScope());\n+            MemorySegment segment = MemorySegment.allocateNative(1, MemorySession.openImplicit());\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -42,0 +42,1 @@\n+import java.util.Arrays;\n@@ -60,2 +61,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            segment = MemorySegment.allocateNative(POINT, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            segment = MemorySegment.allocateNative(POINT, session);\n@@ -63,1 +64,1 @@\n-        assertFalse(segment.scope().isAlive());\n+        assertFalse(segment.session().isAlive());\n@@ -77,7 +78,7 @@\n-            MemorySegment[] segments = new MemorySegment[]{\n-                    MemorySegment.allocateNative(POINT, ResourceScope.newImplicitScope()),\n-                    MemorySegment.allocateNative(POINT, ResourceScope.newImplicitScope()),\n-                    MemorySegment.allocateNative(POINT, ResourceScope.newImplicitScope()),\n-                    MemorySegment.allocateNative(POINT, ResourceScope.newImplicitScope()),\n-                    MemorySegment.allocateNative(POINT, ResourceScope.newImplicitScope()),\n-                    MemorySegment.allocateNative(POINT, ResourceScope.newImplicitScope())\n+            MemorySession[] sessions = new MemorySession[] {\n+                    MemorySession.openShared(),\n+                    MemorySession.openShared(),\n+                    MemorySession.openShared(),\n+                    MemorySession.openShared(),\n+                    MemorySession.openShared(),\n+                    MemorySession.openShared()\n@@ -86,1 +87,1 @@\n-            segments[i].scope().close();\n+            sessions[i].close();\n@@ -89,1 +90,1 @@\n-                    assertFalse(segments[j].scope().isAlive());\n+                    assertFalse(sessions[j].isAlive());\n@@ -91,1 +92,1 @@\n-                    assertTrue(segments[j].scope().isAlive());\n+                    assertTrue(sessions[j].isAlive());\n@@ -95,0 +96,2 @@\n+                MemorySegment[] segments = Arrays.stream(sessions).map(session -> MemorySegment.allocateNative(POINT, session))\n+                        .toArray(MemorySegment[]::new);\n@@ -102,1 +105,1 @@\n-                    segments[j].scope().close(); \/\/ should succeed!\n+                    sessions[j].close(); \/\/ should succeed!\n@@ -111,2 +114,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            list = VaList.make(b -> b.addVarg(C_INT, 42), scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            list = VaList.make(b -> b.addVarg(C_INT, 42), session);\n@@ -114,1 +117,1 @@\n-        assertFalse(list.scope().isAlive());\n+        assertFalse(list.session().isAlive());\n@@ -125,1 +128,1 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+        try (MemorySession session = MemorySession.openConfined()) {\n@@ -127,1 +130,1 @@\n-            upcall = CLinker.systemCLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), scope);\n+            upcall = CLinker.systemCLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), session);\n@@ -129,1 +132,1 @@\n-        assertFalse(upcall.scope().isAlive());\n+        assertFalse(upcall.session().isAlive());\n@@ -145,3 +148,3 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            VaList list = VaList.make(b -> b.addVarg(C_INT, 42), scope);\n-            handle.invoke(list, scopeChecker(scope));\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            VaList list = VaList.make(b -> b.addVarg(C_INT, 42), session);\n+            handle.invoke(list, sessionChecker(session));\n@@ -157,3 +160,3 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(POINT, scope);\n-            handle.invoke(segment, scopeChecker(scope));\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(POINT, session);\n+            handle.invoke(segment, sessionChecker(session));\n@@ -169,1 +172,1 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+        try (MemorySession session = MemorySession.openConfined()) {\n@@ -171,2 +174,2 @@\n-            NativeSymbol upcall = CLinker.systemCLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), scope);\n-            handle.invoke(upcall, scopeChecker(scope));\n+            NativeSymbol upcall = CLinker.systemCLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), session);\n+            handle.invoke(upcall, sessionChecker(session));\n@@ -176,1 +179,1 @@\n-    NativeSymbol scopeChecker(ResourceScope scope) {\n+    NativeSymbol sessionChecker(MemorySession session) {\n@@ -178,4 +181,4 @@\n-            MethodHandle handle = MethodHandles.lookup().findStatic(SafeFunctionAccessTest.class, \"checkScope\",\n-                    MethodType.methodType(void.class, ResourceScope.class));\n-            handle = handle.bindTo(scope);\n-            return CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), ResourceScope.newImplicitScope());\n+            MethodHandle handle = MethodHandles.lookup().findStatic(SafeFunctionAccessTest.class, \"checkSession\",\n+                    MethodType.methodType(void.class, MemorySession.class));\n+            handle = handle.bindTo(session);\n+            return CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), MemorySession.openImplicit());\n@@ -187,1 +190,1 @@\n-    static void checkScope(ResourceScope scope) {\n+    static void checkSession(MemorySession session) {\n@@ -189,2 +192,2 @@\n-            scope.close();\n-            fail(\"Scope closed unexpectedly!\");\n+            session.close();\n+            fail(\"Session closed unexpectedly!\");\n@@ -192,1 +195,1 @@\n-            assertTrue(ex.getMessage().contains(\"kept alive\")); \/\/if acquired, fine\n+            assertTrue(ex.getMessage().contains(\"acquired\")); \/\/if acquired, fine\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":42,"deletions":39,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -199,3 +199,2 @@\n-            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-                var malloc = SegmentAllocator.nativeAllocator(scope);\n-                MemorySegment buf = malloc.allocate(s1.length() + s2.length() + 1);\n+            try (MemorySession session = MemorySession.openConfined()) {\n+                MemorySegment buf = session.allocate(s1.length() + s2.length() + 1);\n@@ -203,1 +202,1 @@\n-                MemorySegment other = malloc.allocateUtf8String(s2);\n+                MemorySegment other = session.allocateUtf8String(s2);\n@@ -209,4 +208,3 @@\n-            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-                var malloc = SegmentAllocator.nativeAllocator(scope);\n-                MemorySegment ns1 = malloc.allocateUtf8String(s1);\n-                MemorySegment ns2 = malloc.allocateUtf8String(s2);\n+            try (MemorySession session = MemorySession.openConfined()) {\n+                MemorySegment ns1 = session.allocateUtf8String(s1);\n+                MemorySegment ns2 = session.allocateUtf8String(s2);\n@@ -218,3 +216,2 @@\n-            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-                var malloc = SegmentAllocator.nativeAllocator(scope);\n-                MemorySegment s = malloc.allocateUtf8String(msg);\n+            try (MemorySession session = MemorySession.openConfined()) {\n+                MemorySegment s = session.allocateUtf8String(msg);\n@@ -226,3 +223,2 @@\n-            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-                var malloc = SegmentAllocator.nativeAllocator(scope);\n-                MemorySegment s = malloc.allocateUtf8String(msg);\n+            try (MemorySession session = MemorySession.openConfined()) {\n+                MemorySegment s = session.allocateUtf8String(msg);\n@@ -234,2 +230,2 @@\n-            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-                MemorySegment time = MemorySegment.allocateNative(8, scope);\n+            try (MemorySession session = MemorySession.openConfined()) {\n+                MemorySegment time = session.allocate(8);\n@@ -249,1 +245,1 @@\n-                this.base = MemorySegment.ofAddress(addr, SIZE, ResourceScope.globalScope());\n+                this.base = MemorySegment.ofAddress(addr, SIZE, MemorySession.global());\n@@ -283,3 +279,2 @@\n-            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-                var malloc = SegmentAllocator.nativeAllocator(scope);\n-                MemorySegment nativeArr = malloc.allocateArray(C_INT, arr);\n+            try (MemorySession session = MemorySession.openConfined()) {\n+                MemorySegment nativeArr = session.allocateArray(C_INT, arr);\n@@ -288,1 +283,1 @@\n-                NativeSymbol qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, scope);\n+                NativeSymbol qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, session);\n@@ -307,3 +302,2 @@\n-            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-                var malloc = SegmentAllocator.nativeAllocator(scope);\n-                MemorySegment formatStr = malloc.allocateUtf8String(format);\n+            try (MemorySession session = MemorySession.openConfined()) {\n+                MemorySegment formatStr = session.allocateUtf8String(format);\n@@ -311,1 +305,1 @@\n-                        args.stream().map(a -> a.nativeValue(scope)).toArray());\n+                        args.stream().map(a -> a.nativeValue(session)).toArray());\n@@ -316,4 +310,3 @@\n-            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-                var malloc = SegmentAllocator.nativeAllocator(scope);\n-                MemorySegment formatStr = malloc.allocateUtf8String(format);\n-                VaList vaList = VaList.make(b -> args.forEach(a -> a.accept(b, scope)), scope);\n+            try (MemorySession session = MemorySession.openConfined()) {\n+                MemorySegment formatStr = session.allocateUtf8String(format);\n+                VaList vaList = VaList.make(b -> args.forEach(a -> a.accept(b, session)), session);\n@@ -393,1 +386,1 @@\n-    enum PrintfArg implements BiConsumer<VaList.Builder, ResourceScope> {\n+    enum PrintfArg implements BiConsumer<VaList.Builder, MemorySession> {\n@@ -395,3 +388,3 @@\n-        INTEGRAL(int.class, C_INT, \"%d\", scope -> 42, 42, VaList.Builder::addVarg),\n-        STRING(MemoryAddress.class, C_POINTER, \"%s\", scope -> {\n-            var segment = MemorySegment.allocateNative(4, scope);\n+        INTEGRAL(int.class, C_INT, \"%d\", session -> 42, 42, VaList.Builder::addVarg),\n+        STRING(MemoryAddress.class, C_POINTER, \"%s\", session -> {\n+            var segment = MemorySegment.allocateNative(4, session);\n@@ -401,2 +394,2 @@\n-        CHAR(byte.class, C_CHAR, \"%c\", scope -> (byte) 'h', 'h', (builder, layout, value) -> builder.addVarg(C_INT, (int)value)),\n-        DOUBLE(double.class, C_DOUBLE, \"%.4f\", scope ->1.2345d, 1.2345d, VaList.Builder::addVarg);\n+        CHAR(byte.class, C_CHAR, \"%c\", session -> (byte) 'h', 'h', (builder, layout, value) -> builder.addVarg(C_INT, (int)value)),\n+        DOUBLE(double.class, C_DOUBLE, \"%.4f\", session ->1.2345d, 1.2345d, VaList.Builder::addVarg);\n@@ -407,1 +400,1 @@\n-        final Function<ResourceScope, ?> nativeValueFactory;\n+        final Function<MemorySession, ?> nativeValueFactory;\n@@ -412,1 +405,1 @@\n-        <Z, L extends ValueLayout> PrintfArg(Class<?> carrier, L layout, String format, Function<ResourceScope, Z> nativeValueFactory, Object javaValue, VaListBuilderCall<Z, L> builderCall) {\n+        <Z, L extends ValueLayout> PrintfArg(Class<?> carrier, L layout, String format, Function<MemorySession, Z> nativeValueFactory, Object javaValue, VaListBuilderCall<Z, L> builderCall) {\n@@ -423,2 +416,2 @@\n-        public void accept(VaList.Builder builder, ResourceScope scope) {\n-            builderCall.build(builder, layout, nativeValueFactory.apply(scope));\n+        public void accept(VaList.Builder builder, MemorySession session) {\n+            builderCall.build(builder, layout, nativeValueFactory.apply(session));\n@@ -431,2 +424,2 @@\n-        public Object nativeValue(ResourceScope scope) {\n-            return nativeValueFactory.apply(scope);\n+        public Object nativeValue(MemorySession session) {\n+            return nativeValueFactory.apply(session);\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":34,"deletions":41,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -96,1 +96,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.openImplicit());\n@@ -115,1 +115,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.openImplicit());\n@@ -136,1 +136,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.openImplicit());\n@@ -193,2 +193,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, session);\n@@ -204,2 +204,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, session);\n@@ -213,1 +213,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.openImplicit());\n@@ -256,1 +256,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.openImplicit());\n@@ -294,1 +294,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.openImplicit());\n@@ -333,1 +333,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.openImplicit());\n@@ -376,1 +376,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.openImplicit());\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -111,1 +111,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.openImplicit());\n@@ -122,1 +122,1 @@\n-        MemorySegment segment = MemorySegment.ofAddress(MemoryAddress.NULL, seq.byteSize(), ResourceScope.globalScope());\n+        MemorySegment segment = MemorySegment.ofAddress(MemoryAddress.NULL, seq.byteSize(), MemorySession.global());\n@@ -130,2 +130,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(layout.byteSize() + 1, layout.byteSize(), scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout.byteSize() + 1, layout.byteSize(), session);\n@@ -139,2 +139,3 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newConfinedScope());\n-        segment.scope().close();\n+        var session = MemorySession.openConfined();\n+        MemorySegment segment = MemorySegment.allocateNative(layout, session);\n+        session.close();\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -197,2 +197,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(tuples, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(tuples, session);\n@@ -242,2 +242,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.mapFile(tempPath, 0L, 8, FileChannel.MapMode.READ_WRITE, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.mapFile(tempPath, 0L, 8, FileChannel.MapMode.READ_WRITE, session);\n@@ -247,2 +247,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.mapFile(tempPath, 0L, 8, FileChannel.MapMode.READ_ONLY, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.mapFile(tempPath, 0L, 8, FileChannel.MapMode.READ_ONLY, session);\n@@ -259,1 +259,1 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+        try (MemorySession session = MemorySession.openConfined()) {\n@@ -261,1 +261,1 @@\n-            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE, scope);\n+            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE, session);\n@@ -266,1 +266,1 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+        try (MemorySession session = MemorySession.openConfined()) {\n@@ -268,1 +268,1 @@\n-            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY, scope);\n+            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY, session);\n@@ -279,1 +279,2 @@\n-        MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 8, FileChannel.MapMode.READ_WRITE, ResourceScope.newImplicitScope());\n+        var session = MemorySession.openConfined();\n+        MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 8, FileChannel.MapMode.READ_WRITE, session);\n@@ -281,1 +282,1 @@\n-        segment.scope().close();\n+        session.close();\n@@ -295,1 +296,1 @@\n-            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            try (MemorySession session = MemorySession.openConfined()) {\n@@ -297,1 +298,1 @@\n-                MemorySegment segment = MemorySegment.mapFile(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE, scope);\n+                MemorySegment segment = MemorySegment.mapFile(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE, session);\n@@ -305,1 +306,1 @@\n-            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            try (MemorySession session = MemorySession.openConfined()) {\n@@ -307,1 +308,1 @@\n-                MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY, scope);\n+                MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY, session);\n@@ -325,2 +326,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0, LARGE_SIZE, FileChannel.MapMode.READ_WRITE, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0, LARGE_SIZE, FileChannel.MapMode.READ_WRITE, session);\n@@ -362,2 +363,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(bytes, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(bytes, session);\n@@ -366,1 +367,1 @@\n-        \/\/outside of scope!!\n+        \/\/outside of session!!\n@@ -373,1 +374,1 @@\n-                \/\/all get\/set buffer operation should fail because of the scope check\n+                \/\/all get\/set buffer operation should fail because of the session check\n@@ -388,2 +389,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(bytes, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(bytes, session);\n@@ -422,2 +423,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(bytes, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(bytes, session);\n@@ -435,2 +436,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(seq, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(seq, session);\n@@ -473,2 +474,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(seq, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(seq, session);\n@@ -482,1 +483,1 @@\n-    public void testBufferOnClosedScope() {\n+    public void testBufferOnClosedSession() {\n@@ -484,2 +485,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            leaked = MemorySegment.allocateNative(bytes, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            leaked = MemorySegment.allocateNative(bytes, session);\n@@ -493,1 +494,1 @@\n-        MemorySegment segment = MemorySegment.ofAddress(MemoryAddress.NULL, Integer.MAX_VALUE + 10L, ResourceScope.newImplicitScope());\n+        MemorySegment segment = MemorySegment.ofAddress(MemoryAddress.NULL, Integer.MAX_VALUE + 10L, MemorySession.openImplicit());\n@@ -502,1 +503,1 @@\n-        MemorySegment.mapFile(f.toPath(), 0L, -1, FileChannel.MapMode.READ_WRITE, ResourceScope.newImplicitScope());\n+        MemorySegment.mapFile(f.toPath(), 0L, -1, FileChannel.MapMode.READ_WRITE, MemorySession.openImplicit());\n@@ -510,1 +511,1 @@\n-        MemorySegment.mapFile(f.toPath(), -1, 1, FileChannel.MapMode.READ_WRITE, ResourceScope.newImplicitScope());\n+        MemorySegment.mapFile(f.toPath(), -1, 1, FileChannel.MapMode.READ_WRITE, MemorySession.openImplicit());\n@@ -521,2 +522,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0, SIZE, FileChannel.MapMode.READ_WRITE, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0, SIZE, FileChannel.MapMode.READ_WRITE, session);\n@@ -530,2 +531,2 @@\n-            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-                MemorySegment segment = MemorySegment.mapFile(f.toPath(), offset, SIZE - offset, FileChannel.MapMode.READ_ONLY, scope);\n+            try (MemorySession session = MemorySession.openConfined()) {\n+                MemorySegment segment = MemorySegment.mapFile(f.toPath(), offset, SIZE - offset, FileChannel.MapMode.READ_ONLY, session);\n@@ -543,2 +544,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 0L, FileChannel.MapMode.READ_WRITE, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 0L, FileChannel.MapMode.READ_WRITE, session);\n@@ -554,2 +555,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 0L, FileChannel.MapMode.READ_ONLY, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 0L, FileChannel.MapMode.READ_ONLY, session);\n@@ -569,1 +570,1 @@\n-        MemorySegment.mapFile(path, 0L, 0L, FileChannel.MapMode.READ_WRITE, ResourceScope.newImplicitScope());\n+        MemorySegment.mapFile(path, 0L, 0L, FileChannel.MapMode.READ_WRITE, MemorySession.openImplicit());\n@@ -576,2 +577,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment nativeArray = MemorySegment.allocateNative(bytes, 1, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment nativeArray = MemorySegment.allocateNative(bytes, 1, session);\n@@ -589,2 +590,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment nativeArray = MemorySegment.allocateNative(seq, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment nativeArray = MemorySegment.allocateNative(seq, session);\n@@ -661,2 +662,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment ms = MemorySegment.allocateNative(4, 1, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment ms = MemorySegment.allocateNative(4, 1, session);\n@@ -671,1 +672,2 @@\n-        MemorySegment s1 = MemorySegment.allocateNative(JAVA_INT, ResourceScope.newConfinedScope());\n+        var session = MemorySession.openConfined();\n+        MemorySegment s1 = MemorySegment.allocateNative(JAVA_INT, session);\n@@ -675,1 +677,1 @@\n-        s1.scope().close();\n+        session.close();\n@@ -680,2 +682,2 @@\n-    @Test(dataProvider = \"allScopes\")\n-    public void testIOOnSegmentBuffer(Supplier<ResourceScope> scopeSupplier) throws IOException {\n+    @Test(dataProvider = \"allSessions\")\n+    public void testIOOnSegmentBuffer(Supplier<MemorySession> sessionSupplier) throws IOException {\n@@ -684,1 +686,1 @@\n-        ResourceScope scope;\n+        MemorySession session;\n@@ -686,2 +688,2 @@\n-             ResourceScope scp = closeableScopeOrNull(scope = scopeSupplier.get())) {\n-            MemorySegment segment = MemorySegment.allocateNative(10, 1, scope);\n+            MemorySession scp = closeableSessionOrNull(session = sessionSupplier.get())) {\n+            MemorySegment segment = MemorySegment.allocateNative(10, 1, session);\n@@ -702,2 +704,2 @@\n-    @Test(dataProvider = \"closeableScopes\")\n-    public void testIOOnClosedSegmentBuffer(Supplier<ResourceScope> scopeSupplier) throws IOException {\n+    @Test(dataProvider = \"closeableSessions\")\n+    public void testIOOnClosedSegmentBuffer(Supplier<MemorySession> sessionSupplier) throws IOException {\n@@ -707,1 +709,2 @@\n-            MemorySegment segment = MemorySegment.allocateNative(10, scopeSupplier.get());\n+            var session = sessionSupplier.get();\n+            MemorySegment segment = MemorySegment.allocateNative(10, session);\n@@ -712,1 +715,1 @@\n-            segment.scope().close();\n+            session.close();\n@@ -724,2 +727,2 @@\n-        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(16, scope);\n+        try (MemorySession session = MemorySession.openShared()) {\n+            MemorySegment segment = MemorySegment.allocateNative(16, session);\n@@ -742,2 +745,2 @@\n-        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(16, scope);\n+        try (MemorySession session = MemorySession.openShared()) {\n+            MemorySegment segment = MemorySegment.allocateNative(16, session);\n@@ -753,2 +756,2 @@\n-                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, ResourceScope.newImplicitScope()) },\n-                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, ResourceScope.newConfinedScope()) },\n+                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, MemorySession.openImplicit()) },\n+                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, MemorySession.openConfined()) },\n@@ -759,2 +762,2 @@\n-    @DataProvider(name = \"closeableScopes\")\n-    public static Object[][] closeableScopes() {\n+    @DataProvider(name = \"closeableSessions\")\n+    public static Object[][] closeableSessions() {\n@@ -762,5 +765,4 @@\n-                { (Supplier<ResourceScope>) () -> ResourceScope.newSharedScope()   },\n-                { (Supplier<ResourceScope>) () -> ResourceScope.newConfinedScope() },\n-                { (Supplier<ResourceScope>) () -> ResourceScope.newSharedScope(Cleaner.create())   },\n-                { (Supplier<ResourceScope>) () -> ResourceScope.newConfinedScope(Cleaner.create()) },\n-                { (Supplier<ResourceScope>) () -> ResourceScope.newImplicitScope() }\n+                { (Supplier<MemorySession>) () -> MemorySession.openShared()   },\n+                { (Supplier<MemorySession>) () -> MemorySession.openConfined() },\n+                { (Supplier<MemorySession>) () -> MemorySession.openShared(Cleaner.create())   },\n+                { (Supplier<MemorySession>) () -> MemorySession.openConfined(Cleaner.create()) },\n@@ -770,3 +772,3 @@\n-    @DataProvider(name = \"allScopes\")\n-    public static Object[][] allScopes() {\n-        return Stream.of(new Object[][] { { (Supplier<ResourceScope>)ResourceScope::globalScope } }, closeableScopes())\n+    @DataProvider(name = \"allSessions\")\n+    public static Object[][] allSessions() {\n+        return Stream.of(new Object[][] { { (Supplier<MemorySession>) MemorySession::global} }, closeableSessions())\n@@ -777,4 +779,2 @@\n-    static ResourceScope closeableScopeOrNull(ResourceScope scope) {\n-        if (scope == ResourceScope.globalScope())\n-            return null;\n-        return scope;\n+    static MemorySession closeableSessionOrNull(MemorySession session) {\n+        return session.isCloseable() ? session : null;\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":83,"deletions":83,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -61,1 +61,1 @@\n-        MemorySegment segment = MemorySegment.ofAddress(this.getClass().getClassLoader().findNative(\"c\").get().address(), ValueLayout.JAVA_INT.byteSize(), ResourceScope.globalScope());\n+        MemorySegment segment = MemorySegment.ofAddress(this.getClass().getClassLoader().findNative(\"c\").get().address(), ValueLayout.JAVA_INT.byteSize(), MemorySession.global());\n","filename":"test\/jdk\/java\/foreign\/TestClassLoaderFindNative.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -68,1 +68,1 @@\n-        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+        try (MemorySession session = MemorySession.openShared()) {\n@@ -71,1 +71,1 @@\n-                    SegmentAllocator.newNativeArena(scope) :\n+                    SegmentAllocator.newNativeArena(session) :\n@@ -78,1 +78,1 @@\n-                    assertEquals(((MemorySegment) res).scope(), scope);\n+                    assertEquals(((MemorySegment)res).session(), session);\n@@ -90,1 +90,1 @@\n-        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+        try (MemorySession session = MemorySession.openShared()) {\n@@ -93,1 +93,1 @@\n-                    SegmentAllocator.newNativeArena(scope) :\n+                    SegmentAllocator.newNativeArena(session) :\n@@ -100,1 +100,1 @@\n-                    assertEquals(((MemorySegment) res).scope(), scope);\n+                    assertEquals(((MemorySegment)res).session(), session);\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -42,1 +42,1 @@\n-        return MemorySegment.ofAddress(addr, numElements * layout.byteSize(), ResourceScope.globalScope());\n+        return MemorySegment.ofAddress(addr, numElements * layout.byteSize(), MemorySession.global());\n","filename":"test\/jdk\/java\/foreign\/TestFree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -70,2 +70,2 @@\n-            ResourceScope scope = ResourceScope.newSharedScope();\n-            MemorySegment segment = MemorySegment.allocateNative(SEGMENT_SIZE, 1, scope);\n+            MemorySession session = MemorySession.openShared();\n+            MemorySegment segment = MemorySegment.allocateNative(SEGMENT_SIZE, 1, session);\n@@ -82,1 +82,1 @@\n-            accessExecutor.execute(new Handshaker(scope));\n+            accessExecutor.execute(new Handshaker(session));\n@@ -85,1 +85,1 @@\n-            assertTrue(!segment.scope().isAlive());\n+            assertTrue(!segment.session().isAlive());\n@@ -101,1 +101,1 @@\n-            outer: while (segment.scope().isAlive()) {\n+            outer: while (segment.session().isAlive()) {\n@@ -195,1 +195,1 @@\n-            this.copy = MemorySegment.allocateNative(SEGMENT_SIZE, 1, segment.scope());\n+            this.copy = MemorySegment.allocateNative(SEGMENT_SIZE, 1, segment.session());\n@@ -240,1 +240,1 @@\n-        final ResourceScope scope;\n+        final MemorySession session;\n@@ -242,2 +242,2 @@\n-        Handshaker(ResourceScope scope) {\n-            this.scope = scope;\n+        Handshaker(MemorySession session) {\n+            this.session = session;\n@@ -251,1 +251,1 @@\n-                    scope.close();\n+                    session.close();\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -104,1 +104,1 @@\n-        NATIVE(MemorySegment.allocateNative(8, ResourceScope.newImplicitScope()), -1);\n+        NATIVE(MemorySegment.allocateNative(8, MemorySession.openImplicit()), -1);\n","filename":"test\/jdk\/java\/foreign\/TestHeapAlignment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -46,1 +46,1 @@\n-    private static final NativeSymbol DUMMY_TARGET = NativeSymbol.ofAddress(\"dummy\", MemoryAddress.ofLong(1), ResourceScope.globalScope());\n+    private static final NativeSymbol DUMMY_TARGET = NativeSymbol.ofAddress(\"dummy\", MemoryAddress.ofLong(1), MemorySession.global());\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -482,2 +482,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, session);\n@@ -517,2 +517,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, session);\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+        try (MemorySession session = MemorySession.openConfined()) {\n@@ -64,1 +64,1 @@\n-                    layout.map(l -> ((SequenceLayout)l).withElementCount(4), MemoryLayout.PathElement.groupElement(\"arr\")), scope);\n+                    layout.map(l -> ((SequenceLayout)l).withElementCount(4), MemoryLayout.PathElement.groupElement(\"arr\")), session);\n@@ -88,1 +88,1 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+        try (MemorySession session = MemorySession.openConfined()) {\n@@ -90,1 +90,1 @@\n-                    layout.map(l -> ((SequenceLayout)l).withElementCount(4), MemoryLayout.PathElement.groupElement(\"arr\"), MemoryLayout.PathElement.sequenceElement()), scope);\n+                    layout.map(l -> ((SequenceLayout)l).withElementCount(4), MemoryLayout.PathElement.groupElement(\"arr\"), MemoryLayout.PathElement.sequenceElement()), session);\n@@ -106,2 +106,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(seq, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(seq, session);\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -89,2 +89,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout, scope));\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout, session));\n@@ -113,1 +113,1 @@\n-            throw new AssertionError(); \/\/not ok, scope is closed\n+            throw new AssertionError(); \/\/not ok, session is closed\n@@ -115,1 +115,1 @@\n-            \/\/ok, should fail (scope is closed)\n+            \/\/ok, should fail (session is closed)\n@@ -121,2 +121,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, scope));\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, session));\n@@ -147,1 +147,1 @@\n-            throw new AssertionError(); \/\/not ok, scope is closed\n+            throw new AssertionError(); \/\/not ok, session is closed\n@@ -149,1 +149,1 @@\n-            \/\/ok, should fail (scope is closed)\n+            \/\/ok, should fail (session is closed)\n@@ -183,2 +183,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, scope));\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, session));\n@@ -212,1 +212,1 @@\n-            throw new AssertionError(); \/\/not ok, scope is closed\n+            throw new AssertionError(); \/\/not ok, session is closed\n@@ -214,1 +214,1 @@\n-            \/\/ok, should fail (scope is closed)\n+            \/\/ok, should fail (session is closed)\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -83,2 +83,2 @@\n-            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-                MemorySegment segment = MemorySegment.allocateNative(64, scope);\n+            try (MemorySession session = MemorySession.openConfined()) {\n+                MemorySegment segment = MemorySegment.allocateNative(64, session);\n@@ -96,2 +96,2 @@\n-            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-                MemorySegment segment = MemorySegment.allocateNative(64, scope);\n+            try (MemorySession session = MemorySession.openConfined()) {\n+                MemorySegment segment = MemorySegment.allocateNative(64, session);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessInstance.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -55,2 +55,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(aligned, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(aligned, session);\n@@ -73,2 +73,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(alignedGroup, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(alignedGroup, session);\n@@ -100,2 +100,2 @@\n-            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-                MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n+            try (MemorySession session = MemorySession.openConfined()) {\n+                MemorySegment segment = MemorySegment.allocateNative(layout, session);\n@@ -124,2 +124,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(g, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(g, session);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,365 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.ref java.base\/jdk.internal.foreign\n+ * @run testng\/othervm TestMemorySession\n+ *\/\n+\n+import java.lang.ref.Cleaner;\n+\n+import java.lang.foreign.MemorySession;\n+\n+import jdk.internal.foreign.MemorySessionImpl;\n+import jdk.internal.ref.CleanerFactory;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+import java.util.stream.IntStream;\n+\n+public class TestMemorySession {\n+\n+    final static int N_THREADS = 100;\n+\n+    @Test(dataProvider = \"cleaners\")\n+    public void testConfined(Supplier<Cleaner> cleanerSupplier) {\n+        AtomicInteger acc = new AtomicInteger();\n+        Cleaner cleaner = cleanerSupplier.get();\n+        MemorySession session = cleaner != null ?\n+                MemorySession.openConfined(cleaner) :\n+                MemorySession.openConfined();\n+        for (int i = 0 ; i < N_THREADS ; i++) {\n+            int delta = i;\n+            session.addCloseAction(() -> acc.addAndGet(delta));\n+        }\n+        assertEquals(acc.get(), 0);\n+\n+        if (cleaner == null) {\n+            session.close();\n+            assertEquals(acc.get(), IntStream.range(0, N_THREADS).sum());\n+        } else {\n+            session = null;\n+            int expected = IntStream.range(0, N_THREADS).sum();\n+            while (acc.get() != expected) {\n+                kickGC();\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"cleaners\")\n+    public void testSharedSingleThread(Supplier<Cleaner> cleanerSupplier) {\n+        AtomicInteger acc = new AtomicInteger();\n+        Cleaner cleaner = cleanerSupplier.get();\n+        MemorySession session = cleaner != null ?\n+                MemorySession.openShared(cleaner) :\n+                MemorySession.openShared();\n+        for (int i = 0 ; i < N_THREADS ; i++) {\n+            int delta = i;\n+            session.addCloseAction(() -> acc.addAndGet(delta));\n+        }\n+        assertEquals(acc.get(), 0);\n+\n+        if (cleaner == null) {\n+            session.close();\n+            assertEquals(acc.get(), IntStream.range(0, N_THREADS).sum());\n+        } else {\n+            session = null;\n+            int expected = IntStream.range(0, N_THREADS).sum();\n+            while (acc.get() != expected) {\n+                kickGC();\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"cleaners\")\n+    public void testSharedMultiThread(Supplier<Cleaner> cleanerSupplier) {\n+        AtomicInteger acc = new AtomicInteger();\n+        Cleaner cleaner = cleanerSupplier.get();\n+        List<Thread> threads = new ArrayList<>();\n+        MemorySession session = cleaner != null ?\n+                MemorySession.openShared(cleaner) :\n+                MemorySession.openShared();\n+        AtomicReference<MemorySession> sessionRef = new AtomicReference<>(session);\n+        for (int i = 0 ; i < N_THREADS ; i++) {\n+            int delta = i;\n+            Thread thread = new Thread(() -> {\n+                try {\n+                    sessionRef.get().addCloseAction(() -> {\n+                        acc.addAndGet(delta);\n+                    });\n+                } catch (IllegalStateException ex) {\n+                    \/\/ already closed - we need to call cleanup manually\n+                    acc.addAndGet(delta);\n+                }\n+            });\n+            threads.add(thread);\n+        }\n+        assertEquals(acc.get(), 0);\n+        threads.forEach(Thread::start);\n+\n+        \/\/ if no cleaner, close - not all segments might have been added to the session!\n+        \/\/ if cleaner, don't unset the session - after all, the session is kept alive by threads\n+        if (cleaner == null) {\n+            while (true) {\n+                try {\n+                    session.close();\n+                    break;\n+                } catch (IllegalStateException ise) {\n+                    \/\/ session is acquired (by add) - wait some more\n+                }\n+            }\n+        }\n+\n+        threads.forEach(t -> {\n+            try {\n+                t.join();\n+            } catch (InterruptedException ex) {\n+                fail();\n+            }\n+        });\n+\n+        if (cleaner == null) {\n+            assertEquals(acc.get(), IntStream.range(0, N_THREADS).sum());\n+        } else {\n+            session = null;\n+            sessionRef.set(null);\n+            int expected = IntStream.range(0, N_THREADS).sum();\n+            while (acc.get() != expected) {\n+                kickGC();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testLockSingleThread() {\n+        MemorySession session = MemorySession.openConfined();\n+        List<MemorySession> handles = new ArrayList<>();\n+        for (int i = 0 ; i < N_THREADS ; i++) {\n+            MemorySession handle = MemorySession.openConfined();\n+            keepAlive(handle, session);\n+            handles.add(handle);\n+        }\n+\n+        while (true) {\n+            try {\n+                session.close();\n+                assertEquals(handles.size(), 0);\n+                break;\n+            } catch (IllegalStateException ex) {\n+                assertTrue(handles.size() > 0);\n+                MemorySession handle = handles.remove(0);\n+                handle.close();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testLockSharedMultiThread() {\n+        MemorySession session = MemorySession.openShared();\n+        AtomicInteger lockCount = new AtomicInteger();\n+        for (int i = 0 ; i < N_THREADS ; i++) {\n+            new Thread(() -> {\n+                try (MemorySession handle = MemorySession.openConfined()) {\n+                    keepAlive(handle, session);\n+                    lockCount.incrementAndGet();\n+                    waitSomeTime();\n+                    lockCount.decrementAndGet();\n+                    handle.close();\n+                } catch (IllegalStateException ex) {\n+                    \/\/ might be already closed - do nothing\n+                }\n+            }).start();\n+        }\n+\n+        while (true) {\n+            try {\n+                session.close();\n+                assertEquals(lockCount.get(), 0);\n+                break;\n+            } catch (IllegalStateException ex) {\n+                waitSomeTime();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testCloseEmptyConfinedSession() {\n+        MemorySession.openConfined().close();\n+    }\n+\n+    @Test\n+    public void testCloseEmptySharedSession() {\n+        MemorySession.openShared().close();\n+    }\n+\n+    @Test\n+    public void testCloseConfinedLock() {\n+        MemorySession session = MemorySession.openConfined();\n+        MemorySession handle = MemorySession.openConfined();\n+        keepAlive(handle, session);\n+        AtomicReference<Throwable> failure = new AtomicReference<>();\n+        Thread t = new Thread(() -> {\n+            try {\n+                handle.close();\n+            } catch (Throwable ex) {\n+                failure.set(ex);\n+            }\n+        });\n+        t.start();\n+        try {\n+            t.join();\n+            assertNotNull(failure.get());\n+            assertEquals(failure.get().getClass(), IllegalStateException.class);\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"sessions\")\n+    public void testSessionAcquires(Supplier<MemorySession> sessionFactory) {\n+        MemorySession session = sessionFactory.get();\n+        acquireRecursive(session, 5);\n+        if (session.isCloseable()) {\n+            session.close();\n+        }\n+    }\n+\n+    private void acquireRecursive(MemorySession session, int acquireCount) {\n+        try (MemorySession handle = MemorySession.openConfined()) {\n+            keepAlive(handle, session);\n+            if (acquireCount > 0) {\n+                \/\/ recursive acquire\n+                acquireRecursive(session, acquireCount - 1);\n+            }\n+            if (session.isCloseable()) {\n+                assertThrows(IllegalStateException.class, session::close);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testConfinedSessionWithImplicitDependency() {\n+        MemorySession root = MemorySession.openConfined();\n+        \/\/ Create many implicit sessions which depend on 'root', and let them become unreachable.\n+        for (int i = 0; i < N_THREADS; i++) {\n+            keepAlive(MemorySession.openConfined(Cleaner.create()), root);\n+        }\n+        \/\/ Now let's keep trying to close 'root' until we succeed. This is trickier than it seems: cleanup action\n+        \/\/ might be called from another thread (the Cleaner thread), so that the confined session lock count is updated racily.\n+        \/\/ If that happens, the loop below never terminates.\n+        while (true) {\n+            try {\n+                root.close();\n+                break; \/\/ success!\n+            } catch (IllegalStateException ex) {\n+                kickGC();\n+                for (int i = 0 ; i < N_THREADS ; i++) {  \/\/ add more races from current thread\n+                    try (MemorySession session = MemorySession.openConfined()) {\n+                        keepAlive(session, root);\n+                        \/\/ dummy\n+                    }\n+                }\n+                \/\/ try again\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testConfinedSessionWithSharedDependency() {\n+        MemorySession root = MemorySession.openConfined();\n+        List<Thread> threads = new ArrayList<>();\n+        \/\/ Create many implicit sessions which depend on 'root', and let them become unreachable.\n+        for (int i = 0; i < N_THREADS; i++) {\n+            MemorySession session = MemorySession.openShared(); \/\/ create session inside same thread!\n+            keepAlive(session, root);\n+            Thread t = new Thread(session::close); \/\/ close from another thread!\n+            threads.add(t);\n+            t.start();\n+        }\n+        for (int i = 0 ; i < N_THREADS ; i++) { \/\/ add more races from current thread\n+            try (MemorySession session = MemorySession.openConfined()) {\n+                keepAlive(session, root);\n+                \/\/ dummy\n+            }\n+        }\n+        threads.forEach(t -> {\n+            try {\n+                t.join();\n+            } catch (InterruptedException ex) {\n+                \/\/ ok\n+            }\n+        });\n+        \/\/ Now let's close 'root'. This is trickier than it seems: releases of the confined session happen in different\n+        \/\/ threads, so that the confined session lock count is updated racily. If that happens, the following close will blow up.\n+        root.close();\n+    }\n+\n+    private void waitSomeTime() {\n+        try {\n+            Thread.sleep(10);\n+        } catch (InterruptedException ex) {\n+            \/\/ ignore\n+        }\n+    }\n+\n+    private void kickGC() {\n+        for (int i = 0 ; i < 100 ; i++) {\n+            byte[] b = new byte[100];\n+            System.gc();\n+            Thread.onSpinWait();\n+        }\n+    }\n+\n+    @DataProvider\n+    static Object[][] cleaners() {\n+        return new Object[][] {\n+                { (Supplier<Cleaner>)() -> null },\n+                { (Supplier<Cleaner>)Cleaner::create },\n+                { (Supplier<Cleaner>)CleanerFactory::cleaner }\n+        };\n+    }\n+\n+    @DataProvider\n+    static Object[][] sessions() {\n+        return new Object[][] {\n+                { (Supplier<MemorySession>) MemorySession::openConfined},\n+                { (Supplier<MemorySession>) MemorySession::openShared},\n+                { (Supplier<MemorySession>) MemorySession::openImplicit},\n+                { (Supplier<MemorySession>) MemorySession::global}\n+        };\n+    }\n+\n+    private void keepAlive(MemorySession child, MemorySession parent) {\n+        ((MemorySessionImpl)parent).acquire0();\n+        child.addCloseAction(() -> ((MemorySessionImpl)parent).release0());\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestMemorySession.java","additions":365,"deletions":0,"binary":false,"changes":365,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -36,1 +37,0 @@\n-import java.lang.foreign.ResourceScope;\n@@ -106,2 +106,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            var nativeSegment = MemorySegment.allocateNative(4, 4, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            var nativeSegment = MemorySegment.allocateNative(4, 4, session);\n@@ -118,3 +118,3 @@\n-            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-                var s1 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, scope);\n-                var s2 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, scope);\n+            try (MemorySession session = MemorySession.openConfined()) {\n+                var s1 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, session);\n+                var s2 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, session);\n@@ -157,3 +157,3 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            s1 = MemorySegment.allocateNative(4, 1, scope);\n-            s2 = MemorySegment.allocateNative(4, 1, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            s1 = MemorySegment.allocateNative(4, 1, session);\n+            s2 = MemorySegment.allocateNative(4, 1, session);\n@@ -168,2 +168,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            var segment = MemorySegment.allocateNative(4, 1, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            var segment = MemorySegment.allocateNative(4, 1, session);\n@@ -210,1 +210,1 @@\n-        NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope())),\n+        NATIVE(i -> MemorySegment.allocateNative(i, MemorySession.openImplicit())),\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import org.testng.annotations.Test;\n+\n@@ -36,0 +38,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -37,3 +40,0 @@\n-import java.lang.foreign.ResourceScope;\n-import org.testng.annotations.Test;\n-\n@@ -49,1 +49,1 @@\n-                NativeSymbol.ofAddress(\"nullAddress\", MemoryAddress.NULL, ResourceScope.globalScope()),\n+                NativeSymbol.ofAddress(\"nullAddress\", MemoryAddress.NULL, MemorySession.global()),\n@@ -57,1 +57,1 @@\n-        mh.invokeExact(NativeSymbol.ofAddress(\"null\", MemoryAddress.NULL, ResourceScope.globalScope()));\n+        mh.invokeExact(NativeSymbol.ofAddress(\"null\", MemoryAddress.NULL, MemorySession.global()));\n","filename":"test\/jdk\/java\/foreign\/TestNULLAddress.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -148,2 +148,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(seq, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(seq, session);\n@@ -158,2 +158,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(doubles, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(doubles, session);\n@@ -171,3 +171,3 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            scope.addCloseAction(() -> freeMemory(addr));\n-            MemorySegment mallocSegment = MemorySegment.ofAddress(addr, 12, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            session.addCloseAction(() -> freeMemory(addr));\n+            MemorySegment mallocSegment = MemorySegment.ofAddress(addr, 12, session);\n@@ -182,3 +182,3 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            scope.addCloseAction(() -> freeMemory(addr));\n-            mallocSegment = MemorySegment.ofAddress(addr, 12, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            session.addCloseAction(() -> freeMemory(addr));\n+            mallocSegment = MemorySegment.ofAddress(addr, 12, session);\n@@ -188,1 +188,1 @@\n-        assertTrue(!mallocSegment.scope().isAlive());\n+        assertTrue(!mallocSegment.session().isAlive());\n@@ -201,3 +201,3 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(4, 1, scope);\n-            MemorySegment.ofAddress(segment.address(), 0, ResourceScope.globalScope());\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(4, 1, session);\n+            MemorySegment.ofAddress(segment.address(), 0, MemorySession.global());\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-            ResourceScope.class,\n+            MemorySession.class,\n@@ -108,2 +108,2 @@\n-            \"java.lang.foreign.ResourceScope\/newConfinedScope(java.lang.ref.Cleaner)\/0\/0\",\n-            \"java.lang.foreign.ResourceScope\/newSharedScope(java.lang.ref.Cleaner)\/0\/0\",\n+            \"java.lang.foreign.MemorySession\/openConfined(java.lang.ref.Cleaner)\/0\/0\",\n+            \"java.lang.foreign.MemorySession\/openShared(java.lang.ref.Cleaner)\/0\/0\",\n@@ -183,1 +183,1 @@\n-        addDefaultMapping(ResourceScope.class, ResourceScope.newSharedScope());\n+        addDefaultMapping(MemorySession.class, MemorySession.openShared());\n@@ -187,1 +187,1 @@\n-        addDefaultMapping(NativeSymbol.class, NativeSymbol.ofAddress(\"dummy\", MemoryAddress.ofLong(1), ResourceScope.globalScope()));\n+        addDefaultMapping(NativeSymbol.class, NativeSymbol.ofAddress(\"dummy\", MemoryAddress.ofLong(1), MemorySession.global()));\n@@ -199,1 +199,1 @@\n-            }, ResourceScope.newImplicitScope());\n+            }, MemorySession.openImplicit());\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,364 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @modules java.base\/jdk.internal.ref\n- * @run testng\/othervm TestResourceScope\n- *\/\n-\n-import java.lang.ref.Cleaner;\n-\n-import java.lang.foreign.ResourceScope;\n-import jdk.internal.ref.CleanerFactory;\n-\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.Supplier;\n-import java.util.stream.IntStream;\n-\n-public class TestResourceScope {\n-\n-    final static int N_THREADS = 100;\n-\n-    @Test(dataProvider = \"cleaners\")\n-    public void testConfined(Supplier<Cleaner> cleanerSupplier) {\n-        AtomicInteger acc = new AtomicInteger();\n-        Cleaner cleaner = cleanerSupplier.get();\n-        ResourceScope scope = cleaner != null ?\n-                ResourceScope.newConfinedScope(cleaner) :\n-                ResourceScope.newConfinedScope();\n-        for (int i = 0 ; i < N_THREADS ; i++) {\n-            int delta = i;\n-            scope.addCloseAction(() -> acc.addAndGet(delta));\n-        }\n-        assertEquals(acc.get(), 0);\n-\n-        if (cleaner == null) {\n-            scope.close();\n-            assertEquals(acc.get(), IntStream.range(0, N_THREADS).sum());\n-        } else {\n-            scope = null;\n-            int expected = IntStream.range(0, N_THREADS).sum();\n-            while (acc.get() != expected) {\n-                kickGC();\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"cleaners\")\n-    public void testSharedSingleThread(Supplier<Cleaner> cleanerSupplier) {\n-        AtomicInteger acc = new AtomicInteger();\n-        Cleaner cleaner = cleanerSupplier.get();\n-        ResourceScope scope = cleaner != null ?\n-                ResourceScope.newSharedScope(cleaner) :\n-                ResourceScope.newSharedScope();\n-        for (int i = 0 ; i < N_THREADS ; i++) {\n-            int delta = i;\n-            scope.addCloseAction(() -> acc.addAndGet(delta));\n-        }\n-        assertEquals(acc.get(), 0);\n-\n-        if (cleaner == null) {\n-            scope.close();\n-            assertEquals(acc.get(), IntStream.range(0, N_THREADS).sum());\n-        } else {\n-            scope = null;\n-            int expected = IntStream.range(0, N_THREADS).sum();\n-            while (acc.get() != expected) {\n-                kickGC();\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"cleaners\")\n-    public void testSharedMultiThread(Supplier<Cleaner> cleanerSupplier) {\n-        AtomicInteger acc = new AtomicInteger();\n-        Cleaner cleaner = cleanerSupplier.get();\n-        List<Thread> threads = new ArrayList<>();\n-        ResourceScope scope = cleaner != null ?\n-                ResourceScope.newSharedScope(cleaner) :\n-                ResourceScope.newSharedScope();\n-        AtomicReference<ResourceScope> scopeRef = new AtomicReference<>(scope);\n-        for (int i = 0 ; i < N_THREADS ; i++) {\n-            int delta = i;\n-            Thread thread = new Thread(() -> {\n-                try {\n-                    scopeRef.get().addCloseAction(() -> {\n-                        acc.addAndGet(delta);\n-                    });\n-                } catch (IllegalStateException ex) {\n-                    \/\/ already closed - we need to call cleanup manually\n-                    acc.addAndGet(delta);\n-                }\n-            });\n-            threads.add(thread);\n-        }\n-        assertEquals(acc.get(), 0);\n-        threads.forEach(Thread::start);\n-\n-        \/\/ if no cleaner, close - not all segments might have been added to the scope!\n-        \/\/ if cleaner, don't unset the scope - after all, the scope is kept alive by threads\n-        if (cleaner == null) {\n-            while (true) {\n-                try {\n-                    scope.close();\n-                    break;\n-                } catch (IllegalStateException ise) {\n-                    \/\/ scope is acquired (by add) - wait some more\n-                }\n-            }\n-        }\n-\n-        threads.forEach(t -> {\n-            try {\n-                t.join();\n-            } catch (InterruptedException ex) {\n-                fail();\n-            }\n-        });\n-\n-        if (cleaner == null) {\n-            assertEquals(acc.get(), IntStream.range(0, N_THREADS).sum());\n-        } else {\n-            scope = null;\n-            scopeRef.set(null);\n-            int expected = IntStream.range(0, N_THREADS).sum();\n-            while (acc.get() != expected) {\n-                kickGC();\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void testLockSingleThread() {\n-        ResourceScope scope = ResourceScope.newConfinedScope();\n-        List<ResourceScope> handles = new ArrayList<>();\n-        for (int i = 0 ; i < N_THREADS ; i++) {\n-            ResourceScope handle = ResourceScope.newConfinedScope();\n-            handle.keepAlive(scope);\n-            handles.add(handle);\n-        }\n-\n-        while (true) {\n-            try {\n-                scope.close();\n-                assertEquals(handles.size(), 0);\n-                break;\n-            } catch (IllegalStateException ex) {\n-                assertTrue(handles.size() > 0);\n-                ResourceScope handle = handles.remove(0);\n-                handle.close();\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void testLockSharedMultiThread() {\n-        ResourceScope scope = ResourceScope.newSharedScope();\n-        AtomicInteger lockCount = new AtomicInteger();\n-        for (int i = 0 ; i < N_THREADS ; i++) {\n-            new Thread(() -> {\n-                try (ResourceScope handle = ResourceScope.newConfinedScope()) {\n-                    handle.keepAlive(scope);\n-                    lockCount.incrementAndGet();\n-                    waitSomeTime();\n-                    lockCount.decrementAndGet();\n-                    handle.close();\n-                } catch (IllegalStateException ex) {\n-                    \/\/ might be already closed - do nothing\n-                }\n-            }).start();\n-        }\n-\n-        while (true) {\n-            try {\n-                scope.close();\n-                assertEquals(lockCount.get(), 0);\n-                break;\n-            } catch (IllegalStateException ex) {\n-                waitSomeTime();\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void testCloseEmptyConfinedScope() {\n-        ResourceScope.newConfinedScope().close();\n-    }\n-\n-    @Test\n-    public void testCloseEmptySharedScope() {\n-        ResourceScope.newSharedScope().close();\n-    }\n-\n-    @Test\n-    public void testCloseConfinedLock() {\n-        ResourceScope scope = ResourceScope.newConfinedScope();\n-        ResourceScope handle = ResourceScope.newConfinedScope();\n-        handle.keepAlive(scope);\n-        AtomicReference<Throwable> failure = new AtomicReference<>();\n-        Thread t = new Thread(() -> {\n-            try {\n-                handle.close();\n-            } catch (Throwable ex) {\n-                failure.set(ex);\n-            }\n-        });\n-        t.start();\n-        try {\n-            t.join();\n-            assertNotNull(failure.get());\n-            assertEquals(failure.get().getClass(), IllegalStateException.class);\n-        } catch (Throwable ex) {\n-            throw new AssertionError(ex);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"scopes\")\n-    public void testScopeHandles(Supplier<ResourceScope> scopeFactory) {\n-        ResourceScope scope = scopeFactory.get();\n-        acquireRecursive(scope, 5);\n-        if (scope != ResourceScope.globalScope()) {\n-            scope.close();\n-        }\n-    }\n-\n-    @Test(dataProvider = \"scopes\", expectedExceptions = IllegalArgumentException.class)\n-    public void testAcquireSelf(Supplier<ResourceScope> scopeSupplier) {\n-        ResourceScope scope = scopeSupplier.get();\n-        scope.keepAlive(scope);\n-    }\n-\n-    private void acquireRecursive(ResourceScope scope, int acquireCount) {\n-        try (ResourceScope handle = ResourceScope.newConfinedScope()) {\n-            handle.keepAlive(scope);\n-            if (acquireCount > 0) {\n-                \/\/ recursive acquire\n-                acquireRecursive(scope, acquireCount - 1);\n-            }\n-            if (scope != ResourceScope.globalScope()) {\n-                assertThrows(IllegalStateException.class, scope::close);\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void testConfinedScopeWithImplicitDependency() {\n-        ResourceScope root = ResourceScope.newConfinedScope();\n-        \/\/ Create many implicit scopes which depend on 'root', and let them become unreachable.\n-        for (int i = 0; i < N_THREADS; i++) {\n-            ResourceScope.newConfinedScope(Cleaner.create()).keepAlive(root);\n-        }\n-        \/\/ Now let's keep trying to close 'root' until we succeed. This is trickier than it seems: cleanup action\n-        \/\/ might be called from another thread (the Cleaner thread), so that the confined scope lock count is updated racily.\n-        \/\/ If that happens, the loop below never terminates.\n-        while (true) {\n-            try {\n-                root.close();\n-                break; \/\/ success!\n-            } catch (IllegalStateException ex) {\n-                kickGC();\n-                for (int i = 0 ; i < N_THREADS ; i++) {  \/\/ add more races from current thread\n-                    try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-                        scope.keepAlive(root);\n-                        \/\/ dummy\n-                    }\n-                }\n-                \/\/ try again\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void testConfinedScopeWithSharedDependency() {\n-        ResourceScope root = ResourceScope.newConfinedScope();\n-        List<Thread> threads = new ArrayList<>();\n-        \/\/ Create many implicit scopes which depend on 'root', and let them become unreachable.\n-        for (int i = 0; i < N_THREADS; i++) {\n-            ResourceScope scope = ResourceScope.newSharedScope(); \/\/ create scope inside same thread!\n-            scope.keepAlive(root);\n-            Thread t = new Thread(scope::close); \/\/ close from another thread!\n-            threads.add(t);\n-            t.start();\n-        }\n-        for (int i = 0 ; i < N_THREADS ; i++) { \/\/ add more races from current thread\n-            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-                scope.keepAlive(root);\n-                \/\/ dummy\n-            }\n-        }\n-        threads.forEach(t -> {\n-            try {\n-                t.join();\n-            } catch (InterruptedException ex) {\n-                \/\/ ok\n-            }\n-        });\n-        \/\/ Now let's close 'root'. This is trickier than it seems: releases of the confined scope happen in different\n-        \/\/ threads, so that the confined scope lock count is updated racily. If that happens, the following close will blow up.\n-        root.close();\n-    }\n-\n-    private void waitSomeTime() {\n-        try {\n-            Thread.sleep(10);\n-        } catch (InterruptedException ex) {\n-            \/\/ ignore\n-        }\n-    }\n-\n-    private void kickGC() {\n-        for (int i = 0 ; i < 100 ; i++) {\n-            byte[] b = new byte[100];\n-            System.gc();\n-            Thread.onSpinWait();\n-        }\n-    }\n-\n-    @DataProvider\n-    static Object[][] cleaners() {\n-        return new Object[][] {\n-                { (Supplier<Cleaner>)() -> null },\n-                { (Supplier<Cleaner>)Cleaner::create },\n-                { (Supplier<Cleaner>)CleanerFactory::cleaner }\n-        };\n-    }\n-\n-    @DataProvider\n-    static Object[][] scopes() {\n-        return new Object[][] {\n-                { (Supplier<ResourceScope>)ResourceScope::newConfinedScope },\n-                { (Supplier<ResourceScope>)ResourceScope::newSharedScope },\n-                { (Supplier<ResourceScope>)ResourceScope::newImplicitScope },\n-                { (Supplier<ResourceScope>)ResourceScope::globalScope }\n-        };\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestResourceScope.java","additions":0,"deletions":364,"binary":false,"changes":364,"status":"deleted"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -61,2 +61,2 @@\n-        Method method = MemorySegment.class.getDeclaredMethod(\"ofAddress\", MemoryAddress.class, long.class, ResourceScope.class);\n-        method.invoke(null, MemoryAddress.NULL, 4000L, ResourceScope.globalScope());\n+        Method method = MemorySegment.class.getDeclaredMethod(\"ofAddress\", MemoryAddress.class, long.class, MemorySession.class);\n+        method.invoke(null, MemoryAddress.NULL, 4000L, MemorySession.global());\n@@ -68,2 +68,2 @@\n-            MethodType.methodType(MemorySegment.class, MemoryAddress.class, long.class, ResourceScope.class));\n-        var seg = (MemorySegment)mh.invokeExact(MemoryAddress.NULL, 4000L, ResourceScope.globalScope());\n+            MethodType.methodType(MemorySegment.class, MemoryAddress.class, long.class, MemorySession.class));\n+        var seg = (MemorySegment)mh.invokeExact(MemoryAddress.NULL, 4000L, MemorySession.global());\n@@ -74,1 +74,1 @@\n-        MemorySegment.ofAddress(MemoryAddress.NULL, 4000, ResourceScope.globalScope());\n+        MemorySegment.ofAddress(MemoryAddress.NULL, 4000, MemorySession.global());\n","filename":"test\/jdk\/java\/foreign\/TestRestricted.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -76,3 +76,3 @@\n-        ResourceScope scope = ResourceScope.newConfinedScope();\n-        Z obj = scopedOperation.apply(scope);\n-        scope.close();\n+        MemorySession session = MemorySession.openConfined();\n+        Z obj = scopedOperation.apply(session);\n+        session.close();\n@@ -89,2 +89,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            Z obj = scopedOperation.apply(scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            Z obj = scopedOperation.apply(session);\n@@ -112,10 +112,5 @@\n-        \/\/ scope operations\n-        ScopedOperation.ofScope(scope -> scope.addCloseAction(() -> {\n-        }), \"ResourceScope::addOnClose\");\n-        ScopedOperation.ofScope(scope -> {\n-            ResourceScope scope2 = ResourceScope.newConfinedScope();\n-            scope2.keepAlive(scope);\n-            scope2.close();\n-        }, \"ResourceScope::keepAlive\");\n-        ScopedOperation.ofScope(scope -> MemorySegment.allocateNative(100, scope), \"MemorySegment::allocateNative\");\n-        ScopedOperation.ofScope(scope -> {\n+        \/\/ session operations\n+        ScopedOperation.ofScope(session -> session.addCloseAction(() -> {\n+        }), \"MemorySession::addCloseAction\");\n+        ScopedOperation.ofScope(session -> MemorySegment.allocateNative(100, session), \"MemorySegment::allocateNative\");\n+        ScopedOperation.ofScope(session -> {\n@@ -123,1 +118,1 @@\n-                MemorySegment.mapFile(tempPath, 0, 10, FileChannel.MapMode.READ_WRITE, scope);\n+                MemorySegment.mapFile(tempPath, 0, 10, FileChannel.MapMode.READ_WRITE, session);\n@@ -128,2 +123,2 @@\n-        ScopedOperation.ofScope(scope -> VaList.make(b -> b.addVarg(JAVA_INT, 42), scope), \"VaList::make\");\n-        ScopedOperation.ofScope(scope -> VaList.ofAddress(MemoryAddress.ofLong(42), scope), \"VaList::make\");\n+        ScopedOperation.ofScope(session -> VaList.make(b -> b.addVarg(JAVA_INT, 42), session), \"VaList::make\");\n+        ScopedOperation.ofScope(session -> VaList.ofAddress(MemoryAddress.ofLong(42), session), \"VaList::make\");\n@@ -167,1 +162,1 @@\n-        ScopedOperation.of(scope -> NativeSymbol.ofAddress(\"\", MemoryAddress.NULL, scope), NativeSymbol::address, \"NativeSymbol::address\");\n+        ScopedOperation.of(session -> NativeSymbol.ofAddress(\"\", MemoryAddress.NULL, session), NativeSymbol::address, \"NativeSymbol::address\");\n@@ -175,1 +170,1 @@\n-    static class ScopedOperation<X> implements Consumer<X>, Function<ResourceScope, X> {\n+    static class ScopedOperation<X> implements Consumer<X>, Function<MemorySession, X> {\n@@ -177,1 +172,1 @@\n-        final Function<ResourceScope, X> factory;\n+        final Function<MemorySession, X> factory;\n@@ -181,1 +176,1 @@\n-        private ScopedOperation(Function<ResourceScope, X> factory, Consumer<X> operation, String name) {\n+        private ScopedOperation(Function<MemorySession, X> factory, Consumer<X> operation, String name) {\n@@ -193,2 +188,2 @@\n-        public X apply(ResourceScope scope) {\n-            return factory.apply(scope);\n+        public X apply(MemorySession session) {\n+            return factory.apply(session);\n@@ -197,1 +192,1 @@\n-        static <Z> void of(Function<ResourceScope, Z> factory, Consumer<Z> consumer, String name) {\n+        static <Z> void of(Function<MemorySession, Z> factory, Consumer<Z> consumer, String name) {\n@@ -201,1 +196,1 @@\n-        static void ofScope(Consumer<ResourceScope> scopeConsumer, String name) {\n+        static void ofScope(Consumer<MemorySession> scopeConsumer, String name) {\n@@ -206,1 +201,1 @@\n-            scopedOperations.add(new ScopedOperation<>(scope -> VaList.make(builder -> builder.addVarg(JAVA_LONG, 42), scope),\n+            scopedOperations.add(new ScopedOperation<>(session -> VaList.make(builder -> builder.addVarg(JAVA_LONG, 42), session),\n@@ -230,2 +225,2 @@\n-            NATIVE(scope -> MemorySegment.allocateNative(10, scope)),\n-            MAPPED(scope -> {\n+            NATIVE(session -> MemorySegment.allocateNative(10, session)),\n+            MAPPED(session -> {\n@@ -233,1 +228,1 @@\n-                    return MemorySegment.mapFile(Path.of(\"foo.txt\"), 0, 10, FileChannel.MapMode.READ_WRITE, scope);\n+                    return MemorySegment.mapFile(Path.of(\"foo.txt\"), 0, 10, FileChannel.MapMode.READ_WRITE, session);\n@@ -238,1 +233,1 @@\n-            UNSAFE(scope -> MemorySegment.ofAddress(MemoryAddress.NULL, 10, scope));\n+            UNSAFE(session -> MemorySegment.ofAddress(MemoryAddress.NULL, 10, session));\n@@ -250,1 +245,1 @@\n-            final Function<ResourceScope, MemorySegment> segmentFactory;\n+            final Function<MemorySession, MemorySegment> segmentFactory;\n@@ -252,1 +247,1 @@\n-            SegmentFactory(Function<ResourceScope, MemorySegment> segmentFactory) {\n+            SegmentFactory(Function<MemorySession, MemorySegment> segmentFactory) {\n@@ -258,1 +253,1 @@\n-            ARENA_BOUNDED(scope -> SegmentAllocator.newNativeArena(1000, scope)),\n+            ARENA_BOUNDED(session -> SegmentAllocator.newNativeArena(1000, session)),\n@@ -261,1 +256,1 @@\n-            final Function<ResourceScope, SegmentAllocator> allocatorFactory;\n+            final Function<MemorySession, SegmentAllocator> allocatorFactory;\n@@ -263,1 +258,1 @@\n-            AllocatorFactory(Function<ResourceScope, SegmentAllocator> allocatorFactory) {\n+            AllocatorFactory(Function<MemorySession, SegmentAllocator> allocatorFactory) {\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":32,"deletions":37,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    @Test(dataProvider = \"nativeScopes\")\n+    @Test(dataProvider = \"scalarAllocations\")\n@@ -71,3 +71,3 @@\n-            ResourceScope[] scopes = {\n-                    ResourceScope.newConfinedScope(),\n-                    ResourceScope.newSharedScope()\n+            MemorySession[] sessions = {\n+                    MemorySession.openConfined(),\n+                    MemorySession.openShared()\n@@ -75,3 +75,3 @@\n-            for (ResourceScope scope : scopes) {\n-                try (scope) {\n-                    SegmentAllocator allocator = allocationFactory.allocator(alignedLayout.byteSize() * ELEMS, scope);\n+            for (MemorySession session : sessions) {\n+                try (session) {\n+                    SegmentAllocator allocator = allocationFactory.allocator(alignedLayout.byteSize() * ELEMS, session);\n@@ -97,1 +97,1 @@\n-                        assertFalse(address.scope().isAlive());\n+                        assertFalse(address.session().isAlive());\n@@ -107,3 +107,3 @@\n-    public void testBigAllocationInUnboundedScope() {\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+    public void testBigAllocationInUnboundedSession() {\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(session);\n@@ -122,2 +122,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(10, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(10, session);\n@@ -131,2 +131,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(4 * 1024 * 2, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(4 * 1024 * 2, session);\n@@ -139,1 +139,1 @@\n-        SegmentAllocator.newNativeArena( -1, ResourceScope.globalScope());\n+        SegmentAllocator.newNativeArena( -1, MemorySession.global());\n@@ -142,1 +142,1 @@\n-    @Test(dataProvider = \"arrayScopes\")\n+    @Test(dataProvider = \"arrayAllocations\")\n@@ -145,3 +145,3 @@\n-        ResourceScope[] scopes = {\n-                ResourceScope.newConfinedScope(),\n-                ResourceScope.newSharedScope()\n+        MemorySession[] sessions = {\n+                MemorySession.openConfined(),\n+                MemorySession.openShared()\n@@ -149,3 +149,3 @@\n-        for (ResourceScope scope : scopes) {\n-            try (scope) {\n-                SegmentAllocator allocator = allocationFactory.allocator(100, scope);\n+        for (MemorySession session : sessions) {\n+            try (session) {\n+                SegmentAllocator allocator = allocationFactory.allocator(100, session);\n@@ -159,3 +159,3 @@\n-    @DataProvider(name = \"nativeScopes\")\n-    static Object[][] nativeScopes() {\n-        List<Object[]> nativeScopes = new ArrayList<>();\n+    @DataProvider(name = \"scalarAllocations\")\n+    static Object[][] scalarAllocations() {\n+        List<Object[]> scalarAllocations = new ArrayList<>();\n@@ -163,1 +163,1 @@\n-            nativeScopes.add(new Object[] { (byte)42, factory, ValueLayout.JAVA_BYTE,\n+            scalarAllocations.add(new Object[] { (byte)42, factory, ValueLayout.JAVA_BYTE,\n@@ -166,1 +166,1 @@\n-            nativeScopes.add(new Object[] { (short)42, factory, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN),\n+            scalarAllocations.add(new Object[] { (short)42, factory, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN),\n@@ -169,1 +169,1 @@\n-            nativeScopes.add(new Object[] { (char)42, factory, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN),\n+            scalarAllocations.add(new Object[] { (char)42, factory, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN),\n@@ -172,1 +172,1 @@\n-            nativeScopes.add(new Object[] { 42, factory,\n+            scalarAllocations.add(new Object[] { 42, factory,\n@@ -176,1 +176,1 @@\n-            nativeScopes.add(new Object[] { 42f, factory, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN),\n+            scalarAllocations.add(new Object[] { 42f, factory, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN),\n@@ -179,1 +179,1 @@\n-            nativeScopes.add(new Object[] { 42L, factory, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN),\n+            scalarAllocations.add(new Object[] { 42L, factory, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN),\n@@ -182,1 +182,1 @@\n-            nativeScopes.add(new Object[] { 42d, factory, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN),\n+            scalarAllocations.add(new Object[] { 42d, factory, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN),\n@@ -185,1 +185,1 @@\n-            nativeScopes.add(new Object[] { MemoryAddress.ofLong(42), factory, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+            scalarAllocations.add(new Object[] { MemoryAddress.ofLong(42), factory, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n@@ -189,1 +189,1 @@\n-            nativeScopes.add(new Object[] { (short)42, factory, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+            scalarAllocations.add(new Object[] { (short)42, factory, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN),\n@@ -192,1 +192,1 @@\n-            nativeScopes.add(new Object[] { (char)42, factory, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN),\n+            scalarAllocations.add(new Object[] { (char)42, factory, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN),\n@@ -195,1 +195,1 @@\n-            nativeScopes.add(new Object[] { 42, factory,\n+            scalarAllocations.add(new Object[] { 42, factory,\n@@ -199,1 +199,1 @@\n-            nativeScopes.add(new Object[] { 42f, factory, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+            scalarAllocations.add(new Object[] { 42f, factory, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN),\n@@ -202,1 +202,1 @@\n-            nativeScopes.add(new Object[] { 42L, factory, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN),\n+            scalarAllocations.add(new Object[] { 42L, factory, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN),\n@@ -205,1 +205,1 @@\n-            nativeScopes.add(new Object[] { 42d, factory, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN),\n+            scalarAllocations.add(new Object[] { 42d, factory, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN),\n@@ -208,1 +208,1 @@\n-            nativeScopes.add(new Object[] { MemoryAddress.ofLong(42), factory, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+            scalarAllocations.add(new Object[] { MemoryAddress.ofLong(42), factory, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n@@ -212,1 +212,1 @@\n-        return nativeScopes.toArray(Object[][]::new);\n+        return scalarAllocations.toArray(Object[][]::new);\n@@ -215,3 +215,3 @@\n-    @DataProvider(name = \"arrayScopes\")\n-    static Object[][] arrayScopes() {\n-        List<Object[]> arrayScopes = new ArrayList<>();\n+    @DataProvider(name = \"arrayAllocations\")\n+    static Object[][] arrayAllocations() {\n+        List<Object[]> arrayAllocations = new ArrayList<>();\n@@ -219,1 +219,1 @@\n-            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_BYTE,\n+            arrayAllocations.add(new Object[] { factory, ValueLayout.JAVA_BYTE,\n@@ -222,1 +222,1 @@\n-            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN),\n+            arrayAllocations.add(new Object[] { factory, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN),\n@@ -225,1 +225,1 @@\n-            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+            arrayAllocations.add(new Object[] { factory, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN),\n@@ -228,1 +228,1 @@\n-            arrayScopes.add(new Object[] { factory,\n+            arrayAllocations.add(new Object[] { factory,\n@@ -232,1 +232,1 @@\n-            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+            arrayAllocations.add(new Object[] { factory, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN),\n@@ -235,1 +235,1 @@\n-            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN),\n+            arrayAllocations.add(new Object[] { factory, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN),\n@@ -238,1 +238,1 @@\n-            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN),\n+            arrayAllocations.add(new Object[] { factory, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN),\n@@ -242,1 +242,1 @@\n-            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN),\n+            arrayAllocations.add(new Object[] { factory, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN),\n@@ -245,1 +245,1 @@\n-            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN),\n+            arrayAllocations.add(new Object[] { factory, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN),\n@@ -248,1 +248,1 @@\n-            arrayScopes.add(new Object[] { factory,\n+            arrayAllocations.add(new Object[] { factory,\n@@ -252,1 +252,1 @@\n-            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN),\n+            arrayAllocations.add(new Object[] { factory, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN),\n@@ -255,1 +255,1 @@\n-            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN),\n+            arrayAllocations.add(new Object[] { factory, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN),\n@@ -258,1 +258,1 @@\n-            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN),\n+            arrayAllocations.add(new Object[] { factory, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN),\n@@ -262,1 +262,1 @@\n-        return arrayScopes.toArray(Object[][]::new);\n+        return arrayAllocations.toArray(Object[][]::new);\n@@ -289,3 +289,3 @@\n-        ARENA_UNBOUNDED(false, (size, scope) -> SegmentAllocator.newNativeArena(scope)),\n-        NATIVE_ALLOCATOR(false, (size, scope) -> SegmentAllocator.nativeAllocator(scope)),\n-        IMPLICIT_ALLOCATOR(false, (size, scope) -> SegmentAllocator.implicitAllocator());\n+        ARENA_UNBOUNDED(false, (size, session) -> SegmentAllocator.newNativeArena(session)),\n+        NATIVE_ALLOCATOR(false, (size, session) -> session),\n+        IMPLICIT_ALLOCATOR(false, (size, session) -> SegmentAllocator.implicitAllocator());\n@@ -294,1 +294,1 @@\n-        private final BiFunction<Long, ResourceScope, SegmentAllocator> factory;\n+        private final BiFunction<Long, MemorySession, SegmentAllocator> factory;\n@@ -296,1 +296,1 @@\n-        AllocationFactory(boolean isBound, BiFunction<Long, ResourceScope, SegmentAllocator> factory) {\n+        AllocationFactory(boolean isBound, BiFunction<Long, MemorySession, SegmentAllocator> factory) {\n@@ -301,2 +301,2 @@\n-        SegmentAllocator allocator(long size, ResourceScope scope) {\n-            return factory.apply(size, scope);\n+        SegmentAllocator allocator(long size, MemorySession session) {\n+            return factory.apply(size, session);\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":66,"deletions":66,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -147,1 +147,1 @@\n-            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope())),\n+            NATIVE(i -> MemorySegment.allocateNative(i, MemorySession.openImplicit())),\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -82,1 +82,1 @@\n-            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newConfinedScope())),\n+            NATIVE(i -> MemorySegment.allocateNative(i, MemorySession.openConfined())),\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOffset.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -64,1 +64,1 @@\n-                () -> MemorySegment.allocateNative(16, ResourceScope.newConfinedScope()),\n+                () -> MemorySegment.allocateNative(16, MemorySession.openConfined()),\n@@ -67,1 +67,1 @@\n-                        return MemorySegment.mapFile(tempPath, 0L, 16, FileChannel.MapMode.READ_WRITE, ResourceScope.newConfinedScope());\n+                        return MemorySegment.mapFile(tempPath, 0L, 16, FileChannel.MapMode.READ_WRITE, MemorySession.openConfined());\n@@ -101,1 +101,1 @@\n-        assertEquals(s1.asOverlappingSlice(s2).scope(), s1.scope());\n+        assertEquals(s1.asOverlappingSlice(s2).session(), s1.session());\n@@ -104,1 +104,1 @@\n-        assertEquals(s2.asOverlappingSlice(s1).scope(), s2.scope());\n+        assertEquals(s2.asOverlappingSlice(s1).session(), s2.session());\n@@ -120,1 +120,1 @@\n-            assertEquals(s1.asOverlappingSlice(slice).scope(), s1.scope());\n+            assertEquals(s1.asOverlappingSlice(slice).session(), s1.session());\n@@ -123,1 +123,1 @@\n-            assertEquals(slice.asOverlappingSlice(s1).scope(), slice.scope());\n+            assertEquals(slice.asOverlappingSlice(s1).session(), slice.session());\n@@ -134,1 +134,1 @@\n-        NATIVE(() -> MemorySegment.allocateNative(16, ResourceScope.newConfinedScope())),\n+        NATIVE(() -> MemorySegment.allocateNative(16, MemorySession.openConfined())),\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOverlap.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -41,0 +41,1 @@\n+import java.util.function.Function;\n@@ -51,1 +52,1 @@\n-        MemorySegment.allocateNative(size, align, ResourceScope.newImplicitScope());\n+        MemorySegment.allocateNative(size, align, MemorySession.openImplicit());\n@@ -57,1 +58,1 @@\n-        MemorySegment.allocateNative(Long.MAX_VALUE, ResourceScope.newImplicitScope());\n+        MemorySegment.allocateNative(Long.MAX_VALUE, MemorySession.openImplicit());\n@@ -62,1 +63,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(1024 * 1024 * 8 * 2, ResourceScope.newImplicitScope()); \/\/ 2M\n+        MemorySegment segment = MemorySegment.allocateNative(1024 * 1024 * 8 * 2, MemorySession.openImplicit()); \/\/ 2M\n@@ -68,2 +69,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(1000, 1, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(1000, 1, session);\n@@ -79,2 +80,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(10, 1, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(10, 1, session);\n@@ -100,1 +101,1 @@\n-        MemorySegment memorySegment = MemorySegment.allocateNative(10, ResourceScope.newImplicitScope());\n+        MemorySegment memorySegment = MemorySegment.allocateNative(10, MemorySession.openImplicit());\n@@ -107,1 +108,1 @@\n-        MemorySegment memorySegment = MemorySegment.allocateNative(10, ResourceScope.newImplicitScope());\n+        MemorySegment memorySegment = MemorySegment.allocateNative(10, MemorySession.openImplicit());\n@@ -112,2 +113,3 @@\n-    public void testAccessModesOfFactories(Supplier<MemorySegment> memorySegmentSupplier) {\n-        MemorySegment segment = memorySegmentSupplier.get();\n+    public void testAccessModesOfFactories(Supplier<SegmentFactory> segmentFactorySupplier) {\n+        SegmentFactory segmentFactory = segmentFactorySupplier.get();\n+        MemorySegment segment = segmentFactory.segment();\n@@ -115,7 +117,1 @@\n-        tryClose(segment);\n-    }\n-\n-    static void tryClose(MemorySegment segment) {\n-        if (segment.scope() != ResourceScope.globalScope()) {\n-            segment.scope().close();\n-        }\n+        segmentFactory.tryClose();\n@@ -126,15 +122,11 @@\n-        List<Supplier<MemorySegment>> l = List.of(\n-                () -> MemorySegment.ofArray(new byte[] { 0x00, 0x01, 0x02, 0x03 }),\n-                () -> MemorySegment.ofArray(new char[] {'a', 'b', 'c', 'd' }),\n-                () -> MemorySegment.ofArray(new double[] { 1d, 2d, 3d, 4d} ),\n-                () -> MemorySegment.ofArray(new float[] { 1.0f, 2.0f, 3.0f, 4.0f }),\n-                () -> MemorySegment.ofArray(new int[] { 1, 2, 3, 4 }),\n-                () -> MemorySegment.ofArray(new long[] { 1l, 2l, 3l, 4l } ),\n-                () -> MemorySegment.ofArray(new short[] { 1, 2, 3, 4 } ),\n-                () -> MemorySegment.allocateNative(4, ResourceScope.newImplicitScope()),\n-                () -> MemorySegment.allocateNative(4, 8, ResourceScope.newImplicitScope()),\n-                () -> MemorySegment.allocateNative(JAVA_INT, ResourceScope.newImplicitScope()),\n-                () -> MemorySegment.allocateNative(4, ResourceScope.newImplicitScope()),\n-                () -> MemorySegment.allocateNative(4, 8, ResourceScope.newImplicitScope()),\n-                () -> MemorySegment.allocateNative(JAVA_INT, ResourceScope.newImplicitScope())\n-\n+        List<Supplier<SegmentFactory>> l = List.of(\n+                () -> SegmentFactory.ofArray(() -> MemorySegment.ofArray(new byte[] { 0x00, 0x01, 0x02, 0x03 })),\n+                () -> SegmentFactory.ofArray(() -> MemorySegment.ofArray(new char[] {'a', 'b', 'c', 'd' })),\n+                () -> SegmentFactory.ofArray(() -> MemorySegment.ofArray(new double[] { 1d, 2d, 3d, 4d} )),\n+                () -> SegmentFactory.ofArray(() -> MemorySegment.ofArray(new float[] { 1.0f, 2.0f, 3.0f, 4.0f })),\n+                () -> SegmentFactory.ofArray(() -> MemorySegment.ofArray(new int[] { 1, 2, 3, 4 })),\n+                () -> SegmentFactory.ofArray(() -> MemorySegment.ofArray(new long[] { 1l, 2l, 3l, 4l } )),\n+                () -> SegmentFactory.ofArray(() -> MemorySegment.ofArray(new short[] { 1, 2, 3, 4 } )),\n+                () -> SegmentFactory.ofImplicitSession(session -> MemorySegment.allocateNative(4, 8, session)),\n+                () -> SegmentFactory.ofImplicitSession(session -> MemorySegment.allocateNative(JAVA_INT, session)),\n+                () -> SegmentFactory.ofImplicitSession(session -> MemorySegment.allocateNative(4, session))\n@@ -145,0 +137,28 @@\n+    static class SegmentFactory {\n+        final MemorySession session;\n+        final Function<MemorySession, MemorySegment> segmentFunc;\n+\n+        SegmentFactory(MemorySession session, Function<MemorySession, MemorySegment> segmentFunc) {\n+            this.session = session;\n+            this.segmentFunc = segmentFunc;\n+        }\n+\n+        public void tryClose() {\n+            if (session.isCloseable()) {\n+                session.close();\n+            }\n+        }\n+\n+        public MemorySegment segment() {\n+            return segmentFunc.apply(session);\n+        }\n+\n+        static SegmentFactory ofArray(Supplier<MemorySegment> segmentSupplier) {\n+            return new SegmentFactory(MemorySession.global(), (_ignored) -> segmentSupplier.get());\n+        }\n+\n+        static SegmentFactory ofImplicitSession(Function<MemorySession, MemorySegment> segmentFunc) {\n+            return new SegmentFactory(MemorySession.openImplicit(), segmentFunc);\n+        }\n+    }\n+\n@@ -146,1 +166,1 @@\n-    public void testFill(Supplier<MemorySegment> memorySegmentSupplier) {\n+    public void testFill(Supplier<SegmentFactory> segmentFactorySupplier) {\n@@ -150,1 +170,2 @@\n-            MemorySegment segment = memorySegmentSupplier.get();\n+            SegmentFactory segmentFactory = segmentFactorySupplier.get();\n+            MemorySegment segment = segmentFactory.segment();\n@@ -167,1 +188,1 @@\n-            tryClose(segment);\n+            segmentFactory.tryClose();\n@@ -172,4 +193,5 @@\n-    public void testFillClosed(Supplier<MemorySegment> memorySegmentSupplier) {\n-        MemorySegment segment = memorySegmentSupplier.get();\n-        tryClose(segment);\n-        if (!segment.scope().isAlive()) {\n+    public void testFillClosed(Supplier<SegmentFactory> segmentFactorySupplier) {\n+        SegmentFactory segmentFactory = segmentFactorySupplier.get();\n+        MemorySegment segment = segmentFactory.segment();\n+        segmentFactory.tryClose();\n+        if (!segment.session().isAlive()) {\n@@ -186,2 +208,3 @@\n-    public void testNativeSegments(Supplier<MemorySegment> memorySegmentSupplier) {\n-        MemorySegment segment = memorySegmentSupplier.get();\n+    public void testNativeSegments(Supplier<SegmentFactory> segmentFactorySupplier) {\n+        SegmentFactory segmentFactory = segmentFactorySupplier.get();\n+        MemorySegment segment = segmentFactory.segment();\n@@ -194,1 +217,1 @@\n-        tryClose(segment);\n+        segmentFactory.tryClose();\n@@ -198,2 +221,3 @@\n-    public void testFillIllegalAccessMode(Supplier<MemorySegment> memorySegmentSupplier) {\n-        MemorySegment segment = memorySegmentSupplier.get();\n+    public void testFillIllegalAccessMode(Supplier<SegmentFactory> segmentFactorySupplier) {\n+        SegmentFactory segmentFactory = segmentFactorySupplier.get();\n+        MemorySegment segment = segmentFactory.segment();\n@@ -201,1 +225,1 @@\n-        tryClose(segment);\n+        segmentFactory.tryClose();\n@@ -205,2 +229,3 @@\n-    public void testFillThread(Supplier<MemorySegment> memorySegmentSupplier) throws Exception {\n-        MemorySegment segment = memorySegmentSupplier.get();\n+    public void testFillThread(Supplier<SegmentFactory> segmentFactorySupplier) throws Exception {\n+        SegmentFactory segmentFactory = segmentFactorySupplier.get();\n+        MemorySegment segment = segmentFactory.segment();\n@@ -219,1 +244,1 @@\n-        if (segment.scope().ownerThread() != null) {\n+        if (segment.session().ownerThread() != null) {\n@@ -227,1 +252,1 @@\n-        tryClose(segment);\n+        segmentFactory.tryClose();\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":76,"deletions":51,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n-            MemorySegment s = MemorySegment.allocateNative(layout, scope);\n+        try (MemorySession session = MemorySession.openShared()) {\n+            MemorySegment s = MemorySegment.allocateNative(layout, session);\n@@ -96,2 +96,2 @@\n-        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n-            MemorySegment s = MemorySegment.allocateNative(4, 1, scope);\n+        try (MemorySession session = MemorySession.openShared()) {\n+            MemorySegment s = MemorySegment.allocateNative(4, 1, session);\n@@ -101,1 +101,1 @@\n-            MemorySegment sharedSegment = MemorySegment.ofAddress(s.address(), s.byteSize(), scope);\n+            MemorySegment sharedSegment = MemorySegment.ofAddress(s.address(), s.byteSize(), session);\n@@ -123,2 +123,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment s1 = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT), scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment s1 = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT), session);\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -49,2 +49,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(LAYOUT, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(LAYOUT, session);\n","filename":"test\/jdk\/java\/foreign\/TestSlices.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -60,2 +60,2 @@\n-        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n+        try (MemorySession session = MemorySession.openShared()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, session);\n@@ -87,1 +87,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.openImplicit());\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -42,2 +42,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(expectedByteLength, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(expectedByteLength, session);\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -56,2 +56,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, session);\n@@ -64,2 +64,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, session);\n@@ -72,2 +72,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, session);\n@@ -80,2 +80,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, session);\n","filename":"test\/jdk\/java\/foreign\/TestTypeAccess.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -40,1 +41,0 @@\n-import java.lang.foreign.ResourceScope;\n@@ -64,2 +64,2 @@\n-        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+        try (MemorySession session = MemorySession.openShared()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(session);\n@@ -68,1 +68,1 @@\n-            Object[] args = makeArgs(ResourceScope.newImplicitScope(), ret, paramTypes, fields, returnChecks, argChecks);\n+            Object[] args = makeArgs(MemorySession.openImplicit(), ret, paramTypes, fields, returnChecks, argChecks);\n@@ -75,1 +75,1 @@\n-            NativeSymbol callback = ABI.upcallStub(mh.asType(CLinker.upcallType(callbackDesc)), callbackDesc, scope);\n+            NativeSymbol callback = ABI.upcallStub(mh.asType(CLinker.upcallType(callbackDesc)), callbackDesc, session);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallAsync.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -31,1 +32,0 @@\n-import java.lang.foreign.ResourceScope;\n@@ -67,1 +67,1 @@\n-        DUMMY_STUB = ABI.upcallStub(DUMMY, FunctionDescriptor.ofVoid(), ResourceScope.newImplicitScope());\n+        DUMMY_STUB = ABI.upcallStub(DUMMY, FunctionDescriptor.ofVoid(), MemorySession.openImplicit());\n@@ -83,2 +83,2 @@\n-    static Object[] makeArgs(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n-        return makeArgs(scope, ret, params, fields, checks, argChecks, List.of());\n+    static Object[] makeArgs(MemorySession session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n+        return makeArgs(session, ret, params, fields, checks, argChecks, List.of());\n@@ -87,1 +87,1 @@\n-    static Object[] makeArgs(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) throws ReflectiveOperationException {\n+    static Object[] makeArgs(MemorySession session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) throws ReflectiveOperationException {\n@@ -96,1 +96,1 @@\n-        args[argNum] = makeCallback(scope, ret, params, fields, checks, argChecks, prefix);\n+        args[argNum] = makeCallback(session, ret, params, fields, checks, argChecks, prefix);\n@@ -100,1 +100,1 @@\n-    static NativeSymbol makeCallback(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n+    static NativeSymbol makeCallback(MemorySession session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n@@ -143,1 +143,1 @@\n-        return ABI.upcallStub(mh, func, scope);\n+        return ABI.upcallStub(mh, func, session);\n@@ -150,1 +150,1 @@\n-                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), ResourceScope.newImplicitScope());\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), MemorySession.openImplicit());\n","filename":"test\/jdk\/java\/foreign\/TestUpcallBase.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -88,1 +88,1 @@\n-                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), ResourceScope.newImplicitScope());\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), MemorySession.openImplicit());\n@@ -103,2 +103,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            NativeSymbol upcallStub = LINKER.upcallStub(target, upcallDescriptor, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            NativeSymbol upcallStub = LINKER.upcallStub(target, upcallDescriptor, session);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -36,1 +37,0 @@\n-import java.lang.foreign.ResourceScope;\n@@ -56,2 +56,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(session);\n@@ -59,1 +59,1 @@\n-            Object[] args = makeArgs(scope, ret, paramTypes, fields, returnChecks, argChecks);\n+            Object[] args = makeArgs(session, ret, paramTypes, fields, returnChecks, argChecks);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallScope.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -37,1 +38,0 @@\n-import java.lang.foreign.ResourceScope;\n@@ -57,2 +57,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(session);\n@@ -60,1 +60,1 @@\n-            Object[] args = makeArgsStack(scope, ret, paramTypes, fields, returnChecks, argChecks);\n+            Object[] args = makeArgsStack(session, ret, paramTypes, fields, returnChecks, argChecks);\n@@ -74,2 +74,2 @@\n-    static Object[] makeArgsStack(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n-        return makeArgs(scope, ret, params, fields, checks, argChecks, STACK_PREFIX_LAYOUTS);\n+    static Object[] makeArgsStack(MemorySession session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n+        return makeArgs(session, ret, params, fields, checks, argChecks, STACK_PREFIX_LAYOUTS);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -92,3 +92,3 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            NativeSymbol upcallStub = LINKER.upcallStub(target, upcallDesc, scope);\n-            MemorySegment argSegment = MemorySegment.allocateNative(S_PDI_LAYOUT, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            NativeSymbol upcallStub = LINKER.upcallStub(target, upcallDesc, session);\n+            MemorySegment argSegment = MemorySegment.allocateNative(S_PDI_LAYOUT, session);\n@@ -99,1 +99,1 @@\n-        assertFalse(captured.scope().isAlive());\n+        assertFalse(captured.session().isAlive());\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -74,4 +74,4 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment writeBack = MemorySegment.allocateNative(args.size() * WRITEBACK_BYTES_PER_ARG, WRITEBACK_BYTES_PER_ARG, scope);\n-            MemorySegment callInfo = MemorySegment.allocateNative(ML_CallInfo, scope);\n-            MemorySegment argIDs = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(args.size(), C_INT), scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment writeBack = MemorySegment.allocateNative(args.size() * WRITEBACK_BYTES_PER_ARG, WRITEBACK_BYTES_PER_ARG, session);\n+            MemorySegment callInfo = MemorySegment.allocateNative(ML_CallInfo, session);\n+            MemorySegment argIDs = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(args.size(), C_INT), session);\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -68,1 +68,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(1, 2, ResourceScope.newImplicitScope());\n+        MemorySegment segment = MemorySegment.allocateNative(1, 2, MemorySession.openImplicit());\n@@ -102,2 +102,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(inner_size * outer_size * 8, 4, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(inner_size * outer_size * 8, 4, session);\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -75,2 +75,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            NativeSymbol stub = CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            NativeSymbol stub = CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), session);\n@@ -88,2 +88,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            NativeSymbol stub = CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.of(C_INT, C_INT), scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            NativeSymbol stub = CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.of(C_INT, C_INT), session);\n","filename":"test\/jdk\/java\/foreign\/ThrowingUpcall.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n@@ -32,2 +34,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ResourceScope;\n@@ -54,4 +54,3 @@\n-    static ResourceScope closeableScopeOrNull(ResourceScope scope) {\n-        if (scope == ResourceScope.globalScope())\n-            return null;\n-        return scope;\n+    static MemorySession closeableSessionOrNull(MemorySession session) {\n+        return (session.isCloseable()) ?\n+                session : null;\n@@ -76,2 +75,2 @@\n-    static ByteBuffer segmentBufferOfSize(ResourceScope scope, int size) {\n-        var segment = MemorySegment.allocateNative(size, 1, scope);\n+    static ByteBuffer segmentBufferOfSize(MemorySession session, int size) {\n+        var segment = MemorySegment.allocateNative(size, 1, session);\n@@ -84,1 +83,1 @@\n-    static ByteBuffer[] segmentBuffersOfSize(int len, ResourceScope scope, int size) {\n+    static ByteBuffer[] segmentBuffersOfSize(int len, MemorySession session, int size) {\n@@ -87,1 +86,1 @@\n-            bufs[i] = segmentBufferOfSize(scope, size);\n+            bufs[i] = segmentBufferOfSize(session, size);\n@@ -93,2 +92,2 @@\n-     * where heap can be from the global scope or scope-less, and direct are\n-     * associated with the given scope.\n+     * where heap can be from the global session or session-less, and direct are\n+     * associated with the given session.\n@@ -96,1 +95,1 @@\n-    static ByteBuffer[] mixedBuffersOfSize(int len, ResourceScope scope, int size) {\n+    static ByteBuffer[] mixedBuffersOfSize(int len, MemorySession session, int size) {\n@@ -98,1 +97,1 @@\n-        boolean atLeastOneScopeBuffer = false;\n+        boolean atLeastOneSessionBuffer = false;\n@@ -109,2 +108,2 @@\n-                    case 2 -> { atLeastOneScopeBuffer = true;\n-                                yield segmentBufferOfSize(scope, size); }\n+                    case 2 -> { atLeastOneSessionBuffer = true;\n+                                yield segmentBufferOfSize(session, size); }\n@@ -114,1 +113,1 @@\n-        } while (!atLeastOneScopeBuffer);\n+        } while (!atLeastOneSessionBuffer);\n@@ -129,2 +128,2 @@\n-    @DataProvider(name = \"confinedScopes\")\n-    public static Object[][] confinedScopes() {\n+    @DataProvider(name = \"confinedSessions\")\n+    public static Object[][] confinedSessions() {\n@@ -132,1 +131,1 @@\n-                { ScopeSupplier.NEW_CONFINED          },\n+                { SessionSupplier.NEW_CONFINED          },\n@@ -136,2 +135,2 @@\n-    @DataProvider(name = \"sharedScopes\")\n-    public static Object[][] sharedScopes() {\n+    @DataProvider(name = \"sharedSessions\")\n+    public static Object[][] sharedSessions() {\n@@ -139,1 +138,1 @@\n-                { ScopeSupplier.NEW_SHARED          },\n+                { SessionSupplier.NEW_SHARED          },\n@@ -143,3 +142,3 @@\n-    @DataProvider(name = \"closeableScopes\")\n-    public static Object[][] closeableScopes() {\n-        return Stream.of(sharedScopes(), confinedScopes())\n+    @DataProvider(name = \"closeableSessions\")\n+    public static Object[][] closeableSessions() {\n+        return Stream.of(sharedSessions(), confinedSessions())\n@@ -150,2 +149,2 @@\n-    @DataProvider(name = \"implicitScopes\")\n-    public static Object[][] implicitScopes() {\n+    @DataProvider(name = \"implicitSessions\")\n+    public static Object[][] implicitSessions() {\n@@ -153,1 +152,1 @@\n-                { ScopeSupplier.GLOBAL       },\n+                { SessionSupplier.GLOBAL       },\n@@ -157,3 +156,3 @@\n-    @DataProvider(name = \"sharedAndImplicitScopes\")\n-    public static Object[][] sharedAndImplicitScopes() {\n-        return Stream.of(sharedScopes(), implicitScopes())\n+    @DataProvider(name = \"sharedAndImplicitSessions\")\n+    public static Object[][] sharedAndImplicitSessions() {\n+        return Stream.of(sharedSessions(), implicitSessions())\n@@ -164,3 +163,3 @@\n-    @DataProvider(name = \"allScopes\")\n-    public static Object[][] allScopes() {\n-        return Stream.of(implicitScopes(), closeableScopes())\n+    @DataProvider(name = \"allSessions\")\n+    public static Object[][] allSessions() {\n+        return Stream.of(implicitSessions(), closeableSessions())\n@@ -171,2 +170,2 @@\n-    @DataProvider(name = \"sharedScopesAndTimeouts\")\n-    public static Object[][] sharedScopesAndTimeouts() {\n+    @DataProvider(name = \"sharedSessionsAndTimeouts\")\n+    public static Object[][] sharedSessionsAndTimeouts() {\n@@ -174,2 +173,2 @@\n-                { ScopeSupplier.NEW_SHARED          ,  0 },\n-                { ScopeSupplier.NEW_SHARED          , 30 },\n+                { SessionSupplier.NEW_SHARED          ,  0 },\n+                { SessionSupplier.NEW_SHARED          , 30 },\n@@ -179,1 +178,1 @@\n-    static class ScopeSupplier implements Supplier<ResourceScope> {\n+    static class SessionSupplier implements Supplier<MemorySession> {\n@@ -181,8 +180,8 @@\n-        static final Supplier<ResourceScope> NEW_CONFINED =\n-                new ScopeSupplier(ResourceScope::newConfinedScope, \"newConfinedScope()\");\n-        static final Supplier<ResourceScope> NEW_SHARED =\n-                new ScopeSupplier(ResourceScope::newSharedScope, \"newSharedScope()\");\n-        static final Supplier<ResourceScope> NEW_IMPLICIT =\n-                new ScopeSupplier(ResourceScope::newImplicitScope, \"newImplicitScope()\");\n-        static final Supplier<ResourceScope> GLOBAL =\n-                new ScopeSupplier(ResourceScope::globalScope, \"globalScope()\");\n+        static final Supplier<MemorySession> NEW_CONFINED =\n+                new SessionSupplier(MemorySession::openConfined, \"newConfinedSession()\");\n+        static final Supplier<MemorySession> NEW_SHARED =\n+                new SessionSupplier(MemorySession::openShared, \"newSharedSession()\");\n+        static final Supplier<MemorySession> NEW_IMPLICIT =\n+                new SessionSupplier(MemorySession::openImplicit, \"newImplicitSession()\");\n+        static final Supplier<MemorySession> GLOBAL =\n+                new SessionSupplier(MemorySession::global, \"globalSession()\");\n@@ -190,1 +189,1 @@\n-        private final Supplier<ResourceScope> supplier;\n+        private final Supplier<MemorySession> supplier;\n@@ -192,1 +191,1 @@\n-        private ScopeSupplier(Supplier<ResourceScope> supplier, String str) {\n+        private SessionSupplier(Supplier<MemorySession> supplier, String str) {\n@@ -197,1 +196,1 @@\n-        @Override public ResourceScope get() { return supplier.get(); }\n+        @Override public MemorySession get() { return supplier.get(); }\n","filename":"test\/jdk\/java\/foreign\/channels\/AbstractChannelsTest.java","additions":50,"deletions":51,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n@@ -52,2 +54,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ResourceScope;\n@@ -69,3 +69,3 @@\n-    \/** Tests that confined scopes are not supported. *\/\n-    @Test(dataProvider = \"confinedScopes\")\n-    public void testWithConfined(Supplier<ResourceScope> scopeSupplier)\n+    \/** Tests that confined sessions are not supported. *\/\n+    @Test(dataProvider = \"confinedSessions\")\n+    public void testWithConfined(Supplier<MemorySession> sessionSupplier)\n@@ -77,2 +77,2 @@\n-             var scope = scopeSupplier.get()) {\n-            var segment = MemorySegment.allocateNative(10, 1, scope);\n+             var session = closeableSessionOrNull(sessionSupplier.get())) {\n+            var segment = MemorySegment.allocateNative(10, 1, session);\n@@ -97,1 +97,1 @@\n-                        .assertExceptionMessage(\"Confined scope not supported\");\n+                        .assertExceptionMessage(\"Confined session not supported\");\n@@ -102,3 +102,3 @@\n-    \/** Tests that I\/O with a closed scope throws a suitable exception. *\/\n-    @Test(dataProvider = \"sharedScopesAndTimeouts\")\n-    public void testIOWithClosedSharedScope(Supplier<ResourceScope> scopeSupplier, int timeout)\n+    \/** Tests that I\/O with a closed session throws a suitable exception. *\/\n+    @Test(dataProvider = \"sharedSessionsAndTimeouts\")\n+    public void testIOWithClosedSharedSession(Supplier<MemorySession> sessionSupplier, int timeout)\n@@ -110,4 +110,4 @@\n-            ResourceScope scope = scopeSupplier.get();\n-            ByteBuffer bb = segmentBufferOfSize(scope, 64);\n-            ByteBuffer[] buffers = segmentBuffersOfSize(8, scope, 32);\n-            scope.close();\n+            MemorySession session = sessionSupplier.get();\n+            ByteBuffer bb = segmentBufferOfSize(session, 64);\n+            ByteBuffer[] buffers = segmentBuffersOfSize(8, session, 32);\n+            ((MemorySession)session).close();\n@@ -153,3 +153,3 @@\n-    \/** Tests basic I\/O operations work with views over implicit and shared scopes. *\/\n-    @Test(dataProvider = \"sharedAndImplicitScopes\")\n-    public void testBasicIOWithSupportedScope(Supplier<ResourceScope> scopeSupplier)\n+    \/** Tests basic I\/O operations work with views over implicit and shared sessions. *\/\n+    @Test(dataProvider = \"sharedAndImplicitSessions\")\n+    public void testBasicIOWithSupportedSession(Supplier<MemorySession> sessionSupplier)\n@@ -158,1 +158,1 @@\n-        ResourceScope scope;\n+        MemorySession session;\n@@ -162,3 +162,3 @@\n-             var scp = closeableScopeOrNull(scope = scopeSupplier.get())) {\n-            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, scope);\n-            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, scope);\n+             var scp = closeableSessionOrNull(session = sessionSupplier.get())) {\n+            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, session);\n+            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, session);\n@@ -187,2 +187,2 @@\n-                var writeBuffers = mixedBuffersOfSize(16, scope, 32);\n-                var readBuffers = mixedBuffersOfSize(16, scope, 32);\n+                var writeBuffers = mixedBuffersOfSize(16, session, 32);\n+                var readBuffers = mixedBuffersOfSize(16, session, 32);\n@@ -201,3 +201,3 @@\n-    \/** Tests that a scope is not closeable when there is an outstanding read operation. *\/\n-    @Test(dataProvider = \"sharedScopesAndTimeouts\")\n-    public void testCloseWithOutstandingRead(Supplier<ResourceScope> scopeSupplier, int timeout)\n+    \/** Tests that a session is not closeable when there is an outstanding read operation. *\/\n+    @Test(dataProvider = \"sharedSessionsAndTimeouts\")\n+    public void testCloseWithOutstandingRead(Supplier<MemorySession> sessionSupplier, int timeout)\n@@ -209,2 +209,2 @@\n-             var scope = scopeSupplier.get()) {\n-            var segment = MemorySegment.allocateNative(10, 1, scope);\n+             var session = closeableSessionOrNull(sessionSupplier.get())) {\n+            var segment = MemorySegment.allocateNative(10, 1, session);\n@@ -224,2 +224,2 @@\n-                assertTrue(scope.isAlive());\n-                assertMessage(expectThrows(ISE, () -> scope.close()), \"Scope is kept alive by\");\n+                assertTrue(session.isAlive());\n+                assertMessage(expectThrows(ISE, () -> session.close()), \"Session is acquired by\");\n@@ -228,1 +228,1 @@\n-                \/\/ in turn unlock the scope and allow it to be closed.\n+                \/\/ in turn unlock the session and allow it to be closed.\n@@ -231,1 +231,1 @@\n-                assertTrue(scope.isAlive());\n+                assertTrue(session.isAlive());\n@@ -236,1 +236,1 @@\n-    \/** Tests that a scope is not closeable when there is an outstanding write operation. *\/\n+    \/** Tests that a session is not closeable when there is an outstanding write operation. *\/\n@@ -238,2 +238,2 @@\n-    @Test(dataProvider = \"sharedScopesAndTimeouts\")\n-    public void testCloseWithOutstandingWrite(Supplier<ResourceScope> scopeSupplier, int timeout)\n+    @Test(dataProvider = \"sharedSessionsAndTimeouts\")\n+    public void testCloseWithOutstandingWrite(Supplier<MemorySession> sessionSupplier, int timeout)\n@@ -245,1 +245,1 @@\n-             var scope = scopeSupplier.get()) {\n+             var session = closeableSessionOrNull(sessionSupplier.get())) {\n@@ -255,1 +255,1 @@\n-            var bba = segmentBuffersOfSize(32, scope, 128);\n+            var bba = segmentBuffersOfSize(32, session, 128);\n@@ -264,1 +264,1 @@\n-                                var bba = segmentBuffersOfSize(32, scope, 128);\n+                                var bba = segmentBuffersOfSize(32, session, 128);\n@@ -274,2 +274,2 @@\n-            assertMessage(expectThrows(ISE, () -> scope.close()), \"Scope is kept alive by\");\n-            assertTrue(scope.isAlive());\n+            assertMessage(expectThrows(ISE, () -> session.close()), \"Session is acquired by\");\n+            assertTrue(session.isAlive());\n@@ -281,1 +281,1 @@\n-            \/\/ in turn unlock the scope and allow it to be closed.\n+            \/\/ in turn unlock the session and allow it to be closed.\n@@ -283,1 +283,1 @@\n-            assertTrue(scope.isAlive());\n+            assertTrue(session.isAlive());\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":43,"deletions":43,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -58,2 +58,2 @@\n-    @Test(dataProvider = \"closeableScopes\")\n-    public void testBasicIOWithClosedSegment(Supplier<ResourceScope> scopeSupplier)\n+    @Test(dataProvider = \"closeableSessions\")\n+    public void testBasicIOWithClosedSegment(Supplier<MemorySession> sessionSupplier)\n@@ -65,3 +65,3 @@\n-            ResourceScope scope = scopeSupplier.get();\n-            ByteBuffer bb = segmentBufferOfSize(scope, 16);\n-            scope.close();\n+            MemorySession session = sessionSupplier.get();\n+            ByteBuffer bb = segmentBufferOfSize(session, 16);\n+            ((MemorySession)session).close();\n@@ -77,2 +77,2 @@\n-    @Test(dataProvider = \"closeableScopes\")\n-    public void testScatterGatherWithClosedSegment(Supplier<ResourceScope> scopeSupplier)\n+    @Test(dataProvider = \"closeableSessions\")\n+    public void testScatterGatherWithClosedSegment(Supplier<MemorySession> sessionSupplier)\n@@ -84,3 +84,3 @@\n-            ResourceScope scope = scopeSupplier.get();\n-            ByteBuffer[] buffers = segmentBuffersOfSize(8, scope, 16);\n-            scope.close();\n+            MemorySession session = (MemorySession)sessionSupplier.get();\n+            ByteBuffer[] buffers = segmentBuffersOfSize(8, session, 16);\n+            session.close();\n@@ -94,2 +94,2 @@\n-    @Test(dataProvider = \"allScopes\")\n-    public void testBasicIO(Supplier<ResourceScope> scopeSupplier)\n+    @Test(dataProvider = \"allSessions\")\n+    public void testBasicIO(Supplier<MemorySession> sessionSupplier)\n@@ -98,1 +98,1 @@\n-        ResourceScope scope;\n+        MemorySession session;\n@@ -102,3 +102,3 @@\n-             var scp = closeableScopeOrNull(scope = scopeSupplier.get())) {\n-            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, scope);\n-            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, scope);\n+             var scp = closeableSessionOrNull(session = sessionSupplier.get())) {\n+            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, session);\n+            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, session);\n@@ -117,1 +117,1 @@\n-    public void testBasicHeapIOWithGlobalScope() throws Exception {\n+    public void testBasicHeapIOWithGlobalSession() throws Exception {\n@@ -134,2 +134,2 @@\n-    @Test(dataProvider = \"confinedScopes\")\n-    public void testIOOnConfinedFromAnotherThread(Supplier<ResourceScope> scopeSupplier)\n+    @Test(dataProvider = \"confinedSessions\")\n+    public void testIOOnConfinedFromAnotherThread(Supplier<MemorySession> sessionSupplier)\n@@ -141,2 +141,2 @@\n-             var scope = scopeSupplier.get()) {\n-            var segment = MemorySegment.allocateNative(10, 1, scope);\n+             var session = closeableSessionOrNull(sessionSupplier.get())) {\n+            var segment = MemorySegment.allocateNative(10, 1, session);\n@@ -163,2 +163,2 @@\n-    @Test(dataProvider = \"allScopes\")\n-    public void testScatterGatherIO(Supplier<ResourceScope> scopeSupplier)\n+    @Test(dataProvider = \"allSessions\")\n+    public void testScatterGatherIO(Supplier<MemorySession> sessionSupplier)\n@@ -167,1 +167,1 @@\n-        ResourceScope scope;\n+        MemorySession session;\n@@ -171,3 +171,3 @@\n-             var scp = closeableScopeOrNull(scope = scopeSupplier.get())) {\n-            var writeBuffers = mixedBuffersOfSize(32, scope, 64);\n-            var readBuffers = mixedBuffersOfSize(32, scope, 64);\n+             var scp = closeableSessionOrNull(session = sessionSupplier.get())) {\n+            var writeBuffers = mixedBuffersOfSize(32, session, 64);\n+            var readBuffers = mixedBuffersOfSize(32, session, 64);\n@@ -181,2 +181,2 @@\n-    @Test(dataProvider = \"closeableScopes\")\n-    public void testBasicIOWithDifferentScopes(Supplier<ResourceScope> scopeSupplier)\n+    @Test(dataProvider = \"closeableSessions\")\n+    public void testBasicIOWithDifferentSessions(Supplier<MemorySession> sessionSupplier)\n@@ -188,3 +188,3 @@\n-             var scope1 = scopeSupplier.get();\n-             var scope2 = scopeSupplier.get()) {\n-            var writeBuffers = Stream.of(mixedBuffersOfSize(16, scope1, 64), mixedBuffersOfSize(16, scope2, 64))\n+             var session1 = closeableSessionOrNull(sessionSupplier.get());\n+             var session2 = closeableSessionOrNull(sessionSupplier.get())) {\n+            var writeBuffers = Stream.of(mixedBuffersOfSize(16, session1, 64), mixedBuffersOfSize(16, session2, 64))\n@@ -193,1 +193,1 @@\n-            var readBuffers = Stream.of(mixedBuffersOfSize(16, scope1, 64), mixedBuffersOfSize(16, scope2, 64))\n+            var readBuffers = Stream.of(mixedBuffersOfSize(16, session1, 64), mixedBuffersOfSize(16, session2, 64))\n","filename":"test\/jdk\/java\/foreign\/channels\/TestSocketChannels.java","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -77,1 +77,1 @@\n-        addDefaultMapping(ResourceScope.class, ResourceScope.newImplicitScope());\n+        addDefaultMapping(MemorySession.class, MemorySession.openImplicit());\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/handle\/invoker\/MethodHandleInvoker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -55,1 +55,1 @@\n-                            MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)),\n+                            MethodType.methodType(VaList.class, MemoryAddress.class, MemorySession.class)),\n@@ -58,1 +58,1 @@\n-                            MethodType.methodType(MemorySegment.class, MemoryAddress.class, long.class, ResourceScope.class)),\n+                            MethodType.methodType(MemorySegment.class, MemoryAddress.class, long.class, MemorySession.class)),\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -58,1 +58,1 @@\n-        MemorySegment seg = MemorySegment.ofAddress(ma, 4L, ResourceScope.newImplicitScope());\n+        MemorySegment seg = MemorySegment.ofAddress(ma, 4L, MemorySession.openImplicit());\n","filename":"test\/jdk\/java\/foreign\/malloc\/TestMixedMallocFree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -119,2 +119,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            NativeSymbol stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            NativeSymbol stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), session);\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -118,2 +118,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            NativeSymbol stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            NativeSymbol stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), session);\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -83,2 +83,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            NativeSymbol stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(C_INT, C_INT, C_INT, C_INT), scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            NativeSymbol stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(C_INT, C_INT, C_INT, C_INT), session);\n","filename":"test\/jdk\/java\/foreign\/upcalldeopt\/TestUpcallDeopt.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-            ADDRESS_TO_VALIST = MethodHandles.lookup().findStatic(VaList.class, \"ofAddress\", MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class));\n+            ADDRESS_TO_VALIST = MethodHandles.lookup().findStatic(VaList.class, \"ofAddress\", MethodType.methodType(VaList.class, MemoryAddress.class, MemorySession.class));\n@@ -124,1 +124,1 @@\n-            = actions -> Windowsx64Linker.newVaList(actions, ResourceScope.newConfinedScope());\n+            = actions -> Windowsx64Linker.newVaList(actions, MemorySession.openImplicit());\n@@ -126,1 +126,1 @@\n-            = actions -> SysVx64Linker.newVaList(actions, ResourceScope.newConfinedScope());\n+            = actions -> SysVx64Linker.newVaList(actions, MemorySession.openImplicit());\n@@ -128,1 +128,1 @@\n-            = actions -> LinuxAArch64Linker.newVaList(actions, ResourceScope.newConfinedScope());\n+            = actions -> LinuxAArch64Linker.newVaList(actions, MemorySession.openImplicit());\n@@ -130,1 +130,1 @@\n-            = actions -> MacOsAArch64Linker.newVaList(actions, ResourceScope.newConfinedScope());\n+            = actions -> MacOsAArch64Linker.newVaList(actions, MemorySession.openImplicit());\n@@ -132,12 +132,12 @@\n-            = (builder) -> VaList.make(builder, ResourceScope.newConfinedScope());\n-\n-    private static final BiFunction<Consumer<VaList.Builder>, ResourceScope, VaList> winVaListScopedFactory\n-            = (builder, scope) -> Windowsx64Linker.newVaList(builder, scope);\n-    private static final BiFunction<Consumer<VaList.Builder>, ResourceScope, VaList> sysvVaListScopedFactory\n-            = (builder, scope) -> SysVx64Linker.newVaList(builder, scope);\n-    private static final BiFunction<Consumer<VaList.Builder>, ResourceScope, VaList> linuxAArch64VaListScopedFactory\n-            = (builder, scope) -> LinuxAArch64Linker.newVaList(builder, scope);\n-    private static final BiFunction<Consumer<VaList.Builder>, ResourceScope, VaList> macAArch64VaListScopedFactory\n-            = (builder, scope) -> MacOsAArch64Linker.newVaList(builder, scope);\n-    private static final BiFunction<Consumer<VaList.Builder>, ResourceScope, VaList> platformVaListScopedFactory\n-            = (builder, scope) -> VaList.make(builder, scope);\n+            = (builder) -> VaList.make(builder, MemorySession.openConfined());\n+\n+    private static final BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> winVaListScopedFactory\n+            = (builder, session) -> Windowsx64Linker.newVaList(builder, session);\n+    private static final BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> sysvVaListScopedFactory\n+            = (builder, session) -> SysVx64Linker.newVaList(builder, session);\n+    private static final BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> linuxAArch64VaListScopedFactory\n+            = (builder, session) -> LinuxAArch64Linker.newVaList(builder, session);\n+    private static final BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> macAArch64VaListScopedFactory\n+            = (builder, session) -> MacOsAArch64Linker.newVaList(builder, session);\n+    private static final BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> platformVaListScopedFactory\n+            = (builder, session) -> VaList.make(builder, session);\n@@ -171,1 +171,0 @@\n-        vaList.scope().close();\n@@ -200,1 +199,0 @@\n-        vaList.scope().close();\n@@ -225,2 +223,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT, session);\n@@ -231,1 +229,0 @@\n-            vaList.scope().close();\n@@ -245,1 +242,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(pointLayout, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(pointLayout, MemorySession.openImplicit());\n@@ -281,2 +278,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, session);\n@@ -289,1 +286,0 @@\n-            vaList.scope().close();\n@@ -299,1 +295,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.openImplicit());\n@@ -335,2 +331,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, session);\n@@ -343,1 +339,0 @@\n-            vaList.scope().close();\n@@ -353,1 +348,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, MemorySession.openImplicit());\n@@ -390,2 +385,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, session);\n@@ -398,1 +393,0 @@\n-            vaList.scope().close();\n@@ -412,1 +406,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, MemorySession.openImplicit());\n@@ -455,2 +449,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, session);\n@@ -464,1 +458,0 @@\n-            vaList.scope().close();\n@@ -508,3 +501,3 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment longSum = MemorySegment.allocateNative(longLayout, scope);\n-            MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment longSum = MemorySegment.allocateNative(longLayout, session);\n+            MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout, session);\n@@ -523,5 +516,1 @@\n-            try {\n-                sumStack.invoke(longSum, doubleSum, list);\n-            } finally {\n-                list.scope().close();\n-            }\n+            sumStack.invoke(longSum, doubleSum, list);\n@@ -540,2 +529,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            NativeSymbol stub = abi.upcallStub(callback, desc, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            NativeSymbol stub = abi.upcallStub(callback, desc, session);\n@@ -560,7 +549,0 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class,\n-            expectedExceptionsMessageRegExp = \".*Scope cannot be closed.*\",\n-            dataProvider = \"emptyVaLists\")\n-    public void testEmptyNotCloseable(VaList emptyList) {\n-        emptyList.scope().close();\n-    }\n-\n@@ -584,1 +566,1 @@\n-    public void testScopedVaList(BiFunction<Consumer<VaList.Builder>, ResourceScope, VaList> vaListFactory,\n+    public void testScopedVaList(BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> vaListFactory,\n@@ -588,1 +570,1 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+        try (MemorySession session = MemorySession.openConfined()) {\n@@ -590,1 +572,1 @@\n-                            .addVarg(intLayout, 8), scope);\n+                            .addVarg(intLayout, 8), session);\n@@ -595,1 +577,1 @@\n-        assertFalse(listLeaked.scope().isAlive());\n+        assertFalse(listLeaked.session().isAlive());\n@@ -603,3 +585,3 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            try (ResourceScope innerScope = ResourceScope.newConfinedScope()) {\n-                MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT, innerScope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            try (MemorySession innerSession = MemorySession.openConfined()) {\n+                MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT, innerSession);\n@@ -609,1 +591,1 @@\n-                pointOut = MemorySegment.allocateNative(Point_LAYOUT, scope);\n+                pointOut = MemorySegment.allocateNative(Point_LAYOUT, session);\n@@ -613,2 +595,1 @@\n-                list.scope().close();\n-                assertTrue(pointOut.scope().isAlive()); \/\/ after VaList freed\n+                assertTrue(pointOut.session().isAlive()); \/\/ after VaList freed\n@@ -616,1 +597,1 @@\n-            assertTrue(pointOut.scope().isAlive()); \/\/ after inner scope freed\n+            assertTrue(pointOut.session().isAlive()); \/\/ after inner session freed\n@@ -618,1 +599,1 @@\n-        assertFalse(pointOut.scope().isAlive()); \/\/ after outer scope freed\n+        assertFalse(pointOut.session().isAlive()); \/\/ after outer session freed\n@@ -624,4 +605,4 @@\n-                { winVaListFactory,          Win64.C_INT   },\n-                { sysvVaListFactory,         SysV.C_INT    },\n-                { linuxAArch64VaListFactory, AArch64.C_INT },\n-                { macAArch64VaListFactory,   AArch64.C_INT },\n+                { winVaListScopedFactory,          Win64.C_INT   },\n+                { sysvVaListScopedFactory,         SysV.C_INT    },\n+                { linuxAArch64VaListScopedFactory, AArch64.C_INT },\n+                { macAArch64VaListScopedFactory,   AArch64.C_INT },\n@@ -632,17 +613,18 @@\n-    public void testCopy(Function<Consumer<VaList.Builder>, VaList> vaListFactory, ValueLayout.OfInt intLayout) {\n-        VaList list = vaListFactory.apply(b -> b.addVarg(intLayout, 4)\n-                .addVarg(intLayout, 8));\n-        VaList  copy = list.copy();\n-        assertEquals(copy.nextVarg(intLayout), 4);\n-        assertEquals(copy.nextVarg(intLayout), 8);\n-\n-\/\/        try { \/\/ this logic only works on Windows!\n-\/\/            int x = copy.vargAsInt(intLayout);\n-\/\/            fail();\n-\/\/        } catch (IndexOutOfBoundsException ex) {\n-\/\/            \/\/ ok - we exhausted the list\n-\/\/        }\n-\n-        assertEquals(list.nextVarg(intLayout), 4);\n-        assertEquals(list.nextVarg(intLayout), 8);\n-        list.scope().close();\n+    public void testCopy(BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> vaListFactory, ValueLayout.OfInt intLayout) {\n+        try (var session = MemorySession.openConfined()) {\n+            VaList list = vaListFactory.apply(b -> b.addVarg(intLayout, 4)\n+                    .addVarg(intLayout, 8), session);\n+            VaList copy = list.copy();\n+            assertEquals(copy.nextVarg(intLayout), 4);\n+            assertEquals(copy.nextVarg(intLayout), 8);\n+\n+            \/\/        try { \/\/ this logic only works on Windows!\n+            \/\/            int x = copy.vargAsInt(intLayout);\n+            \/\/            fail();\n+            \/\/        } catch (IndexOutOfBoundsException ex) {\n+            \/\/            \/\/ ok - we exhausted the list\n+            \/\/        }\n+\n+            assertEquals(list.nextVarg(intLayout), 4);\n+            assertEquals(list.nextVarg(intLayout), 8);\n+        }\n@@ -653,1 +635,1 @@\n-    public void testCopyUnusableAfterOriginalClosed(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n+    public void testCopyUnusableAfterOriginalClosed(BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> vaListFactory,\n@@ -655,4 +637,6 @@\n-        VaList list = vaListFactory.apply(b -> b.addVarg(intLayout, 4)\n-                .addVarg(intLayout, 8));\n-        VaList copy = list.copy();\n-        list.scope().close();\n+        VaList copy;\n+        try (var session = MemorySession.openConfined()) {\n+            VaList list = vaListFactory.apply(b -> b.addVarg(intLayout, 4)\n+                    .addVarg(intLayout, 8), session);\n+            copy = list.copy();\n+        }\n@@ -694,1 +678,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.openImplicit());\n@@ -701,1 +685,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.openImplicit());\n@@ -715,1 +699,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.openImplicit());\n@@ -727,1 +711,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, MemorySession.openImplicit());\n@@ -733,1 +717,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, MemorySession.openImplicit());\n@@ -740,1 +724,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, MemorySession.openImplicit());\n@@ -747,1 +731,1 @@\n-                    MemorySegment ms = MemorySegment.ofAddress(intPtr, C_INT.byteSize(), ResourceScope.globalScope());\n+                    MemorySegment ms = MemorySegment.ofAddress(intPtr, C_INT.byteSize(), MemorySession.global());\n@@ -786,1 +770,1 @@\n-                    MemorySegment buffer = MemorySegment.allocateNative(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment buffer = MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.openImplicit());\n@@ -828,1 +812,1 @@\n-                        MethodHandles.insertArguments(ADDRESS_TO_VALIST, 1, ResourceScope.newConfinedScope()));\n+                        MethodHandles.insertArguments(ADDRESS_TO_VALIST, 1, MemorySession.openConfined()));\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":86,"deletions":102,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -173,2 +173,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment seg = MemorySegment.allocateNative(8, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment seg = MemorySegment.allocateNative(8, session);\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestExact.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -68,2 +68,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, session);\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SpliteratorTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -48,1 +48,1 @@\n-                return MemorySegment.allocateNative(s, ResourceScope.newImplicitScope())\n+                return MemorySegment.allocateNative(s, MemorySession.openImplicit())\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorLoadStoreTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -54,4 +54,4 @@\n-    public enum ScopeKind {\n-        CONFINED(ResourceScope::newConfinedScope),\n-        SHARED(ResourceScope::newSharedScope),\n-        IMPLICIT(ResourceScope::newImplicitScope);\n+    public enum SessionKind {\n+        CONFINED(MemorySession::openConfined),\n+        SHARED(MemorySession::openShared),\n+        IMPLICIT(MemorySession::openImplicit);\n@@ -59,1 +59,1 @@\n-        final Supplier<ResourceScope> scopeFactory;\n+        final Supplier<MemorySession> sessionFactory;\n@@ -61,2 +61,2 @@\n-        ScopeKind(Supplier<ResourceScope> scopeFactory) {\n-            this.scopeFactory = scopeFactory;\n+        SessionKind(Supplier<MemorySession> sessionFactory) {\n+            this.sessionFactory = sessionFactory;\n@@ -65,2 +65,2 @@\n-        ResourceScope makeScope() {\n-            return scopeFactory.get();\n+        MemorySession makeSession() {\n+            return sessionFactory.get();\n@@ -71,1 +71,1 @@\n-    public ScopeKind scopeKind;\n+    public BulkMismatchAcquire.SessionKind sessionKind;\n@@ -76,1 +76,1 @@\n-    ResourceScope scope;\n+    MemorySession session;\n@@ -88,3 +88,3 @@\n-        scope = scopeKind.makeScope();\n-        mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, scope);\n-        mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, scope);\n+        session = sessionKind.makeSession();\n+        mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, session);\n+        mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, session);\n@@ -95,2 +95,2 @@\n-        mismatchSegmentSmall1 = MemorySegment.allocateNative(7, scope);\n-        mismatchSegmentSmall2 = MemorySegment.allocateNative(7, scope);\n+        mismatchSegmentSmall1 = MemorySegment.allocateNative(7, session);\n+        mismatchSegmentSmall2 = MemorySegment.allocateNative(7, session);\n@@ -120,1 +120,3 @@\n-        scope.close();\n+        if (session.isCloseable()) {\n+            session.close();\n+        }\n@@ -132,4 +134,5 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            scope.keepAlive(mismatchSegmentLarge1.scope());\n-            return mismatchSegmentLarge1.mismatch(mismatchSegmentLarge2);\n-        }\n+        long[] arr = new long[1];\n+        mismatchSegmentLarge1.session().whileAlive(() -> {\n+            arr[0] = mismatchSegmentLarge1.mismatch(mismatchSegmentSmall2);\n+        });\n+        return arr[0];\n@@ -153,4 +156,5 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            scope.keepAlive(mismatchSegmentLarge1.scope());\n-            return mismatchSegmentSmall1.mismatch(mismatchSegmentSmall2);\n-        }\n+        long[] arr = new long[1];\n+        mismatchSegmentLarge1.session().whileAlive(() -> {\n+            arr[0] = mismatchSegmentSmall1.mismatch(mismatchSegmentSmall2);\n+        });\n+        return arr[0];\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkMismatchAcquire.java","additions":30,"deletions":26,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.foreign.ResourceScope;\n@@ -42,0 +41,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -63,1 +63,1 @@\n-    final ResourceScope scope = ResourceScope.newConfinedScope();\n+    final MemorySession session = MemorySession.openConfined();\n@@ -66,1 +66,1 @@\n-    final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.newConfinedScope());\n+    final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, MemorySession.openConfined());\n@@ -75,2 +75,2 @@\n-    final MemorySegment mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, scope);\n-    final MemorySegment mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, scope);\n+    final MemorySegment mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, session);\n+    final MemorySegment mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, session);\n@@ -81,2 +81,2 @@\n-    final MemorySegment mismatchSegmentSmall1 = MemorySegment.allocateNative(7, scope);\n-    final MemorySegment mismatchSegmentSmall2 = MemorySegment.allocateNative(7, scope);\n+    final MemorySegment mismatchSegmentSmall1 = MemorySegment.allocateNative(7, session);\n+    final MemorySegment mismatchSegmentSmall2 = MemorySegment.allocateNative(7, session);\n@@ -111,1 +111,1 @@\n-        scope.close();\n+        session.close();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkOps.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -83,2 +83,2 @@\n-    static final MemorySegment sharedPoint = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newSharedScope());\n-    static final MemorySegment confinedPoint = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newConfinedScope());\n+    static final MemorySegment sharedPoint = MemorySegment.allocateNative(POINT_LAYOUT, MemorySession.openShared());\n+    static final MemorySegment confinedPoint = MemorySegment.allocateNative(POINT_LAYOUT, MemorySession.openConfined());\n@@ -86,1 +86,1 @@\n-    static final MemorySegment point = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newImplicitScope());\n+    static final MemorySegment point = MemorySegment.allocateNative(POINT_LAYOUT, MemorySession.openImplicit());\n@@ -88,1 +88,1 @@\n-    static final SegmentAllocator recycling_allocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newImplicitScope()));\n+    static final SegmentAllocator recycling_allocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(POINT_LAYOUT, MemorySession.openImplicit()));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadHelper.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -75,1 +75,1 @@\n-    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.newImplicitScope());\n+    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, MemorySession.openImplicit());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverConstant.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -66,2 +66,2 @@\n-    final ResourceScope scope = ResourceScope.newConfinedScope();\n-    final SegmentAllocator recyclingAlloc = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(ALLOC_LAYOUT, scope));\n+    final MemorySession session = MemorySession.openConfined();\n+    final SegmentAllocator recyclingAlloc = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(ALLOC_LAYOUT, session));\n@@ -71,1 +71,1 @@\n-        scope.close();\n+        session.close();\n@@ -85,2 +85,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, session);\n@@ -95,2 +95,2 @@\n-        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, scope);\n+        try (MemorySession session = MemorySession.openShared()) {\n+            MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, session);\n@@ -125,1 +125,1 @@\n-    \/\/ they should just use deterministic deallocation (with confined scope) instead, which delivers much\n+    \/\/ they should just use deterministic deallocation (with confined session) instead, which delivers much\n@@ -141,1 +141,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.newImplicitScope());\n+        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, MemorySession.openImplicit());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNew.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -69,0 +69,1 @@\n+    MemorySession session;\n@@ -80,1 +81,2 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.newConfinedScope());\n+        session = MemorySession.openConfined();\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE, session);\n@@ -92,1 +94,1 @@\n-        segment.scope().close();\n+        session.close();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstant.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -60,0 +60,1 @@\n+    MemorySession session;\n@@ -74,2 +75,3 @@\n-        segmentIn = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.newConfinedScope());\n-        segmentOut = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.newConfinedScope());\n+        session = MemorySession.openConfined();\n+        segmentIn = MemorySegment.allocateNative(ALLOC_SIZE, session);\n+        segmentOut = MemorySegment.allocateNative(ALLOC_SIZE, session);\n@@ -94,2 +96,1 @@\n-        segmentIn.scope().close();\n-        segmentOut.scope().close();\n+        session.close();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantFP.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -91,1 +91,1 @@\n-            MemorySegment s = MemorySegment.allocateNative(ALLOC_SIZE, 1, ResourceScope.newConfinedScope());\n+            MemorySegment s = MemorySegment.allocateNative(ALLOC_SIZE, 1, MemorySession.openConfined());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantHeap.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -84,0 +84,1 @@\n+    MemorySession session;\n@@ -98,1 +99,1 @@\n-        segment = MemorySegment.mapFile(tempPath, 0L, ALLOC_SIZE, FileChannel.MapMode.READ_WRITE, ResourceScope.newConfinedScope());\n+        segment = MemorySegment.mapFile(tempPath, 0L, ALLOC_SIZE, FileChannel.MapMode.READ_WRITE, session = MemorySession.openConfined());\n@@ -104,1 +105,1 @@\n-        segment.scope().close();\n+        session.close();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantMapped.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -63,0 +63,1 @@\n+    MemorySession session;\n@@ -74,1 +75,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, ResourceScope.newConfinedScope());\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, session = MemorySession.openConfined());\n@@ -86,1 +87,1 @@\n-        segment.scope().close();\n+        session.close();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantShared.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -61,0 +61,2 @@\n+\n+    MemorySession session;\n@@ -75,2 +77,2 @@\n-        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.newConfinedScope());\n-        nativeSharedSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.newSharedScope());\n+        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, session = MemorySession.openConfined());\n+        nativeSharedSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, session);\n@@ -100,1 +102,1 @@\n-        nativeSegment.scope().close();\n+        session.close();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverPollutedSegments.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -61,1 +61,1 @@\n-    ResourceScope scope;\n+    MemorySession session;\n@@ -65,2 +65,2 @@\n-        scope = ResourceScope.newConfinedScope();\n-        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, scope);\n+        session = MemorySession.openConfined();\n+        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, session);\n@@ -74,1 +74,1 @@\n-        scope.close();\n+        session.close();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverSlice.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -51,1 +51,1 @@\n-public class ResourceScopeClose {\n+public class MemorySessionClose {\n@@ -107,2 +107,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            return MemorySegment.allocateNative(ALLOC_SIZE, 4, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            return MemorySegment.allocateNative(ALLOC_SIZE, 4, session);\n@@ -114,2 +114,2 @@\n-        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n-            return MemorySegment.allocateNative(ALLOC_SIZE, 4, scope);\n+        try (MemorySession session = MemorySession.openShared()) {\n+            return MemorySegment.allocateNative(ALLOC_SIZE, 4, session);\n@@ -121,1 +121,1 @@\n-        return MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.newImplicitScope());\n+        return MemorySegment.allocateNative(ALLOC_SIZE, 4, MemorySession.openImplicit());\n@@ -127,1 +127,1 @@\n-        return MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.newImplicitScope());\n+        return MemorySegment.allocateNative(ALLOC_SIZE, 4, MemorySession.openImplicit());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySessionClose.java","additions":8,"deletions":8,"binary":false,"changes":16,"previous_filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ResourceScopeClose.java","status":"renamed"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -76,0 +76,1 @@\n+    MemorySession session;\n@@ -85,1 +86,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, ResourceScope.newSharedScope());\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, session = MemorySession.openShared());\n@@ -94,1 +95,1 @@\n-        segment.scope().close();\n+        session.close();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ParallelSum.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -56,2 +56,2 @@\n-    ResourceScope scope = ResourceScope.newConfinedScope();\n-    MemorySegment segment = MemorySegment.allocateNative(100, scope);\n+    MemorySession session = MemorySession.openConfined();\n+    MemorySegment segment = MemorySegment.allocateNative(100, session);\n@@ -75,1 +75,1 @@\n-        scope.close();\n+        session.close();\n@@ -95,1 +95,1 @@\n-        MemorySegment newSegment = MemorySegment.ofAddress(segment.address(), 100, scope);\n+        MemorySegment newSegment = MemorySegment.ofAddress(segment.address(), 100, session);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/PointerInvoke.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -69,1 +69,1 @@\n-        INPUT_SEGMENT = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(INPUT.length, JAVA_INT), ResourceScope.globalScope());\n+        INPUT_SEGMENT = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(INPUT.length, JAVA_INT), MemorySession.global());\n@@ -87,1 +87,1 @@\n-                    ResourceScope.globalScope()\n+                    MemorySession.global()\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/QSort.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -60,1 +60,1 @@\n-    ResourceScope scope = ResourceScope.newImplicitScope();\n+    MemorySession session = MemorySession.openConfined();\n@@ -63,1 +63,1 @@\n-    SegmentAllocator arenaAllocator = SegmentAllocator.newNativeArena(scope);\n+    SegmentAllocator arenaAllocator = SegmentAllocator.newNativeArena(session);\n@@ -84,1 +84,1 @@\n-        segmentAllocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(size + 1, ResourceScope.newConfinedScope()));\n+        segmentAllocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(size + 1, MemorySession.openConfined()));\n@@ -89,1 +89,1 @@\n-        scope.close();\n+        session.close();\n@@ -99,2 +99,2 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(str.length() + 1, scope);\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(str.length() + 1, session);\n@@ -128,1 +128,1 @@\n-        MemorySegment str = MemorySegment.ofAddress(address, len + 1, ResourceScope.globalScope());\n+        MemorySegment str = MemorySegment.ofAddress(address, len + 1, MemorySession.global());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -70,1 +70,1 @@\n-        srcSegmentImplicit = MemorySegment.allocateNative(size, ResourceScope.newImplicitScope());\n+        srcSegmentImplicit = MemorySegment.allocateNative(size, MemorySession.openImplicit());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestLoadBytes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,2 +69,2 @@\n-            this.inputSegment = MemorySegment.ofAddress(MemoryAddress.ofLong(inputAddress), 8*SIZE, ResourceScope.globalScope());\n-            this.outputSegment = MemorySegment.ofAddress(MemoryAddress.ofLong(outputAddress), 8*SIZE, ResourceScope.globalScope());\n+            this.inputSegment = MemorySegment.ofAddress(MemoryAddress.ofLong(inputAddress), 8*SIZE, MemorySession.global());\n+            this.outputSegment = MemorySegment.ofAddress(MemoryAddress.ofLong(outputAddress), 8*SIZE, MemorySession.global());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/UnrolledAccess.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -133,1 +133,1 @@\n-            fd, ResourceScope.globalScope()\n+            fd, MemorySession.global()\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/Upcalls.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -73,1 +73,1 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+        try (MemorySession session = MemorySession.openConfined()) {\n@@ -77,1 +77,1 @@\n-                            .addVarg(C_LONG_LONG, 3L), scope);\n+                            .addVarg(C_LONG_LONG, 3L), session);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VaList.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -61,0 +61,1 @@\n+    MemorySession session;\n@@ -65,1 +66,1 @@\n-        data = MemorySegment.allocateNative(JAVA_INT, ResourceScope.newConfinedScope());\n+        data = MemorySegment.allocateNative(JAVA_INT, session = MemorySession.openConfined());\n@@ -70,1 +71,1 @@\n-        data.scope().close();\n+        session.close();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VarHandleExact.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -31,1 +30,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -37,1 +36,0 @@\n-import static java.lang.invoke.MethodType.methodType;\n@@ -65,0 +63,1 @@\n+    private final MemorySession session;\n@@ -68,5 +67,2 @@\n-        this(MemorySegment.allocateNative(LAYOUT, ResourceScope.newConfinedScope()), x, y);\n-    }\n-\n-    public PanamaPoint(MemorySegment segment, int x, int y) {\n-        this(segment);\n+        this.session = MemorySession.openConfined();\n+        this.segment = MemorySegment.allocateNative(LAYOUT, session);\n@@ -77,4 +73,0 @@\n-    public PanamaPoint(MemorySegment segment) {\n-        this.segment = segment;\n-    }\n-\n@@ -115,1 +107,1 @@\n-        segment.scope().close();\n+        session.close();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/PanamaPoint.java","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -79,1 +79,1 @@\n-  private ResourceScope implicitScope;\n+  private MemorySession implicitScope;\n@@ -112,1 +112,1 @@\n-    implicitScope = ResourceScope.newImplicitScope();\n+    implicitScope = MemorySession.openImplicit();\n@@ -242,1 +242,1 @@\n-    try (final var scope = ResourceScope.newConfinedScope()) {\n+    try (final var scope = MemorySession.openConfined()) {\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.MemorySession;\n@@ -80,1 +80,1 @@\n-  private ResourceScope implicitScope;\n+  private MemorySession implicitScope;\n@@ -115,1 +115,1 @@\n-    implicitScope = ResourceScope.newSharedScope();\n+    implicitScope = MemorySession.openShared();\n@@ -212,1 +212,1 @@\n-    try (final var scope = ResourceScope.newConfinedScope()) {\n+    try (final var scope = MemorySession.openConfined()) {\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShort.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}