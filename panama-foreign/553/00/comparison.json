{"files":[{"patch":"@@ -1470,5 +1470,0 @@\n-            @Override\n-            public void ensureCustomized(MethodHandle mh) {\n-                mh.customize();\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -136,7 +136,0 @@\n-    \/**\n-     * Ensure given method handle is customized\n-     *\n-     * @param mh the method handle\n-     *\/\n-    void ensureCustomized(MethodHandle mh);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import static java.lang.invoke.MethodHandles.exactInvoker;\n@@ -70,2 +71,0 @@\n-    private static final JavaLangInvokeAccess JLI = SharedSecrets.getJavaLangInvokeAccess();\n-\n@@ -126,1 +125,1 @@\n-            JLI.ensureCustomized(doBindings);\n+            doBindings = insertArguments(exactInvoker(doBindings.type()), 0, doBindings);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+\n+typedef struct {\n+    jclass holder;\n+    jmethodID mid;\n+} *JNICB;\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/JNICB.h","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+public class JNICB {\n+\n+    static {\n+        System.loadLibrary(\"JNICB\");\n+    }\n+\n+    public static native long makeCB(String holder, String name, String signature);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/JNICB.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SymbolLookup;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.invoke.MethodHandles.lookup;\n+import static jdk.incubator.foreign.CLinker.C_INT;\n+import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n+import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n+public class QSort {\n+\n+    static final CLinker abi = CLinker.getInstance();\n+    static final MethodHandle clib_qsort;\n+    static final MemoryAddress native_compar;\n+    static final MemoryAddress panama_upcall_compar;\n+    static final long jni_upcall_compar;\n+\n+    static final int[] INPUT = { 5, 3, 2, 7, 8, 12, 1, 7 };\n+    static final MemorySegment INPUT_SEGMENT;\n+\n+    static {\n+        INPUT_SEGMENT = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(INPUT.length, JAVA_INT), ResourceScope.globalScope());\n+        INPUT_SEGMENT.copyFrom(MemorySegment.ofArray(INPUT));\n+\n+        System.loadLibrary(\"QSortJNI\");\n+        jni_upcall_compar = JNICB.makeCB(\"org\/openjdk\/bench\/jdk\/incubator\/foreign\/QSort\", \"jni_upcall_compar\", \"(II)I\");\n+\n+        try {\n+            SymbolLookup systemLookup = CLinker.systemLookup();\n+            clib_qsort = abi.downcallHandle(\n+                    systemLookup.lookup(\"qsort\").orElseThrow(),\n+                    MethodType.methodType(void.class, MemoryAddress.class, long.class, long.class, MemoryAddress.class),\n+                    FunctionDescriptor.ofVoid(C_POINTER, C_LONG_LONG, C_LONG_LONG, C_POINTER)\n+            );\n+            System.loadLibrary(\"QSort\");\n+            native_compar = SymbolLookup.loaderLookup().lookup(\"compar\").orElseThrow();\n+            panama_upcall_compar = abi.upcallStub(\n+                    lookup().findStatic(QSort.class,\n+                            \"panama_upcall_compar\",\n+                            MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class)),\n+                    FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER),\n+                    ResourceScope.globalScope()\n+            );\n+        } catch (ReflectiveOperationException e) {\n+            throw new BootstrapMethodError(e);\n+        }\n+    }\n+\n+    static native void jni_qsort_optimized(int[] array, long cb);\n+    static native void jni_qsort_naive(int[] array);\n+\n+    @FunctionalInterface\n+    interface JNIComparator {\n+        int cmp(int e0, int e1);\n+    }\n+\n+    static final JNIComparator COMP = QSort::jni_upcall_compar;\n+\n+    @Benchmark\n+    public void native_qsort() throws Throwable {\n+         clib_qsort.invokeExact(INPUT_SEGMENT.address(), (long) INPUT.length, JAVA_INT.byteSize(), native_compar);\n+    }\n+\n+    @Benchmark\n+    public void jni_upcall_qsort_optimized() {\n+        jni_qsort_optimized(INPUT, jni_upcall_compar);\n+    }\n+\n+    @Benchmark\n+    public void jni_upcall_qsort_naive() {\n+        jni_qsort_naive(INPUT);\n+    }\n+\n+    @Benchmark\n+    public void panama_upcall_qsort() throws Throwable {\n+        clib_qsort.invokeExact(INPUT_SEGMENT.address(), (long) INPUT.length, JAVA_INT.byteSize(), panama_upcall_compar);\n+    }\n+\n+    private static int getIntAbsolute(MemoryAddress addr) {\n+        return MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr.toRawLongValue());\n+    }\n+\n+    static int panama_upcall_compar(MemoryAddress e0, MemoryAddress e1) {\n+        return Integer.compare(getIntAbsolute(e0), getIntAbsolute(e1));\n+    }\n+\n+    static int jni_upcall_compar(int j0, int j1) {\n+        return Integer.compare(j0, j1);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/QSort.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -77,4 +77,4 @@\n-        cb_blank_jni = makeCB(className, \"blank\", \"()V\");\n-        cb_identity_jni = makeCB(className, \"identity\", \"(I)I\");\n-        cb_args5_jni = makeCB(className, \"args5\", \"(JDJDJ)V\");\n-        cb_args10_jni = makeCB(className, \"args10\", \"(JDJDJDJDJD)V\");\n+        cb_blank_jni = JNICB.makeCB(className, \"blank\", \"()V\");\n+        cb_identity_jni = JNICB.makeCB(className, \"identity\", \"(I)I\");\n+        cb_args5_jni = JNICB.makeCB(className, \"args5\", \"(JDJDJ)V\");\n+        cb_args10_jni = JNICB.makeCB(className, \"args10\", \"(JDJDJDJDJD)V\");\n@@ -147,1 +147,0 @@\n-    static native long makeCB(String holder, String name, String signature);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/Upcalls.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <stdlib.h>\n+\n+#include \"JNICB.h\"\n+#include \"jlong.h\"\n+\n+#define CHECK_NULL(thing, message) \\\n+    if (thing == NULL) { \\\n+        jclass cls = (*env)->FindClass(env, \"java\/lang\/Exception\"); \\\n+        (*env)->ThrowNew(env, cls, message); \\\n+        return 0; \\\n+    }\n+\n+JNIEXPORT jlong JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_JNICB_makeCB\n+  (JNIEnv *env, jclass cls, jstring holderName, jstring methodName, jstring descriptor) {\n+\n+  const char* holderNameC = (*env)->GetStringUTFChars(env, holderName, NULL);\n+  const char* methodNameC = (*env)->GetStringUTFChars(env, methodName, NULL);\n+  const char* descriptorC = (*env)->GetStringUTFChars(env, descriptor, NULL);\n+\n+  JNICB cb = malloc(sizeof *cb);\n+  CHECK_NULL(cb, \"Can not allocate cb\");\n+\n+  jclass holder = (*env)->FindClass(env, holderNameC);\n+  CHECK_NULL(holder, \"Can not find class\");\n+  holder = (jclass) (*env)->NewGlobalRef(env, holder);\n+  cb->holder = holder;\n+\n+  jmethodID methodID = (*env)->GetStaticMethodID(env, holder, methodNameC, descriptorC);\n+  CHECK_NULL(methodID, \"Can not find method\");\n+  \/\/methodID = (jmethodID) (*env)->NewGlobalRef(env, methodID); \/\/ DON'T DO THIS! -> Crashes GC\n+  cb->mid = methodID;\n+\n+  (*env)->ReleaseStringUTFChars(env, holderName, holderNameC);\n+  (*env)->ReleaseStringUTFChars(env, methodName, methodNameC);\n+  (*env)->ReleaseStringUTFChars(env, descriptor, descriptorC);\n+\n+  return ptr_to_jlong(cb);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libJNICB.c","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+\n+EXPORT int compar(const void* e0, const void* e1) {\n+    int i0 = *((int*) e0);\n+    int i1 = *((int*) e1);\n+    return i0 - i1;\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libQSort.c","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+\n+#include <stdlib.h>\n+\n+#include \"jlong.h\"\n+#include \"JNICB.h\"\n+\n+#ifdef _WIN64\n+#define THREAD_LOCAL __declspec(thread)\n+#else\n+#define THREAD_LOCAL __thread\n+#endif\n+\n+THREAD_LOCAL struct {\n+  JNICB cb;\n+  JNIEnv* env;\n+} ctx_opt;\n+\n+static int comparator(const void* e0, const void* e1) {\n+    JNICB jniCb = ctx_opt.cb;\n+    JNIEnv* env = ctx_opt.env;\n+    jint j0 = *((jint*) e0);\n+    jint j1 = *((jint*) e1);\n+    return (*env)->CallStaticIntMethod(env, jniCb->holder, jniCb->mid, j0, j1);\n+}\n+\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_QSort_jni_1qsort_1optimized\n+        (JNIEnv *env, jclass cls, jintArray arr, jlong cb) {\n+\n+    ctx_opt.cb = jlong_to_ptr(cb);\n+    ctx_opt.env = env;\n+\n+    jint* ints = (*env)->GetIntArrayElements(env, arr, NULL);\n+    jsize length = (*env)->GetArrayLength(env, arr);\n+\n+    qsort(ints, length, sizeof(jint), &comparator);\n+\n+    (*env)->ReleaseIntArrayElements(env, arr, ints, 0);\n+}\n+\n+JavaVM* VM = NULL;\n+\n+int java_cmp(const void *a, const void *b) {\n+   int v1 = *((int*)a);\n+   int v2 = *((int*)b);\n+\n+   JNIEnv* env;\n+   (*VM)->GetEnv(VM, (void**) &env, JNI_VERSION_10);\n+\n+   jclass qsortClass = (*env)->FindClass(env, \"org\/openjdk\/bench\/jdk\/incubator\/foreign\/QSort\");\n+   jmethodID methodId = (*env)->GetStaticMethodID(env, qsortClass, \"jni_upcall_compar\", \"(II)I\");\n+\n+   return (*env)->CallStaticIntMethod(env, qsortClass, methodId, v1, v2);\n+}\n+\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_QSort_jni_1qsort_1naive\n+        (JNIEnv *env, jclass cls, jintArray arr) {\n+    if (VM == NULL) {\n+        (*env)->GetJavaVM(env, &VM);\n+    }\n+\n+    jint* carr = (*env)->GetIntArrayElements(env, arr, 0);\n+    jsize length = (*env)->GetArrayLength(env, arr);\n+    qsort(carr, length, sizeof(jint), java_cmp);\n+    (*env)->ReleaseIntArrayElements(env, arr, carr, 0);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libQSortJNI.c","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -25,20 +25,0 @@\n-#include \"jlong.h\"\n-\n-typedef struct {\n-    jclass holder;\n-    jmethodID mid;\n-} *JNICB;\n-\n-#define CHECK_NULL(thing, message) \\\n-    if (thing == NULL) { \\\n-        jclass cls = (*env)->FindClass(env, \"java\/lang\/Exception\"); \\\n-        (*env)->ThrowNew(env, cls, message); \\\n-        return 0; \\\n-    }\n-\n-JNIEXPORT jlong JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_Upcalls_makeCB\n-  (JNIEnv *env, jclass cls, jstring holderName, jstring methodName, jstring descriptor) {\n-\n-  const char* holderNameC = (*env)->GetStringUTFChars(env, holderName, NULL);\n-  const char* methodNameC = (*env)->GetStringUTFChars(env, methodName, NULL);\n-  const char* descriptorC = (*env)->GetStringUTFChars(env, descriptor, NULL);\n@@ -46,19 +26,2 @@\n-  JNICB cb = malloc(sizeof *cb);\n-  CHECK_NULL(cb, \"Can not allocate cb\");\n-\n-  jclass holder = (*env)->FindClass(env, holderNameC);\n-  CHECK_NULL(holder, \"Can not find class\");\n-  holder = (jclass) (*env)->NewGlobalRef(env, holder);\n-  cb->holder = holder;\n-\n-  jmethodID methodID = (*env)->GetStaticMethodID(env, holder, methodNameC, descriptorC);\n-  CHECK_NULL(methodID, \"Can not find method\");\n-  \/\/methodID = (jmethodID) (*env)->NewGlobalRef(env, methodID); \/\/ DON'T DO THIS! -> Crashes GC\n-  cb->mid = methodID;\n-\n-  (*env)->ReleaseStringUTFChars(env, holderName, holderNameC);\n-  (*env)->ReleaseStringUTFChars(env, methodName, methodNameC);\n-  (*env)->ReleaseStringUTFChars(env, descriptor, descriptorC);\n-\n-  return ptr_to_jlong(cb);\n-}\n+#include \"jlong.h\"\n+#include \"JNICB.h\"\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libUpcallsJNI.c","additions":2,"deletions":39,"binary":false,"changes":41,"status":"modified"}]}