{"files":[{"patch":"@@ -37,1 +37,1 @@\n-        location: msys2\n+        location: ${{ runner.tool_cache }}\/msys2\n@@ -43,1 +43,1 @@\n-        echo \"$env:GITHUB_WORKSPACE\/msys2\/msys64\/usr\/bin\" >> $env:GITHUB_PATH\n+        echo \"$env:RUNNER_TOOL_CACHE\/msys2\/msys64\/usr\/bin\" >> $env:GITHUB_PATH\n","filename":".github\/actions\/get-msys2\/action.yml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -128,0 +128,1 @@\n+        shell: env \/usr\/bin\/bash --login -eo pipefail {0}\n","filename":".github\/workflows\/build-windows.yml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -497,0 +497,3 @@\n+<h4 id=\"report\">REPORT<\/h4>\n+<p>Use this report style when reporting test results (sent to JTReg as\n+<code>-report<\/code>). Defaults to <code>files<\/code>.<\/p>\n","filename":"doc\/testing.html","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -487,0 +487,5 @@\n+#### REPORT\n+\n+Use this report style when reporting test results (sent to JTReg as `-report`).\n+Defaults to `files`.\n+\n","filename":"doc\/testing.md","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -199,0 +199,1 @@\n+$(eval $(call SetTestOpt,REPORT,JTREG))\n@@ -203,1 +204,1 @@\n-        RETRY_COUNT REPEAT_COUNT MAX_OUTPUT $(CUSTOM_JTREG_SINGLE_KEYWORDS), \\\n+        RETRY_COUNT REPEAT_COUNT MAX_OUTPUT REPORT $(CUSTOM_JTREG_SINGLE_KEYWORDS), \\\n@@ -748,0 +749,1 @@\n+  JTREG_REPORT ?= files\n@@ -860,0 +862,1 @@\n+          -report:$${JTREG_REPORT} \\\n","filename":"make\/RunTests.gmk","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -218,0 +218,3 @@\n+# UndefinedBehaviorSanitizer\n+JDKOPT_SETUP_UNDEFINED_BEHAVIOR_SANITIZER\n+\n","filename":"make\/autoconf\/configure.ac","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -448,0 +448,41 @@\n+###############################################################################\n+#\n+# UndefinedBehaviorSanitizer\n+#\n+AC_DEFUN_ONCE([JDKOPT_SETUP_UNDEFINED_BEHAVIOR_SANITIZER],\n+[\n+  # GCC reports lots of likely false positives for stringop-truncation and format-overflow.\n+  # Silence them for now.\n+  UBSAN_CFLAGS=\"-fsanitize=undefined -fsanitize=float-divide-by-zero -Wno-stringop-truncation -Wno-format-overflow -fno-omit-frame-pointer -DUNDEFINED_BEHAVIOR_SANITIZER\"\n+  UBSAN_LDFLAGS=\"-fsanitize=undefined -fsanitize=float-divide-by-zero\"\n+  UTIL_ARG_ENABLE(NAME: ubsan, DEFAULT: false, RESULT: UBSAN_ENABLED,\n+      DESC: [enable UndefinedBehaviorSanitizer],\n+      CHECK_AVAILABLE: [\n+        AC_MSG_CHECKING([if UndefinedBehaviorSanitizer (ubsan) is available])\n+        if test \"x$TOOLCHAIN_TYPE\" = \"xgcc\" ||\n+            test \"x$TOOLCHAIN_TYPE\" = \"xclang\"; then\n+          AC_MSG_RESULT([yes])\n+        else\n+          AC_MSG_RESULT([no])\n+          AVAILABLE=false\n+        fi\n+      ],\n+      IF_ENABLED: [\n+        JVM_CFLAGS=\"$JVM_CFLAGS $UBSAN_CFLAGS\"\n+        JVM_LDFLAGS=\"$JVM_LDFLAGS $UBSAN_LDFLAGS\"\n+        CFLAGS_JDKLIB=\"$CFLAGS_JDKLIB $UBSAN_CFLAGS\"\n+        CFLAGS_JDKEXE=\"$CFLAGS_JDKEXE $UBSAN_CFLAGS\"\n+        CXXFLAGS_JDKLIB=\"$CXXFLAGS_JDKLIB $UBSAN_CFLAGS\"\n+        CXXFLAGS_JDKEXE=\"$CXXFLAGS_JDKEXE $UBSAN_CFLAGS\"\n+        LDFLAGS_JDKLIB=\"$LDFLAGS_JDKLIB $UBSAN_LDFLAGS\"\n+        LDFLAGS_JDKEXE=\"$LDFLAGS_JDKEXE $UBSAN_LDFLAGS\"\n+      ])\n+  if test \"x$UBSAN_ENABLED\" = xfalse; then\n+    UBSAN_CFLAGS=\"\"\n+    UBSAN_LDFLAGS=\"\"\n+  fi\n+  AC_SUBST(UBSAN_CFLAGS)\n+  AC_SUBST(UBSAN_LDFLAGS)\n+  AC_SUBST(UBSAN_ENABLED)\n+])\n+\n@@ -784,1 +825,1 @@\n-          DEFAULT: openjdk_codesign, CHECK_VALUE: UTIL_CHECK_STRING_NON_EMPTY,\n+          DEFAULT: openjdk_codesign, CHECK_VALUE: [UTIL_CHECK_STRING_NON_EMPTY],\n","filename":"make\/autoconf\/jdk-options.m4","additions":42,"deletions":1,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -72,0 +72,5 @@\n+  # Note: UTIL_ARG_WITH treats empty strings as valid values when OPTIONAL is false!\n+\n+  # Outer [ ] to quote m4.\n+  [ USERNAME=`$ECHO \"$USER\" | $TR -d -c '[a-z][A-Z][0-9]'` ]\n+\n@@ -73,10 +78,6 @@\n-  AC_ARG_WITH([build-user], [AS_HELP_STRING([--with-build-user],\n-      [build username to use in version strings])])\n-  if test \"x$with_build_user\" = xyes || test \"x$with_build_user\" = xno; then\n-    AC_MSG_ERROR([--with-build-user must have a value])\n-  elif test \"x$with_build_user\" != x; then\n-    USERNAME=\"$with_build_user\"\n-  else\n-    # Outer [ ] to quote m4.\n-    [ USERNAME=`$ECHO \"$USER\" | $TR -d -c '[a-z][A-Z][0-9]'` ]\n-  fi\n+  UTIL_ARG_WITH(NAME: build-user, TYPE: string,\n+    RESULT: USERNAME,\n+    DEFAULT: $USERNAME,\n+    DESC: [build username to use in version strings],\n+    DEFAULT_DESC: [current username, sanitized],\n+    CHECK_VALUE: [UTIL_CHECK_STRING_NON_EMPTY])\n@@ -86,14 +87,7 @@\n-  AC_ARG_WITH(jdk-rc-name, [AS_HELP_STRING([--with-jdk-rc-name],\n-      [Set JDK RC name. This is used for FileDescription and ProductName properties\n-       of MS Windows binaries. @<:@not specified@:>@])])\n-  if test \"x$with_jdk_rc_name\" = xyes || test \"x$with_jdk_rc_name\" = xno; then\n-    AC_MSG_ERROR([--with-jdk-rc-name must have a value])\n-  elif [ ! [[ $with_jdk_rc_name =~ ^[[:print:]]*$ ]] ]; then\n-    AC_MSG_ERROR([--with-jdk-rc-name contains non-printing characters: $with_jdk_rc_name])\n-  elif test \"x$with_jdk_rc_name\" != x; then\n-    # Set JDK_RC_NAME to a custom value if '--with-jdk-rc-name' was used and is not empty.\n-    JDK_RC_NAME=\"$with_jdk_rc_name\"\n-  else\n-    # Otherwise calculate from \"branding.conf\" included above.\n-    JDK_RC_NAME=\"$PRODUCT_NAME $JDK_RC_PLATFORM_NAME\"\n-  fi\n+  # Otherwise calculate from \"branding.conf\" included above.\n+  UTIL_ARG_WITH(NAME: jdk-rc-name, TYPE: string,\n+    DEFAULT: $PRODUCT_NAME $JDK_RC_PLATFORM_NAME,\n+    DESC: [Set JDK RC name. This is used for FileDescription and ProductName\n+       properties of MS Windows binaries.],\n+    DEFAULT_DESC: [from branding.conf],\n+    CHECK_VALUE: [UTIL_CHECK_STRING_NON_EMPTY_PRINTABLE])\n@@ -103,12 +97,9 @@\n-  AC_ARG_WITH(vendor-name, [AS_HELP_STRING([--with-vendor-name],\n-      [Set vendor name. Among others, used to set the 'java.vendor'\n-       and 'java.vm.vendor' system properties. @<:@not specified@:>@])])\n-  if test \"x$with_vendor_name\" = xyes || test \"x$with_vendor_name\" = xno; then\n-    AC_MSG_ERROR([--with-vendor-name must have a value])\n-  elif [ ! [[ $with_vendor_name =~ ^[[:print:]]*$ ]] ]; then\n-    AC_MSG_ERROR([--with-vendor-name contains non-printing characters: $with_vendor_name])\n-  elif test \"x$with_vendor_name\" != x; then\n-    # Only set COMPANY_NAME if '--with-vendor-name' was used and is not empty.\n-    # Otherwise we will use the value from \"branding.conf\" included above.\n-    COMPANY_NAME=\"$with_vendor_name\"\n-  fi\n+  # Only set COMPANY_NAME if '--with-vendor-name' was used and is not empty.\n+  # Otherwise we will use the value from \"branding.conf\" included above.\n+  UTIL_ARG_WITH(NAME: vendor-name, TYPE: string,\n+    RESULT: COMPANY_NAME,\n+    DEFAULT: $COMPANY_NAME,\n+    DESC: [Set vendor name. Among others, used to set the 'java.vendor'\n+       and 'java.vm.vendor' system properties.],\n+    DEFAULT_DESC: [from branding.conf],\n+    CHECK_VALUE: [UTIL_CHECK_STRING_NON_EMPTY_PRINTABLE])\n@@ -118,11 +109,7 @@\n-  AC_ARG_WITH(vendor-url, [AS_HELP_STRING([--with-vendor-url],\n-      [Set the 'java.vendor.url' system property @<:@not specified@:>@])])\n-  if test \"x$with_vendor_url\" = xyes || test \"x$with_vendor_url\" = xno; then\n-    AC_MSG_ERROR([--with-vendor-url must have a value])\n-  elif [ ! [[ $with_vendor_url =~ ^[[:print:]]*$ ]] ]; then\n-    AC_MSG_ERROR([--with-vendor-url contains non-printing characters: $with_vendor_url])\n-  elif test \"x$with_vendor_url\" != x; then\n-    # Only set VENDOR_URL if '--with-vendor-url' was used and is not empty.\n-    # Otherwise we will use the value from \"branding.conf\" included above.\n-    VENDOR_URL=\"$with_vendor_url\"\n-  fi\n+  # Only set VENDOR_URL if '--with-vendor-url' was used and is not empty.\n+  # Otherwise we will use the value from \"branding.conf\" included above.\n+  UTIL_ARG_WITH(NAME: vendor-url, TYPE: string,\n+    DEFAULT: $VENDOR_URL,\n+    DESC: [Set the 'java.vendor.url' system property],\n+    DEFAULT_DESC: [from branding.conf],\n+    CHECK_VALUE: [UTIL_CHECK_STRING_NON_EMPTY_PRINTABLE])\n@@ -132,11 +119,8 @@\n-  AC_ARG_WITH(vendor-bug-url, [AS_HELP_STRING([--with-vendor-bug-url],\n-      [Set the 'java.vendor.url.bug' system property @<:@not specified@:>@])])\n-  if test \"x$with_vendor_bug_url\" = xyes || test \"x$with_vendor_bug_url\" = xno; then\n-    AC_MSG_ERROR([--with-vendor-bug-url must have a value])\n-  elif [ ! [[ $with_vendor_bug_url =~ ^[[:print:]]*$ ]] ]; then\n-    AC_MSG_ERROR([--with-vendor-bug-url contains non-printing characters: $with_vendor_bug_url])\n-  elif test \"x$with_vendor_bug_url\" != x; then\n-    # Only set VENDOR_URL_BUG if '--with-vendor-bug-url' was used and is not empty.\n-    # Otherwise we will use the value from \"branding.conf\" included above.\n-    VENDOR_URL_BUG=\"$with_vendor_bug_url\"\n-  fi\n+  # Only set VENDOR_URL_BUG if '--with-vendor-bug-url' was used and is not empty.\n+  # Otherwise we will use the value from \"branding.conf\" included above.\n+  UTIL_ARG_WITH(NAME: vendor-bug-url, TYPE: string,\n+    RESULT: VENDOR_URL_BUG,\n+    DEFAULT: $VENDOR_URL_BUG,\n+    DESC: [Set the 'java.vendor.url.bug' system property],\n+    DEFAULT_DESC: [from branding.conf],\n+    CHECK_VALUE: [UTIL_CHECK_STRING_NON_EMPTY_PRINTABLE])\n@@ -146,11 +130,8 @@\n-  AC_ARG_WITH(vendor-vm-bug-url, [AS_HELP_STRING([--with-vendor-vm-bug-url],\n-      [Sets the bug URL which will be displayed when the VM crashes @<:@not specified@:>@])])\n-  if test \"x$with_vendor_vm_bug_url\" = xyes || test \"x$with_vendor_vm_bug_url\" = xno; then\n-    AC_MSG_ERROR([--with-vendor-vm-bug-url must have a value])\n-  elif [ ! [[ $with_vendor_vm_bug_url =~ ^[[:print:]]*$ ]] ]; then\n-    AC_MSG_ERROR([--with-vendor-vm-bug-url contains non-printing characters: $with_vendor_vm_bug_url])\n-  elif test \"x$with_vendor_vm_bug_url\" != x; then\n-    # Only set VENDOR_URL_VM_BUG if '--with-vendor-vm-bug-url' was used and is not empty.\n-    # Otherwise we will use the value from \"branding.conf\" included above.\n-    VENDOR_URL_VM_BUG=\"$with_vendor_vm_bug_url\"\n-  fi\n+  # Only set VENDOR_URL_VM_BUG if '--with-vendor-vm-bug-url' was used and is not empty.\n+  # Otherwise we will use the value from \"branding.conf\" included above.\n+  UTIL_ARG_WITH(NAME: vendor-vm-bug-url, TYPE: string,\n+    RESULT: VENDOR_URL_VM_BUG,\n+    DEFAULT: $VENDOR_URL_VM_BUG,\n+    DESC: [Sets the bug URL which will be displayed when the VM crashes],\n+    DEFAULT_DESC: [from branding.conf],\n+    CHECK_VALUE: [UTIL_CHECK_STRING_NON_EMPTY_PRINTABLE])\n@@ -163,30 +144,52 @@\n-  AC_ARG_WITH(version-string, [AS_HELP_STRING([--with-version-string],\n-      [Set version string @<:@calculated@:>@])])\n-  if test \"x$with_version_string\" = xyes || test \"x$with_version_string\" = xno; then\n-    AC_MSG_ERROR([--with-version-string must have a value])\n-  elif test \"x$with_version_string\" != x; then\n-    # Additional [] needed to keep m4 from mangling shell constructs.\n-    if [ [[ $with_version_string =~ ^([0-9]+)(\\.([0-9]+))?(\\.([0-9]+))?(\\.([0-9]+))?(\\.([0-9]+))?(\\.([0-9]+))?(\\.([0-9]+))?(-([a-zA-Z0-9]+))?(((\\+)([0-9]*))?(-([-a-zA-Z0-9.]+))?)?$ ]] ]; then\n-      VERSION_FEATURE=${BASH_REMATCH[[1]]}\n-      VERSION_INTERIM=${BASH_REMATCH[[3]]}\n-      VERSION_UPDATE=${BASH_REMATCH[[5]]}\n-      VERSION_PATCH=${BASH_REMATCH[[7]]}\n-      VERSION_EXTRA1=${BASH_REMATCH[[9]]}\n-      VERSION_EXTRA2=${BASH_REMATCH[[11]]}\n-      VERSION_EXTRA3=${BASH_REMATCH[[13]]}\n-      VERSION_PRE=${BASH_REMATCH[[15]]}\n-      version_plus_separator=${BASH_REMATCH[[18]]}\n-      VERSION_BUILD=${BASH_REMATCH[[19]]}\n-      VERSION_OPT=${BASH_REMATCH[[21]]}\n-      # Unspecified numerical fields are interpreted as 0.\n-      if test \"x$VERSION_INTERIM\" = x; then\n-        VERSION_INTERIM=0\n-      fi\n-      if test \"x$VERSION_UPDATE\" = x; then\n-        VERSION_UPDATE=0\n-      fi\n-      if test \"x$VERSION_PATCH\" = x; then\n-        VERSION_PATCH=0\n-      fi\n-      if test \"x$VERSION_EXTRA1\" = x; then\n-        VERSION_EXTRA1=0\n+  UTIL_ARG_WITH(NAME: version-string, TYPE: string,\n+    DEFAULT: [],\n+    DESC: [Set version string],\n+    DEFAULT_DESC: [calculated],\n+    CHECK_VALUE: [\n+      if test \"x$RESULT\" != x; then\n+        # Additional [] needed to keep m4 from mangling shell constructs.\n+        if [ [[ $RESULT =~ ^([0-9]+)(\\.([0-9]+))?(\\.([0-9]+))?(\\.([0-9]+))?(\\.([0-9]+))?(\\.([0-9]+))?(\\.([0-9]+))?(-([a-zA-Z0-9]+))?(((\\+)([0-9]*))?(-([-a-zA-Z0-9.]+))?)?$ ]] ]; then\n+          VERSION_FEATURE=${BASH_REMATCH[[1]]}\n+          VERSION_INTERIM=${BASH_REMATCH[[3]]}\n+          VERSION_UPDATE=${BASH_REMATCH[[5]]}\n+          VERSION_PATCH=${BASH_REMATCH[[7]]}\n+          VERSION_EXTRA1=${BASH_REMATCH[[9]]}\n+          VERSION_EXTRA2=${BASH_REMATCH[[11]]}\n+          VERSION_EXTRA3=${BASH_REMATCH[[13]]}\n+          VERSION_PRE=${BASH_REMATCH[[15]]}\n+          version_plus_separator=${BASH_REMATCH[[18]]}\n+          VERSION_BUILD=${BASH_REMATCH[[19]]}\n+          VERSION_OPT=${BASH_REMATCH[[21]]}\n+          # Unspecified numerical fields are interpreted as 0.\n+          if test \"x$VERSION_INTERIM\" = x; then\n+            VERSION_INTERIM=0\n+          fi\n+          if test \"x$VERSION_UPDATE\" = x; then\n+            VERSION_UPDATE=0\n+          fi\n+          if test \"x$VERSION_PATCH\" = x; then\n+            VERSION_PATCH=0\n+          fi\n+          if test \"x$VERSION_EXTRA1\" = x; then\n+            VERSION_EXTRA1=0\n+          fi\n+          if test \"x$VERSION_EXTRA2\" = x; then\n+            VERSION_EXTRA2=0\n+          fi\n+          if test \"x$VERSION_EXTRA3\" = x; then\n+            VERSION_EXTRA3=0\n+          fi\n+          if test \"x$version_plus_separator\" != x \\\n+              && test \"x$VERSION_BUILD$VERSION_OPT\" = x; then\n+            AC_MSG_ERROR([Version string contains + but both 'BUILD' and 'OPT' are missing])\n+          fi\n+          if test \"x$VERSION_BUILD\" = x0; then\n+            AC_MSG_WARN([Version build 0 is interpreted as no build number])\n+            VERSION_BUILD=\n+          fi\n+          # Stop the version part process from setting default values.\n+          # We still allow them to explicitly override though.\n+          NO_DEFAULT_VERSION_PARTS=true\n+        else\n+          FAILURE=\"--with-version-string fails to parse as a valid version string: $RESULT\"\n+        fi\n@@ -194,21 +197,1 @@\n-      if test \"x$VERSION_EXTRA2\" = x; then\n-        VERSION_EXTRA2=0\n-      fi\n-      if test \"x$VERSION_EXTRA3\" = x; then\n-        VERSION_EXTRA3=0\n-      fi\n-      if test \"x$version_plus_separator\" != x \\\n-          && test \"x$VERSION_BUILD$VERSION_OPT\" = x; then\n-        AC_MSG_ERROR([Version string contains + but both 'BUILD' and 'OPT' are missing])\n-      fi\n-      if test \"x$VERSION_BUILD\" = x0; then\n-        AC_MSG_WARN([Version build 0 is interpreted as no build number])\n-        VERSION_BUILD=\n-      fi\n-      # Stop the version part process from setting default values.\n-      # We still allow them to explicitly override though.\n-      NO_DEFAULT_VERSION_PARTS=true\n-    else\n-      AC_MSG_ERROR([--with-version-string fails to parse as a valid version string: $with_version_string])\n-    fi\n-  fi\n+    ])\n@@ -293,15 +276,3 @@\n-  AC_ARG_WITH(version-feature, [AS_HELP_STRING([--with-version-feature],\n-      [Set version 'FEATURE' field (first number) @<:@current source value@:>@])],\n-      [with_version_feature_present=true], [with_version_feature_present=false])\n-\n-  if test \"x$with_version_feature_present\" = xtrue; then\n-    if test \"x$with_version_feature\" = xyes || test \"x$with_version_feature\" = xno; then\n-      AC_MSG_ERROR([--with-version-feature must have a value])\n-    else\n-      JDKVER_CHECK_AND_SET_NUMBER(VERSION_FEATURE, $with_version_feature)\n-    fi\n-  else\n-    if test \"x$NO_DEFAULT_VERSION_PARTS\" != xtrue; then\n-      # Default is to get value from version-numbers.conf\n-      VERSION_FEATURE=\"$DEFAULT_VERSION_FEATURE\"\n-    fi\n+  # Default is to get value from version-numbers.conf\n+  if test \"x$NO_DEFAULT_VERSION_PARTS\" = xtrue; then\n+    DEFAULT_VERSION_FEATURE=\"$VERSION_FEATURE\"\n@@ -310,0 +281,8 @@\n+  UTIL_ARG_WITH(NAME: version-feature, TYPE: string,\n+    DEFAULT: $DEFAULT_VERSION_FEATURE,\n+    DESC: [Set version 'FEATURE' field (first number)],\n+    DEFAULT_DESC: [current source value],\n+    CHECK_VALUE: [\n+      JDKVER_CHECK_AND_SET_NUMBER(VERSION_FEATURE, $RESULT)\n+    ])\n+\n@@ -483,13 +462,11 @@\n-  AC_ARG_WITH(version-date, [AS_HELP_STRING([--with-version-date],\n-      [Set version date @<:@current source value@:>@])])\n-  if test \"x$with_version_date\" = xyes || test \"x$with_version_date\" = xno; then\n-    AC_MSG_ERROR([--with-version-date must have a value])\n-  elif test \"x$with_version_date\" != x; then\n-    if [ ! [[ $with_version_date =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]] ]; then\n-      AC_MSG_ERROR([\"$with_version_date\" is not a valid version date])\n-    else\n-      VERSION_DATE=\"$with_version_date\"\n-    fi\n-  else\n-    VERSION_DATE=\"$DEFAULT_VERSION_DATE\"\n-  fi\n+  UTIL_ARG_WITH(NAME: version-date, TYPE: string,\n+    DEFAULT: $DEFAULT_VERSION_DATE,\n+    DESC: [Set version date],\n+    DEFAULT_DESC: [current source value],\n+    CHECK_VALUE: [\n+      if test \"x$RESULT\" = x; then\n+        FAILURE=\"--with-version-date cannot be empty\"\n+      elif [ ! [[ $RESULT =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]] ]; then\n+        FAILURE=\"\\\"$RESULT\\\" is not a valid version date\"\n+      fi\n+    ])\n@@ -498,11 +475,13 @@\n-  AC_ARG_WITH(vendor-version-string, [AS_HELP_STRING([--with-vendor-version-string],\n-      [Set vendor version string @<:@not specified@:>@])])\n-  if test \"x$with_vendor_version_string\" = xyes; then\n-    AC_MSG_ERROR([--with-vendor-version-string must have a value])\n-  elif [ ! [[ $with_vendor_version_string =~ ^[[:graph:]]*$ ]] ]; then\n-    AC_MSG_ERROR([--with--vendor-version-string contains non-graphical characters: $with_vendor_version_string])\n-  elif test \"x$with_vendor_version_string\" != xno; then\n-    # Set vendor version string if --without is not passed\n-    # Check not required if an empty value is passed, since VENDOR_VERSION_STRING\n-    # would then be set to \"\"\n-    VENDOR_VERSION_STRING=\"$with_vendor_version_string\"\n+  # DEFAULT is set to an empty string in the case of --with-vendor-version-string without\n+  # any value, which would set VENDOR_VERSION_STRING_ENABLED to true and ultimately also\n+  # cause VENDOR_VERSION_STRING to fall back to the value in DEFAULT\n+  UTIL_ARG_WITH(NAME: vendor-version-string, TYPE: string,\n+    DEFAULT: [],\n+    OPTIONAL: true,\n+    DESC: [Set vendor version string],\n+    DEFAULT_DESC: [not specified])\n+\n+  if test \"x$VENDOR_VERSION_STRING_ENABLED\" = xtrue; then\n+    if [ ! [[ $VENDOR_VERSION_STRING =~ ^[[:graph:]]*$ ]] ]; then\n+      AC_MSG_ERROR([--with--vendor-version-string contains non-graphical characters: $VENDOR_VERSION_STRING])\n+    fi\n@@ -512,11 +491,5 @@\n-  AC_ARG_WITH(macosx-bundle-name-base, [AS_HELP_STRING([--with-macosx-bundle-name-base],\n-      [Set the MacOSX Bundle Name base. This is the base name for calculating MacOSX Bundle Names.\n-      @<:@not specified@:>@])])\n-  if test \"x$with_macosx_bundle_name_base\" = xyes || test \"x$with_macosx_bundle_name_base\" = xno; then\n-    AC_MSG_ERROR([--with-macosx-bundle-name-base must have a value])\n-  elif [ ! [[ $with_macosx_bundle_name_base =~ ^[[:print:]]*$ ]] ]; then\n-    AC_MSG_ERROR([--with-macosx-bundle-name-base contains non-printing characters: $with_macosx_bundle_name_base])\n-  elif test \"x$with_macosx_bundle_name_base\" != x; then\n-    # Set MACOSX_BUNDLE_NAME_BASE to the configured value.\n-    MACOSX_BUNDLE_NAME_BASE=\"$with_macosx_bundle_name_base\"\n-  fi\n+  UTIL_ARG_WITH(NAME: macosx-bundle-name-base, TYPE: string,\n+    DEFAULT: $MACOSX_BUNDLE_NAME_BASE,\n+    DESC: [Set the MacOSX Bundle Name base. This is the base name for calculating MacOSX Bundle Names.],\n+    DEFAULT_DESC: [from branding.conf],\n+    CHECK_VALUE: [UTIL_CHECK_STRING_NON_EMPTY_PRINTABLE])\n@@ -525,17 +498,4 @@\n-  # Set the MACOSX Bundle ID base\n-  AC_ARG_WITH(macosx-bundle-id-base, [AS_HELP_STRING([--with-macosx-bundle-id-base],\n-      [Set the MacOSX Bundle ID base. This is the base ID for calculating MacOSX Bundle IDs.\n-      @<:@not specified@:>@])])\n-  if test \"x$with_macosx_bundle_id_base\" = xyes || test \"x$with_macosx_bundle_id_base\" = xno; then\n-    AC_MSG_ERROR([--with-macosx-bundle-id-base must have a value])\n-  elif [ ! [[ $with_macosx_bundle_id_base =~ ^[[:print:]]*$ ]] ]; then\n-    AC_MSG_ERROR([--with-macosx-bundle-id-base contains non-printing characters: $with_macosx_bundle_id_base])\n-  elif test \"x$with_macosx_bundle_id_base\" != x; then\n-    # Set MACOSX_BUNDLE_ID_BASE to the configured value.\n-    MACOSX_BUNDLE_ID_BASE=\"$with_macosx_bundle_id_base\"\n-  else\n-    # If using the default value, append the VERSION_PRE if there is one\n-    # to make it possible to tell official builds apart from developer builds\n-    if test \"x$VERSION_PRE\" != x; then\n-      MACOSX_BUNDLE_ID_BASE=\"$MACOSX_BUNDLE_ID_BASE-$VERSION_PRE\"\n-    fi\n+  # If using the default value, append the VERSION_PRE if there is one\n+  # to make it possible to tell official builds apart from developer builds\n+  if test \"x$VERSION_PRE\" != x; then\n+    MACOSX_BUNDLE_ID_BASE=\"$MACOSX_BUNDLE_ID_BASE-$VERSION_PRE\"\n@@ -543,0 +503,7 @@\n+\n+  # Set the MACOSX Bundle ID base\n+  UTIL_ARG_WITH(NAME: macosx-bundle-id-base, TYPE: string,\n+    DEFAULT: $MACOSX_BUNDLE_ID_BASE,\n+    DESC: [Set the MacOSX Bundle ID base. This is the base ID for calculating MacOSX Bundle IDs.],\n+    DEFAULT_DESC: [based on branding.conf and VERSION_PRE],\n+    CHECK_VALUE: [UTIL_CHECK_STRING_NON_EMPTY_PRINTABLE])\n@@ -545,11 +512,2 @@\n-  # Set the MACOSX CFBundleVersion field\n-  AC_ARG_WITH(macosx-bundle-build-version, [AS_HELP_STRING([--with-macosx-bundle-build-version],\n-      [Set the MacOSX Bundle CFBundleVersion field. This key is a machine-readable\n-      string composed of one to three period-separated integers and should represent the\n-      build version. Defaults to the build number.])])\n-  if test \"x$with_macosx_bundle_build_version\" = xyes || test \"x$with_macosx_bundle_build_version\" = xno; then\n-    AC_MSG_ERROR([--with-macosx-bundle-build-version must have a value])\n-  elif [ ! [[ $with_macosx_bundle_build_version =~ ^[0-9\\.]*$ ]] ]; then\n-    AC_MSG_ERROR([--with-macosx-bundle-build-version contains non numbers and periods: $with_macosx_bundle_build_version])\n-  elif test \"x$with_macosx_bundle_build_version\" != x; then\n-    MACOSX_BUNDLE_BUILD_VERSION=\"$with_macosx_bundle_build_version\"\n+  if test \"x$VERSION_BUILD\" != x; then\n+    MACOSX_BUNDLE_BUILD_VERSION=\"$VERSION_BUILD\"\n@@ -557,5 +515,2 @@\n-    if test \"x$VERSION_BUILD\" != x; then\n-      MACOSX_BUNDLE_BUILD_VERSION=\"$VERSION_BUILD\"\n-    else\n-      MACOSX_BUNDLE_BUILD_VERSION=0\n-    fi\n+    MACOSX_BUNDLE_BUILD_VERSION=0\n+  fi\n@@ -563,4 +518,3 @@\n-    # If VERSION_OPT consists of only numbers and periods, add it.\n-    if [ [[ $VERSION_OPT =~ ^[0-9\\.]+$ ]] ]; then\n-      MACOSX_BUNDLE_BUILD_VERSION=\"$MACOSX_BUNDLE_BUILD_VERSION.$VERSION_OPT\"\n-    fi\n+  # If VERSION_OPT consists of only numbers and periods, add it.\n+  if [ [[ $VERSION_OPT =~ ^[0-9\\.]+$ ]] ]; then\n+    MACOSX_BUNDLE_BUILD_VERSION=\"$MACOSX_BUNDLE_BUILD_VERSION.$VERSION_OPT\"\n@@ -568,0 +522,15 @@\n+\n+  # Set the MACOSX CFBundleVersion field\n+  UTIL_ARG_WITH(NAME: macosx-bundle-build-version, TYPE: string,\n+    DEFAULT: $MACOSX_BUNDLE_BUILD_VERSION,\n+    DESC: [Set the MacOSX Bundle CFBundleVersion field. This key is a machine-readable\n+      string composed of one to three period-separated integers and should represent the\n+      build version.],\n+    DEFAULT_DESC: [the build number],\n+    CHECK_VALUE: [\n+      if test \"x$RESULT\" = x; then\n+        FAILURE=\"--with-macosx-bundle-build-version must have a value\"\n+      elif [ ! [[ $RESULT =~ ^[0-9\\.]*$ ]] ]; then\n+        FAILURE=\"--with-macosx-bundle-build-version contains non numbers and periods: $RESULT\"\n+      fi\n+    ])\n","filename":"make\/autoconf\/jdk-version.m4","additions":176,"deletions":207,"binary":false,"changes":383,"status":"modified"},{"patch":"@@ -458,0 +458,5 @@\n+# UndefinedBehaviorSanitizer\n+UBSAN_ENABLED:=@UBSAN_ENABLED@\n+UBSAN_CFLAGS:=@UBSAN_CFLAGS@\n+UBSAN_LDFLAGS:=@UBSAN_LDFLAGS@\n+\n","filename":"make\/autoconf\/spec.gmk.in","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -821,0 +821,9 @@\n+\n+AC_DEFUN([UTIL_CHECK_STRING_NON_EMPTY_PRINTABLE],\n+[\n+  if test \"x$RESULT\" = x; then\n+    FAILURE=\"Value cannot be empty\"\n+  elif [ ! [[ $RESULT =~ ^[[:print:]]*$ ]] ]; then\n+    FAILURE=\"Value contains non-printing characters: $RESULT\"\n+  fi\n+])\n","filename":"make\/autoconf\/util.m4","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -704,0 +704,13 @@\n+  ifeq ($$($1_TYPE), EXECUTABLE)\n+    ifeq ($(UBSAN_ENABLED), true)\n+      # We need to set the default options for UBSan. This needs to be included in every executable.\n+      # Rather than copy and paste code to everything with a main function, we add an additional\n+      # source file to every executable that exports __ubsan_default_options.\n+      ifneq ($$(filter %.cpp %.cc, $$($1_SRCS)), )\n+        $1_SRCS += $(TOPDIR)\/make\/data\/ubsan\/ubsan_default_options.cpp\n+      else\n+        $1_SRCS += $(TOPDIR)\/make\/data\/ubsan\/ubsan_default_options.c\n+      endif\n+    endif\n+  endif\n+\n","filename":"make\/common\/NativeCompilation.gmk","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -947,1 +947,1 @@\n-                testedProfileTest, testedProfile + \".jdk_symbols\",\n+                testedProfileTest,\n@@ -961,0 +961,3 @@\n+    if (!testedProfile.endsWith(\"-jcov\")) {\n+        testOnlyProfilesPrebuilt[\"run-test-prebuilt\"][\"dependencies\"].push(testedProfile + \".jdk_symbols\");\n+    }\n@@ -990,1 +993,1 @@\n-                input.get(\"lldb\", \"install_path\") + \"\/Xcode.app\/Contents\/Developer\/usr\/bin\",\n+                input.get(\"lldb\", \"install_path\") + \"\/Xcode\/Contents\/Developer\/usr\/bin\",\n@@ -1126,1 +1129,1 @@\n-            revision: (input.build_cpu == \"x64\" ? \"Xcode11.3.1-MacOSX10.15+1.1\" : devkit_platform_revisions[devkit_platform])\n+            revision: (input.build_cpu == \"x64\" ? \"Xcode11.3.1-MacOSX10.15+1.2\" : devkit_platform_revisions[devkit_platform])\n@@ -1154,1 +1157,1 @@\n-            revision: \"3.0-13-jdk-asm+1.0\",\n+            revision: \"3.0-14-jdk-asm+1.0\",\n","filename":"make\/conf\/jib-profiles.js","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef UNDEFINED_BEHAVIOR_SANITIZER\n+#error \"Build misconfigured, preprocessor macro UNDEFINED_BEHAVIOR_SANITIZER should be defined\"\n+#endif\n+\n+#ifndef __has_attribute\n+#define __has_attribute(x) 0\n+#endif\n+\n+#if (defined(__GNUC__) && !defined(__clang__)) || __has_attribute(visibility)\n+#define ATTRIBUTE_DEFAULT_VISIBILITY __attribute__((visibility(\"default\")))\n+#else\n+#define ATTRIBUTE_DEFAULT_VISIBILITY\n+#endif\n+\n+#if (defined(__GNUC__) && !defined(__clang__)) || __has_attribute(used)\n+#define ATTRIBUTE_USED __attribute__((used))\n+#else\n+#define ATTRIBUTE_USED\n+#endif\n+\n+\/\/ Override weak symbol exposed by UBSan to override default options. This is called by UBSan\n+\/\/ extremely early during library loading, before main is called. We need to override the default\n+\/\/ options because by default UBSan only prints a warning for each occurrence. We want jtreg tests\n+\/\/ to fail when undefined behavior is encountered. We also want a full stack trace for the offending\n+\/\/ thread so it is easier to track down. You can override these options by setting the environment\n+\/\/ variable UBSAN_OPTIONS.\n+ATTRIBUTE_DEFAULT_VISIBILITY ATTRIBUTE_USED const char* __ubsan_default_options() {\n+  return \"halt_on_error=1,print_stacktrace=1\";\n+}\n","filename":"make\/data\/ubsan\/ubsan_default_options.c","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+extern \"C\" {\n+\n+#include \".\/ubsan_default_options.c\"\n+\n+} \/\/ extern \"C\"\n","filename":"make\/data\/ubsan\/ubsan_default_options.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -62,0 +62,5 @@\n+  ifeq ($(UBSAN_ENABLED), true)\n+    ADLC_CFLAGS += $(UBSAN_CFLAGS)\n+    ADLC_LDFLAGS += $(UBSAN_LDFLAGS)\n+  endif\n+\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-        FILES := $(MSVCR_DLL) $(VCRUNTIME_1_DLL) $(MSVCP_DLL), \\\n+        FILES := $(MSVCR_DLL), \\\n@@ -48,0 +48,12 @@\n+    $(eval $(call SetupCopyFiles, COPY_GTEST_VCRUNTIME_1_$v, \\\n+        DEST := $(TEST_IMAGE_DIR)\/hotspot\/gtest\/$v, \\\n+        FILES := $(VCRUNTIME_1_DLL), \\\n+        FLATTEN := true, \\\n+    )) \\\n+    $(eval TARGETS += $$(COPY_GTEST_VCRUNTIME_1_$v)) \\\n+    $(eval $(call SetupCopyFiles, COPY_GTEST_MSVCP_$v, \\\n+        DEST := $(TEST_IMAGE_DIR)\/hotspot\/gtest\/$v, \\\n+        FILES := $(MSVCP_DLL), \\\n+        FLATTEN := true, \\\n+    )) \\\n+    $(eval TARGETS += $$(COPY_GTEST_MSVCP_$v)) \\\n","filename":"make\/hotspot\/test\/GtestImage.gmk","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1742,1 +1742,1 @@\n-    st->print(\"ldr  rscratch2, [rthread, #thread_disarmed_offset]\\n\\t\");\n+    st->print(\"ldr  rscratch2, [rthread, #thread_disarmed_guard_value_offset]\\n\\t\");\n@@ -7561,1 +7561,1 @@\n-  predicate(!needs_releasing_store(n));\n+  predicate(!needs_releasing_store(n) && n->as_Store()->barrier_data() == 0);\n@@ -7575,1 +7575,1 @@\n-  predicate(!needs_releasing_store(n));\n+  predicate(!needs_releasing_store(n) && n->as_Store()->barrier_data() == 0);\n@@ -7976,0 +7976,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -7988,0 +7989,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -9657,0 +9659,84 @@\n+\/\/ Manifest a CmpU result in an integer register.\n+\/\/ (src1 < src2) ? -1 : ((src1 > src2) ? 1 : 0)\n+instruct cmpU3_reg_reg(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg flags)\n+%{\n+  match(Set dst (CmpU3 src1 src2));\n+  effect(KILL flags);\n+\n+  ins_cost(INSN_COST * 3);\n+  format %{\n+      \"cmpw $src1, $src2\\n\\t\"\n+      \"csetw $dst, ne\\n\\t\"\n+      \"cnegw $dst, lo\\t# CmpU3(reg)\"\n+  %}\n+  ins_encode %{\n+    __ cmpw($src1$$Register, $src2$$Register);\n+    __ csetw($dst$$Register, Assembler::NE);\n+    __ cnegw($dst$$Register, $dst$$Register, Assembler::LO);\n+  %}\n+\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct cmpU3_reg_imm(iRegINoSp dst, iRegI src1, immIAddSub src2, rFlagsReg flags)\n+%{\n+  match(Set dst (CmpU3 src1 src2));\n+  effect(KILL flags);\n+\n+  ins_cost(INSN_COST * 3);\n+  format %{\n+      \"subsw zr, $src1, $src2\\n\\t\"\n+      \"csetw $dst, ne\\n\\t\"\n+      \"cnegw $dst, lo\\t# CmpU3(imm)\"\n+  %}\n+  ins_encode %{\n+    __ subsw(zr, $src1$$Register, (int32_t)$src2$$constant);\n+    __ csetw($dst$$Register, Assembler::NE);\n+    __ cnegw($dst$$Register, $dst$$Register, Assembler::LO);\n+  %}\n+\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+\/\/ Manifest a CmpUL result in an integer register.\n+\/\/ (src1 < src2) ? -1 : ((src1 > src2) ? 1 : 0)\n+instruct cmpUL3_reg_reg(iRegINoSp dst, iRegL src1, iRegL src2, rFlagsReg flags)\n+%{\n+  match(Set dst (CmpUL3 src1 src2));\n+  effect(KILL flags);\n+\n+  ins_cost(INSN_COST * 3);\n+  format %{\n+      \"cmp $src1, $src2\\n\\t\"\n+      \"csetw $dst, ne\\n\\t\"\n+      \"cnegw $dst, lo\\t# CmpUL3(reg)\"\n+  %}\n+  ins_encode %{\n+    __ cmp($src1$$Register, $src2$$Register);\n+    __ csetw($dst$$Register, Assembler::NE);\n+    __ cnegw($dst$$Register, $dst$$Register, Assembler::LO);\n+  %}\n+\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct cmpUL3_reg_imm(iRegINoSp dst, iRegL src1, immLAddSub src2, rFlagsReg flags)\n+%{\n+  match(Set dst (CmpUL3 src1 src2));\n+  effect(KILL flags);\n+\n+  ins_cost(INSN_COST * 3);\n+  format %{\n+      \"subs zr, $src1, $src2\\n\\t\"\n+      \"csetw $dst, ne\\n\\t\"\n+      \"cnegw $dst, lo\\t# CmpUL3(imm)\"\n+  %}\n+  ins_encode %{\n+    __ subs(zr, $src1$$Register, (int32_t)$src2$$constant);\n+    __ csetw($dst$$Register, Assembler::NE);\n+    __ cnegw($dst$$Register, $dst$$Register, Assembler::LO);\n+  %}\n+\n+  ins_pipe(pipe_class_default);\n+%}\n+\n@@ -9664,1 +9750,1 @@\n-  ins_cost(INSN_COST * 6);\n+  ins_cost(INSN_COST * 3);\n@@ -9666,3 +9752,3 @@\n-      \"cmp $src1, $src2\"\n-      \"csetw $dst, ne\"\n-      \"cnegw $dst, lt\"\n+      \"cmp $src1, $src2\\n\\t\"\n+      \"csetw $dst, ne\\n\\t\"\n+      \"cnegw $dst, lt\\t# CmpL3(reg)\"\n@@ -9670,1 +9756,0 @@\n-  \/\/ format %{ \"CmpL3 $dst, $src1, $src2\" %}\n@@ -9685,1 +9770,1 @@\n-  ins_cost(INSN_COST * 6);\n+  ins_cost(INSN_COST * 3);\n@@ -9687,3 +9772,3 @@\n-      \"cmp $src1, $src2\"\n-      \"csetw $dst, ne\"\n-      \"cnegw $dst, lt\"\n+      \"subs zr, $src1, $src2\\n\\t\"\n+      \"csetw $dst, ne\\n\\t\"\n+      \"cnegw $dst, lt\\t# CmpL3(imm)\"\n@@ -9692,6 +9777,1 @@\n-    int32_t con = (int32_t)$src2$$constant;\n-     if (con < 0) {\n-      __ adds(zr, $src1$$Register, -con);\n-    } else {\n-      __ subs(zr, $src1$$Register, con);\n-    }\n+    __ subs(zr, $src1$$Register, (int32_t)$src2$$constant);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":99,"deletions":19,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -508,1 +508,14 @@\n-    return base() == reg || index() == reg;\n+    switch (_mode) {\n+    case literal:\n+    case no_mode:\n+      return false;\n+    case base_plus_offset:\n+    case base_plus_offset_reg:\n+    case pre:\n+    case post:\n+    case post_reg:\n+      return base() == reg || index() == reg;\n+    default:\n+      ShouldNotReachHere();\n+      return false;\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-    Address thread_disarmed_addr(rthread, in_bytes(bs_nm->thread_disarmed_offset()));\n+    Address thread_disarmed_addr(rthread, in_bytes(bs_nm->thread_disarmed_guard_value_offset()));\n@@ -241,1 +241,1 @@\n-    Address thread_disarmed_and_epoch_addr(rthread, in_bytes(bs_nm->thread_disarmed_offset()));\n+    Address thread_disarmed_and_epoch_addr(rthread, in_bytes(bs_nm->thread_disarmed_guard_value_offset()));\n@@ -249,1 +249,1 @@\n-    Address thread_disarmed_addr(rthread, in_bytes(bs_nm->thread_disarmed_offset()));\n+    Address thread_disarmed_addr(rthread, in_bytes(bs_nm->thread_disarmed_guard_value_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-void BarrierSetNMethod::disarm(nmethod* nm) {\n+void BarrierSetNMethod::set_guard_value(nmethod* nm, int value) {\n@@ -171,21 +171,1 @@\n-  \/\/ The patching epoch is incremented before the nmethod is disarmed. Disarming\n-  \/\/ is performed with a release store. In the nmethod entry barrier, the values\n-  \/\/ are read in the opposite order, such that the load of the nmethod guard\n-  \/\/ acquires the patching epoch. This way, the guard is guaranteed to block\n-  \/\/ entries to the nmethod, until it has safely published the requirement for\n-  \/\/ further fencing by mutators, before they are allowed to enter.\n-  BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs_asm->increment_patching_epoch();\n-\n-  \/\/ Disarms the nmethod guard emitted by BarrierSetAssembler::nmethod_entry_barrier.\n-  \/\/ Symmetric \"LDR; DMB ISHLD\" is in the nmethod barrier.\n-  NativeNMethodBarrier* barrier = native_nmethod_barrier(nm);\n-  barrier->set_value(nm, disarmed_value());\n-}\n-\n-void BarrierSetNMethod::arm(nmethod* nm, int arm_value) {\n-  if (!supports_entry_barrier(nm)) {\n-    return;\n-  }\n-\n-  if (arm_value == disarmed_value()) {\n+  if (value == disarmed_guard_value()) {\n@@ -203,1 +183,1 @@\n-  barrier->set_value(nm, arm_value);\n+  barrier->set_value(nm, value);\n@@ -206,1 +186,1 @@\n-bool BarrierSetNMethod::is_armed(nmethod* nm) {\n+int BarrierSetNMethod::guard_value(nmethod* nm) {\n@@ -208,1 +188,1 @@\n-    return false;\n+    return disarmed_guard_value();\n@@ -212,1 +192,1 @@\n-  return barrier->get_value(nm) != disarmed_value();\n+  return barrier->get_value(nm);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetNMethod_aarch64.cpp","additions":6,"deletions":26,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -5337,1 +5337,1 @@\n-      Address thread_epoch_addr(rthread, in_bytes(bs_nm->thread_disarmed_offset()) + 4);\n+      Address thread_epoch_addr(rthread, in_bytes(bs_nm->thread_disarmed_guard_value_offset()) + 4);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -839,2 +839,4 @@\n-    } else {\n-    __ mov(rscratch1, sp);\n+  } else {\n+    \/\/ Make sure there is room for the exception oop pushed in case method throws\n+    \/\/ an exception (see TemplateInterpreterGenerator::generate_throw_exception())\n+    __ sub(rscratch1, sp, 2 * wordSize);\n@@ -842,0 +844,1 @@\n+    __ mov(sp, rscratch1);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,1 +135,1 @@\n-  if (_cpu == CPU_AMCC && (_model == 0) && (_variant == 0x3)) {\n+  if (_cpu == CPU_AMCC && (_model == CPU_MODEL_EMAG) && (_variant == 0x3)) {\n@@ -147,0 +147,7 @@\n+  \/\/ Ampere CPUs: Ampere-1 and Ampere-1A\n+  if (_cpu == CPU_AMPERE && ((_model == CPU_MODEL_AMPERE_1) || (_model == CPU_MODEL_AMPERE_1A))) {\n+    if (FLAG_IS_DEFAULT(UseSIMDForMemoryOps)) {\n+      FLAG_SET_DEFAULT(UseSIMDForMemoryOps, true);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,0 +105,8 @@\n+enum Ampere_CPU_Model {\n+    CPU_MODEL_EMAG      = 0x0,   \/* CPU implementer is CPU_AMCC *\/\n+    CPU_MODEL_ALTRA     = 0xd0c, \/* CPU implementer is CPU_ARM, Neoverse N1 *\/\n+    CPU_MODEL_ALTRAMAX  = 0xd0c, \/* CPU implementer is CPU_ARM, Neoverse N1 *\/\n+    CPU_MODEL_AMPERE_1  = 0xac3, \/* CPU implementer is CPU_AMPERE *\/\n+    CPU_MODEL_AMPERE_1A = 0xac4  \/* CPU implementer is CPU_AMPERE *\/\n+};\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -295,1 +295,1 @@\n-    st->print(\"ldr t1, [Rthread, #thread_disarmed_offset]\\n\\t\");\n+    st->print(\"ldr t1, [Rthread, #thread_disarmed_guard_value_offset]\\n\\t\");\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-  Address thread_disarmed_addr(Rthread, in_bytes(bs_nm->thread_disarmed_offset()));\n+  Address thread_disarmed_addr(Rthread, in_bytes(bs_nm->thread_disarmed_guard_value_offset()));\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/barrierSetAssembler_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-void BarrierSetNMethod::disarm(nmethod* nm) {\n+void BarrierSetNMethod::set_guard_value(nmethod* nm, int value) {\n@@ -127,1 +127,1 @@\n-  barrier->set_value(disarmed_value());\n+  barrier->set_value(value);\n@@ -130,1 +130,1 @@\n-void BarrierSetNMethod::arm(nmethod* nm, int arm_value) {\n+int BarrierSetNMethod::guard_value(nmethod* nm) {\n@@ -132,10 +132,1 @@\n-    return;\n-  }\n-\n-  NativeNMethodBarrier* barrier = native_nmethod_barrier(nm);\n-  barrier->set_value(arm_value);\n-}\n-\n-bool BarrierSetNMethod::is_armed(nmethod* nm) {\n-  if (!supports_entry_barrier(nm)) {\n-    return false;\n+    return disarmed_guard_value();\n@@ -145,1 +136,1 @@\n-  return barrier->get_value() != disarmed_value();\n+  return barrier->get_value();\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/barrierSetNMethod_arm.cpp","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-  __ ld(R0, in_bytes(bs_nm->thread_disarmed_offset()), R16_thread);\n+  __ ld(R0, in_bytes(bs_nm->thread_disarmed_guard_value_offset()), R16_thread);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-void BarrierSetNMethod::disarm(nmethod* nm) {\n+void BarrierSetNMethod::set_guard_value(nmethod* nm, int value) {\n@@ -127,1 +127,1 @@\n-  barrier->release_set_guard_value(disarmed_value());\n+  barrier->release_set_guard_value(value);\n@@ -130,1 +130,1 @@\n-void BarrierSetNMethod::arm(nmethod* nm, int arm_value) {\n+int BarrierSetNMethod::guard_value(nmethod* nm) {\n@@ -132,10 +132,1 @@\n-    return;\n-  }\n-\n-  NativeNMethodBarrier* barrier = get_nmethod_barrier(nm);\n-  barrier->release_set_guard_value(arm_value);\n-}\n-\n-bool BarrierSetNMethod::is_armed(nmethod* nm) {\n-  if (!supports_entry_barrier(nm)) {\n-    return false;\n+    return disarmed_guard_value();\n@@ -145,1 +136,1 @@\n-  return barrier->get_guard_value() != disarmed_value();\n+  return barrier->get_guard_value();\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetNMethod_ppc.cpp","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -6540,0 +6540,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -801,0 +801,2 @@\n+  INSN(fcvt_s_h, 0b1010011, 0b00010, 0b0100000);\n+  INSN(fcvt_h_s, 0b1010011, 0b00000, 0b0100010);\n@@ -1057,0 +1059,1 @@\n+  INSN(fmv_h_x,  0b1010011, 0b000, 0b00000, 0b1111010);\n@@ -1077,0 +1080,1 @@\n+  INSN(fmv_x_h,  0b1010011, 0b000, 0b00000, 0b1110010);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -223,1 +223,1 @@\n-        Address thread_disarmed_addr(xthread, in_bytes(bs_nm->thread_disarmed_offset()));\n+        Address thread_disarmed_addr(xthread, in_bytes(bs_nm->thread_disarmed_guard_value_offset()));\n@@ -248,1 +248,1 @@\n-        Address thread_disarmed_and_epoch_addr(xthread, in_bytes(bs_nm->thread_disarmed_offset()));\n+        Address thread_disarmed_and_epoch_addr(xthread, in_bytes(bs_nm->thread_disarmed_guard_value_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-void BarrierSetNMethod::disarm(nmethod* nm) {\n+void BarrierSetNMethod::set_guard_value(nmethod* nm, int value) {\n@@ -179,21 +179,1 @@\n-  \/\/ The patching epoch is incremented before the nmethod is disarmed. Disarming\n-  \/\/ is performed with a release store. In the nmethod entry barrier, the values\n-  \/\/ are read in the opposite order, such that the load of the nmethod guard\n-  \/\/ acquires the patching epoch. This way, the guard is guaranteed to block\n-  \/\/ entries to the nmethod, util it has safely published the requirement for\n-  \/\/ further fencing by mutators, before they are allowed to enter.\n-  BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs_asm->increment_patching_epoch();\n-\n-  \/\/ Disarms the nmethod guard emitted by BarrierSetAssembler::nmethod_entry_barrier.\n-  \/\/ Symmetric \"LD; FENCE IR, IR\" is in the nmethod barrier.\n-  NativeNMethodBarrier* barrier = native_nmethod_barrier(nm);\n-  barrier->set_value(nm, disarmed_value());\n-}\n-\n-void BarrierSetNMethod::arm(nmethod* nm, int arm_value) {\n-  if (!supports_entry_barrier(nm)) {\n-    return;\n-  }\n-\n-  if (arm_value == disarmed_value()) {\n+  if (value == disarmed_guard_value()) {\n@@ -211,1 +191,1 @@\n-  barrier->set_value(nm, arm_value);\n+  barrier->set_value(nm, value);\n@@ -214,1 +194,1 @@\n-bool BarrierSetNMethod::is_armed(nmethod* nm) {\n+int BarrierSetNMethod::guard_value(nmethod* nm) {\n@@ -216,1 +196,1 @@\n-    return false;\n+    return disarmed_guard_value();\n@@ -220,1 +200,1 @@\n-  return barrier->get_value(nm) != disarmed_value();\n+  return barrier->get_value(nm);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetNMethod_riscv.cpp","additions":6,"deletions":26,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+  product(bool, UseZfhmin, false, EXPERIMENTAL, \"Use Zfhmin instructions\")       \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1306,1 +1306,1 @@\n-    st->print(\"ld  t1, [xthread, #thread_disarmed_offset]\\n\\t\");\n+    st->print(\"ld  t1, [xthread, #thread_disarmed_guard_value_offset]\\n\\t\");\n@@ -1845,0 +1845,4 @@\n+\n+    case Op_ConvF2HF:\n+    case Op_ConvHF2F:\n+      return UseZfhmin;\n@@ -5117,0 +5121,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -5132,0 +5137,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -8138,0 +8144,38 @@\n+\/\/ float <-> half float\n+\n+instruct convHF2F_reg_reg(fRegF dst, iRegINoSp src, fRegF tmp) %{\n+  predicate(UseZfhmin);\n+  match(Set dst (ConvHF2F src));\n+  effect(TEMP tmp);\n+\n+  ins_cost(XFER_COST);\n+  format %{ \"fmv.h.x $tmp, $src\\t#@convHF2F_reg_reg\\n\\t\"\n+            \"fcvt.s.h $dst, $tmp\\t#@convHF2F_reg_reg\"\n+  %}\n+\n+  ins_encode %{\n+    __ fmv_h_x($tmp$$FloatRegister, $src$$Register);\n+    __ fcvt_s_h($dst$$FloatRegister, $tmp$$FloatRegister);\n+  %}\n+\n+  ins_pipe(fp_i2f);\n+%}\n+\n+instruct convF2HF_reg_reg(iRegINoSp dst, fRegF src, fRegF tmp) %{\n+  predicate(UseZfhmin);\n+  match(Set dst (ConvF2HF src));\n+  effect(TEMP tmp);\n+\n+  ins_cost(XFER_COST);\n+  format %{ \"fcvt.h.s $tmp, $src\\t#@convF2HF_reg_reg\\n\\t\"\n+            \"fmv.x.h $dst, $tmp\\t#@convF2HF_reg_reg\"\n+  %}\n+\n+  ins_encode %{\n+    __ fcvt_h_s($tmp$$FloatRegister, $src$$FloatRegister);\n+    __ fmv_x_h($dst$$Register, $tmp$$FloatRegister);\n+  %}\n+\n+  ins_pipe(fp_f2i);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":46,"deletions":2,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2464,1 +2464,1 @@\n-      Address thread_epoch_addr(xthread, in_bytes(bs_nm->thread_disarmed_offset()) + 4);\n+      Address thread_epoch_addr(xthread, in_bytes(bs_nm->thread_disarmed_guard_value_offset()) + 4);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -779,1 +779,4 @@\n-    __ sd(sp, Address(sp, 5 * wordSize));\n+    \/\/ Make sure there is room for the exception oop pushed in case method throws\n+    \/\/ an exception (see TemplateInterpreterGenerator::generate_throw_exception())\n+    __ sub(t0, sp, 2 * wordSize);\n+    __ sd(t0, Address(sp, 5 * wordSize));\n@@ -781,0 +784,1 @@\n+    __ mv(sp, t0);\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,0 +62,3 @@\n+    if (FLAG_IS_DEFAULT(UseZbs)) {\n+      FLAG_SET_DEFAULT(UseZbs, true);\n+    }\n@@ -74,0 +77,3 @@\n+    if (FLAG_IS_DEFAULT(UseZfhmin)) {\n+      FLAG_SET_DEFAULT(UseZfhmin, true);\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-    __ z_lg(Z_R0_scratch, in_bytes(bs_nm->thread_disarmed_offset()), Z_thread); \/\/ 6 bytes\n+    __ z_lg(Z_R0_scratch, in_bytes(bs_nm->thread_disarmed_guard_value_offset()), Z_thread); \/\/ 6 bytes\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-void BarrierSetNMethod::arm(nmethod* nm, int arm_value) {\n+void BarrierSetNMethod::set_guard_value(nmethod* nm, int value) {\n@@ -110,1 +110,1 @@\n-  barrier->set_guard_value(arm_value);\n+  barrier->set_guard_value(value);\n@@ -113,1 +113,1 @@\n-void BarrierSetNMethod::disarm(nmethod* nm) {\n+int BarrierSetNMethod::guard_value(nmethod* nm) {\n@@ -115,10 +115,1 @@\n-    return;\n-  }\n-\n-  NativeMethodBarrier* barrier = get_nmethod_barrier(nm);\n-  barrier->set_guard_value(disarmed_value());\n-}\n-\n-bool BarrierSetNMethod::is_armed(nmethod* nm) {\n-  if (!supports_entry_barrier(nm)) {\n-    return false;\n+    return disarmed_guard_value();\n@@ -128,1 +119,1 @@\n-  return barrier->get_guard_value() != disarmed_value();\n+  return barrier->get_guard_value();\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetNMethod_s390.cpp","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -13456,0 +13456,5 @@\n+void Assembler::orq_imm32(Register dst, int32_t imm32) {\n+  (void) prefixq_and_encode(dst->encoding());\n+  emit_arith_imm32(0x81, 0xC8, dst, imm32);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1739,0 +1739,1 @@\n+  void orq_imm32(Register dst, int32_t imm32);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,2 @@\n-  \/\/ arbitrary value between 27 and 256\n-  CRC32C_MIDDLE = 8 * 86,\n+  \/\/ arbitrary value between 9 and 256\n+  CRC32C_MIDDLE = 8 * 74,\n@@ -46,1 +46,1 @@\n-  \/\/ shows that 240 and 1024 are equally good choices as the 216==8*27\n+  \/\/ shows that 240 and 1024 are equally good choices as the 216==8*9*3\n@@ -50,1 +50,1 @@\n-  CRC32C_LOW = 8 * 27,\n+  CRC32C_LOW = 8 * 9,\n","filename":"src\/hotspot\/cpu\/x86\/crc32c.h","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -282,1 +282,1 @@\n-  Address disarmed_addr(thread, in_bytes(bs_nm->thread_disarmed_offset()));\n+  Address disarmed_addr(thread, in_bytes(bs_nm->thread_disarmed_guard_value_offset()));\n@@ -313,1 +313,1 @@\n-  __ movptr(tmp, (intptr_t)bs_nm->disarmed_value_address());\n+  __ movptr(tmp, (intptr_t)bs_nm->disarmed_guard_value_address());\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  jint get_immedate() const { return int_at(imm_offset); }\n+  jint get_immediate() const { return int_at(imm_offset); }\n@@ -179,1 +179,1 @@\n-void BarrierSetNMethod::disarm(nmethod* nm) {\n+void BarrierSetNMethod::set_guard_value(nmethod* nm, int value) {\n@@ -185,1 +185,1 @@\n-  cmp->set_immediate(disarmed_value());\n+  cmp->set_immediate(value);\n@@ -188,1 +188,1 @@\n-void BarrierSetNMethod::arm(nmethod* nm, int arm_value) {\n+int BarrierSetNMethod::guard_value(nmethod* nm) {\n@@ -190,10 +190,1 @@\n-    return;\n-  }\n-\n-  NativeNMethodCmpBarrier* cmp = native_nmethod_barrier(nm);\n-  cmp->set_immediate(arm_value);\n-}\n-\n-bool BarrierSetNMethod::is_armed(nmethod* nm) {\n-  if (!supports_entry_barrier(nm)) {\n-    return false;\n+    return disarmed_guard_value();\n@@ -203,1 +194,1 @@\n-  return (disarmed_value() != cmp->get_immedate());\n+  return cmp->get_immediate();\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetNMethod_x86.cpp","additions":6,"deletions":15,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -8231,1 +8231,0 @@\n-  BIND(L_wordByWord);\n@@ -8233,4 +8232,7 @@\n-  jcc(Assembler::greaterEqual, L_byteByByteProlog);\n-    crc32(in_out, Address(in1, 0), 4);\n-    addq(in1, 4);\n-    jmp(L_wordByWord);\n+  jccb(Assembler::greaterEqual, L_byteByByteProlog);\n+  align(16);\n+  BIND(L_wordByWord);\n+    crc32(in_out, Address(in1, 0), 8);\n+    addq(in1, 8);\n+    cmpq(in1, tmp1);\n+    jcc(Assembler::less, L_wordByWord);\n@@ -8242,1 +8244,0 @@\n-  BIND(L_byteByByte);\n@@ -8245,0 +8246,1 @@\n+  BIND(L_byteByByte);\n@@ -8248,1 +8250,2 @@\n-    jmp(L_byteByByte);\n+    cmpl(tmp2, in2);\n+    jcc(Assembler::lessEqual, L_byteByByte);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -892,1 +892,1 @@\n-    st->print(\"cmpl    [r15_thread + #disarmed_offset], #disarmed_value\\t\");\n+    st->print(\"cmpl    [r15_thread + #disarmed_guard_value_offset], #disarmed_guard_value\\t\");\n@@ -6083,0 +6083,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -6095,1 +6096,1 @@\n-  predicate(UseCompressedOops && (CompressedOops::base() == NULL));\n+  predicate(UseCompressedOops && (CompressedOops::base() == NULL) && n->as_Store()->barrier_data() == 0);\n@@ -6109,0 +6110,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-void BarrierSetNMethod::arm(nmethod* nm, int value) {\n+void BarrierSetNMethod::set_guard_value(nmethod* nm, int value) {\n@@ -37,1 +37,1 @@\n-void BarrierSetNMethod::disarm(nmethod* nm) {\n+int BarrierSetNMethod::guard_value(nmethod* nm) {\n@@ -39,5 +39,1 @@\n-}\n-\n-bool BarrierSetNMethod::is_armed(nmethod* nm) {\n-  ShouldNotReachHere();\n-  return false;\n+  return -1;\n","filename":"src\/hotspot\/cpu\/zero\/gc\/shared\/barrierSetNMethod_zero.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1875,1 +1875,1 @@\n-bool os::get_page_info(char *start, page_info* info) {\n+bool os::numa_get_group_ids_for_range(const void** addresses, int* lgrp_ids, size_t count) {\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1578,1 +1578,1 @@\n-bool os::get_page_info(char *start, page_info* info) {\n+bool os::numa_get_group_ids_for_range(const void** addresses, int* lgrp_ids, size_t count) {\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,0 +81,6 @@\n+\/\/ Parses a subsystem's file, looking for a matching line.\n+\/\/ If key is null, then the first line will be matched with scan_fmt.\n+\/\/ If key isn't null, then each line will be matched, looking for something that matches \"$key $scan_fmt\".\n+\/\/ The matching value will be assigned to returnval.\n+\/\/ scan_fmt uses scanf() syntax.\n+\/\/ Return value: 0 on match, OSCONTAINER_ERROR on error.\n@@ -83,1 +89,1 @@\n-                                              const char *matchline,\n+                                              const char *key,\n@@ -86,6 +92,12 @@\n-  FILE *fp = NULL;\n-  char *p;\n-  char file[MAXPATHLEN+1];\n-  char buf[MAXPATHLEN+1];\n-  char discard[MAXPATHLEN+1];\n-  bool found_match = false;\n+  if (c == nullptr) {\n+    log_debug(os, container)(\"subsystem_file_line_contents: CgroupController* is nullptr\");\n+    return OSCONTAINER_ERROR;\n+  }\n+  if (c->subsystem_path() == nullptr) {\n+    log_debug(os, container)(\"subsystem_file_line_contents: subsystem path is nullptr\");\n+    return OSCONTAINER_ERROR;\n+  }\n+\n+  stringStream file_path;\n+  file_path.print_raw(c->subsystem_path());\n+  file_path.print_raw(filename);\n@@ -93,2 +105,2 @@\n-  if (c == NULL) {\n-    log_debug(os, container)(\"subsystem_file_line_contents: CgroupController* is NULL\");\n+  if (file_path.size() > (MAXPATHLEN-1)) {\n+    log_debug(os, container)(\"File path too long %s, %s\", file_path.base(), filename);\n@@ -97,2 +109,6 @@\n-  if (c->subsystem_path() == NULL) {\n-    log_debug(os, container)(\"subsystem_file_line_contents: subsystem path is NULL\");\n+  const char* absolute_path = file_path.freeze();\n+  log_trace(os, container)(\"Path to %s is %s\", filename, absolute_path);\n+\n+  FILE* fp = os::fopen(absolute_path, \"r\");\n+  if (fp == nullptr) {\n+    log_debug(os, container)(\"Open of file %s failed, %s\", absolute_path, os::strerror(errno));\n@@ -102,5 +118,6 @@\n-  strncpy(file, c->subsystem_path(), MAXPATHLEN);\n-  file[MAXPATHLEN-1] = '\\0';\n-  int filelen = strlen(file);\n-  if ((filelen + strlen(filename)) > (MAXPATHLEN-1)) {\n-    log_debug(os, container)(\"File path too long %s, %s\", file, filename);\n+  const int buf_len = MAXPATHLEN+1;\n+  char buf[buf_len];\n+  char* line = fgets(buf, buf_len, fp);\n+  if (line == nullptr) {\n+    log_debug(os, container)(\"Empty file %s\", absolute_path);\n+    fclose(fp);\n@@ -109,19 +126,22 @@\n-  strncat(file, filename, MAXPATHLEN-filelen);\n-  log_trace(os, container)(\"Path to %s is %s\", filename, file);\n-  fp = os::fopen(file, \"r\");\n-  if (fp != NULL) {\n-    int err = 0;\n-    while ((p = fgets(buf, MAXPATHLEN, fp)) != NULL) {\n-      found_match = false;\n-      if (matchline == NULL) {\n-        \/\/ single-line file case\n-        int matched = sscanf(p, scan_fmt, returnval);\n-        found_match = (matched == 1);\n-      } else {\n-        \/\/ multi-line file case\n-        if (strstr(p, matchline) != NULL) {\n-          \/\/ discard matchline string prefix\n-          int matched = sscanf(p, scan_fmt, discard, returnval);\n-          found_match = (matched == 2);\n-        } else {\n-          continue; \/\/ substring not found\n+\n+  bool found_match = false;\n+  if (key == nullptr) {\n+    \/\/ File consists of a single line according to caller, with only a value\n+    int matched = sscanf(line, scan_fmt, returnval);\n+    found_match = matched == 1;\n+  } else {\n+    \/\/ File consists of multiple lines in a \"key value\"\n+    \/\/ fashion, we have to find the key.\n+    const int key_len = strlen(key);\n+    for (; line != nullptr; line = fgets(buf, buf_len, fp)) {\n+      char* key_substr = strstr(line, key);\n+      char after_key = line[key_len];\n+      if (key_substr == line\n+          && isspace(after_key) != 0\n+          && after_key != '\\n') {\n+        \/\/ Skip key, skip space\n+        const char* value_substr = line + key_len + 1;\n+        int matched = sscanf(value_substr, scan_fmt, returnval);\n+        found_match = matched == 1;\n+        if (found_match) {\n+          break;\n@@ -130,7 +150,0 @@\n-      if (found_match) {\n-        fclose(fp);\n-        return 0;\n-      } else {\n-        err = 1;\n-        log_debug(os, container)(\"Type %s not found in file %s\", scan_fmt, file);\n-      }\n@@ -138,5 +151,0 @@\n-    if (err == 0) {\n-      log_debug(os, container)(\"Empty file %s\", file);\n-    }\n-  } else {\n-    log_debug(os, container)(\"Open of file %s failed, %s\", file, os::strerror(errno));\n@@ -144,2 +152,6 @@\n-  if (fp != NULL)\n-    fclose(fp);\n+  fclose(fp);\n+  if (found_match) {\n+    return 0;\n+  }\n+  log_debug(os, container)(\"Type %s (key == %s) not found in file %s\", scan_fmt,\n+                           (key == nullptr ? \"null\" : key), absolute_path);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":61,"deletions":49,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -99,4 +99,2 @@\n-      const char* matchline = \"hierarchical_memory_limit\";\n-      const char* format = \"%s \" JULONG_FORMAT;\n-      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", matchline,\n-                             \"Hierarchical Memory Limit is: \" JULONG_FORMAT, format, hier_memlimit)\n+      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", \"hierarchical_memory_limit\",\n+                             \"Hierarchical Memory Limit is: \" JULONG_FORMAT, JULONG_FORMAT, hier_memlimit)\n@@ -126,1 +124,0 @@\n-      const char* format = \"%s \" JULONG_FORMAT;\n@@ -128,1 +125,1 @@\n-                             \"Hierarchical Memory and Swap Limit is : \" JULONG_FORMAT, format, hier_memswlimit)\n+                             \"Hierarchical Memory and Swap Limit is : \" JULONG_FORMAT, JULONG_FORMAT, hier_memswlimit)\n@@ -136,1 +133,1 @@\n-                             \"Hierarchical Memory Limit is : \" JULONG_FORMAT, format, hier_memlimit)\n+                             \"Hierarchical Memory Limit is : \" JULONG_FORMAT, JULONG_FORMAT, hier_memlimit)\n@@ -289,1 +286,1 @@\n-                     \"Maximum number of tasks is: %s\", \"%s %*d\", pidsmax, 1024);\n+                     \"Maximum number of tasks is: %s\", \"%1023s\", pidsmax, 1024);\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-                     \"Maximum number of tasks is: %s\", \"%1023s %*d\", pidsmax, 1024);\n+                     \"Maximum number of tasks is: %s\", \"%1023s\", pidsmax, 1024);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2780,0 +2780,5 @@\n+bool os::numa_get_group_ids_for_range(const void** addresses, int* lgrp_ids, size_t count) {\n+  void** pages = const_cast<void**>(addresses);\n+  return os::Linux::numa_move_pages(0, count, pages, NULL, lgrp_ids, 0) == 0;\n+}\n+\n@@ -2810,4 +2815,0 @@\n-bool os::get_page_info(char *start, page_info* info) {\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,1 +136,1 @@\n-  int wait(jlong millis);\n+  int wait(uint64_t millis);\n","filename":"src\/hotspot\/os\/posix\/mutex_posix.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1872,2 +1872,1 @@\n-int PlatformMonitor::wait(jlong millis) {\n-  assert(millis >= 0, \"negative timeout\");\n+int PlatformMonitor::wait(uint64_t millis) {\n@@ -1878,1 +1877,2 @@\n-    \/\/ MAX_SECS anyway, so just do that here.\n+    \/\/ MAX_SECS anyway, so just do that here. This also handles values\n+    \/\/ larger than int64_t max.\n@@ -1880,1 +1880,1 @@\n-      millis = jlong(MAX_SECS) * MILLIUNITS;\n+      millis = uint64_t(MAX_SECS) * MILLIUNITS;\n@@ -1882,1 +1882,1 @@\n-    to_abstime(&abst, millis_to_nanos(millis), false, false);\n+    to_abstime(&abst, millis_to_nanos(int64_t(millis)), false, false);\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1208,1 +1208,4 @@\n-  if (fd == OS_ERR || HAS_PENDING_EXCEPTION) {\n+  if (HAS_PENDING_EXCEPTION) {\n+    assert(fd == OS_ERR, \"open_sharedmem_file always return OS_ERR on exceptions\");\n+  }\n+  if (fd == OS_ERR) {\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  int wait(jlong millis);\n+  int wait(uint64_t millis);\n","filename":"src\/hotspot\/os\/windows\/mutex_windows.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1891,0 +1891,4 @@\n+    } else {\n+      if (size < buflen) {\n+        buf[size] = '\\0';\n+      }\n@@ -3726,1 +3730,1 @@\n-bool os::get_page_info(char *start, page_info* info) {\n+bool os::numa_get_group_ids_for_range(const void** addresses, int* lgrp_ids, size_t count) {\n@@ -5361,2 +5365,1 @@\n-int PlatformMonitor::wait(jlong millis) {\n-  assert(millis >= 0, \"negative timeout\");\n+int PlatformMonitor::wait(uint64_t millis) {\n@@ -5364,0 +5367,4 @@\n+  \/\/ The timeout parameter for SleepConditionVariableCS is a DWORD\n+  if (millis > UINT_MAX) {\n+    millis = UINT_MAX;\n+  }\n@@ -5365,1 +5372,1 @@\n-                                        millis == 0 ? INFINITE : millis);\n+                                        millis == 0 ? INFINITE : (DWORD)millis);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -296,1 +296,1 @@\n-  ((objArrayOop)array.resolve())->atomic_compare_exchange_oop(index, o, NULL);\n+  ((objArrayOop)array.resolve())->replace_if_null(index, o);\n","filename":"src\/hotspot\/share\/cds\/cdsProtectionDomain.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,2 @@\n-#include \"ci\/ciUtilities.hpp\"\n+#include \"ci\/ciUtilities.inline.hpp\"\n+#include \"memory\/universe.hpp\"\n@@ -106,0 +107,1 @@\n+\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -695,1 +695,1 @@\n-  oop obj = cpool->resolved_references()->obj_at(obj_index);\n+  oop obj = cpool->resolved_reference_at(obj_index);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+  _transitive_interfaces = NULL;\n@@ -732,0 +733,26 @@\n+GrowableArray<ciInstanceKlass*>* ciInstanceKlass::transitive_interfaces() const{\n+  if (_transitive_interfaces == NULL) {\n+    const_cast<ciInstanceKlass*>(this)->compute_transitive_interfaces();\n+  }\n+  return _transitive_interfaces;\n+}\n+\n+void ciInstanceKlass::compute_transitive_interfaces() {\n+  GUARDED_VM_ENTRY(\n+          InstanceKlass* ik = get_instanceKlass();\n+          Array<InstanceKlass*>* interfaces = ik->transitive_interfaces();\n+          int orig_length = interfaces->length();\n+          Arena* arena = CURRENT_ENV->arena();\n+          int transitive_interfaces_len = orig_length + (is_interface() ? 1 : 0);\n+          GrowableArray<ciInstanceKlass*>* transitive_interfaces = new(arena)GrowableArray<ciInstanceKlass*>(arena, transitive_interfaces_len,\n+                                                                                                             0, NULL);\n+          for (int i = 0; i < orig_length; i++) {\n+            transitive_interfaces->append(CURRENT_ENV->get_instance_klass(interfaces->at(i)));\n+          }\n+          if (is_interface()) {\n+            transitive_interfaces->append(this);\n+          }\n+          _transitive_interfaces = transitive_interfaces;\n+  );\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+  GrowableArray<ciInstanceKlass*>* _transitive_interfaces;\n@@ -82,0 +83,1 @@\n+  void compute_transitive_interfaces();\n@@ -295,0 +297,1 @@\n+  GrowableArray<ciInstanceKlass*>* transitive_interfaces() const;\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -170,0 +170,1 @@\n+        obj->as_instance_klass()->transitive_interfaces();\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n@@ -70,1 +70,0 @@\n-#include \"oops\/objArrayKlass.hpp\"\n@@ -73,0 +72,1 @@\n+#include \"oops\/verifyOopClosure.hpp\"\n@@ -1014,0 +1014,17 @@\n+class VerifyHandleOops : public OopClosure {\n+  VerifyOopClosure vc;\n+ public:\n+  virtual void do_oop(oop* p) {\n+    if (p != nullptr && *p != nullptr) {\n+      oop o = *p;\n+      if (!java_lang_Class::is_instance(o)) {\n+        \/\/ is_instance will assert for an invalid oop.\n+        \/\/ Walk the resolved_references array and other assorted oops in the\n+        \/\/ CLD::_handles field.  The mirror oops are followed by other heap roots.\n+        o->oop_iterate(&vc);\n+      }\n+    }\n+  }\n+  virtual void do_oop(narrowOop* o) { ShouldNotReachHere(); }\n+};\n+\n@@ -1037,0 +1054,13 @@\n+\n+  if (_deallocate_list != nullptr) {\n+    for (int i = _deallocate_list->length() - 1; i >= 0; i--) {\n+      Metadata* m = _deallocate_list->at(i);\n+      if (m->is_klass()) {\n+        ((Klass*)m)->verify();\n+      }\n+    }\n+  }\n+\n+  \/\/ Check the oops in the handles area\n+  VerifyHandleOops vho;\n+  oops_do(&vho, _claim_none, false);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":33,"deletions":3,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1297,3 +1297,0 @@\n-    \/\/ The SEARCH_* bits are not for MN.flags but for the matchFlags argument of MHN.getMembers:\n-    MN_SEARCH_SUPERCLASSES   = 0x00100000, \/\/ walk super classes\n-    MN_SEARCH_INTERFACES     = 0x00200000, \/\/ walk implemented interfaces\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+      ::close(file_handle);\n@@ -101,2 +102,0 @@\n-        \/\/ close file\n-        ::close(file_handle);\n","filename":"src\/hotspot\/share\/compiler\/directivesParser.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,6 +52,0 @@\n-bool G1BlockOffsetTable::is_card_boundary(HeapWord* p) const {\n-  assert(p >= _reserved.start(), \"just checking\");\n-  size_t delta = pointer_delta(p, _reserved.start());\n-  return (delta & right_n_bits((int)BOTConstants::log_card_size_in_words())) == (size_t)NoBits;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -74,2 +74,0 @@\n-  bool is_card_boundary(HeapWord* p) const;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1858,6 +1858,1 @@\n-  switch (cause) {\n-    case GCCause::_java_lang_system_gc:                 return ExplicitGCInvokesConcurrent;\n-    case GCCause::_dcmd_gc_run:                         return ExplicitGCInvokesConcurrent;\n-    case GCCause::_wb_conc_mark:                        return true;\n-    default :                                           return false;\n-  }\n+  return GCCause::is_user_requested_gc(cause) && ExplicitGCInvokesConcurrent;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -255,1 +255,1 @@\n-  \/\/ (d) cause == _wb_conc_mark or _wb_breakpoint,\n+  \/\/ (d) cause == _wb_breakpoint,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -379,6 +379,0 @@\n-  if (NUMAStats) {\n-    for (int i = 0; i < lgrp_spaces()->length(); i++) {\n-      lgrp_spaces()->at(i)->accumulate_statistics(page_size());\n-    }\n-  }\n-\n@@ -408,6 +402,0 @@\n-\n-  if (NUMAStats) {\n-    for (int i = 0; i < lgrp_spaces()->length(); i++) {\n-      lgrp_spaces()->at(i)->accumulate_statistics(page_size());\n-    }\n-  }\n@@ -873,2 +861,1 @@\n-                SIZE_FORMAT \"K\/\" SIZE_FORMAT \"K\/\" SIZE_FORMAT\n-                \"K, large\/small pages: \" SIZE_FORMAT \"\/\" SIZE_FORMAT \"\\n\",\n+                SIZE_FORMAT \"K\/\" SIZE_FORMAT \"K\/\" SIZE_FORMAT \"K\\n\",\n@@ -878,3 +865,1 @@\n-                ls->space_stats()->_uncommited_space \/ K,\n-                ls->space_stats()->_large_pages,\n-                ls->space_stats()->_small_pages);\n+                ls->space_stats()->_uncommited_space \/ K);\n@@ -898,18 +883,13 @@\n-  if (start < end) {\n-    for (char *p = start; p < end;) {\n-      os::page_info info;\n-      if (os::get_page_info(p, &info)) {\n-        if (info.size > 0) {\n-          if (info.size > (size_t)os::vm_page_size()) {\n-            space_stats()->_large_pages++;\n-          } else {\n-            space_stats()->_small_pages++;\n-          }\n-          if (info.lgrp_id == lgrp_id()) {\n-            space_stats()->_local_space += info.size;\n-          } else {\n-            space_stats()->_remote_space += info.size;\n-          }\n-          p += info.size;\n-        } else {\n-          p += os::vm_page_size();\n+  for (char *p = start; p < end; ) {\n+    static const size_t PagesPerIteration = 128;\n+    const void* pages[PagesPerIteration];\n+    int lgrp_ids[PagesPerIteration];\n+\n+    size_t npages = 0;\n+    for (; npages < PagesPerIteration && p < end; p += os::vm_page_size()) {\n+      pages[npages++] = p;\n+    }\n+\n+    if (os::numa_get_group_ids_for_range(pages, lgrp_ids, npages)) {\n+      for (size_t i = 0; i < npages; i++) {\n+        if (lgrp_ids[i] < 0) {\n@@ -917,0 +897,4 @@\n+        } else if (lgrp_ids[i] == lgrp_id()) {\n+          space_stats()->_local_space += os::vm_page_size();\n+        } else {\n+          space_stats()->_remote_space += os::vm_page_size();\n@@ -918,2 +902,0 @@\n-      } else {\n-        return;\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":20,"deletions":38,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,0 @@\n-      size_t _large_pages, _small_pages;\n@@ -83,2 +82,0 @@\n-        _large_pages = 0;\n-        _small_pages = 0;\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -489,1 +489,1 @@\n-  TenuredSpace* space = (TenuredSpace*)_the_space;\n+  TenuredSpace* space = _the_space;\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-  ContiguousSpace*    _the_space;       \/\/ Actual space holding objects\n+  TenuredSpace*       _the_space;       \/\/ Actual space holding objects\n@@ -74,1 +74,1 @@\n-  ContiguousSpace* space() const { return _the_space; }\n+  TenuredSpace* space() const { return _the_space; }\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  nonstatic_field(TenuredGeneration,           _the_space,             ContiguousSpace*)        \\\n+  nonstatic_field(TenuredGeneration,           _the_space,             TenuredSpace*)           \\\n","filename":"src\/hotspot\/share\/gc\/serial\/vmStructs_serial.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-    thread->set_nmethod_disarm_value(bs_nm->disarmed_value());\n+    thread->set_nmethod_disarmed_guard_value(bs_nm->disarmed_guard_value());\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,2 +43,2 @@\n-int BarrierSetNMethod::disarmed_value() const {\n-  return *disarmed_value_address();\n+int BarrierSetNMethod::disarmed_guard_value() const {\n+  return *disarmed_guard_value_address();\n@@ -72,0 +72,8 @@\n+void BarrierSetNMethod::disarm(nmethod* nm) {\n+  set_guard_value(nm, disarmed_guard_value());\n+}\n+\n+bool BarrierSetNMethod::is_armed(nmethod* nm) {\n+  return guard_value(nm) != disarmed_guard_value();\n+}\n+\n@@ -105,1 +113,1 @@\n-int* BarrierSetNMethod::disarmed_value_address() const {\n+int* BarrierSetNMethod::disarmed_guard_value_address() const {\n@@ -109,2 +117,2 @@\n-ByteSize BarrierSetNMethod::thread_disarmed_offset() const {\n-  return Thread::nmethod_disarmed_offset();\n+ByteSize BarrierSetNMethod::thread_disarmed_guard_value_offset() const {\n+  return Thread::nmethod_disarmed_guard_value_offset();\n@@ -115,1 +123,1 @@\n-  int _disarm_value;\n+  int _disarmed_guard_value;\n@@ -118,2 +126,2 @@\n-  BarrierSetNMethodArmClosure(int disarm_value) :\n-      _disarm_value(disarm_value) {}\n+  BarrierSetNMethodArmClosure(int disarmed_guard_value) :\n+      _disarmed_guard_value(disarmed_guard_value) {}\n@@ -122,1 +130,1 @@\n-    thread->set_nmethod_disarm_value(_disarm_value);\n+    thread->set_nmethod_disarmed_guard_value(_disarmed_guard_value);\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -44,2 +44,2 @@\n-  virtual ByteSize thread_disarmed_offset() const;\n-  virtual int* disarmed_value_address() const;\n+  virtual ByteSize thread_disarmed_guard_value_offset() const;\n+  virtual int* disarmed_guard_value_address() const;\n@@ -47,1 +47,1 @@\n-  int disarmed_value() const;\n+  int disarmed_guard_value() const;\n@@ -53,1 +53,3 @@\n-  void arm(nmethod* nm, int arm_value);\n+\n+  int guard_value(nmethod* nm);\n+  void set_guard_value(nmethod* nm, int value);\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -267,0 +267,1 @@\n+  virtual void eliminate_gc_barrier_data(Node* node) const { }\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -116,11 +116,0 @@\n-  \/\/ The kinds of precision a CardTable may offer.\n-  enum PrecisionStyle {\n-    Precise,\n-    ObjHeadPreciseArray\n-  };\n-\n-  \/\/ Tells what style of precision this card table offers.\n-  PrecisionStyle precision() {\n-    return ObjHeadPreciseArray; \/\/ Only one supported for now.\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-void CardTableRS::younger_refs_in_space_iterate(ContiguousSpace* sp,\n+void CardTableRS::younger_refs_in_space_iterate(TenuredSpace* sp,\n@@ -443,1 +443,1 @@\n-void CardTableRS::non_clean_card_iterate(ContiguousSpace* sp,\n+void CardTableRS::non_clean_card_iterate(TenuredSpace* sp,\n@@ -454,1 +454,1 @@\n-  DirtyCardToOopClosure* dcto_cl = sp->new_dcto_cl(cl, precision(), gen_boundary);\n+  DirtyCardToOopClosure* dcto_cl = sp->new_dcto_cl(cl, gen_boundary);\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableRS.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-class ContiguousSpace;\n@@ -36,0 +35,2 @@\n+class TenuredSpace;\n+\n@@ -50,1 +51,1 @@\n-  void younger_refs_in_space_iterate(ContiguousSpace* sp, HeapWord* gen_boundary, OopIterateClosure* cl);\n+  void younger_refs_in_space_iterate(TenuredSpace* sp, HeapWord* gen_boundary, OopIterateClosure* cl);\n@@ -73,1 +74,1 @@\n-  void non_clean_card_iterate(ContiguousSpace* sp,\n+  void non_clean_card_iterate(TenuredSpace* sp,\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableRS.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,3 +57,0 @@\n-    case _wb_conc_mark:\n-      return \"WhiteBox Initiated Concurrent Mark\";\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/gcCause.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,0 @@\n-    _wb_conc_mark,\n","filename":"src\/hotspot\/share\/gc\/shared\/gcCause.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,14 +54,8 @@\n-      if (_precision == CardTable::ObjHeadPreciseArray) {\n-        if (cast_to_oop(top_obj)->is_objArray() || cast_to_oop(top_obj)->is_typeArray()) {\n-          \/\/ An arrayOop is starting on the dirty card - since we do exact\n-          \/\/ store checks for objArrays we are done.\n-        } else {\n-          \/\/ Otherwise, it is possible that the object starting on the dirty\n-          \/\/ card spans the entire card, and that the store happened on a\n-          \/\/ later card.  Figure out where the object ends.\n-          \/\/ Use the block_size() method of the space over which\n-          \/\/ the iteration is being done.  That space (e.g. CMS) may have\n-          \/\/ specific requirements on object sizes which will\n-          \/\/ be reflected in the block_size() method.\n-          top = top_obj + cast_to_oop(top_obj)->size();\n-        }\n+      if (cast_to_oop(top_obj)->is_objArray() || cast_to_oop(top_obj)->is_typeArray()) {\n+        \/\/ An arrayOop is starting on the dirty card - since we do exact\n+        \/\/ store checks for objArrays we are done.\n+      } else {\n+        \/\/ Otherwise, it is possible that the object starting on the dirty\n+        \/\/ card spans the entire card, and that the store happened on a\n+        \/\/ later card.  Figure out where the object ends.\n+        top = top_obj + cast_to_oop(top_obj)->size();\n@@ -118,6 +112,1 @@\n-  assert(_precision == CardTable::ObjHeadPreciseArray ||\n-         _precision == CardTable::Precise,\n-         \"Only ones we deal with for now.\");\n-\n-  assert(_precision != CardTable::ObjHeadPreciseArray ||\n-         _last_bottom == NULL || top <= _last_bottom,\n+  assert(_last_bottom == NULL || top <= _last_bottom,\n@@ -139,3 +128,1 @@\n-  if (_precision == CardTable::ObjHeadPreciseArray &&\n-      _min_done != NULL &&\n-      _min_done < top) {\n+  if (_min_done != NULL && _min_done < top) {\n@@ -151,3 +138,1 @@\n-         (_precision != CardTable::ObjHeadPreciseArray ||\n-          _min_done == NULL ||\n-          top <= _min_done),\n+         (_min_done == NULL || top <= _min_done),\n@@ -167,12 +152,10 @@\n-    if (_precision == CardTable::ObjHeadPreciseArray) {\n-      if (cast_to_oop(top_obj)->is_objArray() || cast_to_oop(top_obj)->is_typeArray()) {\n-        \/\/ An arrayOop is starting on the dirty card - since we do exact\n-        \/\/ store checks for objArrays we are done.\n-      } else {\n-        \/\/ Otherwise, it is possible that the object starting on the dirty\n-        \/\/ card spans the entire card, and that the store happened on a\n-        \/\/ later card.  Figure out where the object ends.\n-        assert(_sp->block_size(top_obj) == cast_to_oop(top_obj)->size(),\n-          \"Block size and object size mismatch\");\n-        top = top_obj + cast_to_oop(top_obj)->size();\n-      }\n+    if (cast_to_oop(top_obj)->is_objArray() || cast_to_oop(top_obj)->is_typeArray()) {\n+      \/\/ An arrayOop is starting on the dirty card - since we do exact\n+      \/\/ store checks for objArrays we are done.\n+    } else {\n+      \/\/ Otherwise, it is possible that the object starting on the dirty\n+      \/\/ card spans the entire card, and that the store happened on a\n+      \/\/ later card.  Figure out where the object ends.\n+      assert(_sp->block_size(top_obj) == cast_to_oop(top_obj)->size(),\n+        \"Block size and object size mismatch\");\n+      top = top_obj + cast_to_oop(top_obj)->size();\n@@ -238,1 +221,0 @@\n-                             CardTable::PrecisionStyle precision,\n@@ -240,1 +222,1 @@\n-  return new ContiguousSpaceDCTOC(this, cl, precision, boundary);\n+  return new ContiguousSpaceDCTOC(this, cl, boundary);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":22,"deletions":40,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -243,1 +243,0 @@\n-  CardTable::PrecisionStyle _precision;\n@@ -246,2 +245,2 @@\n-  HeapWord* _min_done;          \/\/ ObjHeadPreciseArray precision requires\n-                                \/\/ a downwards traversal; this is the\n+  HeapWord* _min_done;          \/\/ Need a downwards traversal to compensate\n+                                \/\/ imprecise write barrier; this is the\n@@ -271,1 +270,0 @@\n-                        CardTable::PrecisionStyle precision,\n@@ -273,1 +271,1 @@\n-    _cl(cl), _sp(sp), _precision(precision), _boundary(boundary),\n+    _cl(cl), _sp(sp), _boundary(boundary),\n@@ -470,1 +468,0 @@\n-                                     CardTable::PrecisionStyle precision,\n@@ -547,1 +544,0 @@\n-                       CardTable::PrecisionStyle precision,\n@@ -549,1 +545,1 @@\n-    DirtyCardToOopClosure(sp, cl, precision, boundary)\n+    DirtyCardToOopClosure(sp, cl, boundary)\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -238,2 +238,0 @@\n-  declare_constant(CardTable::Precise)                                      \\\n-  declare_constant(CardTable::ObjHeadPreciseArray)                          \\\n","filename":"src\/hotspot\/share\/gc\/shared\/vmStructs_gc.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-      thread->set_nmethod_disarm_value(bs_nm->disarmed_value());\n+      thread->set_nmethod_disarmed_guard_value(bs_nm->disarmed_guard_value());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-      _bs->arm(nm, 0);\n+      _bs->set_guard_value(nm, 0);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-int* ZBarrierSetNMethod::disarmed_value_address() const {\n+int* ZBarrierSetNMethod::disarmed_guard_value_address() const {\n@@ -75,1 +75,1 @@\n-ByteSize ZBarrierSetNMethod::thread_disarmed_offset() const {\n+ByteSize ZBarrierSetNMethod::thread_disarmed_guard_value_offset() const {\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetNMethod.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-  virtual ByteSize thread_disarmed_offset() const;\n-  virtual int* disarmed_value_address() const;\n+  virtual ByteSize thread_disarmed_guard_value_offset() const;\n+  virtual int* disarmed_guard_value_address() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetNMethod.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -225,1 +225,0 @@\n-  case GCCause::_wb_conc_mark:\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-void ZNMethod::arm(nmethod* nm, int arm_value) {\n+void ZNMethod::set_guard_value(nmethod* nm, int value) {\n@@ -202,3 +202,1 @@\n-  if (bs != NULL) {\n-    bs->arm(nm, arm_value);\n-  }\n+  bs->set_guard_value(nm, value);\n@@ -303,1 +301,1 @@\n-      \/\/ Heal oops and disarm\n+      \/\/ Heal oops and arm phase invariantly\n@@ -305,1 +303,1 @@\n-      ZNMethod::arm(nm, 0);\n+      ZNMethod::set_guard_value(nm, 0);\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  static void arm(nmethod* nm, int arm_value);\n+  static void set_guard_value(nmethod* nm, int value);\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -197,1 +197,1 @@\n-      oop coop = m->constants()->resolved_references()->obj_at(rindex);\n+      oop coop = m->constants()->resolved_reference_at(rindex);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -978,1 +978,5 @@\n-    THROW_MSG(vmSymbols::java_lang_NoSuchFieldError(), field->as_C_string());\n+    stringStream ss;\n+    ss.print(\"Class %s does not have member field '\", resolved_klass->external_name());\n+    sig->print_as_field_external_type(&ss);\n+    ss.print(\" %s'\", field->as_C_string());\n+    THROW_MSG(vmSymbols::java_lang_NoSuchFieldError(), ss.as_string());\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2130,1 +2130,1 @@\n-              oop result = constants->resolved_references()->obj_at(index);\n+              oop result = constants->resolved_reference_at(index);\n@@ -2235,1 +2235,1 @@\n-        oop result = constants->resolved_references()->obj_at(index);\n+        oop result = constants->resolved_reference_at(index);\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-  if (*ref != NULL) {\n+  if (NativeAccess<>::oop_load(ref) != nullptr) {\n@@ -67,0 +67,24 @@\n+template <typename Delegate>\n+class RawRootClosure : public OopClosure {\n+  Delegate* _delegate;\n+\n+public:\n+  RawRootClosure(Delegate* delegate) : _delegate(delegate) {}\n+\n+  void do_oop(oop* ref) {\n+    assert(ref != NULL, \"invariant\");\n+    assert(is_aligned(ref, HeapWordSize), \"invariant\");\n+    if (*ref != nullptr) {\n+      _delegate->do_root(UnifiedOopRef::encode_as_raw(ref));\n+    }\n+  }\n+\n+  void do_oop(narrowOop* ref) {\n+    assert(ref != NULL, \"invariant\");\n+    assert(is_aligned(ref, HeapWordSize), \"invariant\");\n+    if (!CompressedOops::is_null(*ref)) {\n+      _delegate->do_root(UnifiedOopRef::encode_as_raw(ref));\n+    }\n+  }\n+};\n+\n@@ -70,0 +94,1 @@\n+\n@@ -72,2 +97,1 @@\n-  \/\/ We don't follow code blob oops, because they have misaligned oops.\n-  Threads::oops_do(this, NULL);\n+\n@@ -75,0 +99,4 @@\n+\n+  \/\/ We don't follow code blob oops, because they have misaligned oops.\n+  RawRootClosure<Delegate> rrc(_delegate);\n+  Threads::oops_do(&rrc, NULL);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/rootSetClosure.cpp","additions":31,"deletions":3,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -32,0 +32,9 @@\n+  static const uintptr_t tag_mask   = LP64_ONLY(0b111) NOT_LP64(0b011);\n+  static const uintptr_t native_tag = 0b001;\n+  static const uintptr_t raw_tag    = 0b010;\n+  static const uintptr_t narrow_tag = LP64_ONLY(0b100) NOT_LP64(0);\n+  STATIC_ASSERT((native_tag & raw_tag) == 0);\n+  STATIC_ASSERT((native_tag & narrow_tag) == 0);\n+  STATIC_ASSERT((raw_tag & narrow_tag) == 0);\n+  STATIC_ASSERT((native_tag | raw_tag | narrow_tag) == tag_mask);\n+\n@@ -39,0 +48,1 @@\n+  bool is_raw() const;\n@@ -45,1 +55,2 @@\n-  static UnifiedOopRef encode_in_heap(const oop* ref);\n+  static UnifiedOopRef encode_as_raw(const narrowOop* ref);\n+  static UnifiedOopRef encode_as_raw(const oop* ref);\n@@ -47,0 +58,1 @@\n+  static UnifiedOopRef encode_in_heap(const oop* ref);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/utilities\/unifiedOopRef.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  return reinterpret_cast<T>(_value & ~uintptr_t(3));\n+  return reinterpret_cast<T>(UnifiedOopRef::addr<uintptr_t>());\n@@ -45,1 +45,1 @@\n-  return _value & ~uintptr_t(3);\n+  return (_value & ~tag_mask) LP64_ONLY(>> 1);\n@@ -49,1 +49,1 @@\n-  return _value & 1;\n+  return (_value & narrow_tag) != 0;\n@@ -53,1 +53,5 @@\n-  return _value & 2;\n+  return (_value & native_tag) != 0;\n+}\n+\n+inline bool UnifiedOopRef::is_raw() const {\n+  return (_value & raw_tag) != 0;\n@@ -60,1 +64,2 @@\n-inline UnifiedOopRef UnifiedOopRef::encode_in_native(const narrowOop* ref) {\n+template <typename T>\n+inline UnifiedOopRef create_with_tag(T ref, uintptr_t tag) {\n@@ -62,2 +67,14 @@\n-  UnifiedOopRef result = { reinterpret_cast<uintptr_t>(ref) | 3 };\n-  assert(result.addr<narrowOop*>() == ref, \"sanity\");\n+\n+  uintptr_t value = reinterpret_cast<uintptr_t>(ref);\n+\n+#ifdef _LP64\n+  \/\/ tag_mask is 3 bits. When ref is a narrowOop* we only have 2 alignment\n+  \/\/ bits, because of the 4 byte alignment of compressed oops addresses.\n+  \/\/ Shift up to make way for one more bit.\n+  assert((value & (1ull << 63)) == 0, \"Unexpected high-order bit\");\n+  value <<= 1;\n+#endif\n+  assert((value & UnifiedOopRef::tag_mask) == 0, \"Unexpected low-order bits\");\n+\n+  UnifiedOopRef result = { value | tag };\n+  assert(result.addr<T>() == ref, \"sanity\");\n@@ -67,0 +84,5 @@\n+inline UnifiedOopRef UnifiedOopRef::encode_in_native(const narrowOop* ref) {\n+  NOT_LP64(ShouldNotReachHere());\n+  return create_with_tag(ref, native_tag | narrow_tag);\n+}\n+\n@@ -68,4 +90,10 @@\n-  assert(ref != NULL, \"invariant\");\n-  UnifiedOopRef result = { reinterpret_cast<uintptr_t>(ref) | 2 };\n-  assert(result.addr<oop*>() == ref, \"sanity\");\n-  return result;\n+  return create_with_tag(ref, native_tag);\n+}\n+\n+inline UnifiedOopRef UnifiedOopRef::encode_as_raw(const narrowOop* ref) {\n+  NOT_LP64(ShouldNotReachHere());\n+  return create_with_tag(ref, raw_tag | narrow_tag);\n+}\n+\n+inline UnifiedOopRef UnifiedOopRef::encode_as_raw(const oop* ref) {\n+  return create_with_tag(ref, raw_tag);\n@@ -75,4 +103,2 @@\n-  assert(ref != NULL, \"invariant\");\n-  UnifiedOopRef result = { reinterpret_cast<uintptr_t>(ref) | 1 };\n-  assert(result.addr<narrowOop*>() == ref, \"sanity\");\n-  return result;\n+  NOT_LP64(ShouldNotReachHere());\n+  return create_with_tag(ref, narrow_tag);\n@@ -82,4 +108,1 @@\n-  assert(ref != NULL, \"invariant\");\n-  UnifiedOopRef result = { reinterpret_cast<uintptr_t>(ref) | 0 };\n-  assert(result.addr<oop*>() == ref, \"sanity\");\n-  return result;\n+  return create_with_tag(ref, 0);\n@@ -94,1 +117,8 @@\n-  if (is_native()) {\n+  if (is_raw()) {\n+    if (is_narrow()) {\n+      NOT_LP64(ShouldNotReachHere());\n+      return RawAccess<>::oop_load(addr<narrowOop*>());\n+    } else {\n+      return *addr<oop*>();\n+    }\n+  } else if (is_native()) {\n@@ -96,0 +126,1 @@\n+      NOT_LP64(ShouldNotReachHere());\n@@ -102,0 +133,1 @@\n+      NOT_LP64(ShouldNotReachHere());\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/utilities\/unifiedOopRef.inline.hpp","additions":52,"deletions":20,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1147,2 +1147,3 @@\n-  <Event name=\"HeapDump\" category=\"Java Virtual Machine, Diagnostics\" label=\"Heap Dump\" stackTrace=\"true\" thread=\"true\">\n-    <Field type=\"string\" name=\"destination\" label=\"Destination\" \/>\n+  <Event name=\"HeapDump\" category=\"Java Virtual Machine, Diagnostics\" label=\"Heap Dump\" description=\"Information about a successfully written Java heap dump\"\n+    stackTrace=\"true\" thread=\"true\">\n+    <Field type=\"string\" name=\"destination\" label=\"Destination Path of the Dump\" \/>\n@@ -1151,1 +1152,3 @@\n-    <Field type=\"boolean\" name=\"onOutOfMemoryError\" label=\"On Out of Memory Error\" \/>\n+    <Field type=\"boolean\" name=\"onOutOfMemoryError\" label=\"Heap Dump on Out of Memory Error\" \/>\n+    <Field type=\"boolean\" name=\"overwrite\" label=\"Overwrite\" description=\"Heap dump overwrites previous file location if it exists\" \/>\n+    <Field type=\"int\" name=\"compression\" label=\"Compression Level\" description=\"Compression level of the dump, if larger than 0 we use gzip compression with this level\" \/>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-                                  sizeof(_path_buffer),\n+                                  sizeof(_path_buffer) - path_len,\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrEmergencyDump.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_METAPROGRAMMING_DECAY_HPP\n-#define SHARE_METAPROGRAMMING_DECAY_HPP\n-\n-#include \"memory\/allStatic.hpp\"\n-#include \"metaprogramming\/removeReference.hpp\"\n-\n-#include <type_traits>\n-\n-\/\/ This trait trims the type from CV qualifiers and references.\n-\/\/ This trait provides a subset of the functionality of std::decay;\n-\/\/ array types and function types are not supported here.\n-\n-template <typename T>\n-struct Decay: AllStatic {\n-  using type = std::remove_cv_t<typename RemoveReference<T>::type>;\n-};\n-\n-#endif \/\/ SHARE_METAPROGRAMMING_DECAY_HPP\n","filename":"src\/hotspot\/share\/metaprogramming\/decay.hpp","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\n-#ifndef SHARE_METAPROGRAMMING_ISINTEGRAL_HPP\n-#define SHARE_METAPROGRAMMING_ISINTEGRAL_HPP\n-\n-#include \"metaprogramming\/integralConstant.hpp\"\n-#include \"metaprogramming\/isSigned.hpp\"\n-\n-#include <limits>\n-#include <type_traits>\n-\n-\/\/ This metafunction returns true iff the type T (irrespective of CV qualifiers)\n-\/\/ is an integral type. Note that this is false for enums.\n-\n-template<typename T>\n-struct IsIntegral\n-  : public IntegralConstant<bool, std::numeric_limits<typename std::remove_cv<T>::type>::is_integer>\n-{};\n-\n-\/\/ This metafunction returns true iff the type T (irrespective of CV qualifiers)\n-\/\/ is a signed integral type. Note that this is false for enums.\n-\n-template<typename T>\n-struct IsSignedIntegral\n-  : public IntegralConstant<bool, IsIntegral<T>::value && IsSigned<T>::value>\n-{};\n-\n-\/\/ This metafunction returns true iff the type T (irrespective of CV qualifiers)\n-\/\/ is an unsigned integral type. Note that this is false for enums.\n-\n-template<typename T>\n-struct IsUnsignedIntegral\n-  : public IntegralConstant<bool, IsIntegral<T>::value && !IsSigned<T>::value>\n-{};\n-\n-#endif \/\/ SHARE_METAPROGRAMMING_ISINTEGRAL_HPP\n","filename":"src\/hotspot\/share\/metaprogramming\/isIntegral.hpp","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_METAPROGRAMMING_REMOVEPOINTER_HPP\n-#define SHARE_METAPROGRAMMING_REMOVEPOINTER_HPP\n-\n-#include \"memory\/allStatic.hpp\"\n-\n-\/\/ This metafunction returns for a type T either the underlying type behind\n-\/\/ the pointer iff T is a pointer type (irrespective of CV qualifiers),\n-\/\/ or the same type T if T is not a pointer type.\n-\n-template <typename T> struct RemovePointer: AllStatic { typedef T type; };\n-\n-template <typename T> struct RemovePointer<T*>: AllStatic { typedef T type; };\n-template <typename T> struct RemovePointer<T* const>: AllStatic { typedef T type; };\n-template <typename T> struct RemovePointer<T* volatile>: AllStatic { typedef T type; };\n-template <typename T> struct RemovePointer<T* const volatile>: AllStatic { typedef T type; };\n-\n-#endif \/\/ SHARE_METAPROGRAMMING_REMOVEPOINTER_HPP\n","filename":"src\/hotspot\/share\/metaprogramming\/removePointer.hpp","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"metaprogramming\/decay.hpp\"\n@@ -34,1 +33,0 @@\n-#include \"metaprogramming\/isIntegral.hpp\"\n@@ -432,1 +430,1 @@\n-    typedef typename OopOrNarrowOopInternal<typename Decay<T>::type>::type type;\n+    typedef typename OopOrNarrowOopInternal<std::decay_t<T>>::type type;\n@@ -1098,1 +1096,1 @@\n-                   (IsPointer<T>::value || IsIntegral<T>::value) ||\n+                   (IsPointer<T>::value || std::is_integral<T>::value) ||\n@@ -1105,2 +1103,2 @@\n-    typedef typename Decay<P>::type DecayedP;\n-    typedef typename Decay<T>::type DecayedT;\n+    using DecayedP = std::decay_t<P>;\n+    using DecayedT = std::decay_t<T>;\n@@ -1119,1 +1117,1 @@\n-    typedef typename Decay<T>::type DecayedT;\n+    using DecayedT = std::decay_t<T>;\n@@ -1130,1 +1128,1 @@\n-    typedef typename Decay<P>::type DecayedP;\n+    using DecayedP = std::decay_t<P>;\n@@ -1133,1 +1131,1 @@\n-                                 typename Decay<T>::type>::type DecayedT;\n+                                 std::decay_t<T>>::type DecayedT;\n@@ -1147,1 +1145,1 @@\n-                                 typename Decay<T>::type>::type DecayedT;\n+                                 std::decay_t<T>>::type DecayedT;\n@@ -1159,2 +1157,2 @@\n-    typedef typename Decay<P>::type DecayedP;\n-    typedef typename Decay<T>::type DecayedT;\n+    using DecayedP = std::decay_t<P>;\n+    using DecayedT = std::decay_t<T>;\n@@ -1174,1 +1172,1 @@\n-    typedef typename Decay<T>::type DecayedT;\n+    using DecayedT = std::decay_t<T>;\n@@ -1192,2 +1190,2 @@\n-    typedef typename Decay<P>::type DecayedP;\n-    typedef typename Decay<T>::type DecayedT;\n+    using DecayedP = std::decay_t<P>;\n+    using DecayedT = std::decay_t<T>;\n@@ -1204,1 +1202,1 @@\n-    typedef typename Decay<T>::type DecayedT;\n+    using DecayedT = std::decay_t<T>;\n@@ -1218,1 +1216,1 @@\n-                   (IsSame<T, void>::value || IsIntegral<T>::value) ||\n+                   (IsSame<T, void>::value || std::is_integral<T>::value) ||\n@@ -1220,1 +1218,1 @@\n-    typedef typename Decay<T>::type DecayedT;\n+    using DecayedT = std::decay_t<T>;\n@@ -1258,0 +1256,8 @@\n+\n+    inline bool operator ==(std::nullptr_t) const {\n+      return load<decorators | INTERNAL_VALUE_IS_OOP, P, oop>(_addr) == nullptr;\n+    }\n+\n+    inline bool operator !=(std::nullptr_t) const {\n+      return load<decorators | INTERNAL_VALUE_IS_OOP, P, oop>(_addr) != nullptr;\n+    }\n","filename":"src\/hotspot\/share\/oops\/accessBackend.hpp","additions":24,"deletions":18,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,1 +161,1 @@\n-  return (objArrayOop)_cache->resolved_references();\n+  return _cache->resolved_references();\n@@ -170,1 +170,1 @@\n-    return (objArrayOop)_cache->resolved_references();\n+    return _cache->resolved_references();\n@@ -174,0 +174,12 @@\n+oop ConstantPool::resolved_reference_at(int index) const {\n+  oop result = resolved_references()->obj_at(index);\n+  assert(oopDesc::is_oop_or_null(result), \"Must be oop\");\n+  return result;\n+}\n+\n+\/\/ Use a CAS for multithreaded access\n+oop ConstantPool::set_resolved_reference_at(int index, oop new_result) {\n+  assert(oopDesc::is_oop_or_null(new_result), \"Must be oop\");\n+  return resolved_references()->replace_if_null(index, new_result);\n+}\n+\n@@ -449,1 +461,2 @@\n-  resolved_references()->obj_at_put(obj_index, str);\n+  oop result = set_resolved_reference_at(obj_index, str);\n+  assert(result == nullptr || result == str, \"Only set once or to the same string.\");\n@@ -939,1 +952,1 @@\n-    result_oop = this_cp->resolved_references()->obj_at(cache_index);\n+    result_oop = this_cp->resolved_reference_at(cache_index);\n@@ -1162,3 +1175,2 @@\n-    oop old_result = this_cp->resolved_references()\n-      ->atomic_compare_exchange_oop(cache_index, new_result, NULL);\n-    if (old_result == NULL) {\n+    oop old_result = this_cp->set_resolved_reference_at(cache_index, new_result);\n+    if (old_result == nullptr) {\n@@ -1225,1 +1237,1 @@\n-  oop str = this_cp->resolved_references()->obj_at(obj_index);\n+  oop str = this_cp->resolved_reference_at(obj_index);\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,0 +239,3 @@\n+  oop resolved_reference_at(int obj_index) const;\n+  oop set_resolved_reference_at(int index, oop new_value);\n+\n@@ -477,1 +480,1 @@\n-    return resolved_references()->obj_at(obj_index);\n+    return resolved_reference_at(obj_index);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -435,4 +435,2 @@\n-    objArrayOop resolved_references = cpool->resolved_references();\n-    assert(appendix_index >= 0 && appendix_index < resolved_references->length(), \"oob\");\n-    assert(resolved_references->obj_at(appendix_index) == NULL, \"init just once\");\n-    resolved_references->obj_at_put(appendix_index, appendix());\n+    oop old_oop = cpool->set_resolved_reference_at(appendix_index, appendix());\n+    assert(old_oop == nullptr, \"init just once\");\n@@ -534,2 +532,1 @@\n-  objArrayOop resolved_references = cpool->resolved_references();\n-  return resolved_references->obj_at(ref_index);\n+  return cpool->resolved_reference_at(ref_index);\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -450,1 +450,1 @@\n-  inline oop resolved_references();\n+  inline objArrayOop resolved_references();\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,1 +102,5 @@\n-inline oop ConstantPoolCache::resolved_references() { return _resolved_references.resolve(); }\n+inline objArrayOop ConstantPoolCache::resolved_references() {\n+  oop obj = _resolved_references.resolve();\n+  assert(obj == nullptr || obj->is_objArray(), \"should be objArray\");\n+  return (objArrayOop)obj;\n+}\n","filename":"src\/hotspot\/share\/oops\/cpCache.inline.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1598,1 +1598,1 @@\n-  return profile_arguments_flag() > no_type_profile && profile_arguments_flag() <= type_profile_all;\n+  return profile_arguments_flag() > no_type_profile && profile_arguments_flag() <= type_profile_all && TypeProfileArgsLimit > 0;\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,1 @@\n-oop objArrayOopDesc::atomic_compare_exchange_oop(int index, oop exchange_value,\n-                                                 oop compare_value) {\n+oop objArrayOopDesc::replace_if_null(int index, oop exchange_value) {\n@@ -39,1 +38,1 @@\n-  return HeapAccess<IS_ARRAY>::oop_atomic_cmpxchg_at(as_oop(), offs, compare_value, exchange_value);\n+  return HeapAccess<IS_ARRAY>::oop_atomic_cmpxchg_at(as_oop(), offs, (oop)nullptr, exchange_value);\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,1 +93,1 @@\n-  oop atomic_compare_exchange_oop(int index, oop exchange_value, oop compare_value);\n+  oop replace_if_null(int index, oop exchange_value);\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"memory\/iterator.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -297,0 +297,19 @@\n+void Symbol::print_as_field_external_type(outputStream *os) {\n+  SignatureStream ss(this, false);\n+  assert(!ss.is_done(), \"must have at least one element in field ref\");\n+  assert(!ss.at_return_type(), \"field ref cannot be a return type\");\n+  assert(!Signature::is_method(this), \"field ref cannot be a method\");\n+\n+  if (ss.is_array()) {\n+    print_array(os, ss);\n+  } else if (ss.is_reference()) {\n+    print_class(os, ss);\n+  } else {\n+    os->print(\"%s\", type2name(ss.type()));\n+  }\n+#ifdef ASSERT\n+  ss.next();\n+  assert(ss.is_done(), \"must have at most one element in field ref\");\n+#endif\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -278,0 +278,1 @@\n+  void print_as_field_external_type(outputStream *os);\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-class VerifyOopClosure: public OopClosure {\n+class VerifyOopClosure: public BasicOopIterateClosure {\n","filename":"src\/hotspot\/share\/oops\/verifyOopClosure.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -310,0 +310,3 @@\n+    Node* hook = new Node(1);\n+    hook->init_req(0, dest_offset);\n+\n@@ -311,0 +314,3 @@\n+\n+    hook->destruct(phase);\n+\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -374,24 +374,0 @@\n-\/\/=============================================================================\n-\/\/------------------------------Identity---------------------------------------\n-\/\/ If input is already higher or equal to cast type, then this is an identity.\n-Node* CheckCastPPNode::Identity(PhaseGVN* phase) {\n-  Node* dom = dominating_cast(phase, phase);\n-  if (dom != NULL) {\n-    return dom;\n-  }\n-  if (_dependency != RegularDependency) {\n-    return this;\n-  }\n-  const Type* t = phase->type(in(1));\n-  if (EnableVectorReboxing && in(1)->Opcode() == Op_VectorBox) {\n-    if (t->higher_equal_speculative(phase->type(this))) {\n-      return in(1);\n-    }\n-  } else if (t == phase->type(this)) {\n-    \/\/ Toned down to rescue meeting at a Phi 3 different oops all implementing\n-    \/\/ the same interface.\n-    return in(1);\n-  }\n-  return this;\n-}\n-\n@@ -406,2 +382,6 @@\n-  const TypePtr *in_type   = inn->isa_ptr();\n-  const TypePtr *my_type   = _type->isa_ptr();\n+  if (inn->isa_oopptr() && _type->isa_oopptr()) {\n+    return ConstraintCastNode::Value(phase);\n+  }\n+\n+  const TypePtr *in_type = inn->isa_ptr();\n+  const TypePtr *my_type = _type->isa_ptr();\n@@ -409,2 +389,2 @@\n-  if( in_type != NULL && my_type != NULL ) {\n-    TypePtr::PTR   in_ptr    = in_type->ptr();\n+  if (in_type != NULL && my_type != NULL) {\n+    TypePtr::PTR in_ptr = in_type->ptr();\n@@ -413,12 +393,2 @@\n-    } else if (in_ptr == TypePtr::Constant) {\n-      if (my_type->isa_rawptr()) {\n-        result = my_type;\n-      } else {\n-        const TypeOopPtr *jptr = my_type->isa_oopptr();\n-        assert(jptr, \"\");\n-        result = !in_type->higher_equal(_type)\n-          ? my_type->cast_to_ptr_type(TypePtr::NotNull)\n-          : in_type;\n-      }\n-    } else {\n-      result =  my_type->cast_to_ptr_type( my_type->join_ptr(in_ptr) );\n+    } else if (in_ptr != TypePtr::Constant) {\n+      result =  my_type->cast_to_ptr_type(my_type->join_ptr(in_ptr));\n@@ -428,55 +398,1 @@\n-  \/\/ This is the code from TypePtr::xmeet() that prevents us from\n-  \/\/ having 2 ways to represent the same type. We have to replicate it\n-  \/\/ here because we don't go through meet\/join.\n-  if (result->remove_speculative() == result->speculative()) {\n-    result = result->remove_speculative();\n-  }\n-\n-  \/\/ Same as above: because we don't go through meet\/join, remove the\n-  \/\/ speculative type if we know we won't use it.\n-  return result->cleanup_speculative();\n-\n-  \/\/ JOIN NOT DONE HERE BECAUSE OF INTERFACE ISSUES.\n-  \/\/ FIX THIS (DO THE JOIN) WHEN UNION TYPES APPEAR!\n-\n-  \/\/\n-  \/\/ Remove this code after overnight run indicates no performance\n-  \/\/ loss from not performing JOIN at CheckCastPPNode\n-  \/\/\n-  \/\/ const TypeInstPtr *in_oop = in->isa_instptr();\n-  \/\/ const TypeInstPtr *my_oop = _type->isa_instptr();\n-  \/\/ \/\/ If either input is an 'interface', return destination type\n-  \/\/ assert (in_oop == NULL || in_oop->klass() != NULL, \"\");\n-  \/\/ assert (my_oop == NULL || my_oop->klass() != NULL, \"\");\n-  \/\/ if( (in_oop && in_oop->klass()->is_interface())\n-  \/\/   ||(my_oop && my_oop->klass()->is_interface()) ) {\n-  \/\/   TypePtr::PTR  in_ptr = in->isa_ptr() ? in->is_ptr()->_ptr : TypePtr::BotPTR;\n-  \/\/   \/\/ Preserve cast away nullness for interfaces\n-  \/\/   if( in_ptr == TypePtr::NotNull && my_oop && my_oop->_ptr == TypePtr::BotPTR ) {\n-  \/\/     return my_oop->cast_to_ptr_type(TypePtr::NotNull);\n-  \/\/   }\n-  \/\/   return _type;\n-  \/\/ }\n-  \/\/\n-  \/\/ \/\/ Neither the input nor the destination type is an interface,\n-  \/\/\n-  \/\/ \/\/ history: JOIN used to cause weird corner case bugs\n-  \/\/ \/\/          return (in == TypeOopPtr::NULL_PTR) ? in : _type;\n-  \/\/ \/\/ JOIN picks up NotNull in common instance-of\/check-cast idioms, both oops.\n-  \/\/ \/\/ JOIN does not preserve NotNull in other cases, e.g. RawPtr vs InstPtr\n-  \/\/ const Type *join = in->join(_type);\n-  \/\/ \/\/ Check if join preserved NotNull'ness for pointers\n-  \/\/ if( join->isa_ptr() && _type->isa_ptr() ) {\n-  \/\/   TypePtr::PTR join_ptr = join->is_ptr()->_ptr;\n-  \/\/   TypePtr::PTR type_ptr = _type->is_ptr()->_ptr;\n-  \/\/   \/\/ If there isn't any NotNull'ness to preserve\n-  \/\/   \/\/ OR if join preserved NotNull'ness then return it\n-  \/\/   if( type_ptr == TypePtr::BotPTR  || type_ptr == TypePtr::Null ||\n-  \/\/       join_ptr == TypePtr::NotNull || join_ptr == TypePtr::Constant ) {\n-  \/\/     return join;\n-  \/\/   }\n-  \/\/   \/\/ ELSE return same old type as before\n-  \/\/   return _type;\n-  \/\/ }\n-  \/\/ \/\/ Not joining two pointers\n-  \/\/ return join;\n+  return result;\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":11,"deletions":95,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -182,1 +182,0 @@\n-  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1217,16 +1217,0 @@\n-  \/\/ Until we have harmony between classes and interfaces in the type\n-  \/\/ lattice, we must tread carefully around phis which implicitly\n-  \/\/ convert the one to the other.\n-  const TypePtr* ttp = _type->make_ptr();\n-  const TypeInstPtr* ttip = (ttp != NULL) ? ttp->isa_instptr() : NULL;\n-  const TypeInstKlassPtr* ttkp = (ttp != NULL) ? ttp->isa_instklassptr() : NULL;\n-  bool is_intf = false;\n-  if (ttip != NULL) {\n-    if (ttip->is_interface())\n-      is_intf = true;\n-  }\n-  if (ttkp != NULL) {\n-    if (ttkp->is_interface())\n-      is_intf = true;\n-  }\n-\n@@ -1239,14 +1223,0 @@\n-      \/\/ We assume that each input of an interface-valued Phi is a true\n-      \/\/ subtype of that interface.  This might not be true of the meet\n-      \/\/ of all the input types.  The lattice is not distributive in\n-      \/\/ such cases.  Ward off asserts in type.cpp by refusing to do\n-      \/\/ meets between interfaces and proper classes.\n-      const TypePtr* tip = ti->make_ptr();\n-      const TypeInstPtr* tiip = (tip != NULL) ? tip->isa_instptr() : NULL;\n-      if (tiip) {\n-        bool ti_is_intf = false;\n-        if (tiip->is_interface())\n-          ti_is_intf = true;\n-        if (is_intf != ti_is_intf)\n-          { t = _type; break; }\n-      }\n@@ -1276,25 +1246,3 @@\n-\n-    \/\/ Check for evil case of 't' being a class and '_type' expecting an\n-    \/\/ interface.  This can happen because the bytecodes do not contain\n-    \/\/ enough type info to distinguish a Java-level interface variable\n-    \/\/ from a Java-level object variable.  If we meet 2 classes which\n-    \/\/ both implement interface I, but their meet is at 'j\/l\/O' which\n-    \/\/ doesn't implement I, we have no way to tell if the result should\n-    \/\/ be 'I' or 'j\/l\/O'.  Thus we'll pick 'j\/l\/O'.  If this then flows\n-    \/\/ into a Phi which \"knows\" it's an Interface type we'll have to\n-    \/\/ uplift the type.\n-    if (!t->empty() && ttip && ttip->is_interface()) {\n-      assert(ft == _type, \"\"); \/\/ Uplift to interface\n-    } else if (!t->empty() && ttkp && ttkp->is_interface()) {\n-      assert(ft == _type, \"\"); \/\/ Uplift to interface\n-    } else {\n-      \/\/ We also have to handle 'evil cases' of interface- vs. class-arrays\n-      Type::get_arrays_base_elements(jt, _type, NULL, &ttip);\n-      if (!t->empty() && ttip != NULL && ttip->is_interface()) {\n-          assert(ft == _type, \"\");   \/\/ Uplift to array of interface\n-      } else {\n-        \/\/ Otherwise it's something stupid like non-overlapping int ranges\n-        \/\/ found on dying counted loops.\n-        assert(ft == Type::TOP, \"\"); \/\/ Canonical empty value\n-      }\n-    }\n+    \/\/ Otherwise it's something stupid like non-overlapping int ranges\n+    \/\/ found on dying counted loops.\n+    assert(ft == Type::TOP, \"\"); \/\/ Canonical empty value\n@@ -1305,25 +1253,0 @@\n-    \/\/ If we have an interface-typed Phi and we narrow to a class type, the join\n-    \/\/ should report back the class.  However, if we have a J\/L\/Object\n-    \/\/ class-typed Phi and an interface flows in, it's possible that the meet &\n-    \/\/ join report an interface back out.  This isn't possible but happens\n-    \/\/ because the type system doesn't interact well with interfaces.\n-    const TypePtr *jtp = jt->make_ptr();\n-    const TypeInstPtr *jtip = (jtp != NULL) ? jtp->isa_instptr() : NULL;\n-    const TypeInstKlassPtr *jtkp = (jtp != NULL) ? jtp->isa_instklassptr() : NULL;\n-    if (jtip && ttip) {\n-      if (jtip->is_interface() &&\n-          !ttip->is_interface()) {\n-        assert(ft == ttip->cast_to_ptr_type(jtip->ptr()) ||\n-               ft->isa_narrowoop() && ft->make_ptr() == ttip->cast_to_ptr_type(jtip->ptr()), \"\");\n-        jt = ft;\n-      }\n-    }\n-    if (jtkp && ttkp) {\n-      if (jtkp->is_interface() &&\n-          !jtkp->klass_is_exact() && \/\/ Keep exact interface klass (6894807)\n-          ttkp->is_loaded() && !ttkp->is_interface()) {\n-        assert(ft == ttkp->cast_to_ptr_type(jtkp->ptr()) ||\n-               ft->isa_narrowklass() && ft->make_ptr() == ttkp->cast_to_ptr_type(jtkp->ptr()), \"\");\n-        jt = ft;\n-      }\n-    }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":3,"deletions":80,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -4363,2 +4363,2 @@\n-Compile::SubTypeCheckResult Compile::static_subtype_check(const TypeKlassPtr* superk, const TypeKlassPtr* subk) {\n-  if (StressReflectiveCode) {\n+Compile::SubTypeCheckResult Compile::static_subtype_check(const TypeKlassPtr* superk, const TypeKlassPtr* subk, bool skip) {\n+  if (skip) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1177,1 +1177,1 @@\n-  SubTypeCheckResult static_subtype_check(const TypeKlassPtr* superk, const TypeKlassPtr* subk);\n+  SubTypeCheckResult static_subtype_check(const TypeKlassPtr* superk, const TypeKlassPtr* subk, bool skip = StressReflectiveCode);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -600,1 +600,1 @@\n-    Node* cls_node = makecon(TypeKlassPtr::make(receiver_constraint));\n+    Node* cls_node = makecon(TypeKlassPtr::make(receiver_constraint, Type::trust_interfaces));\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1553,1 +1553,2 @@\n-                                bool unsafe) {\n+                                bool unsafe,\n+                                int barrier_data) {\n@@ -1568,0 +1569,1 @@\n+  st->as_Store()->set_barrier_data(barrier_data);\n@@ -2185,1 +2187,1 @@\n-    const TypeKlassPtr* tklass = TypeKlassPtr::make(exact_kls);\n+    const TypeKlassPtr* tklass = TypeKlassPtr::make(exact_kls, Type::trust_interfaces);\n@@ -2639,1 +2641,1 @@\n-  gvn.transform(cmp);\n+  cmp = gvn.transform(cmp);\n@@ -2847,1 +2849,1 @@\n-  const TypeKlassPtr* tklass = TypeKlassPtr::make(klass);\n+  const TypeKlassPtr* tklass = TypeKlassPtr::make(klass, Type::trust_interfaces);\n@@ -2876,1 +2878,1 @@\n-  const TypeKlassPtr* tklass = TypeKlassPtr::make(klass);\n+  const TypeKlassPtr* tklass = TypeKlassPtr::make(klass, Type::trust_interfaces)->try_improve();\n@@ -2999,1 +3001,1 @@\n-        C->static_subtype_check(require_klass, TypeKlassPtr::make(exact_kls)) == Compile::SSC_always_true) {\n+        C->static_subtype_check(require_klass, TypeKlassPtr::make(exact_kls, Type::trust_interfaces)) == Compile::SSC_always_true) {\n@@ -3185,2 +3187,2 @@\n-  const TypeKlassPtr *tk = _gvn.type(superklass)->is_klassptr();\n-  const Type *toop = tk->cast_to_exactness(false)->as_instance_type();\n+  const TypeKlassPtr *tk = _gvn.type(superklass)->is_klassptr()->try_improve();\n+  const TypeOopPtr *toop = tk->cast_to_exactness(false)->as_instance_type();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -571,1 +571,2 @@\n-                        bool unsafe = false) {\n+                        bool unsafe = false,\n+                        int barrier_data = 0) {\n@@ -577,1 +578,2 @@\n-                           unaligned, mismatched, unsafe);\n+                           unaligned, mismatched, unsafe,\n+                           barrier_data);\n@@ -587,1 +589,2 @@\n-                        bool unsafe = false);\n+                        bool unsafe = false,\n+                        int barrier_data = 0);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -503,3 +503,1 @@\n-      if ((toop != NULL && toop->is_interface()) || (tkls != NULL && tkls->is_interface())) {\n-        s2.print(\"  Interface:\");\n-      } else if (toop) {\n+      if (toop) {\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3670,1 +3670,1 @@\n-      int static_res = C->static_subtype_check(TypeKlassPtr::make(tm->as_klass()), tp->as_klass_type());\n+      int static_res = C->static_subtype_check(TypeKlassPtr::make(tm->as_klass(), Type::trust_interfaces), tp->as_klass_type());\n@@ -7238,1 +7238,1 @@\n-  const TypeOopPtr* xtype = aklass->as_instance_type()->cast_to_ptr_type(TypePtr::NotNull);\n+  const TypeOopPtr* xtype = aklass->cast_to_exactness(false)->as_instance_type()->cast_to_ptr_type(TypePtr::NotNull);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4384,0 +4384,13 @@\n+  \/\/ If the store is on the backedge, it is not executed in the last\n+  \/\/ iteration, and we must subtract 1 from the len.\n+  Node* backedge = head->loopexit()->proj_out(1);\n+  if (store->in(0) == backedge) {\n+    len = new SubINode(len, _igvn.intcon(1));\n+    _igvn.register_new_node_with_optimizer(len);\n+#ifndef PRODUCT\n+    if (TraceOptimizeFill) {\n+      tty->print_cr(\"ArrayFill store on backedge, subtract 1 from len.\");\n+    }\n+#endif\n+  }\n+\n@@ -4486,0 +4499,7 @@\n+#ifndef PRODUCT\n+  if (TraceOptimizeFill) {\n+    tty->print(\"ArrayFill call   \");\n+    call->dump();\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1582,0 +1582,3 @@\n+  bool cannot_split_division(const Node* n, const Node* region) const;\n+  static bool is_divisor_counted_loop_phi(const Node* divisor, const Node* loop);\n+  bool loop_phi_backedge_type_contains_zero(const Node* phi_divisor, const Type* zero) const;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,13 +64,2 @@\n-  \/\/ Bail out if 'n' is a Div or Mod node whose zero check was removed earlier (i.e. control is NULL) and its divisor is an induction variable\n-  \/\/ phi p of a trip-counted (integer) loop whose inputs could be zero (include zero in their type range). p could have a more precise type\n-  \/\/ range that does not necessarily include all values of its inputs. Since each of these inputs will be a divisor of the newly cloned nodes\n-  \/\/ of 'n', we need to bail out of one of these divisors could be zero (zero in its type range).\n-  if ((n->Opcode() == Op_DivI || n->Opcode() == Op_ModI) && n->in(0) == NULL\n-      && region->is_CountedLoop() && n->in(2) == region->as_CountedLoop()->phi()) {\n-    Node* phi = region->as_CountedLoop()->phi();\n-    for (uint i = 1; i < phi->req(); i++) {\n-      if (_igvn.type(phi->in(i))->filter_speculative(TypeInt::ZERO) != Type::TOP) {\n-        \/\/ Zero could be a possible value but we already removed the zero check. Bail out to avoid a possible division by zero at a later point.\n-        return NULL;\n-      }\n-    }\n+  if (cannot_split_division(n, region)) {\n+    return NULL;\n@@ -228,0 +217,36 @@\n+\/\/ Return true if 'n' is a Div or Mod node (without zero check If node which was removed earlier) with a loop phi divisor\n+\/\/ of a trip-counted (integer or long) loop with a backedge input that could be zero (include zero in its type range). In\n+\/\/ this case, we cannot split the division to the backedge as it could freely float above the loop exit check resulting in\n+\/\/ a division by zero. This situation is possible because the type of an increment node of an iv phi (trip-counter) could\n+\/\/ include zero while the iv phi does not (see PhiNode::Value() for trip-counted loops where we improve types of iv phis).\n+\/\/ We also need to check other loop phis as they could have been created in the same split-if pass when applying\n+\/\/ PhaseIdealLoop::split_thru_phi() to split nodes through an iv phi.\n+bool PhaseIdealLoop::cannot_split_division(const Node* n, const Node* region) const {\n+  const Type* zero;\n+  switch (n->Opcode()) {\n+    case Op_DivI:\n+    case Op_ModI:\n+      zero = TypeInt::ZERO;\n+      break;\n+    case Op_DivL:\n+    case Op_ModL:\n+      zero = TypeLong::ZERO;\n+      break;\n+    default:\n+      return false;\n+  }\n+\n+  assert(n->in(0) == NULL, \"divisions with zero check should already have bailed out earlier in split-if\");\n+  Node* divisor = n->in(2);\n+  return is_divisor_counted_loop_phi(divisor, region) &&\n+         loop_phi_backedge_type_contains_zero(divisor, zero);\n+}\n+\n+bool PhaseIdealLoop::is_divisor_counted_loop_phi(const Node* divisor, const Node* loop) {\n+  return loop->is_BaseCountedLoop() && divisor->is_Phi() && divisor->in(0) == loop;\n+}\n+\n+bool PhaseIdealLoop::loop_phi_backedge_type_contains_zero(const Node* phi_divisor, const Type* zero) const {\n+    return _igvn.type(phi_divisor->in(LoopNode::LoopBackControl))->filter_speculative(zero) != Type::TOP;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":39,"deletions":14,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2030,1 +2030,1 @@\n-  if (tkls != NULL && !StressReflectiveCode) {\n+  if (tkls != NULL) {\n@@ -2050,1 +2050,1 @@\n-        return ss ? TypeKlassPtr::make(ss) : TypePtr::NULL_PTR;\n+        return ss ? TypeKlassPtr::make(ss, Type::trust_interfaces) : TypePtr::NULL_PTR;\n@@ -2081,1 +2081,1 @@\n-          return ss ? TypeKlassPtr::make(ss) : TypePtr::NULL_PTR;\n+          return ss ? TypeKlassPtr::make(ss, Type::trust_interfaces) : TypePtr::NULL_PTR;\n@@ -2341,1 +2341,1 @@\n-          return TypeKlassPtr::make(ciArrayKlass::make(t));\n+          return TypeKlassPtr::make(ciArrayKlass::make(t), Type::trust_interfaces);\n@@ -2348,1 +2348,1 @@\n-        return TypeKlassPtr::make(t->as_klass());\n+        return TypeKlassPtr::make(t->as_klass(), Type::trust_interfaces);\n@@ -2386,1 +2386,1 @@\n-      return sup ? TypeKlassPtr::make(sup) : TypePtr::NULL_PTR;\n+      return sup ? TypeKlassPtr::make(sup, Type::trust_interfaces) : TypePtr::NULL_PTR;\n@@ -4007,0 +4007,1 @@\n+  BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n@@ -4010,0 +4011,1 @@\n+  bs->eliminate_gc_barrier_data(new_st);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -737,1 +737,0 @@\n-  dump();\n@@ -2546,4 +2545,1 @@\n-    ciKlass*           klass = toop ? toop->instance_klass() : (tkls ? tkls->instance_klass() : NULL );\n-    if (klass && klass->is_loaded() && ((toop && toop->is_interface()) || (tkls && tkls->is_interface()))) {\n-      st->print(\"  Interface:\");\n-    } else if (toop) {\n+    if (toop) {\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1200,1 +1200,1 @@\n-    const Type* holder_type = TypeInstPtr::make(TypePtr::BotPTR, callee_holder);\n+    const Type* holder_type = TypeInstPtr::make(TypePtr::BotPTR, callee_holder, Type::trust_interfaces);\n@@ -1213,1 +1213,1 @@\n-      Node* holder_klass = _gvn.makecon(TypeKlassPtr::make(callee_holder));\n+      Node* holder_klass = _gvn.makecon(TypeKlassPtr::make(callee_holder, Type::trust_interfaces));\n@@ -2133,1 +2133,1 @@\n-  Node* holder = makecon(TypeKlassPtr::make(method()->holder()));\n+  Node* holder = makecon(TypeKlassPtr::make(method()->holder(), Type::trust_interfaces));\n@@ -2212,21 +2212,0 @@\n-    const TypeInstPtr *tr = phi->bottom_type()->isa_instptr();\n-    if (tr && tr->is_loaded() &&\n-        tr->is_interface()) {\n-      const TypeInstPtr *tp = value->bottom_type()->isa_instptr();\n-      if (tp && tp->is_loaded() &&\n-          !tp->is_interface()) {\n-        \/\/ sharpen the type eagerly; this eases certain assert checking\n-        if (tp->higher_equal(TypeInstPtr::NOTNULL))\n-          tr = tr->join_speculative(TypeInstPtr::NOTNULL)->is_instptr();\n-        value = _gvn.transform(new CheckCastPPNode(0, value, tr));\n-      }\n-    } else {\n-      \/\/ Also handle returns of oop-arrays to an arrays-of-interface return\n-      const TypeInstPtr* phi_tip;\n-      const TypeInstPtr* val_tip;\n-      Type::get_arrays_base_elements(phi->bottom_type(), value->bottom_type(), &phi_tip, &val_tip);\n-      if (phi_tip != NULL && phi_tip->is_loaded() && phi_tip->is_interface() &&\n-          val_tip != NULL && val_tip->is_loaded() && !val_tip->is_interface()) {\n-        value = _gvn.transform(new CheckCastPPNode(0, value, phi->bottom_type()));\n-      }\n-    }\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":3,"deletions":24,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-  const TypeKlassPtr* array_klass_type = TypeKlassPtr::make(array_klass);\n+  const TypeKlassPtr* array_klass_type = TypeKlassPtr::make(array_klass, Type::trust_interfaces);\n@@ -302,1 +302,1 @@\n-  Node* array = new_array(makecon(TypeKlassPtr::make(array_klass)), length, nargs);\n+  Node* array = new_array(makecon(TypeKlassPtr::make(array_klass, Type::trust_interfaces)), length, nargs);\n@@ -388,1 +388,1 @@\n-                          makecon(TypeKlassPtr::make(array_klass)),\n+                          makecon(TypeKlassPtr::make(array_klass, Type::trust_interfaces)),\n@@ -410,1 +410,1 @@\n-                          makecon(TypeKlassPtr::make(array_klass)),\n+                          makecon(TypeKlassPtr::make(array_klass, Type::trust_interfaces)),\n@@ -417,1 +417,1 @@\n-  const Type* type = TypeOopPtr::make_from_klass_raw(array_klass);\n+  const Type* type = TypeOopPtr::make_from_klass_raw(array_klass, Type::trust_interfaces);\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-  Node* res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass)));\n+  Node* res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass, Type::trust_interfaces)));\n@@ -132,1 +132,1 @@\n-  Node* res = gen_instanceof(peek(), makecon(TypeKlassPtr::make(klass)), true);\n+  Node* res = gen_instanceof(peek(), makecon(TypeKlassPtr::make(klass, Type::trust_interfaces)), true);\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1083,1 +1083,1 @@\n-  return phase->makecon(TypeKlassPtr::make(mirror_type->as_klass()));\n+  return phase->makecon(TypeKlassPtr::make(mirror_type->as_klass(), Type::trust_interfaces));\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-    switch (Compile::current()->static_subtype_check(superk, subk)) {\n+    switch (Compile::current()->static_subtype_check(superk, subk, false)) {\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,0 +123,2 @@\n+const TypePtr::InterfaceSet* TypeAryPtr::_array_interfaces = NULL;\n+const TypePtr::InterfaceSet* TypeAryKlassPtr::_array_interfaces = NULL;\n@@ -137,1 +139,1 @@\n-const Type* Type::get_const_type(ciType* type) {\n+const Type* Type::get_const_type(ciType* type, InterfaceHandling interface_handling) {\n@@ -143,1 +145,1 @@\n-    return TypeOopPtr::make_from_klass(type->as_klass());\n+    return TypeOopPtr::make_from_klass(type->as_klass(), interface_handling);\n@@ -569,0 +571,6 @@\n+  GrowableArray<ciInstanceKlass*> array_interfaces;\n+  array_interfaces.push(current->env()->Cloneable_klass());\n+  array_interfaces.push(current->env()->Serializable_klass());\n+  TypeAryPtr::_array_interfaces = new TypePtr::InterfaceSet(&array_interfaces);\n+  TypeAryKlassPtr::_array_interfaces = TypeAryPtr::_array_interfaces;\n+\n@@ -781,45 +789,0 @@\n-\/\/----------------------interface_vs_oop---------------------------------------\n-#ifdef ASSERT\n-bool Type::interface_vs_oop_helper(const Type *t) const {\n-  bool result = false;\n-\n-  const TypePtr* this_ptr = this->make_ptr(); \/\/ In case it is narrow_oop\n-  const TypePtr*    t_ptr =    t->make_ptr();\n-  if( this_ptr == NULL || t_ptr == NULL )\n-    return result;\n-\n-  const TypeInstPtr* this_inst = this_ptr->isa_instptr();\n-  const TypeInstPtr*    t_inst =    t_ptr->isa_instptr();\n-  if( this_inst && this_inst->is_loaded() && t_inst && t_inst->is_loaded() ) {\n-    bool this_interface = this_inst->is_interface();\n-    bool    t_interface =    t_inst->is_interface();\n-    result = this_interface ^ t_interface;\n-  }\n-\n-  return result;\n-}\n-\n-bool Type::interface_vs_oop(const Type *t) const {\n-  if (interface_vs_oop_helper(t)) {\n-    return true;\n-  }\n-  \/\/ Now check the speculative parts as well\n-  const TypePtr* this_spec = isa_ptr() != NULL ? is_ptr()->speculative() : NULL;\n-  const TypePtr* t_spec = t->isa_ptr() != NULL ? t->is_ptr()->speculative() : NULL;\n-  if (this_spec != NULL && t_spec != NULL) {\n-    if (this_spec->interface_vs_oop_helper(t_spec)) {\n-      return true;\n-    }\n-    return false;\n-  }\n-  if (this_spec != NULL && this_spec->interface_vs_oop_helper(t)) {\n-    return true;\n-  }\n-  if (t_spec != NULL && interface_vs_oop_helper(t_spec)) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n-#endif\n-\n@@ -845,1 +808,1 @@\n-  if (!interface_vs_oop(t) && (t2t != t->_dual || t2this != this->_dual)) {\n+  if (t2t != t->_dual || t2this != this->_dual) {\n@@ -2023,1 +1986,1 @@\n-const TypeTuple *TypeTuple::make_range(ciSignature* sig) {\n+const TypeTuple *TypeTuple::make_range(ciSignature* sig, InterfaceHandling interface_handling) {\n@@ -2044,1 +2007,1 @@\n-    field_array[TypeFunc::Parms] = get_const_type(return_type);\n+    field_array[TypeFunc::Parms] = get_const_type(return_type, interface_handling);\n@@ -2055,1 +2018,1 @@\n-const TypeTuple *TypeTuple::make_domain(ciInstanceKlass* recv, ciSignature* sig) {\n+const TypeTuple *TypeTuple::make_domain(ciInstanceKlass* recv, ciSignature* sig, InterfaceHandling interface_handling) {\n@@ -2064,1 +2027,1 @@\n-    field_array[pos++] = get_const_type(recv)->join_speculative(TypePtr::NOTNULL);\n+    field_array[pos++] = get_const_type(recv, interface_handling)->join_speculative(TypePtr::NOTNULL);\n@@ -2086,1 +2049,1 @@\n-      field_array[pos++] = get_const_type(type);\n+      field_array[pos++] = get_const_type(type, interface_handling);\n@@ -2317,15 +2280,0 @@\n-\/\/----------------------interface_vs_oop---------------------------------------\n-#ifdef ASSERT\n-bool TypeAry::interface_vs_oop(const Type *t) const {\n-  const TypeAry* t_ary = t->is_ary();\n-  if (t_ary) {\n-    const TypePtr* this_ptr = _elem->make_ptr(); \/\/ In case we have narrow_oops\n-    const TypePtr*    t_ptr = t_ary->_elem->make_ptr();\n-    if(this_ptr != NULL && t_ptr != NULL) {\n-      return this_ptr->interface_vs_oop(t_ptr);\n-    }\n-  }\n-  return false;\n-}\n-#endif\n-\n@@ -2369,3 +2317,1 @@\n-  ciKlass* tklass = toop->klass();\n-  if (tklass == NULL)       return false;  \/\/ unloaded class\n-  if (!tklass->is_loaded()) return false;  \/\/ unloaded class\n+  if (!toop->is_loaded())   return false;  \/\/ unloaded class\n@@ -2378,1 +2324,1 @@\n-    return tklass->as_instance_klass()->is_final();\n+    return tinst->instance_klass()->is_final();\n@@ -3170,0 +3116,229 @@\n+TypePtr::InterfaceSet::InterfaceSet()\n+        : _list(Compile::current()->type_arena(), 0, 0, NULL),\n+          _hash_computed(0), _exact_klass_computed(0), _is_loaded_computed(0) {\n+}\n+\n+TypePtr::InterfaceSet::InterfaceSet(GrowableArray<ciInstanceKlass*>* interfaces)\n+        : _list(Compile::current()->type_arena(), interfaces->length(), 0, NULL),\n+          _hash_computed(0), _exact_klass_computed(0), _is_loaded_computed(0) {\n+  for (int i = 0; i < interfaces->length(); i++) {\n+    add(interfaces->at(i));\n+  }\n+}\n+\n+\n+int TypePtr::InterfaceSet::compare(ciKlass* const& k1, ciKlass* const& k2) {\n+  if ((intptr_t)k1 < (intptr_t)k2) {\n+    return -1;\n+  } else if ((intptr_t)k1 > (intptr_t)k2) {\n+    return 1;\n+  }\n+  return 0;\n+}\n+\n+void TypePtr::InterfaceSet::add(ciKlass* interface) {\n+  assert(interface->is_interface(), \"for interfaces only\");\n+  _list.insert_sorted<compare>(interface);\n+  verify();\n+}\n+\n+void TypePtr::InterfaceSet::raw_add(ciKlass* interface) {\n+  assert(interface->is_interface(), \"for interfaces only\");\n+  _list.push(interface);\n+}\n+\n+bool TypePtr::InterfaceSet::eq(const InterfaceSet& other) const {\n+  if (_list.length() != other._list.length()) {\n+    return false;\n+  }\n+  for (int i = 0; i < _list.length(); i++) {\n+    ciKlass* k1 = _list.at(i);\n+    ciKlass* k2 = other._list.at(i);\n+    if (!k1->equals(k2)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+int TypePtr::InterfaceSet::hash() const {\n+  if (_hash_computed) {\n+    return _hash;\n+  }\n+  const_cast<InterfaceSet*>(this)->compute_hash();\n+  assert(_hash_computed, \"should be computed now\");\n+  return _hash;\n+}\n+\n+void TypePtr::InterfaceSet::compute_hash() {\n+  int hash = 0;\n+  for (int i = 0; i < _list.length(); i++) {\n+    ciKlass* k = _list.at(i);\n+    hash += (jint)k->hash();\n+  }\n+  _hash_computed = 1;\n+  _hash = hash;\n+}\n+\n+static int compare_interfaces(ciKlass** k1, ciKlass** k2) {\n+  return (int)((*k1)->ident() - (*k2)->ident());\n+}\n+\n+void TypePtr::InterfaceSet::dump(outputStream *st) const {\n+  if (_list.length() == 0) {\n+    return;\n+  }\n+  ResourceMark rm;\n+  st->print(\" (\");\n+  GrowableArray<ciKlass*> interfaces;\n+  interfaces.appendAll(&_list);\n+  \/\/ Sort the interfaces so they are listed in the same order from one run to the other of the same compilation\n+  interfaces.sort(compare_interfaces);\n+  for (int i = 0; i < interfaces.length(); i++) {\n+    if (i > 0) {\n+      st->print(\",\");\n+    }\n+    ciKlass* k = interfaces.at(i);\n+    k->print_name_on(st);\n+  }\n+  st->print(\")\");\n+}\n+\n+void TypePtr::InterfaceSet::verify() const {\n+#ifdef DEBUG\n+  for (int i = 1; i < _list.length(); i++) {\n+    ciKlass* k1 = _list.at(i-1);\n+    ciKlass* k2 = _list.at(i);\n+    assert(compare(k2, k1) > 0, \"should be ordered\");\n+    assert(k1 != k2, \"no duplicate\");\n+  }\n+#endif\n+}\n+\n+TypePtr::InterfaceSet TypeOopPtr::InterfaceSet::union_with(const InterfaceSet& other) const {\n+  InterfaceSet result;\n+  int i = 0;\n+  int j = 0;\n+  while (i < _list.length() || j < other._list.length()) {\n+    while (i < _list.length() &&\n+           (j >= other._list.length() ||\n+            compare(_list.at(i), other._list.at(j)) < 0)) {\n+      result.raw_add(_list.at(i));\n+      i++;\n+    }\n+    while (j < other._list.length() &&\n+           (i >= _list.length() ||\n+            compare(other._list.at(j), _list.at(i)) < 0)) {\n+      result.raw_add(other._list.at(j));\n+      j++;\n+    }\n+    if (i < _list.length() &&\n+        j < other._list.length() &&\n+        _list.at(i) == other._list.at(j)) {\n+      result.raw_add(_list.at(i));\n+      i++;\n+      j++;\n+    }\n+  }\n+  result.verify();\n+#ifdef DEBUG\n+  for (int i = 0; i < _list.length(); i++) {\n+    assert(result.contains(_list.at(i)), \"missing\");\n+  }\n+  for (int i = 0; i < other._list.length(); i++) {\n+    assert(result.contains(other._list.at(i)), \"missing\");\n+  }\n+  for (int i = 0; i < result._list.length(); i++) {\n+    assert(_list.contains(result._list.at(i)) || other._list.contains(result._list.at(i)), \"missing\");\n+  }\n+#endif\n+  return result;\n+}\n+\n+TypePtr::InterfaceSet TypeOopPtr::InterfaceSet::intersection_with(const InterfaceSet& other) const {\n+  InterfaceSet result;\n+  int i = 0;\n+  int j = 0;\n+  while (i < _list.length() || j < other._list.length()) {\n+    while (i < _list.length() &&\n+           (j >= other._list.length() ||\n+            compare(_list.at(i), other._list.at(j)) < 0)) {\n+      i++;\n+    }\n+    while (j < other._list.length() &&\n+           (i >= _list.length() ||\n+            compare(other._list.at(j), _list.at(i)) < 0)) {\n+      j++;\n+    }\n+    if (i < _list.length() &&\n+        j < other._list.length() &&\n+        _list.at(i) == other._list.at(j)) {\n+      result.raw_add(_list.at(i));\n+      i++;\n+      j++;\n+    }\n+  }\n+  result.verify();\n+#ifdef DEBUG\n+  for (int i = 0; i < _list.length(); i++) {\n+    assert(!other._list.contains(_list.at(i)) || result.contains(_list.at(i)), \"missing\");\n+  }\n+  for (int i = 0; i < other._list.length(); i++) {\n+    assert(!_list.contains(other._list.at(i)) || result.contains(other._list.at(i)), \"missing\");\n+  }\n+  for (int i = 0; i < result._list.length(); i++) {\n+    assert(_list.contains(result._list.at(i)) && other._list.contains(result._list.at(i)), \"missing\");\n+  }\n+#endif\n+  return result;\n+}\n+\n+\/\/ Is there a single ciKlass* that can represent the interface set?\n+ciKlass* TypePtr::InterfaceSet::exact_klass() const {\n+  if (_exact_klass_computed) {\n+    return _exact_klass;\n+  }\n+  const_cast<InterfaceSet*>(this)->compute_exact_klass();\n+  assert(_exact_klass_computed, \"should be computed now\");\n+  return _exact_klass;\n+}\n+\n+void TypePtr::InterfaceSet::compute_exact_klass() {\n+  if (_list.length() == 0) {\n+    _exact_klass_computed = 1;\n+    _exact_klass = NULL;\n+    return;\n+  }\n+  ciKlass* res = NULL;\n+  for (int i = 0; i < _list.length(); i++) {\n+    ciKlass* interface = _list.at(i);\n+    if (eq(interfaces(interface, false, true, false, trust_interfaces))) {\n+      assert(res == NULL, \"\");\n+      res = _list.at(i);\n+    }\n+  }\n+  _exact_klass_computed = 1;\n+  _exact_klass = res;\n+}\n+\n+bool TypePtr::InterfaceSet::is_loaded() const {\n+  if (_is_loaded_computed) {\n+    return _is_loaded;\n+  }\n+  const_cast<InterfaceSet*>(this)->compute_is_loaded();\n+  assert(_is_loaded_computed, \"should be computed now\");\n+  return _is_loaded;\n+}\n+\n+void TypePtr::InterfaceSet::compute_is_loaded() {\n+  _is_loaded_computed = 1;\n+  for (int i = 0; i < _list.length(); i++) {\n+    ciKlass* interface = _list.at(i);\n+    if (!interface->is_loaded()) {\n+      _is_loaded = false;\n+      return;\n+    }\n+  }\n+  _is_loaded = true;\n+}\n+\n@@ -3171,1 +3346,1 @@\n-TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,\n+TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int offset,\n@@ -3175,0 +3350,1 @@\n+    _interfaces(interfaces),\n@@ -3222,1 +3398,1 @@\n-            _is_ptr_to_narrowoop = UseCompressedOops && is_reference_type(basic_elem_type);\n+            _is_ptr_to_narrowoop = UseCompressedOops && ::is_reference_type(basic_elem_type);\n@@ -3232,1 +3408,1 @@\n-            _is_ptr_to_narrowoop = UseCompressedOops && is_reference_type(basic_elem_type);\n+            _is_ptr_to_narrowoop = UseCompressedOops && ::is_reference_type(basic_elem_type);\n@@ -3255,1 +3431,1 @@\n-  return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, instance_id, speculative, inline_depth))->hashcons();\n+  return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, InterfaceSet(), xk, o, offset, instance_id, speculative, inline_depth))->hashcons();\n@@ -3368,1 +3544,1 @@\n-  return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n+  return new TypeOopPtr(_base, dual_ptr(), klass(), _interfaces, klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n@@ -3373,1 +3549,1 @@\n-const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {\n+const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact, InterfaceHandling interface_handling) {\n@@ -3400,1 +3576,2 @@\n-    return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, 0);\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n+    return TypeInstPtr::make(TypePtr::BotPTR, klass, interfaces, klass_is_exact, NULL, 0);\n@@ -3403,1 +3580,2 @@\n-    const TypeOopPtr *etype = TypeOopPtr::make_from_klass_common(klass->as_obj_array_klass()->element_klass(), false, try_for_exact);\n+    ciKlass* eklass = klass->as_obj_array_klass()->element_klass();\n+    const TypeOopPtr *etype = TypeOopPtr::make_from_klass_common(eklass, false, try_for_exact, interface_handling);\n@@ -3409,1 +3587,1 @@\n-    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, 0);\n+    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, NULL, xk, 0);\n@@ -3443,1 +3621,1 @@\n-      TypeOopPtr::make_from_klass_raw(klass->as_obj_array_klass()->element_klass());\n+      TypeOopPtr::make_from_klass_raw(klass->as_obj_array_klass()->element_klass(), trust_interfaces);\n@@ -3501,21 +3679,0 @@\n-    \/\/ Check for evil case of 'this' being a class and 'kills' expecting an\n-    \/\/ interface.  This can happen because the bytecodes do not contain\n-    \/\/ enough type info to distinguish a Java-level interface variable\n-    \/\/ from a Java-level object variable.  If we meet 2 classes which\n-    \/\/ both implement interface I, but their meet is at 'j\/l\/O' which\n-    \/\/ doesn't implement I, we have no way to tell if the result should\n-    \/\/ be 'I' or 'j\/l\/O'.  Thus we'll pick 'j\/l\/O'.  If this then flows\n-    \/\/ into a Phi which \"knows\" it's an Interface type we'll have to\n-    \/\/ uplift the type.\n-    if (!empty()) {\n-      if (ktip != NULL && ktip->is_loaded() && ktip->klass()->is_interface()) {\n-        return kills;           \/\/ Uplift to interface\n-      }\n-      \/\/ Also check for evil cases of 'this' being a class array\n-      \/\/ and 'kills' expecting an array of interfaces.\n-      Type::get_arrays_base_elements(ft, kills, NULL, &ktip);\n-      if (ktip != NULL && ktip->is_loaded() && ktip->klass()->is_interface()) {\n-        return kills;           \/\/ Uplift to array of interface\n-      }\n-    }\n-\n@@ -3525,12 +3682,0 @@\n-  \/\/ If we have an interface-typed Phi or cast and we narrow to a class type,\n-  \/\/ the join should report back the class.  However, if we have a J\/L\/Object\n-  \/\/ class-typed Phi and an interface flows in, it's possible that the meet &\n-  \/\/ join report an interface back out.  This isn't possible but happens\n-  \/\/ because the type system doesn't interact well with interfaces.\n-  if (ftip != NULL && ktip != NULL &&\n-      ftip->is_loaded() &&  ftip->klass()->is_interface() &&\n-      ktip->is_loaded() && !ktip->klass()->is_interface()) {\n-    assert(!ftip->klass_is_exact(), \"interface could not be exact\");\n-    return ktip->cast_to_ptr_type(ftip->ptr());\n-  }\n-\n@@ -3595,1 +3740,1 @@\n-const TypePtr *TypeOopPtr::add_offset(intptr_t offset) const {\n+const TypePtr* TypeOopPtr::add_offset(intptr_t offset) const {\n@@ -3662,0 +3807,12 @@\n+\n+TypePtr::InterfaceSet TypeOopPtr::meet_interfaces(const TypeOopPtr* other) const {\n+  if (above_centerline(_ptr) && above_centerline(other->_ptr)) {\n+    return _interfaces.union_with(other->_interfaces);\n+  } else if (above_centerline(_ptr) && !above_centerline(other->_ptr)) {\n+    return other->_interfaces;\n+  } else if (above_centerline(other->_ptr) && !above_centerline(_ptr)) {\n+    return _interfaces;\n+  }\n+  return _interfaces.intersection_with(other->_interfaces);\n+}\n+\n@@ -3686,0 +3843,1 @@\n+\/\/ Is there a single ciKlass* that can represent that type?\n@@ -3687,1 +3845,12 @@\n-  return _klass;\n+  if (_interfaces.empty()) {\n+    return _klass;\n+  }\n+  if (_klass != ciEnv::current()->Object_klass()) {\n+    ciKlass* k = _klass;\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    if (_interfaces.eq(interfaces)) {\n+      return _klass;\n+    }\n+    return NULL;\n+  }\n+  return _interfaces.exact_klass();\n@@ -3691,1 +3860,1 @@\n-TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int off,\n+TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int off,\n@@ -3693,4 +3862,5 @@\n-  : TypeOopPtr(InstPtr, ptr, k, xk, o, off, instance_id, speculative, inline_depth) {\n-   assert(k != NULL &&\n-          (k->is_loaded() || o == NULL),\n-          \"cannot have constants with non-loaded klass\");\n+  : TypeOopPtr(InstPtr, ptr, k, interfaces, xk, o, off, instance_id, speculative, inline_depth) {\n+  assert(k == NULL || !k->is_loaded() || !k->is_interface(), \"no interface here\");\n+  assert(k != NULL &&\n+         (k->is_loaded() || o == NULL),\n+         \"cannot have constants with non-loaded klass\");\n@@ -3702,0 +3872,1 @@\n+                                     const InterfaceSet& interfaces,\n@@ -3722,0 +3893,1 @@\n+    assert(!ik->is_interface(), \"no interface here\");\n@@ -3727,1 +3899,1 @@\n-    (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o ,offset, instance_id, speculative, inline_depth))->hashcons();\n+    (TypeInstPtr*)(new TypeInstPtr(ptr, k, interfaces, xk, o ,offset, instance_id, speculative, inline_depth))->hashcons();\n@@ -3732,0 +3904,33 @@\n+TypePtr::InterfaceSet TypePtr::interfaces(ciKlass*& k, bool klass, bool interface, bool array, InterfaceHandling interface_handling) {\n+  if (k->is_instance_klass()) {\n+    if (k->is_loaded()) {\n+      if (k->is_interface() && interface_handling == ignore_interfaces) {\n+        assert(interface, \"no interface expected\");\n+        k = ciEnv::current()->Object_klass();\n+        InterfaceSet interfaces;\n+        return interfaces;\n+      }\n+      GrowableArray<ciInstanceKlass *> *k_interfaces = k->as_instance_klass()->transitive_interfaces();\n+      InterfaceSet interfaces(k_interfaces);\n+      if (k->is_interface()) {\n+        assert(interface, \"no interface expected\");\n+        k = ciEnv::current()->Object_klass();\n+      } else {\n+        assert(klass, \"no instance klass expected\");\n+      }\n+      return interfaces;\n+    }\n+    InterfaceSet interfaces;\n+    return interfaces;\n+  }\n+  assert(array, \"no array expected\");\n+  assert(k->is_array_klass(), \"Not an array?\");\n+  ciType* e = k->as_array_klass()->base_element_type();\n+  if (e->is_loaded() && e->is_instance_klass() && e->as_instance_klass()->is_interface()) {\n+    if (interface_handling == ignore_interfaces) {\n+      k = ciObjArrayKlass::make(ciEnv::current()->Object_klass(), k->as_array_klass()->dimension());\n+    }\n+  }\n+  return *TypeAryPtr::_array_interfaces;\n+}\n+\n@@ -3760,1 +3965,1 @@\n-  return make(ptr, klass(), klass_is_exact(), ptr == Constant ? const_oop() : NULL, _offset, _instance_id, _speculative, _inline_depth);\n+  return make(ptr, klass(), _interfaces, klass_is_exact(), ptr == Constant ? const_oop() : NULL, _offset, _instance_id, _speculative, _inline_depth);\n@@ -3770,2 +3975,2 @@\n-  if( ik->is_interface() )              return this;  \/\/ cannot set xk\n-  return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _instance_id, _speculative, _inline_depth);\n+  assert(!ik->is_interface(), \"no interface here\");\n+  return make(ptr(), klass(), _interfaces, klass_is_exact, const_oop(), _offset, _instance_id, _speculative, _inline_depth);\n@@ -3777,1 +3982,1 @@\n-  return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, instance_id, _speculative, _inline_depth);\n+  return make(_ptr, klass(),  _interfaces, _klass_is_exact, const_oop(), _offset, instance_id, _speculative, _inline_depth);\n@@ -3783,35 +3988,31 @@\n-const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {\n-    int off = meet_offset(tinst->offset());\n-    PTR ptr = meet_ptr(tinst->ptr());\n-    int instance_id = meet_instance_id(tinst->instance_id());\n-    const TypePtr* speculative = xmeet_speculative(tinst);\n-    int depth = meet_inline_depth(tinst->inline_depth());\n-\n-    const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;\n-    const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;\n-    if( loaded->klass()->equals(ciEnv::current()->Object_klass()) ) {\n-      \/\/\n-      \/\/ Meet unloaded class with java\/lang\/Object\n-      \/\/\n-      \/\/ Meet\n-      \/\/          |                     Unloaded Class\n-      \/\/  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |\n-      \/\/  ===================================================================\n-      \/\/   TOP    | ..........................Unloaded......................|\n-      \/\/  AnyNull |  U-AN    |................Unloaded......................|\n-      \/\/ Constant | ... O-NN .................................. |   O-BOT   |\n-      \/\/  NotNull | ... O-NN .................................. |   O-BOT   |\n-      \/\/  BOTTOM  | ........................Object-BOTTOM ..................|\n-      \/\/\n-      assert(loaded->ptr() != TypePtr::Null, \"insanity check\");\n-      \/\/\n-      if(      loaded->ptr() == TypePtr::TopPTR ) { return unloaded; }\n-      else if (loaded->ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded->klass(), false, NULL, off, instance_id, speculative, depth); }\n-      else if (loaded->ptr() == TypePtr::BotPTR ) { return TypeInstPtr::BOTTOM; }\n-      else if (loaded->ptr() == TypePtr::Constant || loaded->ptr() == TypePtr::NotNull) {\n-        if (unloaded->ptr() == TypePtr::BotPTR  ) { return TypeInstPtr::BOTTOM;  }\n-        else                                      { return TypeInstPtr::NOTNULL; }\n-      }\n-      else if( unloaded->ptr() == TypePtr::TopPTR )  { return unloaded; }\n-\n-      return unloaded->cast_to_ptr_type(TypePtr::AnyNull)->is_instptr();\n+const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst, const InterfaceSet& interfaces) const {\n+  int off = meet_offset(tinst->offset());\n+  PTR ptr = meet_ptr(tinst->ptr());\n+  int instance_id = meet_instance_id(tinst->instance_id());\n+  const TypePtr* speculative = xmeet_speculative(tinst);\n+  int depth = meet_inline_depth(tinst->inline_depth());\n+\n+  const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;\n+  const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;\n+  if( loaded->klass()->equals(ciEnv::current()->Object_klass()) ) {\n+    \/\/\n+    \/\/ Meet unloaded class with java\/lang\/Object\n+    \/\/\n+    \/\/ Meet\n+    \/\/          |                     Unloaded Class\n+    \/\/  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |\n+    \/\/  ===================================================================\n+    \/\/   TOP    | ..........................Unloaded......................|\n+    \/\/  AnyNull |  U-AN    |................Unloaded......................|\n+    \/\/ Constant | ... O-NN .................................. |   O-BOT   |\n+    \/\/  NotNull | ... O-NN .................................. |   O-BOT   |\n+    \/\/  BOTTOM  | ........................Object-BOTTOM ..................|\n+    \/\/\n+    assert(loaded->ptr() != TypePtr::Null, \"insanity check\");\n+    \/\/\n+    if (loaded->ptr() == TypePtr::TopPTR)        { return unloaded; }\n+    else if (loaded->ptr() == TypePtr::AnyNull)  { return make(ptr, unloaded->klass(), interfaces, false, NULL, off, instance_id, speculative, depth); }\n+    else if (loaded->ptr() == TypePtr::BotPTR)   { return TypeInstPtr::BOTTOM; }\n+    else if (loaded->ptr() == TypePtr::Constant || loaded->ptr() == TypePtr::NotNull) {\n+      if (unloaded->ptr() == TypePtr::BotPTR)    { return TypeInstPtr::BOTTOM;  }\n+      else                                       { return TypeInstPtr::NOTNULL; }\n@@ -3819,0 +4020,1 @@\n+    else if (unloaded->ptr() == TypePtr::TopPTR) { return unloaded; }\n@@ -3820,6 +4022,9 @@\n-    \/\/ Both are unloaded, not the same class, not Object\n-    \/\/ Or meet unloaded with a different loaded class, not java\/lang\/Object\n-    if( ptr != TypePtr::BotPTR ) {\n-      return TypeInstPtr::NOTNULL;\n-    }\n-    return TypeInstPtr::BOTTOM;\n+    return unloaded->cast_to_ptr_type(TypePtr::AnyNull)->is_instptr();\n+  }\n+\n+  \/\/ Both are unloaded, not the same class, not Object\n+  \/\/ Or meet unloaded with a different loaded class, not java\/lang\/Object\n+  if (ptr != TypePtr::BotPTR) {\n+    return TypeInstPtr::NOTNULL;\n+  }\n+  return TypeInstPtr::BOTTOM;\n@@ -3878,1 +4083,1 @@\n-      return make(ptr, klass(), klass_is_exact(),\n+      return make(ptr, klass(), _interfaces, klass_is_exact(),\n@@ -3906,1 +4111,1 @@\n-      return make(ptr, klass(), klass_is_exact(),\n+      return make(ptr, klass(), _interfaces, klass_is_exact(),\n@@ -3940,0 +4145,2 @@\n+    InterfaceSet interfaces = meet_interfaces(tinst);\n+\n@@ -3942,2 +4149,0 @@\n-    bool tinst_xk = tinst->klass_is_exact();\n-    bool this_xk  = klass_is_exact();\n@@ -3948,1 +4153,2 @@\n-    MeetResult kind = meet_instptr(ptr, this_klass, tinst_klass, this_xk, tinst_xk, this->_ptr, tinst->_ptr, res_klass, res_xk);\n+    MeetResult kind = meet_instptr(ptr, interfaces, this, tinst, res_klass, res_xk);\n+\n@@ -3951,1 +4157,1 @@\n-      const TypeInstPtr* unloaded_meet = xmeet_unloaded(tinst);\n+      const TypeInstPtr* unloaded_meet = xmeet_unloaded(tinst, interfaces);\n@@ -3988,1 +4194,1 @@\n-      res = make(ptr, res_klass, res_xk, o, off, instance_id, speculative, depth);\n+      res = make(ptr, res_klass, interfaces, res_xk, o, off, instance_id, speculative, depth);\n@@ -3999,4 +4205,10 @@\n-TypePtr::MeetResult TypePtr::meet_instptr(PTR &ptr, ciKlass* this_klass, ciKlass* tinst_klass, bool this_xk, bool tinst_xk,\n-                                          PTR this_ptr,\n-                                          PTR tinst_ptr, ciKlass*&res_klass, bool &res_xk) {\n-\n+template<class T> TypePtr::MeetResult TypePtr::meet_instptr(PTR& ptr, InterfaceSet& interfaces, const T* this_type, const T* other_type,\n+                      ciKlass*& res_klass, bool& res_xk) {\n+  ciKlass* this_klass = this_type->klass();\n+  ciKlass* other_klass = other_type->klass();\n+  bool this_xk = this_type->klass_is_exact();\n+  bool other_xk = other_type->klass_is_exact();\n+  PTR this_ptr = this_type->ptr();\n+  PTR other_ptr = other_type->ptr();\n+  InterfaceSet this_interfaces = this_type->interfaces();\n+  InterfaceSet other_interfaces = other_type->interfaces();\n@@ -4007,1 +4219,1 @@\n-  if (ptr != Constant && this_klass->equals(tinst_klass) && this_xk == tinst_xk) {\n+  if (ptr != Constant && this_klass->equals(other_klass) && this_xk == other_xk) {\n@@ -4014,1 +4226,1 @@\n-  if (!tinst_klass->is_loaded() || !this_klass->is_loaded()) {\n+  if (!other_klass->is_loaded() || !this_klass->is_loaded()) {\n@@ -4018,41 +4230,0 @@\n-  \/\/ Handle mixing oops and interfaces first.\n-  if (this_klass->is_interface() && !(tinst_klass->is_interface() ||\n-                                      tinst_klass == ciEnv::current()->Object_klass())) {\n-    ciKlass *tmp = tinst_klass; \/\/ Swap interface around\n-    tinst_klass = this_klass;\n-    this_klass = tmp;\n-    bool tmp2 = tinst_xk;\n-    tinst_xk = this_xk;\n-    this_xk = tmp2;\n-  }\n-  if (tinst_klass->is_interface() &&\n-      !(this_klass->is_interface() ||\n-        \/\/ Treat java\/lang\/Object as an honorary interface,\n-        \/\/ because we need a bottom for the interface hierarchy.\n-        this_klass == ciEnv::current()->Object_klass())) {\n-    \/\/ Oop meets interface!\n-\n-    \/\/ See if the oop subtypes (implements) interface.\n-    if (this_klass->is_subtype_of(tinst_klass)) {\n-      \/\/ Oop indeed subtypes.  Now keep oop or interface depending\n-      \/\/ on whether we are both above the centerline or either is\n-      \/\/ below the centerline.  If we are on the centerline\n-      \/\/ (e.g., Constant vs. AnyNull interface), use the constant.\n-      res_klass  = below_centerline(ptr) ? tinst_klass : this_klass;\n-      \/\/ If we are keeping this_klass, keep its exactness too.\n-      res_xk = below_centerline(ptr) ? tinst_xk    : this_xk;\n-      return SUBTYPE;\n-    } else {                  \/\/ Does not implement, fall to Object\n-      \/\/ Oop does not implement interface, so mixing falls to Object\n-      \/\/ just like the verifier does (if both are above the\n-      \/\/ centerline fall to interface)\n-      res_klass = above_centerline(ptr) ? tinst_klass : ciEnv::current()->Object_klass();\n-      res_xk = above_centerline(ptr) ? tinst_xk : false;\n-      \/\/ Watch out for Constant vs. AnyNull interface.\n-      if (ptr == Constant)  ptr = NotNull;   \/\/ forget it was a constant\n-      return NOT_SUBTYPE;\n-    }\n-  }\n-\n-  \/\/ Either oop vs oop or interface vs interface or interface vs Object\n-\n@@ -4084,1 +4255,1 @@\n-  ciKlass *subtype = NULL;\n+  const T* subtype = NULL;\n@@ -4086,5 +4257,7 @@\n-  if (tinst_klass->equals(this_klass)) {\n-    subtype = this_klass;\n-    subtype_exact = below_centerline(ptr) ? (this_xk && tinst_xk) : (this_xk || tinst_xk);\n-  } else if (!tinst_xk && this_klass->is_subtype_of(tinst_klass)) {\n-    subtype = this_klass;     \/\/ Pick subtyping class\n+  InterfaceSet subtype_interfaces;\n+\n+  if (this_type->is_same_java_type_as(other_type)) {\n+    subtype = this_type;\n+    subtype_exact = below_centerline(ptr) ? (this_xk && other_xk) : (this_xk || other_xk);\n+  } else if (!other_xk && this_type->is_meet_subtype_of(other_type)) {\n+    subtype = this_type;     \/\/ Pick subtyping class\n@@ -4092,3 +4265,3 @@\n-  } else if (!this_xk && tinst_klass->is_subtype_of(this_klass)) {\n-    subtype = tinst_klass;    \/\/ Pick subtyping class\n-    subtype_exact = tinst_xk;\n+  } else if(!this_xk && other_type->is_meet_subtype_of(this_type)) {\n+    subtype = other_type;    \/\/ Pick subtyping class\n+    subtype_exact = other_xk;\n@@ -4099,8 +4272,8 @@\n-      this_klass = tinst_klass = subtype;\n-      this_xk = tinst_xk = subtype_exact;\n-    } else if (above_centerline(this_ptr) && !above_centerline(tinst_ptr)) {\n-      this_klass = tinst_klass; \/\/ tinst is down; keep down man\n-      this_xk = tinst_xk;\n-    } else if (above_centerline(tinst_ptr) && !above_centerline(this_ptr)) {\n-      tinst_klass = this_klass; \/\/ this is down; keep down man\n-      tinst_xk = this_xk;\n+      this_type = other_type = subtype;\n+      this_xk = other_xk = subtype_exact;\n+    } else if (above_centerline(this_ptr) && !above_centerline(other_ptr)) {\n+      this_type = other_type; \/\/ tinst is down; keep down man\n+      this_xk = other_xk;\n+    } else if (above_centerline(other_ptr) && !above_centerline(this_ptr)) {\n+      other_type = this_type; \/\/ this is down; keep down man\n+      other_xk = this_xk;\n@@ -4113,1 +4286,1 @@\n-  if (tinst_klass->equals(this_klass)) {\n+  if (this_type->is_same_java_type_as(other_type)) {\n@@ -4117,1 +4290,1 @@\n-    res_klass = this_klass;\n+    res_klass = this_type->klass();\n@@ -4128,0 +4301,2 @@\n+  interfaces = this_interfaces.intersection_with(other_interfaces);\n+\n@@ -4129,1 +4304,1 @@\n-  ciKlass* k = this_klass->least_common_ancestor(tinst_klass);\n+  ciKlass* k = this_klass->least_common_ancestor(other_klass);\n@@ -4137,1 +4312,0 @@\n-\n@@ -4154,1 +4328,1 @@\n-  return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n+  return new TypeInstPtr(dual_ptr(), klass(), _interfaces, klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n@@ -4163,0 +4337,1 @@\n+    _interfaces.eq(p->_interfaces) &&\n@@ -4169,1 +4344,1 @@\n-  int hash = java_add((jint)klass()->hash(), (jint)TypeOopPtr::hash());\n+  int hash = java_add(java_add((jint)klass()->hash(), (jint)TypeOopPtr::hash()), _interfaces.hash());\n@@ -4174,20 +4349,1 @@\n-  if (!is_loaded() || !other->is_loaded()) {\n-    return false;\n-  }\n-  if (!other->isa_instptr()) {\n-    return false;\n-  }\n-\n-  if (!other_exact) {\n-    return false;\n-  }\n-\n-  if (other->klass()->equals(ciEnv::current()->Object_klass())) {\n-    return true;\n-  }\n-\n-  if (!this_exact && klass()->is_interface()) {\n-    return false;\n-  }\n-\n-  return _klass->is_subtype_of(other->klass());\n+  return TypePtr::is_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n@@ -4196,8 +4352,3 @@\n-bool TypeInstPtr::is_same_java_type_as(const TypeOopPtr* other) const {\n-  if (!is_loaded() || !other->is_loaded()) {\n-    return false;\n-  }\n-  if (!other->isa_instptr()) {\n-    return false;\n-  }\n-  return _klass->equals(other->_klass);\n+\n+bool TypeInstPtr::is_same_java_type_as_helper(const TypeOopPtr* other) const {\n+  return TypePtr::is_same_java_type_as_helper_for_instance(this, other);\n@@ -4207,27 +4358,1 @@\n-  if (!is_loaded() || !other->is_loaded()) {\n-    return true;\n-  }\n-\n-  if (other->isa_aryptr()) {\n-    return !this_exact && (_klass->equals(ciEnv::current()->Object_klass()) || _klass->is_interface());\n-  }\n-\n-  if ((_klass->is_interface() && !this_exact) || (other->klass()->is_interface() \/*&& !other_exact*\/)) {\n-    return true;\n-  }\n-\n-  assert(other->isa_instptr(), \"unsupported\");\n-\n-  if (this_exact && other_exact) {\n-    return is_java_subtype_of(other);\n-  }\n-\n-  if (!_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(_klass)) {\n-    return false;\n-  }\n-\n-  if (this_exact) {\n-    return _klass->is_subtype_of(other->_klass);\n-  }\n-\n-  return true;\n+  return TypePtr::maybe_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n@@ -4243,0 +4368,1 @@\n+  _interfaces.dump(st);\n@@ -4292,1 +4418,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset),\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), xadd_offset(offset),\n@@ -4297,1 +4423,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), offset,\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), offset,\n@@ -4306,1 +4432,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset,\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset,\n@@ -4310,1 +4436,1 @@\n-const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {\n+const TypePtr* TypeInstPtr::with_inline_depth(int depth) const {\n@@ -4314,1 +4440,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, depth);\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, depth);\n@@ -4317,1 +4443,1 @@\n-const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {\n+const TypePtr* TypeInstPtr::with_instance_id(int instance_id) const {\n@@ -4319,1 +4445,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, instance_id, _speculative, _inline_depth);\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, instance_id, _speculative, _inline_depth);\n@@ -4325,5 +4451,59 @@\n-  if (try_for_exact && !xk && !ik->has_subklass() && !ik->is_final() && !ik->is_interface()) {\n-    Compile* C = Compile::current();\n-    Dependencies* deps = C->dependencies();\n-    deps->assert_leaf_type(ik);\n-    xk = true;\n+  if (try_for_exact && !xk && !ik->has_subklass() && !ik->is_final()) {\n+    ciKlass* k = ik;\n+    TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    assert(k == ik, \"\");\n+    if (interfaces.eq(_interfaces)) {\n+      Compile *C = Compile::current();\n+      Dependencies* deps = C->dependencies();\n+      deps->assert_leaf_type(ik);\n+      xk = true;\n+    }\n+  }\n+  return TypeInstKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, klass(), _interfaces, 0);\n+}\n+\n+template <class T1, class T2> bool TypePtr::is_meet_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_xk, bool other_xk) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+\n+  if (!this_one->is_instance_type(other)) {\n+    return false;\n+  }\n+\n+  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty()) {\n+    return true;\n+  }\n+\n+  return this_one->klass()->is_subtype_of(other->klass()) &&\n+         (!this_xk || this_one->_interfaces.contains(other->_interfaces));\n+}\n+\n+\n+bool TypeInstPtr::is_meet_subtype_of_helper(const TypeOopPtr *other, bool this_xk, bool other_xk) const {\n+  return TypePtr::is_meet_subtype_of_helper_for_instance(this, other, this_xk, other_xk);\n+}\n+\n+template <class T1, class T2>  bool TypePtr::is_meet_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_xk, bool other_xk) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty()) {\n+    return true;\n+  }\n+\n+  if (this_one->is_instance_type(other)) {\n+    return other->klass() == ciEnv::current()->Object_klass() && this_one->_interfaces.contains(other->_interfaces);\n+  }\n+\n+  int dummy;\n+  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n+  if (this_top_or_bottom) {\n+    return false;\n+  }\n+\n+  const T1* other_ary = this_one->is_array_type(other);\n+  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n+  const TypePtr* this_elem = this_one->elem()->make_ptr();\n+  if (other_elem != NULL && this_elem != NULL) {\n+    return this_one->is_reference_type(this_elem)->is_meet_subtype_of_helper(this_one->is_reference_type(other_elem), this_xk, other_xk);\n+  }\n+\n+  if (other_elem == NULL && this_elem == NULL) {\n+    return this_one->_klass->is_subtype_of(other->_klass);\n@@ -4331,1 +4511,14 @@\n-  return TypeInstKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, klass(), 0);\n+\n+  return false;\n+}\n+\n+bool TypeAryPtr::is_meet_subtype_of_helper(const TypeOopPtr *other, bool this_xk, bool other_xk) const {\n+  return TypePtr::is_meet_subtype_of_helper_for_array(this, other, this_xk, other_xk);\n+}\n+\n+bool TypeInstKlassPtr::is_meet_subtype_of_helper(const TypeKlassPtr *other, bool this_xk, bool other_xk) const {\n+  return TypePtr::is_meet_subtype_of_helper_for_instance(this, other, this_xk, other_xk);\n+}\n+\n+bool TypeAryKlassPtr::is_meet_subtype_of_helper(const TypeKlassPtr *other, bool this_xk, bool other_xk) const {\n+  return TypePtr::is_meet_subtype_of_helper_for_array(this, other, this_xk, other_xk);\n@@ -4354,0 +4547,4 @@\n+  if (k != NULL && k->is_loaded() && k->is_obj_array_klass() &&\n+      k->as_obj_array_klass()->base_element_klass()->is_interface()) {\n+    k = NULL;\n+  }\n@@ -4366,0 +4563,4 @@\n+  if (k != NULL && k->is_loaded() && k->is_obj_array_klass() &&\n+      k->as_obj_array_klass()->base_element_klass()->is_interface()) {\n+    k = NULL;\n+  }\n@@ -4393,1 +4594,1 @@\n-  if (!is_java_primitive(etype) && !is_reference_type(etype)) {\n+  if (!is_java_primitive(etype) && !::is_reference_type(etype)) {\n@@ -4501,22 +4702,1 @@\n-  if (other->klass() == ciEnv::current()->Object_klass() && other_exact) {\n-    return true;\n-  }\n-\n-  if (!is_loaded() || !other->is_loaded() || other->klass() == NULL || klass() == NULL) {\n-    return false;\n-  }\n-  if (other->isa_instptr()) {\n-    return _klass->is_subtype_of(other->_klass) && other_exact;\n-  }\n-  if (klass() == NULL) {\n-    return false;\n-  }\n-  assert(other->isa_aryptr(), \"\");\n-  const TypeAryPtr* other_ary = other->isa_aryptr();\n-  if (other_ary->elem()->make_oopptr() && elem()->make_oopptr()) {\n-    return elem()->make_oopptr()->is_java_subtype_of_helper(other_ary->elem()->make_oopptr(), this_exact, other_exact);\n-  }\n-  if (!other_ary->elem()->make_oopptr() && !elem()->make_oopptr()) {\n-    return _klass->is_subtype_of(other->_klass);\n-  }\n-  return false;\n+  return TypePtr::is_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n@@ -4525,13 +4705,2 @@\n-bool TypeAryPtr::is_same_java_type_as(const TypeOopPtr* other) const {\n-  if (!other->isa_aryptr() ||\n-      !is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n-    return false;\n-  }\n-  const TypeAryPtr* other_ary = other->isa_aryptr();\n-  if (other_ary->elem()->make_oopptr() && elem()->make_oopptr()) {\n-    return elem()->make_oopptr()->is_same_java_type_as(other_ary->elem()->make_oopptr());\n-  }\n-  if (!other_ary->elem()->make_oopptr() && !elem()->make_oopptr()) {\n-    return _klass->equals(other->_klass);\n-  }\n-  return false;\n+bool TypeAryPtr::is_same_java_type_as_helper(const TypeOopPtr* other) const {\n+  return TypePtr::is_same_java_type_as_helper_for_array(this, other);\n@@ -4541,25 +4710,1 @@\n-  if (other->klass() == ciEnv::current()->Object_klass()) {\n-    return true;\n-  }\n-\n-  if (!is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n-    return true;\n-  }\n-  if (other->isa_instptr()) {\n-    return (!other_exact && other->_klass->is_interface()) || _klass->is_subtype_of(other->_klass);\n-  }\n-  assert(other->isa_aryptr(), \"\");\n-\n-  if (this_exact && other_exact) {\n-    return is_java_subtype_of(other);\n-  }\n-\n-  const TypeAryPtr* other_ary = other->isa_aryptr();\n-  if (other_ary->elem()->make_oopptr() && elem()->make_oopptr()) {\n-    return elem()->make_oopptr()->maybe_java_subtype_of_helper(other_ary->elem()->make_oopptr(), this_exact,\n-                                                               other_exact);\n-  }\n-  if (!other_ary->elem()->make_oopptr() && !elem()->make_oopptr()) {\n-    return _klass->is_subtype_of(other->_klass);\n-  }\n-  return false;\n+  return TypePtr::maybe_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n@@ -4660,1 +4805,1 @@\n-    if (meet_aryptr(ptr, elem, this->klass(), tap->klass(), this->klass_is_exact(), tap->klass_is_exact(), this->ptr(), tap->ptr(), res_klass, res_xk) == NOT_SUBTYPE) {\n+    if (meet_aryptr(ptr, elem, this, tap, res_klass, res_xk) == NOT_SUBTYPE) {\n@@ -4690,0 +4835,4 @@\n+    InterfaceSet interfaces = meet_interfaces(tp);\n+    InterfaceSet tp_interfaces = tp->_interfaces;\n+    InterfaceSet this_interfaces = _interfaces;\n+\n@@ -4696,2 +4845,2 @@\n-      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n-        return make(ptr, _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);\n+      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.contains(tp_interfaces) && !tp->klass_is_exact()) {\n+        return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);\n@@ -4702,1 +4851,2 @@\n-        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, NULL,offset, instance_id, speculative, depth);\n+        interfaces = this_interfaces.intersection_with(tp_interfaces);\n+        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, false, NULL,offset, instance_id, speculative, depth);\n@@ -4714,1 +4864,1 @@\n-        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n+        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.contains(tp_interfaces) && !tp->klass_is_exact()) {\n@@ -4728,1 +4878,2 @@\n-      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, NULL, offset, instance_id, speculative, depth);\n+      interfaces = this_interfaces.intersection_with(tp_interfaces);\n+      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, false, NULL, offset, instance_id, speculative, depth);\n@@ -4737,1 +4888,11 @@\n-TypePtr::MeetResult TypePtr::meet_aryptr(PTR& ptr, const Type*& elem, ciKlass* this_klass, ciKlass* tap_klass, bool this_xk, bool tap_xk, PTR this_ptr, PTR tap_ptr, ciKlass*& res_klass, bool& res_xk) {\n+template<class T> TypePtr::MeetResult TypePtr::meet_aryptr(PTR& ptr, const Type*& elem, const T* this_ary,\n+                                                           const T* other_ary, ciKlass*& res_klass, bool& res_xk) {\n+  int dummy;\n+  bool this_top_or_bottom = (this_ary->base_element_type(dummy) == Type::TOP || this_ary->base_element_type(dummy) == Type::BOTTOM);\n+  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n+  ciKlass* this_klass = this_ary->klass();\n+  ciKlass* other_klass = other_ary->klass();\n+  bool this_xk = this_ary->klass_is_exact();\n+  bool other_xk = other_ary->klass_is_exact();\n+  PTR this_ptr = this_ary->ptr();\n+  PTR other_ptr = other_ary->ptr();\n@@ -4743,3 +4904,3 @@\n-    if (this_klass == NULL)\n-      res_klass = tap_klass;\n-    else if (tap_klass == NULL || tap_klass == this_klass) {\n+    if (this_top_or_bottom)\n+      res_klass = other_klass;\n+    else if (other_top_or_bottom || other_klass == this_klass) {\n@@ -4754,1 +4915,1 @@\n-  } else \/\/ Non integral arrays.\n+  } else {\/\/ Non integral arrays.\n@@ -4757,1 +4918,1 @@\n-    if ((above_centerline(ptr) || ptr == Constant) && this_klass != tap_klass &&\n+    if ((above_centerline(ptr) || ptr == Constant) && !this_ary->is_same_java_type_as(other_ary) &&\n@@ -4759,1 +4920,1 @@\n-        tap_klass != NULL  && this_klass != NULL   &&\n+        !this_top_or_bottom && !other_top_or_bottom &&\n@@ -4761,1 +4922,1 @@\n-        ((tap_xk && this_xk) ||\n+        ((other_xk && this_xk) ||\n@@ -4763,1 +4924,1 @@\n-         (tap_xk && !tap_klass->is_subtype_of(this_klass)) ||\n+         (other_xk && !other_ary->is_meet_subtype_of(this_ary)) ||\n@@ -4765,1 +4926,1 @@\n-         (this_xk && !this_klass->is_subtype_of(tap_klass)))) {\n+         (this_xk && !this_ary->is_meet_subtype_of(other_ary)))) {\n@@ -4773,0 +4934,1 @@\n+  }\n@@ -4775,1 +4937,1 @@\n-  switch (tap_ptr) {\n+  switch (other_ptr) {\n@@ -4782,1 +4944,1 @@\n-        res_xk = (tap_xk || this_xk);\n+        res_xk = (other_xk || this_xk);\n@@ -4792,1 +4954,1 @@\n-        res_xk = this_xk && (this_klass == tap_klass);\n+        res_xk = this_xk && (this_ary->is_same_java_type_as(other_ary) || (this_top_or_bottom && other_top_or_bottom));\n@@ -4800,1 +4962,1 @@\n-        res_xk = tap_xk;\n+        res_xk = other_xk;\n@@ -4802,2 +4964,2 @@\n-        res_xk = (tap_xk && this_xk) &&\n-          (this_klass == tap_klass); \/\/ Only precise for identical arrays\n+        res_xk = (other_xk && this_xk) &&\n+                 (this_ary->is_same_java_type_as(other_ary) || (this_top_or_bottom && other_top_or_bottom)); \/\/ Only precise for identical arrays\n@@ -4821,11 +4983,0 @@\n-\/\/----------------------interface_vs_oop---------------------------------------\n-#ifdef ASSERT\n-bool TypeAryPtr::interface_vs_oop(const Type *t) const {\n-  const TypeAryPtr* t_aryptr = t->isa_aryptr();\n-  if (t_aryptr) {\n-    return _ary->interface_vs_oop(t_aryptr->_ary);\n-  }\n-  return false;\n-}\n-#endif\n-\n@@ -4836,0 +4987,2 @@\n+  _interfaces.dump(st);\n+\n@@ -4888,1 +5041,1 @@\n-const TypePtr *TypeAryPtr::add_offset(intptr_t offset) const {\n+const TypePtr* TypeAryPtr::add_offset(intptr_t offset) const {\n@@ -4908,1 +5061,1 @@\n-const TypePtr *TypeAryPtr::with_inline_depth(int depth) const {\n+const TypePtr* TypeAryPtr::with_inline_depth(int depth) const {\n@@ -4915,1 +5068,1 @@\n-const TypePtr *TypeAryPtr::with_instance_id(int instance_id) const {\n+const TypePtr* TypeAryPtr::with_instance_id(int instance_id) const {\n@@ -5100,1 +5253,1 @@\n-const TypePtr *TypeMetadataPtr::add_offset( intptr_t offset ) const {\n+const TypePtr* TypeMetadataPtr::add_offset( intptr_t offset ) const {\n@@ -5275,1 +5428,1 @@\n-const TypeKlassPtr* TypeKlassPtr::make(ciKlass *klass) {\n+const TypeKlassPtr* TypeKlassPtr::make(ciKlass *klass, InterfaceHandling interface_handling) {\n@@ -5277,1 +5430,1 @@\n-    return TypeInstKlassPtr::make(klass);\n+    return TypeInstKlassPtr::make(klass, interface_handling);\n@@ -5279,1 +5432,1 @@\n-  return TypeAryKlassPtr::make(klass);\n+  return TypeAryKlassPtr::make(klass, interface_handling);\n@@ -5282,1 +5435,1 @@\n-const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* klass, int offset) {\n+const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* klass, int offset, InterfaceHandling interface_handling) {\n@@ -5284,1 +5437,2 @@\n-    return TypeInstKlassPtr::make(ptr, klass, offset);\n+    const InterfaceSet interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n+    return TypeInstKlassPtr::make(ptr, klass, interfaces, offset);\n@@ -5286,1 +5440,1 @@\n-  return TypeAryKlassPtr::make(ptr, klass, offset);\n+  return TypeAryKlassPtr::make(ptr, klass, offset, interface_handling);\n@@ -5291,2 +5445,4 @@\n-TypeKlassPtr::TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, int offset)\n-  : TypePtr(t, ptr, offset), _klass(klass) {\n+TypeKlassPtr::TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, const InterfaceSet& interfaces, int offset)\n+  : TypePtr(t, ptr, offset), _klass(klass), _interfaces(interfaces) {\n+  assert(klass == NULL || !klass->is_loaded() || (klass->is_instance_klass() && !klass->is_interface()) ||\n+         klass->is_type_array_klass() || !klass->as_obj_array_klass()->base_element_klass()->is_interface(), \"no interface here\");\n@@ -5295,0 +5451,1 @@\n+\/\/ Is there a single ciKlass* that can represent that type?\n@@ -5296,1 +5453,12 @@\n-  return _klass;\n+  assert(_klass->is_instance_klass() && !_klass->is_interface(), \"No interface\");\n+  if (_interfaces.empty()) {\n+    return _klass;\n+  }\n+  if (_klass != ciEnv::current()->Object_klass()) {\n+    ciKlass* k = _klass;\n+    if (_interfaces.eq(TypePtr::interfaces(k, true, false, true, ignore_interfaces))) {\n+      return _klass;\n+    }\n+    return NULL;\n+  }\n+  return _interfaces.exact_klass();\n@@ -5304,0 +5472,1 @@\n+    _interfaces.eq(p->_interfaces) &&\n@@ -5310,1 +5479,1 @@\n-  return TypePtr::hash();\n+  return java_add((jint)TypePtr::hash(), _interfaces.hash());\n@@ -5331,3 +5500,0 @@\n-    if (!empty() && ktkp != NULL && ktkp->klass()->is_loaded() && ktkp->klass()->is_interface())\n-      return kills;             \/\/ Uplift to interface\n-\n@@ -5337,9 +5503,0 @@\n-  \/\/ Interface klass type could be exact in opposite to interface type,\n-  \/\/ return it here instead of incorrect Constant ptr J\/L\/Object (6894807).\n-  if (ftkp != NULL && ktkp != NULL &&\n-      ftkp->is_loaded() &&  ftkp->klass()->is_interface() &&\n-      !ftkp->klass_is_exact() && \/\/ Keep exact interface klass\n-      ktkp->is_loaded() && !ktkp->klass()->is_interface()) {\n-    return ktkp->cast_to_ptr_type(ftkp->ptr());\n-  }\n-\n@@ -5349,0 +5506,11 @@\n+TypePtr::InterfaceSet TypeKlassPtr::meet_interfaces(const TypeKlassPtr* other) const {\n+  if (above_centerline(_ptr) && above_centerline(other->_ptr)) {\n+    return _interfaces.union_with(other->_interfaces);\n+  } else if (above_centerline(_ptr) && !above_centerline(other->_ptr)) {\n+    return other->_interfaces;\n+  } else if (above_centerline(other->_ptr) && !above_centerline(_ptr)) {\n+    return _interfaces;\n+  }\n+  return _interfaces.intersection_with(other->_interfaces);\n+}\n+\n@@ -5386,0 +5554,1 @@\n+      _interfaces.dump(st);\n@@ -5426,1 +5595,1 @@\n-const TypeInstKlassPtr *TypeInstKlassPtr::make(PTR ptr, ciKlass* k, int offset) {\n+const TypeInstKlassPtr *TypeInstKlassPtr::make(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, int offset) {\n@@ -5428,1 +5597,1 @@\n-    (TypeInstKlassPtr*)(new TypeInstKlassPtr(ptr, k, offset))->hashcons();\n+    (TypeInstKlassPtr*)(new TypeInstKlassPtr(ptr, k, interfaces, offset))->hashcons();\n@@ -5435,2 +5604,2 @@\n-const TypePtr *TypeInstKlassPtr::add_offset( intptr_t offset ) const {\n-  return make( _ptr, klass(), xadd_offset(offset) );\n+const TypePtr* TypeInstKlassPtr::add_offset( intptr_t offset ) const {\n+  return make( _ptr, klass(), _interfaces, xadd_offset(offset) );\n@@ -5440,1 +5609,1 @@\n-  return make(_ptr, klass(), offset);\n+  return make(_ptr, klass(), _interfaces, offset);\n@@ -5447,1 +5616,1 @@\n-  return make(ptr, _klass, _offset);\n+  return make(ptr, _klass, _interfaces, _offset);\n@@ -5463,1 +5632,1 @@\n-  return make(klass_is_exact ? Constant : NotNull, k, _offset);\n+  return make(klass_is_exact ? Constant : NotNull, k, _interfaces, _offset);\n@@ -5478,0 +5647,1 @@\n+  TypePtr::InterfaceSet interfaces = _interfaces;\n@@ -5486,3 +5656,8 @@\n-        deps->assert_abstract_with_unique_concrete_subtype(ik, sub);\n-        k = ik = sub;\n-        xk = sub->is_final();\n+        ciKlass* sub_k = sub;\n+        TypePtr::InterfaceSet sub_interfaces = TypePtr::interfaces(sub_k, true, false, false, ignore_interfaces);\n+        assert(sub_k == sub, \"\");\n+        if (sub_interfaces.eq(_interfaces)) {\n+          deps->assert_abstract_with_unique_concrete_subtype(ik, sub);\n+          k = ik = sub;\n+          xk = sub->is_final();\n+        }\n@@ -5492,1 +5667,1 @@\n-  return TypeInstPtr::make(TypePtr::BotPTR, k, xk, NULL, 0);\n+  return TypeInstPtr::make(TypePtr::BotPTR, k, interfaces, xk, NULL, 0);\n@@ -5533,1 +5708,1 @@\n-      return make( ptr, klass(), offset );\n+      return make( ptr, klass(), _interfaces, offset );\n@@ -5568,4 +5743,1 @@\n-    ciKlass* tkls_klass = tkls->klass();\n-    ciKlass* this_klass  = klass();\n-    bool tkls_xk = tkls->klass_is_exact();\n-    bool this_xk  = klass_is_exact();\n+    InterfaceSet interfaces = meet_interfaces(tkls);\n@@ -5575,1 +5747,1 @@\n-    switch(meet_instptr(ptr, this_klass, tkls_klass, this_xk, tkls_xk, this->_ptr, tkls->_ptr, res_klass, res_xk)) {\n+    switch(meet_instptr(ptr, interfaces, this, tkls, res_klass, res_xk)) {\n@@ -5583,2 +5755,2 @@\n-        const Type* res1 = make(ptr, res_klass, off);\n-        return res1;\n+        const Type* res = make(ptr, res_klass, interfaces, off);\n+        return res;\n@@ -5594,0 +5766,3 @@\n+    InterfaceSet interfaces = meet_interfaces(tp);\n+    InterfaceSet tp_interfaces = tp->_interfaces;\n+    InterfaceSet this_interfaces = _interfaces;\n@@ -5601,1 +5776,1 @@\n-      if (klass()->equals(ciEnv::current()->Object_klass()) && !klass_is_exact()) {\n+      if (klass()->equals(ciEnv::current()->Object_klass()) && tp_interfaces.contains(this_interfaces) && !klass_is_exact()) {\n@@ -5606,1 +5781,2 @@\n-        return make(ptr, ciEnv::current()->Object_klass(), offset);\n+        interfaces = _interfaces.intersection_with(tp->_interfaces);\n+        return make(ptr, ciEnv::current()->Object_klass(), interfaces, offset);\n@@ -5618,1 +5794,1 @@\n-        if (klass()->equals(ciEnv::current()->Object_klass())) {\n+        if (klass()->equals(ciEnv::current()->Object_klass()) && tp_interfaces.contains(this_interfaces) && !klass_is_exact()) {\n@@ -5628,1 +5804,2 @@\n-      return make(ptr, ciEnv::current()->Object_klass(), offset);\n+      interfaces = this_interfaces.intersection_with(tp_interfaces);\n+      return make(ptr, ciEnv::current()->Object_klass(), interfaces, offset);\n@@ -5640,1 +5817,1 @@\n-  return new TypeInstKlassPtr(dual_ptr(), klass(), dual_offset());\n+  return new TypeInstKlassPtr(dual_ptr(), klass(), _interfaces, dual_offset());\n@@ -5643,2 +5820,3 @@\n-bool TypeInstKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  if (!is_loaded() || !other->is_loaded()) {\n+template <class T1, class T2> bool TypePtr::is_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (!this_one->is_loaded() || !other->is_loaded()) {\n@@ -5647,1 +5825,1 @@\n-  if (!other->isa_instklassptr()) {\n+  if (!this_one->is_instance_type(other)) {\n@@ -5655,1 +5833,1 @@\n-  if (other->_klass->equals(ciEnv::current()->Object_klass())) {\n+  if (other->klass()->equals(ciEnv::current()->Object_klass()) && other->_interfaces.empty()) {\n@@ -5659,3 +5837,2 @@\n-  if (!this_exact && klass()->is_interface()) {\n-    return false;\n-  }\n+  return this_one->_klass->is_subtype_of(other->_klass) && this_one->_interfaces.contains(other->_interfaces);\n+}\n@@ -5663,1 +5840,2 @@\n-  return _klass->is_subtype_of(other->_klass);\n+bool TypeInstKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  return TypePtr::is_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n@@ -5666,2 +5844,3 @@\n-bool TypeInstKlassPtr::is_same_java_type_as(const TypeKlassPtr* other) const {\n-  if (!is_loaded() || !other->is_loaded()) {\n+template <class T1, class T2> bool TypePtr::is_same_java_type_as_helper_for_instance(const T1* this_one, const T2* other) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (!this_one->is_loaded() || !other->is_loaded()) {\n@@ -5670,1 +5849,1 @@\n-  if (!other->isa_instklassptr()) {\n+  if (!this_one->is_instance_type(other)) {\n@@ -5673,1 +5852,1 @@\n-  return _klass->equals(other->_klass);\n+  return this_one->_klass->equals(other->_klass) && this_one->_interfaces.eq(other->_interfaces);\n@@ -5676,4 +5855,3 @@\n-bool TypeInstKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  if (!is_loaded() || !other->is_loaded()) {\n-    return true;\n-  }\n+bool TypeInstKlassPtr::is_same_java_type_as_helper(const TypeKlassPtr* other) const {\n+  return TypePtr::is_same_java_type_as_helper_for_instance(this, other);\n+}\n@@ -5681,2 +5859,4 @@\n-  if (other->isa_aryklassptr()) {\n-    return !this_exact && (_klass->equals(ciEnv::current()->Object_klass()) || _klass->is_interface());\n+template <class T1, class T2> bool TypePtr::maybe_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (!this_one->is_loaded() || !other->is_loaded()) {\n+    return true;\n@@ -5685,2 +5865,2 @@\n-  if ((_klass->is_interface() && !this_exact) || (other->klass()->is_interface() \/*&& !other_exact*\/)) {\n-    return true;\n+  if (this_one->is_array_type(other)) {\n+    return !this_exact && this_one->_klass->equals(ciEnv::current()->Object_klass())  && other->_interfaces.contains(this_one->_interfaces);\n@@ -5689,1 +5869,1 @@\n-  assert(other->isa_instklassptr(), \"unsupported\");\n+  assert(this_one->is_instance_type(other), \"unsupported\");\n@@ -5692,1 +5872,1 @@\n-    return is_java_subtype_of(other);\n+    return this_one->is_java_subtype_of(other);\n@@ -5695,1 +5875,1 @@\n-  if (!_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(_klass)) {\n+  if (!this_one->_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(this_one->_klass)) {\n@@ -5700,1 +5880,1 @@\n-    return _klass->is_subtype_of(other->_klass);\n+    return this_one->_klass->is_subtype_of(other->_klass) && this_one->_interfaces.contains(other->_interfaces);\n@@ -5706,0 +5886,36 @@\n+bool TypeInstKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  return TypePtr::maybe_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n+}\n+\n+const TypeKlassPtr* TypeInstKlassPtr::try_improve() const {\n+  if (!UseUniqueSubclasses) {\n+    return this;\n+  }\n+  ciKlass* k = klass();\n+  Compile* C = Compile::current();\n+  Dependencies* deps = C->dependencies();\n+  assert((deps != NULL) == (C->method() != NULL && C->method()->code_size() > 0), \"sanity\");\n+  TypePtr::InterfaceSet interfaces = _interfaces;\n+  if (k->is_loaded()) {\n+    ciInstanceKlass* ik = k->as_instance_klass();\n+    bool klass_is_exact = ik->is_final();\n+    if (!klass_is_exact &&\n+        deps != NULL) {\n+      ciInstanceKlass* sub = ik->unique_concrete_subklass();\n+      if (sub != NULL) {\n+        ciKlass *sub_k = sub;\n+        TypePtr::InterfaceSet sub_interfaces = TypePtr::interfaces(sub_k, true, false, false, ignore_interfaces);\n+        assert(sub_k == sub, \"\");\n+        if (sub_interfaces.eq(_interfaces)) {\n+          deps->assert_abstract_with_unique_concrete_subtype(ik, sub);\n+          k = ik = sub;\n+          klass_is_exact = sub->is_final();\n+          return TypeKlassPtr::make(klass_is_exact ? Constant : _ptr, k, _offset);\n+        }\n+      }\n+    }\n+  }\n+  return this;\n+}\n+\n+\n@@ -5710,2 +5926,2 @@\n-const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, ciKlass* klass, int offset) {\n-  if (klass->is_obj_array_klass()) {\n+const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, ciKlass* k, int offset, InterfaceHandling interface_handling) {\n+  if (k->is_obj_array_klass()) {\n@@ -5713,2 +5929,2 @@\n-    ciKlass* eklass = klass->as_obj_array_klass()->element_klass();\n-    const TypeKlassPtr *etype = TypeKlassPtr::make(eklass)->cast_to_exactness(false);\n+    ciKlass* eklass = k->as_obj_array_klass()->element_klass();\n+    const TypeKlassPtr *etype = TypeKlassPtr::make(eklass, interface_handling)->cast_to_exactness(false);\n@@ -5716,1 +5932,1 @@\n-  } else if (klass->is_type_array_klass()) {\n+  } else if (k->is_type_array_klass()) {\n@@ -5718,2 +5934,2 @@\n-    const Type* etype = get_const_basic_type(klass->as_type_array_klass()->element_type());\n-    return TypeAryKlassPtr::make(ptr, etype, klass, offset);\n+    const Type* etype = get_const_basic_type(k->as_type_array_klass()->element_type());\n+    return TypeAryKlassPtr::make(ptr, etype, k, offset);\n@@ -5726,2 +5942,2 @@\n-const TypeAryKlassPtr* TypeAryKlassPtr::make(ciKlass* klass) {\n-  return TypeAryKlassPtr::make(Constant, klass, 0);\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(ciKlass* klass, InterfaceHandling interface_handling) {\n+  return TypeAryKlassPtr::make(Constant, klass, 0, interface_handling);\n@@ -5759,2 +5975,1 @@\n-    \/\/ Compute array klass from element klass\n-    k_ary = ciObjArrayKlass::make(tinst->klass());\n+    \/\/ Leave k_ary at NULL.\n@@ -5762,5 +5977,1 @@\n-    \/\/ Compute array klass from element klass\n-    ciKlass* k_elem = tary->klass();\n-    \/\/ If element type is something like bottom[], k_elem will be null.\n-    if (k_elem != NULL)\n-      k_ary = ciObjArrayKlass::make(k_elem);\n+    \/\/ Leave k_ary at NULL.\n@@ -5824,5 +6035,0 @@\n-    if (UseCompressedOops && k_ary != NULL && k_ary->is_obj_array_klass() &&\n-        _offset != 0 && _offset != arrayOopDesc::length_offset_in_bytes() &&\n-        _offset != arrayOopDesc::klass_offset_in_bytes()) {\n-      ((TypeAryPtr*)this)->_is_ptr_to_narrowoop = true;\n-    }\n@@ -5833,0 +6039,1 @@\n+\/\/ Is there a single ciKlass* that can represent that type?\n@@ -5858,1 +6065,1 @@\n-const TypePtr *TypeAryKlassPtr::add_offset(intptr_t offset) const {\n+const TypePtr* TypeAryKlassPtr::add_offset(intptr_t offset) const {\n@@ -5988,1 +6195,1 @@\n-    meet_aryptr(ptr, elem, this->klass(), tap->klass(), this->klass_is_exact(), tap->klass_is_exact(), this->ptr(), tap->ptr(), res_klass, res_xk);\n+    meet_aryptr(ptr, elem, this, tap, res_klass, res_xk);\n@@ -5996,0 +6203,3 @@\n+    InterfaceSet interfaces = meet_interfaces(tp);\n+    InterfaceSet tp_interfaces = tp->_interfaces;\n+    InterfaceSet this_interfaces = _interfaces;\n@@ -6003,1 +6213,1 @@\n-      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n+      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.intersection_with(tp_interfaces).eq(tp_interfaces) && !tp->klass_is_exact()) {\n@@ -6008,1 +6218,2 @@\n-        return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), offset);\n+        interfaces = this_interfaces.intersection_with(tp->_interfaces);\n+        return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, offset);\n@@ -6020,1 +6231,1 @@\n-        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n+        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.intersection_with(tp_interfaces).eq(tp_interfaces) && !tp->klass_is_exact()) {\n@@ -6029,1 +6240,2 @@\n-      return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), offset);\n+      interfaces = this_interfaces.intersection_with(tp_interfaces);\n+      return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, offset);\n@@ -6038,2 +6250,4 @@\n-bool TypeAryKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  if (other->klass() == ciEnv::current()->Object_klass() && other_exact) {\n+template <class T1, class T2> bool TypePtr::is_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+\n+  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty() && other_exact) {\n@@ -6043,1 +6257,4 @@\n-  if (!is_loaded() || !other->is_loaded() || other->klass() == NULL || klass() == NULL) {\n+  int dummy;\n+  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n+\n+  if (!this_one->is_loaded() || !other->is_loaded() || this_top_or_bottom) {\n@@ -6046,2 +6263,3 @@\n-  if (other->isa_instklassptr()) {\n-    return _klass->is_subtype_of(other->_klass) && other_exact;\n+\n+  if (this_one->is_instance_type(other)) {\n+    return other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.intersection_with(this_one->_interfaces).eq(other->_interfaces) && other_exact;\n@@ -6049,1 +6267,5 @@\n-  if (klass() == NULL) {\n+\n+  assert(this_one->is_array_type(other), \"\");\n+  const T1* other_ary = this_one->is_array_type(other);\n+  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n+  if (other_top_or_bottom) {\n@@ -6052,4 +6274,5 @@\n-  assert(other->isa_aryklassptr(), \"\");\n-  const TypeAryKlassPtr* other_ary = other->isa_aryklassptr();\n-  if (other_ary->_elem->isa_klassptr() && _elem->isa_klassptr()) {\n-    return _elem->is_klassptr()->is_java_subtype_of_helper(other_ary->_elem->is_klassptr(), this_exact, other_exact);\n+\n+  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n+  const TypePtr* this_elem = this_one->elem()->make_ptr();\n+  if (this_elem != NULL && other_elem != NULL) {\n+    return this_one->is_reference_type(this_elem)->is_java_subtype_of_helper(this_one->is_reference_type(other_elem), this_exact, other_exact);\n@@ -6057,2 +6280,2 @@\n-  if (!other_ary->_elem->isa_klassptr() && !_elem->isa_klassptr()) {\n-    return _klass->is_subtype_of(other->_klass);\n+  if (this_elem == NULL && other_elem == NULL) {\n+    return this_one->_klass->is_subtype_of(other->_klass);\n@@ -6063,3 +6286,18 @@\n-bool TypeAryKlassPtr::is_same_java_type_as(const TypeKlassPtr* other) const {\n-  if (!other->isa_aryklassptr() ||\n-      !is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n+bool TypeAryKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  return TypePtr::is_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n+}\n+\n+template <class T1, class T2> bool TypePtr::is_same_java_type_as_helper_for_array(const T1* this_one, const T2* other) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+\n+  int dummy;\n+  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n+\n+  if (!this_one->is_array_type(other) ||\n+      !this_one->is_loaded() || !other->is_loaded() || this_top_or_bottom) {\n+    return false;\n+  }\n+  const T1* other_ary = this_one->is_array_type(other);\n+  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n+\n+  if (other_top_or_bottom) {\n@@ -6068,3 +6306,5 @@\n-  const TypeAryKlassPtr* other_ary = other->isa_aryklassptr();\n-  if (other_ary->_elem->isa_klassptr() && _elem->isa_klassptr()) {\n-    return _elem->is_klassptr()->is_same_java_type_as(other_ary->_elem->is_klassptr());\n+\n+  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n+  const TypePtr* this_elem = this_one->elem()->make_ptr();\n+  if (other_elem != NULL && this_elem != NULL) {\n+    return this_one->is_reference_type(this_elem)->is_same_java_type_as(this_one->is_reference_type(other_elem));\n@@ -6072,2 +6312,3 @@\n-  if (!other_ary->_elem->isa_klassptr() && !_elem->isa_klassptr()) {\n-    return _klass->equals(other->_klass);\n+  if (other_elem == NULL && this_elem == NULL) {\n+    assert(this_one->_klass != NULL && other->_klass != NULL, \"\");\n+    return this_one->_klass->equals(other->_klass);\n@@ -6078,2 +6319,7 @@\n-bool TypeAryKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  if (other->klass() == ciEnv::current()->Object_klass()) {\n+bool TypeAryKlassPtr::is_same_java_type_as_helper(const TypeKlassPtr* other) const {\n+  return TypePtr::is_same_java_type_as_helper_for_array(this, other);\n+}\n+\n+template <class T1, class T2> bool TypePtr::maybe_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty() && other_exact) {\n@@ -6082,1 +6328,3 @@\n-  if (!is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n+  int dummy;\n+  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n+  if (!this_one->is_loaded() || !other->is_loaded() || this_top_or_bottom) {\n@@ -6085,2 +6333,2 @@\n-  if (other->isa_instklassptr()) {\n-    return (!other_exact && other->_klass->is_interface()) || _klass->is_subtype_of(other->_klass);\n+  if (this_one->is_instance_type(other)) {\n+    return other->_klass->equals(ciEnv::current()->Object_klass()) && other->_interfaces.intersection_with(this_one->_interfaces).eq(other->_interfaces);\n@@ -6088,1 +6336,1 @@\n-  assert(other->isa_aryklassptr(), \"\");\n+  assert(this_one->is_array_type(other), \"\");\n@@ -6090,0 +6338,5 @@\n+  const T1* other_ary = this_one->is_array_type(other);\n+  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n+  if (other_top_or_bottom) {\n+    return true;\n+  }\n@@ -6091,1 +6344,1 @@\n-    return is_java_subtype_of(other);\n+    return this_one->is_java_subtype_of(other);\n@@ -6094,3 +6347,4 @@\n-  const TypeAryKlassPtr* other_ary = other->isa_aryklassptr();\n-  if (other_ary->_elem->isa_klassptr() && _elem->isa_klassptr()) {\n-    return _elem->is_klassptr()->maybe_java_subtype_of_helper(other_ary->_elem->is_klassptr(), this_exact, other_exact);\n+  const TypePtr* this_elem = this_one->elem()->make_ptr();\n+  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n+  if (other_elem != NULL && this_elem != NULL) {\n+    return this_one->is_reference_type(this_elem)->maybe_java_subtype_of_helper(this_one->is_reference_type(other_elem), this_exact, other_exact);\n@@ -6098,2 +6352,2 @@\n-  if (!other_ary->_elem->isa_klassptr() && !_elem->isa_klassptr()) {\n-    return _klass->is_subtype_of(other->_klass);\n+  if (other_elem == NULL && this_elem == NULL) {\n+    return this_one->_klass->is_subtype_of(other->_klass);\n@@ -6104,0 +6358,4 @@\n+bool TypeAryKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  return TypePtr::maybe_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n+}\n+\n@@ -6110,1 +6368,1 @@\n-\/\/------------------------------get_con----------------------------------------\n+\/\/ Is there a single ciKlass* that can represent that type?\n@@ -6130,5 +6388,1 @@\n-    k = elem()->is_klassptr()->klass();\n-    if (k != NULL) {\n-      k = ciObjArrayKlass::make(k);\n-      ((TypeAryKlassPtr*)this)->_klass = k;\n-    }\n+    \/\/ leave NULL\n@@ -6139,0 +6393,1 @@\n+    ((TypeAryKlassPtr*)this)->_klass = k;\n@@ -6154,0 +6409,1 @@\n+      _interfaces.dump(st);\n@@ -6202,1 +6458,1 @@\n-    domain = TypeTuple::make_domain(NULL, method->signature());\n+    domain = TypeTuple::make_domain(NULL, method->signature(), ignore_interfaces);\n@@ -6204,1 +6460,1 @@\n-    domain = TypeTuple::make_domain(method->holder(), method->signature());\n+    domain = TypeTuple::make_domain(method->holder(), method->signature(), ignore_interfaces);\n@@ -6206,1 +6462,1 @@\n-  const TypeTuple *range  = TypeTuple::make_range(method->signature());\n+  const TypeTuple *range  = TypeTuple::make_range(method->signature(), ignore_interfaces);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":805,"deletions":549,"binary":false,"changes":1354,"status":"modified"},{"patch":"@@ -171,4 +171,0 @@\n-#ifdef ASSERT\n-  \/\/ One type is interface, the other is oop\n-  virtual bool interface_vs_oop_helper(const Type *t) const;\n-#endif\n@@ -263,1 +259,0 @@\n-  \/\/ Currently, it also works around limitations involving interface types.\n@@ -273,5 +268,0 @@\n-#ifdef ASSERT\n-  \/\/ One type is interface, the other is oop\n-  virtual bool interface_vs_oop(const Type *t) const;\n-#endif\n-\n@@ -407,0 +397,4 @@\n+  enum InterfaceHandling {\n+      trust_interfaces,\n+      ignore_interfaces\n+  };\n@@ -408,1 +402,1 @@\n-  static const Type* get_const_type(ciType* type);\n+  static const Type* get_const_type(ciType* type, InterfaceHandling interface_handling = ignore_interfaces);\n@@ -727,2 +721,2 @@\n-  static const TypeTuple *make_range(ciSignature *sig);\n-  static const TypeTuple *make_domain(ciInstanceKlass* recv, ciSignature *sig);\n+  static const TypeTuple *make_range(ciSignature *sig, InterfaceHandling interface_handling = ignore_interfaces);\n+  static const TypeTuple *make_domain(ciInstanceKlass* recv, ciSignature *sig, InterfaceHandling interface_handling);\n@@ -779,4 +773,0 @@\n-#ifdef ASSERT\n-  \/\/ One type is interface, the other is oop\n-  virtual bool interface_vs_oop(const Type *t) const;\n-#endif\n@@ -888,0 +878,46 @@\n+  friend class Type;\n+protected:\n+  class InterfaceSet {\n+  private:\n+    GrowableArray<ciKlass*> _list;\n+    void raw_add(ciKlass* interface);\n+    void add(ciKlass* interface);\n+    void verify() const;\n+    int _hash_computed:1;\n+    int _exact_klass_computed:1;\n+    int _is_loaded_computed:1;\n+    int _hash;\n+    ciKlass* _exact_klass;\n+    bool _is_loaded;\n+    void compute_hash();\n+    void compute_exact_klass();\n+  public:\n+    InterfaceSet();\n+    InterfaceSet(GrowableArray<ciInstanceKlass*>* interfaces);\n+    bool eq(const InterfaceSet& other) const;\n+    int hash() const;\n+    void dump(outputStream *st) const;\n+    InterfaceSet union_with(const InterfaceSet& other) const;\n+    InterfaceSet intersection_with(const InterfaceSet& other) const;\n+    bool contains(const InterfaceSet& other) const {\n+      return intersection_with(other).eq(other);\n+    }\n+    bool empty() const { return _list.length() == 0; }\n+\n+    inline void* operator new(size_t x) throw() {\n+      Compile* compile = Compile::current();\n+      return compile->type_arena()->AmallocWords(x);\n+    }\n+    inline void operator delete( void* ptr ) {\n+      ShouldNotReachHere();\n+    }\n+    ciKlass* exact_klass() const;\n+    bool is_loaded() const;\n+\n+    static int compare(ciKlass* const &, ciKlass* const & k2);\n+\n+    void compute_is_loaded();\n+  };\n+\n+  static InterfaceSet interfaces(ciKlass*& k, bool klass, bool interface, bool array, InterfaceHandling interface_handling);\n+\n@@ -946,6 +982,14 @@\n-  static MeetResult\n-  meet_instptr(PTR &ptr, ciKlass* this_klass, ciKlass* tinst_klass, bool this_xk, bool tinst_xk, PTR this_ptr,\n-               PTR tinst_ptr, ciKlass*&res_klass, bool &res_xk);\n-  static MeetResult\n-  meet_aryptr(PTR& ptr, const Type*& elem, ciKlass* this_klass, ciKlass* tap_klass, bool this_xk, bool tap_xk, PTR this_ptr, PTR tap_ptr, ciKlass*& res_klass, bool& res_xk);\n-\n+  template<class T> static TypePtr::MeetResult meet_instptr(PTR& ptr, InterfaceSet& interfaces, const T* this_type,\n+                                                            const T* other_type, ciKlass*& res_klass, bool& res_xk);\n+\n+  template<class T> static MeetResult meet_aryptr(PTR& ptr, const Type*& elem, const T* this_ary, const T* other_ary,\n+                                                  ciKlass*& res_klass, bool& res_xk);\n+\n+  template <class T1, class T2> static bool is_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact);\n+  template <class T1, class T2> static bool is_same_java_type_as_helper_for_instance(const T1* this_one, const T2* other);\n+  template <class T1, class T2> static bool maybe_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact);\n+  template <class T1, class T2> static bool is_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact);\n+  template <class T1, class T2> static bool is_same_java_type_as_helper_for_array(const T1* this_one, const T2* other);\n+  template <class T1, class T2> static bool maybe_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact);\n+  template <class T1, class T2> static bool is_meet_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_xk, bool other_xk);\n+  template <class T1, class T2> static bool is_meet_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_xk, bool other_xk);\n@@ -1060,1 +1104,1 @@\n-  TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id,\n+ TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int offset, int instance_id,\n@@ -1076,0 +1120,3 @@\n+\n+  const InterfaceSet _interfaces;\n+\n@@ -1087,1 +1134,1 @@\n-  static const TypeOopPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact);\n+  static const TypeOopPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact, InterfaceHandling interface_handling);\n@@ -1092,0 +1139,2 @@\n+  InterfaceSet meet_interfaces(const TypeOopPtr* other) const;\n+\n@@ -1103,1 +1152,9 @@\n-  virtual bool is_same_java_type_as(const TypeOopPtr* other) const { ShouldNotReachHere(); return false; }\n+\n+  bool is_same_java_type_as(const TypePtr* other) const {\n+    return is_same_java_type_as_helper(other->is_oopptr());\n+  }\n+\n+  virtual bool is_same_java_type_as_helper(const TypeOopPtr* other) const {\n+    ShouldNotReachHere(); return false;\n+  }\n+\n@@ -1114,2 +1171,2 @@\n-  static const TypeOopPtr* make_from_klass(ciKlass* klass) {\n-    return make_from_klass_common(klass, true, false);\n+  static const TypeOopPtr* make_from_klass(ciKlass* klass, InterfaceHandling interface_handling = ignore_interfaces) {\n+    return make_from_klass_common(klass, true, false, interface_handling);\n@@ -1119,2 +1176,2 @@\n-  static const TypeOopPtr* make_from_klass_unique(ciKlass* klass) {\n-    return make_from_klass_common(klass, true, true);\n+  static const TypeOopPtr* make_from_klass_unique(ciKlass* klass, InterfaceHandling interface_handling= ignore_interfaces) {\n+    return make_from_klass_common(klass, true, true, interface_handling);\n@@ -1124,2 +1181,2 @@\n-  static const TypeOopPtr* make_from_klass_raw(ciKlass* klass) {\n-    return make_from_klass_common(klass, false, false);\n+  static const TypeOopPtr* make_from_klass_raw(ciKlass* klass, InterfaceHandling interface_handling = ignore_interfaces) {\n+    return make_from_klass_common(klass, false, false, interface_handling);\n@@ -1144,2 +1201,2 @@\n-  virtual bool  is_loaded() const { return klass()->is_loaded(); }\n-  bool klass_is_exact()    const { return _klass_is_exact; }\n+  virtual bool  is_loaded() const { return klass()->is_loaded() && _interfaces.is_loaded(); }\n+  virtual bool klass_is_exact()    const { return _klass_is_exact; }\n@@ -1187,0 +1244,24 @@\n+private:\n+  virtual bool is_meet_subtype_of(const TypePtr* other) const {\n+    return is_meet_subtype_of_helper(other->is_oopptr(), klass_is_exact(), other->is_oopptr()->klass_is_exact());\n+  }\n+\n+  virtual bool is_meet_subtype_of_helper(const TypeOopPtr* other, bool this_xk, bool other_xk) const {\n+    ShouldNotReachHere(); return false;\n+  }\n+\n+  virtual const InterfaceSet interfaces() const {\n+    return _interfaces;\n+  };\n+\n+  const TypeOopPtr* is_reference_type(const Type* other) const {\n+    return other->isa_oopptr();\n+  }\n+\n+  const TypeAryPtr* is_array_type(const TypeOopPtr* other) const {\n+    return other->isa_aryptr();\n+  }\n+\n+  const TypeInstPtr* is_instance_type(const TypeOopPtr* other) const {\n+    return other->isa_instptr();\n+  }\n@@ -1193,1 +1274,1 @@\n-  TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id,\n+  TypeInstPtr(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int offset, int instance_id,\n@@ -1204,3 +1285,1 @@\n-    if (klass()->is_loaded() && klass()->is_interface()) {\n-      return Compile::current()->env()->Object_klass();\n-    }\n+    assert(!(klass()->is_loaded() && klass()->is_interface()), \"\");\n@@ -1210,1 +1289,1 @@\n-  bool is_same_java_type_as(const TypeOopPtr* other) const;\n+  bool is_same_java_type_as_helper(const TypeOopPtr* other) const;\n@@ -1216,1 +1295,3 @@\n-    return make(TypePtr::Constant, o->klass(), true, o, 0, InstanceBot);\n+    ciKlass* k = o->klass();\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    return make(TypePtr::Constant, k, interfaces, true, o, 0, InstanceBot);\n@@ -1220,1 +1301,3 @@\n-    return make(TypePtr::Constant, o->klass(), true, o, offset, InstanceBot);\n+    ciKlass* k = o->klass();\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    return make(TypePtr::Constant, k, interfaces, true, o, offset, InstanceBot);\n@@ -1224,2 +1307,3 @@\n-  static const TypeInstPtr *make(PTR ptr, ciKlass* klass) {\n-    return make(ptr, klass, false, NULL, 0, InstanceBot);\n+  static const TypeInstPtr *make(PTR ptr, ciKlass* klass, InterfaceHandling interface_handling = ignore_interfaces) {\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n+    return make(ptr, klass, interfaces, false, NULL, 0, InstanceBot);\n@@ -1230,1 +1314,2 @@\n-    return make(ptr, klass, true, NULL, 0, InstanceBot);\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, false, false, ignore_interfaces);\n+    return make(ptr, klass, interfaces, true, NULL, 0, InstanceBot);\n@@ -1235,1 +1320,2 @@\n-    return make(ptr, klass, false, NULL, offset, InstanceBot);\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, false, false, ignore_interfaces);\n+    return make(ptr, klass, interfaces, false, NULL, offset, InstanceBot);\n@@ -1238,2 +1324,1 @@\n-  \/\/ Make a pointer to an oop.\n-  static const TypeInstPtr *make(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,\n+  static const TypeInstPtr *make(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int offset,\n@@ -1244,0 +1329,5 @@\n+  static const TypeInstPtr *make(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id = InstanceBot) {\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    return make(ptr, k, interfaces, xk, o, offset, instance_id);\n+  }\n+\n@@ -1268,1 +1358,1 @@\n-  virtual const TypeInstPtr *xmeet_unloaded( const TypeInstPtr *t ) const;\n+  virtual const TypeInstPtr *xmeet_unloaded(const TypeInstPtr *t, const InterfaceSet& interfaces) const;\n@@ -1273,2 +1363,0 @@\n-  bool is_interface() const { return is_loaded() && klass()->is_interface(); }\n-\n@@ -1284,0 +1372,8 @@\n+\n+private:\n+  virtual bool is_meet_subtype_of_helper(const TypeOopPtr* other, bool this_xk, bool other_xk) const;\n+\n+  virtual bool is_meet_same_type_as(const TypePtr* other) const {\n+    return _klass->equals(other->is_instptr()->_klass) && _interfaces.eq(other->is_instptr()->_interfaces);\n+  }\n+\n@@ -1289,0 +1385,3 @@\n+  friend class Type;\n+  friend class TypePtr;\n+\n@@ -1292,1 +1391,1 @@\n-    : TypeOopPtr(AryPtr,ptr,k,xk,o,offset, instance_id, speculative, inline_depth),\n+    : TypeOopPtr(AryPtr,ptr,k,*_array_interfaces,xk,o,offset, instance_id, speculative, inline_depth),\n@@ -1296,14 +1395,7 @@\n-#ifdef ASSERT\n-    if (k != NULL) {\n-      \/\/ Verify that specified klass and TypeAryPtr::klass() follow the same rules.\n-      ciKlass* ck = compute_klass(true);\n-      if (k != ck) {\n-        this->dump(); tty->cr();\n-        tty->print(\" k: \");\n-        k->print(); tty->cr();\n-        tty->print(\"ck: \");\n-        if (ck != NULL) ck->print();\n-        else tty->print(\"<NULL>\");\n-        tty->cr();\n-        assert(false, \"unexpected TypeAryPtr::_klass\");\n-      }\n+    int dummy;\n+    bool top_or_bottom = (base_element_type(dummy) == Type::TOP || base_element_type(dummy) == Type::BOTTOM);\n+\n+    if (UseCompressedOops && (elem()->make_oopptr() != NULL && !top_or_bottom) &&\n+        _offset != 0 && _offset != arrayOopDesc::length_offset_in_bytes() &&\n+        _offset != arrayOopDesc::klass_offset_in_bytes()) {\n+      _is_ptr_to_narrowoop = true;\n@@ -1311,1 +1403,1 @@\n-#endif\n+\n@@ -1320,0 +1412,3 @@\n+  \/\/ A pointer to delay allocation to Type::Initialize_shared()\n+\n+  static const InterfaceSet* _array_interfaces;\n@@ -1321,0 +1416,1 @@\n+  \/\/ Only guaranteed non null for array of basic types\n@@ -1325,1 +1421,1 @@\n-  bool is_same_java_type_as(const TypeOopPtr* other) const;\n+  bool is_same_java_type_as_helper(const TypeOopPtr* other) const;\n@@ -1402,4 +1498,0 @@\n-#ifdef ASSERT\n-  \/\/ One type is interface, the other is oop\n-  virtual bool interface_vs_oop(const Type *t) const;\n-#endif\n@@ -1409,0 +1501,2 @@\n+private:\n+  virtual bool is_meet_subtype_of_helper(const TypeOopPtr* other, bool this_xk, bool other_xk) const;\n@@ -1456,0 +1550,1 @@\n+  friend class TypePtr;\n@@ -1457,1 +1552,1 @@\n-  TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, int offset);\n+  TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, const InterfaceSet& interfaces, int offset);\n@@ -1469,1 +1564,2 @@\n-\n+  const InterfaceSet _interfaces;\n+  InterfaceSet meet_interfaces(const TypeKlassPtr* other) const;\n@@ -1479,0 +1575,4 @@\n+  bool is_same_java_type_as(const TypePtr* other) const {\n+    return is_same_java_type_as_helper(other->is_klassptr());\n+  }\n+\n@@ -1482,1 +1582,1 @@\n-  virtual bool is_same_java_type_as(const TypeKlassPtr* other) const { ShouldNotReachHere(); return false; }\n+  virtual bool is_same_java_type_as_helper(const TypeKlassPtr* other) const { ShouldNotReachHere(); return false; }\n@@ -1488,0 +1588,1 @@\n+  virtual bool klass_is_exact()    const { return _ptr == Constant; }\n@@ -1489,4 +1590,2 @@\n-  bool klass_is_exact()    const { return _ptr == Constant; }\n-\n-  static const TypeKlassPtr* make(ciKlass* klass);\n-  static const TypeKlassPtr *make(PTR ptr, ciKlass* klass, int offset);\n+  static const TypeKlassPtr* make(ciKlass* klass, InterfaceHandling interface_handling = ignore_interfaces);\n+  static const TypeKlassPtr *make(PTR ptr, ciKlass* klass, int offset, InterfaceHandling interface_handling = ignore_interfaces);\n@@ -1511,0 +1610,2 @@\n+  virtual const TypeKlassPtr* try_improve() const { return this; }\n+\n@@ -1514,0 +1615,24 @@\n+private:\n+  virtual bool is_meet_subtype_of(const TypePtr* other) const {\n+    return is_meet_subtype_of_helper(other->is_klassptr(), klass_is_exact(), other->is_klassptr()->klass_is_exact());\n+  }\n+\n+  virtual bool is_meet_subtype_of_helper(const TypeKlassPtr* other, bool this_xk, bool other_xk) const {\n+    ShouldNotReachHere(); return false;\n+  }\n+\n+  virtual const InterfaceSet interfaces() const {\n+    return _interfaces;\n+  };\n+\n+  const TypeKlassPtr* is_reference_type(const Type* other) const {\n+    return other->isa_klassptr();\n+  }\n+\n+  const TypeAryKlassPtr* is_array_type(const TypeKlassPtr* other) const {\n+    return other->isa_aryklassptr();\n+  }\n+\n+  const TypeInstKlassPtr* is_instance_type(const TypeKlassPtr* other) const {\n+    return other->isa_instklassptr();\n+  }\n@@ -1519,2 +1644,3 @@\n-  TypeInstKlassPtr(PTR ptr, ciKlass* klass, int offset)\n-    : TypeKlassPtr(InstKlassPtr, ptr, klass, offset) {\n+  TypeInstKlassPtr(PTR ptr, ciKlass* klass, const InterfaceSet& interfaces, int offset)\n+    : TypeKlassPtr(InstKlassPtr, ptr, klass, interfaces, offset) {\n+    assert(klass->is_instance_klass() && (!klass->is_loaded() || !klass->is_interface()), \"\");\n@@ -1528,3 +1654,1 @@\n-    if (klass()->is_interface()) {\n-      return Compile::current()->env()->Object_klass();\n-    }\n+    assert(!klass()->is_interface(), \"\");\n@@ -1534,1 +1658,1 @@\n-  bool is_same_java_type_as(const TypeKlassPtr* other) const;\n+  bool is_same_java_type_as_helper(const TypeKlassPtr* other) const;\n@@ -1538,2 +1662,9 @@\n-  static const TypeInstKlassPtr *make(ciKlass* k) {\n-    return make(TypePtr::Constant, k, 0);\n+  static const TypeInstKlassPtr *make(ciKlass* k, InterfaceHandling interface_handling) {\n+    InterfaceSet interfaces = TypePtr::interfaces(k, true, true, false, interface_handling);\n+    return make(TypePtr::Constant, k, interfaces, 0);\n+  }\n+  static const TypeInstKlassPtr* make(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, int offset);\n+\n+  static const TypeInstKlassPtr* make(PTR ptr, ciKlass* k, int offset) {\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    return make(ptr, k, interfaces, offset);\n@@ -1541,1 +1672,0 @@\n-  static const TypeInstKlassPtr *make(PTR ptr, ciKlass* k, int offset);\n@@ -1557,1 +1687,1 @@\n-  bool is_interface() const { return klass()->is_interface(); }\n+  virtual const TypeKlassPtr* try_improve() const;\n@@ -1562,0 +1692,2 @@\n+private:\n+  virtual bool is_meet_subtype_of_helper(const TypeKlassPtr* other, bool this_xk, bool other_xk) const;\n@@ -1567,0 +1699,3 @@\n+  friend class Type;\n+  friend class TypePtr;\n+\n@@ -1569,0 +1704,1 @@\n+  static const InterfaceSet* _array_interfaces;\n@@ -1570,1 +1706,2 @@\n-    : TypeKlassPtr(AryKlassPtr, ptr, klass, offset), _elem(elem) {\n+    : TypeKlassPtr(AryKlassPtr, ptr, klass, *_array_interfaces, offset), _elem(elem) {\n+    assert(klass == NULL || klass->is_type_array_klass() || !klass->as_obj_array_klass()->base_element_klass()->is_interface(), \"\");\n@@ -1574,0 +1711,1 @@\n+  \/\/ Only guaranteed non null for array of basic types\n@@ -1583,1 +1721,1 @@\n-  static const TypeAryKlassPtr *make(PTR ptr, ciKlass* k, int offset);\n+  static const TypeAryKlassPtr *make(PTR ptr, ciKlass* k, int offset, InterfaceHandling interface_handling);\n@@ -1585,1 +1723,1 @@\n-  bool is_same_java_type_as(const TypeKlassPtr* other) const;\n+  bool is_same_java_type_as_helper(const TypeKlassPtr* other) const;\n@@ -1592,1 +1730,1 @@\n-  static const TypeAryKlassPtr* make(ciKlass* klass);\n+  static const TypeAryKlassPtr* make(ciKlass* klass, InterfaceHandling interface_handling);\n@@ -1619,0 +1757,2 @@\n+private:\n+  virtual bool is_meet_subtype_of_helper(const TypeKlassPtr* other, bool this_xk, bool other_xk) const;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":232,"deletions":92,"binary":false,"changes":324,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,2 +131,1 @@\n-    default:\n-      assert(false, \"Unexpected type\");\n+    default: fatal(\"Unexpected type: %s\", type2name(elem_bt));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -141,2 +141,0 @@\n-  SEARCH_SUPERCLASSES  = java_lang_invoke_MemberName::MN_SEARCH_SUPERCLASSES,\n-  SEARCH_INTERFACES    = java_lang_invoke_MemberName::MN_SEARCH_INTERFACES,\n@@ -935,110 +933,0 @@\n-int MethodHandles::find_MemberNames(Klass* k,\n-                                    Symbol* name, Symbol* sig,\n-                                    int mflags, Klass* caller,\n-                                    int skip, objArrayHandle results, TRAPS) {\n-  \/\/ %%% take caller into account!\n-\n-  if (k == NULL || !k->is_instance_klass())  return -1;\n-\n-  int rfill = 0, rlimit = results->length(), rskip = skip;\n-  \/\/ overflow measurement:\n-  int overflow = 0, overflow_limit = MAX2(1000, rlimit);\n-\n-  int match_flags = mflags;\n-  bool search_superc = ((match_flags & SEARCH_SUPERCLASSES) != 0);\n-  bool search_intfc  = ((match_flags & SEARCH_INTERFACES)   != 0);\n-  bool local_only = !(search_superc | search_intfc);\n-\n-  if (name != NULL) {\n-    if (name->utf8_length() == 0)  return 0; \/\/ a match is not possible\n-  }\n-  if (sig != NULL) {\n-    if (sig->starts_with(JVM_SIGNATURE_FUNC))\n-      match_flags &= ~(IS_FIELD | IS_TYPE);\n-    else\n-      match_flags &= ~(IS_CONSTRUCTOR | IS_METHOD);\n-  }\n-\n-  if ((match_flags & IS_TYPE) != 0) {\n-    \/\/ NYI, and Core Reflection works quite well for this query\n-  }\n-\n-  if ((match_flags & IS_FIELD) != 0) {\n-    InstanceKlass* ik = InstanceKlass::cast(k);\n-    for (FieldStream st(ik, local_only, !search_intfc); !st.eos(); st.next()) {\n-      if (name != NULL && st.name() != name)\n-          continue;\n-      if (sig != NULL && st.signature() != sig)\n-        continue;\n-      \/\/ passed the filters\n-      if (rskip > 0) {\n-        --rskip;\n-      } else if (rfill < rlimit) {\n-        Handle result(THREAD, results->obj_at(rfill++));\n-        if (!java_lang_invoke_MemberName::is_instance(result()))\n-          return -99;  \/\/ caller bug!\n-        oop saved = MethodHandles::init_field_MemberName(result, st.field_descriptor());\n-        if (saved != result())\n-          results->obj_at_put(rfill-1, saved);  \/\/ show saved instance to user\n-      } else if (++overflow >= overflow_limit) {\n-        match_flags = 0; break; \/\/ got tired of looking at overflow\n-      }\n-    }\n-  }\n-\n-  if ((match_flags & (IS_METHOD | IS_CONSTRUCTOR)) != 0) {\n-    \/\/ watch out for these guys:\n-    Symbol* init_name   = vmSymbols::object_initializer_name();\n-    Symbol* clinit_name = vmSymbols::class_initializer_name();\n-    if (name == clinit_name)  clinit_name = NULL; \/\/ hack for exposing <clinit>\n-    bool negate_name_test = false;\n-    \/\/ fix name so that it captures the intention of IS_CONSTRUCTOR\n-    if (!(match_flags & IS_METHOD)) {\n-      \/\/ constructors only\n-      if (name == NULL) {\n-        name = init_name;\n-      } else if (name != init_name) {\n-        return 0;               \/\/ no constructors of this method name\n-      }\n-    } else if (!(match_flags & IS_CONSTRUCTOR)) {\n-      \/\/ methods only\n-      if (name == NULL) {\n-        name = init_name;\n-        negate_name_test = true; \/\/ if we see the name, we *omit* the entry\n-      } else if (name == init_name) {\n-        return 0;               \/\/ no methods of this constructor name\n-      }\n-    } else {\n-      \/\/ caller will accept either sort; no need to adjust name\n-    }\n-    InstanceKlass* ik = InstanceKlass::cast(k);\n-    for (MethodStream st(ik, local_only, !search_intfc); !st.eos(); st.next()) {\n-      Method* m = st.method();\n-      Symbol* m_name = m->name();\n-      if (m_name == clinit_name)\n-        continue;\n-      if (name != NULL && ((m_name != name) ^ negate_name_test))\n-          continue;\n-      if (sig != NULL && m->signature() != sig)\n-        continue;\n-      \/\/ passed the filters\n-      if (rskip > 0) {\n-        --rskip;\n-      } else if (rfill < rlimit) {\n-        Handle result(THREAD, results->obj_at(rfill++));\n-        if (!java_lang_invoke_MemberName::is_instance(result()))\n-          return -99;  \/\/ caller bug!\n-        CallInfo info(m, NULL, CHECK_0);\n-        oop saved = MethodHandles::init_method_MemberName(result, info);\n-        if (saved != result())\n-          results->obj_at_put(rfill-1, saved);  \/\/ show saved instance to user\n-      } else if (++overflow >= overflow_limit) {\n-        match_flags = 0; break; \/\/ got tired of looking at overflow\n-      }\n-    }\n-  }\n-\n-  \/\/ return number of elements we at leasted wanted to initialize\n-  return rfill + overflow;\n-}\n-\n@@ -1120,2 +1008,0 @@\n-    template(java_lang_invoke_MemberName,MN_SEARCH_SUPERCLASSES) \\\n-    template(java_lang_invoke_MemberName,MN_SEARCH_INTERFACES) \\\n@@ -1329,43 +1215,0 @@\n-\n-\n-\/\/  static native int getMembers(Class<?> defc, String matchName, String matchSig,\n-\/\/          int matchFlags, Class<?> caller, int skip, MemberName[] results);\n-JVM_ENTRY(jint, MHN_getMembers(JNIEnv *env, jobject igcls,\n-                               jclass clazz_jh, jstring name_jh, jstring sig_jh,\n-                               int mflags, jclass caller_jh, jint skip, jobjectArray results_jh)) {\n-  if (clazz_jh == NULL || results_jh == NULL)  return -1;\n-  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz_jh));\n-\n-  objArrayHandle results(THREAD, (objArrayOop) JNIHandles::resolve(results_jh));\n-  if (results.is_null() || !results->is_objArray())  return -1;\n-\n-  TempNewSymbol name = NULL;\n-  TempNewSymbol sig = NULL;\n-  if (name_jh != NULL) {\n-    name = java_lang_String::as_symbol_or_null(JNIHandles::resolve_non_null(name_jh));\n-    if (name == NULL)  return 0; \/\/ a match is not possible\n-  }\n-  if (sig_jh != NULL) {\n-    sig = java_lang_String::as_symbol_or_null(JNIHandles::resolve_non_null(sig_jh));\n-    if (sig == NULL)  return 0; \/\/ a match is not possible\n-  }\n-\n-  Klass* caller = NULL;\n-  if (caller_jh != NULL) {\n-    oop caller_oop = JNIHandles::resolve_non_null(caller_jh);\n-    if (!java_lang_Class::is_instance(caller_oop))  return -1;\n-    caller = java_lang_Class::as_Klass(caller_oop);\n-  }\n-\n-  if (name != NULL && sig != NULL && results.not_null()) {\n-    \/\/ try a direct resolve\n-    \/\/ %%% TO DO\n-  }\n-\n-  int res = MethodHandles::find_MemberNames(k, name, sig, mflags,\n-                                            caller, skip, results, CHECK_0);\n-  \/\/ TO DO: expand at least some of the MemberNames, to avoid massive callbacks\n-  return res;\n-}\n-JVM_END\n-\n@@ -1546,3 +1389,0 @@\n-  \/\/  static native int getMembers(Class<?> defc, String matchName, String matchSig,\n-  \/\/          int matchFlags, Class<?> caller, int skip, MemberName[] results);\n-  {CC \"getMembers\",                CC \"(\" CLS \"\" STRG \"\" STRG \"I\" CLS \"I[\" MEM \")I\", FN_PTR(MHN_getMembers)},\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":0,"deletions":160,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -73,3 +73,0 @@\n-  static int find_MemberNames(Klass* k, Symbol* name, Symbol* sig,\n-                              int mflags, Klass* caller,\n-                              int skip, objArrayHandle results, TRAPS);\n","filename":"src\/hotspot\/share\/prims\/methodHandles.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"metaprogramming\/isIntegral.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"metaprogramming\/isSigned.hpp\"\n@@ -35,1 +35,0 @@\n-#include \"metaprogramming\/removePointer.hpp\"\n@@ -396,1 +395,1 @@\n-  typename EnableIf<IsIntegral<T>::value || IsPointer<T>::value>::type>\n+  typename EnableIf<std::is_integral<T>::value || IsPointer<T>::value>::type>\n@@ -448,1 +447,1 @@\n-  typename EnableIf<IsIntegral<T>::value>::type>\n+  typename EnableIf<std::is_integral<T>::value>::type>\n@@ -513,1 +512,1 @@\n-  STATIC_ASSERT(IsPointer<D>::value || IsIntegral<D>::value);\n+  STATIC_ASSERT(IsPointer<D>::value || std::is_integral<D>::value);\n@@ -520,1 +519,1 @@\n-  STATIC_ASSERT(IsPointer<D>::value || IsIntegral<D>::value);\n+  STATIC_ASSERT(IsPointer<D>::value || std::is_integral<D>::value);\n@@ -529,2 +528,2 @@\n-  STATIC_ASSERT(IsPointer<D>::value || IsIntegral<D>::value);\n-  STATIC_ASSERT(IsIntegral<I>::value);\n+  STATIC_ASSERT(IsPointer<D>::value || std::is_integral<D>::value);\n+  STATIC_ASSERT(std::is_integral<I>::value);\n@@ -679,2 +678,2 @@\n-  typename EnableIf<IsIntegral<I>::value &&\n-                    IsIntegral<D>::value &&\n+  typename EnableIf<std::is_integral<I>::value &&\n+                    std::is_integral<D>::value &&\n@@ -697,1 +696,1 @@\n-  typename EnableIf<IsIntegral<I>::value && (sizeof(I) <= sizeof(P*))>::type>\n+  typename EnableIf<std::is_integral<I>::value && (sizeof(I) <= sizeof(P*))>::type>\n@@ -772,1 +771,1 @@\n-  typename EnableIf<IsIntegral<T>::value>::type>\n+  typename EnableIf<std::is_integral<T>::value>::type>\n@@ -907,1 +906,1 @@\n-  typename EnableIf<IsIntegral<T>::value>::type>\n+  typename EnableIf<std::is_integral<T>::value>::type>\n","filename":"src\/hotspot\/share\/runtime\/atomic.hpp","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -212,1 +212,2 @@\n-bool Monitor::wait_without_safepoint_check(int64_t timeout) {\n+\/\/ timeout is in milliseconds - with zero meaning never timeout\n+bool Monitor::wait_without_safepoint_check(uint64_t timeout) {\n@@ -215,2 +216,0 @@\n-  \/\/ timeout is in milliseconds - with zero meaning never timeout\n-  assert(timeout >= 0, \"negative timeout\");\n@@ -232,1 +231,2 @@\n-bool Monitor::wait(int64_t timeout) {\n+\/\/ timeout is in milliseconds - with zero meaning never timeout\n+bool Monitor::wait(uint64_t timeout) {\n@@ -237,2 +237,0 @@\n-  \/\/ timeout is in milliseconds - with zero meaning never timeout\n-  assert(timeout >= 0, \"negative timeout\");\n","filename":"src\/hotspot\/share\/runtime\/mutex.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,2 +215,2 @@\n-  bool wait(int64_t timeout = 0);\n-  bool wait_without_safepoint_check(int64_t timeout = 0);\n+  bool wait(uint64_t timeout = 0);\n+  bool wait_without_safepoint_check(uint64_t timeout = 0);\n","filename":"src\/hotspot\/share\/runtime\/mutex.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -503,0 +503,1 @@\n+  static bool   numa_get_group_ids_for_range(const void** addresses, int* lgrp_ids, size_t count);\n@@ -509,1 +510,0 @@\n-  static bool   get_page_info(char *start, page_info* info);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -118,2 +118,2 @@\n-  \/\/ an nmethod gets disarmed. The low order 32 bit denote the disarm value.\n-  uint64_t _nmethod_disarm_value;\n+  \/\/ an nmethod gets disarmed. The low order 32 bits denote the disarmed value.\n+  uint64_t _nmethod_disarmed_guard_value;\n@@ -122,2 +122,2 @@\n-  void set_nmethod_disarm_value(int value) {\n-    _nmethod_disarm_value = (uint64_t)(uint32_t)value;\n+  void set_nmethod_disarmed_guard_value(int value) {\n+    _nmethod_disarmed_guard_value = (uint64_t)(uint32_t)value;\n@@ -126,2 +126,2 @@\n-  static ByteSize nmethod_disarmed_offset() {\n-    ByteSize offset = byte_offset_of(Thread, _nmethod_disarm_value);\n+  static ByteSize nmethod_disarmed_guard_value_offset() {\n+    ByteSize offset = byte_offset_of(Thread, _nmethod_disarmed_guard_value);\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2428,0 +2428,2 @@\n+    event.set_overwrite(overwrite);\n+    event.set_compression(compression);\n@@ -2429,0 +2431,2 @@\n+  } else {\n+    log_debug(cds, heap)(\"Error %s while dumping heap\", error());\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"metaprogramming\/isIntegral.hpp\"\n@@ -35,0 +34,2 @@\n+#include <type_traits>\n+\n@@ -50,1 +51,1 @@\n-  STATIC_ASSERT(IsIntegral<T>::value);\n+  STATIC_ASSERT(std::is_integral<T>::value);\n","filename":"src\/hotspot\/share\/utilities\/population_count.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.Objects;\n@@ -100,4 +101,2 @@\n-        if ((off < 0) || (off > c.length) || (len < 0) ||\n-            ((off + len) > c.length) || ((off + len) < 0)) {\n-            throw new IndexOutOfBoundsException();\n-        } else if (len == 0) {\n+        Objects.checkFromIndexSize(off, len, c.length);\n+        if (len == 0) {\n","filename":"src\/java.base\/share\/classes\/java\/io\/CharArrayWriter.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -387,1 +387,7 @@\n-            \/\/ Try loading providers\n+            \/*\n+             * The JdkConsole provider used for Console instantiation can be specified\n+             * with the system property \"jdk.console\", whose value designates the module\n+             * name of the implementation, and which defaults to \"java.base\". If no\n+             * providers are available, or instantiation failed, java.base built-in\n+             * Console implementation is used.\n+             *\/\n","filename":"src\/java.base\/share\/classes\/java\/io\/Console.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.util.Objects;\n+\n@@ -134,2 +136,1 @@\n-        if ((off | len | (b.length - (len + off)) | (off + len)) < 0)\n-            throw new IndexOutOfBoundsException();\n+        Objects.checkFromIndexSize(off, len, b.length);\n","filename":"src\/java.base\/share\/classes\/java\/io\/FilterOutputStream.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    private static final int DEFAULT_BUFFER_SIZE = 8192;\n+    private static final int DEFAULT_BUFFER_SIZE = 16384;\n","filename":"src\/java.base\/share\/classes\/java\/io\/InputStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.util.Objects;\n+\n@@ -132,4 +134,3 @@\n-        } else if ((off < 0) || (off > b.length) || (len < 0) ||\n-                   ((off + len) > b.length) || ((off + len) < 0)) {\n-            throw new IndexOutOfBoundsException();\n-        } else if (len == 0) {\n+        }\n+        Objects.checkFromIndexSize(off, len, b.length);\n+        if (len == 0) {\n","filename":"src\/java.base\/share\/classes\/java\/io\/LineNumberInputStream.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import java.io.*;\n+import java.util.Objects;\n@@ -147,4 +147,3 @@\n-        } else if ((off < 0) || (off > b.length) || (len < 0) ||\n-                   ((off + len) > b.length) || ((off + len) < 0)) {\n-            throw new IndexOutOfBoundsException();\n-        } else if (len == 0) {\n+        }\n+        Objects.checkFromIndexSize(off, len, b.length);\n+        if (len == 0) {\n","filename":"src\/java.base\/share\/classes\/java\/io\/PipedOutputStream.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.util.Objects;\n+\n@@ -153,2 +155,0 @@\n-        } else if ((off | len | (off + len) | (cbuf.length - (off + len))) < 0) {\n-            throw new IndexOutOfBoundsException();\n@@ -156,0 +156,1 @@\n+        Objects.checkFromIndexSize(off, len, cbuf.length);\n","filename":"src\/java.base\/share\/classes\/java\/io\/PipedWriter.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.util.Objects;\n+\n@@ -93,4 +95,2 @@\n-        if ((off < 0) || (off > cbuf.length) || (len < 0) ||\n-            ((off + len) > cbuf.length) || ((off + len) < 0)) {\n-            throw new IndexOutOfBoundsException();\n-        } else if (len == 0) {\n+        Objects.checkFromIndexSize(off, len, cbuf.length);\n+        if (len == 0) {\n","filename":"src\/java.base\/share\/classes\/java\/io\/StringWriter.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- *     x[0] = new Integer(0);\n+ *     x[0] = Integer.valueOf(0);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ArrayStoreException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -236,1 +236,1 @@\n-     * {@code new Byte(Byte.parseByte(s, radix))}\n+     * {@code Byte.valueOf(Byte.parseByte(s, radix))}\n@@ -265,1 +265,1 @@\n-     * {@code new Byte(Byte.parseByte(s))}\n+     * {@code Byte.valueOf(Byte.parseByte(s))}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Byte.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1263,1 +1263,1 @@\n-     *    new Double(d1).compareTo(new Double(d2))\n+     *    Double.valueOf(d1).compareTo(Double.valueOf(d2))\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1221,1 +1221,1 @@\n-     *    new Float(f1).compareTo(new Float(f2))\n+     *    Float.valueOf(f1).compareTo(Float.valueOf(f2))\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -954,1 +954,1 @@\n-     *  {@code new Integer(Integer.parseInt(s, radix))}\n+     *  {@code Integer.valueOf(Integer.parseInt(s, radix))}\n@@ -982,1 +982,1 @@\n-     *  {@code new Integer(Integer.parseInt(s))}\n+     *  {@code Integer.valueOf(Integer.parseInt(s))}\n@@ -1289,1 +1289,1 @@\n-     *  {@code getInteger(nm, new Integer(val))}\n+     *  {@code getInteger(nm, Integer.valueOf(val))}\n@@ -1296,1 +1296,1 @@\n-     * return (result == null) ? new Integer(val) : result;\n+     * return (result == null) ? Integer.valueOf(val) : result;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1117,1 +1117,1 @@\n-     *  {@code new Long(Long.parseLong(s, radix))}\n+     *  {@code Long.valueOf(Long.parseLong(s, radix))}\n@@ -1145,1 +1145,1 @@\n-     *  {@code new Long(Long.parseLong(s))}\n+     *  {@code Long.valueOf(Long.parseLong(s))}\n@@ -1512,1 +1512,1 @@\n-     *  {@code getLong(nm, new Long(val))}\n+     *  {@code getLong(nm, Long.valueOf(val))}\n@@ -1519,1 +1519,1 @@\n-     * return (result == null) ? new Long(val) : result;\n+     * return (result == null) ? Long.valueOf(val) : result;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1007,0 +1007,2 @@\n+     * The minimal set of system dependent environment variables\n+     * may override the values provided in the environment.\n@@ -1184,0 +1186,2 @@\n+     * The minimal set of system dependent environment variables\n+     * may override the values provided in the environment.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ProcessBuilder.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -572,0 +572,2 @@\n+     * The minimal set of system dependent environment variables\n+     * may override the values provided in the environment.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Runtime.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -180,1 +180,1 @@\n-     *  {@code new Short(Short.parseShort(s, radix))}\n+     *  {@code Short.valueOf(Short.parseShort(s, radix))}\n@@ -209,1 +209,1 @@\n-     *  {@code new Short(Short.parseShort(s))}\n+     *  {@code Short.valueOf(Short.parseShort(s))}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Short.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,1 +123,2 @@\n-     * <p>This implementation simply returns {@code null}; if the\n+     * @implSpec\n+     * This implementation simply returns {@code null}; if the\n@@ -125,3 +126,4 @@\n-     * value other than {@code null}, {@code ThreadLocal} must be\n-     * subclassed, and this method overridden.  Typically, an\n-     * anonymous inner class will be used.\n+     * value other than {@code null}, then either {@code ThreadLocal}\n+     * can be subclassed and this method overridden or the method\n+     * {@link ThreadLocal#withInitial(Supplier)} can be used to\n+     * construct a {@code ThreadLocal}.\n@@ -130,0 +132,1 @@\n+     * @see #withInitial(java.util.function.Supplier)\n@@ -162,2 +165,1 @@\n-     * this method returns its {@link #initialValue} (or {@code null}\n-     * if the {@code initialValue} method is not overridden).\n+     * this method returns its {@link #initialValue}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ThreadLocal.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -305,2 +305,2 @@\n-         * parameter directly following the target address parameter. This memory segment must be a\n-         * native segment into which the captured state is written.\n+         * parameter directly following the target address, and optional {@link SegmentAllocator} parameters.\n+         * This memory segment must be a native segment into which the captured state is written.\n@@ -325,0 +325,4 @@\n+         * For this purpose, a downcall method handle linked with the {@link #captureCallState(String[])}\n+         * option will feature an additional {@link MemorySegment} parameter directly\n+         * following the target address, and optional {@link SegmentAllocator} parameters.\n+         * This parameter represents the native segment into which the captured state is written.\n@@ -347,0 +351,1 @@\n+        @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1737,0 +1737,1 @@\n+     * @throws UnsupportedOperationException if {@code value} is not a {@linkplain #isNative() native} segment.\n@@ -2082,0 +2083,1 @@\n+     * @throws UnsupportedOperationException if {@code value} is not a {@linkplain #isNative() native} segment.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -497,2 +497,1 @@\n-            throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n-                    + ad.symbolicMethodTypeExact);\n+            throw newWrongMethodTypeException(handle.accessModeType(ad.type), ad.symbolicMethodTypeExact);\n@@ -521,1 +520,1 @@\n-    static WrongMethodTypeException newWrongMethodTypeException(MethodType actual, MethodType expected) {\n+    static WrongMethodTypeException newWrongMethodTypeException(MethodType targetType, MethodType callSiteType) {\n@@ -523,1 +522,1 @@\n-        return new WrongMethodTypeException(\"expected \"+expected+\" but found \"+actual);\n+        return new WrongMethodTypeException(\"handle's method type \" + targetType + \" but found \" + callSiteType);\n@@ -530,3 +529,3 @@\n-        MethodType actual = mh.type();\n-        if (actual != expected)\n-            throw newWrongMethodTypeException(expected, actual);\n+        MethodType targetType = mh.type();\n+        if (targetType != expected)\n+            throw newWrongMethodTypeException(targetType, expected);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/Invokers.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -55,2 +55,0 @@\n-    static native int getMembers(Class<?> defc, String matchName, String matchSig,\n-            int matchFlags, Class<?> caller, int skip, MemberName[] results);\n@@ -122,4 +120,1 @@\n-            MN_REFERENCE_KIND_MASK = 0x0F000000 >> MN_REFERENCE_KIND_SHIFT,\n-            \/\/ The SEARCH_* bits are not for MN.flags but for the matchFlags argument of MHN.getMembers:\n-            MN_SEARCH_SUPERCLASSES = 0x00100000,\n-            MN_SEARCH_INTERFACES   = 0x00200000;\n+            MN_REFERENCE_KIND_MASK = 0x0F000000 >> MN_REFERENCE_KIND_SHIFT;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -7934,1 +7934,1 @@\n-     * Finally, in all other cases, we say that a memory access operation is <em>misaligned<\/em>; in such cases an\n+     * In all other cases, we say that a memory access operation is <em>misaligned<\/em>; in such cases an\n@@ -7936,0 +7936,3 @@\n+     * <p>\n+     * Finally, if {@code T} is {@code MemorySegment} all write access modes throw {@link IllegalArgumentException}\n+     * unless the value to be written is a {@linkplain MemorySegment#isNative() native} memory segment.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2086,2 +2086,2 @@\n-        throw new WrongMethodTypeException(\"expected \" + accessModeType(ad.type) + \" but found \"\n-                + ad.symbolicMethodTypeExact);\n+        throw new WrongMethodTypeException(\"handle's method type \" + accessModeType(ad.type)\n+                + \" but found \" + ad.symbolicMethodTypeExact);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,2 +127,2 @@\n-        \/\/ update the Sockets impl to the impl from the http Socket\n-        SocketImpl si = httpSocket.impl;\n+        \/\/ change Socket to use httpSocket's SocketImpl\n+        SocketImpl si = httpSocket.impl();\n","filename":"src\/java.base\/share\/classes\/java\/net\/HttpConnectSocketImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,3 +81,1 @@\n-    \/**\n-     * The underlying SocketImpl\n-     *\/\n+    \/\/ the underlying SocketImpl\n@@ -86,3 +84,1 @@\n-    \/**\n-     * Various states of this socket, need stateLock to change.\n-     *\/\n+    \/\/ various states\n@@ -92,1 +88,10 @@\n-    private final Object stateLock = new Object();\n+\n+    \/\/ used to coordinate creating and closing underlying socket\n+    private final Object socketLock = new Object();\n+\n+    \/**\n+     * Creates a server socket with the given {@code SocketImpl}.\n+     *\/\n+    private ServerSocket(Void unused, SocketImpl impl) {\n+        this.impl = Objects.requireNonNull(impl);\n+    }\n@@ -107,3 +112,1 @@\n-        Objects.requireNonNull(impl);\n-        checkPermission();\n-        this.impl = impl;\n+        this(checkPermission(), impl);\n@@ -283,6 +286,16 @@\n-     * Get the {@code SocketImpl} attached to this socket, creating\n-     * it if necessary.\n-     *\n-     * @return  the {@code SocketImpl} attached to that ServerSocket.\n-     * @throws SocketException if creation fails.\n-     * @since 1.4\n+     * Create a SocketImpl for a server socket. The SocketImpl is created\n+     * without an underlying socket.\n+     *\/\n+    private static SocketImpl createImpl() {\n+        SocketImplFactory factory = ServerSocket.factory;\n+        if (factory != null) {\n+            return factory.createSocketImpl();\n+        } else {\n+            return SocketImpl.createPlatformSocketImpl(true);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the {@code SocketImpl} for this ServerSocket, creating the\n+     * underlying socket if required.\n+     * @throws SocketException if creating the underlying socket fails\n@@ -292,1 +305,1 @@\n-            synchronized (stateLock) {\n+            synchronized (socketLock) {\n@@ -311,12 +324,0 @@\n-    \/**\n-     * Create a SocketImpl for a server socket.\n-     *\/\n-    private static SocketImpl createImpl() {\n-        SocketImplFactory factory = ServerSocket.factory;\n-        if (factory != null) {\n-            return factory.createSocketImpl();\n-        } else {\n-            return SocketImpl.createPlatformSocketImpl(true);\n-        }\n-    }\n-\n@@ -388,9 +389,5 @@\n-        synchronized (stateLock) {\n-            if (closed)\n-                throw new SocketException(\"Socket is closed\");\n-            if (bound)\n-                throw new SocketException(\"Already bound\");\n-            getImpl().bind(epoint.getAddress(), epoint.getPort());\n-            getImpl().listen(backlog);\n-            bound = true;\n-        }\n+        \/\/ SocketImpl bind+listen throw if already bound or closed\n+        SocketImpl impl = getImpl();\n+        impl.bind(epoint.getAddress(), epoint.getPort());\n+        impl.listen(backlog);\n+        bound = true;\n@@ -584,1 +581,1 @@\n-        SocketImpl si = s.impl;\n+        SocketImpl si = s.impl();\n@@ -589,2 +586,7 @@\n-            s.setImpl(si);\n-            s.postAccept();\n+            try {\n+                s.setConnectedImpl(si);\n+            } catch (SocketException e) {\n+                \/\/ s has been closed so newly accepted connection needs to be closed\n+                si.closeQuietly();\n+                throw e;\n+            }\n@@ -595,2 +597,2 @@\n-        if (si instanceof DelegatingSocketImpl) {\n-            si = ((DelegatingSocketImpl) si).delegate();\n+        if (si instanceof DelegatingSocketImpl dsi) {\n+            si = dsi.delegate();\n@@ -612,2 +614,7 @@\n-            s.setImpl(psi);\n-            si.closeQuietly();\n+            try {\n+                s.setConnectedImpl(psi);\n+            } catch (SocketException e) {\n+                \/\/ s has been closed so newly accepted connection needs to be closed\n+                psi.closeQuietly();\n+                throw e;\n+            }\n@@ -615,1 +622,1 @@\n-            s.impl = null; \/\/ temporarily break connection to impl\n+            s.setImpl(null);    \/\/ temporarily break connection to impl\n@@ -619,1 +626,1 @@\n-                s.impl = si;  \/\/ restore connection to impl\n+                s.setImpl(si);  \/\/ restore connection to impl\n@@ -621,0 +628,1 @@\n+            s.setConnected();\n@@ -622,1 +630,1 @@\n-        s.postAccept();\n+\n@@ -739,1 +747,1 @@\n-        synchronized (stateLock) {\n+        synchronized (socketLock) {\n@@ -833,2 +841,2 @@\n-        if (o instanceof Integer) {\n-            return ((Integer) o).intValue();\n+        if (o instanceof Integer i) {\n+            return i.intValue();\n@@ -1013,2 +1021,2 @@\n-     public void setReceiveBufferSize (int size) throws SocketException {\n-        if (!(size > 0)) {\n+    public void setReceiveBufferSize(int size) throws SocketException {\n+        if (size <= 0)\n@@ -1016,1 +1024,0 @@\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/net\/ServerSocket.java","additions":62,"deletions":55,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,22 +101,1 @@\n-    \/**\n-     * Various states of this socket.\n-     *\/\n-    private boolean created = false;\n-    private boolean bound = false;\n-    private boolean connected = false;\n-    private boolean closed = false;\n-    private Object closeLock = new Object();\n-    private boolean shutIn = false;\n-    private boolean shutOut = false;\n-\n-    \/**\n-     * The implementation of this Socket.\n-     *\/\n-    SocketImpl impl;\n-\n-    \/**\n-     * Socket input\/output streams\n-     *\/\n-    private volatile InputStream in;\n-    private volatile OutputStream out;\n-    private static final VarHandle IN, OUT;\n+    private static final VarHandle STATE, IN, OUT;\n@@ -126,0 +105,1 @@\n+            STATE = l.findVarHandle(Socket.class, \"state\", int.class);\n@@ -133,0 +113,57 @@\n+    \/\/ the underlying SocketImpl, may be null, may be swapped when connecting\n+    private volatile SocketImpl impl;\n+\n+    \/\/ state bits\n+    private static final int SOCKET_CREATED = 1 << 0;   \/\/ impl.create(boolean) called\n+    private static final int BOUND          = 1 << 1;\n+    private static final int CONNECTED      = 1 << 2;\n+    private static final int CLOSED         = 1 << 3;\n+    private static final int SHUT_IN        = 1 << 9;\n+    private static final int SHUT_OUT       = 1 << 10;\n+    private volatile int state;\n+\n+    \/\/ used to coordinate creating and closing underlying socket\n+    private final Object socketLock = new Object();\n+\n+    \/\/ input\/output streams\n+    private volatile InputStream in;\n+    private volatile OutputStream out;\n+\n+    \/**\n+     * Atomically sets state to the result of a bitwise OR of the current value\n+     * and the given mask.\n+     * @return the previous state value\n+     *\/\n+    private int getAndBitwiseOrState(int mask) {\n+        return (int) STATE.getAndBitwiseOr(this, mask);\n+    }\n+\n+    private static boolean isBound(int s) {\n+        return (s & BOUND) != 0;\n+    }\n+\n+    private static boolean isConnected(int s) {\n+        return (s & CONNECTED) != 0;\n+    }\n+\n+    private static boolean isClosed(int s) {\n+        return (s & CLOSED) != 0;\n+    }\n+\n+    private static boolean isInputShutdown(int s) {\n+        return (s & SHUT_IN) != 0;\n+    }\n+\n+    private static boolean isOutputShutdown(int s) {\n+        return (s & SHUT_OUT) != 0;\n+    }\n+\n+    \/**\n+     * Creates an unconnected socket with the given {@code SocketImpl}.\n+     *\/\n+    private Socket(Void unused, SocketImpl impl) {\n+        if (impl != null) {\n+            this.impl = impl;\n+        }\n+    }\n+\n@@ -145,1 +182,1 @@\n-        setImpl();\n+        this.impl = createImpl();\n@@ -235,2 +272,1 @@\n-        checkPermission(impl);\n-        this.impl = impl;\n+        this(checkPermission(impl), impl);\n@@ -240,7 +276,6 @@\n-        if (impl == null) {\n-            return null;\n-        }\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(SecurityConstants.SET_SOCKETIMPL_PERMISSION);\n+        if (impl != null) {\n+            @SuppressWarnings(\"removal\")\n+            SecurityManager sm = System.getSecurityManager();\n+            if (sm != null) {\n+                sm.checkPermission(SecurityConstants.SET_SOCKETIMPL_PERMISSION);\n+            }\n@@ -497,3 +532,12 @@\n-    private Socket(SocketAddress address, SocketAddress localAddr,\n-                   boolean stream) throws IOException {\n-        setImpl();\n+    \/**\n+     * Initialize a new Socket that is connected to the given remote address.\n+     * The socket is optionally bound to a local address before connecting.\n+     *\n+     * @param address the remote address to connect to\n+     * @param localAddr the local address to bind to, can be null\n+     * @param stream true for a stream socket, false for a datagram socket\n+     *\/\n+    private Socket(SocketAddress address, SocketAddress localAddr, boolean stream)\n+        throws IOException\n+    {\n+        Objects.requireNonNull(address);\n@@ -501,3 +545,6 @@\n-        \/\/ backward compatibility\n-        if (address == null)\n-            throw new NullPointerException();\n+        \/\/ create the SocketImpl and the underlying socket\n+        SocketImpl impl = createImpl();\n+        impl.create(stream);\n+\n+        this.impl = impl;\n+        this.state = SOCKET_CREATED;\n@@ -506,1 +553,0 @@\n-            createImpl(stream);\n@@ -521,6 +567,2 @@\n-     * Creates the socket implementation.\n-     *\n-     * @param stream a {@code boolean} value : {@code true} for a TCP socket,\n-     *               {@code false} for UDP.\n-     * @throws SocketException if creation fails\n-     * @since 1.4\n+     * Create a new SocketImpl for a connecting\/client socket. The SocketImpl\n+     * is created without an underlying socket.\n@@ -528,10 +570,8 @@\n-     void createImpl(boolean stream) throws SocketException {\n-        if (impl == null)\n-            setImpl();\n-        try {\n-            impl.create(stream);\n-            created = true;\n-        } catch (SocketException e) {\n-            throw e;\n-        } catch (IOException e) {\n-            throw new SocketException(e.getMessage(), e);\n+    private static SocketImpl createImpl() {\n+        SocketImplFactory factory = Socket.factory;\n+        if (factory != null) {\n+            return factory.createSocketImpl();\n+        } else {\n+            \/\/ create a SOCKS SocketImpl that delegates to a platform SocketImpl\n+            SocketImpl delegate = SocketImpl.createPlatformSocketImpl(false);\n+            return new SocksSocketImpl(delegate);\n@@ -541,2 +581,29 @@\n-    void setImpl(SocketImpl si) {\n-         impl = si;\n+    \/**\n+     * Returns the {@code SocketImpl} for this Socket, creating it, and the\n+     * underlying socket, if required.\n+     * @throws SocketException if creating the underlying socket fails\n+     *\/\n+    private SocketImpl getImpl() throws SocketException {\n+        if ((state & SOCKET_CREATED) == 0) {\n+            synchronized (socketLock) {\n+                int s = state;   \/\/ re-read state\n+                if ((s & SOCKET_CREATED) == 0) {\n+                    if (isClosed(s)) {\n+                        throw new SocketException(\"Socket is closed\");\n+                    }\n+                    SocketImpl impl = this.impl;\n+                    if (impl == null) {\n+                        this.impl = impl = createImpl();\n+                    }\n+                    try {\n+                        impl.create(true);\n+                    } catch (SocketException e) {\n+                        throw e;\n+                    } catch (IOException e) {\n+                        throw new SocketException(e.getMessage(), e);\n+                    }\n+                    getAndBitwiseOrState(SOCKET_CREATED);\n+                }\n+            }\n+        }\n+        return impl;\n@@ -546,2 +613,1 @@\n-     * Sets impl to the system-default type of SocketImpl.\n-     * @since 1.4\n+     * Returns the SocketImpl, may be null.\n@@ -549,8 +615,24 @@\n-    void setImpl() {\n-        SocketImplFactory factory = Socket.factory;\n-        if (factory != null) {\n-            impl = factory.createSocketImpl();\n-        } else {\n-            \/\/ create a SOCKS SocketImpl that delegates to a platform SocketImpl\n-            SocketImpl delegate = SocketImpl.createPlatformSocketImpl(false);\n-            impl = new SocksSocketImpl(delegate);\n+    SocketImpl impl() {\n+        return impl;\n+    }\n+\n+    \/**\n+     * Sets the SocketImpl. The SocketImpl is connected to a peer. The behavior for\n+     * the case that the Socket was not a newly created Socket is unspecified. If\n+     * there is an existing SocketImpl then it closed to avoid leaking resources.\n+     * @throws SocketException if the Socket is closed\n+     * @apiNote For ServerSocket use when accepting connections\n+     *\/\n+    void setConnectedImpl(SocketImpl si) throws SocketException {\n+        synchronized (socketLock) {\n+            if ((state & CLOSED) != 0) {\n+                throw new SocketException(\"Socket is closed\");\n+            }\n+            SocketImpl previous = impl;\n+            impl = si;\n+            state = (SOCKET_CREATED | BOUND | CONNECTED);\n+            if (previous != null) {\n+                in = null;\n+                out = null;\n+                previous.closeQuietly();\n+            }\n@@ -561,6 +643,2 @@\n-     * Get the {@code SocketImpl} attached to this socket, creating\n-     * it if necessary.\n-     *\n-     * @return  the {@code SocketImpl} attached to that ServerSocket.\n-     * @throws SocketException if creation fails\n-     * @since 1.4\n+     * Sets the SocketImpl.\n+     * @apiNote For ServerSocket use when accepting connections with a custom SocketImpl\n@@ -568,4 +646,10 @@\n-    SocketImpl getImpl() throws SocketException {\n-        if (!created)\n-            createImpl(true);\n-        return impl;\n+    void setImpl(SocketImpl si) {\n+        impl = si;\n+    }\n+\n+    \/**\n+     * Sets to Socket state for a newly accepted connection.\n+     * @apiNote For ServerSocket use when accepting connections with a custom SocketImpl\n+     *\/\n+    void setConnected() {\n+        getAndBitwiseOrState(SOCKET_CREATED | BOUND | CONNECTED);\n@@ -642,1 +726,1 @@\n-          throw new IllegalArgumentException(\"connect: timeout can't be negative\");\n+            throw new IllegalArgumentException(\"connect: timeout can't be negative\");\n@@ -644,1 +728,2 @@\n-        if (isClosed())\n+        int s = state;\n+        if (isClosed(s))\n@@ -646,2 +731,1 @@\n-\n-        if (isConnected())\n+        if (isConnected(s))\n@@ -653,1 +737,1 @@\n-        InetAddress addr = epoint.getAddress ();\n+        InetAddress addr = epoint.getAddress();\n@@ -665,2 +749,1 @@\n-        if (!created)\n-            createImpl(true);\n+\n@@ -668,1 +751,1 @@\n-            impl.connect(epoint, timeout);\n+            getImpl().connect(epoint, timeout);\n@@ -679,6 +762,3 @@\n-        connected = true;\n-        \/*\n-         * If the socket was not bound before the connect, it is now because\n-         * the kernel will have picked an ephemeral port & a local address\n-         *\/\n-        bound = true;\n+\n+        \/\/ connect will bind the socket if not previously bound\n+        getAndBitwiseOrState(BOUND | CONNECTED);\n@@ -706,1 +786,2 @@\n-        if (isClosed())\n+        int s = state;\n+        if (isClosed(s))\n@@ -708,1 +789,1 @@\n-        if (isBound())\n+        if (isBound(s))\n@@ -727,2 +808,2 @@\n-        getImpl().bind (addr, port);\n-        bound = true;\n+        getImpl().bind(addr, port);\n+        getAndBitwiseOrState(BOUND);\n@@ -731,1 +812,1 @@\n-    private void checkAddress (InetAddress addr, String op) {\n+    private void checkAddress(InetAddress addr, String op) {\n@@ -740,9 +821,0 @@\n-    \/**\n-     * set the flags after an accept() call.\n-     *\/\n-    final void postAccept() {\n-        connected = true;\n-        created = true;\n-        bound = true;\n-    }\n-\n@@ -899,1 +971,0 @@\n-\n@@ -987,1 +1058,2 @@\n-        if (isClosed())\n+        int s = state;\n+        if (isClosed(s))\n@@ -989,1 +1061,1 @@\n-        if (!isConnected())\n+        if (!isConnected(s))\n@@ -991,1 +1063,1 @@\n-        if (isInputShutdown())\n+        if (isInputShutdown(s))\n@@ -1083,1 +1155,2 @@\n-        if (isClosed())\n+        int s = state;\n+        if (isClosed(s))\n@@ -1085,1 +1158,1 @@\n-        if (!isConnected())\n+        if (!isConnected(s))\n@@ -1087,1 +1160,1 @@\n-        if (isOutputShutdown())\n+        if (isOutputShutdown(s))\n@@ -1221,2 +1294,2 @@\n-        if (o instanceof Integer) {\n-            return ((Integer) o).intValue();\n+        if (o instanceof Integer i) {\n+            return i.intValue();\n@@ -1238,2 +1311,2 @@\n-    public void sendUrgentData (int data) throws IOException  {\n-        if (!getImpl().supportsUrgentData ()) {\n+    public void sendUrgentData(int data) throws IOException {\n+        if (!getImpl().supportsUrgentData()) {\n@@ -1310,1 +1383,1 @@\n-    public synchronized void setSoTimeout(int timeout) throws SocketException {\n+    public void setSoTimeout(int timeout) throws SocketException {\n@@ -1314,2 +1387,1 @@\n-          throw new IllegalArgumentException(\"timeout can't be negative\");\n-\n+            throw new IllegalArgumentException(\"timeout can't be negative\");\n@@ -1330,1 +1402,1 @@\n-    public synchronized int getSoTimeout() throws SocketException {\n+    public int getSoTimeout() throws SocketException {\n@@ -1335,2 +1407,2 @@\n-        if (o instanceof Integer) {\n-            return ((Integer) o).intValue();\n+        if (o instanceof Integer i) {\n+            return i.intValue();\n@@ -1365,3 +1437,2 @@\n-    public synchronized void setSendBufferSize(int size)\n-    throws SocketException{\n-        if (!(size > 0)) {\n+    public void setSendBufferSize(int size) throws SocketException {\n+        if (size <= 0)\n@@ -1369,1 +1440,0 @@\n-        }\n@@ -1388,1 +1458,1 @@\n-    public synchronized int getSendBufferSize() throws SocketException {\n+    public int getSendBufferSize() throws SocketException {\n@@ -1393,2 +1463,2 @@\n-        if (o instanceof Integer) {\n-            result = ((Integer)o).intValue();\n+        if (o instanceof Integer i) {\n+            result = i.intValue();\n@@ -1439,3 +1509,2 @@\n-    public synchronized void setReceiveBufferSize(int size)\n-    throws SocketException{\n-        if (size <= 0) {\n+    public void setReceiveBufferSize(int size) throws SocketException {\n+        if (size <= 0)\n@@ -1443,1 +1512,0 @@\n-        }\n@@ -1461,2 +1529,1 @@\n-    public synchronized int getReceiveBufferSize()\n-    throws SocketException{\n+    public int getReceiveBufferSize() throws SocketException {\n@@ -1467,2 +1534,2 @@\n-        if (o instanceof Integer) {\n-            result = ((Integer)o).intValue();\n+        if (o instanceof Integer i) {\n+            result = i.intValue();\n@@ -1553,1 +1620,0 @@\n-\n@@ -1556,8 +1622,1 @@\n-        try {\n-            getImpl().setOption(SocketOptions.IP_TOS, tc);\n-        } catch (SocketException se) {\n-            \/\/ not supported if socket already connected\n-            \/\/ Solaris returns error in such cases\n-            if(!isConnected())\n-                throw se;\n-        }\n+        getImpl().setOption(SocketOptions.IP_TOS, tc);\n@@ -1664,7 +1723,9 @@\n-    public synchronized void close() throws IOException {\n-        synchronized(closeLock) {\n-            if (isClosed())\n-                return;\n-            if (created)\n-                impl.close();\n-            closed = true;\n+    public void close() throws IOException {\n+        synchronized (socketLock) {\n+            if ((state & CLOSED) == 0) {\n+                int s = getAndBitwiseOrState(CLOSED);\n+                if ((s & (SOCKET_CREATED | CLOSED)) == SOCKET_CREATED) {\n+                    \/\/ close underlying socket if created\n+                    impl.close();\n+                }\n+            }\n@@ -1692,3 +1753,3 @@\n-    public void shutdownInput() throws IOException\n-    {\n-        if (isClosed())\n+    public void shutdownInput() throws IOException {\n+        int s = state;\n+        if (isClosed(s))\n@@ -1696,1 +1757,1 @@\n-        if (!isConnected())\n+        if (!isConnected(s))\n@@ -1698,1 +1759,1 @@\n-        if (isInputShutdown())\n+        if (isInputShutdown(s))\n@@ -1701,1 +1762,1 @@\n-        shutIn = true;\n+        getAndBitwiseOrState(SHUT_IN);\n@@ -1722,3 +1783,3 @@\n-    public void shutdownOutput() throws IOException\n-    {\n-        if (isClosed())\n+    public void shutdownOutput() throws IOException {\n+        int s = state;\n+        if (isClosed(s))\n@@ -1726,1 +1787,1 @@\n-        if (!isConnected())\n+        if (!isConnected(s))\n@@ -1728,1 +1789,1 @@\n-        if (isOutputShutdown())\n+        if (isOutputShutdown(s))\n@@ -1731,1 +1792,1 @@\n-        shutOut = true;\n+        getAndBitwiseOrState(SHUT_OUT);\n@@ -1762,1 +1823,1 @@\n-        return connected;\n+        return isConnected(state);\n@@ -1778,1 +1839,1 @@\n-        return bound;\n+        return isBound(state);\n@@ -1789,3 +1850,1 @@\n-        synchronized(closeLock) {\n-            return closed;\n-        }\n+        return isClosed(state);\n@@ -1802,1 +1861,1 @@\n-        return shutIn;\n+        return isInputShutdown(state);\n@@ -1813,1 +1872,1 @@\n-        return shutOut;\n+        return isOutputShutdown(state);\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":232,"deletions":173,"binary":false,"changes":405,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-     * s.setOption(SO_LINGER, new Integer(10));\n+     * s.setOption(SO_LINGER, Integer.valueOf(10));\n@@ -59,1 +59,1 @@\n-     * s.setOption(SO_LINGER, new Double(10));\n+     * s.setOption(SO_LINGER, Double.valueOf(10));\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketOptions.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n- *     testArgs[0] = new Integer(i);\n+ *     testArgs[0] = Integer.valueOf(i);\n","filename":"src\/java.base\/share\/classes\/java\/text\/ChoiceFormat.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -252,1 +252,1 @@\n- * Object[] testArgs = {new Long(fileCount), diskName};\n+ * Object[] testArgs = {Long.valueOf(fileCount), diskName};\n@@ -278,1 +278,1 @@\n- * Object[] testArgs = {new Long(fileCount), diskName};\n+ * Object[] testArgs = {Long.valueOf(fileCount), diskName};\n@@ -310,1 +310,1 @@\n- * Object[] objs = {new Double(3.1415)};\n+ * Object[] objs = {Double.valueOf(3.1415)};\n@@ -313,1 +313,0 @@\n- * objs = null;\n@@ -315,1 +314,1 @@\n- * \/\/ objs now equals {new Double(3.1)}\n+ * \/\/ objs now equals {Double.valueOf(3.1)}\n","filename":"src\/java.base\/share\/classes\/java\/text\/MessageFormat.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -319,0 +319,4 @@\n+                \/\/ restore old state\n+                ZONES.put(zoneId, old);\n+                provider.provideZoneIds().stream()\n+                    .forEach(id -> ZONES.remove(id, provider));\n","filename":"src\/java.base\/share\/classes\/java\/time\/zone\/ZoneRulesProvider.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2796,1 +2796,1 @@\n-     * <pre>    {@code new Double(d1).equals(new Double(d2))}<\/pre>\n+     * <pre>    {@code Double.valueOf(d1).equals(Double.valueOf(d2))}<\/pre>\n@@ -2829,1 +2829,1 @@\n-     * <pre>    {@code new Double(d1).equals(new Double(d2))}<\/pre>\n+     * <pre>    {@code Double.valueOf(d1).equals(Double.valueOf(d2))}<\/pre>\n@@ -2879,1 +2879,1 @@\n-     * <pre>    {@code new Float(f1).equals(new Float(f2))}<\/pre>\n+     * <pre>    {@code Float.valueOf(f1).equals(Float.valueOf(f2))}<\/pre>\n@@ -2912,1 +2912,1 @@\n-     * <pre>    {@code new Float(f1).equals(new Float(f2))}<\/pre>\n+     * <pre>    {@code Float.valueOf(f1).equals(Float.valueOf(f2))}<\/pre>\n","filename":"src\/java.base\/share\/classes\/java\/util\/Arrays.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -4599,4 +4599,3 @@\n-            if (width != -1 && Flags.contains(f, Flags.ZERO_PAD)) {\n-                for (int k = sb.length(); k < width; k++) {\n-                    sb.insert(begin, zero);\n-                }\n+            if (width > sb.length() && Flags.contains(f, Flags.ZERO_PAD)) {\n+                String zeros = String.valueOf(zero).repeat(width - sb.length());\n+                sb.insert(begin, zeros);\n","filename":"src\/java.base\/share\/classes\/java\/util\/Formatter.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -402,2 +402,2 @@\n-     * {@link java.util.Collection#iterator()} as the source of elements, and\n-     * reporting its {@link java.util.Collection#size()} as its initial size.\n+     * {@link java.util.Collection#iterator() iterator} as the source of elements, and\n+     * reporting its {@link java.util.Collection#size() size} as its initial size.\n@@ -1820,2 +1820,2 @@\n-         * collection's {@link java.util.Collection#iterator()) for traversal,\n-         * and reporting its {@link java.util.Collection#size()) as its initial\n+         * collection's {@link java.util.Collection#iterator() iterator} for traversal,\n+         * and reporting its {@link java.util.Collection#size() size} as its initial\n@@ -1824,1 +1824,1 @@\n-         * @param c the collection\n+         * @param collection the collection\n","filename":"src\/java.base\/share\/classes\/java\/util\/Spliterators.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -634,1 +634,1 @@\n-     * <li>Use the {@code user.timezone} property value as the default\n+     * <li>Use the {@systemProperty user.timezone} property value as the default\n","filename":"src\/java.base\/share\/classes\/java\/util\/TimeZone.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -68,2 +69,2 @@\n-            ADDRESS_TO_LONG = lookup.findVirtual(MemorySegment.class, \"address\",\n-                    MethodType.methodType(long.class));\n+            ADDRESS_TO_LONG = lookup.findStatic(SharedUtils.class, \"unboxSegment\",\n+                    MethodType.methodType(long.class, MemorySegment.class));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -267,1 +267,1 @@\n-    static long unboxSegment(MemorySegment segment) {\n+    public static long unboxSegment(MemorySegment segment) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,6 +31,0 @@\n- * The provider used for instantiating JdkConsole instance can be\n- * specified with the system property \"jdk.console\", whose value\n- * designates the module name of the implementation, and which defaults\n- * to \"jdk.internal.le\" (jline). If no providers is available,\n- * or instantiation failed, java.base built-in Console implementation\n- * is used.\n@@ -42,1 +36,1 @@\n-    String DEFAULT_PROVIDER_MODULE_NAME = \"jdk.internal.le\";\n+    String DEFAULT_PROVIDER_MODULE_NAME = \"java.base\";\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/io\/JdkConsoleProvider.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -652,5 +652,1 @@\n-        JrtFileAttributes zfas = jrtfs.getFileAttributes(this, options);\n-        if (zfas == null) {\n-            throw new NoSuchFileException(toString());\n-        }\n-        return zfas;\n+        return jrtfs.getFileAttributes(this, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/JrtPath.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -540,1 +540,10 @@\n-                return digAlg + \"with\" + keyAlg;\n+                String sigAlg = digAlg + \"with\" + keyAlg;\n+                try {\n+                    Signature.getInstance(sigAlg);\n+                    return sigAlg;\n+                } catch (NoSuchAlgorithmException e) {\n+                    \/\/ Possibly an unknown modern signature algorithm,\n+                    \/\/ in this case, encAlg should already be a signature\n+                    \/\/ algorithm.\n+                    return encAlg;\n+                }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/SignerInfo.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,3 +74,0 @@\n-    final HashMap<Integer,\n-            SessionTicketExtension.StatelessKey> keyHashMap = new HashMap<>();\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLContextImpl.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.util.Iterator;\n@@ -32,0 +33,3 @@\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -72,0 +76,5 @@\n+    \/\/ The current session ticket encryption key ID (only used in server context)\n+    private int currentKeyID;\n+    \/\/ Session ticket encryption keys and IDs map (only used in server context)\n+    private final Map<Integer, SessionTicketExtension.StatelessKey> keyHashMap;\n+\n@@ -83,0 +92,8 @@\n+        if (server) {\n+            keyHashMap = new ConcurrentHashMap<>();\n+            \/\/ Should be \"randomly generated\" according to RFC 5077,\n+            \/\/ but doesn't necessarily has to be a true random number.\n+            currentKeyID = new Random(System.nanoTime()).nextInt();\n+        } else {\n+            keyHashMap = Map.of();\n+        }\n@@ -173,0 +190,45 @@\n+    private void cleanupStatelessKeys() {\n+        Iterator<Map.Entry<Integer, SessionTicketExtension.StatelessKey>> it =\n+            keyHashMap.entrySet().iterator();\n+        while (it.hasNext()) {\n+            Map.Entry<Integer, SessionTicketExtension.StatelessKey> entry = it.next();\n+            SessionTicketExtension.StatelessKey k = entry.getValue();\n+            if (k.isInvalid(this)) {\n+                it.remove();\n+                try {\n+                    k.key.destroy();\n+                } catch (Exception e) {\n+                    \/\/ Suppress\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Package-private, used only from SessionTicketExtension.KeyState::getCurrentKey.\n+    SessionTicketExtension.StatelessKey getKey(HandshakeContext hc) {\n+        SessionTicketExtension.StatelessKey ssk = keyHashMap.get(currentKeyID);\n+        if (ssk != null && !ssk.isExpired()) {\n+            return ssk;\n+        }\n+        synchronized (this) {\n+            \/\/ If the current key is no longer expired, it was already\n+            \/\/ updated by a concurrent request, and we can return.\n+            ssk = keyHashMap.get(currentKeyID);\n+            if (ssk != null && !ssk.isExpired()) {\n+                return ssk;\n+            }\n+            int newID = currentKeyID + 1;\n+            ssk = new SessionTicketExtension.StatelessKey(hc, newID);\n+            keyHashMap.put(Integer.valueOf(newID), ssk);\n+            currentKeyID = newID;\n+        }\n+        \/\/ Check for and delete invalid keys every time we create a new stateless key.\n+        cleanupStatelessKeys();\n+        return ssk;\n+    }\n+\n+    \/\/ Package-private, used only from SessionTicketExtension.KeyState::getKey.\n+    SessionTicketExtension.StatelessKey getKey(int id) {\n+        return keyHashMap.get(id);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionContextImpl.java","additions":63,"deletions":1,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import javax.net.ssl.SSLSessionContext;\n@@ -77,1 +78,0 @@\n-    private static int currentKeyID = new SecureRandom().nextInt();\n@@ -118,1 +118,2 @@\n-        StatelessKey(HandshakeContext hc, int newNum) {\n+        \/\/ package-private, used only by SSLContextImpl\n+        StatelessKey(HandshakeContext hc, int num) {\n@@ -129,2 +130,1 @@\n-            num = newNum;\n-            hc.sslContext.keyHashMap.put(Integer.valueOf(num), this);\n+            this.num = num;\n@@ -139,1 +139,2 @@\n-        boolean isInvalid(long sessionTimeout) {\n+        boolean isInvalid(SSLSessionContext sslSessionContext) {\n+            int sessionTimeout = sslSessionContext.getSessionTimeout() * 1000;\n@@ -148,1 +149,3 @@\n-            StatelessKey ssk = hc.sslContext.keyHashMap.get(num);\n+            SSLSessionContextImpl serverCache =\n+                (SSLSessionContextImpl)hc.sslContext.engineGetServerSessionContext();\n+            StatelessKey ssk = serverCache.getKey(num);\n@@ -150,1 +153,1 @@\n-            if (ssk == null || ssk.isInvalid(getSessionTimeout(hc))) {\n+            if (ssk == null || ssk.isInvalid(serverCache)) {\n@@ -158,63 +161,3 @@\n-            StatelessKey ssk = hc.sslContext.keyHashMap.get(currentKeyID);\n-\n-            if (ssk != null && !ssk.isExpired()) {\n-                return ssk;\n-            }\n-            return nextKey(hc);\n-        }\n-\n-        \/\/ This method locks when the first getCurrentKey() finds it to be too\n-        \/\/ old and create a new key to replace the current key.  After the new\n-        \/\/ key established, the lock can be released so following\n-        \/\/ operations will start using the new key.\n-        \/\/ The first operation will take a longer code path by generating the\n-        \/\/ next key and cleaning up old keys.\n-        private static StatelessKey nextKey(HandshakeContext hc) {\n-            StatelessKey ssk;\n-\n-            synchronized (hc.sslContext.keyHashMap) {\n-                \/\/ If the current key is no longer expired, it was already\n-                \/\/ updated by a previous operation, and we can return.\n-                ssk = hc.sslContext.keyHashMap.get(currentKeyID);\n-                if (ssk != null && !ssk.isExpired()) {\n-                    return ssk;\n-                }\n-                int newNum;\n-                if (currentKeyID == Integer.MAX_VALUE) {\n-                    newNum = 0;\n-                } else {\n-                    newNum = currentKeyID + 1;\n-                }\n-                \/\/ Get new key\n-                ssk = new StatelessKey(hc, newNum);\n-                currentKeyID = newNum;\n-                \/\/ Release lock since the new key is ready to be used.\n-            }\n-\n-            \/\/ Clean up any old keys, then return the current key\n-            cleanup(hc);\n-            return ssk;\n-        }\n-\n-        \/\/ Deletes any invalid SessionStateKeys.\n-        static void cleanup(HandshakeContext hc) {\n-            int sessionTimeout = getSessionTimeout(hc);\n-\n-            StatelessKey ks;\n-            for (Object o : hc.sslContext.keyHashMap.keySet().toArray()) {\n-                Integer i = (Integer)o;\n-                ks = hc.sslContext.keyHashMap.get(i);\n-                if (ks.isInvalid(sessionTimeout)) {\n-                    try {\n-                        ks.key.destroy();\n-                    } catch (Exception e) {\n-                        \/\/ Suppress\n-                    }\n-                    hc.sslContext.keyHashMap.remove(i);\n-                }\n-            }\n-        }\n-\n-        static int getSessionTimeout(HandshakeContext hc) {\n-            return hc.sslContext.engineGetServerSessionContext().\n-                    getSessionTimeout() * 1000;\n+            SSLSessionContextImpl serverCache =\n+                (SSLSessionContextImpl)hc.sslContext.engineGetServerSessionContext();\n+            return serverCache.getKey(hc);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SessionTicketExtension.java","additions":14,"deletions":71,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -126,12 +126,1 @@\n-\n-    \/*\n-     * If fd 0 is a socket it means we may have been launched from inetd or\n-     * xinetd. If it's a socket then check the family - if it's an\n-     * IPv4 socket then we need to disable IPv6.\n-     *\/\n-    if (getsockname(0, &sa.sa, &sa_len) == 0) {\n-        if (sa.sa.sa_family == AF_INET) {\n-            close(fd);\n-            return JNI_FALSE;\n-        }\n-    }\n+    close(fd);\n@@ -150,1 +139,0 @@\n-            close(fd);\n@@ -156,1 +144,0 @@\n-            close(fd);\n@@ -167,1 +154,0 @@\n-    close(fd);\n","filename":"src\/java.base\/unix\/native\/libnet\/net_util_md.c","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,4 +41,0 @@\n-static int toInetFamily(SOCKETADDRESS *sa) {\n-    return (sa->sa.sa_family == (ipv6_available() ? AF_INET6 : AF_INET));\n-}\n-\n@@ -61,3 +57,1 @@\n-        if (toInetFamily(&sa)) {\n-            remote_ia = NET_SockaddrToInetAddress(env, &sa, (int *)&remote_port);\n-        }\n+        remote_ia = NET_SockaddrToInetAddress(env, &sa, (int *)&remote_port);\n@@ -92,3 +86,1 @@\n-        if (toInetFamily(&sa)) {\n-            NET_SockaddrToInetAddress(env, &sa, (int *)&remote_port);\n-        }\n+        NET_SockaddrToInetAddress(env, &sa, (int *)&remote_port);\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/InheritedChannel.c","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -103,1 +103,0 @@\n-static jfieldID        CMpDataID;\n@@ -1617,1 +1616,0 @@\n-        CHECK_NULL(CMpDataID = (*env)->GetFieldID(env, icm, \"pData\", \"J\"));\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/ImageSurfaceData.m","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,2 +81,3 @@\n- * <td><a href=\"http:\/\/www.exif.org\/Exif2-2.PDF\">Exif 2.2 Specification<\/a>\n- * (PDF), section 4.5.5, \"Basic Structure of Thumbnail Data\"<\/td>\n+ * <td><a href=\"https:\/\/www.cipa.jp\/std\/documents\/e\/DC-008-2012_E.pdf\">\n+ * Exif 2.3 Specification<\/a>\n+ * (PDF), section 4.5.8, \"Basic Structure of Thumbnail Data\"<\/td>\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/tiff\/TIFFImageWriteParam.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -580,0 +580,1 @@\n+            \"ComboBox.squareButton\", Boolean.FALSE,\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKLookAndFeel.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -159,1 +159,0 @@\n-    private long pData;         \/\/ Placeholder for data for native functions\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/ColorModel.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -577,2 +577,3 @@\n-<td><a href=\"http:\/\/www.exif.org\/Exif2-2.PDF\">Exif 2.2 Specification<\/a>\n-(PDF), section 4.5.5, \"Basic Structure of Thumbnail Data\"<\/td>\n+<td><a href=\"https:\/\/www.cipa.jp\/std\/documents\/e\/DC-008-2012_E.pdf\">\n+    Exif 2.3 Specification<\/a>\n+(PDF), section 4.5.8, \"Basic Structure of Thumbnail Data\"<\/td>\n@@ -742,1 +743,1 @@\n-values will be modified such that the result is in accord with the Exif 2.2\n+values will be modified such that the result is in accord with the Exif 2.3\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/metadata\/doc-files\/tiff_metadata.html","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-    private static final Object SYNTH_BUTTON_UI_KEY = new Object();\n-\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthButtonUI.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -355,0 +355,28 @@\n+    \/**\n+     * The minimum size is the size of the display area plus insets plus the button.\n+     *\/\n+    @Override\n+    public Dimension getMinimumSize( JComponent c ) {\n+        if ( !isMinimumSizeDirty ) {\n+            return new Dimension(cachedMinimumSize);\n+        }\n+        Dimension size = getDisplaySize();\n+        Insets insets = getInsets();\n+        Insets arrowInsets = arrowButton.getInsets();\n+        \/\/calculate the width and height of the button\n+        int buttonHeight = size.height;\n+        int buttonWidth = squareButton ?\n+                            buttonHeight :\n+                            arrowButton.getPreferredSize().width;\n+        \/\/adjust the size based on the button width\n+        size.height += insets.top + insets.bottom + arrowInsets.top\n+                        + arrowInsets.bottom;\n+        size.width  += insets.left + insets.right + arrowInsets.left\n+                        + arrowInsets.right + buttonWidth;\n+\n+        cachedMinimumSize.setSize( size.width, size.height );\n+        isMinimumSizeDirty = false;\n+\n+        return new Dimension(size);\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthComboBoxUI.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -99,5 +99,3 @@\n-    static long createTransform(\n-        LCMSProfile[] profiles, int renderingIntent,\n-        int inFormatter, boolean isInIntPacked,\n-        int outFormatter, boolean isOutIntPacked,\n-        Object disposerRef)\n+    static long createTransform(LCMSProfile[] profiles, int renderingIntent,\n+                                int inFormatter, int outFormatter,\n+                                Object disposerRef)\n@@ -116,1 +114,1 @@\n-                    isInIntPacked, outFormatter, isOutIntPacked, disposerRef);\n+                                         outFormatter, disposerRef);\n@@ -122,5 +120,5 @@\n-    private static native long createNativeTransform(\n-        long[] profileIDs, int renderingIntent,\n-        int inFormatter, boolean isInIntPacked,\n-        int outFormatter, boolean isOutIntPacked,\n-        Object disposerRef);\n+    private static native long createNativeTransform(long[] profileIDs,\n+                                                     int renderingIntent,\n+                                                     int inFormatter,\n+                                                     int outFormatter,\n+                                                     Object disposerRef);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMS.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.nio.ByteOrder;\n@@ -39,0 +40,2 @@\n+import static java.nio.ByteOrder.LITTLE_ENDIAN;\n+\n@@ -62,1 +65,2 @@\n-\n+    private static final int SWAP_ENDIAN =\n+            ByteOrder.nativeOrder() == LITTLE_ENDIAN ? DOSWAP : 0;\n@@ -67,1 +71,0 @@\n-    boolean isIntPacked = false;\n@@ -146,2 +149,1 @@\n-                l.pixelType = PT_ARGB_8;\n-                l.isIntPacked = true;\n+                l.pixelType = PT_ARGB_8 ^ SWAP_ENDIAN;\n@@ -150,2 +152,1 @@\n-                l.pixelType = PT_ARGB_8;\n-                l.isIntPacked = true;\n+                l.pixelType = PT_ARGB_8 ^ SWAP_ENDIAN;\n@@ -154,2 +155,1 @@\n-                l.pixelType = PT_ABGR_8;\n-                l.isIntPacked = true;\n+                l.pixelType = PT_ABGR_8 ^ SWAP_ENDIAN;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMSImageLayout.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-        private boolean isInIntPacked;\n@@ -58,1 +57,0 @@\n-        private boolean isOutIntPacked;\n@@ -61,4 +59,1 @@\n-            return inFormatter == in.pixelType\n-                    && isInIntPacked == in.isIntPacked\n-                    && outFormatter == out.pixelType\n-                    && isOutIntPacked == out.isIntPacked;\n+            return inFormatter == in.pixelType && outFormatter == out.pixelType;\n@@ -118,2 +113,0 @@\n-                    tfm.isInIntPacked = in.isIntPacked;\n-\n@@ -121,2 +114,0 @@\n-                    tfm.isOutIntPacked = out.isIntPacked;\n-\n@@ -125,3 +116,1 @@\n-                                                  tfm.isInIntPacked,\n-                                                  tfm.outFormatter,\n-                                                  tfm.isOutIntPacked, tfm);\n+                                                  tfm.outFormatter, tfm);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMSTransform.java","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,1 +108,0 @@\n-    CHECK_NULL(g_CMpDataID = (*env)->GetFieldID (env, cls, \"pData\", \"J\"));\n","filename":"src\/java.desktop\/share\/native\/libawt\/awt\/image\/imageInitIDs.c","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,0 @@\n-IMGEXTERN jfieldID g_CMpDataID;\n","filename":"src\/java.desktop\/share\/native\/libawt\/awt\/image\/imageInitIDs.h","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1617,1 +1617,2 @@\n- * (see http:\/\/www.exif.org\/Exif2-2.PDF, section 4.7, page 58)\n+ * (see https:\/\/www.cipa.jp\/std\/documents\/e\/DC-008-2012_E.pdf,\n+ * section 4.7, page 83)\n@@ -1718,1 +1719,2 @@\n-             *     Must be YCbCr (see http:\/\/www.exif.org\/Exif2-2.PDF, section 4.7, page 63)\n+             *     Must be YCbCr (see https:\/\/www.cipa.jp\/std\/documents\/e\/DC-008-2012_E.pdf,\n+             *     section 4.7, page 88)\n","filename":"src\/java.desktop\/share\/native\/libjavajpeg\/imageioJPEG.c","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -145,2 +145,1 @@\n-   jint inFormatter, jboolean isInIntPacked,\n-   jint outFormatter, jboolean isOutIntPacked, jobject disposerRef)\n+   jint inFormatter, jint outFormatter, jobject disposerRef)\n@@ -161,10 +160,0 @@\n-#ifdef _LITTLE_ENDIAN\n-    \/* Reversing data packed into int for LE archs *\/\n-    if (isInIntPacked) {\n-        inFormatter ^= DOSWAP_SH(1);\n-    }\n-    if (isOutIntPacked) {\n-        outFormatter ^= DOSWAP_SH(1);\n-    }\n-#endif\n-\n","filename":"src\/java.desktop\/share\/native\/liblcms\/LCMS.c","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1227,5 +1227,0 @@\n-\n-        \/* Set pData field of ColorModel to point to ColorData *\/\n-        JNU_SetLongFieldFromPtr(env, awt_colormodel, g_CMpDataID,\n-                                aData->color_data);\n-\n","filename":"src\/java.desktop\/unix\/native\/common\/awt\/X11Color.c","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1476,1 +1476,1 @@\n-            s = (int)(0.3 * height + 0.5) + 1;\n+            s = (int)(0.3 * MIN(height, width) + 0.5) + 1;\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk3_interface.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -904,1 +904,1 @@\n-                    } catch (InterruptedException e) {\n+                    } catch (InterruptedException | FileNotFoundException e) {\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/shell\/Win32ShellFolder2.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,2 @@\n-            throws InterruptedException {\n+            throws InterruptedException, FileNotFoundException\n+    {\n@@ -116,0 +117,3 @@\n+                if (!parent.isDirectory()) {\n+                    throw new FileNotFoundException(\"not a directory\");\n+                }\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/shell\/Win32ShellFolderManager2.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -261,1 +261,1 @@\n-            if (!d3dw.isSurfaceLost() || validate(d3dw, false)) {\n+            if (!d3dw.isSurfaceLost() || validate(d3dw)) {\n@@ -455,1 +455,1 @@\n-                    } else if (!validate(sd, true)) {\n+                    } else if (!validate(sd)) {\n@@ -477,1 +477,1 @@\n-    private boolean validate(D3DWindowSurfaceData sd, boolean postEvent) {\n+    private boolean validate(D3DWindowSurfaceData sd) {\n@@ -494,3 +494,1 @@\n-                if (postEvent) {\n-                    repaintPeerTarget(sd.getPeer());\n-                }\n+                repaintPeerTarget(sd.getPeer());\n","filename":"src\/java.desktop\/windows\/classes\/sun\/java2d\/d3d\/D3DScreenUpdateManager.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,71 +58,1 @@\n-#define GETMIN(v1, v2)    (((v1) > (t=(v2))) && ((v1) = t))\n-#define GETMAX(v1, v2)    (((v1) < (t=(v2))) && ((v1) = t))\n-\n-#ifdef D3D_PPL_DLL\n-\n-JNIEXPORT void JNICALL\n-SurfaceData_IntersectBounds(SurfaceDataBounds *dst, SurfaceDataBounds *src)\n-{\n-    int t;\n-    GETMAX(dst->x1, src->x1);\n-    GETMAX(dst->y1, src->y1);\n-    GETMIN(dst->x2, src->x2);\n-    GETMIN(dst->y2, src->y2);\n-}\n-\n-JNIEXPORT void JNICALL\n-SurfaceData_IntersectBoundsXYXY(SurfaceDataBounds *bounds,\n-                                jint x1, jint y1, jint x2, jint y2)\n-{\n-    int t;\n-    GETMAX(bounds->x1, x1);\n-    GETMAX(bounds->y1, y1);\n-    GETMIN(bounds->x2, x2);\n-    GETMIN(bounds->y2, y2);\n-}\n-\n-JNIEXPORT void JNICALL\n-SurfaceData_IntersectBoundsXYWH(SurfaceDataBounds *bounds,\n-                                jint x, jint y, jint w, jint h)\n-{\n-    w = (w <= 0) ? x : x+w;\n-    if (w < x) {\n-        w = 0x7fffffff;\n-    }\n-    if (bounds->x1 < x) {\n-        bounds->x1 = x;\n-    }\n-    if (bounds->x2 > w) {\n-        bounds->x2 = w;\n-    }\n-    h = (h <= 0) ? y : y+h;\n-    if (h < y) {\n-        h = 0x7fffffff;\n-    }\n-    if (bounds->y1 < y) {\n-        bounds->y1 = y;\n-    }\n-    if (bounds->y2 > h) {\n-        bounds->y2 = h;\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-SurfaceData_IntersectBlitBounds(SurfaceDataBounds *src,\n-                                SurfaceDataBounds *dst,\n-                                jint dx, jint dy)\n-{\n-    int t;\n-    GETMAX(dst->x1, src->x1 + dx);\n-    GETMAX(dst->y1, src->y1 + dy);\n-    GETMIN(dst->x2, src->x2 + dx);\n-    GETMIN(dst->y2, src->y2 + dy);\n-    GETMAX(src->x1, dst->x1 - dx);\n-    GETMAX(src->y1, dst->y1 - dy);\n-    GETMIN(src->x2, dst->x2 - dx);\n-    GETMIN(src->y2, dst->y2 - dy);\n-}\n-\n-#endif \/* D3D_PPL_DLL *\/\n-\n-D3DPIPELINE_API HRESULT\n+HRESULT\n@@ -202,1 +132,1 @@\n-D3DPIPELINE_API HRESULT\n+HRESULT\n@@ -561,1 +491,1 @@\n-D3DPIPELINE_API HRESULT\n+HRESULT\n@@ -690,1 +620,1 @@\n-D3DPIPELINE_API HRESULT\n+HRESULT\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DBlitLoops.cpp","additions":4,"deletions":74,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-D3DPIPELINE_API HRESULT\n+HRESULT\n@@ -50,1 +50,1 @@\n-D3DPIPELINE_API HRESULT\n+HRESULT\n@@ -57,1 +57,1 @@\n-D3DPIPELINE_API HRESULT\n+HRESULT\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DBlitLoops.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-class D3DPIPELINE_API D3DContext {\n+class D3DContext {\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DContext.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,3 @@\n-#ifdef D3D_PPL_DLL\n+\/\/ this include ensures that with debug build we get\n+\/\/ awt's overridden debug \"new\" and \"delete\" operators\n+#include \"awt.h\"\n@@ -33,0 +35,3 @@\n+#include <windows.h>\n+#include <d3d9.h>\n+#include \"Trace.h\"\n@@ -34,34 +39,2 @@\n-    #ifndef WIN32_LEAN_AND_MEAN\n-    #define WIN32_LEAN_AND_MEAN\n-    #endif\n-\n-    #ifdef D3DPIPELINE_EXPORTS\n-    #define D3DPIPELINE_API __declspec(dllexport)\n-    #else\n-    #define D3DPIPELINE_API __declspec(dllimport)\n-    #endif\n-\n-    #include <windows.h>\n-    #include <d3d9.h>\n-    #include <DDErr.h>\n-    #include \"..\\Import\\Trace.h\"\n-\n-    #define DebugPrintD3DError(res, msg) \\\n-        DXTRACE_ERR(msg, res)\n-\n-#else\n-\n-    #define D3DPIPELINE_API __declspec(dllexport)\n-\n-    \/\/ this include ensures that with debug build we get\n-    \/\/ awt's overridden debug \"new\" and \"delete\" operators\n-    #include \"awt.h\"\n-\n-    #include <windows.h>\n-    #include <d3d9.h>\n-    #include \"Trace.h\"\n-\n-    #define DebugPrintD3DError(res, msg) \\\n-        J2dTraceLn1(J2D_TRACE_ERROR, \"D3D Error: \" msg \" res=%d\", res)\n-\n-#endif \/*D3D_PPL_DLL*\/\n+#define DebugPrintD3DError(res, msg) \\\n+    J2dTraceLn1(J2D_TRACE_ERROR, \"D3D Error: \" msg \" res=%d\", res)\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DPipeline.h","additions":8,"deletions":35,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-class D3DPIPELINE_API D3DPipelineManager\n+class D3DPipelineManager\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DPipelineManager.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-HRESULT D3DPIPELINE_API\n+HRESULT\n@@ -45,1 +45,1 @@\n-HRESULT D3DPIPELINE_API\n+HRESULT\n@@ -57,1 +57,1 @@\n-HRESULT D3DPIPELINE_API\n+HRESULT\n@@ -69,1 +69,1 @@\n-HRESULT D3DPIPELINE_API\n+HRESULT\n@@ -88,1 +88,1 @@\n-HRESULT D3DPIPELINE_API\n+HRESULT\n@@ -105,1 +105,1 @@\n-HRESULT D3DPIPELINE_API\n+HRESULT\n@@ -117,1 +117,1 @@\n-HRESULT D3DPIPELINE_API\n+HRESULT\n@@ -138,1 +138,1 @@\n-HRESULT D3DPIPELINE_API\n+HRESULT\n@@ -245,1 +245,1 @@\n-HRESULT D3DPIPELINE_API\n+HRESULT\n@@ -277,1 +277,1 @@\n-HRESULT D3DPIPELINE_API\n+HRESULT\n@@ -352,2 +352,0 @@\n-#ifndef D3D_PPL_DLL\n-\n@@ -391,2 +389,0 @@\n-\n-#endif \/\/ D3D_PPL_DLL\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DRenderer.cpp","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-HRESULT D3DPIPELINE_API\n+HRESULT\n@@ -40,1 +40,1 @@\n-HRESULT D3DPIPELINE_API\n+HRESULT\n@@ -44,1 +44,1 @@\n-HRESULT D3DPIPELINE_API\n+HRESULT\n@@ -48,1 +48,1 @@\n-HRESULT D3DPIPELINE_API\n+HRESULT\n@@ -54,1 +54,1 @@\n-HRESULT D3DPIPELINE_API\n+HRESULT\n@@ -58,1 +58,1 @@\n-HRESULT D3DPIPELINE_API\n+HRESULT\n@@ -61,1 +61,1 @@\n-HRESULT D3DPIPELINE_API\n+HRESULT\n@@ -67,1 +67,1 @@\n-HRESULT D3DPIPELINE_API\n+HRESULT\n@@ -74,1 +74,1 @@\n-HRESULT D3DPIPELINE_API\n+HRESULT\n@@ -80,1 +80,1 @@\n-HRESULT D3DPIPELINE_API\n+HRESULT\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DRenderer.h","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-class D3DPIPELINE_API D3DVertexCacher {\n+class D3DVertexCacher {\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DVertexCacher.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -423,1 +423,1 @@\n-        jplis_assert(success);\n+        jplis_assert_msg(success, \"createInstrumentationImpl failed\");\n@@ -430,1 +430,1 @@\n-            jplis_assert(success);\n+            jplis_assert_msg(success, \"setLivePhaseEventHandlers failed\");\n@@ -442,0 +442,1 @@\n+            jplis_assert_msg(success, \"startJavaAgent failed\");\n","filename":"src\/java.instrument\/share\/native\/libinstrument\/InvocationAdapter.c","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -451,0 +451,1 @@\n+    jplis_assert_msg(success, \"commandStringIntoJavaStrings failed\");\n@@ -458,0 +459,1 @@\n+        jplis_assert_msg(success, \"invokeJavaAgentMainMethod failed\");\n@@ -617,0 +619,1 @@\n+            jplis_assert_msg(!errorOutstanding, \"Outstanding error when calling method in invokeJavaAgentMainMethod\");\n","filename":"src\/java.instrument\/share\/native\/libinstrument\/JPLISAgent.c","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n- * {@code setProperty(\"javax.xml.stream.isRepairingNamespaces\", new Boolean(true|false));}\n+ * {@code setProperty(\"javax.xml.stream.isRepairingNamespaces\", Boolean.TRUE);}\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/stream\/XMLOutputFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2030,4 +2030,4 @@\n-                    if (inits.isMember(sym.adr) || !uninits.isMember(sym.adr)) {\n-                        \/\/assignment targeting an effectively final variable makes the\n-                        \/\/variable lose its status of effectively final if the variable\n-                        \/\/is definitely assigned or _not_ definitively unassigned\n+                    if (!uninits.isMember(sym.adr)) {\n+                        \/\/assignment targeting an effectively final variable\n+                        \/\/makes the variable lose its status of effectively final\n+                        \/\/if the variable is _not_ definitively unassigned\n@@ -2035,0 +2035,2 @@\n+                    } else {\n+                        uninit(sym);\n@@ -2036,1 +2038,0 @@\n-                    uninit(sym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -4176,11 +4176,28 @@\n-            return diags.create(dkind, log.currentSource(), pos,\n-                      \"cant.apply.symbol\",\n-                      compactMethodDiags ?\n-                              d -> MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, c.snd) : null,\n-                      kindName(ws),\n-                      ws.name == names.init ? ws.owner.name : ws.name,\n-                      methodArguments(ws.type.getParameterTypes()),\n-                      methodArguments(argtypes),\n-                      kindName(ws.owner),\n-                      ws.owner.type,\n-                      c.snd);\n+\n+            \/\/ If the problem is due to type arguments, then the method parameters aren't relevant,\n+            \/\/ so use the error message that omits them to avoid confusion.\n+            switch (c.snd.getCode()) {\n+                case \"compiler.misc.wrong.number.type.args\":\n+                case \"compiler.misc.explicit.param.do.not.conform.to.bounds\":\n+                    return diags.create(dkind, log.currentSource(), pos,\n+                              \"cant.apply.symbol.noargs\",\n+                              compactMethodDiags ?\n+                                      d -> MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, c.snd) : null,\n+                              kindName(ws),\n+                              ws.name == names.init ? ws.owner.name : ws.name,\n+                              kindName(ws.owner),\n+                              ws.owner.type,\n+                              c.snd);\n+                default:\n+                    return diags.create(dkind, log.currentSource(), pos,\n+                              \"cant.apply.symbol\",\n+                              compactMethodDiags ?\n+                                      d -> MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, c.snd) : null,\n+                              kindName(ws),\n+                              ws.name == names.init ? ws.owner.name : ws.name,\n+                              methodArguments(ws.type.getParameterTypes()),\n+                              methodArguments(argtypes),\n+                              kindName(ws.owner),\n+                              ws.owner.type,\n+                              c.snd);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":28,"deletions":11,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -236,0 +236,5 @@\n+# 0: symbol kind, 1: name, 2: symbol kind, 3: type, 4: message segment\n+compiler.err.cant.apply.symbol.noargs=\\\n+    {0} {1} in {2} {3} cannot be applied to given types;\\n\\\n+    reason: {4}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-  _wb_conc_mark (\"WhiteBox Initiated Concurrent Mark\"),\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/shared\/GCCause.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n@@ -54,1 +55,4 @@\n-        throw new UnsupportedOperationException(\"Not yet implemented\");\n+        CommentHelper ch = configuration.utils.getCommentHelper(owner);\n+        var path = ch.getDocTreePath(tag);\n+        configuration.getMessages().warning(path, \"doclet.inheritDocWithinInappropriateTag\");\n+        return new Output(null, null, List.of(), true \/* true, otherwise there will be an exception up the stack *\/);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SeeTaglet.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n@@ -53,1 +54,4 @@\n-        throw new UnsupportedOperationException(\"Not yet implemented\");\n+        CommentHelper ch = configuration.utils.getCommentHelper(owner);\n+        var path = ch.getDocTreePath(tag);\n+        configuration.getMessages().warning(path, \"doclet.inheritDocWithinInappropriateTag\");\n+        return new Output(null, null, List.of(), true \/* true, otherwise there will be an exception up the stack *\/);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SpecTaglet.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -192,2 +192,0 @@\n-        struct protoent *proto = getprotobyname(\"TCP\");\n-        int tcp_level = (proto == 0 ? IPPROTO_TCP: proto->p_proto);\n@@ -196,1 +194,1 @@\n-        if (setsockopt(fd, tcp_level, TCP_NODELAY,\n+        if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\n","filename":"src\/jdk.jdwp.agent\/unix\/native\/libdt_socket\/socket_md.c","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -271,2 +271,0 @@\n-        struct protoent *proto = getprotobyname(\"TCP\");\n-        int tcp_level = (proto == 0 ? IPPROTO_TCP: proto->p_proto);\n@@ -275,1 +273,1 @@\n-        if (setsockopt(fd, tcp_level, TCP_NODELAY,\n+        if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\n","filename":"src\/jdk.jdwp.agent\/windows\/native\/libdt_socket\/socket_md.c","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import com.sun.tools.javac.code.Symbol;\n@@ -1034,1 +1035,8 @@\n-                result.addAll(at.getElements().getAllMembers(element));\n+                at.getElements().getAllMembers(element).forEach(m -> result.add(\n+                    element.equals(m.getEnclosingElement())\n+                        ? m\n+                        : (m instanceof Symbol.MethodSymbol ms)\n+                            ? ms.clone((Symbol)element)\n+                            : (m instanceof Symbol.VarSymbol vs)\n+                                ? vs.clone((Symbol)element)\n+                                : m));\n@@ -1683,0 +1691,5 @@\n+    private Element getOriginalEnclosingElement(Element el) {\n+        if (el instanceof Symbol s) el = s.baseSymbol();\n+        return el.getEnclosingElement();\n+    }\n+\n@@ -1733,1 +1746,1 @@\n-                return appendDot(elementHeader(at, el.getEnclosingElement(), includeParameterNames, false)) + el.getSimpleName() + \":\" + el.asType();\n+                return appendDot(elementHeader(at, getOriginalEnclosingElement(el), includeParameterNames, false)) + el.getSimpleName() + \":\" + el.asType();\n@@ -1735,1 +1748,1 @@\n-                return appendDot(elementHeader(at, el.getEnclosingElement(), includeParameterNames, false)) + el.getSimpleName();\n+                return appendDot(elementHeader(at, getOriginalEnclosingElement(el), includeParameterNames, false)) + el.getSimpleName();\n@@ -1756,1 +1769,1 @@\n-                String clazz = elementHeader(at, el.getEnclosingElement(), includeParameterNames, false);\n+                String clazz = elementHeader(at, getOriginalEnclosingElement(el), includeParameterNames, false);\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/SourceCodeAnalysisImpl.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -60,0 +60,4 @@\n+    private static final int TRUNCATE_END = MAX_UTF_CHARS \/ 3;\n+    private static final String TRUNCATE_JOIN = \" ... \";\n+    private static final int TRUNCATE_START = MAX_UTF_CHARS - TRUNCATE_JOIN.length() - TRUNCATE_END;\n+\n@@ -111,1 +115,1 @@\n-            s = s.substring(0, MAX_UTF_CHARS);\n+            s = s.substring(0, TRUNCATE_START) + TRUNCATE_JOIN + s.substring(s.length() - TRUNCATE_END);\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/ExecutionControlForwarder.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import java.util.Objects;\n@@ -42,1 +43,1 @@\n-class ZipFileStore extends FileStore {\n+final class ZipFileStore extends FileStore {\n@@ -67,0 +68,1 @@\n+        Objects.requireNonNull(type);\n@@ -75,0 +77,1 @@\n+        Objects.requireNonNull(name);\n@@ -81,2 +84,1 @@\n-        if (type == null)\n-            throw new NullPointerException();\n+        Objects.requireNonNull(type);\n@@ -103,0 +105,1 @@\n+        Objects.requireNonNull(attribute);\n@@ -109,1 +112,1 @@\n-         throw new UnsupportedOperationException(\"does not support the given attribute\");\n+        throw new UnsupportedOperationException(\"does not support the given attribute: \" + attribute);\n@@ -112,1 +115,1 @@\n-    private static class ZipFileStoreAttributes {\n+    private static final class ZipFileStoreAttributes {\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileStore.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"metaprogramming\/decay.hpp\"\n-#include \"metaprogramming\/isSame.hpp\"\n-#include \"utilities\/debug.hpp\"\n-\n-class TestDecay: AllStatic {\n-  class A: AllStatic {};\n-\n-  typedef const volatile A cvA;\n-  typedef const volatile A& cvAref;\n-  typedef const volatile A* cvAptr;\n-  typedef const volatile A* const volatile cvAptrcv;\n-  typedef A& Aref;\n-\n-  typedef Decay<cvAref>::type rr_cvAref;\n-  static const bool decay_cvAref_is_A = IsSame<rr_cvAref, A>::value;\n-  STATIC_ASSERT(decay_cvAref_is_A);\n-\n-  typedef Decay<cvAptrcv>::type rr_cvAptrcv;\n-  static const bool decay_cvAptrcv_is_cvAptr = IsSame<rr_cvAptrcv, cvAptr>::value;\n-  STATIC_ASSERT(decay_cvAptrcv_is_cvAptr);\n-};\n","filename":"test\/hotspot\/gtest\/metaprogramming\/test_decay.cpp","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"metaprogramming\/isIntegral.hpp\"\n-#include \"utilities\/debug.hpp\"\n-\n-class IsIntegralTest: AllStatic {\n-  class A: AllStatic {};\n-\n-  static const bool ii_voidptr = IsIntegral<void*>::value;\n-  STATIC_ASSERT(!ii_voidptr);\n-\n-  static const bool ii_Aptr = IsIntegral<A*>::value;\n-  STATIC_ASSERT(!ii_Aptr);\n-\n-  static const bool ii_cAptr = IsIntegral<const A*>::value;\n-  STATIC_ASSERT(!ii_cAptr);\n-\n-  static const bool ii_vAptr = IsIntegral<volatile A*>::value;\n-  STATIC_ASSERT(!ii_vAptr);\n-\n-  static const bool ii_Avptr = IsIntegral<A* volatile>::value;\n-  STATIC_ASSERT(!ii_Avptr);\n-\n-  static const bool ii_intptrt = IsIntegral<intptr_t>::value;\n-  STATIC_ASSERT(ii_intptrt);\n-\n-  static const bool ii_char = IsIntegral<char>::value;\n-  STATIC_ASSERT(ii_char);\n-\n-  static const bool ii_cintptrt = IsIntegral<const intptr_t>::value;\n-  STATIC_ASSERT(ii_cintptrt);\n-\n-  static const bool ii_vintptrt = IsIntegral<volatile intptr_t>::value;\n-  STATIC_ASSERT(ii_vintptrt);\n-\n-  static const bool ii_cvintptrt = IsIntegral<const volatile intptr_t>::value;\n-  STATIC_ASSERT(ii_cvintptrt);\n-};\n","filename":"test\/hotspot\/gtest\/metaprogramming\/test_isIntegral.cpp","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"metaprogramming\/removePointer.hpp\"\n-#include \"metaprogramming\/isSame.hpp\"\n-#include \"utilities\/debug.hpp\"\n-\n-class RemovePointerTest {\n-  class A: AllStatic {};\n-\n-  typedef const volatile A cvA;\n-  typedef const volatile A& cvAref;\n-  typedef const volatile A* const volatile cvAptrcv;\n-\n-  typedef RemovePointer<cvAref>::type rp_cvAref;\n-  static const bool rp_cvAref_is_cvAref = IsSame<rp_cvAref, cvAref>::value;\n-  STATIC_ASSERT(rp_cvAref_is_cvAref);\n-\n-  typedef RemovePointer<cvAptrcv>::type rp_cvAptrcv;\n-  static const bool rp_cvAptrcv_is_cvAptrcv = IsSame<rp_cvAptrcv, cvA>::value;\n-  STATIC_ASSERT(rp_cvAptrcv_is_cvAptrcv);\n-};\n","filename":"test\/hotspot\/gtest\/metaprogramming\/test_removePointer.cpp","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#ifdef LINUX\n+\n+#include \"runtime\/os.hpp\"\n+#include \"cgroupSubsystem_linux.hpp\"\n+#include \"unittest.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#include <stdio.h>\n+\n+\n+\/\/ Utilities\n+bool file_exists(const char* filename) {\n+  struct stat st;\n+  return os::stat(filename, &st) == 0;\n+}\n+\n+char* temp_file(const char* prefix) {\n+  const testing::TestInfo* test_info = ::testing::UnitTest::GetInstance()->current_test_info();\n+  stringStream path;\n+  path.print_raw(os::get_temp_directory());\n+  path.print_raw(os::file_separator());\n+  path.print(\"%s-test-jdk.pid%d.%s.%s\", prefix, os::current_process_id(),\n+             test_info->test_case_name(), test_info->name());\n+  return path.as_string(true);\n+}\n+\n+void delete_file(const char* filename) {\n+  if (!file_exists(filename)) {\n+    return;\n+  }\n+  int ret = remove(filename);\n+  EXPECT_TRUE(ret == 0 || errno == ENOENT) << \"failed to remove file '\" << filename << \"': \"\n+      << os::strerror(errno) << \" (\" << errno << \")\";\n+}\n+\n+class TestController : public CgroupController {\n+public:\n+  char* subsystem_path() override {\n+    \/\/ The real subsystem is in \/tmp\/, generaed by temp_file()\n+    return (char*)\"\/\";\n+  };\n+};\n+\n+void fill_file(const char* path, const char* content) {\n+  delete_file(path);\n+  FILE* fp = os::fopen(path, \"w\");\n+  if (fp == nullptr) {\n+    return;\n+  }\n+  if (content != nullptr) {\n+    fprintf(fp, \"%s\", content);\n+  }\n+  fclose(fp);\n+}\n+\n+TEST(cgroupTest, SubSystemFileLineContentsMultipleLinesErrorCases) {\n+  TestController my_controller{};\n+  const char* test_file = temp_file(\"cgroups\");\n+  int x = 0;\n+  char s[1024];\n+  int err = 0;\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"foo \");\n+  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  EXPECT_NE(err, 0) << \"Value must not be missing in key\/value case\";\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"faulty_start foo bar\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  EXPECT_NE(err, 0) << \"Key must be at start\";\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"foof bar\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  EXPECT_NE(err, 0) << \"Key must be exact match\";\n+}\n+\n+TEST(cgroupTest, SubSystemFileLineContentsMultipleLinesSuccessCases) {\n+  TestController my_controller{};\n+  const char* test_file = temp_file(\"cgroups\");\n+  int x = 0;\n+  char s[1024];\n+  int err = 0;\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"foo bar\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"bar\") << \"Incorrect!\";\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"foo\\tbar\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"bar\") << \"Incorrect!\";\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"foof bar\\nfoo car\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"car\");\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"foo\\ttest\\nfoot car\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"test\");\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"foo 1\\nfoo car\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"1\");\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"max 10000\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s %*d\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"max\");\n+\n+  x = -3;\n+  fill_file(test_file, \"max 10001\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%*s %d\", &x);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_EQ(x, 10001);\n+}\n+\n+TEST(cgroupTest, SubSystemFileLineContentsSingleLine) {\n+  TestController my_controller{};\n+  const char* test_file = temp_file(\"cgroups\");\n+  int x = 0;\n+  char s[1024];\n+  int err = 0;\n+\n+  fill_file(test_file, \"foo\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"foo\");\n+\n+  fill_file(test_file, \"1337\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%d\", &x);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_EQ(x, 1337) << \"Wrong value for x\";\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"1337\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"1337\");\n+\n+  x = -1;\n+  fill_file(test_file, nullptr);\n+  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%d\", &x);\n+  EXPECT_NE(err, 0) << \"Empty file should've failed\";\n+  EXPECT_EQ(x, -1) << \"x was altered\";\n+\n+  jlong y;\n+  fill_file(test_file, \"1337\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, JLONG_FORMAT, &y);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_EQ(y, 1337) << \"Wrong value for y\";\n+  julong z;\n+  fill_file(test_file, \"1337\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, JULONG_FORMAT, &z);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_EQ(z, (julong)1337) << \"Wrong value for z\";\n+}\n+\n+#endif \/\/ LINUX\n","filename":"test\/hotspot\/gtest\/os\/linux\/test_cgroupSubsystem_linux.cpp","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -39,1 +39,1 @@\n-TEST(os_linux_cgroup, set_cgroupv1_subsystem_path) {\n+TEST(cgroupTest, set_cgroupv1_subsystem_path) {\n@@ -63,1 +63,1 @@\n-TEST(os_linux_cgroup, set_cgroupv2_subsystem_path) {\n+TEST(cgroupTest, set_cgroupv2_subsystem_path) {\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux_cgroups.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,0 @@\n-\n-compiler\/c1\/TestPrintC1Statistics.java 8298053 linux-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -134,23 +134,0 @@\n-###\n-# These 2 tests try to create 10 vthreads and have them all block on a synchronized\n-# method call, but on some hosts there are not enough carrier threads to support pinning\n-# all 10 vthreads, so the test deadlocks. -Djdk.defaultScheduler.parallelism=<n>\n-# could be used with the debuggee to ensure there are enough carrier threads.\n-\n-vmTestbase\/nsk\/jdi\/EventRequestManager\/stepRequests\/stepreq002\/TestDescription.java 8285416 generic-all\n-vmTestbase\/nsk\/jdi\/EventRequestManager\/deleteEventRequests\/delevtreqs002\/TestDescription.java 8285416 generic-all\n-\n-###\n-# These tests all create 5 virtual threads that block on a synchronized block, which causes\n-# them to pin the carrier therad. On some of the macOS hosts there are only 4 cores,\n-# so by default you only get 4 carrier threads. When this happesn the test is unable to get all\n-# of the virtual threads started, and ends up timing out. -Djdk.defaultScheduler.parallelism=<n>\n-# could be used with the debuggee to ensure there are enough carrier threads.\n-\n-vmTestbase\/nsk\/jdb\/kill\/kill001\/kill001.java 8282383 macosx-x64\n-vmTestbase\/nsk\/jdi\/LocatableEvent\/thread\/thread001\/TestDescription.java 8282383 macosx-x64\n-vmTestbase\/nsk\/jdi\/Event\/request\/request001\/TestDescription.java 8282383 macosx-x64\n-vmTestbase\/nsk\/jdi\/EventIterator\/nextEvent\/nextevent001\/TestDescription.java 8282383 macosx-x64\n-vmTestbase\/nsk\/jdi\/EventRequestManager\/stepRequests\/stepreq001\/TestDescription.java 8282383 macosx-x64\n-vmTestbase\/nsk\/jdi\/ObjectReference\/waitingThreads\/waitingthreads002\/TestDescription.java 8282383 macosx-x64\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList-svc-vthread.txt","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,2 @@\n- * @bug 8283726\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+ * @bug 8283726 8287925\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n@@ -76,0 +76,24 @@\n+    @Test\n+    @IR(counts = {IRNode.CMP_U3, \"1\"})\n+    public int compareIntWithImm1(int x) {\n+        return Integer.compareUnsigned(x, 42);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMP_U3, \"1\"})\n+    public int compareIntWithImm2(int x) {\n+        return Integer.compareUnsigned(x, 42 << 12);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMP_U3, \"1\"})\n+    public int compareIntWithImm3(int x) {\n+        return Integer.compareUnsigned(x, 42 << 24);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMP_U3, \"1\"})\n+    public int compareIntWithImm4(int x) {\n+        return Integer.compareUnsigned(x, Integer.MIN_VALUE);\n+    }\n+\n@@ -82,1 +106,38 @@\n-    @Run(test = {\"lessThanInt\", \"lessThanLong\", \"compareInt\", \"compareLong\"})\n+    @Test\n+    @IR(counts = {IRNode.CMP_UL3, \"1\"})\n+    public int compareLongWithImm1(long x) {\n+        return Long.compareUnsigned(x, 42);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMP_UL3, \"1\"})\n+    public int compareLongWithImm2(long x) {\n+        return Long.compareUnsigned(x, 42 << 12);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMP_UL3, \"1\"})\n+    public int compareLongWithImm3(long x) {\n+        return Long.compareUnsigned(x, 42 << 24);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMP_UL3, \"1\"})\n+    public int compareLongWithImm4(long x) {\n+        return Long.compareUnsigned(x, Integer.MIN_VALUE);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CMP_UL3, \"1\"})\n+    public int compareLongWithImm5(long x) {\n+        return Long.compareUnsigned(x, Long.MIN_VALUE);\n+    }\n+\n+    @Run(test = {\"lessThanInt\", \"lessThanLong\",\n+                 \"compareInt\",\n+                 \"compareIntWithImm1\", \"compareIntWithImm2\",\n+                 \"compareIntWithImm3\", \"compareIntWithImm4\",\n+                 \"compareLong\",\n+                 \"compareLongWithImm1\", \"compareLongWithImm2\",\n+                 \"compareLongWithImm3\", \"compareLongWithImm4\",\n+                 \"compareLongWithImm5\"})\n@@ -92,0 +153,4 @@\n+            Asserts.assertEquals(compareIntWithImm1(x), expectedResult(x, 42));\n+            Asserts.assertEquals(compareIntWithImm2(x), expectedResult(x, 42 << 12));\n+            Asserts.assertEquals(compareIntWithImm3(x), expectedResult(x, 42 << 24));\n+            Asserts.assertEquals(compareIntWithImm4(x), expectedResult(x, Integer.MIN_VALUE));\n@@ -100,0 +165,5 @@\n+            Asserts.assertEquals(compareLongWithImm1(x), expectedResult(x, 42));\n+            Asserts.assertEquals(compareLongWithImm2(x), expectedResult(x, 42 << 12));\n+            Asserts.assertEquals(compareLongWithImm3(x), expectedResult(x, 42 << 24));\n+            Asserts.assertEquals(compareLongWithImm4(x), expectedResult(x, Integer.MIN_VALUE));\n+            Asserts.assertEquals(compareLongWithImm5(x), expectedResult(x, Long.MIN_VALUE));\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestCompareUnsigned.java","additions":74,"deletions":4,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-        t.runTest(methodObjClassCast,  true,  svalue);\n+        t.runTest(methodObjClassCast,  false,  svalue);\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/klass\/CastNullCheckDroppingsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,7 +35,16 @@\n- * @library \/compiler\/patches \/test\/lib\n- * @run main\/othervm -Xbatch -XX:Tier4InvocationThreshold=200 -XX:CompileThreshold=100 compiler.intrinsics.string.TestStringLatin1IndexOfChar\n- * @run main\/othervm -Xbatch -XX:Tier4InvocationThreshold=200 -XX:CompileThreshold=100 -XX:+UnlockDiagnosticVMOptions -XX:DisableIntrinsic=_indexOfL_char compiler.intrinsics.string.TestStringLatin1IndexOfChar\n- * @run main\/othervm -Xbatch -XX:Tier4InvocationThreshold=200 -XX:CompileThreshold=100 -XX:+IgnoreUnrecognizedVMOptions -XX:UseSSE=0 compiler.intrinsics.string.TestStringLatin1IndexOfChar\n- * @run main\/othervm -Xbatch -XX:Tier4InvocationThreshold=200 -XX:CompileThreshold=100 -XX:+IgnoreUnrecognizedVMOptions -XX:UseAVX=1 compiler.intrinsics.string.TestStringLatin1IndexOfChar\n- * @run main\/othervm -Xbatch -XX:Tier4InvocationThreshold=200 -XX:CompileThreshold=100 -XX:+IgnoreUnrecognizedVMOptions -XX:UseAVX=2 compiler.intrinsics.string.TestStringLatin1IndexOfChar\n- * @run main\/othervm -Xbatch -XX:Tier4InvocationThreshold=200 -XX:CompileThreshold=100 -XX:+IgnoreUnrecognizedVMOptions -XX:UseAVX=3 compiler.intrinsics.string.TestStringLatin1IndexOfChar\n+ * @requires vm.compiler2.enabled\n+ * @library \/compiler\/patches \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch compiler.intrinsics.string.TestStringLatin1IndexOfChar\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:DisableIntrinsic=_indexOfL_char compiler.intrinsics.string.TestStringLatin1IndexOfChar\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:UseAVX=0 compiler.intrinsics.string.TestStringLatin1IndexOfChar\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:UseAVX=1 compiler.intrinsics.string.TestStringLatin1IndexOfChar\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:UseAVX=2 compiler.intrinsics.string.TestStringLatin1IndexOfChar\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:UseAVX=3 compiler.intrinsics.string.TestStringLatin1IndexOfChar\n@@ -47,0 +56,3 @@\n+import jdk.test.whitebox.WhiteBox;\n+import java.lang.reflect.Method;\n+import compiler.whitebox.CompilerWhiteBoxTest;\n@@ -49,0 +61,1 @@\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n@@ -52,1 +65,21 @@\n-        for (int i = 0; i < 1_000; ++i) {\/\/repeat such that we enter into C2 code...\n+        Method methodFindOneItem    = TestStringLatin1IndexOfChar.class.getDeclaredMethod(\"findOneItem\");\n+        Method methodWithOffsetTest = TestStringLatin1IndexOfChar.class.getDeclaredMethod(\"withOffsetTest\");\n+        Method methodTestEmpty      = TestStringLatin1IndexOfChar.class.getDeclaredMethod(\"testEmpty\");\n+        Asserts.assertNotNull(methodFindOneItem);\n+        Asserts.assertNotNull(methodWithOffsetTest);\n+        Asserts.assertNotNull(methodTestEmpty);\n+\n+        \/\/ Warmup - profiling must inline the methods\n+        for (int i = 0; i < 10; ++i) {\n+            findOneItem();\n+            withOffsetTest();\n+            testEmpty();\n+        }\n+\n+        \/\/ Compile\n+        WHITE_BOX.enqueueMethodForCompilation(methodFindOneItem,    CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+        WHITE_BOX.enqueueMethodForCompilation(methodWithOffsetTest, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+        WHITE_BOX.enqueueMethodForCompilation(methodTestEmpty,      CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+\n+        \/\/ Run compiled method\n+        for (int i = 0; i < 10; ++i) {\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestStringLatin1IndexOfChar.java","additions":41,"deletions":8,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1207,0 +1207,10 @@\n+    public static final String XOR3_NEON = PREFIX + \"XOR3_NEON\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(XOR3_NEON, \"veor3_neon\");\n+    }\n+\n+    public static final String XOR3_SVE = PREFIX + \"XOR3_SVE\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(XOR3_SVE, \"veor3_sve\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class TestBackedgeLoadArrayFill\n+{\n+    public Method \"<init>\":\"()V\"\n+    stack 2 locals 1\n+    {\n+        aload_0;\n+        invokespecial  Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    static Method test_101:\"()V\"\n+    stack 20 locals 20\n+    {\n+        \/\/ test_002 in jasm: using try-catch\n+        ldc 6;\n+        istore_0; \/\/ i = 6\n+        ldc 25;\n+        newarray int;\n+        astore_1; \/\/ arr = new int[25]\n+    HEAD:\n+        aload_1;\n+        iload_0;\n+        iconst_1;\n+        iastore; \/\/ arr[i] = 1\n+        \/\/ second block - the only one -> head block can be copied: one before, one on backedge\n+        try t0;\n+        aload_1;\n+        iload_0;\n+        aload_1;\n+        iload_0;\n+        iaload;\n+        iastore; \/\/ arr[i] = arr[i]\n+        goto FINALLY;\n+        endtry t0;\n+        catch t0 java\/lang\/Exception;\n+        pop; \/\/ exception\n+    FINALLY:\n+        iinc 0, 1; \/\/ i++\n+        iload_0;\n+        ldc 21;\n+        if_icmplt HEAD; \/\/ if i < 21\n+        \/\/ write array\n+        aload_1;\n+        putstatic Field TestBackedgeLoadArrayFillMain.intA:\"[I\";\n+        return;\n+    }\n+\n+    static Method test_102:\"()V\"\n+    stack 20 locals 20\n+    {\n+        \/\/ test_002 in jasm: without try-catch\n+        ldc 5;\n+        istore_0; \/\/ i = 5\n+        ldc 25;\n+        newarray int;\n+        astore_1; \/\/ arr = new int[25]\n+    HEAD:\n+        aload_1;\n+        iload_0;\n+        iconst_1;\n+        iastore; \/\/ arr[i] = 1\n+        goto SECOND;\n+        \/\/ second block - the only one -> head block can be copied: one before, one on backedge\n+        \/\/ must have some material before inc, else it is partial peeled away\n+        \/\/ And if we set -XX:-PartialPeelLoop, then the counted loop is never detected\n+    SECOND:\n+        aload_1;\n+        iload_0;\n+        aload_1;\n+        iload_0;\n+        iaload;\n+        iastore; \/\/ arr[i] = arr[i]\n+        iinc 0, 1; \/\/ i++\n+        iload_0;\n+        ldc 21;\n+        if_icmplt HEAD; \/\/ if i < 21\n+        \/\/ write array\n+        aload_1;\n+        putstatic Field TestBackedgeLoadArrayFillMain.intA:\"[I\";\n+        return;\n+    }\n+\n+    static Method test_103:\"()V\"\n+    stack 20 locals 20\n+    {\n+        \/\/ test_002 in jasm: without try-catch, and second array\n+        ldc 7;\n+        istore_0; \/\/ i = 7\n+        ldc 25;\n+        newarray int;\n+        astore_1; \/\/ arr = new int[25]\n+        ldc 25;\n+        newarray int;\n+        astore_2; \/\/ arr2 = new int[25]\n+    HEAD:\n+        aload_1;\n+        iload_0;\n+        iconst_1;\n+        iastore; \/\/ arr[i] = 1\n+        goto SECOND;\n+        \/\/ second block - the only one -> head block can be copied: one before, one on backedge\n+    SECOND:\n+        \/\/ we can also do the identity read-write on another array - it just has to eventually disappear\n+        aload_2;\n+        iload_0;\n+        aload_2;\n+        iload_0;\n+        iaload;\n+        iastore; \/\/ arr2[i] = arr2[i]\n+\n+        iinc 0, 1; \/\/ i++\n+        iload_0;\n+        ldc 21;\n+        if_icmplt HEAD; \/\/ if i < 21\n+        \/\/ write array\n+        aload_1;\n+        putstatic Field TestBackedgeLoadArrayFillMain.intA:\"[I\";\n+        return;\n+    }\n+\n+    static Method test_104:\"()V\"\n+    stack 20 locals 20\n+    {\n+        ldc 9;\n+        istore_0; \/\/ i = 9\n+        ldc 25;\n+        newarray int;\n+        astore_1; \/\/ arr = new int[25]\n+    HEAD:\n+        aload_1;\n+        iload_0;\n+        iconst_1;\n+        iastore; \/\/ arr[i] = 1\n+        goto SECOND;\n+        \/\/ second block - the only one -> head block can be copied: one before, one on backedge\n+    SECOND:\n+        \/\/ CFG leads to partial peel -> load moved into loop body, then intrinsified\n+        iload_0;\n+        ldc 2;\n+        irem;\n+        ifeq SKIP;\n+\n+    SKIP:\n+\n+        iinc 0, 1; \/\/ i++\n+        iload_0;\n+        ldc 21;\n+        if_icmplt HEAD; \/\/ if i < 21\n+        \/\/ write array\n+        aload_1;\n+        putstatic Field TestBackedgeLoadArrayFillMain.intA:\"[I\";\n+        return;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestBackedgeLoadArrayFill.jasm","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -0,0 +1,231 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8299179\n+ * @summary ArrayFill: if store is on backedge, last iteration is not to be executed.\n+ * @library \/test\/lib\n+ * @compile TestBackedgeLoadArrayFill.jasm\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,TestBackedgeLoadArrayFill*::test*\n+ *      -XX:-TieredCompilation -Xcomp -XX:+OptimizeFill\n+ *      TestBackedgeLoadArrayFillMain\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,TestBackedgeLoadArrayFill*::test*\n+ *      -XX:-TieredCompilation -Xcomp -XX:+OptimizeFill\n+ *      -XX:LoopUnrollLimit=1\n+ *      TestBackedgeLoadArrayFillMain\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+public class TestBackedgeLoadArrayFillMain {\n+    static long[]  longA;\n+    static int[]   intA;\n+    static short[] shortA;\n+    static byte[]  byteA;\n+\n+    static class Data {\n+        long longValue;\n+        int intValue;\n+        short shortValue;\n+        byte byteValue;\n+\n+        Data(int value) {\n+            longValue  = (long)  value;\n+            intValue   = (int)   value;\n+            shortValue = (short) value;\n+            longValue  = (byte)  value;\n+        }\n+    }\n+\n+    public static long longSum() {\n+        long s = 0;\n+        for (long v : longA) { s += v; }\n+        return s;\n+    }\n+\n+    public static int intSum() {\n+        int s = 0;\n+        for (int v : intA) { s += v; }\n+        return s;\n+    }\n+\n+    public static short shortSum() {\n+        short s = 0;\n+        for (short v : shortA) { s += v; }\n+        return s;\n+    }\n+\n+    public static byte byteSum() {\n+        byte s = 0;\n+        for (byte v : byteA) { s += v; }\n+        return s;\n+    }\n+\n+    static void test_001() {\n+        \/\/ long seems not yet supported\n+        int i = 6;\n+        long arr[] = new long[22];\n+        do {\n+            arr[i] = 1;\n+            try {\n+                arr[i] = arr[i];\n+            } catch (Exception e) {\n+            }\n+        } while (++i < 20);\n+        longA = arr;\n+    }\n+\n+    static void test_002() {\n+        \/\/ jint_fill\n+        int i = 6;\n+        int arr[] = new int[22];\n+        do {\n+            arr[i] = 1;\n+            try {\n+                arr[i] = arr[i];\n+            } catch (Exception e) {\n+            }\n+        } while (++i < 20);\n+        intA = arr;\n+    }\n+\n+    static void test_003() {\n+        \/\/ jshort_fill\n+        int i = 6;\n+        short arr[] = new short[22];\n+        do {\n+            \/\/ first block of loop: copied before loop, and onto backedge -> store on backedge\n+            arr[i] = 1;\n+            \/\/ second block of loop\n+            try {\n+                arr[i] = arr[i];\n+            } catch (Exception e) {\n+            }\n+        } while (++i < 20);\n+        shortA = arr;\n+    }\n+\n+    static void test_004() {\n+        \/\/ jbyte_fill\n+        int i = 6;\n+        byte arr[] = new byte[22];\n+        do {\n+            arr[i] = 1;\n+            try {\n+                arr[i] = arr[i];\n+            } catch (Exception e) {\n+            }\n+        } while (++i < 20);\n+        byteA = arr;\n+    }\n+\n+    static void test_005() {\n+        \/\/ Note: currently unrolled, not intrinsified (unless -XX:LoopUnrollLimit=1)\n+        int arr[] = new int[22];\n+        for (int i = 6; i < 20; i++) {\n+            arr[i] = 1;\n+        }\n+        intA = arr;\n+    }\n+\n+    static void test_006() {\n+        \/\/ Note: currently unrolled, not intrinsified (unless -XX:LoopUnrollLimit=1)\n+        \/\/ Load in normal body, because not moved to backedge during parsing.\n+        int i = 6;\n+        int arr[] = new int[22];\n+        do {\n+            arr[i] = 1;\n+        } while (++i < 20);\n+        intA = arr;\n+    }\n+\n+    static void test_007() {\n+        int i = 6;\n+        int arr[] = new int[22];\n+        do {\n+            \/\/ still not on backedge [7,20) partial peel\n+            arr[i] = 1;\n+            try { int x = arr[i]; } catch (Exception e) {}\n+        } while (++i < 20);\n+        intA = arr;\n+    }\n+\n+    static void test_008(Data data) {\n+        \/\/ Because of conditional in loop, at first not intrinsified, and also not unrolled.\n+        \/\/ After unswitching both loops are intrinsified.\n+        \/\/ I stole this idea from TestOptimizeFillWithStripMinedLoop.java\n+        int i = 6;\n+        int arr[] = new int[22];\n+        do {\n+            arr[i] = (data == null) ? 1 : data.intValue;\n+        } while (++i < 20);\n+        intA = arr;\n+    }\n+\n+    static void test_009() {\n+        \/\/ Cast to int leads to \"missing use of index\", not intrinsified\n+        int arr[] = new int[22];\n+        for (long i = 6; i < 20; i++) {\n+            arr[(int)i] = 1;\n+        }\n+        intA = arr;\n+    }\n+\n+\n+    public static void main(String[] strArr) {\n+        test_001();\n+        Asserts.assertEQ(longSum(),  (long)14);\n+        test_002();\n+        Asserts.assertEQ(intSum(),   14);\n+        test_003();\n+        Asserts.assertEQ(shortSum(), (short)14);\n+        test_004();\n+        Asserts.assertEQ(byteSum(),  (byte)14);\n+        test_005();\n+        Asserts.assertEQ(intSum(),   14);\n+        test_006();\n+        Asserts.assertEQ(intSum(),   14);\n+        test_007();\n+        Asserts.assertEQ(intSum(),   14);\n+        test_008(new Data(1));\n+        Asserts.assertEQ(intSum(),   14);\n+        test_008(null);\n+        Asserts.assertEQ(intSum(),   14);\n+        test_009();\n+        Asserts.assertEQ(intSum(),   14);\n+        TestBackedgeLoadArrayFill t = new TestBackedgeLoadArrayFill();\n+        t.test_101();\n+        Asserts.assertEQ(intSum(),   15);\n+        t.test_102();\n+        Asserts.assertEQ(intSum(),   16);\n+        t.test_103();\n+        Asserts.assertEQ(intSum(),   14);\n+        t.test_104();\n+        Asserts.assertEQ(intSum(),   12);\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestBackedgeLoadArrayFillMain.java","additions":231,"deletions":0,"binary":false,"changes":231,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test TestTypeProfileArgsLimit\n+ * @bug 8295406\n+ * @summary Tests execution with TypeProfileArgsLimit=0 TypeProfileLevel=222.\n+ *\n+ * @run main\/othervm -XX:TypeProfileArgsLimit=0 -XX:TypeProfileLevel=222 compiler.profiling.TestTypeProfileArgsLimit\n+ * @run main\/othervm -XX:TypeProfileArgsLimit=0 -XX:TypeProfileLevel=212 compiler.profiling.TestTypeProfileArgsLimit\n+ * @run main\/othervm -XX:TypeProfileArgsLimit=0 -XX:TypeProfileLevel=202 compiler.profiling.TestTypeProfileArgsLimit\n+ * @run main\/othervm -XX:TypeProfileParmsLimit=0 -XX:TypeProfileLevel=222 compiler.profiling.TestTypeProfileArgsLimit\n+ * @run main\/othervm -XX:TypeProfileParmsLimit=0 -XX:TypeProfileArgsLimit=0 -XX:TypeProfileLevel=222 compiler.profiling.TestTypeProfileArgsLimit\n+ * @run main\/othervm -XX:TypeProfileParmsLimit=-1 -XX:TypeProfileArgsLimit=0 -XX:TypeProfileLevel=222 compiler.profiling.TestTypeProfileArgsLimit\n+ *\/\n+\n+package compiler.profiling;\n+\n+public class TestTypeProfileArgsLimit {\n+    public static void main(String args[]) {\n+        System.out.println(\"Passed\");\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/profiling\/TestTypeProfileArgsLimit.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @key stress randomness\n+* @bug 8299259\n+* @requires vm.compiler2.enabled\n+* @summary Test various cases of divisions\/modulo which should not be split through iv phis.\n+* @run main\/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:LoopUnrollLimit=0 -XX:+StressGCM -XX:StressSeed=884154126\n+*                   -XX:CompileCommand=compileonly,compiler.splitif.TestSplitDivisionThroughPhi::*\n+*                   compiler.splitif.TestSplitDivisionThroughPhi\n+*\/\n+\n+\/**\n+* @test\n+* @key stress randomness\n+* @bug 8299259\n+* @requires vm.compiler2.enabled\n+* @summary Test various cases of divisions\/modulo which should not be split through iv phis.\n+* @run main\/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:LoopUnrollLimit=0 -XX:+StressGCM\n+*                   -XX:CompileCommand=compileonly,compiler.splitif.TestSplitDivisionThroughPhi::*\n+*                   compiler.splitif.TestSplitDivisionThroughPhi\n+*\/\n+\n+package compiler.splitif;\n+\n+public class TestSplitDivisionThroughPhi {\n+    static int iFld;\n+    static long lFld;\n+    static boolean flag;\n+\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 5000; i++) {\n+            testPushDivIThruPhi();\n+            testPushDivIThruPhiInChain();\n+            testPushModIThruPhi();\n+            testPushModIThruPhiInChain();\n+            testPushDivLThruPhi();\n+            testPushDivLThruPhiInChain();\n+            testPushModLThruPhi();\n+            testPushModLThruPhiInChain();\n+        }\n+    }\n+\n+    \/\/ Already fixed by JDK-8248552.\n+    static void testPushDivIThruPhi() {\n+        for (int i = 10; i > 1; i -= 2) {\n+            \/\/ The Div node is only split in later loop opts phase because the zero divisor check is only removed\n+            \/\/ in IGVN after the first loop opts phase.\n+            \/\/\n+            \/\/ iv phi i type: [2..10]\n+            \/\/ When splitting the DivI through the iv phi, it ends up on the back edge with the trip count decrement\n+            \/\/ as input which has type [0..8]. We end up executing a division by zero on the last iteration because\n+            \/\/ the DivI it is not pinned to the loop exit test and can freely float above the loop exit check.\n+            iFld = 10 \/ i;\n+        }\n+    }\n+\n+   \/\/ Same as above but with an additional Mul node between the iv phi and the Div node. Both nodes are split through\n+   \/\/ the iv phi in one pass of Split If.\n+    static void testPushDivIThruPhiInChain() {\n+        for (int i = 10; i > 1; i -= 2) {\n+            \/\/ Empty one iteration loop which is only removed after split if in first loop opts phase. This prevents\n+            \/\/ that the Mul node is already split through the iv phi while the Div node cannot be split yet due to\n+            \/\/ the zero divisor check which can only be removed in the IGVN after the first loop opts pass.\n+            for (int j = 0; j < 1; j++) {\n+            }\n+            iFld = 10 \/ (i * 100);\n+        }\n+    }\n+\n+    \/\/ Already fixed by JDK-8248552.\n+    static void testPushModIThruPhi() {\n+        for (int i = 10; i > 1; i -= 2) {\n+            iFld = 10 \/ i;\n+        }\n+    }\n+\n+    \/\/ Same as above but with ModI.\n+    static void testPushModIThruPhiInChain() {\n+        for (int i = 10; i > 1; i -= 2) {\n+            for (int j = 0; j < 1; j++) {\n+            }\n+            iFld = 10 \/ (i * 100);\n+        }\n+    }\n+\n+    \/\/ Long cases only trigger since JDK-8256655.\n+\n+    \/\/ Same as above but with DivL.\n+    static void testPushDivLThruPhi() {\n+        for (long i = 10; i > 1; i -= 2) {\n+            lFld = 10L \/ i;\n+\n+            \/\/ Loop that is not removed such that we do not transform the outer LongCountedLoop (only done if innermost)\n+            for (int j = 0; j < 10; j++) {\n+                flag = !flag;\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as above but with DivL.\n+    static void testPushDivLThruPhiInChain() {\n+        for (long i = 10; i > 1; i -= 2) {\n+            for (int j = 0; j < 1; j++) {\n+            }\n+            lFld = 10L \/ (i * 100L);\n+\n+            for (int j = 0; j < 10; j++) {\n+                flag = !flag;\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as above but with ModL\n+    static void testPushModLThruPhi() {\n+        for (long i = 10; i > 1; i -= 2) {\n+            lFld = 10L % i;\n+\n+            for (int j = 0; j < 10; j++) {\n+                flag = !flag;\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as above but with ModL\n+    static void testPushModLThruPhiInChain() {\n+        for (long i = 10; i > 1; i -= 2) {\n+            for (int j = 0; j < 1; j++) {\n+            }\n+            lFld = 10L % (i * 100L);\n+\n+            for (int j = 0; j < 10; j++) {\n+                flag = !flag;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/splitif\/TestSplitDivisionThroughPhi.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8297556\n+ * @summary Parse::check_interpreter_type fails with assert \"must constrain OSR typestate\"\n+ *\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation -XX:CompileOnly=TestExactArrayOfBasicType::test TestExactArrayOfBasicType\n+ *\n+ *\/\n+\n+\n+public class TestExactArrayOfBasicType {\n+    public static void test() {\n+        int[][][][][] array = new int[1][2][3][4][5];\n+\n+        for (int i = 0; i < 50_000; ++i) {\n+            array[0] = new int[0][1][2][3];\n+        }\n+    }\n+\n+    public static void main(String args[]) {\n+        test();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/types\/TestExactArrayOfBasicType.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -82,1 +82,1 @@\n-            m[i] = RD.nextBoolean();\n+            m[i] = i % 2 == 0;\n@@ -105,0 +105,2 @@\n+        \/\/ \"mask\" is guaranteed to be not alltrue, in case the masked\n+        \/\/ gather load is optimized to the non-masked version.\n@@ -135,0 +137,2 @@\n+        \/\/ \"mask\" is guaranteed to be not alltrue, in case the masked\n+        \/\/ scatter store is optimized to the non-masked version.\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorGatherScatterTest.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -81,2 +81,2 @@\n-    @IR(counts = {\"veor3_neon\", \"> 0\"}, applyIf = {\"MaxVectorSize\", \"16\"}, applyIfCPUFeature = {\"sha3\", \"true\"})\n-    @IR(counts = {\"veor3_sve\", \"> 0\"}, applyIfAnd = {\"UseSVE\", \"2\", \"MaxVectorSize\", \"> 16\"})\n+    @IR(counts = {IRNode.XOR3_NEON, \"> 0\"}, applyIf = {\"MaxVectorSize\", \"16\"}, applyIfCPUFeature = {\"sha3\", \"true\"})\n+    @IR(counts = {IRNode.XOR3_SVE, \"> 0\"}, applyIfAnd = {\"UseSVE\", \"2\", \"MaxVectorSize\", \"> 16\"})\n@@ -99,2 +99,2 @@\n-    @IR(counts = {\"veor3_neon\", \"> 0\"}, applyIf = {\"MaxVectorSize\", \"16\"}, applyIfCPUFeature = {\"sha3\", \"true\"})\n-    @IR(counts = {\"veor3_sve\", \"> 0\"}, applyIfAnd = {\"UseSVE\", \"2\", \"MaxVectorSize\", \"> 16\"})\n+    @IR(counts = {IRNode.XOR3_NEON, \"> 0\"}, applyIf = {\"MaxVectorSize\", \"16\"}, applyIfCPUFeature = {\"sha3\", \"true\"})\n+    @IR(counts = {IRNode.XOR3_SVE, \"> 0\"}, applyIfAnd = {\"UseSVE\", \"2\", \"MaxVectorSize\", \"> 16\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestEor3AArch64.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.nio.file.Paths;\n@@ -360,0 +361,2 @@\n+        \/\/ get the real path in case the firstJar is specified as a relative path\n+        firstJar = Paths.get(firstJar).toRealPath().toString();\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestCommon.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+public class NoSuchFieldArray {\n+    static char[] z;\n+    public NoSuchFieldArray() {\n+        z = new char[1];\n+    }\n+}\n+*\/\n+\n+super public class NoSuchFieldArray\n+\tversion 65:0\n+{\n+  \/\/ REMOVED static Field z:\"[C\";\n+\n+  public Method \"<init>\":\"()V\"\n+\tstack 1 locals 1\n+  {\n+\t\taload_0;\n+\t\tinvokespecial\tMethod java\/lang\/Object.\"<init>\":\"()V\";\n+\t\ticonst_1;\n+\t\tnewarray char;\n+\t\tputstatic\tField z:\"[C\";\n+\t\treturn;\n+  }\n+\n+} \/\/ end Class NoSuchFieldArray\n","filename":"test\/hotspot\/jtreg\/runtime\/linkResolver\/NoSuchFieldArray.jasm","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+public class NoSuchFieldMultiArray {\n+    static double[][] a;\n+    public NoSuchFieldMultiArray() {\n+        a = new double[1][1];\n+    }\n+}\n+*\/\n+\n+super public class NoSuchFieldMultiArray\n+\tversion 65:0\n+{\n+  \/\/ REMOVED static Field a:\"[[D\";\n+\n+  public Method \"<init>\":\"()V\"\n+\tstack 2 locals 1\n+  {\n+\t\taload_0;\n+\t\tinvokespecial\tMethod java\/lang\/Object.\"<init>\":\"()V\";\n+\t\ticonst_1;\n+\t\ticonst_1;\n+\t\tmultianewarray\tclass \"[[D\",  2;\n+\t\tputstatic\tField a:\"[[D\";\n+\t\treturn;\n+  }\n+\n+} \/\/ end Class NoSuchFieldMultiArray\n","filename":"test\/hotspot\/jtreg\/runtime\/linkResolver\/NoSuchFieldMultiArray.jasm","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298065\n+ * @summary Test output of NoSuchFieldError when field signature does not match\n+ * @compile NoSuchFieldPrimitive.jasm NoSuchFieldReference.jasm TestClass.java\n+ * @compile NoSuchFieldArray.jasm NoSuchFieldMultiArray.jasm\n+ * @run main NoSuchFieldOutputTest\n+ *\/\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/\/ Tests the output text of NoSuchFieldError\n+public class NoSuchFieldOutputTest {\n+\n+  public static void main(java.lang.String[] unused) throws Exception {\n+    try {\n+      Class.forName(\"NoSuchFieldPrimitive\").newInstance();\n+    } catch (NoSuchFieldError nsfe) {\n+      testNoSuchFieldOutput(nsfe, \"primitive\");\n+    }\n+    try {\n+      Class.forName(\"NoSuchFieldReference\").newInstance();\n+    } catch (NoSuchFieldError nsfe) {\n+      testNoSuchFieldOutput(nsfe, \"reference\");\n+    }\n+    try {\n+      Class.forName(\"NoSuchFieldArray\").newInstance();\n+    } catch (NoSuchFieldError nsfe) {\n+      testNoSuchFieldOutput(nsfe, \"array\");\n+    }\n+    try {\n+      Class.forName(\"NoSuchFieldMultiArray\").newInstance();\n+    } catch (NoSuchFieldError nsfe) {\n+      testNoSuchFieldOutput(nsfe, \"multiArray\");\n+    }\n+  }\n+\n+  private static void testNoSuchFieldOutput(NoSuchFieldError nsfe, String testType) throws Exception {\n+    Pattern noSuchFieldPattern = Pattern.compile(\"Class (?<classname>[\\\\w\\\\d]+) does not have member field '(?<signature>[\\\\S]+) (?<varname>[\\\\w\\\\d]+)'\");\n+    String output = nsfe.getMessage();\n+    Matcher noSuchFieldMatcher = noSuchFieldPattern.matcher(output);\n+    if (noSuchFieldMatcher.matches()) {\n+      switch (testType) {\n+      case \"primitive\":\n+        checkOutputGroups(noSuchFieldMatcher, output, \"NoSuchFieldPrimitive\", \"int\", \"x\");\n+        break;\n+      case \"reference\":\n+        checkOutputGroups(noSuchFieldMatcher, output, \"NoSuchFieldReference\", \"TestClass\", \"y\");\n+        break;\n+      case \"array\":\n+        checkOutputGroups(noSuchFieldMatcher, output, \"NoSuchFieldArray\", \"char[]\", \"z\");\n+        break;\n+      case \"multiArray\":\n+        checkOutputGroups(noSuchFieldMatcher, output, \"NoSuchFieldMultiArray\", \"double[][]\", \"a\");\n+        break;\n+      default:\n+        throwTestException(\"No matching test\", output);\n+      }\n+    } else {\n+      throwTestException(\"Output format does not match\", output);\n+    }\n+    System.out.println(output);\n+  }\n+\n+  private static void checkOutputGroups(Matcher noSuchFieldMatcher, String output,\n+                                 String testClass, String testSig, String testVar) throws Exception {\n+    String classname = noSuchFieldMatcher.group(\"classname\");\n+    String signature = noSuchFieldMatcher.group(\"signature\");\n+    String varname   = noSuchFieldMatcher.group(\"varname\");\n+    if (!classname.equals(testClass)) {\n+      throwTestException(\"Failed to match class name\", output);\n+    }\n+    if (!signature.equals(testSig)) {\n+      throwTestException(\"Failed to match type signature\", output);\n+    }\n+    if (!varname.equals(testVar)) {\n+      throwTestException(\"Failed to match field name\", output);\n+    }\n+  }\n+\n+  private static void throwTestException(String reason, String output) throws Exception {\n+      throw new Exception(reason + \" . Stdout is :\\n\" + output);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/linkResolver\/NoSuchFieldOutputTest.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+public class NoSuchFieldPrimitive {\n+    \/\/ static int x;\n+    public NoSuchFieldPrimitive() {\n+       x = 123;\n+    }\n+}\n+*\/\n+\n+super public class NoSuchFieldPrimitive\n+\tversion 65:0\n+{\n+  \/\/ REMOVED static Field x:I;\n+\n+  public Method \"<init>\":\"()V\"\n+\tstack 1 locals 1\n+  {\n+\t\taload_0;\n+\t\tinvokespecial\tMethod java\/lang\/Object.\"<init>\":\"()V\";\n+\t\tbipush\t123;\n+\t\tputstatic\tField x:\"I\";\n+\t\treturn;\n+  }\n+\n+} \/\/ end Class NoSuchFieldPrimitive\n","filename":"test\/hotspot\/jtreg\/runtime\/linkResolver\/NoSuchFieldPrimitive.jasm","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+public class NoSuchFieldReference {\n+    static TestClass y;\n+    public NoSuchFieldReference() {\n+        y = new TestClass();\n+    }\n+}\n+*\/\n+\n+super public class NoSuchFieldReference\n+\tversion 65:0\n+{\n+  \/\/ REMOVED static Field y:\"LTestClass;\";\n+\n+  public Method \"<init>\":\"()V\"\n+\tstack 2 locals 1\n+  {\n+\t\taload_0;\n+\t\tinvokespecial\tMethod java\/lang\/Object.\"<init>\":\"()V\";\n+\t\tnew\tclass TestClass;\n+\t\tdup;\n+\t\tinvokespecial\tMethod TestClass.\"<init>\":\"()V\";\n+\t\tputstatic\tField y:\"LTestClass;\";\n+\t\treturn;\n+  }\n+\n+} \/\/ end Class NoSuchFieldReference\n","filename":"test\/hotspot\/jtreg\/runtime\/linkResolver\/NoSuchFieldReference.jasm","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Used as a reference type for a field in NoSuchFieldReference.jasm\n+public class TestClass {}\n","filename":"test\/hotspot\/jtreg\/runtime\/linkResolver\/TestClass.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -59,1 +59,1 @@\n-                \"field TenuredGeneration _the_space ContiguousSpace*\",\n+                \"field TenuredGeneration _the_space TenuredSpace*\",\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbField.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,1 +166,0 @@\n-            \/* Need --enable-preview on the debuggee in order to support virtual threads. *\/\n@@ -169,0 +168,1 @@\n+                \/* Need --enable-preview on the debuggee in order to support virtual threads. *\/\n@@ -170,0 +170,2 @@\n+                \/* Some tests need more carrier threads than the default provided. *\/\n+                args.add(\"-R-Djdk.virtualThreadScheduler.parallelism=15\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdb\/Launcher.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -754,1 +754,0 @@\n-        \/* Need --enable-preview on the debuggee in order to support virtual threads. *\/\n@@ -757,0 +756,1 @@\n+            \/* Need --enable-preview on the debuggee in order to support virtual threads. *\/\n@@ -758,0 +758,2 @@\n+            \/* Some tests need more carrier threads than the default provided. *\/\n+            vmArgs += \" -Djdk.virtualThreadScheduler.parallelism=15\";\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdi\/Binder.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -225,1 +225,0 @@\n-sun\/java2d\/DirectX\/MultiPaintEventTest\/MultiPaintEventTest.java 8284825 windows-all\n@@ -624,0 +623,2 @@\n+java\/security\/Policy\/Root\/Root.java                             8299994 generic-all\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,198 @@\n+\/*\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8139581\n+ * @summary Verify that components are redrawn after\n+ * removal and addition to a container\n+ * @run main ComponentRedrawnTest\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Panel;\n+import java.awt.Robot;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.MouseEvent;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.swing.JButton;\n+\n+public class ComponentRedrawnTest {\n+\n+    private static Frame frame;\n+    private static Panel componentPanel;\n+    private static Button buttonRemove;\n+    private static Button buttonAdd;\n+    private static Button awtButton;\n+\n+    private static volatile Robot robot;\n+    private static volatile int x;\n+    private static volatile int y;\n+    private static AtomicInteger awtPainted = new AtomicInteger();\n+    private static AtomicInteger swingPainted = new AtomicInteger();\n+\n+    public static void main(String args[]) throws Exception {\n+        try {\n+            EventQueue.invokeAndWait(() -> createGUI());\n+            runTest();\n+            System.out.println(\"Test Passed\");\n+        } finally {\n+            EventQueue.invokeAndWait(() -> dispose());\n+        }\n+    }\n+\n+    private static void createGUI() {\n+        frame = new Frame(\"ComponentRedrawnTest\");\n+        frame.setSize(350, 300);\n+        frame.setBackground(Color.red);\n+\n+        componentPanel = new Panel();\n+        componentPanel.setLayout(null);\n+        componentPanel.setBackground(Color.green);\n+\n+        awtButton = new Button(\"AWT Button\") {\n+            @Override\n+            public void paint(Graphics g) {\n+                super.paint(g);\n+                awtPainted.incrementAndGet();\n+            }\n+        };\n+\n+        awtButton.setBounds(0, 0, 330, 100);\n+        componentPanel.add(awtButton);\n+\n+        JButton swingButton = new JButton(\"Swing JButton\") {\n+            @Override\n+            public void paint(Graphics g) {\n+                super.paint(g);\n+                swingPainted.incrementAndGet();\n+            }\n+        };\n+\n+        swingButton.setBounds(0, 100, 330, 100);\n+        componentPanel.add(swingButton);\n+        frame.add(componentPanel, BorderLayout.CENTER);\n+        buttonRemove = new Button(\"remove\");\n+        buttonRemove.addActionListener(ae -> buttonClicked(ae));\n+\n+        buttonAdd = new Button(\"add\");\n+        buttonAdd.addActionListener(ae -> buttonClicked(ae));\n+\n+        Panel controlPanel = new Panel();\n+        controlPanel.setLayout(new BorderLayout());\n+        controlPanel.add(buttonRemove, BorderLayout.NORTH);\n+        controlPanel.add(buttonAdd, BorderLayout.SOUTH);\n+\n+        frame.add(controlPanel, BorderLayout.SOUTH);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    private static void buttonClicked(ActionEvent ae) {\n+        if (ae.getSource() == buttonRemove) {\n+            frame.remove(componentPanel);\n+        } else if (ae.getSource() == buttonAdd) {\n+            frame.add(componentPanel);\n+        }\n+        frame.invalidate();\n+        frame.validate();\n+    }\n+\n+    private static void runTest() throws Exception {\n+        EventQueue.invokeAndWait(() -> createGUI());\n+        robot = new Robot();\n+        robot.setAutoDelay(500);\n+        awtPainted.set(0);\n+        swingPainted.set(0);\n+\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                x = awtButton.getLocationOnScreen().x\n+                    + awtButton.getSize().width \/ 2;\n+                y = awtButton.getLocationOnScreen().y\n+                    + awtButton.getSize().height \/ 2;\n+            });\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unexpected Exception encountered: \" + e);\n+        }\n+\n+        robot.mouseMove(x, y);\n+        robot.waitForIdle();\n+        robot.mousePress(MouseEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(MouseEvent.BUTTON1_DOWN_MASK);\n+\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                x = buttonRemove.getLocationOnScreen().x\n+                    + buttonRemove.getSize().width \/ 2;\n+                y = buttonRemove.getLocationOnScreen().y\n+                    + buttonRemove.getSize().height \/ 2;\n+            });\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unexpected Exception encountered: \" + e);\n+        }\n+\n+        robot.mouseMove(x, y);\n+        robot.waitForIdle();\n+        robot.mousePress(MouseEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(MouseEvent.BUTTON1_DOWN_MASK);\n+\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                x = buttonAdd.getLocationOnScreen().x\n+                    + buttonAdd.getSize().width \/ 2;\n+                y = buttonAdd.getLocationOnScreen().y\n+                    + buttonAdd.getSize().height \/ 2;\n+            });\n+\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unexpected Exception encountered: \" + e);\n+        }\n+        robot.mouseMove(x, y);\n+        robot.waitForIdle();\n+        robot.mousePress(MouseEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(MouseEvent.BUTTON1_DOWN_MASK);\n+\n+        if (awtPainted.get() == 0) {\n+            throw new RuntimeException(\"AWT button is not painted\");\n+        }\n+        if (swingPainted.get() == 0) {\n+            throw new RuntimeException(\"Swing button is not painted\");\n+        }\n+    }\n+\n+    private static void dispose() {\n+        if (frame != null) {\n+            frame.dispose();\n+            frame = null;\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/awt\/Component\/ComponentRedrawnTest.java","additions":198,"deletions":0,"binary":false,"changes":198,"status":"added"},{"patch":"@@ -214,1 +214,1 @@\n-        if (windows != 0) {\n+        if (windows != 0 || frames != 1 || dialogs != 0 || modalDialogs != 0) {\n","filename":"test\/jdk\/java\/awt\/Dialog\/ModalDialogTest\/ModalDialogTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -135,0 +136,16 @@\n+    @Test(expectedExceptions = IllegalArgumentException.class,\n+            expectedExceptionsMessageRegExp = \".*Heap segment not allowed.*\")\n+    public void badHeapSegmentSet() {\n+        MemorySegment targetSegment = MemorySegment.allocateNative(ValueLayout.ADDRESS.byteSize(), SegmentScope.auto());\n+        MemorySegment segment = MemorySegment.ofArray(new byte[]{ 0, 1, 2 });\n+        targetSegment.set(ValueLayout.ADDRESS, 0, segment); \/\/ should throw\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class,\n+            expectedExceptionsMessageRegExp = \".*Heap segment not allowed.*\")\n+    public void badHeapSegmentSetAtIndex() {\n+        MemorySegment targetSegment = MemorySegment.allocateNative(ValueLayout.ADDRESS.byteSize(), SegmentScope.auto());\n+        MemorySegment segment = MemorySegment.ofArray(new byte[]{ 0, 1, 2 });\n+        targetSegment.setAtIndex(ValueLayout.ADDRESS, 0, segment); \/\/ should throw\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessInstance.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8295803\n+ * @bug 8295803 8299689\n@@ -30,1 +30,1 @@\n- * @run main\/othervm ModuleSelectionTest jdk.internal.le\n+ * @run main\/othervm ModuleSelectionTest java.base\n","filename":"test\/jdk\/java\/io\/Console\/ModuleSelectionTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @bug 8295803\n+ * @bug 8295803 8299689\n@@ -34,0 +34,2 @@\n+ * @run main RedirectTest\n+ * @run main\/othervm -Djdk.console=jdk.internal.le RedirectTest\n@@ -36,0 +38,2 @@\n+    private static final String SYSPROP = \"jdk.console\";\n+\n@@ -39,1 +43,3 @@\n-            var pb = ProcessTools.createTestJvm(\"RedirectTest\", \"dummy\");\n+            var pb = ProcessTools.createTestJvm(\n+                    \"-D\" + SYSPROP + \"=\" + System.getProperty(SYSPROP, \"\"),\n+                    \"RedirectTest\", \"dummy\");\n@@ -43,4 +49,7 @@\n-            var output = oa.asLines();\n-            var expected = Files.readAllLines(input.toPath());\n-            if (!output.equals(expected)) {\n-                throw new RuntimeException(\"\"\"\n+            if (oa.getExitValue() == 1) {\n+                System.out.println(\"System.console() returns null. Ignoring the test.\");\n+            } else {\n+                var output = oa.asLines();\n+                var expected = Files.readAllLines(input.toPath());\n+                if (!output.equals(expected)) {\n+                    throw new RuntimeException(\"\"\"\n@@ -51,0 +60,4 @@\n+                } else {\n+                    oa.shouldHaveExitValue(0);\n+                    System.out.println(\"Redirect succeeded.\");\n+                }\n@@ -52,1 +65,0 @@\n-            oa.shouldHaveExitValue(0);\n@@ -55,3 +67,8 @@\n-            String line;\n-            while ((line = con.readLine()) != null) {\n-                System.out.println(line);\n+            if (con != null) {\n+                String line;\n+                while ((line = con.readLine()) != null) {\n+                    System.out.println(line);\n+                }\n+            } else {\n+                \/\/ Exit with 1\n+                System.exit(1);\n","filename":"test\/jdk\/java\/io\/Console\/RedirectTest.java","additions":28,"deletions":11,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-            \".*\\\\Qexpected (Widget,\" + fieldType.getSimpleName() + \")void \\\\E.*\");\n+            \".*\\\\Qhandle's method type (Widget,\" + fieldType.getSimpleName() + \")void \\\\E.*\");\n@@ -118,1 +118,1 @@\n-            \".*\\\\Qexpected (Widget)\" + fieldType.getSimpleName() + \" \\\\E.*\");\n+            \".*\\\\Qhandle's method type (Widget)\" + fieldType.getSimpleName() + \" \\\\E.*\");\n@@ -132,1 +132,1 @@\n-            \".*\\\\Qexpected (\" + fieldType.getSimpleName() + \")void \\\\E.*\");\n+            \".*\\\\Qhandle's method type (\" + fieldType.getSimpleName() + \")void \\\\E.*\");\n@@ -145,1 +145,1 @@\n-            \".*\\\\Qexpected ()\" + fieldType.getSimpleName() + \" \\\\E.*\");\n+            \".*\\\\Qhandle's method type ()\" + fieldType.getSimpleName() + \" \\\\E.*\");\n@@ -156,1 +156,1 @@\n-            \".*\\\\Qexpected (\" + arrayClass.getSimpleName() + \",int,\" + arrayClass.componentType().getSimpleName() + \")void \\\\E.*\");\n+            \".*\\\\Qhandle's method type (\" + arrayClass.getSimpleName() + \",int,\" + arrayClass.componentType().getSimpleName() + \")void \\\\E.*\");\n@@ -167,1 +167,1 @@\n-            \".*\\\\Qexpected (ByteBuffer,int,\" + arrayClass.componentType().getSimpleName() + \")void \\\\E.*\");\n+            \".*\\\\Qhandle's method type (ByteBuffer,int,\" + arrayClass.componentType().getSimpleName() + \")void \\\\E.*\");\n@@ -178,1 +178,1 @@\n-                \".*\\\\Qexpected (MemorySegment,long,\" + carrier.getSimpleName() + \")void \\\\E.*\");\n+                \".*\\\\Qhandle's method type (MemorySegment,long,\" + carrier.getSimpleName() + \")void \\\\E.*\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestExact.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test 8299183\n+ * @run testng WrongMethodTypeTest\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.VarHandle;\n+import java.lang.invoke.WrongMethodTypeException;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+\n+import static org.testng.AssertJUnit.*;\n+\n+import org.testng.annotations.*;\n+\n+public class WrongMethodTypeTest {\n+    static final Lookup LOOKUP = MethodHandles.lookup();\n+\n+    @Test\n+    public void checkExactType() throws Throwable {\n+        String expectedMessage = \"handle's method type (int)int but found ()boolean\";\n+        try {\n+            MethodHandle mh = LOOKUP.findStatic(WrongMethodTypeTest.class, \"m\", methodType(int.class, int.class));\n+            boolean b = (boolean)mh.invokeExact();\n+            fail(\"Expected WrongMethodTypeException\");\n+        } catch (WrongMethodTypeException ex) {\n+            assertEquals(expectedMessage, ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void checkAccessModeInvokeExact() throws Throwable {\n+        String expectedMessage = \"handle's method type ()int but found ()Void\";\n+        VarHandle vh = LOOKUP.findStaticVarHandle(WrongMethodTypeTest.class, \"x\", int.class)\n+                             .withInvokeExactBehavior();\n+        try {\n+            Void o = (Void) vh.get();\n+        } catch (WrongMethodTypeException ex) {\n+            assertEquals(expectedMessage, ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void checkVarHandleInvokeExact() throws Throwable {\n+        String expectedMessage = \"handle's method type (WrongMethodTypeTest)boolean but found (WrongMethodTypeTest)int\";\n+        VarHandle vh = LOOKUP.findVarHandle(WrongMethodTypeTest.class, \"y\", boolean.class)\n+                             .withInvokeExactBehavior();\n+        try {\n+            int o = (int) vh.get(new WrongMethodTypeTest());\n+        } catch (WrongMethodTypeException ex) {\n+            assertEquals(expectedMessage, ex.getMessage());\n+        }\n+    }\n+\n+    static int m(int x) {\n+        return x;\n+    }\n+\n+    static int x = 200;\n+    boolean y = false;\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/WrongMethodTypeTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,293 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8278326\n+ * @modules java.base\/java.net:+open\n+ * @run junit ImplAccept\n+ * @summary Test ServerSocket.implAccept with a Socket in different states.\n+ *\/\n+\n+import java.io.FileDescriptor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketImpl;\n+import java.net.SocketOption;\n+import java.net.StandardSocketOptions;\n+import java.io.IOException;\n+\n+import org.junit.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class ImplAccept {\n+\n+    \/**\n+     * Test ServerSocket.implAccept with an unbound Socket.\n+     *\/\n+    @Test\n+    public void testUnbound() throws Exception {\n+        try (Socket socket = new Socket()) {\n+\n+            \/\/ Socket.impl -> DelegatingSocketImpl\n+            SocketImpl si = getSocketImpl(socket);\n+            assertTrue(isDelegatingSocketImpl(si));\n+\n+            try (ServerSocket ss = serverSocketToAccept(socket);\n+                 Socket peer = new Socket(ss.getInetAddress(), ss.getLocalPort())) {\n+\n+                Socket s = ss.accept();\n+                assertTrue(s == socket);\n+\n+                \/\/ Socket.impl should be replaced with a new PlatformSocketImpl\n+                SocketImpl psi = getSocketImpl(socket);\n+                assertTrue(isPlatformSocketImpl(psi));\n+\n+                \/\/ socket and peer should be connected to each other\n+                pingPong(socket, peer);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test ServerSocket.implAccept with a bound Socket. The usage is nonsensical\n+     * but we can test that the accepted Socket is connected and the underlying\n+     * socket from the original SocketImpl is closed.\n+     *\/\n+    @Test\n+    public void testBound() throws Exception {\n+        try (Socket socket = new Socket()) {\n+\n+            \/\/ Socket.impl -> DelegatingSocketImpl -> PlatformSocketImpl\n+            SocketImpl si = getSocketImpl(socket);\n+            SocketImpl psi1 = getDelegate(si);\n+            assertTrue(isPlatformSocketImpl(psi1));\n+\n+            \/\/ bind to local address\n+            socket.bind(loopbackSocketAddress());\n+            assertTrue(isSocketOpen(psi1));\n+\n+            try (ServerSocket ss = serverSocketToAccept(socket);\n+                 Socket peer = new Socket(ss.getInetAddress(), ss.getLocalPort())) {\n+\n+                Socket s = ss.accept();\n+                assertTrue(s == socket);\n+\n+                \/\/ Socket.impl should be replaced with a new PlatformSocketImpl\n+                SocketImpl psi2 = getSocketImpl(socket);\n+                assertTrue(isPlatformSocketImpl(psi2));\n+\n+                \/\/ psi1 should be closed\n+                assertFalse(isSocketOpen(psi1));\n+\n+                \/\/ socket and peer should be connected to each other\n+                pingPong(socket, peer);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test ServerSocket.implAccept with a connected Socket. The usage is nonsensical\n+     * but we can test that the accepted Socket is connected and the underlying\n+     * socket from the original SocketImpl is closed.\n+     *\/\n+    @Test\n+    public void testConnected() throws Exception {\n+        Socket socket;\n+        Socket peer1;\n+        try (ServerSocket ss = new ServerSocket()) {\n+            ss.bind(loopbackSocketAddress());\n+            socket = new Socket(ss.getInetAddress(), ss.getLocalPort());\n+            peer1 = ss.accept();\n+        }\n+\n+        try {\n+            \/\/ Socket.impl -> DelegatingSocketImpl -> PlatformSocketImpl\n+            SocketImpl si = getSocketImpl(socket);\n+            SocketImpl psi1 = getDelegate(si);\n+            assertTrue(isPlatformSocketImpl(psi1));\n+\n+            try (ServerSocket ss = serverSocketToAccept(socket);\n+                 Socket peer2 = new Socket(ss.getInetAddress(), ss.getLocalPort())) {\n+\n+                Socket s = ss.accept();\n+                assertTrue(s == socket);\n+\n+                \/\/ Socket.impl should be replaced with a new PlatformSocketImpl\n+                SocketImpl psi2 = getSocketImpl(socket);\n+                assertTrue(isPlatformSocketImpl(psi2));\n+\n+                \/\/ psi1 should be closed and peer1 should read EOF\n+                assertFalse(isSocketOpen(psi1));\n+                assertTrue(peer1.getInputStream().read() == -1);\n+\n+                \/\/ socket and peer2 should be connected to each other\n+                pingPong(socket, peer2);\n+            }\n+        } finally {\n+            socket.close();\n+            peer1.close();\n+        }\n+    }\n+\n+    \/**\n+     * Test ServerSocket.implAccept with a closed Socket. The usage is nonsensical\n+     * but we can test ServerSocket.accept throws and that it closes the connection\n+     * to the peer.\n+     *\/\n+    @Test\n+    public void testClosed() throws Exception {\n+        Socket socket = new Socket();\n+        socket.close();\n+\n+        try (ServerSocket ss = serverSocketToAccept(socket);\n+             Socket peer = new Socket(ss.getInetAddress(), ss.getLocalPort())) {\n+\n+            SocketImpl si = getSocketImpl(socket);\n+\n+            \/\/ accept should throw and peer should read EOF\n+            assertThrows(IOException.class, ss::accept);\n+            assertTrue(peer.getInputStream().read() == -1);\n+\n+            \/\/ the SocketImpl should have not changed\n+            assertTrue(getSocketImpl(socket) == si);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the socket's SocketImpl.\n+     *\/\n+    private static SocketImpl getSocketImpl(Socket s) {\n+        try {\n+            Field f = Socket.class.getDeclaredField(\"impl\");\n+            f.setAccessible(true);\n+            return (SocketImpl) f.get(s);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the SocketImpl that the given SocketImpl delegates to.\n+     *\/\n+    private static SocketImpl getDelegate(SocketImpl si) {\n+        try {\n+            Class<?> clazz = Class.forName(\"java.net.DelegatingSocketImpl\");\n+            Field f = clazz.getDeclaredField(\"delegate\");\n+            f.setAccessible(true);\n+            return (SocketImpl) f.get(si);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns true if the SocketImpl is a DelegatingSocketImpl.\n+     *\/\n+    private static boolean isDelegatingSocketImpl(SocketImpl si) {\n+        try {\n+            Class<?> clazz = Class.forName(\"java.net.DelegatingSocketImpl\");\n+            return clazz.isInstance(si);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns true if the SocketImpl is a PlatformSocketImpl.\n+     *\/\n+    private static boolean isPlatformSocketImpl(SocketImpl si) {\n+        try {\n+            Class<?> clazz = Class.forName(\"sun.net.PlatformSocketImpl\");\n+            return clazz.isInstance(si);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns true if the SocketImpl has an open socket.\n+     *\/\n+    private static boolean isSocketOpen(SocketImpl si) throws Exception {\n+        assertTrue(isPlatformSocketImpl(si));\n+\n+        \/\/ check if SocketImpl.fd is set\n+        Field f = SocketImpl.class.getDeclaredField(\"fd\");\n+        f.setAccessible(true);\n+        FileDescriptor fd = (FileDescriptor) f.get(si);\n+        if (fd == null) {\n+            return false;  \/\/ not created\n+        }\n+\n+        \/\/ call getOption to get the value of the SO_REUSEADDR socket option\n+        Method m = SocketImpl.class.getDeclaredMethod(\"getOption\", SocketOption.class);\n+        m.setAccessible(true);\n+        try {\n+            m.invoke(si, StandardSocketOptions.SO_REUSEADDR);\n+            return true; \/\/ socket is open\n+        } catch (InvocationTargetException e) {\n+            if (e.getCause() instanceof IOException) {\n+                return false; \/\/ assume socket is closed\n+            }\n+            throw e;\n+        }\n+    }\n+\n+    \/**\n+     * Test that two sockets are connected to each other.\n+     *\/\n+    private static void pingPong(Socket s1, Socket s2) throws Exception {\n+        s1.getOutputStream().write(11);\n+        s2.getOutputStream().write(22);\n+        assertTrue(s1.getInputStream().read() == 22);\n+        assertTrue(s2.getInputStream().read() == 11);\n+    }\n+\n+    \/**\n+     * Creates a ServerSocket that returns the given Socket from accept.\n+     *\/\n+    private static ServerSocket serverSocketToAccept(Socket s) throws IOException {\n+        ServerSocket ss = new ServerSocket() {\n+            @Override\n+            public Socket accept() throws IOException {\n+                implAccept(s);\n+                return s;\n+            }\n+        };\n+        ss.bind(loopbackSocketAddress());\n+        return ss;\n+    }\n+\n+    \/**\n+     * Returns a new InetSocketAddress with the loopback interface and port 0.\n+     *\/\n+    private static InetSocketAddress loopbackSocketAddress() {\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        return new InetSocketAddress(loopback, 0);\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/ServerSocket\/ImplAccept.java","additions":293,"deletions":0,"binary":false,"changes":293,"status":"added"},{"patch":"@@ -0,0 +1,244 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8278326\n+ * @modules java.base\/java.net:+open\n+ * @run junit Leaky\n+ * @summary Test async close when binding, connecting, or reading a socket option\n+ *\/\n+\n+import java.io.FileDescriptor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketImpl;\n+import java.net.SocketOption;\n+import java.net.StandardSocketOptions;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.*;\n+import org.junit.jupiter.api.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class Leaky {\n+    private static ScheduledExecutorService executor;\n+    private static ServerSocket listener;\n+\n+    @BeforeAll\n+    public static void setup() throws Exception {\n+        listener = new ServerSocket();\n+        listener.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+        executor = Executors.newScheduledThreadPool(2);\n+    }\n+\n+    @AfterAll\n+    public static void finish() throws Exception {\n+        executor.close();\n+        listener.close();\n+    }\n+\n+    \/**\n+     * Race Socket bind and close.\n+     *\/\n+    @RepeatedTest(100)\n+    public void raceBindAndClose() throws Exception {\n+        Socket socket = new Socket();\n+\n+        race(socket::close, () -> {\n+            try {\n+                socket.bind(new InetSocketAddress(0));\n+            } catch (IOException ioe) {\n+                if (!socket.isClosed()) {\n+                    throw ioe;\n+                }\n+            }\n+        });\n+\n+        \/\/ check that there isn't an open socket\n+        SocketImpl psi = getPlatformSocketImpl(socket);\n+        assertFalse(isSocketOpen(psi));\n+    }\n+\n+    \/**\n+     * Race Socket connect and close.\n+     *\/\n+    @RepeatedTest(100)\n+    public void raceConnectAndClose() throws Exception {\n+        Socket socket = new Socket();\n+\n+        race(socket::close, () -> {\n+            try {\n+                socket.connect(listener.getLocalSocketAddress());\n+                \/\/ if connected, need to close other end\n+                listener.accept().close();\n+            } catch (IOException ioe) {\n+                if (!socket.isClosed()) {\n+                    throw ioe;\n+                }\n+            }\n+        });\n+\n+        \/\/ check that there isn't an open socket\n+        SocketImpl psi = getPlatformSocketImpl(socket);\n+        assertFalse(isSocketOpen(psi));\n+    }\n+\n+    \/**\n+     * Race Socket getOption and close.\n+     *\/\n+    @RepeatedTest(100)\n+    public void raceGetOptionAndClose() throws Exception {\n+        Socket socket = new Socket();\n+\n+        race(socket::close, () -> {\n+            try {\n+                socket.getOption(StandardSocketOptions.SO_REUSEADDR);\n+            } catch (IOException ioe) {\n+                if (!socket.isClosed()) {\n+                    throw ioe;\n+                }\n+            }\n+        });\n+\n+        \/\/ check that there isn't an open socket\n+        SocketImpl psi = getPlatformSocketImpl(socket);\n+        assertFalse(isSocketOpen(psi));\n+    }\n+\n+    \/**\n+     * A task that may throw an exception.\n+     *\/\n+    private interface ThrowingRunnable {\n+        void run() throws Exception;\n+    }\n+\n+    \/**\n+     * Staggers two tasks to execute after random delays.\n+     *\/\n+    private void race(ThrowingRunnable task1, ThrowingRunnable task2) throws Exception {\n+        int delay1 = ThreadLocalRandom.current().nextInt(10);\n+        int delay2 = ThreadLocalRandom.current().nextInt(10);\n+\n+        Future<Void> future1 = executor.schedule(() -> {\n+            task1.run();\n+            return null;\n+        }, delay1, TimeUnit.MILLISECONDS);\n+\n+        Future<Void> future2 = executor.schedule(() -> {\n+            task2.run();\n+            return null;\n+        }, delay2, TimeUnit.MILLISECONDS);\n+\n+        ExecutionException e = null;\n+        try {\n+            future1.get();\n+        } catch (ExecutionException e1) {\n+            e = e1;\n+        }\n+        try {\n+            future2.get();\n+        } catch (ExecutionException e2) {\n+            if (e == null) {\n+                e = e2;\n+            } else {\n+                e.addSuppressed(e2);\n+            }\n+        }\n+        if (e != null) {\n+            throw e;\n+        }\n+    }\n+\n+    \/**\n+     * Return the underlying PlatformSocketImpl for the given socket.\n+     *\/\n+    private static SocketImpl getPlatformSocketImpl(Socket s) {\n+        SocketImpl si = getSocketImpl(s);\n+        return getDelegate(si);\n+    }\n+\n+    \/**\n+     * Returns the socket's SocketImpl.\n+     *\/\n+    private static SocketImpl getSocketImpl(Socket s) {\n+        try {\n+            Field f = Socket.class.getDeclaredField(\"impl\");\n+            f.setAccessible(true);\n+            return (SocketImpl) f.get(s);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the SocketImpl that the given SocketImpl delegates to.\n+     *\/\n+    private static SocketImpl getDelegate(SocketImpl si) {\n+        try {\n+            Class<?> clazz = Class.forName(\"java.net.DelegatingSocketImpl\");\n+            Field f = clazz.getDeclaredField(\"delegate\");\n+            f.setAccessible(true);\n+            return (SocketImpl) f.get(si);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns true if the SocketImpl has an open socket.\n+     *\/\n+    private static boolean isSocketOpen(SocketImpl si) throws Exception {\n+        \/\/ check if SocketImpl.fd is set\n+        Field f = SocketImpl.class.getDeclaredField(\"fd\");\n+        f.setAccessible(true);\n+        FileDescriptor fd = (FileDescriptor) f.get(si);\n+        if (fd == null) {\n+            return false;  \/\/ not created\n+        }\n+\n+        \/\/ call getOption to get the value of the SO_REUSEADDR socket option\n+        Method m = SocketImpl.class.getDeclaredMethod(\"getOption\", SocketOption.class);\n+        m.setAccessible(true);\n+        try {\n+            m.invoke(si, StandardSocketOptions.SO_REUSEADDR);\n+            return true; \/\/ socket is open\n+        } catch (InvocationTargetException e) {\n+            if (e.getCause() instanceof IOException) {\n+                return false; \/\/ assume socket is closed\n+            }\n+            throw e;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/asyncClose\/Leaky.java","additions":244,"deletions":0,"binary":false,"changes":244,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channel;\n+import java.nio.channels.SocketChannel;\n+\n+public class CheckIPv6Service {\n+\n+    static boolean isIPv6Available() {\n+        try {\n+            new ServerSocket(0,0, InetAddress.getByAddress(new byte[16])).close();\n+            return true;\n+        } catch (Exception e) {\n+            return false;\n+        }\n+    }\n+\n+    private static void doIt(SocketChannel sc, int closeAfter, int delay) throws IOException {\n+        ByteBuffer bb = ByteBuffer.allocate(1024);\n+        int total = 0;\n+        for (;;) {\n+            bb.clear();\n+            int n = sc.read(bb);\n+            if (n < 0) {\n+                break;\n+            }\n+            total += n;\n+\n+            \/\/ echo\n+            bb.flip();\n+            sc.write(bb);\n+\n+            \/\/ close after X bytes?\n+            if (closeAfter > 0 && total >= closeAfter) {\n+                break;\n+            }\n+        }\n+\n+        sc.close();\n+        if (delay > 0) {\n+            try {\n+                Thread.currentThread().sleep(delay);\n+            } catch (InterruptedException x) { }\n+        }\n+    }\n+\n+    public static void main(String args[]) throws IOException {\n+        \/\/ check if IPv6 is available; if it is, behave like EchoService.\n+        if (!isIPv6Available()) {\n+            return;\n+        }\n+\n+        Channel c = System.inheritedChannel();\n+        if (c == null) {\n+            return;\n+        }\n+\n+        if (c instanceof SocketChannel) {\n+            int closeAfter = 0;\n+            int delay = 0;\n+            if (args.length > 0) {\n+                closeAfter = Integer.parseInt(args[0]);\n+            }\n+            if (args.length > 1) {\n+                delay = Integer.parseInt(args[1]);\n+            }\n+            doIt((SocketChannel)c, closeAfter, delay);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/CheckIPv6Service.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+\n+\/**\n+ * This test verifies that a service launched with IPv4 inherited channel\n+ * can use IPv6 networking; this used to be impossible, see JDK-6914801\n+ *\/\n+public class CheckIPv6Test {\n+\n+    private static int failures = 0;\n+\n+    private static final String SERVICE = \"CheckIPv6Service\";\n+\n+    public static void main(String args[]) throws IOException {\n+\n+        if (!CheckIPv6Service.isIPv6Available()) {\n+            System.out.println(\"IPv6 not available. Test skipped.\");\n+            return;\n+        }\n+\n+        try {\n+            EchoTest.TCPEchoTest(SERVICE);\n+            System.out.println(\"IPv6 test passed.\");\n+        } catch (Exception x) {\n+            System.err.println(x);\n+            failures++;\n+        }\n+\n+        if (failures > 0) {\n+            throw new RuntimeException(\"Test failed - see log for details\");\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/CheckIPv6Test.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,2 +60,2 @@\n-    private static void TCPEchoTest() throws IOException {\n-        SocketChannel sc = Launcher.launchWithInetSocketChannel(ECHO_SERVICE, null);\n+    static void TCPEchoTest(String echoService) throws IOException {\n+        SocketChannel sc = Launcher.launchWithInetSocketChannel(echoService, null);\n@@ -163,1 +163,1 @@\n-            TCPEchoTest();\n+            TCPEchoTest(ECHO_SERVICE);\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/EchoTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4673940 4930794 8211842\n+ * @bug 4673940 4930794 8211842 6914801\n@@ -38,0 +38,1 @@\n+ *        CheckIPv6Test CheckIPv6Service\n@@ -82,0 +83,1 @@\n+            { \"CheckIPv6Test\",  List.of(CheckIPv6Test.class.getName())  },\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/InheritedChannelTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import static java.net.StandardProtocolFamily.INET;\n@@ -103,5 +104,12 @@\n-        try (ServerSocketChannel ssc = ServerSocketChannel.open()) {\n-            ssc.socket().bind(new InetSocketAddress(InetAddress.getLocalHost(), 0));\n-            InetSocketAddress isa = new InetSocketAddress(InetAddress.getLocalHost(),\n-                                                      ssc.socket().getLocalPort());\n-            SocketChannel sc1 = SocketChannel.open(isa);\n+        ServerSocketChannel ch;\n+        try {\n+            ch = ServerSocketChannel.open(INET);\n+            System.out.println(\"Using INET (IPv4) channel\");\n+        } catch (Exception e) {\n+            ch = ServerSocketChannel.open();\n+            System.out.println(\"Using default channel (probably IPv6)\");\n+        }\n+        try (ServerSocketChannel ssc = ch) {\n+            ssc.socket().bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+            System.out.println(\"Socket bound to \" + ssc.getLocalAddress());\n+            SocketChannel sc1 = SocketChannel.open(ssc.getLocalAddress());\n","filename":"test\/jdk\/java\/nio\/channels\/spi\/SelectorProvider\/inheritedChannel\/Launcher.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,23 @@\n+#\n+# Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/CurrencySymbols.properties","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.java.time.zone;\n+\n+import java.time.ZoneId;\n+import java.time.zone.ZoneRules;\n+import java.time.zone.ZoneRulesException;\n+import java.time.zone.ZoneRulesProvider;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.NavigableMap;\n+import java.util.Set;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+\/**\n+ * @summary Tests for ZoneRulesProvider class.\n+ * @bug 8299571\n+ *\/\n+@Test\n+public class TestZoneRulesProvider {\n+    private static final Set<String> MY_ZONE_IDS =\n+        new LinkedHashSet(Arrays.asList(new String[] {\"MyID_1\", \"MyID_2\", \"CET\", \"MyID_3\"}));\n+\n+    \/**\n+     * Tests whether partially registered zones are cleaned on a provider registration\n+     * failure, in case a duplicated zone is detected.\n+     *\/\n+    @Test\n+    public void test_registerDuplicatedZone() {\n+        try {\n+            ZoneRulesProvider.registerProvider(new ZoneRulesProvider() {\n+                @Override\n+                protected Set<String> provideZoneIds() {\n+                    return MY_ZONE_IDS;\n+                }\n+\n+                @Override\n+                protected ZoneRules provideRules(String zoneId, boolean forCaching) {\n+                    return null;\n+                }\n+\n+                @Override\n+                protected NavigableMap<String, ZoneRules> provideVersions(String zoneId) {\n+                    return null;\n+                }\n+            });\n+            throw new RuntimeException(\"Registering a provider that duplicates a zone should throw an exception\");\n+        } catch (ZoneRulesException e) {\n+            \/\/ Ignore. Failure on registration is expected.\n+        }\n+\n+        MY_ZONE_IDS.stream().forEach(id -> {\n+            var isCET = id.equals(\"CET\");\n+\n+            \/\/ availability check\n+            var available = ZoneId.getAvailableZoneIds().contains(id);\n+            if (available ^ isCET) {\n+                throw new RuntimeException(\"Unexpected availability for \" + id + \", availability: \" + available);\n+            }\n+\n+            \/\/ instantiation check\n+            try {\n+                ZoneId.of(id);\n+                assertTrue(isCET, \"ZoneId.of() for the custom id %s should throw ZoneRulesException.\".formatted(id));\n+            } catch (ZoneRulesException e) {\n+                assertFalse(isCET, \"Not possible to obtain a ZoneId for \\\"CET\\\".\");\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/time\/test\/java\/time\/zone\/TestZoneRulesProvider.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import static java.util.Calendar.*;\n","filename":"test\/jdk\/java\/util\/Calendar\/CalendarTestScripts\/Symbol.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,313 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4906370\n+ * @summary Tests to excercise padding on int and double values,\n+ *      with various flag combinations.\n+ * @run junit Padding\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+public class Padding {\n+\n+    static Arguments[] padding() {\n+        return new Arguments[] {\n+                \/* blank padding, right adjusted, optional plus sign *\/\n+                arguments(\"12\", \"%1d\", 12),\n+                arguments(\"12\", \"%2d\", 12),\n+                arguments(\" 12\", \"%3d\", 12),\n+                arguments(\"  12\", \"%4d\", 12),\n+                arguments(\"   12\", \"%5d\", 12),\n+                arguments(\"        12\", \"%10d\", 12),\n+\n+                arguments(\"-12\", \"%1d\", -12),\n+                arguments(\"-12\", \"%2d\", -12),\n+                arguments(\"-12\", \"%3d\", -12),\n+                arguments(\" -12\", \"%4d\", -12),\n+                arguments(\"  -12\", \"%5d\", -12),\n+                arguments(\"       -12\", \"%10d\", -12),\n+\n+                arguments(\"1.2\", \"%1.1f\", 1.2),\n+                arguments(\"1.2\", \"%2.1f\", 1.2),\n+                arguments(\"1.2\", \"%3.1f\", 1.2),\n+                arguments(\" 1.2\", \"%4.1f\", 1.2),\n+                arguments(\"  1.2\", \"%5.1f\", 1.2),\n+                arguments(\"       1.2\", \"%10.1f\", 1.2),\n+\n+                arguments(\"-1.2\", \"%1.1f\", -1.2),\n+                arguments(\"-1.2\", \"%2.1f\", -1.2),\n+                arguments(\"-1.2\", \"%3.1f\", -1.2),\n+                arguments(\"-1.2\", \"%4.1f\", -1.2),\n+                arguments(\" -1.2\", \"%5.1f\", -1.2),\n+                arguments(\"      -1.2\", \"%10.1f\", -1.2),\n+\n+                \/* blank padding, right adjusted, mandatory plus sign *\/\n+                arguments(\"+12\", \"%+1d\", 12),\n+                arguments(\"+12\", \"%+2d\", 12),\n+                arguments(\"+12\", \"%+3d\", 12),\n+                arguments(\" +12\", \"%+4d\", 12),\n+                arguments(\"  +12\", \"%+5d\", 12),\n+                arguments(\"       +12\", \"%+10d\", 12),\n+\n+                arguments(\"-12\", \"%+1d\", -12),\n+                arguments(\"-12\", \"%+2d\", -12),\n+                arguments(\"-12\", \"%+3d\", -12),\n+                arguments(\" -12\", \"%+4d\", -12),\n+                arguments(\"  -12\", \"%+5d\", -12),\n+                arguments(\"       -12\", \"%+10d\", -12),\n+\n+                arguments(\"+1.2\", \"%+1.1f\", 1.2),\n+                arguments(\"+1.2\", \"%+2.1f\", 1.2),\n+                arguments(\"+1.2\", \"%+3.1f\", 1.2),\n+                arguments(\"+1.2\", \"%+4.1f\", 1.2),\n+                arguments(\" +1.2\", \"%+5.1f\", 1.2),\n+                arguments(\"      +1.2\", \"%+10.1f\", 1.2),\n+\n+                arguments(\"-1.2\", \"%+1.1f\", -1.2),\n+                arguments(\"-1.2\", \"%+2.1f\", -1.2),\n+                arguments(\"-1.2\", \"%+3.1f\", -1.2),\n+                arguments(\"-1.2\", \"%+4.1f\", -1.2),\n+                arguments(\" -1.2\", \"%+5.1f\", -1.2),\n+                arguments(\"      -1.2\", \"%+10.1f\", -1.2),\n+\n+                \/* blank padding, right adjusted, mandatory blank sign *\/\n+                arguments(\" 12\", \"% 1d\", 12),\n+                arguments(\" 12\", \"% 2d\", 12),\n+                arguments(\" 12\", \"% 3d\", 12),\n+                arguments(\"  12\", \"% 4d\", 12),\n+                arguments(\"   12\", \"% 5d\", 12),\n+                arguments(\"        12\", \"% 10d\", 12),\n+\n+                arguments(\"-12\", \"% 1d\", -12),\n+                arguments(\"-12\", \"% 2d\", -12),\n+                arguments(\"-12\", \"% 3d\", -12),\n+                arguments(\" -12\", \"% 4d\", -12),\n+                arguments(\"  -12\", \"% 5d\", -12),\n+                arguments(\"       -12\", \"% 10d\", -12),\n+\n+                arguments(\" 1.2\", \"% 1.1f\", 1.2),\n+                arguments(\" 1.2\", \"% 2.1f\", 1.2),\n+                arguments(\" 1.2\", \"% 3.1f\", 1.2),\n+                arguments(\" 1.2\", \"% 4.1f\", 1.2),\n+                arguments(\"  1.2\", \"% 5.1f\", 1.2),\n+                arguments(\"       1.2\", \"% 10.1f\", 1.2),\n+\n+                arguments(\"-1.2\", \"% 1.1f\", -1.2),\n+                arguments(\"-1.2\", \"% 2.1f\", -1.2),\n+                arguments(\"-1.2\", \"% 3.1f\", -1.2),\n+                arguments(\"-1.2\", \"% 4.1f\", -1.2),\n+                arguments(\" -1.2\", \"% 5.1f\", -1.2),\n+                arguments(\"      -1.2\", \"% 10.1f\", -1.2),\n+\n+                \/* blank padding, left adjusted, optional sign *\/\n+                arguments(\"12\", \"%-1d\", 12),\n+                arguments(\"12\", \"%-2d\", 12),\n+                arguments(\"12 \", \"%-3d\", 12),\n+                arguments(\"12  \", \"%-4d\", 12),\n+                arguments(\"12   \", \"%-5d\", 12),\n+                arguments(\"12        \", \"%-10d\", 12),\n+\n+                arguments(\"-12\", \"%-1d\", -12),\n+                arguments(\"-12\", \"%-2d\", -12),\n+                arguments(\"-12\", \"%-3d\", -12),\n+                arguments(\"-12 \", \"%-4d\", -12),\n+                arguments(\"-12  \", \"%-5d\", -12),\n+                arguments(\"-12       \", \"%-10d\", -12),\n+\n+                arguments(\"1.2\", \"%-1.1f\", 1.2),\n+                arguments(\"1.2\", \"%-2.1f\", 1.2),\n+                arguments(\"1.2\", \"%-3.1f\", 1.2),\n+                arguments(\"1.2 \", \"%-4.1f\", 1.2),\n+                arguments(\"1.2  \", \"%-5.1f\", 1.2),\n+                arguments(\"1.2       \", \"%-10.1f\", 1.2),\n+\n+                arguments(\"-1.2\", \"%-1.1f\", -1.2),\n+                arguments(\"-1.2\", \"%-2.1f\", -1.2),\n+                arguments(\"-1.2\", \"%-3.1f\", -1.2),\n+                arguments(\"-1.2\", \"%-4.1f\", -1.2),\n+                arguments(\"-1.2 \", \"%-5.1f\", -1.2),\n+                arguments(\"-1.2      \", \"%-10.1f\", -1.2),\n+\n+                \/* blank padding, left adjusted, mandatory plus sign *\/\n+                arguments(\"+12\", \"%-+1d\", 12),\n+                arguments(\"+12\", \"%-+2d\", 12),\n+                arguments(\"+12\", \"%-+3d\", 12),\n+                arguments(\"+12 \", \"%-+4d\", 12),\n+                arguments(\"+12  \", \"%-+5d\", 12),\n+                arguments(\"+12       \", \"%-+10d\", 12),\n+\n+                arguments(\"-12\", \"%-+1d\", -12),\n+                arguments(\"-12\", \"%-+2d\", -12),\n+                arguments(\"-12\", \"%-+3d\", -12),\n+                arguments(\"-12 \", \"%-+4d\", -12),\n+                arguments(\"-12  \", \"%-+5d\", -12),\n+                arguments(\"-12       \", \"%-+10d\", -12),\n+\n+                arguments(\"+1.2\", \"%-+1.1f\", 1.2),\n+                arguments(\"+1.2\", \"%-+2.1f\", 1.2),\n+                arguments(\"+1.2\", \"%-+3.1f\", 1.2),\n+                arguments(\"+1.2\", \"%-+4.1f\", 1.2),\n+                arguments(\"+1.2 \", \"%-+5.1f\", 1.2),\n+                arguments(\"+1.2      \", \"%-+10.1f\", 1.2),\n+\n+                arguments(\"-1.2\", \"%-+1.1f\", -1.2),\n+                arguments(\"-1.2\", \"%-+2.1f\", -1.2),\n+                arguments(\"-1.2\", \"%-+3.1f\", -1.2),\n+                arguments(\"-1.2\", \"%-+4.1f\", -1.2),\n+                arguments(\"-1.2 \", \"%-+5.1f\", -1.2),\n+                arguments(\"-1.2      \", \"%-+10.1f\", -1.2),\n+\n+                \/* blank padding, left adjusted, mandatory blank sign *\/\n+                arguments(\" 12\", \"%- 1d\", 12),\n+                arguments(\" 12\", \"%- 2d\", 12),\n+                arguments(\" 12\", \"%- 3d\", 12),\n+                arguments(\" 12 \", \"%- 4d\", 12),\n+                arguments(\" 12  \", \"%- 5d\", 12),\n+                arguments(\" 12       \", \"%- 10d\", 12),\n+\n+                arguments(\"-12\", \"%- 1d\", -12),\n+                arguments(\"-12\", \"%- 2d\", -12),\n+                arguments(\"-12\", \"%- 3d\", -12),\n+                arguments(\"-12 \", \"%- 4d\", -12),\n+                arguments(\"-12  \", \"%- 5d\", -12),\n+                arguments(\"-12       \", \"%- 10d\", -12),\n+\n+                arguments(\" 1.2\", \"%- 1.1f\", 1.2),\n+                arguments(\" 1.2\", \"%- 2.1f\", 1.2),\n+                arguments(\" 1.2\", \"%- 3.1f\", 1.2),\n+                arguments(\" 1.2\", \"%- 4.1f\", 1.2),\n+                arguments(\" 1.2 \", \"%- 5.1f\", 1.2),\n+                arguments(\" 1.2      \", \"%- 10.1f\", 1.2),\n+\n+                arguments(\"-1.2\", \"%- 1.1f\", -1.2),\n+                arguments(\"-1.2\", \"%- 2.1f\", -1.2),\n+                arguments(\"-1.2\", \"%- 3.1f\", -1.2),\n+                arguments(\"-1.2\", \"%- 4.1f\", -1.2),\n+                arguments(\"-1.2 \", \"%- 5.1f\", -1.2),\n+                arguments(\"-1.2      \", \"%- 10.1f\", -1.2),\n+\n+                \/* zero padding, right adjusted, optional sign *\/\n+                arguments(\"12\", \"%01d\", 12),\n+                arguments(\"12\", \"%02d\", 12),\n+                arguments(\"012\", \"%03d\", 12),\n+                arguments(\"0012\", \"%04d\", 12),\n+                arguments(\"00012\", \"%05d\", 12),\n+                arguments(\"0000000012\", \"%010d\", 12),\n+\n+                arguments(\"-12\", \"%01d\", -12),\n+                arguments(\"-12\", \"%02d\", -12),\n+                arguments(\"-12\", \"%03d\", -12),\n+                arguments(\"-012\", \"%04d\", -12),\n+                arguments(\"-0012\", \"%05d\", -12),\n+                arguments(\"-000000012\", \"%010d\", -12),\n+\n+                arguments(\"1.2\", \"%01.1f\", 1.2),\n+                arguments(\"1.2\", \"%02.1f\", 1.2),\n+                arguments(\"1.2\", \"%03.1f\", 1.2),\n+                arguments(\"01.2\", \"%04.1f\", 1.2),\n+                arguments(\"001.2\", \"%05.1f\", 1.2),\n+                arguments(\"00000001.2\", \"%010.1f\", 1.2),\n+\n+                arguments(\"-1.2\", \"%01.1f\", -1.2),\n+                arguments(\"-1.2\", \"%02.1f\", -1.2),\n+                arguments(\"-1.2\", \"%03.1f\", -1.2),\n+                arguments(\"-1.2\", \"%04.1f\", -1.2),\n+                arguments(\"-01.2\", \"%05.1f\", -1.2),\n+                arguments(\"-0000001.2\", \"%010.1f\", -1.2),\n+\n+                \/* zero padding, right adjusted, mandatory plus sign *\/\n+                arguments(\"+12\", \"%+01d\", 12),\n+                arguments(\"+12\", \"%+02d\", 12),\n+                arguments(\"+12\", \"%+03d\", 12),\n+                arguments(\"+012\", \"%+04d\", 12),\n+                arguments(\"+0012\", \"%+05d\", 12),\n+                arguments(\"+000000012\", \"%+010d\", 12),\n+\n+                arguments(\"-12\", \"%+01d\", -12),\n+                arguments(\"-12\", \"%+02d\", -12),\n+                arguments(\"-12\", \"%+03d\", -12),\n+                arguments(\"-012\", \"%+04d\", -12),\n+                arguments(\"-0012\", \"%+05d\", -12),\n+                arguments(\"-000000012\", \"%+010d\", -12),\n+\n+                arguments(\"+1.2\", \"%+01.1f\", 1.2),\n+                arguments(\"+1.2\", \"%+02.1f\", 1.2),\n+                arguments(\"+1.2\", \"%+03.1f\", 1.2),\n+                arguments(\"+1.2\", \"%+04.1f\", 1.2),\n+                arguments(\"+01.2\", \"%+05.1f\", 1.2),\n+                arguments(\"+0000001.2\", \"%+010.1f\", 1.2),\n+\n+                arguments(\"-1.2\", \"%+01.1f\", -1.2),\n+                arguments(\"-1.2\", \"%+02.1f\", -1.2),\n+                arguments(\"-1.2\", \"%+03.1f\", -1.2),\n+                arguments(\"-1.2\", \"%+04.1f\", -1.2),\n+                arguments(\"-01.2\", \"%+05.1f\", -1.2),\n+                arguments(\"-0000001.2\", \"%+010.1f\", -1.2),\n+\n+                \/* zero padding, right adjusted, mandatory blank sign *\/\n+                arguments(\" 12\", \"% 01d\", 12),\n+                arguments(\" 12\", \"% 02d\", 12),\n+                arguments(\" 12\", \"% 03d\", 12),\n+                arguments(\" 012\", \"% 04d\", 12),\n+                arguments(\" 0012\", \"% 05d\", 12),\n+                arguments(\" 000000012\", \"% 010d\", 12),\n+\n+                arguments(\"-12\", \"% 01d\", -12),\n+                arguments(\"-12\", \"% 02d\", -12),\n+                arguments(\"-12\", \"% 03d\", -12),\n+                arguments(\"-012\", \"% 04d\", -12),\n+                arguments(\"-0012\", \"% 05d\", -12),\n+                arguments(\"-000000012\", \"% 010d\", -12),\n+\n+                arguments(\" 1.2\", \"% 01.1f\", 1.2),\n+                arguments(\" 1.2\", \"% 02.1f\", 1.2),\n+                arguments(\" 1.2\", \"% 03.1f\", 1.2),\n+                arguments(\" 1.2\", \"% 04.1f\", 1.2),\n+                arguments(\" 01.2\", \"% 05.1f\", 1.2),\n+                arguments(\" 0000001.2\", \"% 010.1f\", 1.2),\n+\n+                arguments(\"-1.2\", \"% 01.1f\", -1.2),\n+                arguments(\"-1.2\", \"% 02.1f\", -1.2),\n+                arguments(\"-1.2\", \"% 03.1f\", -1.2),\n+                arguments(\"-1.2\", \"% 04.1f\", -1.2),\n+                arguments(\"-01.2\", \"% 05.1f\", -1.2),\n+                arguments(\"-0000001.2\", \"% 010.1f\", -1.2),\n+\n+        };\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void padding(String expected, String format, Object value) {\n+        assertEquals(expected, String.format(format, value));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/Formatter\/Padding.java","additions":313,"deletions":0,"binary":false,"changes":313,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8218474\n+ * @key headful\n+ * @requires (os.family == \"linux\")\n+ * @summary Verifies if combobox components are rendered correctly.\n+ * @run main TestComboBoxComponentRendering\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.image.BufferedImage;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.io.File;\n+import javax.imageio.ImageIO;\n+import javax.swing.JComboBox;\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+import javax.swing.JList;\n+import javax.swing.ListCellRenderer;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+\n+public class TestComboBoxComponentRendering {\n+    private static JFrame frame;\n+    private static JComboBox cb;\n+    private static Robot robot;\n+\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+        robot.setAutoDelay(100);\n+\n+        for (UIManager.LookAndFeelInfo laf :\n+                UIManager.getInstalledLookAndFeels()) {\n+            if (!laf.getClassName().contains(\"MotifLookAndFeel\") &&\n+                !laf.getClassName().contains(\"MetalLookAndFeel\")) {\n+                System.out.println(\"Testing LAF: \" + laf.getClassName());\n+                SwingUtilities.invokeAndWait(() -> setLookAndFeel(laf));\n+                doTesting(laf);\n+            }\n+        }\n+    }\n+\n+    private static void setLookAndFeel(UIManager.LookAndFeelInfo laf) {\n+        try {\n+            UIManager.setLookAndFeel(laf.getClassName());\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Unsupported LAF: \" + laf.getClassName());\n+        } catch (ClassNotFoundException | InstantiationException\n+                 | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static void doTesting(UIManager.LookAndFeelInfo laf)\n+            throws Exception {\n+        try {\n+            SwingUtilities.invokeAndWait(() -> {\n+                createAndShowUI();\n+            });\n+            boolean passed = false;\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            Point pt = cb.getLocationOnScreen();\n+            BufferedImage img = robot.createScreenCapture(\n+                    new Rectangle(pt.x, pt.y, cb.getWidth(), cb.getHeight()));\n+            for (int x = 20; x < img.getWidth()-20; ++x) {\n+                for (int y = 20; y < img.getHeight()-20; ++y) {\n+                    if (img.getRGB(x,y) == Color.RED.getRGB()) {\n+                        passed = true;\n+                        break;\n+                    }\n+                }\n+                if (passed)\n+                    break;\n+            }\n+\n+            if (passed) {\n+                System.out.println(\"Passed\");\n+            } else {\n+                ImageIO.write(img, \"png\",\n+                        new File(\"ComboBox.png\"));\n+                throw new RuntimeException(\"ComboBox components not rendered\" +\n+                        \" correctly for: \" + laf.getClassName());\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void createAndShowUI() {\n+        String[] petStrings = { \"Bird\", \"Cat\", \"Dog\", \"Rabbit\", \"Pig\" };\n+        frame = new JFrame();\n+        cb = new JComboBox(petStrings);\n+        cb.setRenderer(new ComboBoxCustomRenderer());\n+        frame.pack();\n+        frame.add(cb);\n+        frame.setSize(200,250);\n+        frame.setLocationRelativeTo(null);\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setVisible(true);\n+    }\n+}\n+\n+class ComboBoxCustomRenderer extends JLabel\n+        implements ListCellRenderer {\n+\n+    public ComboBoxCustomRenderer() {\n+        setOpaque(true);\n+        setHorizontalAlignment(CENTER);\n+        setVerticalAlignment(CENTER);\n+    }\n+\n+    public Component getListCellRendererComponent(JList list, Object value,\n+                        int index, boolean isSelected, boolean cellHasFocus) {\n+        setText(value.toString());\n+        setForeground(Color.RED);\n+        return this;\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JComboBox\/TestComboBoxComponentRendering.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 4517214\n+ * @bug 4517214 8218474\n","filename":"test\/jdk\/javax\/swing\/JComboBox\/TestComboBoxHeight.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4847375 8171363\n+ * @bug 4847375 8171363 8227257\n@@ -32,0 +32,2 @@\n+ * @run main\/othervm bug4847375\n+ * @run main\/othervm -ea -esa bug4847375\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/4847375\/bug4847375.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+\n+import javax.swing.filechooser.FileSystemView;\n+\n+\/*\n+ * @test\n+ * @bug 8227257\n+ * @requires (os.family == \"windows\")\n+ * @summary existing but inaccessible target for a link should be ignored\n+ * @run main\/othervm InaccessibleLink\n+ * @run main\/othervm -ea -esa InaccessibleLink\n+ *\/\n+public final class InaccessibleLink {\n+\n+    \/**\n+     * The link to the windows-update settings.\n+     *\/\n+    private static final byte[] bytes = {\n+            76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, -64, 0, 0, 0, 0, 0, 0, 70,\n+            -127, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 84, 0, 20, 0, 31, 104, -128, 83,\n+            28, -121, -96, 66, 105, 16, -94, -22, 8, 0, 43, 48, 48, -99, 62, 0,\n+            97, -128, 0, 0, 0, 0, 109, 0, 115, 0, 45, 0, 115, 0, 101, 0, 116, 0,\n+            116, 0, 105, 0, 110, 0, 103, 0, 115, 0, 58, 0, 119, 0, 105, 0, 110,\n+            0, 100, 0, 111, 0, 119, 0, 115, 0, 117, 0, 112, 0, 100, 0, 97, 0,\n+            116, 0, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n+    };\n+\n+    public static void main(String[] args) throws IOException {\n+        File file = new File(\"inaccessible.lnk\");\n+        try {\n+            FileOutputStream fos = new FileOutputStream(file);\n+            fos.write(bytes);\n+            fos.close();\n+\n+            FileSystemView fsv = FileSystemView.getFileSystemView();\n+            if (!fsv.isLink(file)) {\n+                throw new RuntimeException(\"not a link\");\n+            }\n+            File linkLocation = fsv.getLinkLocation(file);\n+            if (linkLocation != null) {\n+                throw new RuntimeException(\n+                        \"location is not null: \" + linkLocation);\n+            }\n+        } finally {\n+            Files.deleteIfExists(file.toPath());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/FileSystemView\/InaccessibleLink.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,2 @@\n+            Events.assertField(e, \"compression\").below(1);\n+            Events.assertField(e, \"overwrite\").equal(false);\n","filename":"test\/jdk\/jdk\/jfr\/event\/diagnostics\/TestHeapDump.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.nio.file.FileStore;\n@@ -48,0 +49,1 @@\n+import java.nio.file.attribute.FileAttributeView;\n@@ -76,1 +78,1 @@\n- *      8131067 8034802 8210899 8273961 8271079\n+ *      8131067 8034802 8210899 8273961 8271079 8299864\n@@ -95,1 +97,2 @@\n-            test2(fs);   \/\/ more tests\n+            test2(fs);\n+            testFileStoreNullArgs(fs); \/\/ more tests\n@@ -103,1 +106,1 @@\n-    private static Random rdm = new Random();\n+    private static final Random RDM = new Random();\n@@ -134,1 +137,1 @@\n-            rdm.nextBytes(bits);\n+            RDM.nextBytes(bits);\n@@ -185,2 +188,2 @@\n-            Path dst2 = getPathWithParents(fs, \"\/xyz\" + rdm.nextInt(100) +\n-                                           \"\/efg\" + rdm.nextInt(100) + \"\/foo.class\");\n+            Path dst2 = getPathWithParents(fs, \"\/xyz\" + RDM.nextInt(100) +\n+                                           \"\/efg\" + RDM.nextInt(100) + \"\/foo.class\");\n@@ -363,1 +366,1 @@\n-                        } catch (FileAlreadyExistsException x){\n+                        } catch (FileAlreadyExistsException x) {\n@@ -422,1 +425,1 @@\n-        Object[][] entries = new Object[10 + rdm.nextInt(20)][3];\n+        Object[][] entries = new Object[10 + RDM.nextInt(20)][3];\n@@ -433,4 +436,4 @@\n-            entries[i][1] = rdm.nextInt(10) % 2 == 0 ?\n-                METHOD_STORED : METHOD_DEFLATED;\n-            entries[i][2] = new byte[rdm.nextInt(8192)];\n-            rdm.nextBytes((byte[])entries[i][2]);\n+            entries[i][1] = RDM.nextInt(10) % 2 == 0 ?\n+                    METHOD_STORED : METHOD_DEFLATED;\n+            entries[i][2] = new byte[RDM.nextInt(8192)];\n+            RDM.nextBytes((byte[]) entries[i][2]);\n@@ -497,2 +500,2 @@\n-                    pos = rdm.nextInt((int) sbc.size());\n-                    len = rdm.nextInt(Math.min(buf.length, expected.length - pos));\n+                    pos = RDM.nextInt((int) sbc.size());\n+                    len = RDM.nextInt(Math.min(buf.length, expected.length - pos));\n@@ -935,2 +938,2 @@\n-                int pos = rdm.nextInt((int)chSrc.size());\n-                int limit = rdm.nextInt(1024);\n+                int pos = RDM.nextInt((int) chSrc.size());\n+                int limit = RDM.nextInt(1024);\n@@ -1082,0 +1085,38 @@\n+\n+    \/**\n+     * Tests if certain methods throw a NullPointerException if invoked with null\n+     * as specified in java.nio.file.package-info.java\n+     * @param fs file system containing at least one ZipFileStore\n+     *\n+     * @see 8299864\n+     *\/\n+    static void testFileStoreNullArgs(FileSystem fs)  {\n+        FileStore store = fs.getFileStores().iterator().next();\n+\n+        \/\/ Make sure we are testing the right thing\n+        if (!\"jdk.nio.zipfs.ZipFileStore\".equals(store.getClass().getName()))\n+            throw new AssertionError(store.getClass().getName());\n+\n+        assertThrowsNPE(() -> store.supportsFileAttributeView((String) null));\n+        assertThrowsNPE(() -> store.supportsFileAttributeView((Class<? extends FileAttributeView>) null));\n+        assertThrowsNPE(() -> store.getAttribute(null));\n+        assertThrowsNPE(() -> store.getFileStoreAttributeView(null));\n+    }\n+\n+    @FunctionalInterface\n+    private interface ThrowingRunnable {\n+        void run() throws Exception;\n+    }\n+\n+    static void assertThrowsNPE(ThrowingRunnable r) {\n+        try {\n+            r.run();\n+            \/\/ Didn't throw an exception\n+            throw new AssertionError();\n+        } catch (NullPointerException expected) {\n+            \/\/ happy path\n+        } catch (Exception e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/ZipFSTester.java","additions":58,"deletions":17,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key headful\n- * @bug 8275715\n- * @summary Tests that paint method is not called twice\n- * @run main\/othervm MultiPaintEventTest\n- *\/\n-\n-import java.awt.*;\n-\n-public class MultiPaintEventTest extends Canvas {\n-\n-    private int count = 0;\n-    private final Object lock = new Object();\n-\n-    public void paint(Graphics g) {\n-        synchronized(lock) {\n-            count++;\n-        }\n-\n-        int w = getWidth();\n-        int h = getHeight();\n-\n-        Graphics2D g2d = (Graphics2D)g;\n-        if (count % 2 == 1) {\n-            g2d.setColor(Color.green);\n-        } else {\n-            g2d.setColor(Color.red);\n-        }\n-        g2d.fillRect(0, 0, w, h);\n-    }\n-\n-    public int getCount() {\n-        synchronized(lock) {\n-            return count;\n-        }\n-    }\n-\n-    public Dimension getPreferredSize() {\n-        return new Dimension(400, 400);\n-    }\n-\n-    public static void main(String[] args) {\n-        MultiPaintEventTest test = new MultiPaintEventTest();\n-        Frame frame = new Frame();\n-        frame.setUndecorated(true);\n-        frame.add(test);\n-        frame.pack();\n-        frame.setLocationRelativeTo(null);\n-        frame.setVisible(true);\n-\n-        try {\n-            Thread.sleep(2000);\n-            if (test.getCount() > 1) {\n-                throw new RuntimeException(\"Processed unnecessary paint().\");\n-            }\n-        } catch (InterruptedException ex) {\n-            throw new RuntimeException(\"Failed: Interrupted\");\n-        } finally {\n-            frame.dispose();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/java2d\/DirectX\/MultiPaintEventTest\/MultiPaintEventTest.java","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8299746\n+ * @summary Accept unknown signatureAlgorithm in PKCS7 SignerInfo\n+ * @modules java.base\/sun.security.pkcs\n+ *          java.base\/sun.security.x509\n+ * @library \/test\/lib\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import sun.security.pkcs.SignerInfo;\n+import sun.security.x509.AlgorithmId;\n+\n+public class NewSigAlg {\n+    public static void main(String[] args) throws Exception {\n+        test(\"SHA-1\", \"RSA\", \"SHA1withRSA\");\n+        test(\"SHA-1\", \"SHA1withRSA\", \"SHA1withRSA\");\n+        test(\"SHA-1\", \"SHA256withRSA\", \"SHA1withRSA\");\n+        \/\/ Sorry I have to use something that has an OID but not known\n+        \/\/ as a signature algorithm.\n+        test(\"SHA-1\", \"PBES2\", \"PBES2\");\n+    }\n+\n+    static void test(String d, String e, String s) throws Exception {\n+        Asserts.assertEQ(s, SignerInfo.makeSigAlg(\n+                AlgorithmId.get(d), AlgorithmId.get(s), false));\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs\/pkcs7\/NewSigAlg.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.function.Supplier;\n@@ -238,0 +239,12 @@\n+    private static class BadResultException extends RuntimeException {\n+        BadResultException(Result v) {\n+            value = v;\n+        }\n+\n+        Result getValue() {\n+            return value;\n+        }\n+\n+        private final Result value;\n+    }\n+\n@@ -243,1 +256,19 @@\n-        Result result;\n+        try {\n+            return tryRunMultipleTimes(() -> {\n+                Result result = executeWithoutExitCodeCheck();\n+                if (result.getExitCode() != expectedCode) {\n+                    throw new BadResultException(result);\n+                }\n+                return result;\n+            }, max, wait).assertExitCodeIs(expectedCode);\n+        } catch (BadResultException ex) {\n+            return ex.getValue().assertExitCodeIs(expectedCode);\n+        }\n+    }\n+\n+    \/*\n+     * Repeates a \"task\" \"max\" times and waits for \"wait\" seconds between each\n+     * execution until the \"task\" returns without throwing an exception.\n+     *\/\n+    public static <T> T tryRunMultipleTimes(Supplier<T> task, int max, int wait) {\n+        RuntimeException lastException = null;\n@@ -247,3 +278,4 @@\n-            result = executeWithoutExitCodeCheck();\n-            if (result.getExitCode() == expectedCode) {\n-                return result;\n+            try {\n+                return task.get();\n+            } catch (RuntimeException ex) {\n+                lastException = ex;\n@@ -261,1 +293,8 @@\n-        return result.assertExitCodeIs(expectedCode);\n+        throw lastException;\n+    }\n+\n+    public static void tryRunMultipleTimes(Runnable task, int max, int wait) {\n+        tryRunMultipleTimes(() -> {\n+            task.run();\n+            return null;\n+        }, max, wait);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Executor.java","additions":44,"deletions":5,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -97,1 +97,3 @@\n-                    setIcon(expectedIcon, iconContainer);\n+                    Executor.tryRunMultipleTimes(() -> {\n+                        setIcon(expectedIcon, iconContainer);\n+                    }, 3, 5);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherIconVerifier.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=540 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinDirChooserTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m  jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=540 -Xmx512m  jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinInstallerIconTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m  jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=720 -Xmx512m  jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinInstallerUiTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=540 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinMenuGroupTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=540 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinMenuTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=540 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinPerUserInstallTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinScriptTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m  jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=720 -Xmx512m  jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinShortcutPromptTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=540 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinShortcutTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m  jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=720 -Xmx512m  jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinUrlTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8284299 8287379\n+ * @bug 8284299 8287379 8298525\n@@ -68,0 +68,3 @@\n+                             *\n+                             * @see A {@inheritDoc}\n+                             * @spec http:\/\/example.com {@inheritDoc}\n@@ -98,0 +101,10 @@\n+                        \"\"\",\n+                \"\"\"\n+                        warning: @inheritDoc cannot be used within this tag\n+                             * @see A {@inheritDoc}\n+                               ^\n+                        \"\"\",\n+                \"\"\"\n+                        warning: @inheritDoc cannot be used within this tag\n+                             * @spec http:\/\/example.com {@inheritDoc}\n+                               ^\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testInheritDocWithinInappropriateTag\/TestInheritDocWithinInappropriateTag.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8131025 8141092 8153761 8145263 8131019 8175886 8176184 8176241 8176110 8177466 8197439 8221759 8234896 8240658 8278039 8286206\n+ * @bug 8131025 8141092 8153761 8145263 8131019 8175886 8176184 8176241 8176110 8177466 8197439 8221759 8234896 8240658 8278039 8286206 8296789\n@@ -794,0 +794,6 @@\n+\n+    \/\/JDK-8296789\n+    public void testParentMembers() {\n+        assertEval(\"var sb=new StringBuilder();\");\n+        assertCompletionIncludesExcludes(\"sb.|\", true, Set.of(\"capacity()\", \"setLength(\"), Set.of(\"maybeLatin1\"));\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/CompletionSuggestionTest.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8148316 8148317 8151755 8152246 8153551 8154812 8157261 8163840 8166637 8161969 8173007\n+ * @bug 8148316 8148317 8151755 8152246 8153551 8154812 8157261 8163840 8166637 8161969 8173007 8299829\n@@ -303,1 +303,2 @@\n-                    (a) -> assertCommand(a, \"r=s\", \"String:\\\"AB\")\n+                    (a) -> assertCommand(a, \"r=s\", \"String:\\\"AB\"),\n+                    (a) -> assertCommand(a, \"\\\"0\\\".repeat(49999)+\\\"2\\\"\", \"String:\\\"00000000 ... 00002\\\"\")\n","filename":"test\/langtools\/jdk\/jshell\/ToolFormatTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,10 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @bug     8043251\n+ * @summary Confusing error message with wrong number of type parameters\n+ * @compile\/fail\/ref=T8043251.out -XDrawDiagnostics T8043251.java\n+ *\/\n+import java.util.function.Function;\n+class T8043251 {\n+    Function<String, String> f = Function.<String, String>identity();\n+}\n","filename":"test\/langtools\/tools\/javac\/Diagnostics\/8043251\/T8043251.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+T8043251.java:9:42: compiler.err.cant.apply.symbol.noargs: kindname.method, identity, kindname.interface, java.util.function.Function<T,R>, (compiler.misc.wrong.number.type.args: 1)\n+1 error\n","filename":"test\/langtools\/tools\/javac\/Diagnostics\/8043251\/T8043251.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -24,1 +24,1 @@\n-\/\/ key: compiler.err.cant.apply.symbol\n+\/\/ key: compiler.err.cant.apply.symbol.noargs\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ExplicitParamsDoNotConformToBounds.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-\/\/ key: compiler.err.cant.apply.symbol\n+\/\/ key: compiler.err.cant.apply.symbol.noargs\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/WrongNumberTypeArgsFragment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,14 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Verify for() loop variable not effectively final even if loop never increments\n- * @bug 8294461\n- * @compile\/fail\/ref=EffectivelyFinalLoopIncrement.out -XDrawDiagnostics EffectivelyFinalLoopIncrement.java\n- *\/\n-class EffectivelyFinalLoopIncrement {\n-    EffectivelyFinalLoopIncrement() {\n-        for (int i = 0; i < 10; i++) {\n-            Runnable r = () -> System.out.println(i);   \/\/ variable i is NOT effectively final\n-            break;                                      \/\/ even though \"i++\" is never reached\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/lambda\/8294461\/EffectivelyFinalLoopIncrement.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-EffectivelyFinalLoopIncrement.java:10:51: compiler.err.cant.ref.non.effectively.final.var: i, (compiler.misc.lambda)\n-1 error\n","filename":"test\/langtools\/tools\/javac\/lambda\/8294461\/EffectivelyFinalLoopIncrement.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"}]}