{"files":[{"patch":"@@ -274,0 +274,1 @@\n+  template(linkToNative_name,                         \"linkToNative\")                             \\\n@@ -348,2 +349,5 @@\n-                                                                                                                                      \\\n-  \/* Support for JVMCI *\/                                                                                                             \\\n+  \/* Panama Support *\/                                                                                          \\\n+  template(jdk_internal_invoke_NativeEntryPoint,                 \"jdk\/internal\/invoke\/NativeEntryPoint\")           \\\n+  template(jdk_internal_invoke_NativeEntryPoint_signature,       \"Ljdk\/internal\/invoke\/NativeEntryPoint;\")         \\\n+                                                                                                  \\\n+  \/* Support for JVMCI *\/                                                                         \\\n@@ -521,0 +525,1 @@\n+  template(long_array_signature,                      \"[J\")                                       \\\n@@ -796,0 +801,132 @@\n+<<<<<<< HEAD\n+=======\n+\/\/ VM Intrinsic ID's uniquely identify some very special methods\n+class vmIntrinsics: AllStatic {\n+  friend class vmSymbols;\n+  friend class ciObjectFactory;\n+\n+ public:\n+  \/\/ Accessing\n+  enum ID {\n+    _none = 0,                      \/\/ not an intrinsic (default answer)\n+\n+    #define VM_INTRINSIC_ENUM(id, klass, name, sig, flags)  id,\n+    VM_INTRINSICS_DO(VM_INTRINSIC_ENUM,\n+                     VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE)\n+    #undef VM_INTRINSIC_ENUM\n+\n+    ID_LIMIT,\n+    LAST_COMPILER_INLINE = _getAndSetReference,\n+    FIRST_MH_SIG_POLY    = _invokeGeneric,\n+    FIRST_MH_STATIC      = _linkToVirtual,\n+    LAST_MH_SIG_POLY     = _linkToNative,\n+\n+    FIRST_ID = _none + 1\n+  };\n+\n+  enum Flags {\n+    \/\/ AccessFlags syndromes relevant to intrinsics.\n+    F_none = 0,\n+    F_R,                        \/\/ !static ?native !synchronized (R=\"regular\")\n+    F_S,                        \/\/  static ?native !synchronized\n+    F_Y,                        \/\/ !static ?native  synchronized\n+    F_RN,                       \/\/ !static  native !synchronized\n+    F_SN,                       \/\/  static  native !synchronized\n+    F_RNY,                      \/\/ !static  native  synchronized\n+\n+    FLAG_LIMIT\n+  };\n+  enum {\n+    log2_FLAG_LIMIT = 4         \/\/ checked by an assert at start-up\n+  };\n+\n+public:\n+  static ID ID_from(int raw_id) {\n+    assert(raw_id >= (int)_none && raw_id < (int)ID_LIMIT,\n+           \"must be a valid intrinsic ID\");\n+    return (ID)raw_id;\n+  }\n+\n+  static const char* name_at(ID id);\n+\n+private:\n+  static ID find_id_impl(vmSymbols::SID holder,\n+                         vmSymbols::SID name,\n+                         vmSymbols::SID sig,\n+                         jshort flags);\n+\n+  \/\/ check if the intrinsic is disabled by course-grained flags.\n+  static bool disabled_by_jvm_flags(vmIntrinsics::ID id);\n+public:\n+  static ID find_id(const char* name);\n+  \/\/ Given a method's class, name, signature, and access flags, report its ID.\n+  static ID find_id(vmSymbols::SID holder,\n+                    vmSymbols::SID name,\n+                    vmSymbols::SID sig,\n+                    jshort flags) {\n+    ID id = find_id_impl(holder, name, sig, flags);\n+#ifdef ASSERT\n+    \/\/ ID _none does not hold the following asserts.\n+    if (id == _none)  return id;\n+#endif\n+    assert(    class_for(id) == holder, \"correct id\");\n+    assert(     name_for(id) == name,   \"correct id\");\n+    assert(signature_for(id) == sig,    \"correct id\");\n+    return id;\n+  }\n+\n+  static void verify_method(ID actual_id, Method* m) PRODUCT_RETURN;\n+\n+  \/\/ Find out the symbols behind an intrinsic:\n+  static vmSymbols::SID     class_for(ID id);\n+  static vmSymbols::SID      name_for(ID id);\n+  static vmSymbols::SID signature_for(ID id);\n+  static Flags              flags_for(ID id);\n+\n+  static const char* short_name_as_C_string(ID id, char* buf, int size);\n+\n+  \/\/ Wrapper object methods:\n+  static ID for_boxing(BasicType type);\n+  static ID for_unboxing(BasicType type);\n+\n+  \/\/ Raw conversion:\n+  static ID for_raw_conversion(BasicType src, BasicType dest);\n+\n+  \/\/ The methods below provide information related to compiling intrinsics.\n+\n+  \/\/ (1) Information needed by the C1 compiler.\n+\n+  static bool preserves_state(vmIntrinsics::ID id);\n+  static bool can_trap(vmIntrinsics::ID id);\n+  static bool should_be_pinned(vmIntrinsics::ID id);\n+\n+  \/\/ (2) Information needed by the C2 compiler.\n+\n+  \/\/ Returns true if the intrinsic for method 'method' will perform a virtual dispatch.\n+  static bool does_virtual_dispatch(vmIntrinsics::ID id);\n+  \/\/ A return value larger than 0 indicates that the intrinsic for method\n+  \/\/ 'method' requires predicated logic.\n+  static int predicates_needed(vmIntrinsics::ID id);\n+\n+  \/\/ There are 2 kinds of JVM options to control intrinsics.\n+  \/\/ 1. Disable\/Control Intrinsic accepts a list of intrinsic IDs.\n+  \/\/    ControlIntrinsic is recommended. DisableIntrinic will be deprecated.\n+  \/\/    Currently, the DisableIntrinsic list prevails if an intrinsic appears on\n+  \/\/    both lists.\n+  \/\/\n+  \/\/ 2. Explicit UseXXXIntrinsics options. eg. UseAESIntrinsics, UseCRC32Intrinsics etc.\n+  \/\/    Each option can control a group of intrinsics. The user can specify them but\n+  \/\/    their final values are subject to hardware inspection (VM_Version::initialize).\n+  \/\/    Stub generators are controlled by them.\n+  \/\/\n+  \/\/ An intrinsic is enabled if and only if neither the fine-grained control(1) nor\n+  \/\/ the corresponding coarse-grained control(2) disables it.\n+  static bool is_disabled_by_flags(vmIntrinsics::ID id);\n+\n+  static bool is_disabled_by_flags(const methodHandle& method);\n+  static bool is_intrinsic_available(vmIntrinsics::ID id) {\n+    return !is_disabled_by_flags(id);\n+  }\n+};\n+\n+>>>>>>> 76b9a24ec95863d22ece9f6d9e76633bbfcde341\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":139,"deletions":2,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -390,0 +390,1 @@\n+  GrowableArray<address>*       _native_stubs;\n@@ -950,0 +951,1 @@\n+<<<<<<< HEAD\n@@ -953,0 +955,5 @@\n+=======\n+  void add_native_stub(address stub);\n+\n+  GrowableArray<address>* native_stubs() const { return _native_stubs; }\n+>>>>>>> 76b9a24ec95863d22ece9f6d9e76633bbfcde341\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -429,0 +429,1 @@\n+  case vmIntrinsics::_linkToNative:     return vmSymbols::linkToNative_name();\n@@ -451,0 +452,1 @@\n+  case vmIntrinsics::_linkToNative:     return 0;\n@@ -470,0 +472,1 @@\n+<<<<<<< HEAD\n@@ -474,0 +477,7 @@\n+=======\n+  case vmSymbols::VM_SYMBOL_ENUM_NAME(linkToVirtual_name):    return vmIntrinsics::_linkToVirtual;\n+  case vmSymbols::VM_SYMBOL_ENUM_NAME(linkToStatic_name):     return vmIntrinsics::_linkToStatic;\n+  case vmSymbols::VM_SYMBOL_ENUM_NAME(linkToSpecial_name):    return vmIntrinsics::_linkToSpecial;\n+  case vmSymbols::VM_SYMBOL_ENUM_NAME(linkToInterface_name):  return vmIntrinsics::_linkToInterface;\n+  case vmSymbols::VM_SYMBOL_ENUM_NAME(linkToNative_name):     return vmIntrinsics::_linkToNative;\n+>>>>>>> 76b9a24ec95863d22ece9f6d9e76633bbfcde341\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -619,0 +619,1 @@\n+<<<<<<< HEAD\n@@ -621,0 +622,4 @@\n+=======\n+  \/\/ Walk stack frames of current thread\n+  public native void verifyFrames(boolean log);\n+>>>>>>> 76b9a24ec95863d22ece9f6d9e76633bbfcde341\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}