{"files":[{"patch":"@@ -121,0 +121,2 @@\n+    } else if (is_optimized_entry_frame()) {\n+      return fp_safe;\n@@ -223,0 +225,2 @@\n+    } else if (sender_blob->is_optimized_entry_blob()) {\n+      return false;\n@@ -372,2 +376,4 @@\n-  ShouldNotCallThis();\n-  return nullptr;\n+  assert(frame.is_optimized_entry_frame(), \"wrong frame\");\n+  \/\/ need unextended_sp here, since normal sp is wrong for interpreter callees\n+  return reinterpret_cast<OptimizedEntryBlob::FrameData*>(\n+    reinterpret_cast<char*>(frame.unextended_sp()) + in_bytes(_frame_data_offset));\n@@ -377,2 +383,4 @@\n-  ShouldNotCallThis();\n-  return false;\n+  assert(is_optimized_entry_frame(), \"must be optimzed entry frame\");\n+  OptimizedEntryBlob* blob = _cb->as_optimized_entry_blob();\n+  JavaFrameAnchor* jfa = blob->jfa_for_frame(*this);\n+  return jfa->last_Java_sp() == NULL;\n@@ -382,2 +390,19 @@\n-  ShouldNotCallThis();\n-  return {};\n+  assert(map != NULL, \"map must be set\");\n+  OptimizedEntryBlob* blob = _cb->as_optimized_entry_blob();\n+  \/\/ Java frame called from C; skip all C frames and return top C\n+  \/\/ frame of that chunk as the sender\n+  JavaFrameAnchor* jfa = blob->jfa_for_frame(*this);\n+  assert(!optimized_entry_frame_is_first(), \"must have a frame anchor to go back to\");\n+  assert(jfa->last_Java_sp() > sp(), \"must be above this frame on stack\");\n+  \/\/ Since we are walking the stack now this nested anchor is obviously walkable\n+  \/\/ even if it wasn't when it was stacked.\n+  if (!jfa->walkable()) {\n+    \/\/ Capture _last_Java_pc (if needed) and mark anchor walkable.\n+    jfa->capture_last_Java_pc();\n+  }\n+  map->clear();\n+  assert(map->include_argument_oops(), \"should be set by clear\");\n+  vmassert(jfa->last_Java_pc() != NULL, \"not walkable\");\n+  frame fr(jfa->last_Java_sp(), jfa->last_Java_fp(), jfa->last_Java_pc());\n+\n+  return fr;\n@@ -456,0 +481,1 @@\n+<<<<<<< HEAD\n@@ -457,0 +483,43 @@\n+=======\n+  return frame(l_sender_sp, unextended_sp, *saved_fp_addr, sender_pc);\n+}\n+\n+\/\/------------------------------------------------------------------------------\n+\/\/ frame::sender_raw\n+frame frame::sender_raw(RegisterMap* map) const {\n+  \/\/ Default is we done have to follow them. The sender_for_xxx will\n+  \/\/ update it accordingly\n+   map->set_include_argument_oops(false);\n+\n+  if (is_entry_frame())\n+    return sender_for_entry_frame(map);\n+  if (is_optimized_entry_frame())\n+    return sender_for_optimized_entry_frame(map);\n+  if (is_interpreted_frame())\n+    return sender_for_interpreter_frame(map);\n+  assert(_cb == CodeCache::find_blob(pc()),\"Must be the same\");\n+\n+  \/\/ This test looks odd: why is it not is_compiled_frame() ?  That's\n+  \/\/ because stubs also have OOP maps.\n+  if (_cb != NULL) {\n+    return sender_for_compiled_frame(map);\n+  }\n+\n+  \/\/ Must be native-compiled frame, i.e. the marshaling code for native\n+  \/\/ methods that exists in the core system.\n+\n+  \/\/ Native code may or may not have signed the return address, we have no way to be sure or what\n+  \/\/ signing methods they used. Instead, just ensure the stripped value is used.\n+\n+  return frame(sender_sp(), link(), sender_pc());\n+}\n+\n+frame frame::sender(RegisterMap* map) const {\n+  frame result = sender_raw(map);\n+\n+  if (map->process_frames()) {\n+    StackWatermarkSet::on_iteration(map->thread(), result);\n+  }\n+\n+  return result;\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":75,"deletions":6,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -1054,0 +1054,1 @@\n+<<<<<<< HEAD\n@@ -1058,0 +1059,3 @@\n+=======\n+                            RTMState  rtm_state) {\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -1146,2 +1150,1 @@\n-                               compiler, task()->comp_level(),\n-                               native_invokers);\n+                               compiler, task()->comp_level());\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -395,0 +395,1 @@\n+<<<<<<< HEAD\n@@ -399,0 +400,3 @@\n+=======\n+                       RTMState                  rtm_state = NoRTM);\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3365,0 +3365,1 @@\n+<<<<<<< HEAD\n@@ -3369,0 +3370,3 @@\n+=======\n+                                     C->rtm_state());\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -56,0 +57,1 @@\n+<<<<<<< HEAD\n@@ -67,0 +69,2 @@\n+=======\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -68,2 +72,0 @@\n-  args.push_jobject(rec);\n-  args.push_long((jlong) buff);\n@@ -71,2 +73,1 @@\n-  JavaCalls::call_static(&result, upcall_method.klass, upcall_method.name, upcall_method.sig, &args, CATCH);\n-}\n+APPROVED_CPP_THREAD_LOCAL UpcallContext threadContext;\n@@ -119,2 +120,0 @@\n-  MACOS_AARCH64_ONLY(thread->enable_wx(WXExec));\n-\n@@ -129,2 +128,0 @@\n-  MACOS_AARCH64_ONLY(thread->enable_wx(WXWrite));\n-\n@@ -148,0 +145,1 @@\n+<<<<<<< HEAD\n@@ -178,0 +176,2 @@\n+=======\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -188,7 +188,3 @@\n-JVM_ENTRY(jlong, PUH_AllocateUpcallStub(JNIEnv *env, jclass unused, jobject rec, jobject abi, jobject buffer_layout))\n-  Handle receiver(THREAD, JNIHandles::resolve(rec));\n-  jobject global_rec = JNIHandles::make_global(receiver);\n-  return (jlong) ProgrammableUpcallHandler::generate_upcall_stub(global_rec, abi, buffer_layout);\n-JNI_END\n-\n-JVM_ENTRY(jlong, PUH_AllocateOptimizedUpcallStub(JNIEnv *env, jclass unused, jobject mh, jobject abi, jobject conv))\n+JVM_ENTRY(jlong, PUH_AllocateOptimizedUpcallStub(JNIEnv *env, jclass unused, jobject mh, jobject abi, jobject conv,\n+                                                 jboolean needs_return_buffer, jlong ret_buf_size))\n+  ResourceMark rm(THREAD);\n@@ -206,2 +202,21 @@\n-  return (jlong) ProgrammableUpcallHandler::generate_optimized_upcall_stub(mh_j, entry, abi, conv);\n-JVM_END\n+  assert(entry->is_static(), \"static only\");\n+  \/\/ Fill in the signature array, for the calling-convention call.\n+  const int total_out_args = entry->size_of_parameters();\n+  assert(total_out_args > 0, \"receiver arg\");\n+\n+  BasicType* out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_out_args);\n+  BasicType ret_type;\n+  {\n+    int i = 0;\n+    SignatureStream ss(entry->signature());\n+    for (; !ss.at_return_type(); ss.next()) {\n+      out_sig_bt[i++] = ss.type();  \/\/ Collect remaining bits of signature\n+      if (ss.type() == T_LONG || ss.type() == T_DOUBLE)\n+        out_sig_bt[i++] = T_VOID;   \/\/ Longs & doubles take 2 Java slots\n+    }\n+    assert(i == total_out_args, \"\");\n+    ret_type = ss.type();\n+  }\n+  \/\/ skip receiver\n+  BasicType* in_sig_bt = out_sig_bt + 1;\n+  int total_in_args = total_out_args - 1;\n@@ -209,2 +224,2 @@\n-JVM_ENTRY(jboolean, PUH_SupportsOptimizedUpcalls(JNIEnv *env, jclass unused))\n-  return (jboolean) ProgrammableUpcallHandler::supports_optimized_upcalls();\n+  return (jlong) ProgrammableUpcallHandler::generate_optimized_upcall_stub(\n+    mh_j, entry, in_sig_bt, total_in_args, out_sig_bt, total_out_args, ret_type, abi, conv, needs_return_buffer, checked_cast<int>(ret_buf_size));\n@@ -217,3 +232,1 @@\n-  {CC \"allocateUpcallStub\", CC \"(\" \"Ljava\/lang\/invoke\/MethodHandle;\" \"L\" FOREIGN_ABI \"ABIDescriptor;\" \"L\" FOREIGN_ABI \"BufferLayout;\" \")J\", FN_PTR(PUH_AllocateUpcallStub)},\n-  {CC \"allocateOptimizedUpcallStub\", CC \"(\" \"Ljava\/lang\/invoke\/MethodHandle;\" \"L\" FOREIGN_ABI \"ABIDescriptor;\" \"L\" FOREIGN_ABI \"ProgrammableUpcallHandler$CallRegs;\" \")J\", FN_PTR(PUH_AllocateOptimizedUpcallStub)},\n-  {CC \"supportsOptimizedUpcalls\", CC \"()Z\", FN_PTR(PUH_SupportsOptimizedUpcalls)},\n+  {CC \"allocateOptimizedUpcallStub\", CC \"(\" \"Ljava\/lang\/invoke\/MethodHandle;\" \"L\" FOREIGN_ABI \"ABIDescriptor;\" \"L\" FOREIGN_ABI \"ProgrammableUpcallHandler$CallRegs;\" \"ZJ)J\", FN_PTR(PUH_AllocateOptimizedUpcallStub)},\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.cpp","additions":35,"deletions":22,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -35,15 +35,0 @@\n-  static constexpr CodeBuffer::csize_t upcall_stub_size = 1024;\n-\n-  struct UpcallMethod {\n-    Klass* klass;\n-    Symbol* name;\n-    Symbol* sig;\n-  } upcall_method;\n-\n-  ProgrammableUpcallHandler();\n-\n-  static const ProgrammableUpcallHandler& instance();\n-\n-  static void upcall_helper(JavaThread* thread, jobject rec, address buff);\n-  static void attach_thread_and_do_upcall(jobject rec, address buff);\n-\n@@ -52,0 +37,4 @@\n+<<<<<<< HEAD\n+=======\n+  static void detach_current_thread();\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -56,3 +45,6 @@\n-  static address generate_optimized_upcall_stub(jobject mh, Method* entry, jobject jabi, jobject jconv);\n-  static address generate_upcall_stub(jobject rec, jobject abi, jobject buffer_layout);\n-  static bool supports_optimized_upcalls();\n+  static address generate_optimized_upcall_stub(jobject mh, Method* entry,\n+                                                BasicType* in_sig_bt, int total_in_args,\n+                                                BasicType* out_sig_bt, int total_out_args,\n+                                                BasicType ret_type,\n+                                                jobject jabi, jobject jconv,\n+                                                bool needs_return_buffer, int ret_buf_size);\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.hpp","additions":10,"deletions":18,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+<<<<<<< HEAD:src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java\n@@ -29,0 +30,8 @@\n+=======\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.foreign.Utils;\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c:src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java\n@@ -45,0 +54,2 @@\n+    private final ABIDescriptor abi;\n+\n@@ -53,1 +64,2 @@\n-    public CallingSequenceBuilder(boolean forUpcall) {\n+    public CallingSequenceBuilder(ABIDescriptor abi, boolean forUpcall) {\n+        this.abi = abi;\n@@ -59,4 +71,1 @@\n-        verifyBindings(true, carrier, bindings);\n-        inputBindings.add(bindings);\n-        mt = mt.appendParameterTypes(carrier);\n-        desc = desc.appendArgumentLayouts(layout);\n+        addArgumentBinding(inputBindings.size(), carrier, layout, bindings);\n@@ -66,0 +75,7 @@\n+    private void addArgumentBinding(int index, Class<?> carrier, MemoryLayout layout, List<Binding> bindings) {\n+        verifyBindings(true, carrier, bindings);\n+        inputBindings.add(index, bindings);\n+        mt = mt.insertParameterTypes(index, carrier);\n+        desc = desc.insertArgumentLayouts(index, layout);\n+    }\n+\n@@ -80,0 +96,6 @@\n+    private boolean needsReturnBuffer() {\n+        return outputBindings.stream()\n+            .filter(Binding.Move.class::isInstance)\n+            .count() > 1;\n+    }\n+\n@@ -81,1 +103,47 @@\n-        return new CallingSequence(mt, desc, isTrivial, inputBindings, outputBindings);\n+        boolean needsReturnBuffer = needsReturnBuffer();\n+        long returnBufferSize = needsReturnBuffer ? computeReturnBuferSize() : 0;\n+        long allocationSize = computeAllocationSize() + returnBufferSize;\n+        if (!forUpcall) {\n+            addArgumentBinding(0, NativeSymbol.class, ValueLayout.ADDRESS, List.of(\n+                Binding.unboxAddress(NativeSymbol.class),\n+                Binding.vmStore(abi.targetAddrStorage(), long.class)));\n+            if (needsReturnBuffer) {\n+                addArgumentBinding(0, MemorySegment.class, ValueLayout.ADDRESS, List.of(\n+                    Binding.unboxAddress(MemorySegment.class),\n+                    Binding.vmStore(abi.retBufAddrStorage(), long.class)));\n+            }\n+        } else if (needsReturnBuffer) { \/\/ forUpcall == true\n+            addArgumentBinding(0, MemorySegment.class, ValueLayout.ADDRESS, List.of(\n+                Binding.vmLoad(abi.retBufAddrStorage(), long.class),\n+                Binding.boxAddress(),\n+                Binding.toSegment(returnBufferSize)));\n+        }\n+        return new CallingSequence(mt, desc, isTrivial, needsReturnBuffer, returnBufferSize, allocationSize, inputBindings, outputBindings);\n+    }\n+\n+    private long computeAllocationSize() {\n+        \/\/ FIXME: > 16 bytes alignment might need extra space since the\n+        \/\/ starting address of the allocator might be un-aligned.\n+        long size = 0;\n+        for (List<Binding> bindings : inputBindings) {\n+            for (Binding b : bindings) {\n+                if (b instanceof Binding.Copy copy) {\n+                    size = Utils.alignUp(size, copy.alignment());\n+                    size += copy.size();\n+                } else if (b instanceof Binding.Allocate allocate) {\n+                    size = Utils.alignUp(size, allocate.alignment());\n+                    size += allocate.size();\n+                }\n+            }\n+        }\n+        return size;\n+    }\n+\n+    private long computeReturnBuferSize() {\n+        return outputBindings.stream()\n+                .filter(Binding.Move.class::isInstance)\n+                .map(Binding.Move.class::cast)\n+                .map(Binding.Move::storage)\n+                .map(VMStorage::type)\n+                .mapToLong(abi.arch::typeSize)\n+                .sum();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":74,"deletions":6,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+<<<<<<< HEAD:src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java\n@@ -32,0 +33,8 @@\n+=======\n+import jdk.incubator.foreign.MemoryHandles;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import jdk.incubator.foreign.ValueLayout;\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c:src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java\n@@ -42,0 +51,1 @@\n+import java.nio.ByteOrder;\n@@ -45,1 +55,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n@@ -50,1 +59,1 @@\n-import static java.lang.invoke.MethodHandles.filterArguments;\n+import static java.lang.invoke.MethodHandles.foldArguments;\n@@ -54,1 +63,0 @@\n-import static sun.security.action.GetBooleanAction.privilegedGetProperty;\n@@ -62,2 +70,0 @@\n-    private static final boolean DEBUG =\n-        privilegedGetProperty(\"jdk.internal.foreign.ProgrammableInvoker.DEBUG\");\n@@ -66,2 +72,0 @@\n-    private static final boolean USE_INTRINSICS = Boolean.parseBoolean(\n-        GetPropertyAction.privilegedGetProperty(\"jdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS\", \"true\"));\n@@ -71,3 +75,0 @@\n-    private static final VarHandle VH_LONG = ValueLayout.JAVA_LONG.varHandle();\n-\n-    private static final MethodHandle MH_INVOKE_MOVES;\n@@ -75,1 +76,0 @@\n-    private static final MethodHandle MH_ADDR_TO_LONG;\n@@ -77,2 +77,2 @@\n-\n-    private static final Map<ABIDescriptor, Long> adapterStubs = new ConcurrentHashMap<>();\n+    private static final MethodHandle MH_ALLOCATE_RETURN_BUFFER;\n+    private static final MethodHandle MH_CHECK_SYMBOL;\n@@ -85,2 +85,0 @@\n-            MH_INVOKE_MOVES = lookup.findVirtual(ProgrammableInvoker.class, \"invokeMoves\",\n-                    methodType(Object.class, long.class, Object[].class, Binding.VMStore[].class, Binding.VMLoad[].class));\n@@ -88,0 +86,1 @@\n+<<<<<<< HEAD:src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java\n@@ -92,0 +91,9 @@\n+=======\n+                    methodType(Object.class, SegmentAllocator.class, Object[].class, InvocationData.class));\n+            MH_WRAP_ALLOCATOR = lookup.findStatic(Binding.Context.class, \"ofAllocator\",\n+                    methodType(Binding.Context.class, SegmentAllocator.class));\n+            MH_ALLOCATE_RETURN_BUFFER = lookup.findStatic(ProgrammableInvoker.class, \"allocateReturnBuffer\",\n+                    methodType(MemorySegment.class, Binding.Context.class, long.class));\n+            MH_CHECK_SYMBOL = lookup.findStatic(SharedUtils.class, \"checkSymbol\",\n+                    methodType(void.class, NativeSymbol.class));\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c:src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java\n@@ -98,3 +106,0 @@\n-    private final BufferLayout layout;\n-    private final long stackArgsBytes;\n-\n@@ -103,4 +108,0 @@\n-    private final long stubAddress;\n-\n-    private final long bufferCopySize;\n-\n@@ -109,3 +110,0 @@\n-        this.layout = BufferLayout.of(abi);\n-        this.stubAddress = adapterStubs.computeIfAbsent(abi, key -> generateAdapter(key, layout));\n-\n@@ -113,8 +111,0 @@\n-\n-        this.stackArgsBytes = argMoveBindingsStream(callingSequence)\n-                .map(Binding.VMStore::storage)\n-                .filter(s -> abi.arch.isStackType(s.type()))\n-                .count()\n-                * abi.arch.typeSize(abi.arch.stackType());\n-\n-        this.bufferCopySize = SharedUtils.bufferCopySize(callingSequence);\n@@ -128,5 +118,1 @@\n-        Class<?> returnType = retMoves.length == 0\n-                ? void.class\n-                : retMoves.length == 1\n-                    ? retMoves[0].type()\n-                    : Object[].class;\n+        Class<?> returnType = retMoves.length == 1 ? retMoves[0].type() : void.class;\n@@ -135,22 +121,0 @@\n-        MethodType leafTypeWithAddress = leafType.insertParameterTypes(0, long.class);\n-\n-        MethodHandle handle = insertArguments(MH_INVOKE_MOVES.bindTo(this), 2, argMoves, retMoves);\n-        MethodHandle collector = makeCollectorHandle(leafType);\n-        handle = collectArguments(handle, 1, collector);\n-        handle = handle.asType(leafTypeWithAddress);\n-\n-        boolean isSimple = !(retMoves.length > 1);\n-        boolean usesStackArgs = stackArgsBytes != 0;\n-        if (USE_INTRINSICS && isSimple && !usesStackArgs) {\n-            NativeEntryPoint nep = NativeEntryPoint.make(\n-                \"native_call\",\n-                abi,\n-                toStorageArray(argMoves),\n-                toStorageArray(retMoves),\n-                !callingSequence.isTrivial(),\n-                leafTypeWithAddress\n-            );\n-\n-            handle = JLIA.nativeMethodHandle(nep, handle);\n-        }\n-        handle = filterArguments(handle, 0, MH_ADDR_TO_LONG);\n@@ -158,1 +122,12 @@\n-        if (USE_SPEC && isSimple) {\n+        NativeEntryPoint nep = NativeEntryPoint.make(\n+            \"native_invoker_\" + leafType.descriptorString(),\n+            abi,\n+            toStorageArray(argMoves),\n+            toStorageArray(retMoves),\n+            !callingSequence.isTrivial(),\n+            leafType,\n+            callingSequence.needsReturnBuffer()\n+        );\n+        MethodHandle handle = JLIA.nativeMethodHandle(nep);\n+\n+        if (USE_SPEC) {\n@@ -164,4 +139,11 @@\n-            handle = insertArguments(MH_INVOKE_INTERP_BINDINGS.bindTo(this), 3, handle, argIndexMap, retIndexMap);\n-            MethodHandle collectorInterp = makeCollectorHandle(callingSequence.methodType());\n-            handle = collectArguments(handle, 2, collectorInterp);\n-            handle = handle.asType(handle.type().changeReturnType(callingSequence.methodType().returnType()));\n+            InvocationData invData = new InvocationData(handle, argIndexMap, retIndexMap);\n+            handle = insertArguments(MH_INVOKE_INTERP_BINDINGS.bindTo(this), 2, invData);\n+            MethodType interpType = callingSequence.methodType();\n+            if (callingSequence.needsReturnBuffer()) {\n+                \/\/ Return buffer is supplied by invokeInterpBindings\n+                assert interpType.parameterType(0) == MemorySegment.class;\n+                interpType.dropParameterTypes(0, 1);\n+            }\n+            MethodHandle collectorInterp = makeCollectorHandle(interpType);\n+            handle = collectArguments(handle, 1, collectorInterp);\n+            handle = handle.asType(handle.type().changeReturnType(interpType.returnType()));\n@@ -170,0 +152,6 @@\n+        assert handle.type().parameterType(0) == SegmentAllocator.class;\n+        assert handle.type().parameterType(1) == NativeSymbol.class;\n+        handle = foldArguments(handle, 1, MH_CHECK_SYMBOL);\n+\n+        handle = SharedUtils.swapArguments(handle, 0, 1); \/\/ normalize parameter order\n+\n@@ -173,0 +161,1 @@\n+<<<<<<< HEAD:src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java\n@@ -176,0 +165,4 @@\n+=======\n+    private static MemorySegment allocateReturnBuffer(Binding.Context context, long size) {\n+        return context.allocator().allocate(size);\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c:src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java\n@@ -194,0 +187,4 @@\n+        return retMoveBindingsStream(callingSequence).toArray(Binding.VMLoad[]::new);\n+    }\n+\n+    private Stream<Binding.VMLoad> retMoveBindingsStream(CallingSequence callingSequence) {\n@@ -196,2 +193,1 @@\n-                .map(Binding.VMLoad.class::cast)\n-                .toArray(Binding.VMLoad[]::new);\n+                .map(Binding.VMLoad.class::cast);\n@@ -200,1 +196,0 @@\n-\n@@ -208,2 +203,2 @@\n-        int argInsertPos = 1;\n-        int argContextPos = 1;\n+        int argInsertPos = 0;\n+        int argContextPos = 0;\n@@ -212,1 +207,0 @@\n-\n@@ -229,0 +223,2 @@\n+            int retBufPos = -1;\n+            long retBufReadOffset = -1;\n@@ -231,0 +227,7 @@\n+            if (callingSequence.needsReturnBuffer()) {\n+                retBufPos = 0;\n+                retBufReadOffset = callingSequence.returnBufferSize();\n+                retContextPos++;\n+                retInsertPos++;\n+                returnFilter = dropArguments(returnFilter, retBufPos, MemorySegment.class);\n+            }\n@@ -235,1 +238,26 @@\n-                returnFilter = binding.specialize(returnFilter, retInsertPos, retContextPos);\n+                if (callingSequence.needsReturnBuffer() && binding.tag() == Binding.Tag.VM_LOAD) {\n+                    \/\/ spacial case this, since we need to update retBufReadOffset as well\n+                    Binding.VMLoad load = (Binding.VMLoad) binding;\n+                    ValueLayout layout = MemoryLayout.valueLayout(load.type(), ByteOrder.nativeOrder()).withBitAlignment(8);\n+                    \/\/ since we iterate the bindings in reverse, we have to compute the offset in reverse as well\n+                    retBufReadOffset -= abi.arch.typeSize(load.storage().type());\n+                    MethodHandle loadHandle = MemoryHandles.insertCoordinates(MemoryHandles.varHandle(layout), 1, retBufReadOffset)\n+                            .toMethodHandle(VarHandle.AccessMode.GET);\n+\n+                    returnFilter = MethodHandles.collectArguments(returnFilter, retInsertPos, loadHandle);\n+                    assert returnFilter.type().parameterType(retInsertPos - 1) == MemorySegment.class;\n+                    assert returnFilter.type().parameterType(retInsertPos - 2) == MemorySegment.class;\n+                    returnFilter = SharedUtils.mergeArguments(returnFilter, retBufPos, retInsertPos);\n+                    \/\/ to (... MemorySegment, MemorySegment, <primitive>, ...)\n+                    \/\/ from (... MemorySegment, MemorySegment, ...)\n+                    retInsertPos -= 2; \/\/ set insert pos back to the first MS (later DUP binding will merge the 2 MS)\n+                } else {\n+                    returnFilter = binding.specialize(returnFilter, retInsertPos, retContextPos);\n+                    if (callingSequence.needsReturnBuffer() && binding.tag() == Binding.Tag.BUFFER_STORE) {\n+                        \/\/ from (... MemorySegment, ...)\n+                        \/\/ to (... MemorySegment, MemorySegment, <primitive>, ...)\n+                        retInsertPos += 2; \/\/ set insert pos to <primitive>\n+                        assert returnFilter.type().parameterType(retInsertPos - 1) == MemorySegment.class;\n+                        assert returnFilter.type().parameterType(retInsertPos - 2) == MemorySegment.class;\n+                    }\n+                }\n@@ -237,2 +265,1 @@\n-            returnFilter = MethodHandles.filterArguments(returnFilter, retContextPos, MH_WRAP_ALLOCATOR);\n-            \/\/ (SegmentAllocator, Addressable, Context, ...) -> ...\n+            \/\/ (R, Context (ret)) -> (MemorySegment?, Context (ret), MemorySegment?, Context (arg), ...)\n@@ -240,2 +267,13 @@\n-            \/\/ (Addressable, SegmentAllocator, Context, ...) -> ...\n-            specializedHandle = SharedUtils.swapArguments(specializedHandle, 0, 1); \/\/ normalize parameter order\n+            if (callingSequence.needsReturnBuffer()) {\n+                \/\/ (MemorySegment, Context (ret), Context (arg), MemorySegment,  ...) -> (MemorySegment, Context (ret), Context (arg), ...)\n+                specializedHandle = SharedUtils.mergeArguments(specializedHandle, retBufPos, retBufPos + 3);\n+\n+                \/\/ allocate the return buffer from the binding context, and then merge the 2 allocator args\n+                MethodHandle retBufAllocHandle = MethodHandles.insertArguments(MH_ALLOCATE_RETURN_BUFFER, 1, callingSequence.returnBufferSize());\n+                \/\/ (MemorySegment, Context (ret), Context (arg), ...) -> (Context (arg), Context (ret), Context (arg), ...)\n+                specializedHandle = MethodHandles.filterArguments(specializedHandle, retBufPos, retBufAllocHandle);\n+                \/\/ (Context (arg), Context (ret), Context (arg), ...) -> (Context (ret), Context (arg), ...)\n+                specializedHandle = SharedUtils.mergeArguments(specializedHandle, argContextPos + 1, retBufPos); \/\/ +1 to skip return context\n+            }\n+            \/\/ (Context (ret), Context (arg), ...) -> (SegmentAllocator, Context (arg), ...)\n+            specializedHandle = MethodHandles.filterArguments(specializedHandle, 0, MH_WRAP_ALLOCATOR);\n@@ -243,1 +281,1 @@\n-            specializedHandle = MethodHandles.dropArguments(specializedHandle, 1, SegmentAllocator.class);\n+            specializedHandle = MethodHandles.dropArguments(specializedHandle, 0, SegmentAllocator.class);\n@@ -249,1 +287,1 @@\n-        specializedHandle = SharedUtils.wrapWithAllocator(specializedHandle, argContextPos, bufferCopySize, false);\n+        specializedHandle = SharedUtils.wrapWithAllocator(specializedHandle, argContextPos, callingSequence.allocationSize(), false);\n@@ -253,0 +291,1 @@\n+<<<<<<< HEAD:src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java\n@@ -318,0 +357,7 @@\n+=======\n+    private record InvocationData(MethodHandle leaf, Map<VMStorage, Integer> argIndexMap, Map<VMStorage, Integer> retIndexMap) {}\n+\n+    Object invokeInterpBindings(SegmentAllocator allocator, Object[] args, InvocationData invData) throws Throwable {\n+        Binding.Context unboxContext = callingSequence.allocationSize() != 0\n+                ? Binding.Context.ofBoundedAllocator(callingSequence.allocationSize())\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c:src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java\n@@ -320,0 +366,2 @@\n+            MemorySegment returnBuffer = null;\n+\n@@ -321,2 +369,9 @@\n-            Object[] leafArgs = new Object[leaf.type().parameterCount()];\n-            leafArgs[0] = symbol; \/\/ symbol\n+            Object[] leafArgs = new Object[invData.leaf.type().parameterCount()];\n+            if (callingSequence.needsReturnBuffer()) {\n+                \/\/ we supply the return buffer (argument array does not contain it)\n+                Object[] prefixedArgs = new Object[args.length + 1];\n+                returnBuffer = unboxContext.allocator().allocate(callingSequence.returnBufferSize());\n+                prefixedArgs[0] = returnBuffer;\n+                System.arraycopy(args, 0, prefixedArgs, 1, args.length);\n+                args = prefixedArgs;\n+            }\n@@ -327,1 +382,1 @@\n-                            leafArgs[argIndexMap.get(storage) + 1] = value; \/\/ +1 to skip symbol\n+                            leafArgs[invData.argIndexMap.get(storage)] = value;\n@@ -332,1 +387,1 @@\n-            Object o = leaf.invokeWithArguments(leafArgs);\n+            Object o = invData.leaf.invokeWithArguments(leafArgs);\n@@ -336,3 +391,4 @@\n-                return null;\n-            } else if (o instanceof Object[]) {\n-                Object[] oArr = (Object[]) o;\n+                if (!callingSequence.needsReturnBuffer()) {\n+                    return null;\n+                }\n+                MemorySegment finalReturnBuffer = returnBuffer;\n@@ -340,1 +396,9 @@\n-                        (storage, type) -> oArr[retIndexMap.get(storage)], Binding.Context.ofAllocator(allocator));\n+                        new BindingInterpreter.LoadFunc() {\n+                            int retBufReadOffset = 0;\n+                            @Override\n+                            public Object load(VMStorage storage, Class<?> type) {\n+                                Object result1 = SharedUtils.read(finalReturnBuffer.asSlice(retBufReadOffset), type);\n+                                retBufReadOffset += abi.arch.typeSize(storage.type());\n+                                return result1;\n+                            }\n+                        }, Binding.Context.ofAllocator(allocator));\n@@ -347,10 +411,0 @@\n-\n-    \/\/natives\n-\n-    static native void invokeNative(long adapterStub, long buff);\n-    static native long generateAdapter(ABIDescriptor abi, BufferLayout layout);\n-\n-    private static native void registerNatives();\n-    static {\n-        registerNatives();\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":150,"deletions":96,"binary":false,"changes":246,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+<<<<<<< HEAD:src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java\n@@ -32,0 +33,8 @@\n+=======\n+import jdk.incubator.foreign.MemoryHandles;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c:src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java\n@@ -34,1 +43,0 @@\n-import jdk.internal.foreign.MemoryAddressImpl;\n@@ -41,0 +49,1 @@\n+import java.nio.ByteOrder;\n@@ -47,0 +56,1 @@\n+import static java.lang.invoke.MethodHandles.collectArguments;\n@@ -48,0 +58,1 @@\n+<<<<<<< HEAD:src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java\n@@ -49,0 +60,4 @@\n+=======\n+import static java.lang.invoke.MethodHandles.empty;\n+import static java.lang.invoke.MethodHandles.exactInvoker;\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c:src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java\n@@ -56,5 +71,0 @@\n-\/**\n- * This class implements upcall invocation from native code through a so called 'universal adapter'. A universal upcall adapter\n- * takes an array of storage pointers, which describes the state of the CPU at the time of the upcall. This can be used\n- * by the Java code to fetch the upcall arguments and to store the results to the desired location, as per system ABI.\n- *\/\n@@ -66,4 +76,0 @@\n-    private static final boolean USE_INTRINSICS = Boolean.parseBoolean(\n-        GetPropertyAction.privilegedGetProperty(\"jdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS\", \"true\"));\n-\n-    private static final JavaLangInvokeAccess JLI = SharedSecrets.getJavaLangInvokeAccess();\n@@ -71,3 +77,0 @@\n-    private static final VarHandle VH_LONG = ValueLayout.JAVA_LONG.varHandle();\n-\n-    private static final MethodHandle MH_invokeMoves;\n@@ -76,0 +79,2 @@\n+    private static final JavaLangInvokeAccess JLI = SharedSecrets.getJavaLangInvokeAccess();\n+\n@@ -79,3 +84,0 @@\n-            MH_invokeMoves = lookup.findStatic(ProgrammableUpcallHandler.class, \"invokeMoves\",\n-                    methodType(void.class, MemoryAddress.class, MethodHandle.class,\n-                               Binding.VMLoad[].class, Binding.VMStore[].class, ABIDescriptor.class, BufferLayout.class));\n@@ -83,2 +85,1 @@\n-                    methodType(Object.class, Object[].class, MethodHandle.class, Map.class, Map.class,\n-                            CallingSequence.class, long.class));\n+                    methodType(Object.class, Object[].class, InvocationData.class));\n@@ -94,7 +95,1 @@\n-        boolean isSimple = !(retMoves.length > 1);\n-\n-        Class<?> llReturn = !isSimple\n-            ? Object[].class\n-            : retMoves.length == 1\n-                ? retMoves[0].type()\n-                : void.class;\n+        Class<?> llReturn = retMoves.length == 1 ? retMoves[0].type() : void.class;\n@@ -102,1 +97,1 @@\n-        MethodType llType = MethodType.methodType(llReturn, llParams);\n+        MethodType llType = methodType(llReturn, llParams);\n@@ -105,3 +100,2 @@\n-        long bufferCopySize = SharedUtils.bufferCopySize(callingSequence);\n-        if (USE_SPEC && isSimple) {\n-            doBindings = specializedBindingHandle(target, callingSequence, llReturn, bufferCopySize);\n+        if (USE_SPEC) {\n+            doBindings = specializedBindingHandle(target, callingSequence, llReturn, abi);\n@@ -112,3 +106,7 @@\n-            target = target.asSpreader(Object[].class, callingSequence.methodType().parameterCount());\n-            doBindings = insertArguments(MH_invokeInterpBindings, 1, target, argIndices, retIndices, callingSequence,\n-                    bufferCopySize);\n+            int spreaderCount = callingSequence.methodType().parameterCount();\n+            if (callingSequence.needsReturnBuffer()) {\n+                spreaderCount--; \/\/ return buffer is dropped from the argument list\n+            }\n+            target = target.asSpreader(Object[].class, spreaderCount);\n+            InvocationData invData = new InvocationData(target, argIndices, retIndices, callingSequence, retMoves, abi);\n+            doBindings = insertArguments(MH_invokeInterpBindings, 1, invData);\n@@ -119,0 +117,1 @@\n+<<<<<<< HEAD:src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java\n@@ -137,0 +136,10 @@\n+=======\n+        checkPrimitive(doBindings.type());\n+        JLI.ensureCustomized(doBindings);\n+        VMStorage[] args = Arrays.stream(argMoves).map(Binding.Move::storage).toArray(VMStorage[]::new);\n+        VMStorage[] rets = Arrays.stream(retMoves).map(Binding.Move::storage).toArray(VMStorage[]::new);\n+        CallRegs conv = new CallRegs(args, rets);\n+        long entryPoint = allocateOptimizedUpcallStub(doBindings, abi, conv,\n+                callingSequence.needsReturnBuffer(), callingSequence.returnBufferSize());\n+        return UpcallStubs.makeUpcall(entryPoint, scope);\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c:src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java\n@@ -164,1 +173,1 @@\n-                                                         Class<?> llReturn, long bufferCopySize) {\n+                                                         Class<?> llReturn, ABIDescriptor abi) {\n@@ -169,0 +178,32 @@\n+        \/\/ we handle returns first since IMR adds an extra parameter that needs to be specialized as well\n+        if (llReturn != void.class || callingSequence.needsReturnBuffer()) {\n+            int retAllocatorPos = -1; \/\/ assumed not needed\n+            int retInsertPos;\n+            MethodHandle filter;\n+            if (callingSequence.needsReturnBuffer()) {\n+                retInsertPos = 1;\n+                filter = empty(methodType(void.class, MemorySegment.class));\n+            } else {\n+                retInsertPos = 0;\n+                filter = identity(llReturn);\n+            }\n+            long retBufWriteOffset = callingSequence.returnBufferSize();\n+            List<Binding> bindings = callingSequence.returnBindings();\n+            for (int j = bindings.size() - 1; j >= 0; j--) {\n+                Binding binding = bindings.get(j);\n+                if (callingSequence.needsReturnBuffer() && binding.tag() == Binding.Tag.VM_STORE) {\n+                    Binding.VMStore store = (Binding.VMStore) binding;\n+                    ValueLayout layout = MemoryLayout.valueLayout(store.type(), ByteOrder.nativeOrder()).withBitAlignment(8);\n+                    \/\/ since we iterate the bindings in reverse, we have to compute the offset in reverse as well\n+                    retBufWriteOffset -= abi.arch.typeSize(store.storage().type());\n+                    MethodHandle storeHandle = MemoryHandles.insertCoordinates(MemoryHandles.varHandle(layout), 1, retBufWriteOffset)\n+                            .toMethodHandle(VarHandle.AccessMode.SET);\n+                    filter = collectArguments(filter, retInsertPos, storeHandle);\n+                    filter = mergeArguments(filter, retInsertPos - 1, retInsertPos);\n+                } else {\n+                    filter = binding.specialize(filter, retInsertPos, retAllocatorPos);\n+                }\n+            }\n+            specializedHandle = collectArguments(filter, retInsertPos, specializedHandle);\n+        }\n+\n@@ -188,13 +229,1 @@\n-        if (llReturn != void.class) {\n-            int retAllocatorPos = -1; \/\/ assumed not needed\n-            int retInsertPos = 0;\n-            MethodHandle filter = identity(llReturn);\n-            List<Binding> bindings = callingSequence.returnBindings();\n-            for (int j = bindings.size() - 1; j >= 0; j--) {\n-                Binding binding = bindings.get(j);\n-                filter = binding.specialize(filter, retInsertPos, retAllocatorPos);\n-            }\n-            specializedHandle = filterReturnValue(specializedHandle, filter);\n-        }\n-\n-        specializedHandle = SharedUtils.wrapWithAllocator(specializedHandle, argAllocatorPos, bufferCopySize, true);\n+        specializedHandle = SharedUtils.wrapWithAllocator(specializedHandle, argAllocatorPos, callingSequence.allocationSize(), true);\n@@ -205,24 +234,6 @@\n-    public static void invoke(MethodHandle mh, long address) throws Throwable {\n-        mh.invokeExact(MemoryAddress.ofLong(address));\n-    }\n-\n-    private static void invokeMoves(MemoryAddress buffer, MethodHandle leaf,\n-                                    Binding.VMLoad[] argBindings, Binding.VMStore[] returnBindings,\n-                                    ABIDescriptor abi, BufferLayout layout) throws Throwable {\n-        MemorySegment bufferBase = MemoryAddressImpl.ofLongUnchecked(buffer.toRawLongValue(), layout.size);\n-\n-        if (DEBUG) {\n-            System.err.println(\"Buffer state before:\");\n-            layout.dump(abi.arch, bufferBase, System.err);\n-        }\n-\n-        MemorySegment stackArgsBase = MemoryAddressImpl.ofLongUnchecked((long)VH_LONG.get(bufferBase.asSlice(layout.stack_args)));\n-        Object[] moves = new Object[argBindings.length];\n-        for (int i = 0; i < moves.length; i++) {\n-            Binding.VMLoad binding = argBindings[i];\n-            VMStorage storage = binding.storage();\n-            MemorySegment ptr = abi.arch.isStackType(storage.type())\n-                ? stackArgsBase.asSlice(storage.index() * abi.arch.typeSize(abi.arch.stackType()))\n-                : bufferBase.asSlice(layout.argOffset(storage));\n-            moves[i] = SharedUtils.read(ptr, binding.type());\n-        }\n+    private record InvocationData(MethodHandle leaf,\n+                                  Map<VMStorage, Integer> argIndexMap,\n+                                  Map<VMStorage, Integer> retIndexMap,\n+                                  CallingSequence callingSequence,\n+                                  Binding.VMStore[] retMoves,\n+                                  ABIDescriptor abi) {}\n@@ -230,32 +241,3 @@\n-        \/\/ invokeInterpBindings, and then actual target\n-        Object o = leaf.invoke(moves);\n-\n-        if (o == null) {\n-            \/\/ nop\n-        } else if (o instanceof Object[] returns) {\n-            for (int i = 0; i < returnBindings.length; i++) {\n-                Binding.VMStore binding = returnBindings[i];\n-                VMStorage storage = binding.storage();\n-                MemorySegment ptr = bufferBase.asSlice(layout.retOffset(storage));\n-                SharedUtils.writeOverSized(ptr, binding.type(), returns[i]);\n-            }\n-        } else { \/\/ single Object\n-            Binding.VMStore binding = returnBindings[0];\n-            VMStorage storage = binding.storage();\n-            MemorySegment ptr = bufferBase.asSlice(layout.retOffset(storage));\n-            SharedUtils.writeOverSized(ptr, binding.type(), o);\n-        }\n-\n-        if (DEBUG) {\n-            System.err.println(\"Buffer state after:\");\n-            layout.dump(abi.arch, bufferBase, System.err);\n-        }\n-    }\n-\n-    private static Object invokeInterpBindings(Object[] moves, MethodHandle leaf,\n-                                               Map<VMStorage, Integer> argIndexMap,\n-                                               Map<VMStorage, Integer> retIndexMap,\n-                                               CallingSequence callingSequence,\n-                                               long bufferCopySize) throws Throwable {\n-        Binding.Context allocator = bufferCopySize != 0\n-                ? Binding.Context.ofBoundedAllocator(bufferCopySize)\n+    private static Object invokeInterpBindings(Object[] lowLevelArgs, InvocationData invData) throws Throwable {\n+        Binding.Context allocator = invData.callingSequence.allocationSize() != 0\n+                ? Binding.Context.ofBoundedAllocator(invData.callingSequence.allocationSize())\n@@ -265,4 +247,13 @@\n-            Object[] args = new Object[callingSequence.methodType().parameterCount()];\n-            for (int i = 0; i < args.length; i++) {\n-                args[i] = BindingInterpreter.box(callingSequence.argumentBindings(i),\n-                        (storage, type) -> moves[argIndexMap.get(storage)], allocator);\n+            Object[] highLevelArgs = new Object[invData.callingSequence.methodType().parameterCount()];\n+            for (int i = 0; i < highLevelArgs.length; i++) {\n+                highLevelArgs[i] = BindingInterpreter.box(invData.callingSequence.argumentBindings(i),\n+                        (storage, type) -> lowLevelArgs[invData.argIndexMap.get(storage)], allocator);\n+            }\n+\n+            MemorySegment returnBuffer = null;\n+            if (invData.callingSequence.needsReturnBuffer()) {\n+                \/\/ this one is for us\n+                returnBuffer = (MemorySegment) highLevelArgs[0];\n+                Object[] newArgs = new Object[highLevelArgs.length - 1];\n+                System.arraycopy(highLevelArgs, 1, newArgs, 0, newArgs.length);\n+                highLevelArgs = newArgs;\n@@ -273,1 +264,1 @@\n-                System.err.println(Arrays.toString(args).indent(2));\n+                System.err.println(Arrays.toString(highLevelArgs).indent(2));\n@@ -277,1 +268,1 @@\n-            Object o = leaf.invoke(args);\n+            Object o = invData.leaf.invoke(highLevelArgs);\n@@ -284,4 +275,4 @@\n-            Object[] returnMoves = new Object[retIndexMap.size()];\n-            if (leaf.type().returnType() != void.class) {\n-                BindingInterpreter.unbox(o, callingSequence.returnBindings(),\n-                        (storage, type, value) -> returnMoves[retIndexMap.get(storage)] = value, null);\n+            Object[] returnValues = new Object[invData.retIndexMap.size()];\n+            if (invData.leaf.type().returnType() != void.class) {\n+                BindingInterpreter.unbox(o, invData.callingSequence.returnBindings(),\n+                        (storage, type, value) -> returnValues[invData.retIndexMap.get(storage)] = value, null);\n@@ -290,1 +281,1 @@\n-            if (returnMoves.length == 0) {\n+            if (returnValues.length == 0) {\n@@ -292,2 +283,2 @@\n-            } else if (returnMoves.length == 1) {\n-                return returnMoves[0];\n+            } else if (returnValues.length == 1) {\n+                return returnValues[0];\n@@ -295,1 +286,16 @@\n-                return returnMoves;\n+                assert invData.callingSequence.needsReturnBuffer();\n+\n+                Binding.VMStore[] retMoves = invData.callingSequence.returnBindings().stream()\n+                        .filter(Binding.VMStore.class::isInstance)\n+                        .map(Binding.VMStore.class::cast)\n+                        .toArray(Binding.VMStore[]::new);\n+\n+                assert returnValues.length == retMoves.length;\n+                int retBufWriteOffset = 0;\n+                for (int i = 0; i < retMoves.length; i++) {\n+                    Binding.VMStore store = retMoves[i];\n+                    Object value = returnValues[i];\n+                    SharedUtils.writeOverSized(returnBuffer.asSlice(retBufWriteOffset), store.type(), value);\n+                    retBufWriteOffset += invData.abi.arch.typeSize(store.storage().type());\n+                }\n+                return null;\n@@ -306,3 +312,2 @@\n-    static native long allocateOptimizedUpcallStub(MethodHandle mh, ABIDescriptor abi, CallRegs conv);\n-    static native long allocateUpcallStub(MethodHandle mh, ABIDescriptor abi, BufferLayout layout);\n-    static native boolean supportsOptimizedUpcalls();\n+    static native long allocateOptimizedUpcallStub(MethodHandle mh, ABIDescriptor abi, CallRegs conv,\n+                                                   boolean needsReturnBuffer, long returnBufferSize);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":124,"deletions":119,"binary":false,"changes":243,"status":"modified"},{"patch":"@@ -297,21 +297,0 @@\n-    static long bufferCopySize(CallingSequence callingSequence) {\n-        \/\/ FIXME: > 16 bytes alignment might need extra space since the\n-        \/\/ starting address of the allocator might be un-aligned.\n-        long size = 0;\n-        for (int i = 0; i < callingSequence.argumentCount(); i++) {\n-            List<Binding> bindings = callingSequence.argumentBindings(i);\n-            for (Binding b : bindings) {\n-                if (b instanceof Binding.Copy) {\n-                    Binding.Copy c = (Binding.Copy) b;\n-                    size = Utils.alignUp(size, c.alignment());\n-                    size += c.size();\n-                } else if (b instanceof Binding.Allocate) {\n-                    Binding.Allocate c = (Binding.Allocate) b;\n-                    size = Utils.alignUp(size, c.alignment());\n-                    size += c.size();\n-                }\n-            }\n-        }\n-        return size;\n-    }\n-\n@@ -334,1 +313,2 @@\n-        assert destIndex > sourceIndex;\n+        if (destIndex < sourceIndex)\n+            sourceIndex--;\n@@ -372,1 +352,1 @@\n-                                          int allocatorPos, long bufferCopySize,\n+                                          int allocatorPos, long allocationSize,\n@@ -394,1 +374,1 @@\n-        \/\/ downcalls get the leading NativeSymbol\/SegmentAllocator param as well\n+        \/\/ downcalls get the leading SegmentAllocator param as well\n@@ -396,0 +376,1 @@\n+<<<<<<< HEAD:src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java\n@@ -398,0 +379,3 @@\n+=======\n+            closer = dropArguments(closer, insertPos++, SegmentAllocator.class); \/\/ (Throwable, V?, SegmentAllocator, NativeSymbol) -> V\/void\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c:src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java\n@@ -400,1 +384,1 @@\n-        closer = collectArguments(closer, insertPos++, MH_CLOSE_CONTEXT); \/\/ (Throwable, V?, NativeSymbol?, BindingContext) -> V\/void\n+        closer = collectArguments(closer, insertPos, MH_CLOSE_CONTEXT); \/\/ (Throwable, V?, SegmentAllocator?, BindingContext) -> V\/void\n@@ -404,2 +388,2 @@\n-        if (bufferCopySize > 0) {\n-            contextFactory = MethodHandles.insertArguments(MH_MAKE_CONTEXT_BOUNDED_ALLOCATOR, 0, bufferCopySize);\n+        if (allocationSize > 0) {\n+            contextFactory = MethodHandles.insertArguments(MH_MAKE_CONTEXT_BOUNDED_ALLOCATOR, 0, allocationSize);\n@@ -559,0 +543,1 @@\n+<<<<<<< HEAD:src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java\n@@ -560,0 +545,23 @@\n+=======\n+    public static MethodHandle maybeInsertAllocator(MethodHandle handle) {\n+        if (!handle.type().returnType().equals(MemorySegment.class)) {\n+            \/\/ not returning segment, just insert a throwing allocator\n+            handle = insertArguments(handle, 1, THROWING_ALLOCATOR);\n+        }\n+        return handle;\n+    }\n+\n+    \/\/ lazy init MH_ALLOC and MH_FREE handles\n+    private static class AllocHolder {\n+\n+        private static final CLinker SYS_LINKER = getSystemLinker();\n+\n+        static final MethodHandle MH_MALLOC = SYS_LINKER.downcallHandle(CLinker.systemCLinker().lookup(\"malloc\").get(),\n+                FunctionDescriptor.of(ADDRESS, JAVA_LONG));\n+\n+        static final MethodHandle MH_FREE = SYS_LINKER.downcallHandle(CLinker.systemCLinker().lookup(\"free\").get(),\n+                FunctionDescriptor.ofVoid(ADDRESS));\n+    }\n+\n+    public static void checkSymbol(NativeSymbol symbol) {\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c:src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":35,"deletions":27,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+<<<<<<< HEAD:src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java\n@@ -36,0 +37,8 @@\n+=======\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.VaList;\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c:src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java\n@@ -39,1 +48,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -77,4 +85,1 @@\n-        if (!type.returnType().equals(MemorySegment.class)) {\n-            \/\/ not returning segment, just insert a throwing allocator\n-            handle = MethodHandles.insertArguments(handle, 1, SharedUtils.THROWING_ALLOCATOR);\n-        }\n+        handle = SharedUtils.maybeInsertAllocator(handle);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -489,0 +489,4 @@\n+<<<<<<< HEAD\n+=======\n+java\/foreign\/TestMismatch.java 8249684 macosx-all\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n","filename":"test\/jdk\/ProblemList.txt","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+<<<<<<< HEAD\n@@ -45,0 +46,9 @@\n+=======\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SymbolLookup;\n+import jdk.incubator.foreign.MemoryLayout;\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -69,0 +79,1 @@\n+<<<<<<< HEAD\n@@ -73,0 +84,28 @@\n+=======\n+        NativeSymbol addr = LOOKUP.lookup(fName).get();\n+        FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n+        Object[] args = makeArgs(paramTypes, fields, checks);\n+        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+            boolean needsScope = descriptor.returnLayout().map(GroupLayout.class::isInstance).orElse(false);\n+            SegmentAllocator allocator = needsScope ?\n+                    SegmentAllocator.newNativeArena(scope) :\n+                    THROWING_ALLOCATOR;\n+            Object res = doCall(addr, allocator, descriptor, args);\n+            if (ret == Ret.NON_VOID) {\n+                checks.forEach(c -> c.accept(res));\n+                if (needsScope) {\n+                    \/\/ check that return struct has indeed been allocated in the native scope\n+                    assertEquals(((MemorySegment) res).scope(), scope);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n+    public void testDowncallStack(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+        List<Consumer<Object>> checks = new ArrayList<>();\n+        NativeSymbol addr = LOOKUP.lookup(\"s\" + fName).get();\n+        FunctionDescriptor descriptor = functionStack(ret, paramTypes, fields);\n+        Object[] args = makeArgsStack(paramTypes, fields, checks);\n+        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+<<<<<<< HEAD\n@@ -84,0 +85,33 @@\n+=======\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * Note: to run this test manually, you need to build the tests first to get native\n+ * libraries compiled, and then execute it with plain jtreg, like:\n+ *\n+ *  $ bin\/jtreg -jdk:<path-to-tested-jdk> \\\n+ *              -nativepath:<path-to-build-dir>\/support\/test\/jdk\/jtreg\/native\/manual\/lib\/ \\\n+ *              -concurrency:auto \\\n+ *              .\/test\/jdk\/java\/foreign\/TestMatrix.java\n+ *\/\n+\n+\/* @test id=UpcallHighArity-FF\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -90,0 +124,1 @@\n+<<<<<<< HEAD\n@@ -95,0 +130,7 @@\n+=======\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   TestUpcallHighArity\n+ *\/\n+\n+\/* @test id=UpcallHighArity-TF\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -101,0 +143,1 @@\n+<<<<<<< HEAD\n@@ -106,0 +149,7 @@\n+=======\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   TestUpcallHighArity\n+ *\/\n+\n+\/* @test id=UpcallHighArity-FT\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -112,0 +162,1 @@\n+<<<<<<< HEAD\n@@ -118,0 +169,7 @@\n+=======\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   TestUpcallHighArity\n+ *\/\n+\n+\/* @test id=UpcallHighArity-TT\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -124,0 +182,1 @@\n+<<<<<<< HEAD\n@@ -132,0 +191,10 @@\n+=======\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   TestUpcallHighArity\n+ *\/\n+\n+\/* @test id=Downcall-F\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestDowncall\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -136,0 +205,1 @@\n+<<<<<<< HEAD\n@@ -144,0 +214,9 @@\n+=======\n+ *   TestDowncall\n+ *\/\n+\n+\/* @test id=Downcall-T\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestDowncall\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -148,0 +227,1 @@\n+<<<<<<< HEAD\n@@ -155,0 +235,8 @@\n+=======\n+ *   TestDowncall\n+ *\/\n+\n+\/* @test id=UpcallScope-FF\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -161,0 +249,1 @@\n+<<<<<<< HEAD\n@@ -167,0 +256,8 @@\n+=======\n+ *   TestUpcallScope\n+ *\/\n+\n+\/* @test id=UpcallScope-TF\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -173,0 +270,1 @@\n+<<<<<<< HEAD\n@@ -179,0 +277,8 @@\n+=======\n+ *   TestUpcallScope\n+ *\/\n+\n+\/* @test id=UpcallScope-FT\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -185,0 +291,1 @@\n+<<<<<<< HEAD\n@@ -191,0 +298,8 @@\n+=======\n+ *   TestUpcallScope\n+ *\/\n+\n+\/* @test id=UpcallScope-TT\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -197,0 +312,1 @@\n+<<<<<<< HEAD\n@@ -203,0 +319,8 @@\n+=======\n+ *   TestUpcallScope\n+ *\/\n+\n+\/* @test id=UpcallAsync-FF\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -205,1 +329,1 @@\n- * @run testng\/othervm\/native\/manual\n+ * @run testng\/othervm\/native\/manual\/timeout=960\n@@ -209,0 +333,1 @@\n+<<<<<<< HEAD\n@@ -215,0 +340,58 @@\n+=======\n+ *   TestUpcallAsync\n+ *\/\n+\n+\/* @test id=UpcallAsync-TF\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n+ *\n+ * @run testng\/othervm\/native\/manual\/timeout=960\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+<<<<<<< HEAD\n+=======\n+ *   TestUpcallAsync\n+ *\/\n+\n+\/* @test id=UpcallAsync-FT\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n+ *\n+ * @run testng\/othervm\/native\/manual\/timeout=960\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   TestUpcallAsync\n+ *\/\n+\n+\/* @test id=UpcallAsync-TT\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n+ *\n+ * @run testng\/othervm\/native\/manual\/timeout=960\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   TestUpcallAsync\n+ *\/\n+\n+\/* @test id=UpcallStack-FF\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n+ *\n+ * @run testng\/othervm\/native\/manual\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   TestUpcallStack\n+ *\/\n+\n+\/* @test id=UpcallStack-TF\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -221,0 +404,1 @@\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -225,0 +409,1 @@\n+<<<<<<< HEAD\n@@ -227,0 +412,4 @@\n+=======\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -237,0 +426,1 @@\n+<<<<<<< HEAD\n@@ -239,0 +429,4 @@\n+=======\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -247,0 +441,1 @@\n+\n","filename":"test\/jdk\/java\/foreign\/TestMatrix.java","additions":196,"deletions":1,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+<<<<<<< HEAD\n@@ -28,0 +29,4 @@\n+=======\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -35,0 +40,1 @@\n+<<<<<<< HEAD\n@@ -42,0 +48,9 @@\n+=======\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -63,0 +78,1 @@\n+<<<<<<< HEAD\n@@ -69,0 +85,8 @@\n+=======\n+        NativeSymbol addr = LOOKUP.lookup(fName).get();\n+        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+            FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n+            MethodHandle mh = downcallHandle(ABI, addr, allocator, descriptor);\n+            Object[] args = makeArgs(ResourceScope.newImplicitScope(), ret, paramTypes, fields, returnChecks, argChecks);\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -75,0 +99,1 @@\n+<<<<<<< HEAD\n@@ -76,0 +101,3 @@\n+=======\n+            NativeSymbol callback = ABI.upcallStub(mh.asType(CLinker.upcallType(callbackDesc)), callbackDesc, scope);\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -96,0 +124,1 @@\n+<<<<<<< HEAD\n@@ -97,0 +126,3 @@\n+=======\n+                            LOOKUP.lookup(symbol).orElseThrow(),\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -104,0 +136,1 @@\n+<<<<<<< HEAD\n@@ -105,0 +138,3 @@\n+=======\n+            NativeSymbol invokerSymbol = LOOKUP.lookup(symbol).orElseThrow();\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n","filename":"test\/jdk\/java\/foreign\/TestUpcallAsync.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+<<<<<<< HEAD\n@@ -32,0 +33,10 @@\n+=======\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.SymbolLookup;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import jdk.incubator.foreign.ResourceScope;\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -48,0 +59,1 @@\n+<<<<<<< HEAD\n@@ -49,0 +61,4 @@\n+=======\n+    static CLinker ABI = CLinker.systemCLinker();\n+    static final SymbolLookup LOOKUP = SymbolLookup.loaderLookup();\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -63,0 +79,1 @@\n+<<<<<<< HEAD\n@@ -68,0 +85,7 @@\n+=======\n+    private static NativeSymbol DUMMY_STUB;\n+\n+    @BeforeClass\n+    void setup() {\n+        DUMMY_STUB = ABI.upcallStub(DUMMY, FunctionDescriptor.ofVoid(), ResourceScope.newImplicitScope());\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -83,0 +107,1 @@\n+<<<<<<< HEAD\n@@ -88,0 +113,7 @@\n+=======\n+    static Object[] makeArgs(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n+        return makeArgs(scope, ret, params, fields, checks, argChecks, List.of());\n+    }\n+\n+    static Object[] makeArgs(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) throws ReflectiveOperationException {\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -96,0 +128,1 @@\n+<<<<<<< HEAD\n@@ -101,0 +134,7 @@\n+=======\n+        args[argNum] = makeCallback(scope, ret, params, fields, checks, argChecks, prefix);\n+        return args;\n+    }\n+\n+    static NativeSymbol makeCallback(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -143,0 +183,1 @@\n+<<<<<<< HEAD\n@@ -144,0 +185,3 @@\n+=======\n+        return ABI.upcallStub(mh, func, scope);\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -150,0 +194,1 @@\n+<<<<<<< HEAD\n@@ -151,0 +196,3 @@\n+=======\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), ResourceScope.newImplicitScope());\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n","filename":"test\/jdk\/java\/foreign\/TestUpcallBase.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+<<<<<<< HEAD\n@@ -28,0 +29,4 @@\n+=======\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -35,0 +40,1 @@\n+<<<<<<< HEAD\n@@ -38,0 +44,5 @@\n+=======\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -55,0 +66,1 @@\n+<<<<<<< HEAD\n@@ -60,0 +72,7 @@\n+=======\n+        NativeSymbol addr = LOOKUP.lookup(fName).get();\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+            MethodHandle mh = downcallHandle(ABI, addr, allocator, function(ret, paramTypes, fields));\n+            Object[] args = makeArgs(scope, ret, paramTypes, fields, returnChecks, argChecks);\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n","filename":"test\/jdk\/java\/foreign\/TestUpcallScope.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+<<<<<<< HEAD\n@@ -28,0 +29,4 @@\n+=======\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -35,0 +40,1 @@\n+<<<<<<< HEAD\n@@ -39,0 +45,6 @@\n+=======\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -56,0 +68,1 @@\n+<<<<<<< HEAD\n@@ -61,0 +74,7 @@\n+=======\n+        NativeSymbol addr = LOOKUP.lookup(\"s\" + fName).get();\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+            MethodHandle mh = downcallHandle(ABI, addr, allocator, functionStack(ret, paramTypes, fields));\n+            Object[] args = makeArgsStack(scope, ret, paramTypes, fields, returnChecks, argChecks);\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -74,0 +94,1 @@\n+<<<<<<< HEAD\n@@ -76,0 +97,4 @@\n+=======\n+    static Object[] makeArgsStack(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n+        return makeArgs(scope, ret, params, fields, checks, argChecks, STACK_PREFIX_LAYOUTS);\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+<<<<<<< HEAD\n@@ -39,0 +40,7 @@\n+=======\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeSymbol;\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -47,0 +55,1 @@\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n@@ -64,2 +73,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -67,1 +76,3 @@\n-        checkArgumentBindings(callingSequence, new Binding[][]{});\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) }\n+        });\n@@ -86,2 +97,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -90,0 +101,1 @@\n+<<<<<<< HEAD\n@@ -100,0 +112,13 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(r2, int.class) },\n+            { vmStore(r3, int.class) },\n+            { vmStore(r4, int.class) },\n+            { vmStore(r5, int.class) },\n+            { vmStore(r6, int.class) },\n+            { vmStore(r7, int.class) },\n+            { vmStore(stackStorage(0), int.class) },\n+            { vmStore(stackStorage(1), int.class) },\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -115,2 +140,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -119,0 +144,1 @@\n+<<<<<<< HEAD\n@@ -123,0 +149,7 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(v0, float.class) },\n+            { vmStore(v1, float.class) },\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -136,2 +169,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -140,0 +173,1 @@\n+<<<<<<< HEAD\n@@ -141,0 +175,4 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n+            expectedBindings\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -195,2 +233,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -199,0 +237,1 @@\n+<<<<<<< HEAD\n@@ -210,0 +249,14 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n+            {\n+                copy(struct1),\n+                unboxAddress(MemorySegment.class),\n+                vmStore(r0, long.class)\n+            },\n+            {\n+                copy(struct2),\n+                unboxAddress(MemorySegment.class),\n+                vmStore(r1, long.class)\n+            },\n+            { vmStore(r2, int.class) }\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -225,2 +278,2 @@\n-        assertEquals(callingSequence.methodType(), MethodType.methodType(void.class, MemoryAddress.class));\n-        assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(C_POINTER));\n+        assertEquals(callingSequence.methodType(), MethodType.methodType(void.class, NativeSymbol.class, MemoryAddress.class));\n+        assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(ADDRESS, C_POINTER));\n@@ -229,0 +282,1 @@\n+<<<<<<< HEAD\n@@ -233,0 +287,7 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n+            {\n+                unboxAddress(),\n+                vmStore(r8, long.class)\n+            }\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -248,2 +309,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, MemorySegment.class, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS, ADDRESS));\n@@ -251,1 +312,4 @@\n-        checkArgumentBindings(callingSequence, new Binding[][]{});\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(MemorySegment.class), vmStore(r10, long.class) },\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) }\n+        });\n@@ -274,2 +338,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, MemorySegment.class, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS, ADDRESS));\n@@ -278,0 +342,1 @@\n+<<<<<<< HEAD\n@@ -287,0 +352,13 @@\n+=======\n+            { unboxAddress(MemorySegment.class), vmStore(r10, long.class) },\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n+            { vmStore(v0, float.class) },\n+            { vmStore(r0, int.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, float.class),\n+                vmStore(v1, float.class),\n+                bufferLoad(4, float.class),\n+                vmStore(v2, float.class)\n+            }\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -310,2 +388,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -314,0 +392,1 @@\n+<<<<<<< HEAD\n@@ -341,0 +420,30 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, float.class),\n+                vmStore(v0, float.class),\n+                dup(),\n+                bufferLoad(4, float.class),\n+                vmStore(v1, float.class),\n+                bufferLoad(8, float.class),\n+                vmStore(v2, float.class)\n+            },\n+            {\n+                dup(),\n+                bufferLoad(0, float.class),\n+                vmStore(v3, float.class),\n+                dup(),\n+                bufferLoad(4, float.class),\n+                vmStore(v4, float.class),\n+                bufferLoad(8, float.class),\n+                vmStore(v5, float.class)\n+            },\n+            {\n+                dup(),\n+                bufferLoad(0, long.class),\n+                vmStore(stackStorage(0), long.class),\n+                bufferLoad(8, int.class),\n+                vmStore(stackStorage(1), int.class),\n+            }\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -363,2 +472,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -367,0 +476,1 @@\n+<<<<<<< HEAD\n@@ -377,0 +487,13 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(r0, long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(r1, long.class) },\n+            { vmStore(r2, int.class) },\n+            { vmStore(r3, int.class) },\n+            { vmStore(r4, int.class) },\n+            { vmStore(r5, int.class) },\n+            { vmStore(r6, int.class) },\n+            { vmStore(r7, int.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(stackStorage(0), long.class) },\n+            { vmStore(stackStorage(1), int.class) },\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -386,0 +509,1 @@\n+        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_INT).asVariadic(C_INT, C_FLOAT);\n@@ -390,0 +514,1 @@\n+<<<<<<< HEAD\n@@ -398,0 +523,11 @@\n+=======\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fdExpected);\n+\n+        \/\/ This is identical to the non-variadic calling sequence\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(v0, float.class) },\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -407,0 +543,1 @@\n+        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_INT).asVariadic(C_INT, C_FLOAT);\n@@ -411,0 +548,1 @@\n+<<<<<<< HEAD\n@@ -419,0 +557,11 @@\n+=======\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fdExpected);\n+\n+        \/\/ The two variadic arguments should be allocated on the stack\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(stackStorage(0), int.class) },\n+            { vmStore(stackStorage(1), float.class) },\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":171,"deletions":22,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+<<<<<<< HEAD\n@@ -40,0 +41,7 @@\n+=======\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeSymbol;\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -48,0 +56,1 @@\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n@@ -65,2 +74,2 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));\n-        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));\n+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n@@ -69,0 +78,1 @@\n+<<<<<<< HEAD\n@@ -70,0 +80,4 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { vmStore(rax, long.class) }\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -92,2 +106,2 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));\n-        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));\n+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n@@ -96,0 +110,1 @@\n+<<<<<<< HEAD\n@@ -99,0 +114,6 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { dup(), bufferLoad(0, long.class), vmStore(rdi, long.class),\n+              bufferLoad(8, int.class), vmStore(rsi, int.class)},\n+            { vmStore(rax, long.class) },\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -122,2 +143,2 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));\n-        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));\n+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n@@ -126,3 +147,4 @@\n-                { dup(), bufferLoad(0, long.class), vmStore(rdi, long.class),\n-                        bufferLoad(8, long.class), vmStore(rsi, long.class)},\n-                { vmStore(rax, long.class) },\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { dup(), bufferLoad(0, long.class), vmStore(rdi, long.class),\n+                    bufferLoad(8, long.class), vmStore(rsi, long.class)},\n+            { vmStore(rax, long.class) },\n@@ -151,2 +173,2 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));\n-        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));\n+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n@@ -155,3 +177,4 @@\n-                { dup(), bufferLoad(0, long.class), vmStore(stackStorage(0), long.class),\n-                        bufferLoad(8, long.class), vmStore(stackStorage(1), long.class)},\n-                { vmStore(rax, long.class) },\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { dup(), bufferLoad(0, long.class), vmStore(stackStorage(0), long.class),\n+                    bufferLoad(8, long.class), vmStore(stackStorage(1), long.class)},\n+            { vmStore(rax, long.class) },\n@@ -180,2 +203,2 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));\n-        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));\n+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n@@ -184,3 +207,4 @@\n-                { dup(), bufferLoad(0, long.class), vmStore(stackStorage(0), long.class),\n-                        bufferLoad(8, int.class), vmStore(stackStorage(1), int.class)},\n-                { vmStore(rax, long.class) },\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { dup(), bufferLoad(0, long.class), vmStore(stackStorage(0), long.class),\n+                    bufferLoad(8, int.class), vmStore(stackStorage(1), int.class)},\n+            { vmStore(rax, long.class) },\n@@ -204,2 +228,2 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));\n-        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));\n+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n@@ -208,0 +232,1 @@\n+<<<<<<< HEAD\n@@ -215,0 +240,10 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { vmStore(rdi, int.class) },\n+            { vmStore(rsi, int.class) },\n+            { vmStore(rdx, int.class) },\n+            { vmStore(rcx, int.class) },\n+            { vmStore(r8, int.class) },\n+            { vmStore(r9, int.class) },\n+            { vmStore(rax, long.class) },\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -234,2 +269,2 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));\n-        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));\n+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n@@ -238,0 +273,1 @@\n+<<<<<<< HEAD\n@@ -247,0 +283,12 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { vmStore(xmm0, double.class) },\n+            { vmStore(xmm1, double.class) },\n+            { vmStore(xmm2, double.class) },\n+            { vmStore(xmm3, double.class) },\n+            { vmStore(xmm4, double.class) },\n+            { vmStore(xmm5, double.class) },\n+            { vmStore(xmm6, double.class) },\n+            { vmStore(xmm7, double.class) },\n+            { vmStore(rax, long.class) },\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -268,2 +316,2 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));\n-        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));\n+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n@@ -272,0 +320,1 @@\n+<<<<<<< HEAD\n@@ -291,0 +340,22 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { vmStore(rdi, long.class) },\n+            { vmStore(rsi, long.class) },\n+            { vmStore(rdx, long.class) },\n+            { vmStore(rcx, long.class) },\n+            { vmStore(r8, long.class) },\n+            { vmStore(r9, long.class) },\n+            { vmStore(stackStorage(0), long.class) },\n+            { vmStore(stackStorage(1), long.class) },\n+            { vmStore(xmm0, float.class) },\n+            { vmStore(xmm1, float.class) },\n+            { vmStore(xmm2, float.class) },\n+            { vmStore(xmm3, float.class) },\n+            { vmStore(xmm4, float.class) },\n+            { vmStore(xmm5, float.class) },\n+            { vmStore(xmm6, float.class) },\n+            { vmStore(xmm7, float.class) },\n+            { vmStore(stackStorage(2), float.class) },\n+            { vmStore(stackStorage(3), float.class) },\n+            { vmStore(rax, long.class) },\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -324,2 +395,2 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));\n-        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));\n+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n@@ -328,0 +399,1 @@\n+<<<<<<< HEAD\n@@ -343,0 +415,18 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { vmStore(rdi, int.class) },\n+            { vmStore(rsi, int.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, long.class), vmStore(rdx, long.class),\n+                bufferLoad(8, double.class), vmStore(xmm0, double.class)\n+            },\n+            { vmStore(rcx, int.class) },\n+            { vmStore(r8, int.class) },\n+            { vmStore(xmm1, double.class) },\n+            { vmStore(xmm2, double.class) },\n+            { vmStore(r9, int.class) },\n+            { vmStore(stackStorage(0), int.class) },\n+            { vmStore(stackStorage(1), int.class) },\n+            { vmStore(rax, long.class) },\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -366,2 +456,2 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));\n-        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));\n+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n@@ -370,0 +460,1 @@\n+<<<<<<< HEAD\n@@ -372,0 +463,5 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(rdi, long.class) },\n+            { vmStore(rax, long.class) },\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -387,2 +483,2 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));\n-        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));\n+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n@@ -391,0 +487,1 @@\n+<<<<<<< HEAD\n@@ -393,0 +490,5 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            expectedBindings,\n+            { vmStore(rax, long.class) },\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -445,2 +547,2 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));\n-        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));\n+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS, ADDRESS));\n@@ -449,0 +551,1 @@\n+<<<<<<< HEAD\n@@ -450,0 +553,5 @@\n+=======\n+            { unboxAddress(MemorySegment.class), vmStore(r11, long.class) },\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { vmStore(rax, long.class) }\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -475,2 +583,2 @@\n-        assertEquals(callingSequence.methodType(), MethodType.methodType(void.class, MemoryAddress.class, long.class));\n-        assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(C_POINTER, C_LONG));\n+        assertEquals(callingSequence.methodType(), MethodType.methodType(void.class, NativeSymbol.class, MemoryAddress.class, long.class));\n+        assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(ADDRESS, C_POINTER, C_LONG));\n@@ -479,0 +587,1 @@\n+<<<<<<< HEAD\n@@ -481,0 +590,5 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(rdi, long.class) },\n+            { vmStore(rax, long.class) }\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":149,"deletions":35,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+<<<<<<< HEAD\n@@ -40,0 +41,7 @@\n+=======\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeSymbol;\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -47,0 +55,1 @@\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n@@ -63,2 +72,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -66,1 +75,3 @@\n-        checkArgumentBindings(callingSequence, new Binding[][]{});\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) }\n+        });\n@@ -78,2 +89,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -82,0 +93,1 @@\n+<<<<<<< HEAD\n@@ -86,0 +98,7 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { vmStore(rcx, int.class) },\n+            { vmStore(rdx, int.class) },\n+            { vmStore(r8, int.class) },\n+            { vmStore(r9, int.class) }\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -99,2 +118,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -103,0 +122,1 @@\n+<<<<<<< HEAD\n@@ -107,0 +127,7 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { vmStore(xmm0, double.class) },\n+            { vmStore(xmm1, double.class) },\n+            { vmStore(xmm2, double.class) },\n+            { vmStore(xmm3, double.class) }\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -122,2 +149,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -126,0 +153,1 @@\n+<<<<<<< HEAD\n@@ -134,0 +162,11 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { vmStore(rcx, long.class) },\n+            { vmStore(rdx, long.class) },\n+            { vmStore(xmm2, float.class) },\n+            { vmStore(xmm3, float.class) },\n+            { vmStore(stackStorage(0), long.class) },\n+            { vmStore(stackStorage(1), long.class) },\n+            { vmStore(stackStorage(2), float.class) },\n+            { vmStore(stackStorage(3), float.class) }\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -152,2 +191,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -156,0 +195,1 @@\n+<<<<<<< HEAD\n@@ -171,0 +211,18 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { vmStore(rcx, int.class) },\n+            { vmStore(rdx, int.class) },\n+            {\n+                copy(structLayout),\n+                unboxAddress(MemorySegment.class),\n+                vmStore(r8, long.class)\n+            },\n+            { vmStore(r9, int.class) },\n+            { vmStore(stackStorage(0), int.class) },\n+            { vmStore(stackStorage(1), double.class) },\n+            { vmStore(stackStorage(2), double.class) },\n+            { vmStore(stackStorage(3), double.class) },\n+            { vmStore(stackStorage(4), int.class) },\n+            { vmStore(stackStorage(5), int.class) },\n+            { vmStore(stackStorage(6), int.class) }\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -182,0 +240,2 @@\n+        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(\n+                ADDRESS, C_INT, C_DOUBLE).asVariadic(C_INT, C_DOUBLE, C_DOUBLE);\n@@ -186,0 +246,1 @@\n+<<<<<<< HEAD\n@@ -195,0 +256,12 @@\n+=======\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fdExpected);\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { vmStore(rcx, int.class) },\n+            { vmStore(xmm1, double.class) },\n+            { vmStore(r8, int.class) },\n+            { dup(), vmStore(r9, double.class), vmStore(xmm3, double.class) },\n+            { vmStore(stackStorage(0), double.class) },\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -219,2 +292,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -223,0 +296,1 @@\n+<<<<<<< HEAD\n@@ -224,0 +298,4 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { bufferLoad(0, long.class), vmStore(rcx, long.class) }\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -248,2 +326,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -252,0 +330,1 @@\n+<<<<<<< HEAD\n@@ -257,0 +336,8 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            {\n+                copy(struct),\n+                unboxAddress(MemorySegment.class),\n+                vmStore(rcx, long.class)\n+            }\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -278,2 +365,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -282,0 +369,1 @@\n+<<<<<<< HEAD\n@@ -283,0 +371,4 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(rcx, long.class) }\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -298,2 +390,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -301,1 +393,3 @@\n-        checkArgumentBindings(callingSequence, new Binding[][]{});\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+        });\n@@ -320,2 +414,2 @@\n-        assertEquals(callingSequence.methodType(), MethodType.methodType(void.class, MemoryAddress.class));\n-        assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(C_POINTER));\n+        assertEquals(callingSequence.methodType(), MethodType.methodType(void.class, NativeSymbol.class, MemoryAddress.class));\n+        assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(ADDRESS, C_POINTER));\n@@ -324,0 +418,1 @@\n+<<<<<<< HEAD\n@@ -325,0 +420,4 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(rcx, long.class) }\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n@@ -348,2 +447,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -352,0 +451,1 @@\n+<<<<<<< HEAD\n@@ -368,0 +468,19 @@\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(rcx, long.class) },\n+            { vmStore(rdx, int.class) },\n+            { vmStore(xmm2, double.class) },\n+            { unboxAddress(), vmStore(r9, long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(stackStorage(0), long.class) },\n+            { vmStore(stackStorage(1), int.class) },\n+            { vmStore(stackStorage(2), double.class) },\n+            { unboxAddress(), vmStore(stackStorage(3), long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(stackStorage(4), long.class) },\n+            { vmStore(stackStorage(5), int.class) },\n+            { vmStore(stackStorage(6), double.class) },\n+            { unboxAddress(), vmStore(stackStorage(7), long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(stackStorage(8), long.class) },\n+            { vmStore(stackStorage(9), int.class) },\n+            { vmStore(stackStorage(10), double.class) },\n+            { unboxAddress(), vmStore(stackStorage(11), long.class) },\n+>>>>>>> b4e38e04a3aefec656763e4c5f6b3d0d14fb0d6c\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":143,"deletions":24,"binary":false,"changes":167,"status":"modified"}]}