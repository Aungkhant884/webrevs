{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.foreign.ValueLayout.OfAddress;\n@@ -260,0 +261,2 @@\n+     * @throws IllegalArgumentException if the layout path contains one or more dereference path elements\n+     * (see {@link PathElement#dereferenceElement()}).\n@@ -265,1 +268,1 @@\n-                EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE), elements);\n+                EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE, PathKind.DEREF_ELEMENT), elements);\n@@ -294,0 +297,2 @@\n+     * @throws IllegalArgumentException if the layout path contains one or more dereference path elements\n+     * (see {@link PathElement#dereferenceElement()}).\n@@ -297,1 +302,1 @@\n-                EnumSet.of(PathKind.SEQUENCE_RANGE), elements);\n+                EnumSet.of(PathKind.SEQUENCE_RANGE, PathKind.DEREF_ELEMENT), elements);\n@@ -309,0 +314,2 @@\n+     * @throws IllegalArgumentException if the layout path contains one or more dereference path elements\n+     * (see {@link PathElement#dereferenceElement()}).\n@@ -347,0 +354,2 @@\n+     * @throws IllegalArgumentException if the layout path contains one or more dereference path elements\n+     * (see {@link PathElement#dereferenceElement()}).\n@@ -380,0 +389,22 @@\n+     * <p>\n+     * Multiple paths can be chained, by using {@linkplain PathElement#dereferenceElement() dereference path elements}.\n+     * A dereference path element allows to obtain a native memory segment whose base address is the address obtained\n+     * by following the layout path elements immediately preceding the dereference path element. In other words,\n+     * if a layout path contains one or more dereference path elements, the final address accessed by the returned\n+     * var handle can be computed as follows:\n+     *\n+     * <blockquote><pre>{@code\n+     * address_1 = base(segment) + offset_1\n+     * address_2 = base(segment_1) + offset_2\n+     * ...\n+     * address_k = base(segment_k-1) + offset_k\n+     * }<\/pre><\/blockquote>\n+     *\n+     * where {@code k} is the number of dereference path elements in a layout path, {@code segment} is the input segment,\n+     * {@code segment_1}, ...  {@code segment_k-1} are the segments obtained by dereferencing the address associated with\n+     * a given dereference path element (e.g. {@code segment_1} is a native segment whose base address is {@code address_1}),\n+     * and {@code offset_1}, {@code offset_2}, ... {@code offset_k} are the offsets computed by evaluating\n+     * the path elements after a given dereference operation (these offsets are obtained using the computation described\n+     * above). In these more complex access operations, all memory accesses immediately preceding a dereference operation\n+     * (e.g. those at addresses {@code address_1}, {@code address_2}, ...,  {@code address_k-1} are performed using the\n+     * {@link VarHandle.AccessMode#GET} access mode.\n@@ -389,0 +420,2 @@\n+     * @throws IllegalArgumentException if the layout path in {@code elements} contains a {@linkplain PathElement#dereferenceElement()\n+     * dereference path element} for an address layout that has no {@linkplain OfAddress#targetLayout() target layout}.\n@@ -433,0 +466,2 @@\n+     * @throws IllegalArgumentException if the layout path contains one or more dereference path elements\n+     * (see {@link PathElement#dereferenceElement()}).\n@@ -447,0 +482,2 @@\n+     * @throws IllegalArgumentException if the layout path contains one or more dereference path elements\n+     * (see {@link PathElement#dereferenceElement()}).\n@@ -450,1 +487,1 @@\n-                EnumSet.of(PathKind.SEQUENCE_ELEMENT_INDEX, PathKind.SEQUENCE_RANGE), elements);\n+                EnumSet.of(PathKind.SEQUENCE_ELEMENT_INDEX, PathKind.SEQUENCE_RANGE, PathKind.DEREF_ELEMENT), elements);\n@@ -597,0 +634,15 @@\n+\n+        \/**\n+         * Returns a path element which dereferences an address layout as its\n+         * {@linkplain OfAddress#targetLayout() target layout} (where set).\n+         * The path element returned by this method does not alter the number of free dimensions of any path\n+         * that is combined with such element. Using this path layout to dereference an address layout\n+         * that has no target layout results in an {@link IllegalArgumentException} (e.g. when\n+         * a var handle is {@linkplain #varHandle(PathElement...) obtained}).\n+         *\n+         * @return a path element which dereferences an address layout.\n+         *\/\n+        static PathElement dereferenceElement() {\n+            return new LayoutPath.PathElementImpl(PathKind.DEREF_ELEMENT,\n+                    LayoutPath::derefElement);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":55,"deletions":3,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.foreign.SegmentScope;\n@@ -56,0 +57,1 @@\n+    private static final MethodHandle[] EMPTY_DEREF_HANDLES = new MethodHandle[0];\n@@ -59,0 +61,1 @@\n+    private static final MethodHandle MH_SEGMENT_RESIZE;\n@@ -67,0 +70,2 @@\n+            MH_SEGMENT_RESIZE = lookup.findStatic(LayoutPath.class, \"resizeSegment\",\n+                    MethodType.methodType(MemorySegment.class, MemorySegment.class, MemoryLayout.class));\n@@ -78,0 +83,1 @@\n+    private final MethodHandle[] derefAdapters;\n@@ -79,1 +85,1 @@\n-    private LayoutPath(MemoryLayout layout, long offset, long[] strides, long[] bounds, LayoutPath enclosing) {\n+    private LayoutPath(MemoryLayout layout, long offset, long[] strides, long[] bounds, MethodHandle[] derefAdapters, LayoutPath enclosing) {\n@@ -84,0 +90,1 @@\n+        this.derefAdapters = derefAdapters;\n@@ -93,1 +100,1 @@\n-        return LayoutPath.nestedPath(elem, offset, addStride(elem.bitSize()), addBound(seq.elementCount()), this);\n+        return LayoutPath.nestedPath(elem, offset, addStride(elem.bitSize()), addBound(seq.elementCount()), derefAdapters, this);\n@@ -107,1 +114,1 @@\n-                                     addStride(elemSize * step), addBound(maxIndex), this);\n+                                     addStride(elemSize * step), addBound(maxIndex), derefAdapters, this);\n@@ -116,1 +123,1 @@\n-        return LayoutPath.nestedPath(seq.elementLayout(), offset + elemOffset, strides, bounds, this);\n+        return LayoutPath.nestedPath(seq.elementLayout(), offset + elemOffset, strides, bounds, derefAdapters,this);\n@@ -137,1 +144,1 @@\n-        return LayoutPath.nestedPath(elem, this.offset + offset, strides, bounds, this);\n+        return LayoutPath.nestedPath(elem, this.offset + offset, strides, bounds, derefAdapters, this);\n@@ -155,1 +162,17 @@\n-        return LayoutPath.nestedPath(elem, this.offset + offset, strides, bounds, this);\n+        return LayoutPath.nestedPath(elem, this.offset + offset, strides, bounds, derefAdapters, this);\n+    }\n+\n+    public LayoutPath derefElement() {\n+        if (!(layout instanceof ValueLayout.OfAddress addressLayout) ||\n+                addressLayout.targetLayout().isEmpty()) {\n+            throw badLayoutPath(\"Cannot dereference layout: \" + layout);\n+        }\n+        MemoryLayout derefLayout = addressLayout.targetLayout().get();\n+        MethodHandle handle = dereferenceHandle(false).toMethodHandle(VarHandle.AccessMode.GET);\n+        handle = MethodHandles.filterReturnValue(handle,\n+                MethodHandles.insertArguments(MH_SEGMENT_RESIZE, 1, derefLayout));\n+        return derefPath(derefLayout, handle, this);\n+    }\n+\n+    private static MemorySegment resizeSegment(MemorySegment segment, MemoryLayout layout) {\n+        return Utils.longToAddress(segment.address(), layout.byteSize(), layout.byteAlignment());\n@@ -165,0 +188,4 @@\n+        return dereferenceHandle(true);\n+    }\n+\n+    public VarHandle dereferenceHandle(boolean adapt) {\n@@ -181,0 +208,6 @@\n+\n+        if (adapt) {\n+            for (int i = derefAdapters.length; i > 0; i--) {\n+                handle = MethodHandles.collectCoordinates(handle, 0, derefAdapters[i - 1]);\n+            }\n+        }\n@@ -225,1 +258,5 @@\n-        return new LayoutPath(layout, 0L, EMPTY_STRIDES, EMPTY_BOUNDS, null);\n+        return new LayoutPath(layout, 0L, EMPTY_STRIDES, EMPTY_BOUNDS, EMPTY_DEREF_HANDLES, null);\n+    }\n+\n+    private static LayoutPath nestedPath(MemoryLayout layout, long offset, long[] strides, long[] bounds, MethodHandle[] derefAdapters, LayoutPath encl) {\n+        return new LayoutPath(layout, offset, strides, bounds, derefAdapters, encl);\n@@ -228,2 +265,4 @@\n-    private static LayoutPath nestedPath(MemoryLayout layout, long offset, long[] strides, long[] bounds, LayoutPath encl) {\n-        return new LayoutPath(layout, offset, strides, bounds, encl);\n+    private static LayoutPath derefPath(MemoryLayout layout, MethodHandle handle, LayoutPath encl) {\n+        MethodHandle[] handles = Arrays.copyOf(encl.derefAdapters, encl.derefAdapters.length + 1);\n+        handles[encl.derefAdapters.length] = handle;\n+        return new LayoutPath(layout, 0L, EMPTY_STRIDES, EMPTY_BOUNDS, handles, null);\n@@ -292,1 +331,2 @@\n-            GROUP_ELEMENT(\"group element\");\n+            GROUP_ELEMENT(\"group element\"),\n+            DEREF_ELEMENT(\"dereference element\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":50,"deletions":10,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestDereferencePath\n+ *\/\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemoryLayout.PathElement;\n+import java.lang.foreign.MemorySegment;\n+\n+import java.lang.foreign.ValueLayout;\n+\n+import org.testng.annotations.*;\n+\n+import java.lang.invoke.VarHandle;\n+import static org.testng.Assert.*;\n+\n+public class TestDereferencePath {\n+\n+    static final MemoryLayout C = MemoryLayout.structLayout(\n+            ValueLayout.JAVA_INT.withName(\"x\")\n+    );\n+\n+    static final MemoryLayout B = MemoryLayout.structLayout(\n+            ValueLayout.ADDRESS.withName(\"c\")\n+                               .withTargetLayout(C)\n+    );\n+\n+    static final MemoryLayout A = MemoryLayout.structLayout(\n+            ValueLayout.ADDRESS.withName(\"b\")\n+                               .withTargetLayout(B)\n+    );\n+\n+    static final VarHandle abcx = A.varHandle(\n+            PathElement.groupElement(\"b\"), PathElement.dereferenceElement(),\n+            PathElement.groupElement(\"c\"), PathElement.dereferenceElement(),\n+            PathElement.groupElement(\"x\"));\n+\n+    @Test\n+    public void testSingle() {\n+        try (Arena arena = Arena.openConfined()) {\n+            \/\/ init structs\n+            MemorySegment a = arena.allocate(A);\n+            MemorySegment b = arena.allocate(B);\n+            MemorySegment c = arena.allocate(C);\n+            \/\/ init struct fields\n+            a.set(ValueLayout.ADDRESS, 0, b);\n+            b.set(ValueLayout.ADDRESS, 0, c);\n+            c.set(ValueLayout.JAVA_INT, 0, 42);\n+            \/\/ dereference\n+            int val = (int) abcx.get(a);\n+            assertEquals(val, 42);\n+        }\n+    }\n+\n+    static final MemoryLayout B_MULTI = MemoryLayout.structLayout(\n+            ValueLayout.ADDRESS.withName(\"cs\")\n+                    .withTargetLayout(MemoryLayout.sequenceLayout(2, C))\n+    );\n+\n+    static final MemoryLayout A_MULTI = MemoryLayout.structLayout(\n+            ValueLayout.ADDRESS.withName(\"bs\")\n+                    .withTargetLayout(MemoryLayout.sequenceLayout(2, B_MULTI))\n+    );\n+\n+    static final VarHandle abcx_multi = A_MULTI.varHandle(\n+            PathElement.groupElement(\"bs\"), PathElement.dereferenceElement(), PathElement.sequenceElement(),\n+            PathElement.groupElement(\"cs\"), PathElement.dereferenceElement(), PathElement.sequenceElement(),\n+            PathElement.groupElement(\"x\"));\n+\n+    @Test\n+    public void testMulti() {\n+        try (Arena arena = Arena.openConfined()) {\n+            \/\/ init structs\n+            MemorySegment a = arena.allocate(A);\n+            MemorySegment b = arena.allocateArray(B, 2);\n+            MemorySegment c = arena.allocateArray(C, 4);\n+            \/\/ init struct fields\n+            a.set(ValueLayout.ADDRESS, 0, b);\n+            b.set(ValueLayout.ADDRESS, 0, c);\n+            b.setAtIndex(ValueLayout.ADDRESS, 1, c.asSlice(C.byteSize() * 2));\n+            c.setAtIndex(ValueLayout.JAVA_INT, 0, 1);\n+            c.setAtIndex(ValueLayout.JAVA_INT, 1, 2);\n+            c.setAtIndex(ValueLayout.JAVA_INT, 2, 3);\n+            c.setAtIndex(ValueLayout.JAVA_INT, 3, 4);\n+            \/\/ dereference\n+            int val00 = (int) abcx_multi.get(a, 0, 0); \/\/ a->b[0]->c[0] = 1\n+            assertEquals(val00, 1);\n+            int val10 = (int) abcx_multi.get(a, 1, 0); \/\/ a->b[1]->c[0] = 3\n+            assertEquals(val10, 3);\n+            int val01 = (int) abcx_multi.get(a, 0, 1); \/\/ a->b[0]->c[1] = 2\n+            assertEquals(val01, 2);\n+            int val11 = (int) abcx_multi.get(a, 1, 1); \/\/ a->b[1]->c[1] = 4\n+            assertEquals(val11, 4);\n+        }\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    void testBadDerefInSelect() {\n+        A.select(PathElement.groupElement(\"b\"), PathElement.dereferenceElement());\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    void testBadDerefInOffset() {\n+        A.byteOffset(PathElement.groupElement(\"b\"), PathElement.dereferenceElement());\n+    }\n+\n+    static final MemoryLayout A_MULTI_NO_TARGET = MemoryLayout.structLayout(\n+            ValueLayout.ADDRESS.withName(\"bs\")\n+    );\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    void badDerefAddressNoTarget() {\n+        A_MULTI_NO_TARGET.varHandle(PathElement.groupElement(\"bs\"), PathElement.dereferenceElement());\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestDereferencePath.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"}]}