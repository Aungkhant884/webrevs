{"files":[{"patch":"@@ -212,1 +212,1 @@\n-    MemoryAddress NULL = new MemoryAddressImpl(null,  0L);\n+    MemoryAddress NULL = new MemoryAddressImpl.UncheckedAddress(0L);\n@@ -222,1 +222,1 @@\n-                new MemoryAddressImpl(null, value);\n+                new MemoryAddressImpl.UncheckedAddress(value);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -148,3 +148,4 @@\n-     * The base memory address associated with this memory segment. The returned address is\n-     * a <em>checked<\/em> memory address and can therefore be used in dereference operations\n-     * (see {@link MemoryAddress}).\n+     * The base memory address associated with this memory segment.\n+     * The returned memory address contains a strong reference to this segment; this means that if this segment\n+     * is associated with a resource scope featuring <a href=\"ResourceScope.html#implicit-closure\"><em>implicit closure<\/em><\/a>,\n+     * the scope won't be closed as long as the returned address is <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">reachable<\/a>.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n- * <h2>Implicit closure<\/h2>\n+ * <h2><a id = \"implicit-closure\">Implicit closure<\/a><\/h2>\n@@ -256,1 +256,2 @@\n-     * Create a new <em>default scope<\/em>, a shared, non-closeable scope which only features implicit closure.\n+     * Create a new <em>default scope<\/em>, a shared, non-closeable scope which only features\n+     * <a href=\"ResourceScope.html#implicit-closure\"><em>implicit closure<\/em><\/a>.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ResourceScope.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -227,1 +227,1 @@\n-        return new MemoryAddressImpl(base(), min());\n+        return new MemoryAddressImpl.SegmentAddress(this, 0L);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-public final class MemoryAddressImpl implements MemoryAddress {\n+public abstract class MemoryAddressImpl implements MemoryAddress {\n@@ -40,7 +40,2 @@\n-    private final Object base;\n-    private final long offset;\n-\n-    public MemoryAddressImpl(Object base, long offset) {\n-        this.base = base;\n-        this.offset = offset;\n-    }\n+    abstract Object base();\n+    abstract long offset();\n@@ -54,1 +49,1 @@\n-        if (segmentImpl.base() != base) {\n+        if (segmentImpl.base() != base()) {\n@@ -57,1 +52,1 @@\n-        return offset - segmentImpl.min();\n+        return offset() - segmentImpl.min();\n@@ -62,1 +57,1 @@\n-        if (base != null) {\n+        if (base() != null) {\n@@ -65,6 +60,1 @@\n-        return offset;\n-    }\n-\n-    @Override\n-    public MemoryAddress addOffset(long bytes) {\n-        return new MemoryAddressImpl(base, offset + bytes);\n+        return offset();\n@@ -77,1 +67,1 @@\n-        return Objects.hash(base, offset);\n+        return Objects.hash(base(), offset());\n@@ -84,2 +74,2 @@\n-            return Objects.equals(base, addr.base) &&\n-                    offset == addr.offset;\n+            return Objects.equals(base(), addr.base()) &&\n+                    offset() == addr.offset();\n@@ -93,1 +83,1 @@\n-        return \"MemoryAddress{ base: \" + base + \" offset=0x\" + Long.toHexString(offset) + \" }\";\n+        return \"MemoryAddress{ base: \" + base() + \" offset=0x\" + Long.toHexString(offset()) + \" }\";\n@@ -119,0 +109,55 @@\n+\n+    \/**\n+     * A memory address that wraps a raw address.\n+     *\/\n+    public static final class UncheckedAddress extends MemoryAddressImpl {\n+        final long addr;\n+\n+        public UncheckedAddress(long addr) {\n+            this.addr = addr;\n+        }\n+\n+        @Override\n+        public MemoryAddress addOffset(long offset) {\n+            return new UncheckedAddress(addr + offset);\n+        }\n+\n+        @Override\n+        Object base() {\n+            return null;\n+        }\n+\n+        @Override\n+        long offset() {\n+            return addr;\n+        }\n+    }\n+\n+    \/**\n+     * A memory address expressed as an offset into a segment. Crucially, this keeps the segment reachable,\n+     * which is useful when segments are passed to native functions \"by reference\".\n+     *\/\n+    public static final class SegmentAddress extends MemoryAddressImpl {\n+        final AbstractMemorySegmentImpl segment;\n+        final long offset;\n+\n+        public SegmentAddress(AbstractMemorySegmentImpl segment, long offset) {\n+            this.segment = segment;\n+            this.offset = offset;\n+        }\n+\n+        @Override\n+        public MemoryAddress addOffset(long offset) {\n+            return new SegmentAddress(segment, this.offset + offset);\n+        }\n+\n+        @Override\n+        Object base() {\n+            return segment.base();\n+        }\n+\n+        @Override\n+        long offset() {\n+            return segment.min() + offset;\n+        }\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":66,"deletions":21,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.lang.ref.Reference;\n@@ -251,5 +252,1 @@\n-        if (bufferCopySize > 0) {\n-            specializedHandle = SharedUtils.wrapWithAllocator(specializedHandle, argContextPos, bufferCopySize, false);\n-        } else {\n-            specializedHandle = insertArguments(specializedHandle, argContextPos, Binding.Context.DUMMY);\n-        }\n+        specializedHandle = SharedUtils.wrapWithAllocator(specializedHandle, argContextPos, bufferCopySize, false);\n@@ -339,0 +336,4 @@\n+            \/\/ make sure arguments are reachable during the call\n+            \/\/ technically we only need to do all Addressable parameters here\n+            Reference.reachabilityFence(address);\n+            Reference.reachabilityFence(args);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import java.lang.ref.Reference;\n@@ -80,0 +81,1 @@\n+    private static final MethodHandle MH_REACHBILITY_FENCE;\n@@ -96,0 +98,2 @@\n+            MH_REACHBILITY_FENCE = lookup.findStatic(Reference.class, \"reachabilityFence\",\n+                    methodType(void.class, Object.class));\n@@ -356,0 +360,4 @@\n+    private static MethodHandle reachabilityFenceHandle(Class<?> type) {\n+        return MH_REACHBILITY_FENCE.asType(MethodType.methodType(void.class, type));\n+    }\n+\n@@ -373,2 +381,2 @@\n-            closer = dropArguments(closer, insertPos, Addressable.class, SegmentAllocator.class); \/\/ (Throwable, V?, Addressable, SegmentAllocator) -> V\/void\n-            insertPos+=2;\n+            closer = collectArguments(closer, insertPos++, reachabilityFenceHandle(Addressable.class));\n+            closer = dropArguments(closer, insertPos++, SegmentAllocator.class); \/\/ (Throwable, V?, Addressable, SegmentAllocator) -> V\/void\n@@ -377,1 +385,15 @@\n-        closer = collectArguments(closer, insertPos, MH_CLOSE_CONTEXT); \/\/ (Throwable, V?, Addressable?, BindingContext) -> V\/void\n+        closer = collectArguments(closer, insertPos++, MH_CLOSE_CONTEXT); \/\/ (Throwable, V?, Addressable?, BindingContext) -> V\/void\n+\n+        if (!upcall) {\n+            \/\/ now for each Addressable parameter, add a reachability fence\n+            MethodType specType = specializedHandle.type();\n+            \/\/ skip 3 for address, segment allocator, and binding context\n+            for (int i = 3; i < specType.parameterCount(); i++) {\n+                Class<?> param = specType.parameterType(i);\n+                if (Addressable.class.isAssignableFrom(param)) {\n+                    closer = collectArguments(closer, insertPos++, reachabilityFenceHandle(param));\n+                } else {\n+                    closer = dropArguments(closer, insertPos++, param);\n+                }\n+            }\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -50,2 +50,0 @@\n-    static int functions = 0;\n-\n@@ -185,0 +183,1 @@\n+        int functions = 0;\n@@ -196,0 +195,1 @@\n+                                int count = functions;\n@@ -198,1 +198,1 @@\n-                                downcalls.add(new Object[] { fName, r, ptypes, fields });\n+                                downcalls.add(new Object[] { count, fName, r, ptypes, fields });\n@@ -203,0 +203,1 @@\n+                        int count = functions;\n@@ -205,1 +206,1 @@\n-                        downcalls.add(new Object[] { fName, r, ptypes, List.of() });\n+                        downcalls.add(new Object[] { count, fName, r, ptypes, List.of() });\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-\n@@ -59,1 +58,1 @@\n-    public void testDowncall(String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+    public void testDowncall(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n@@ -85,0 +84,26 @@\n+    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n+    public void testDowncallNoScope(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+        List<Consumer<Object>> checks = new ArrayList<>();\n+        LibraryLookup.Symbol addr = lib.lookup(fName).get();\n+        MethodType mt = methodType(ret, paramTypes, fields);\n+        FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n+        Object[] args = makeArgs(paramTypes, fields, checks);\n+        boolean needsScope = mt.returnType().equals(MemorySegment.class);\n+        if (count % 100 == 0) {\n+            System.gc();\n+        }\n+        Object res = doCall(addr, SegmentAllocator.ofDefault(), mt, descriptor, args);\n+        if (ret == Ret.NON_VOID) {\n+            checks.forEach(c -> c.accept(res));\n+            if (needsScope) {\n+                \/\/ check that return struct has indeed been allocated in the default scope\n+                try {\n+                    ((MemorySegment)res).scope().close(); \/\/ should throw\n+                    fail(\"Expected exception!\");\n+                } catch (UnsupportedOperationException ex) {\n+                    \/\/ ok\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -86,1 +88,1 @@\n-    public void testUpcalls(String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+    public void testUpcalls(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n@@ -93,1 +95,1 @@\n-            Object[] args = makeArgs(scope, ret, paramTypes, fields, returnChecks, argChecks);\n+            Object[] args = makeArgs(scope.scope(), ret, paramTypes, fields, returnChecks, argChecks);\n@@ -103,0 +105,19 @@\n+    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n+    public void testUpcallsNoScope(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+        List<Consumer<Object>> returnChecks = new ArrayList<>();\n+        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n+        LibraryLookup.Symbol addr = lib.lookup(fName).get();\n+        MethodType mtype = methodType(ret, paramTypes, fields);\n+        MethodHandle mh = abi.downcallHandle(addr, SegmentAllocator.ofDefault(), mtype, function(ret, paramTypes, fields));\n+        Object[] args = makeArgs(ResourceScope.ofDefault(), ret, paramTypes, fields, returnChecks, argChecks);\n+        Object[] callArgs = args;\n+        if (count % 100 == 0) {\n+            System.gc();\n+        }\n+        Object res = mh.invokeWithArguments(callArgs);\n+        argChecks.forEach(c -> c.accept(args));\n+        if (ret == Ret.NON_VOID) {\n+            returnChecks.forEach(c -> c.accept(res));\n+        }\n+    }\n+\n@@ -122,1 +143,1 @@\n-    static Object[] makeArgs(NativeScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n+    static Object[] makeArgs(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n@@ -132,1 +153,1 @@\n-    static MemoryAddress makeCallback(NativeScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) {\n+    static MemoryAddress makeCallback(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) {\n@@ -171,1 +192,1 @@\n-        MemorySegment stub = abi.upcallStub(mh, func, scope.scope());\n+        MemorySegment stub = abi.upcallStub(mh, func, scope);\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"}]}