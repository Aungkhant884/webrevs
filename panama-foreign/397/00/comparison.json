{"files":[{"patch":"@@ -174,0 +174,2 @@\n+        Objects.requireNonNull(carrier);\n+        Objects.requireNonNull(byteOrder);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryHandles.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -628,0 +628,1 @@\n+        Objects.requireNonNull(order);\n@@ -629,1 +630,1 @@\n-        return new ValueLayout(Objects.requireNonNull(order), size);\n+        return new ValueLayout(order, size);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayout.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -156,15 +156,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadFilterNullTarget() {\n-        MemoryHandles.filterValue(null, S2I, I2S);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadFilterNullUnbox() {\n-        MemoryHandles.filterValue(intHandle, null, I2S);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadFilterNullBox() {\n-        MemoryHandles.filterValue(intHandle, S2I, null);\n-    }\n-\n@@ -238,10 +223,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadFilterCoordinatesNullTarget() {\n-        MemoryHandles.filterCoordinates(null, 0, S2I);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadFilterCoordinatesNullFilters() {\n-        MemoryHandles.filterCoordinates(intHandle, 0, null);\n-    }\n-\n@@ -291,10 +266,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadInsertCoordinatesNullTarget() {\n-        MemoryHandles.insertCoordinates(null, 0, 42);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadInsertCoordinatesNullValues() {\n-        MemoryHandles.insertCoordinates(intHandle, 0, null);\n-    }\n-\n@@ -340,15 +305,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadPermuteCoordinatesNullTarget() {\n-        MemoryHandles.permuteCoordinates(null, List.of());\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadPermuteCoordinatesNullCoordinates() {\n-        MemoryHandles.permuteCoordinates(intHandle, null);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadPermuteCoordinatesNullReorder() {\n-        MemoryHandles.permuteCoordinates(intHandle, List.of(int.class), null);\n-    }\n-\n@@ -393,10 +343,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadCollectCoordinatesNullTarget() {\n-        MemoryHandles.collectCoordinates(null, 0, SUM_OFFSETS);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadCollectCoordinatesNullFilters() {\n-        MemoryHandles.collectCoordinates(intHandle, 0, null);\n-    }\n-\n@@ -456,10 +396,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadDropCoordinatesNullValueTypes() {\n-        MemoryHandles.dropCoordinates(intHandle, 1, null);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadDropCoordinatesNullTarget() {\n-        MemoryHandles.dropCoordinates(null, 1);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -88,5 +88,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadAdaptNull() {\n-        MemoryHandles.asAddressVarHandle(null);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestAddressHandle.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -126,6 +126,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullCleaner() {\n-        MemorySegment segment = MemorySegment.ofArray(new byte[10]);\n-        segment.registerCleaner(null);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestCleaner.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -82,15 +82,0 @@\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testWithNameNull() {\n-        MemoryLayouts.BITS_8_BE.withName(null);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testFetchAttributeNull() {\n-        MemoryLayouts.BITS_8_BE.attribute(null);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testPutAttributeNull() {\n-        MemoryLayouts.BITS_8_BE.withAttribute(null, \"Hello\");\n-    }\n","filename":"test\/jdk\/java\/foreign\/TestLayoutAttributes.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -226,100 +226,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testValueLayoutNullOrder() {\n-        MemoryLayout.ofValueBits(10, null);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testValueLayoutWithNullOrder() {\n-        MemoryLayout.ofValueBits(10, ByteOrder.BIG_ENDIAN).withOrder(null);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testUnboundSequenceLayoutNullElement() {\n-        MemoryLayout.ofSequence(null);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBoundSequenceLayoutNullElement() {\n-        MemoryLayout.ofSequence(10, null);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testStructNullElements() {\n-        MemoryLayout.ofStruct(null);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testUnionNullElements() {\n-        MemoryLayout.ofUnion(null);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testStructWithNullElement() {\n-        MemoryLayout.ofStruct(new MemoryLayout[] { null });\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testUnionWithNullElement() {\n-        MemoryLayout.ofUnion(new MemoryLayout[] { null });\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testMapWithNullPathElement() {\n-        MemoryLayouts.BITS_8_BE.map(UnaryOperator.identity(), new MemoryLayout.PathElement[] { null });\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testMapWithNullElements() {\n-        MemoryLayouts.BITS_8_BE.map(UnaryOperator.identity(), null);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testMapWithNullOp() {\n-        MemoryLayouts.BITS_8_BE.map(null);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBitOffsetWithNullPathElement() {\n-        MemoryLayouts.BITS_8_BE.bitOffset(new MemoryLayout.PathElement[] { null });\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBitOffsetWithNullElements() {\n-        MemoryLayouts.BITS_8_BE.bitOffset(null);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testByteOffsetWithNullPathElement() {\n-        MemoryLayouts.BITS_8_BE.byteOffset(new MemoryLayout.PathElement[] { null });\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testByteOffsetWithNullElements() {\n-        MemoryLayouts.BITS_8_BE.byteOffset(null);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testSelectWithNullPathElement() {\n-        MemoryLayouts.BITS_8_BE.select(new MemoryLayout.PathElement[] { null });\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testSelectWithNullElements() {\n-        MemoryLayouts.BITS_8_BE.select(null);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testHandleWithNullPathElement() {\n-        MemoryLayouts.BITS_8_BE.varHandle(int.class, new MemoryLayout.PathElement[] { null });\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testhandleWithNullElements() {\n-        MemoryLayouts.BITS_8_BE.varHandle(null);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testHandleWithNullCarrier() {\n-        MemoryLayouts.BITS_8_BE.varHandle(null);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":0,"deletions":100,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -100,41 +100,0 @@\n-    @Test\n-    public void testNulls() {\n-        for (Method m : MemoryAccess.class.getMethods()) {\n-            if ((m.getModifiers() & Modifier.STATIC) == 0) continue;\n-            Object[] args = new Object[m.getParameterCount()];\n-            for (int i = 0 ; i < args.length ; i++) {\n-                args[i] = defaultValue(m.getParameterTypes()[i]);\n-            }\n-            try {\n-                m.invoke(null, args);\n-                fail();\n-            } catch (InvocationTargetException ex) {\n-                assertEquals(ex.getCause().getClass(), NullPointerException.class);\n-                assertTrue(ex.getCause().getStackTrace()[1].getClassName().contains(\"MemoryAccess\"));\n-            } catch (Throwable ex) {\n-                fail();\n-            }\n-        }\n-    }\n-\n-    static Object defaultValue(Class<?> carrier) {\n-        if (carrier == char.class) {\n-            return (char)0;\n-        } else if (carrier == byte.class) {\n-            return (byte)0;\n-        } else if (carrier == short.class) {\n-            return (short)0;\n-        } else if (carrier == int.class) {\n-            return 0;\n-        } else if (carrier == long.class) {\n-            return 0L;\n-        } else if (carrier == float.class) {\n-            return 0f;\n-        } else if (carrier == double.class) {\n-            return 0d;\n-        } else {\n-            \/\/ reference type!\n-            return null;\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessStatics.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -64,6 +64,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNull() {\n-        var segment = MemorySegment.ofArray(new byte[4]);\n-        segment.copyFrom(null);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestMemoryCopy.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -172,6 +172,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNull() {\n-        var segment = MemorySegment.ofArray(new byte[4]);\n-        segment.mismatch(null);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.ref\n+ *          jdk.incubator.foreign\n+ * @run testng\/othervm -Dforeign.restricted=permit TestNulls\n+ *\/\n+\n+import jdk.incubator.foreign.*;\n+import jdk.internal.ref.CleanerFactory;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.NoInjection;\n+import org.testng.annotations.Test;\n+\n+import java.lang.constant.Constable;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.ref.Cleaner;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.testng.Assert.*;\n+import static org.testng.Assert.fail;\n+\n+\/**\n+ * This test makes sure that public API classes (listed in {@link TestNulls#CLASSES}) throws NPEs whenever\n+ * nulls are provided. The test looks at all the public methods in all the listed classes, and injects\n+ * values automatically. If an API takes a reference, the test will try to inject nulls. For APIs taking\n+ * either reference arrays, or collections, the framework will also generate additional <em>replacements<\/em>\n+ * (e.g. other than just replacing the array, or collection with null), such as an array or collection\n+ * with null elements. The test can be customized by adding\/removing classes to the {@link #CLASSES} array,\n+ * by adding\/removing default mappings for standard carrier types (see {@link #DEFAULT_VALUES} or by\n+ * adding\/removing custom replacements (see {@link #REPLACEMENT_VALUES}).\n+ *\/\n+public class TestNulls {\n+\n+    static final Class<?>[] CLASSES = new Class<?>[] {\n+            MemorySegment.class,\n+            MemoryAddress.class,\n+            MemoryLayout.class,\n+            MemoryLayout.PathElement.class,\n+            SequenceLayout.class,\n+            ValueLayout.class,\n+            GroupLayout.class,\n+            Addressable.class,\n+            MemoryAccess.class,\n+            MappedMemorySegments.class,\n+            MemoryLayouts.class,\n+            MemoryHandles.class\n+    };\n+\n+    static final Set<String> EXCLUDE_LIST = Set.of(\n+            \"jdk.incubator.foreign.MemoryLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.MemoryAddress\/asSegmentRestricted(long,java.lang.Runnable,java.lang.Object)\/1\/0\",\n+            \"jdk.incubator.foreign.MemoryAddress\/asSegmentRestricted(long,java.lang.Runnable,java.lang.Object)\/2\/0\",\n+            \"jdk.incubator.foreign.SequenceLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.GroupLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.MemoryHandles\/insertCoordinates(java.lang.invoke.VarHandle,int,java.lang.Object[])\/2\/1\"\n+    );\n+\n+    static final Set<String> OBJECT_METHODS = Stream.of(Object.class.getMethods())\n+            .map(Method::getName)\n+            .collect(Collectors.toSet());\n+\n+    static final Map<Class<?>, Object> DEFAULT_VALUES = new HashMap<>();\n+\n+    static <Z> void addDefaultMapping(Class<Z> carrier, Z value) {\n+        DEFAULT_VALUES.put(carrier, value);\n+    }\n+\n+    static {\n+        addDefaultMapping(char.class, (char)0);\n+        addDefaultMapping(byte.class, (byte)0);\n+        addDefaultMapping(short.class, (short)0);\n+        addDefaultMapping(int.class, 0);\n+        addDefaultMapping(float.class, 0f);\n+        addDefaultMapping(long.class, 0L);\n+        addDefaultMapping(double.class, 0d);\n+        addDefaultMapping(ByteOrder.class, ByteOrder.nativeOrder());\n+        addDefaultMapping(Thread.class, Thread.currentThread());\n+        addDefaultMapping(Cleaner.class, CleanerFactory.cleaner());\n+        addDefaultMapping(ByteBuffer.class, ByteBuffer.wrap(new byte[10]));\n+        addDefaultMapping(Path.class, Path.of(\"nonExistent\"));\n+        addDefaultMapping(FileChannel.MapMode.class, FileChannel.MapMode.PRIVATE);\n+        addDefaultMapping(UnaryOperator.class, UnaryOperator.identity());\n+        addDefaultMapping(String.class, \"Hello!\");\n+        addDefaultMapping(Constable.class, \"Hello!\");\n+        addDefaultMapping(Class.class, String.class);\n+        addDefaultMapping(Runnable.class, () -> {});\n+        addDefaultMapping(Object.class, new Object());\n+        addDefaultMapping(VarHandle.class, MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()));\n+        addDefaultMapping(MethodHandle.class, MethodHandles.identity(int.class));\n+        addDefaultMapping(List.class, List.of());\n+        addDefaultMapping(MemoryAddress.class, MemoryAddress.NULL);\n+        addDefaultMapping(Addressable.class, MemoryAddress.NULL);\n+        addDefaultMapping(MemoryLayout.class, MemoryLayouts.JAVA_INT);\n+        addDefaultMapping(ValueLayout.class, MemoryLayouts.JAVA_INT);\n+        addDefaultMapping(GroupLayout.class, MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT));\n+        addDefaultMapping(SequenceLayout.class, MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT));\n+        addDefaultMapping(MemorySegment.class, MemorySegment.ofArray(new byte[10]));\n+    }\n+\n+    static final Map<Class<?>, Object[]> REPLACEMENT_VALUES = new HashMap<>();\n+\n+    @SafeVarargs\n+    static <Z> void addReplacements(Class<Z> carrier, Z... value) {\n+        REPLACEMENT_VALUES.put(carrier, value);\n+    }\n+\n+    static {\n+        addReplacements(Collection.class, null, Stream.of(new Object[] { null }).collect(Collectors.toList()));\n+        addReplacements(List.class, null, Stream.of(new Object[] { null }).collect(Collectors.toList()));\n+        addReplacements(Set.class, null, Stream.of(new Object[] { null }).collect(Collectors.toSet()));\n+    }\n+\n+    @Test(dataProvider = \"cases\")\n+    public void testNulls(String testName, @NoInjection Method meth, Object receiver, Object[] args) {\n+        try {\n+            meth.invoke(receiver, args);\n+            fail(\"Method invocation completed normally\");\n+        } catch (InvocationTargetException ex) {\n+            Class<?> cause = ex.getCause().getClass();\n+            assertEquals(cause, NullPointerException.class, \"got \" + cause.getName() + \" - expected NullPointerException\");\n+        } catch (Throwable ex) {\n+            fail(\"Unexpected exception: \" + ex);\n+        }\n+    }\n+\n+    @DataProvider(name = \"cases\")\n+    static Iterator<Object[]> cases() {\n+        List<Object[]> cases = new ArrayList<>();\n+        for (Class<?> clazz : CLASSES) {\n+            for (Method m : clazz.getMethods()) {\n+                if (OBJECT_METHODS.contains(m.getName())) continue;\n+                boolean isStatic = (m.getModifiers() & Modifier.STATIC) != 0;\n+                List<Integer> refIndices = new ArrayList<>();\n+                for (int i = 0; i < m.getParameterCount(); i++) {\n+                    Class<?> param = m.getParameterTypes()[i];\n+                    if (!param.isPrimitive()) {\n+                        refIndices.add(i);\n+                    }\n+                }\n+                for (int i : refIndices) {\n+                    Object[] replacements = replacements(m.getParameterTypes()[i]);\n+                    for (int r = 0 ; r < replacements.length ; r++) {\n+                        String testName = clazz.getName() + \"\/\" + shortSig(m) + \"\/\" + i + \"\/\" + r;\n+                        if (EXCLUDE_LIST.contains(testName)) continue;\n+                        Object[] args = new Object[m.getParameterCount()];\n+                        for (int j = 0; j < args.length; j++) {\n+                            args[j] = defaultValue(m.getParameterTypes()[j]);\n+                        }\n+                        args[i] = replacements[r];\n+                        Object receiver = isStatic ? null : defaultValue(clazz);\n+                        cases.add(new Object[]{testName, m, receiver, args});\n+                    }\n+                }\n+            }\n+        }\n+        return cases.iterator();\n+    };\n+\n+    static String shortSig(Method m) {\n+        StringJoiner sj = new StringJoiner(\",\", m.getName() + \"(\", \")\");\n+        for (Class<?> parameterType : m.getParameterTypes()) {\n+            sj.add(parameterType.getTypeName());\n+        }\n+        return sj.toString();\n+    }\n+\n+    static Object defaultValue(Class<?> carrier) {\n+        if (carrier.isArray()) {\n+            return Array.newInstance(carrier.componentType(), 0);\n+        }\n+        Object value = DEFAULT_VALUES.get(carrier);\n+        if (value == null) {\n+            throw new UnsupportedOperationException(carrier.getName());\n+        }\n+        return value;\n+    }\n+\n+    static Object[] replacements(Class<?> carrier) {\n+        if (carrier.isArray() && !carrier.getComponentType().isPrimitive()) {\n+            Object arr = Array.newInstance(carrier.componentType(), 1);\n+            Array.set(arr, 0, null);\n+            return new Object[] { null, arr };\n+        }\n+        return REPLACEMENT_VALUES.getOrDefault(carrier, new Object[] { null });\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -280,53 +280,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullAllocateNative() {\n-        MemorySegment.allocateNative(null);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullAllocateBuffer() {\n-        MemorySegment.ofByteBuffer(null);\n-    }\n-\n-    @Test\n-    public void testNullAllocateArray() {\n-        for (Method m : MemorySegment.class.getMethods()) {\n-            if (((m.getModifiers() & Modifier.STATIC) == 0) ||\n-                    !m.getName().startsWith(\"ofArray\")) continue;\n-            try {\n-                m.invoke(null, new Object[] { null });\n-                fail();\n-            } catch (InvocationTargetException ex) {\n-                assertEquals(ex.getCause().getClass(), NullPointerException.class);\n-            } catch (Throwable ex) {\n-                fail();\n-            }\n-        }\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testMapNullPath() throws IOException {\n-        MemorySegment.mapFile(null, 0, 10, FileChannel.MapMode.PRIVATE);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testMapNullMapMode() throws IOException  {\n-        File f = File.createTempFile(\"hello\", \"txt\");\n-        f.deleteOnExit();\n-        MemorySegment.mapFile(f.toPath(), 0, 10, null);\n-    }\n-\n-    @Test\n-    public void testMappedSegmentsOpsNullArgs() {\n-        for (Method m : MappedMemorySegments.class.getMethods()) {\n-            if ((m.getModifiers() & Modifier.STATIC) == 0) continue;\n-            try {\n-                m.invoke(null, new Object[] { null });\n-                fail();\n-            } catch (InvocationTargetException ex) {\n-                assertEquals(ex.getCause().getClass(), NullPointerException.class);\n-            } catch (Throwable ex) {\n-                fail();\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -231,5 +231,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullSpliteratoorLayout() {\n-        MemorySegment.ofArray(new byte[10]).spliterator(null);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -124,20 +124,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testVarHandleNullCarrierNoAlign() {\n-        MemoryHandles.varHandle(null, ByteOrder.nativeOrder());\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testVarHandleNullCarrierAlign() {\n-        MemoryHandles.varHandle(null, 8, ByteOrder.nativeOrder());\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testVarHandleNullOrderNoAlign() {\n-        MemoryHandles.varHandle(int.class, null);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testVarHandleNullOrderAlign() {\n-        MemoryHandles.varHandle(int.class, 8, null);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"}]}