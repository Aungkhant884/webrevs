{"files":[{"patch":"@@ -3,1 +3,1 @@\n-**September 2021**\n+**January 2022**\n@@ -7,1 +7,1 @@\n-Panama support foreign functions through the Foreign Memory Access API, which has been available as an [incubating](https:\/\/openjdk.java.net\/jeps\/11) API since Java [16](https:\/\/openjdk.java.net\/jeps\/389). The central abstraction in the Foreign Linker API is the *foreign linker*, which allows clients to construct *native* method handles — that is, method handles whose invocation targets a native function defined in some native library. In other words, Panama foreign function support is completely expressed in terms of Java code and no intermediate native code is required.\n+Panama supports foreign functions through the Foreign Linker API, which has been available as an [incubating](https:\/\/openjdk.java.net\/jeps\/11) API since Java [16](https:\/\/openjdk.java.net\/jeps\/389). The central abstraction in the Foreign Linker API is the *foreign linker*, which allows clients to construct *downcall* method handles — that is, method handles whose invocation targets a native function defined in some native library. In other words, Panama foreign function support is completely expressed in terms of Java code and no intermediate native code is required.\n@@ -13,1 +13,1 @@\n-Now, in the case of memory segments, the above properties (spatial bounds, temporal bounds and confinement) can be known *in full* when the segment is created. But when we interact with native libraries we will often be receiving *raw* pointers; such pointers have no spatial bounds (does a `char*` in C refer to one `char`, or a `char` array of a given size?), no notion of temporal bounds, nor thread-confinement. Raw addresses in our interop support are modeled using the `MemoryAddress` abstraction.\n+Now, in the case of memory segments, the above properties (spatial bounds, temporal bounds and confinement) can be known *in full* when the segment is created. But when we interact with native libraries we often receive *raw* pointers; such pointers have no spatial bounds (does a `char*` in C refer to one `char`, or a `char` array of a given size?), no notion of temporal bounds, nor thread-confinement. Raw addresses in our interop support are modeled using the `MemoryAddress` abstraction.\n@@ -23,1 +23,1 @@\n-Alternatively, the client can create a memory segment from an address *unsafely*, using the `MemorySegment::ofAddressNative` factory (which is also a *restricted* method); this can also be useful to inject extra knowledge about spatial bounds which might be available in the native library the client is interacting with:\n+Alternatively, the client can create a memory segment from an address *unsafely*, using the `MemorySegment::ofAddress` factory (which is also a *restricted* method); this can also be useful to inject extra knowledge about spatial bounds which might be available in the native library the client is interacting with:\n@@ -28,1 +28,1 @@\n-\tMemorySegment segment = MemorySegment.ofAddressNative(100, scope);\n+\tMemorySegment segment = MemorySegment.ofAddress(100, scope);\n@@ -33,1 +33,1 @@\n-Both `MemoryAddress` and `MemorySegment` implement the `Addressable` interface, which is an interface modelling entities that can be passed *by reference* — that is, which can be projected to a `MemoryAddress` instance. In the case of `MemoryAddress` such a projection is the identity function; in the case of a memory segment, the projection returns the `MemoryAddres` instance for the segment's base address. This abstraction allows to pass either memory address or memory segments where an address is expected (this is especially useful when generating native bindings).\n+Both `MemoryAddress` and `MemorySegment` implement the `Addressable` interface, which is an interface modelling entities that can be passed *by reference* — that is, which can be projected to a `MemoryAddress` instance. In the case of `MemoryAddress` such a projection is the identity function; in the case of a memory segment, the projection returns the `MemoryAddress` instance for the segment's base address. This abstraction allows to pass either memory address or memory segments where an address is expected (this is especially useful when generating native bindings).\n@@ -60,1 +60,1 @@\n-To address these problems, Panama provides a `SegmentAllocator` abstraction, a functional interface which provides methods to allocate commonly used values. Conveniently, all resource scopes implement the `SegmentAllocator` interface, which means that the above code can be rewritten as follows:\n+To address these problems, Panama provides a `SegmentAllocator` abstraction, a functional interface which provides methods to allocate commonly used values. Conveniently, the above code can be rewritten as follows:\n@@ -64,1 +64,2 @@\n-    MemorySegment arr = scope.allocateArray(JAVA_INT, new int[] { 0, 1, 2, 3, 4 });\n+    SegmentAllocator allocator = SegmentAllocator.nativeAllocator(scope);\n+    MemorySegment arr = allocator.allocateArray(JAVA_INT, new int[] { 0, 1, 2, 3, 4 });\n@@ -68,1 +69,1 @@\n-In the above code, the resource scope is used as an allocator (built on top of `MemorySegment::allocateNative`) to create a native array which is initialized to the values `{ 0, 1, 2, 3, 4 }`.  The array initialization is more efficient, compared to the previous snippet, as the Java array is copied *in bulk* into the memory region associated with the newly allocated memory segment. Since the returned segment is associated with the scope which performed the allocation, meaning that the segment will no longer be accessible after the try-with-resource construct.\n+In the above code, the resource scope is used to build a *native* allocator (that is, an allocator built on top of `MemorySegment::allocateNative`). The segment allocator is then used to create a native array, initialized to the values `{ 0, 1, 2, 3, 4 }`.  The array initialization is more efficient, compared to the previous snippet, as the Java array is copied *in bulk* into the memory region associated with the newly allocated memory segment. The returned segment is associated with the scope which performed the allocation, meaning that the segment will no longer be accessible after the try-with-resource construct.\n@@ -74,1 +75,1 @@\n-    SegmentAllocator allocator = SegmentAllocator.arenaAllocator(scope);\n+    SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n@@ -82,1 +83,1 @@\n-The above code creates a confined scope; inside the *try-with-resources*, a new unbounded arena allocation is created, associated with the existing scope. The allocator will allocate slabs of memory, of a specific size, and respond to allocation requests by returning different slices of the pre-allocated slab. If a slab does not have sufficient space to accommodate a new allocation request, a new one will be allocated. If the scope associated with the arena allocator is closed, all memory associated with the segments created by the allocator (see the body of the `for` loop) will be deallocated at once. This idiom combines the advantages of deterministic deallocation (provided by the Memory Access API) with a more flexible and scalable allocation scheme, and can be very useful when writing large applications.\n+The above code creates a confined scope; inside the *try-with-resources*, a new unbounded arena allocation is created, associated with the existing scope. The allocator will pre-allocate a native segment, of a specific size, and respond to allocation requests by returning different slices of the pre-allocated segment. If the pre-allocated segment does not have sufficient space to accommodate a new allocation request, a new segment will be allocated. If the scope associated with the arena allocator is closed, all memory segments created by the allocator (see the body of the `for` loop) will be deallocated at once. This idiom combines the advantages of deterministic deallocation (provided by the Memory Access API) with a more flexible and scalable allocation scheme, and can be very useful when writing large applications.\n@@ -93,1 +94,1 @@\n-Once a lookup has been obtained, a client can use it to retrieve handles to library symbols (either global variables or functions) using the `lookup(String)` method, which returns an `Optional<MemoryAddress>`.\n+Once a lookup has been obtained, a client can use it to retrieve handles to library symbols (either global variables or functions) using the `lookup(String)` method, which returns an `Optional<NativeSymbol>`.  `NativeSymbol` is a class used to model references to library symbols, which implements the `Addressable` interface.\n@@ -99,1 +100,1 @@\n-MemoryAddress clangVersion = SymbolLookup.loaderLookup().lookup(\"clang_getClangVersion\").get();\n+NativeSymbol clangVersion = SymbolLookup.loaderLookup().lookup(\"clang_getClangVersion\").get();\n@@ -104,1 +105,1 @@\n-At the core of Panama foreign function support we find the `CLinker` abstraction. This abstraction plays a dual role: first, for downcalls, it allows modelling native function calls as plain `MethodHandle` calls (see `ForeignLinker::downcallHandle`); second, for upcalls, it allows to convert an existing `MethodHandle` (which might point to some Java method) into a `MemorySegment` which could then be passed to native functions as a function pointer (see `ForeignLinker::upcallStub`):\n+At the core of Panama foreign function support we find the `CLinker` abstraction. This abstraction plays a dual role: first, for downcalls, it allows modelling native function calls as plain `MethodHandle` calls (see `CLinker::downcallHandle`); second, for upcalls, it allows to convert an existing `MethodHandle` (which might point to some Java method) into a `NativeSymbol` which could then be passed to native functions as a function pointer (see `CLinker::upcallStub`):\n@@ -108,2 +109,2 @@\n-    MethodHandle downcallHandle(Addressable func, MethodType type, FunctionDescriptor function);\n-    UpcallStub upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope);    \n+    MethodHandle downcallHandle(NativeSymbol func, FunctionDescriptor function);\n+    NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope);    \n@@ -116,1 +117,1 @@\n-In the following sections we will dive deeper into how downcall handles and upcall stubs are created; here we want to focus on the similarities between these two routines. First, both take a `FunctionDescriptor` instance — essentially an aggregate of memory layouts which is used to describe the argument and return types of a foreign function in full. Supported layouts are *value layouts* (for scalars and pointers) and *group layouts* (for structs\/unions). Each layout in a function descriptor is associated with a carrier Java type (see table below); together, all the carrier types associated with layouts in a function descriptor will determine a unique Java `MethodType`, embodying the Java signature that clients will be using when interacting with said downcall handles, or upcall stubs.\n+Both functions take a `FunctionDescriptor` instance — essentially an aggregate of memory layouts which is used to describe the argument and return types of a foreign function in full. Supported layouts are *value layouts* (for scalars and pointers) and *group layouts* (for structs\/unions). Each layout in a function descriptor is associated with a carrier Java type (see table below); together, all the carrier types associated with layouts in a function descriptor will determine a unique Java `MethodType`  — that is, the Java signature that clients will be using when interacting with said downcall handles, or upcall stubs.\n@@ -120,12 +121,12 @@\n-| C type                                                       | Layout         | Java carrier                       |\n-| ------------------------------------------------------------ | -------------- | ---------------------------------- |\n-| `bool`                                                       | `JAVA_BOOLEAN` | `byte`                             |\n-| `char`                                                       | `JAVA_BYTE`    | `byte`                             |\n-| `short`                                                      | `JAVA_SHORT`   | `short`, `char`                    |\n-| `int`                                                        | `JAVA_INT`     | `int`                              |\n-| `long`                                                       | `JAVA_LONG`    | `long`                             |\n-| `long long`                                                  | `JAVA_LONG`    | `long`                             |\n-| `float`                                                      | `JAVA_FLOAT`   | `float`                            |\n-| `double`                                                     | `JAVA_DOUBLE`  | `double`                           |\n-| `char*`<br \/>`int**`<br \/> ...                               | `ADDRESS`      | `Addressable`<br \/>`MemoryAddress` |\n-| `struct Point { int x; int y; };`<br \/>`union Choice { float a; int b; };`<br \/>... | `GroupLayout`  | `MemorySegment`                    |\n+| C type                                                       | Layout                                                       | Java carrier                       |\n+| ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------- |\n+| `bool`                                                       | `JAVA_BOOLEAN`                                               | `byte`                             |\n+| `char`                                                       | `JAVA_BYTE`                                                  | `byte`                             |\n+| `short`                                                      | `JAVA_SHORT`                                                 | `short`, `char`                    |\n+| `int`                                                        | `JAVA_INT`                                                   | `int`                              |\n+| `long`                                                       | `JAVA_LONG`                                                  | `long`                             |\n+| `long long`                                                  | `JAVA_LONG`                                                  | `long`                             |\n+| `float`                                                      | `JAVA_FLOAT`                                                 | `float`                            |\n+| `double`                                                     | `JAVA_DOUBLE`                                                | `double`                           |\n+| `char*`<br \/>`int**`<br \/> ...                               | `ADDRESS`                                                    | `Addressable`<br \/>`MemoryAddress` |\n+| `struct Point { int x; int y; };`<br \/>`union Choice { float a; int b; };`<br \/>... | `MemoryLayout.structLayout(...)`<br \/>`MemoryLayout.unionLayout(...)`<br \/> | `MemorySegment`                    |\n@@ -164,1 +165,1 @@\n-One we have obtained the downcall native method handle, we can just use it as any other method handle<a href=\"#3\"><sup>3<\/sup><\/a>:\n+Once we have obtained the downcall method handle, we can just use it as any other method handle<a href=\"#2\"><sup>2<\/sup><\/a>:\n@@ -168,1 +169,2 @@\n-    long len = strlen.invoke(scope.allocateUtf8String(\"Hello\")); \/\/ 5\n+    SegmentAllocator malloc = SegmentAllocator.nativeAllocator(scope);\n+    long len = strlen.invoke(malloc.allocateUtf8String(\"Hello\")); \/\/ 5\n@@ -172,1 +174,1 @@\n-Here we are using one of the helper methods in `CLinker` to convert a Java string into an off-heap memory segment which contains a `NULL` terminated C string. We then pass that segment to the method handle and retrieve our result in a Java `long`. Note how all this has been possible *without* any piece of intervening native code — all the interop code can be expressed in (low level) Java. Note also how we used an explicit resource scope to control the lifecycle of the allocated C string, which ensures timely deallocation of the memory segment holding the native string.\n+Here we are using a native segment allocator to convert a Java string into an off-heap memory segment which contains a `NULL` terminated C string. We then pass that segment to the method handle and retrieve our result in a Java `long`. Note how all this is possible *without* any piece of intervening native code — all the interop code can be expressed in (low level) Java. Note also how we use an explicit resource scope to control the lifecycle of the allocated C string, which ensures timely deallocation of the memory segment holding the native string.\n@@ -174,1 +176,1 @@\n-The `CLinker` interfaces also supports linking of native function without an address known at link time; when that happens, an address must be provided when the method handle returned by the linker is invoked — this is very useful to support *virtual calls*. For instance, the above code can be rewritten as follows:\n+The `CLinker` interface also supports linking of native functions without an address known at link time; when that happens, an address (of type `Addressable`) must be provided when the method handle returned by the linker is invoked — this is very useful to support *virtual calls*. For instance, the above code can be rewritten as follows:\n@@ -182,0 +184,1 @@\n+    SegmentAllocator malloc = SegmentAllocator.nativeAllocator(scope);\n@@ -184,1 +187,1 @@\n-        scope.allocateUtf8String(\"Hello\")\n+        malloc.allocateUtf8String(\"Hello\")\n@@ -189,1 +192,1 @@\n-Now that we have seen the basics of how foreign function calls are supported in Panama, let's add some additional considerations. First, it is important to note that, albeit the interop code is written in Java, the above code can *not* be considered 100% safe. There are many arbitrary decisions to be made when setting up downcall method handles such as the one above, some of which might be obvious to us (e.g. how many parameters does the function take), but which cannot ultimately be verified by the Panama runtime. After all, a symbol in a dynamic library is, mostly a numeric offset and, unless we are using a shared library with debugging information, no type information is attached to a given library symbol. This means that, in this case, the Panama runtime has to *trust* our description of the `strlen` function. For this reason, access to the foreign linker is a restricted operation, which can only be performed if the requesting module is listed in the `--enable-native-access` command-line flag <a href=\"#2\"><sup>2<\/sup><\/a>.\n+It is important to note that, albeit the interop code is written in Java, the above code can *not* be considered 100% safe. There are many arbitrary decisions to be made when setting up downcall method handles such as the one above, some of which might be obvious to us (e.g. how many parameters does the function take), but which cannot ultimately be verified by the Panama runtime. After all, a symbol in a dynamic library is nothing but a numeric offset and, unless we are using a shared library with debugging information, no type information is attached to a given library symbol. This means that the Panama runtime has to *trust* the function descriptor passed in<a href=\"#3\"><sup>3<\/sup><\/a>; for this reason, access to the foreign linker is a restricted operation, which can only be performed if the requesting module is listed in the `--enable-native-access` command-line flag.\n@@ -191,1 +194,1 @@\n-Certain functions might return pointers, or structs; it is important to realize that if a function returns a pointer (or a `MemoryAddress`), no life-cycle whatsoever is attached to that pointer. It is then up to the client to e.g. free the memory associated with that pointer, or do nothing (in case the library is responsible for the life-cycle of that pointer). If a library returns a struct by value, things are different, as a *fresh*, memory segment is allocated off-heap and returned to the callee. In such cases, the foreign linker API will request an additional prefix `SegmentAllocator` (see above) parameter which will be responsible for allocating the returned segment. The allocation will likely associate the segment with a *resource scope* that is known to the callee and which can then be used to release the memory associated with that segment. An additional overload of `downcallHandle` is also provided by `CLinker` where a client can specify which allocator should be used in such cases at *link-time*.\n+If a native function returns a raw pointer (of type `MemoryAddress`), it is then up to the client to make sure that the address is being accessed and disposed of correctly, compatibly with the requirements of the underlying native library. If a native function returns a struct by value, a *fresh*, memory segment is allocated off-heap and returned to the caller. In such cases, the downcall method handle will feature an additional prefix `SegmentAllocator` (see above) parameter which will be used by the downcall method handle to allocate the returned segment. The allocation will likely associate the segment with a *resource scope* that is known to the caller and which can then be used to release the memory associated with that segment. \n@@ -193,1 +196,1 @@\n-Performance-wise, the reader might ask how efficient calling a foreign function using a native method handle is; the answer is *very*. The JVM comes with some special support for native method handles, so that, if a give method handle is invoked many times (e.g, inside a *hot* loop), the JIT compiler might decide to just generate a snippet of assembly code required to call the native function, and execute that directly. In most cases, invoking native function this way is as efficient as doing so through JNI.\n+Performance-wise, the reader might ask how efficient calling a foreign function using a native method handle is; the answer is *very*. The JVM comes with some special support for native method handles, so that, if a give method handle is invoked many times (e.g, inside a *hot* loop), the JIT compiler might decide to generate a snippet of assembly code required to call the native function, and execute that directly. In most cases, invoking native function this way is as efficient as doing so through JNI.\n@@ -204,1 +207,1 @@\n-This is a function that can be used to sort the contents of an array, using a custom comparator function — `compar` — which is passed as a function pointer. To be able to call the `qsort` function from Java we have first to create a downcall native method handle for it:\n+The `qsort` function can be used to sort the contents of an array, using a custom comparator function — `compar` — which is passed as a function pointer. To be able to call the `qsort` function from Java we have first to create a downcall method handle for it:\n@@ -228,1 +231,1 @@\n- Now let's create a method handle pointing to the comparator function above:\n+Now let's create a method handle pointing to the comparator function above:\n@@ -231,0 +234,1 @@\n+FunctionDescriptor comparDesc = FunctionDescriptor.of(JAVA_INT, ADDRESS, ADDRESS);\n@@ -233,1 +237,1 @@\n-                                                     MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class));\n+                                                     CLinker.upcallType(comparDesc));\n@@ -236,1 +240,1 @@\n-Now that we have a method handle for our Java comparator function, we finally have all the ingredients to create an upcall stub, and pass it to the `qsort` downcall handle:\n+To do that, we first create a function descriptor for the function pointer type, and then we use the `CLinker::upcallType` to turn that function descriptor into a suitable `MethodType` instance to be used in a method handle lookup. Now that we have a method handle for our Java comparator function, we finally have all the ingredients to create an upcall stub, and pass it to the `qsort` downcall handle:\n@@ -240,5 +244,4 @@\n-    UpcallStub comparFunc = linker.upcallStub(\n-        comparHandle,\n-    \tFunctionDescriptor.of(JAVA_INT, ADDRESS, ADDRESS),\n-        scope);\n-    MemorySegment array = scope.allocateArray(new int[] { 0, 9, 3, 4, 6, 5, 1, 8, 2, 7 }));\n+    NativeSymbol comparFunc = linker.upcallStub(\n+        comparHandle, comparDesc, scope);\n+    SegmentAllocator malloc = SegmentAllocator.nativeAllocator(scope);\n+    MemorySegment array = malloc.allocateArray(new int[] { 0, 9, 3, 4, 6, 5, 1, 8, 2, 7 }));\n@@ -250,1 +253,1 @@\n-The above code creates an upcall stub — `comparFunc` — a function pointer that can be used to invoke our Java comparator function. The upcall stub is associated with the provided resource scope instance; this means that the stub will be uninstalled when the resource scope is closed.\n+The above code creates an upcall stub — `comparFunc` — a function pointer that can be used to invoke our Java comparator function, of type `NativeSymbol`. The upcall stub is associated with the provided resource scope instance; this means that the stub will be uninstalled when the resource scope is closed.\n@@ -284,1 +287,2 @@\n-\tprintf.invoke(scope.allocateUtf8String(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n+    SegmentAllocator malloc = SegmentAllocator.nativeAllocator(scope);\n+    printf.invoke(malloc.allocateUtf8String(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n@@ -314,0 +318,1 @@\n+    SegmentAllocator malloc = SegmentAllocator.nativeAllocator(scope);\n@@ -315,1 +320,1 @@\n-            scope.allocateUtf8String(\"%d plus %d equals %d\", scope),\n+            malloc.allocateUtf8String(\"%d plus %d equals %d\", scope),\n@@ -317,3 +322,3 @@\n-                            builder.addVarg(C_INT, 2)\n-                                   .addVarg(C_INT, 2)\n-                                   .addVarg(C_INT, 4), scope)\n+                            builder.addVarg(JAVA_INT, 2)\n+                                   .addVarg(JAVA_INT, 2)\n+                                   .addVarg(JAVA_INT, 4), scope)\n@@ -338,0 +343,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -368,1 +374,2 @@\n-            MemorySegment hello = scope.allocateUtf8String(\"Hello\");\n+            SegmentAllocator malloc = SegmentAllocator.nativeAllocator(scope);\n+            MemorySegment hello = malloc.allocateUtf8String(\"Hello\");\n@@ -380,1 +387,2 @@\n-            MemorySegment hello = scope.allocateUtf8String(\"Hello\");\n+            SegmentAllocator malloc = SegmentAllocator.nativeAllocator(scope);\n+            MemorySegment hello = malloc.allocateUtf8String(\"Hello\");\n@@ -399,1 +407,1 @@\n-\n+        FunctionDescriptor comparDesc = FunctionDescriptor.of(JAVA_INT, ADDRESS, ADDRESS);\n@@ -401,2 +409,2 @@\n-                .findStatic(Qsort.class, \"qsortCompare\",\n-                        MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class));\n+                                         .findStatic(Qsort.class, \"qsortCompare\",\n+                                                     CLinker.upcallType(comparDesc));\n@@ -405,3 +413,2 @@\n-            CLinker.UpcallStub comparFunc = LINKER.upcallStub(\n-                comparHandle,\n-                FunctionDescriptor.of(JAVA_INT, ADDRESS, ADDRESS), scope);\n+            NativeSymbol comparFunc = LINKER.upcallStub(\n+                comparHandle, comparDesc, scope);\n@@ -409,1 +416,2 @@\n-            MemorySegment array = scope.allocateArray(JAVA_INT, new int[] { 0, 9, 3, 4, 6, 5, 1, 8, 2, 7 });\n+            SegmentAllocator malloc = SegmentAllocator.nativeAllocator(scope);\n+            MemorySegment array = malloc.allocateArray(JAVA_INT, new int[] { 0, 9, 3, 4, 6, 5, 1, 8, 2, 7 });\n@@ -422,1 +430,2 @@\n-            MemorySegment s = scope.allocateUtf8String(\"%d plus %d equals %d\\n\");\n+            SegmentAllocator malloc = SegmentAllocator.nativeAllocator(scope);\n+            MemorySegment s = malloc.allocateUtf8String(\"%d plus %d equals %d\\n\");\n@@ -434,1 +443,2 @@\n-            MemorySegment s = scope.allocateUtf8String(\"%d plus %d equals %d\\n\");\n+            SegmentAllocator malloc = SegmentAllocator.nativeAllocator(scope);\n+            MemorySegment s = malloc.allocateUtf8String(\"%d plus %d equals %d\\n\");\n@@ -447,4 +457,3 @@\n-* <a id=\"1\"\/>(<sup>1<\/sup>):<small> In the future, we might add more ways to obtain a symbol lookup — for instance: `SymbolLookup.ofLibrary(String libName, ResourceScope scope)`. This would allow developers to load a library and associate its lifecycle with a `ResourceScope` (rather than a classloader). That is, when the scope is closed, the library will be unloaded. However, adding these new mode will require some additional foundational work on the `CLinker` support — as we need to make sure that the memory address used by a downcall method handle cannot be unloaded while the downcall method handle is being invoked.<\/small>\n-* <a id=\"2\"\/>(<sup>2<\/sup>):<small> In reality this is not entirely new; even in JNI, when you call a `native` method the VM trusts that the corresponding implementing function in C will feature compatible parameter types and return values; if not a crash might occur.<\/small>\n-* <a id=\"3\"\/>(<sup>3<\/sup>):<small> For simplicity, the examples shown in this document use `MethodHandle::invoke` rather than `MethodHandle::invokeExact`; by doing so we avoid having to cast by-reference arguments back to `Addressable`. With `invokeExact` the method handle invocation should be rewritten as `strlen.invokeExact((Addressable)scope.allocateUtf8String(\"Hello\"));`<\/small>\n-\n+* <a id=\"1\"\/>(<sup>1<\/sup>):<small> Users might add more ways to obtain a symbol lookup — for instance: `SymbolLookup libraryLookup(String libName, ResourceScope scope)`. This would allow developers to load a library and associate its lifecycle with a `ResourceScope` (rather than a classloader). That is, when the scope is closed, the library will be unloaded. This is possible, as `CLinker` guarantees that memory addresses used by a downcall method handle cannot be released while the downcall method handle is being invoked.<\/small>\n+* <a id=\"2\"\/>(<sup>2<\/sup>):<small> For simplicity, the examples shown in this document use `MethodHandle::invoke` rather than `MethodHandle::invokeExact`; by doing so we avoid having to cast by-reference arguments back to `Addressable`. With `invokeExact` the method handle invocation should be rewritten as `strlen.invokeExact((Addressable)malloc.allocateUtf8String(\"Hello\"));`<\/small>\n+* <a id=\"3\"\/>(<sup>3<\/sup>):<small> In reality this is not entirely new; even in JNI, when you call a `native` method the VM trusts that the corresponding implementing function in C will feature compatible parameter types and return values; if not a crash might occur.<\/small>\n","filename":"doc\/panama_ffi.md","additions":76,"deletions":67,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-**September 2021**\n+**January 2022**\n@@ -16,1 +16,1 @@\n-MemorySegment segment = MemorySegment.allocateNative(100, ResourceScope.newConfinedScope());\n+MemorySegment segment = MemorySegment.allocateNative(100, ResourceScope.newImplicitScope());\n@@ -19,1 +19,1 @@\n-The above code allocates a 100-bytes long memory segment. The lifecycle of a memory segment is controlled by an abstraction called `ResourceScope`, which can be used to deallocate the memory associated with the memory segment (we will cover that in a later section of this document). Resource scopes feature (by default) an *implicit deallocation* mechanism, which allow memory segments such as the one above to be used pretty much in the same way as a `ByteBuffer` allocated with the `allocateDirect` factory. That is, the memory associated with the segment is deallocated when the resource scope, and hence, the segment, becomes unreacheable.\n+The above code allocates a 100-bytes long memory segment. The lifecycle of a memory segment is controlled by an abstraction called `ResourceScope`. In this example, the segment memory will not be *freed* as long as the segment instance is deemed *reachable*, as specified by the `newImplicitScope()` parameter. In other words, the above factory creates a segment whose behavior closely matches that of a `ByteBuffer` allocated with the `allocateDirect` factory. Of course, the memory access API also supports deterministic memory release; we will cover that in a later section of this document.\n@@ -24,1 +24,1 @@\n-MemorySegment segment = MemorySement.allocateNative(10, ResourceScope.newConfinedScope());\n+MemorySegment segment = MemorySement.allocateNative(10, ResourceScope.newImplicitScope());\n@@ -41,1 +41,1 @@\n-MemorySegment segment = MemorySement.allocateNative(10 * 4 * 2, ResourceScope.newConfinedScope());\n+MemorySegment segment = MemorySement.allocateNative(10 * 4 * 2, ResourceScope.newImplicitScope());\n@@ -50,1 +50,1 @@\n-The above snippet allocates a flat array of 80 bytes using `MemorySegment::allocateNative`. Then, inside the loop, elements in the array are accessed using the `MemorySegment::getAtIndex` method, which accesses `int` elements in a segment at a certain *logical* index (in other words, the segment offset being accessed is obtained by multiplying the index by 4, which is the stride of a Java `int` array). Thus, all coordinates `x` and `y` are collected into instances of a `Point` record.\n+The above snippet allocates a flat array of 80 bytes using `MemorySegment::allocateNative`. Then, inside the loop, elements in the array are accessed using the `MemorySegment::getAtIndex` method, which accesses `int` elements in a segment at a certain *logical* index (under the hood, the segment offset being accessed is obtained by multiplying the logical index by 4, which is the stride of a Java `int` array). Thus, all coordinates `x` and `y` are collected into instances of a `Point` record.\n@@ -79,1 +79,1 @@\n-That is, our layout is a repetition of 10 *struct* elements, each struct element containing two 32-bit values each. The advantage of defining a memory layout upfront, using an API, is that we can then query the layout — for instance we can compute the offset of the `y` coordinate in the 4th element of the points array:\n+That is, our layout is a repetition of 10 *struct* elements, each struct element containing two 32-bit values each. The advantage of defining a memory layout upfront, using an API, is that we can then query the layout — for instance we can compute the offset of the `y` coordinate in the 4th element of the `points` array:\n@@ -90,1 +90,1 @@\n-MemorySegment segment = MemorySegment.allocateNative(points, ResourceScope.newConfinedScope());\n+MemorySegment segment = MemorySegment.allocateNative(points, ResourceScope.newImplicitScope());\n@@ -113,1 +113,1 @@\n-Memory segments support deterministic deallocation, through an abstraction called `ResourceScope`. A resource scope models the lifecycle associated with one or more resources (in this document, by resources we mean mostly memory segments); a resource scope has a state: it starts off in the *alive* state, which means that all the resources it manages can be safely accessed — and, at the user request, it can be *closed*. After a resource scope is closed, access to resources managed by that scope is no longer allowed. Resource scope support the `AutoCloseable` interface, which means that user can use resource scopes with the *try-with-resources* construct, as demonstrated in the following code:\n+Memory segments support deterministic deallocation, through an abstraction called `ResourceScope`. A resource scope models the lifecycle associated with one or more resources (in this document, by resources we mean mostly memory segments); a resource scope has a state: it starts off in the *alive* state, which means that all the resources it manages can be safely accessed — and, at the user's request, it can be *closed*. After a resource scope is closed, access to resources managed by that scope is no longer allowed. Resource scopes implement the `AutoCloseable` interface, and can therefore be used with the *try-with-resources* construct, as demonstrated in the following code:\n@@ -121,1 +121,1 @@\n-Here, we create a new *confined* resource scope, which is then used when creating a mapped segment; this means that the lifecycle of the `mapped` segment will be tied to that of the resource scope, and that accessing the segment (e.g. dereference) *after* `scope` has been closed will not be possible.\n+Here, we create a new *confined* resource scope, which is then used when creating a mapped segment; this means that the lifecycle of the `mapped` segment is tied to that of the resource scope, and that accessing the segment (e.g. dereference) *after* `scope` has been closed will not be possible.\n@@ -123,3 +123,1 @@\n-As this example alludes to, resource scopes can come in two flavors: they can be *confined* (where access is restricted to the thread which created the scope) or *shared* <a href=\"#3\"><sup>3<\/sup><\/a> (where access can occur in any thread). By default, all resources scopes are associated with an internal `Cleaner` object, which would take care of performing implicit deallocation (in case `close` is never called). Optionally, clients can provide a custom `Cleaner` object, or decide not to use a `Cleaner` all together. While this latter option provides slightly better scope creation performance, it must be used with caution: any scope that becomes unreachable before its `close` method has been called will end up leaking memory resources.\n-\n-Resource scopes are very handy when managing the lifecycle of multiple resources:\n+As this example alludes to, resource scopes can come in many flavors: they can be *confined* (where access is restricted to the thread which created the scope), *shared* <a href=\"#3\"><sup>3<\/sup><\/a> (where access can occur in any thread) and can be optionally associated with a `Cleaner` object (as in the case of `newImplicitScope`), which performs *implicit* deallocation when the resource scope becomes *unreachable* (if the `close` method has not been called by the user). Resource scopes are very handy when managing the lifecycle of multiple resources:\n@@ -200,1 +198,1 @@\n-The attentive reader might have noted how rich the var handles returned by the layout API are, compared to the simple memory access var handle we have constructed above. How do we go from a simple access var handle that takes a byte offset to a var handle that can dereference a complex layout path? The answer is, by using var handle *combinators*. Developers familiar with the method handle API know how simpler method handles can be combined into more complex ones using the various combinator methods in the `MethodHandles` API. These methods allow, for instance, to insert (or bind) arguments into a target method handle, filter return values, permute arguments and much more.\n+The attentive reader might have noted how rich the var handles returned by the layout API are, compared to the simple memory access var handle we have constructed here. How do we go from a simple access var handle that takes a byte offset to a var handle that can dereference a complex layout path? The answer is, by using var handle *combinators*. Developers familiar with the method handle API know how simpler method handles can be combined into more complex ones using the various combinator methods in the `MethodHandles` API. These methods allow, for instance, to insert (or bind) arguments into a target method handle, filter return values, permute arguments and much more.\n@@ -221,3 +219,1 @@\n-The memory access API provides basic safety guarantees for all memory segments created using the API. More specifically, dereferencing memory should either succeed, or result in a runtime exception — but, crucially, should never result in a VM crash, or, more subtly, in memory corruption occurring *outside* the region of memory associated with a memory segment. This is possible, since all segments have immutable *spatial bounds*, and, as we have seen, are associated with a resource scope which make sure that the segment cannot be dereferenced after the scope has been closed, or, in case of a confined scope, that the segment is dereferenced from the very same thread which created the scope.\n-\n-That said, it is sometimes necessary to create a segment out of an existing memory source, which might be managed by native code. This is the case, for instance, if we want to create a segment out of memory managed by a custom allocator.\n+The memory access API provides basic safety guarantees for all memory segments created using the API. More specifically, a memory dereference operation should either succeed, or result in a runtime exception — but, crucially, should never result in a VM crash, or, more subtly, in memory corruption occurring *outside* the region of memory associated with a memory segment. This is indeed the case, as all memory segments feature immutable *spatial bounds*, and, as we have seen, are associated with a resource scope which make sure that segments cannot be dereferenced after their scope has been closed, or, in case of a confined scope, that segments cannot be dereferenced from a thread other than the one which created the scope.\n@@ -225,1 +221,1 @@\n-The ByteBuffer API allows such a move, through a JNI [method](https:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/guides\/jni\/spec\/functions.html#NewDirectByteBuffer), namely `NewDirectByteBuffer`. This native method can be used to wrap a long address in a fresh byte buffer instance which is then returned to unsuspecting Java code.\n+That said, it is sometimes necessary to create a segment out of an existing memory source, which might be managed by native code. This is the case, for instance, if we want to create a segment out of a memory region managed by a *custom allocator*.\n@@ -227,1 +223,1 @@\n-Memory segments provide a similar capability — that is, given an address (which might have been obtained through some native calls), it is possible to wrap a segment around it, with given spatial bounds and resource scope; a cleanup action to be executed when the segment is closed might also be specified.\n+The ByteBuffer API allows such a move, through a JNI [method](https:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/guides\/jni\/spec\/functions.html#NewDirectByteBuffer), namely `NewDirectByteBuffer`. This native method can be used to wrap a long address in a fresh direct byte buffer instance which is then returned to unsuspecting Java code.\n@@ -229,1 +225,1 @@\n-For instance, assuming we have an address pointing at some externally managed memory block, we can construct an *unsafe* segment, as follows:\n+Memory segments provide a similar capability — that is, given an address (which might have been obtained through some native calls), it is possible to wrap a segment around it, with given spatial bounds and resource scope, as follows:\n@@ -234,1 +230,1 @@\n-    var unsafeSegment = MemorySegment.ofAddressNative(addr, 10, scope);\n+    var unsafeSegment = MemorySegment.ofAddress(addr, 10, scope);\n","filename":"doc\/panama_memaccess.md","additions":17,"deletions":21,"binary":false,"changes":38,"status":"modified"}]}