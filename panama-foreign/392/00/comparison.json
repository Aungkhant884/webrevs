{"files":[{"patch":"@@ -311,1 +311,1 @@\n-                        StorageClasses.INTEGER, layout);\n+                        StorageClasses.INTEGER, AArch64.C_POINTER);\n@@ -406,1 +406,2 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(\n+                        StorageClasses.INTEGER, AArch64.C_POINTER);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -347,0 +347,36 @@\n+\n+    @Test\n+    public void testStructStackSpill() {\n+        \/\/ A large (> 16 byte) struct argument that is spilled to the\n+        \/\/ stack should be passed as a pointer to a copy and occupy one\n+        \/\/ stack slot.\n+\n+        MemoryLayout struct = MemoryLayout.ofStruct(C_INT, C_INT, C_DOUBLE, C_INT);\n+\n+        MethodType mt = MethodType.methodType(\n+            void.class, MemorySegment.class, MemorySegment.class, int.class, int.class,\n+            int.class, int.class, int.class, int.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+            struct, struct, C_INT, C_INT, C_INT, C_INT, C_INT, C_INT, struct, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn);\n+        CallingSequence callingSequence = bindings.callingSequence;\n+        assertEquals(callingSequence.methodType(), mt);\n+        assertEquals(callingSequence.functionDesc(), fd);\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { copy(struct), baseAddress(), unboxAddress(), vmStore(r0, long.class) },\n+            { copy(struct), baseAddress(), unboxAddress(), vmStore(r1, long.class) },\n+            { vmStore(r2, int.class) },\n+            { vmStore(r3, int.class) },\n+            { vmStore(r4, int.class) },\n+            { vmStore(r5, int.class) },\n+            { vmStore(r6, int.class) },\n+            { vmStore(r7, int.class) },\n+            { copy(struct), baseAddress(), unboxAddress(), vmStore(stackStorage(0), long.class) },\n+            { vmStore(stackStorage(1), int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"}]}