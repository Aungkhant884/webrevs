{"files":[{"patch":"@@ -93,16 +93,0 @@\n-    \/**\n-     * Returns the method type consisting of the carrier types of the layouts in this function descriptor.\n-     * <p>\n-     * The carrier type of a layout is determined as follows:\n-     * <ul>\n-     * <li>If the layout is a {@link ValueLayout} the carrier type is determined through {@link ValueLayout#carrier()}.<\/li>\n-     * <li>If the layout is a {@link GroupLayout} the carrier type is {@link MemorySegment}.<\/li>\n-     * <li>If the layout is a {@link PaddingLayout}, or {@link SequenceLayout} an {@link IllegalArgumentException} is thrown.<\/li>\n-     * <\/ul>\n-     *\n-     * @return the method type consisting of the carrier types of the layouts in this function descriptor\n-     * @throws IllegalArgumentException if one or more layouts in the function descriptor can not be mapped to carrier\n-     *                                  types (e.g. if they are sequence layouts or padding layouts).\n-     *\/\n-    MethodType toMethodType();\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.lang.invoke.MethodType;\n@@ -245,1 +246,1 @@\n- *                                                      comparDesc.toMethodType());\n+ *                                                      linker.toMethodType(comparDesc));\n@@ -251,1 +252,1 @@\n- * the contents of the array elements to be compared. We then {@linkplain FunctionDescriptor#toMethodType() turn}\n+ * the contents of the array elements to be compared. We then {@linkplain #toMethodType(FunctionDescriptor) turn}\n@@ -467,1 +468,1 @@\n-     * {@linkplain FunctionDescriptor#toMethodType() derived} from the argument and return layouts in the function descriptor,\n+     * {@linkplain #toMethodType(FunctionDescriptor) derived} from the argument and return layouts in the function descriptor,\n@@ -554,0 +555,18 @@\n+    \/**\n+     * Returns the method type associated with the provided function descriptor. The mapping between\n+     * the layouts in the function descriptor and the carrier types in the resulting method type instance\n+     * is linker-specific. For instance, in the case of the {@linkplain #nativeLinker() native linker} carrier types\n+     * are determined from layouts as follows:\n+     * <ul>\n+     * <li>If the layout is a {@link ValueLayout} the carrier type is determined through {@link ValueLayout#carrier()}.<\/li>\n+     * <li>If the layout is a {@link GroupLayout} the carrier type is {@link MemorySegment}.<\/li>\n+     * <li>If the layout is a {@link PaddingLayout}, or {@link SequenceLayout} an {@link IllegalArgumentException} is thrown.<\/li>\n+     * <\/ul>\n+     *\n+     * @param desc the function descriptor.\n+     * @return the method type consisting of the carrier types of the layouts in this function descriptor\n+     * @throws IllegalArgumentException if one or more layouts in the function descriptor can not be mapped to carrier\n+     *                                  types by this linker instance.\n+     *\/\n+    MethodType toMethodType(FunctionDescriptor desc);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.GroupLayout;\n@@ -30,3 +29,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodType;\n@@ -120,20 +116,0 @@\n-    private static Class<?> carrierTypeFor(MemoryLayout layout) {\n-        if (layout instanceof ValueLayout valueLayout) {\n-            return valueLayout.carrier();\n-        } else if (layout instanceof GroupLayout) {\n-            return MemorySegment.class;\n-        } else {\n-            throw new IllegalArgumentException(\"Unsupported layout: \" + layout);\n-        }\n-    }\n-\n-    @Override\n-    public MethodType toMethodType() {\n-        Class<?> returnValue = resLayout != null ? carrierTypeFor(resLayout) : void.class;\n-        Class<?>[] argCarriers = new Class<?>[argLayouts.size()];\n-        for (int i = 0; i < argCarriers.length; i++) {\n-            argCarriers[i] = carrierTypeFor(argLayouts.get(i));\n-        }\n-        return MethodType.methodType(returnValue, argCarriers);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/FunctionDescriptorImpl.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -37,7 +37,1 @@\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.*;\n@@ -61,0 +55,22 @@\n+    private static Class<?> carrierTypeFor(MemoryLayout layout) {\n+        if (layout instanceof ValueLayout valueLayout) {\n+            return valueLayout.carrier();\n+        } else if (layout instanceof GroupLayout) {\n+            return MemorySegment.class;\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported layout: \" + layout);\n+        }\n+    }\n+\n+    @Override\n+    public MethodType toMethodType(FunctionDescriptor desc) {\n+        Class<?> returnValue = desc.returnLayout()\n+                .map(AbstractLinker::carrierTypeFor)\n+                .orElse(void.class);\n+        Class<?>[] argCarriers = new Class<?>[desc.argumentLayouts().size()];\n+        for (int i = 0; i < argCarriers.length; i++) {\n+            argCarriers[i] = carrierTypeFor(desc.argumentLayouts().get(i));\n+        }\n+        return MethodType.methodType(returnValue, argCarriers);\n+    }\n+\n@@ -70,1 +86,1 @@\n-            MethodType type = fd.toMethodType();\n+            MethodType type = toMethodType(fd);\n@@ -87,1 +103,1 @@\n-        MethodType type = function.toMethodType();\n+        MethodType type = toMethodType(function);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":25,"deletions":9,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -483,3 +483,1 @@\n-                    for (StorageCalculator.StructStorage(\n-                            long offset, Class<?> ca, int byteWidth, VMStorage storage\n-                    ) : structStorages) {\n+                    for (StorageCalculator.StructStorage structStorage : structStorages) {\n@@ -487,2 +485,2 @@\n-                        bindings.vmLoad(storage, ca)\n-                                .bufferStore(offset, ca, byteWidth);\n+                        bindings.vmLoad(structStorage.storage, structStorage.carrier)\n+                                .bufferStore(structStorage.offset, structStorage.carrier, structStorage.byteWidth);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-            MethodHandle target = MethodHandles.lookup().findStatic(holder, name, descriptor.toMethodType());\n+            MethodHandle target = MethodHandles.lookup().findStatic(holder, name, LINKER.toMethodType(descriptor));\n@@ -290,1 +290,1 @@\n-        target = target.asType(fd.toMethodType());\n+        target = target.asType(LINKER.toMethodType(fd));\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-                        qsortComparFunction.toMethodType());\n+                        LINKER.toMethodType(qsortComparFunction));\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -112,19 +112,0 @@\n-    @Test\n-    public void testCarrierMethodType() {\n-        FunctionDescriptor fd = FunctionDescriptor.of(C_INT,\n-                C_INT,\n-                MemoryLayout.structLayout(C_INT, C_INT));\n-        MethodType cmt = fd.toMethodType();\n-        assertEquals(cmt, MethodType.methodType(int.class, int.class, MemorySegment.class));\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadCarrierMethodType() {\n-        FunctionDescriptor fd = FunctionDescriptor.of(C_INT,\n-                C_INT,\n-                MemoryLayout.structLayout(C_INT, C_INT),\n-                MemoryLayout.sequenceLayout(3, C_INT),\n-                MemoryLayout.paddingLayout(32));\n-        fd.toMethodType(); \/\/ should throw\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestFunctionDescriptor.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -46,2 +46,1 @@\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n+import static org.testng.Assert.*;\n@@ -79,0 +78,19 @@\n+\n+    @Test\n+    public void testCarrierMethodType() {\n+        FunctionDescriptor fd = FunctionDescriptor.of(C_INT,\n+                C_INT,\n+                MemoryLayout.structLayout(C_INT, C_INT));\n+        MethodType cmt = LINKER.toMethodType(fd);\n+        assertEquals(cmt, MethodType.methodType(int.class, int.class, MemorySegment.class));\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testBadCarrierMethodType() {\n+        FunctionDescriptor fd = FunctionDescriptor.of(C_INT,\n+                C_INT,\n+                MemoryLayout.structLayout(C_INT, C_INT),\n+                MemoryLayout.sequenceLayout(3, C_INT),\n+                MemoryLayout.paddingLayout(32));\n+        LINKER.toMethodType(fd); \/\/ should throw\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"}]}