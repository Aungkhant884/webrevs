{"files":[{"patch":"@@ -93,0 +93,16 @@\n+    \/**\n+     * Returns the method type consisting of the carrier types of the layouts in this function descriptor.\n+     * <p>\n+     * The carrier type of a layout is determined as follows:\n+     * <ul>\n+     * <li>If the layout is a {@link ValueLayout} the carrier type is determined through {@link ValueLayout#carrier()}.<\/li>\n+     * <li>If the layout is a {@link GroupLayout} or a {@link SequenceLayout}, the carrier type is {@link MemorySegment}.<\/li>\n+     * <li>If the layout is a {@link PaddingLayout}, an {@link IllegalArgumentException} is thrown.<\/li>\n+     * <\/ul>\n+     *\n+     * @return the method type consisting of the carrier types of the layouts in this function descriptor\n+     * @throws IllegalArgumentException if one or more layouts in the function descriptor can not be mapped to carrier\n+     *                                  types (e.g. if they are sequence layouts or padding layouts).\n+     *\/\n+    MethodType toMethodType();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.invoke.MethodType;\n@@ -246,1 +245,1 @@\n- *                                                      linker.toMethodType(comparDesc));\n+ *                                                      comparDesc.toMethodType());\n@@ -252,1 +251,1 @@\n- * the contents of the array elements to be compared. We then {@linkplain #toMethodType(FunctionDescriptor) turn}\n+ * the contents of the array elements to be compared. We then {@linkplain FunctionDescriptor#toMethodType() turn}\n@@ -468,1 +467,1 @@\n-     * {@linkplain #toMethodType(FunctionDescriptor) derived} from the argument and return layouts in the function descriptor,\n+     * {@linkplain FunctionDescriptor#toMethodType() derived} from the argument and return layouts in the function descriptor,\n@@ -555,18 +554,0 @@\n-    \/**\n-     * Returns the method type associated with the provided function descriptor. The mapping between\n-     * the layouts in the function descriptor and the carrier types in the resulting method type instance\n-     * is linker-specific. For instance, in the case of the {@linkplain #nativeLinker() native linker} carrier types\n-     * are determined from layouts as follows:\n-     * <ul>\n-     * <li>If the layout is a {@link ValueLayout} the carrier type is determined through {@link ValueLayout#carrier()}.<\/li>\n-     * <li>If the layout is a {@link GroupLayout} the carrier type is {@link MemorySegment}.<\/li>\n-     * <li>If the layout is a {@link PaddingLayout}, or {@link SequenceLayout} an {@link IllegalArgumentException} is thrown.<\/li>\n-     * <\/ul>\n-     *\n-     * @param desc the function descriptor.\n-     * @return the method type consisting of the carrier types of the layouts in this function descriptor\n-     * @throws IllegalArgumentException if one or more layouts in the function descriptor can not be mapped to carrier\n-     *                                  types by this linker instance.\n-     *\/\n-    MethodType toMethodType(FunctionDescriptor desc);\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":3,"deletions":22,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.foreign.GroupLayout;\n@@ -29,0 +30,4 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodType;\n@@ -116,0 +121,20 @@\n+    private static Class<?> carrierTypeFor(MemoryLayout layout) {\n+        if (layout instanceof ValueLayout valueLayout) {\n+            return valueLayout.carrier();\n+        } else if (layout instanceof GroupLayout || layout instanceof SequenceLayout) {\n+            return MemorySegment.class;\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported layout: \" + layout);\n+        }\n+    }\n+\n+    @Override\n+    public MethodType toMethodType() {\n+        Class<?> returnValue = resLayout != null ? carrierTypeFor(resLayout) : void.class;\n+        Class<?>[] argCarriers = new Class<?>[argLayouts.size()];\n+        for (int i = 0; i < argCarriers.length; i++) {\n+            argCarriers[i] = carrierTypeFor(argLayouts.get(i));\n+        }\n+        return MethodType.methodType(returnValue, argCarriers);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/FunctionDescriptorImpl.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -37,1 +37,8 @@\n-import java.lang.foreign.*;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.PaddingLayout;\n+import java.lang.foreign.SequenceLayout;\n@@ -55,22 +62,0 @@\n-    private static Class<?> carrierTypeFor(MemoryLayout layout) {\n-        if (layout instanceof ValueLayout valueLayout) {\n-            return valueLayout.carrier();\n-        } else if (layout instanceof GroupLayout) {\n-            return MemorySegment.class;\n-        } else {\n-            throw new IllegalArgumentException(\"Unsupported layout: \" + layout);\n-        }\n-    }\n-\n-    @Override\n-    public MethodType toMethodType(FunctionDescriptor desc) {\n-        Class<?> returnValue = desc.returnLayout()\n-                .map(AbstractLinker::carrierTypeFor)\n-                .orElse(void.class);\n-        Class<?>[] argCarriers = new Class<?>[desc.argumentLayouts().size()];\n-        for (int i = 0; i < argCarriers.length; i++) {\n-            argCarriers[i] = carrierTypeFor(desc.argumentLayouts().get(i));\n-        }\n-        return MethodType.methodType(returnValue, argCarriers);\n-    }\n-\n@@ -81,1 +66,1 @@\n-        checkHasNaturalAlignment(function);\n+        checkIsSupportedDescriptor(function);\n@@ -86,1 +71,1 @@\n-            MethodType type = toMethodType(fd);\n+            MethodType type = fd.toMethodType();\n@@ -99,1 +84,1 @@\n-        checkHasNaturalAlignment(function);\n+        checkIsSupportedDescriptor(function);\n@@ -103,1 +88,1 @@\n-        MethodType type = toMethodType(function);\n+        MethodType type = function.toMethodType();\n@@ -120,6 +105,13 @@\n-    \/\/ Current limitation of the implementation:\n-    \/\/ We don't support packed structs on some platforms,\n-    \/\/ so reject them here explicitly\n-    private static void checkHasNaturalAlignment(FunctionDescriptor descriptor) {\n-        descriptor.returnLayout().ifPresent(AbstractLinker::checkHasNaturalAlignmentRecursive);\n-        descriptor.argumentLayouts().forEach(AbstractLinker::checkHasNaturalAlignmentRecursive);\n+    \/\/ Native linkers do not support sequence or padding layouts. They also do not support \"packed\" struct layouts, or\n+    \/\/ struct layouts containing additional padding. Such illegal layouts are ruled out here.\n+    private static void checkIsSupportedDescriptor(FunctionDescriptor descriptor) {\n+        descriptor.returnLayout().ifPresent(AbstractLinker::checkIsSupportedLayout);\n+        descriptor.argumentLayouts().forEach(AbstractLinker::checkIsSupportedLayout);\n+    }\n+\n+    private static void checkIsSupportedLayout(MemoryLayout layout) {\n+        if (layout instanceof SequenceLayout || layout instanceof PaddingLayout) {\n+            throw new IllegalArgumentException(\"Unsupported layout: \" + layout);\n+        } else {\n+            checkHasNaturalAlignmentRecursive(layout);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":25,"deletions":33,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -483,1 +483,3 @@\n-                    for (StorageCalculator.StructStorage structStorage : structStorages) {\n+                    for (StorageCalculator.StructStorage(\n+                            long offset, Class<?> ca, int byteWidth, VMStorage storage\n+                    ) : structStorages) {\n@@ -485,2 +487,2 @@\n-                        bindings.vmLoad(structStorage.storage, structStorage.carrier)\n-                                .bufferStore(structStorage.offset, structStorage.carrier, structStorage.byteWidth);\n+                        bindings.vmLoad(storage, ca)\n+                                .bufferStore(offset, ca, byteWidth);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-            MethodHandle target = MethodHandles.lookup().findStatic(holder, name, LINKER.toMethodType(descriptor));\n+            MethodHandle target = MethodHandles.lookup().findStatic(holder, name, descriptor.toMethodType());\n@@ -290,1 +290,1 @@\n-        target = target.asType(LINKER.toMethodType(fd));\n+        target = target.asType(fd.toMethodType());\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-                        LINKER.toMethodType(qsortComparFunction));\n+                        qsortComparFunction.toMethodType());\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -112,0 +112,20 @@\n+    @Test\n+    public void testCarrierMethodType() {\n+        FunctionDescriptor fd = FunctionDescriptor.of(C_INT,\n+                C_INT,\n+                MemoryLayout.structLayout(C_INT, C_INT),\n+                MemoryLayout.sequenceLayout(3, C_INT));\n+        MethodType cmt = fd.toMethodType();\n+        assertEquals(cmt, MethodType.methodType(int.class, int.class, MemorySegment.class, MemorySegment.class));\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testBadCarrierMethodType() {\n+        FunctionDescriptor fd = FunctionDescriptor.of(C_INT,\n+                C_INT,\n+                MemoryLayout.structLayout(C_INT, C_INT),\n+                MemoryLayout.sequenceLayout(3, C_INT),\n+                MemoryLayout.paddingLayout(32));\n+        fd.toMethodType(); \/\/ should throw\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestFunctionDescriptor.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -46,1 +46,2 @@\n-import static org.testng.Assert.*;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n@@ -78,19 +79,0 @@\n-\n-    @Test\n-    public void testCarrierMethodType() {\n-        FunctionDescriptor fd = FunctionDescriptor.of(C_INT,\n-                C_INT,\n-                MemoryLayout.structLayout(C_INT, C_INT));\n-        MethodType cmt = LINKER.toMethodType(fd);\n-        assertEquals(cmt, MethodType.methodType(int.class, int.class, MemorySegment.class));\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadCarrierMethodType() {\n-        FunctionDescriptor fd = FunctionDescriptor.of(C_INT,\n-                C_INT,\n-                MemoryLayout.structLayout(C_INT, C_INT),\n-                MemoryLayout.sequenceLayout(3, C_INT),\n-                MemoryLayout.paddingLayout(32));\n-        LINKER.toMethodType(fd); \/\/ should throw\n-    }\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"}]}