{"files":[{"patch":"@@ -88,1 +88,1 @@\n-    private static final String ADDRESS_DESC = methodType(long.class).descriptorString();\n+    private static final String UNBOX_SEGMENT_DESC = methodType(long.class, MemorySegment.class).descriptorString();\n@@ -578,4 +578,0 @@\n-    private void emitAddress() {\n-        emitInvokeInterface(MemorySegment.class, \"address\", ADDRESS_DESC);\n-    }\n-\n@@ -720,1 +716,1 @@\n-        emitAddress();\n+        emitInvokeStatic(SharedUtils.class, \"unboxSegment\", UNBOX_SEGMENT_DESC);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.foreign.HeapMemorySegmentImpl;\n@@ -263,0 +264,7 @@\n+    static long unboxSegment(MemorySegment segment) {\n+        if (!segment.isNative()) {\n+            throw new IllegalArgumentException(\"Heap segment not allowed: \" + segment);\n+        }\n+        return segment.address();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -33,0 +34,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -85,1 +87,1 @@\n-    private static Linker LINKER = Linker.nativeLinker();\n+    private static final Linker LINKER = Linker.nativeLinker();\n@@ -112,0 +114,13 @@\n+\n+    public static MethodHandle downcallHandle(String symbol, FunctionDescriptor desc) {\n+        return LINKER.downcallHandle(findNativeOrThrow(symbol), desc);\n+    }\n+\n+    public static MemorySegment upcallStub(Class<?> holder, String name, FunctionDescriptor descriptor) {\n+        try {\n+            MethodHandle target = MethodHandles.lookup().findStatic(holder, name, descriptor.toMethodType());\n+            return LINKER.upcallStub(target, descriptor, MemorySession.openImplicit());\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import jdk.test.lib.Utils;\n+import org.testng.annotations.DataProvider;\n@@ -39,1 +39,0 @@\n-import java.io.BufferedReader;\n@@ -41,4 +40,0 @@\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.nio.file.Paths;\n-import java.util.List;\n@@ -46,3 +41,1 @@\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.assertNotEquals;\n-import static org.testng.Assert.assertTrue;\n+public class TestUpcallException extends UpcallTestHelper {\n@@ -50,46 +43,4 @@\n-public class TestUpcallException {\n-\n-    @Test\n-    public void testExceptionInterpreted() throws InterruptedException, IOException {\n-        run(\/* useSpec = *\/ false, \/* isVoid = *\/ true);\n-        run(\/* useSpec = *\/ false, \/* isVoid = *\/ false);\n-    }\n-\n-    @Test\n-    public void testExceptionSpecialized() throws IOException, InterruptedException {\n-        run(\/* useSpec = *\/ true, \/* isVoid = *\/ true);\n-        run(\/* useSpec = *\/ true, \/* isVoid = *\/ false);\n-    }\n-\n-    private void run(boolean useSpec, boolean isVoid) throws IOException, InterruptedException {\n-        Process process = new ProcessBuilder()\n-            .command(\n-                Paths.get(Utils.TEST_JDK)\n-                     .resolve(\"bin\")\n-                     .resolve(\"java\")\n-                     .toAbsolutePath()\n-                     .toString(),\n-                \"--enable-preview\",\n-                \"--enable-native-access=ALL-UNNAMED\",\n-                \"-Djava.library.path=\" + System.getProperty(\"java.library.path\"),\n-                \"-Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=\" + useSpec,\n-                \"-cp\", Utils.TEST_CLASS_PATH,\n-                \"ThrowingUpcall\",\n-                isVoid ? \"void\" : \"non-void\")\n-            .start();\n-\n-        int result = process.waitFor();\n-        assertNotEquals(result, 0);\n-\n-        List<String> outLines = linesFromStream(process.getInputStream());\n-        outLines.forEach(System.out::println);\n-        List<String> errLines = linesFromStream(process.getErrorStream());\n-        errLines.forEach(System.err::println);\n-\n-        \/\/ Exception message would be found in stack trace\n-        String shouldInclude = \"Testing upcall exceptions\";\n-        assertTrue(linesContain(errLines, shouldInclude), \"Did not find '\" + shouldInclude + \"' in stderr\");\n-    }\n-\n-    private boolean linesContain(List<String> errLines, String shouldInclude) {\n-        return errLines.stream().anyMatch(line -> line.contains(shouldInclude));\n+    @Test(dataProvider = \"cases\")\n+    public void testException(boolean useSpec, boolean isVoid) throws InterruptedException, IOException {\n+        runInNewProcess(ThrowingUpcall.class, useSpec, isVoid ? \"void\" : \"\")\n+                .assertStdErrContains(\"Testing upcall exceptions\");\n@@ -98,4 +49,8 @@\n-    private static List<String> linesFromStream(InputStream stream) throws IOException {\n-        try (BufferedReader reader = new BufferedReader(new InputStreamReader(stream))) {\n-            return reader.lines().toList();\n-        }\n+    @DataProvider\n+    public static Object[][] cases() {\n+        return new Object[][]{\n+            { false, true,  },\n+            { false, false, },\n+            { true,  true,  },\n+            { true,  false, }\n+        };\n","filename":"test\/jdk\/java\/foreign\/TestUpcallException.java","additions":14,"deletions":59,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+public class UpcallTestHelper extends NativeTestHelper {\n+    public record Output(List<String> stdout, List<String> stderr) {\n+        private static void assertContains(List<String> lines, String shouldInclude) {\n+            assertTrue(lines.stream().anyMatch(line -> line.contains(shouldInclude)),\n+                \"Did not find '\" + shouldInclude + \"' in stderr\");\n+        }\n+\n+        public void assertStdErrContains(String shouldInclude) {\n+            assertContains(stderr, shouldInclude);\n+        }\n+    }\n+\n+    public Output runInNewProcess(Class<?> target, boolean useSpec, String... programArgs) throws IOException, InterruptedException {\n+        assert !target.isArray();\n+\n+        List<String> command = new ArrayList<>(List.of(\n+            Paths.get(Utils.TEST_JDK)\n+                    .resolve(\"bin\")\n+                    .resolve(\"java\")\n+                    .toAbsolutePath()\n+                    .toString(),\n+            \"--enable-preview\",\n+            \"--enable-native-access=ALL-UNNAMED\",\n+            \"-Djava.library.path=\" + System.getProperty(\"java.library.path\"),\n+            \"-Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=\" + useSpec,\n+            \"-cp\", Utils.TEST_CLASS_PATH,\n+            target.getName()\n+        ));\n+        command.addAll(Arrays.asList(programArgs));\n+        Process process = new ProcessBuilder()\n+            .command(command)\n+            .start();\n+\n+        int result = process.waitFor();\n+        assertNotEquals(result, 0);\n+\n+        List<String> outLines = linesFromStream(process.getInputStream());\n+        outLines.forEach(System.out::println);\n+        List<String> errLines = linesFromStream(process.getErrorStream());\n+        errLines.forEach(System.err::println);\n+\n+        return new Output(outLines, errLines);\n+    }\n+\n+    private static List<String> linesFromStream(InputStream stream) throws IOException {\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(stream))) {\n+            return reader.lines().toList();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/UpcallTestHelper.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @library ..\/ \/test\/lib\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestPassHeapSegment\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+\n+public class TestPassHeapSegment extends UpcallTestHelper  {\n+\n+    static {\n+        System.loadLibrary(\"PassHeapSegment\");\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class,\n+        expectedExceptionsMessageRegExp = \".*Heap segment not allowed.*\")\n+    public void testNoHeapArgs() throws Throwable {\n+        MethodHandle handle = downcallHandle(\"test_args\", FunctionDescriptor.ofVoid(ADDRESS));\n+        MemorySegment segment = MemorySegment.ofArray(new byte[]{ 0, 1, 2 });\n+        handle.invoke(segment); \/\/ should throw\n+    }\n+\n+    @Test(dataProvider = \"specs\")\n+    public void testNoHeapReturns(boolean spec) throws IOException, InterruptedException {\n+        runInNewProcess(Runner.class, spec).assertStdErrContains(\"Heap segment not allowed\");\n+    }\n+\n+    public static class Runner {\n+\n+        static {\n+            System.loadLibrary(\"PassHeapSegment\");\n+        }\n+\n+        public static void main(String[] args) throws Throwable {\n+            MethodHandle handle = downcallHandle(\"test_return\", FunctionDescriptor.ofVoid(ADDRESS));\n+            MemorySegment upcallStub = upcallStub(Runner.class, \"target\", FunctionDescriptor.of(ADDRESS));\n+            handle.invoke(upcallStub);\n+        }\n+\n+        public static MemorySegment target() {\n+            return MemorySegment.ofArray(new byte[]{ 0, 1, 2 }); \/\/ should throw\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] specs() {\n+        return new Object[][]{\n+            { true },\n+            { false }\n+        };\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/foreign\/passheapsegment\/TestPassHeapSegment.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT void test_args(void* ptr) {}\n+\n+EXPORT void test_return(void* (*cb)(void)) {\n+    cb();\n+}\n","filename":"test\/jdk\/java\/foreign\/passheapsegment\/libPassHeapSegment.c","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"}]}