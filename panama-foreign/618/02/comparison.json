{"files":[{"patch":"@@ -359,0 +359,8 @@\n+  # Check if it's GNU date\n+  check_date=`$DATE --version 2>&1 | $GREP GNU`\n+  if test \"x$check_date\" != x; then\n+    IS_GNU_DATE=yes\n+  else\n+    IS_GNU_DATE=no\n+  fi\n+\n","filename":"make\/autoconf\/basic_tools.m4","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,3 +37,4 @@\n-      # distinguishing between WSL1 and WSL2. Assume only WSL2 has WSL_INTEROP\n-      # in \/run\/WSL\n-      if test -d \"\/run\/WSL\" ; then\n+      # distinguishing between WSL1 and WSL2.\n+      # Check whether \"Hyper-V\" appears in \/proc\/interrupts because WSL2 runs on Hyper-V.\n+      $GREP -q Hyper-V \/proc\/interrupts\n+      if test $? -eq 0; then\n","filename":"make\/autoconf\/basic_windows.m4","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -202,0 +202,6 @@\n+  elif test \"x$SOURCE_DATE_EPOCH\" != x; then\n+    if test \"x$IS_GNU_DATE\" = xyes; then\n+      COPYRIGHT_YEAR=`date --date=@$SOURCE_DATE_EPOCH +%Y`\n+    else\n+      COPYRIGHT_YEAR=`date -j -f %s $SOURCE_DATE_EPOCH +%Y`\n+    fi\n","filename":"make\/autoconf\/jdk-options.m4","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1157,1 +1157,1 @@\n-            revision: \"1.28+1.0\"\n+            revision: \"1.33+1.0\"\n","filename":"make\/conf\/jib-profiles.js","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -117,0 +117,1 @@\n+    static int copyrightYear;\n@@ -220,0 +221,4 @@\n+                    case \"-year\":\n+                        copyrightYear = Integer.parseInt(args[++i]);\n+                        break;\n+\n@@ -238,1 +243,1 @@\n-                severe(\"unknown or imcomplete arg(s): \" + currentArg);\n+                severe(\"unknown or incomplete arg(s): \" + currentArg);\n@@ -263,0 +268,4 @@\n+        if (copyrightYear == 0) {\n+            copyrightYear = ZonedDateTime.now(ZoneId.of(\"America\/Los_Angeles\")).getYear();\n+        }\n+\n@@ -295,0 +304,1 @@\n+                + \"\\t-year year     copyright year in output%n\"\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/CLDRConverter.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.Date;\n@@ -134,2 +135,1 @@\n-    static String getOracleCopyright() {\n-        int year = getYear();\n+    static String getOracleCopyright(int year) {\n@@ -143,2 +143,1 @@\n-    static String getOpenJDKCopyright() {\n-        int year = getYear();\n+    static String getOpenJDKCopyright(int year) {\n@@ -148,5 +147,0 @@\n-    private static int getYear() {\n-        return new GregorianCalendar(TimeZone.getTimeZone(\"America\/Los_Angeles\"),\n-                                         Locale.US).get(Calendar.YEAR);\n-    }\n-\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/CopyrightHeaders.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -201,1 +201,1 @@\n-            out.println(CopyrightHeaders.getOpenJDKCopyright());\n+            out.println(CopyrightHeaders.getOpenJDKCopyright(CLDRConverter.copyrightYear));\n@@ -269,1 +269,1 @@\n-            out.printf(CopyrightHeaders.getOpenJDKCopyright());\n+            out.printf(CopyrightHeaders.getOpenJDKCopyright(CLDRConverter.copyrightYear));\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/ResourceBundleGenerator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-import java.time.ZoneId;\n-import java.time.ZonedDateTime;\n@@ -36,0 +34,3 @@\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n@@ -39,0 +40,1 @@\n+import java.util.TimeZone;\n@@ -54,1 +56,1 @@\n-        if (args.length != 2) {\n+        if (args.length != 3) {\n@@ -56,1 +58,1 @@\n-                    + \" language-subtag-registry.txt LocaleEquivalentMaps.java\");\n+                    + \" language-subtag-registry.txt LocaleEquivalentMaps.java copyrightYear\");\n@@ -59,0 +61,1 @@\n+        copyrightYear = Integer.parseInt(args[2]);\n@@ -65,0 +68,1 @@\n+    private static int copyrightYear;\n@@ -247,3 +251,1 @@\n-        int year = ZonedDateTime.now(ZoneId\n-                .of(\"America\/Los_Angeles\")).getYear();\n-        return String.format(Locale.US, COPYRIGHT, year);\n+        return String.format(Locale.US, COPYRIGHT, copyrightYear);\n","filename":"make\/jdk\/src\/classes\/build\/tools\/generatelsrequivmaps\/EquivMapsGenerator.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+\t    -year $(COPYRIGHT_YEAR) \\\n@@ -102,1 +103,1 @@\n-\t$(TOOL_GENERATELSREQUIVMAPS) $< $@\n+\t$(TOOL_GENERATELSREQUIVMAPS) $< $@ $(COPYRIGHT_YEAR)\n","filename":"make\/modules\/java.base\/Gensrc.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-      NAME := jpackageapplauncher, \\\n+      NAME := jpackageapplauncheraux, \\\n@@ -97,1 +97,1 @@\n-      SYMBOLS_DIR := $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE)\/libjpackageapplauncher, \\\n+      SYMBOLS_DIR := $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE)\/libjpackageapplauncheraux, \\\n","filename":"make\/modules\/jdk.jpackage\/Lib.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+\t    -year $(COPYRIGHT_YEAR) \\\n","filename":"make\/modules\/jdk.localedata\/Gensrc.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1202,0 +1202,3 @@\n+reg_class p0_reg(P0);\n+reg_class p1_reg(P1);\n+\n@@ -5685,0 +5688,18 @@\n+operand pRegGov_P0()\n+%{\n+  constraint(ALLOC_IN_RC(p0_reg));\n+  match(RegVectMask);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand pRegGov_P1()\n+%{\n+  constraint(ALLOC_IN_RC(p1_reg));\n+  match(RegVectMask);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -16663,1 +16684,1 @@\n-  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n+  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU));\n@@ -16673,1 +16694,1 @@\n-                      fnoreg, fnoreg, fnoreg, StrIntrinsicNode::UU);\n+                      fnoreg, fnoreg, fnoreg, pnoreg, pnoreg, StrIntrinsicNode::UU);\n@@ -16681,1 +16702,1 @@\n-  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n+  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL));\n@@ -16690,1 +16711,1 @@\n-                      fnoreg, fnoreg, fnoreg, StrIntrinsicNode::LL);\n+                      fnoreg, fnoreg, fnoreg, pnoreg, pnoreg, StrIntrinsicNode::LL);\n@@ -16699,1 +16720,1 @@\n-  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n+  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL));\n@@ -16710,1 +16731,1 @@\n-                      $vtmp3$$FloatRegister, StrIntrinsicNode::UL);\n+                      $vtmp3$$FloatRegister, pnoreg, pnoreg, StrIntrinsicNode::UL);\n@@ -16719,1 +16740,1 @@\n-  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n+  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU));\n@@ -16730,1 +16751,1 @@\n-                      $vtmp3$$FloatRegister,StrIntrinsicNode::LU);\n+                      $vtmp3$$FloatRegister, pnoreg, pnoreg, StrIntrinsicNode::LU);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":29,"deletions":8,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -5554,0 +5554,99 @@\n+\/\/ Intrisics for String.compareTo()\n+\n+\/\/ Note that Z registers alias the corresponding NEON registers, we declare the vector operands of\n+\/\/ these string_compare variants as NEON register type for convenience so that the prototype of\n+\/\/ string_compare can be shared with all variants.\n+\n+\n+instruct string_compareLL_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::LL);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct string_compareLU_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::LU);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct string_compareUL_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::UL);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct string_compareUU_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::UU);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":99,"deletions":0,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -3047,0 +3047,36 @@\n+\/\/ Intrisics for String.compareTo()\n+\n+\/\/ Note that Z registers alias the corresponding NEON registers, we declare the vector operands of\n+\/\/ these string_compare variants as NEON register type for convenience so that the prototype of\n+\/\/ string_compare can be shared with all variants.\n+\n+dnl\n+define(`STRING_COMPARETO', `\n+instruct string_compare$1_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::$1));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::$1);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}')dnl\n+dnl              $1\n+STRING_COMPARETO(LL)\n+STRING_COMPARETO(LU)\n+STRING_COMPARETO(UL)\n+STRING_COMPARETO(UU)\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -989,8 +989,1 @@\n-      \/\/ FIXME: OMG this is a horrible kludge.  Any offset from an\n-      \/\/ address that matches klass_offset_in_bytes() will be loaded\n-      \/\/ as a word, not a long.\n-      if (UseCompressedClassPointers && addr->disp() == oopDesc::klass_offset_in_bytes()) {\n-        __ ldrw(dest->as_register(), as_Address(from_addr));\n-      } else {\n-        __ ldr(dest->as_register(), as_Address(from_addr));\n-      }\n+      __ ldr(dest->as_register(), as_Address(from_addr));\n@@ -1035,4 +1028,0 @@\n-  } else if (type == T_ADDRESS && addr->disp() == oopDesc::klass_offset_in_bytes()) {\n-    if (UseCompressedClassPointers) {\n-      __ decode_klass_not_null(dest->as_register());\n-    }\n@@ -2596,0 +2585,16 @@\n+void LIR_Assembler::emit_load_klass(LIR_OpLoadKlass* op) {\n+  Register obj = op->obj()->as_pointer_register();\n+  Register result = op->result_opr()->as_pointer_register();\n+\n+  CodeEmitInfo* info = op->info();\n+  if (info != NULL) {\n+    add_debug_info_for_null_check_here(info);\n+  }\n+\n+  if (UseCompressedClassPointers) {\n+    __ ldrw(result, Address (obj, oopDesc::klass_offset_in_bytes()));\n+    __ decode_klass_not_null(result);\n+  } else {\n+    __ ldr(result, Address (obj, oopDesc::klass_offset_in_bytes()));\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -679,1 +679,2 @@\n-    FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3, int ae) {\n+    FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3,\n+    PRegister pgtmp1, PRegister pgtmp2, int ae) {\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-                      FloatRegister vtmp2, FloatRegister vtmp3, int ae);\n+                      FloatRegister vtmp2, FloatRegister vtmp3,\n+                      PRegister pgtmp1, PRegister pgtmp2, int ae);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -271,0 +271,2 @@\n+CONSTANT_REGISTER_DECLARATION(PRegister, pnoreg, (-1));\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,0 +191,2 @@\n+REGISTER_DEFINITION(PRegister, pnoreg);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/register_definitions_aarch64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5034,0 +5034,91 @@\n+  enum string_compare_mode {\n+    LL,\n+    LU,\n+    UL,\n+    UU,\n+  };\n+\n+  \/\/ The following registers are declared in aarch64.ad\n+  \/\/ r0  = result\n+  \/\/ r1  = str1\n+  \/\/ r2  = cnt1\n+  \/\/ r3  = str2\n+  \/\/ r4  = cnt2\n+  \/\/ r10 = tmp1\n+  \/\/ r11 = tmp2\n+  \/\/ z0  = ztmp1\n+  \/\/ z1  = ztmp2\n+  \/\/ p0  = pgtmp1\n+  \/\/ p1  = pgtmp2\n+  address generate_compare_long_string_sve(string_compare_mode mode) {\n+    __ align(CodeEntryAlignment);\n+    address entry = __ pc();\n+    Register result = r0, str1 = r1, cnt1 = r2, str2 = r3, cnt2 = r4,\n+             tmp1 = r10, tmp2 = r11;\n+\n+    Label LOOP, MATCH, DONE, NOMATCH;\n+    Register vec_len = tmp1;\n+    Register idx = tmp2;\n+    \/\/ The minimum of the string lengths has been stored in cnt2.\n+    Register cnt = cnt2;\n+    FloatRegister ztmp1 = z0, ztmp2 = z1;\n+    PRegister pgtmp1 = p0, pgtmp2 = p1;\n+\n+    if (mode == LL) {\n+      __ sve_cntb(vec_len);\n+    } else {\n+      __ sve_cnth(vec_len);\n+    }\n+\n+    __ mov(idx, 0);\n+    __ sve_whilelt(pgtmp1, mode == LL ? __ B : __ H, idx, cnt);\n+\n+    __ bind(LOOP);\n+      switch (mode) {\n+        case LL:\n+          __ sve_ld1b(ztmp1, __ B, pgtmp1, Address(str1, idx));\n+          __ sve_ld1b(ztmp2, __ B, pgtmp1, Address(str2, idx));\n+          break;\n+        case LU:\n+          __ sve_ld1b(ztmp1, __ H, pgtmp1, Address(str1, idx));\n+          __ sve_ld1h(ztmp2, __ H, pgtmp1, Address(str2, idx, Address::lsl(1)));\n+          break;\n+        case UL:\n+          __ sve_ld1h(ztmp1, __ H, pgtmp1, Address(str1, idx, Address::lsl(1)));\n+          __ sve_ld1b(ztmp2, __ H, pgtmp1, Address(str2, idx));\n+          break;\n+        case UU:\n+          __ sve_ld1h(ztmp1, __ H, pgtmp1, Address(str1, idx, Address::lsl(1)));\n+          __ sve_ld1h(ztmp2, __ H, pgtmp1, Address(str2, idx, Address::lsl(1)));\n+          break;\n+        default: ShouldNotReachHere();\n+      }\n+      __ add(idx, idx, vec_len);\n+\n+      \/\/ Compare strings.\n+      __ sve_cmp(Assembler::NE, pgtmp2, mode == LL ? __ B : __ H, pgtmp1, ztmp1, ztmp2);\n+      __ br(__ NE, MATCH);\n+      __ sve_whilelt(pgtmp1, mode == LL ? __ B : __ H, idx, cnt);\n+      __ br(__ LT, LOOP);\n+\n+      \/\/ The result has been computed in the caller prior to entering this stub.\n+      __ b(DONE);\n+\n+    __ bind(MATCH);\n+\n+      \/\/ Crop the vector to find its location.\n+      __ sve_brkb(pgtmp2, pgtmp1, pgtmp2, false \/* isMerge *\/);\n+\n+      \/\/ Extract the first different characters of each string.\n+      __ sve_lasta(rscratch1, mode == LL ? __ B : __ H, pgtmp2, ztmp1);\n+      __ sve_lasta(rscratch2, mode == LL ? __ B : __ H, pgtmp2, ztmp2);\n+\n+      \/\/ Compute the difference of the first different characters.\n+      __ sub(result, rscratch1, rscratch2);\n+\n+    __ bind(DONE);\n+      __ ret(lr);\n+\n+    return entry;\n+  }\n+\n@@ -5156,0 +5247,1 @@\n+    if (UseSVE == 0) {\n@@ -5164,0 +5256,10 @@\n+    } else {\n+      StubRoutines::aarch64::_compare_long_string_LL\n+          = generate_compare_long_string_sve(LL);\n+      StubRoutines::aarch64::_compare_long_string_UU\n+          = generate_compare_long_string_sve(UU);\n+      StubRoutines::aarch64::_compare_long_string_LU\n+          = generate_compare_long_string_sve(LU);\n+      StubRoutines::aarch64::_compare_long_string_UL\n+          = generate_compare_long_string_sve(UL);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":102,"deletions":0,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -723,5 +723,1 @@\n-      if (UseCompressedClassPointers && addr->disp() == oopDesc::klass_offset_in_bytes()) {\n-        __ ldr_u32(dest->as_pointer_register(), as_Address(addr));\n-      } else {\n-        __ ldr(dest->as_pointer_register(), as_Address(addr));\n-      }\n+      __ ldr(dest->as_pointer_register(), as_Address(addr));\n@@ -2448,0 +2444,15 @@\n+void LIR_Assembler::emit_load_klass(LIR_OpLoadKlass* op) {\n+  Register obj = op->obj()->as_pointer_register();\n+  Register result = op->result_opr()->as_pointer_register();\n+\n+  CodeEmitInfo* info = op->info();\n+  if (info != NULL) {\n+    add_debug_info_for_null_check_here(info);\n+  }\n+\n+  if (UseCompressedClassPointers) { \/\/ On 32 bit arm??\n+    __ ldr_u32(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n+  } else {\n+    __ ldr(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -815,6 +815,1 @@\n-        if (offset == oopDesc::klass_offset_in_bytes() && UseCompressedClassPointers) {\n-          __ lwz(to_reg->as_register(), offset, base);\n-          __ decode_klass_not_null(to_reg->as_register());\n-        } else {\n-          __ ld(to_reg->as_register(), offset, base);\n-        }\n+        __ ld(to_reg->as_register(), offset, base);\n@@ -2735,0 +2730,22 @@\n+void LIR_Assembler::emit_load_klass(LIR_OpLoadKlass* op) {\n+  Register obj = op->obj()->as_pointer_register();\n+  Register result = op->result_opr()->as_pointer_register();\n+\n+  CodeEmitInfo* info = op->info();\n+  if (info != NULL) {\n+    if (info != NULL) {\n+      if (!os::zero_page_read_protected() || !ImplicitNullChecks) {\n+        explicit_null_check(obj, info);\n+      } else {\n+        add_debug_info_for_null_check_here(info);\n+      }\n+    }\n+  }\n+\n+  if (UseCompressedClassPointers) {\n+    __ lwz(result, oopDesc::klass_offset_in_bytes(), obj);\n+    __ decode_klass_not_null(result);\n+  } else {\n+    __ ld(result, oopDesc::klass_offset_in_bytes(), obj);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -953,6 +953,1 @@\n-      if (UseCompressedClassPointers && addr->disp() == oopDesc::klass_offset_in_bytes()) {\n-        __ z_llgf(dest->as_register(), disp_value, disp_reg, src);\n-        __ decode_klass_not_null(dest->as_register());\n-      } else {\n-        __ z_lg(dest->as_register(), disp_value, disp_reg, src);\n-      }\n+      __ z_lg(dest->as_register(), disp_value, disp_reg, src);\n@@ -2757,0 +2752,16 @@\n+void LIR_Assembler::emit_load_klass(LIR_OpLoadKlass* op) {\n+  Register obj = op->obj()->as_pointer_register();\n+  Register result = op->result_opr()->as_pointer_register();\n+\n+  CodeEmitInfo* info = op->info();\n+  if (info != NULL) {\n+    add_debug_info_for_null_check_here(info);\n+  }\n+\n+  if (UseCompressedClassPointers) {\n+    __ z_llgf(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n+    __ decode_klass_not_null(result);\n+  } else {\n+    __ z_lg(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1187,1 +1187,0 @@\n-  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n@@ -1260,5 +1259,1 @@\n-      if (UseCompressedClassPointers && addr->disp() == oopDesc::klass_offset_in_bytes()) {\n-        __ movl(dest->as_register(), from_addr);\n-      } else {\n-        __ movptr(dest->as_register(), from_addr);\n-      }\n+      __ movptr(dest->as_register(), from_addr);\n@@ -1370,6 +1365,0 @@\n-  } else if (type == T_ADDRESS && addr->disp() == oopDesc::klass_offset_in_bytes()) {\n-#ifdef _LP64\n-    if (UseCompressedClassPointers) {\n-      __ decode_klass_not_null(dest->as_register(), tmp_load_klass);\n-    }\n-#endif\n@@ -3531,0 +3520,17 @@\n+void LIR_Assembler::emit_load_klass(LIR_OpLoadKlass* op) {\n+  Register obj = op->obj()->as_pointer_register();\n+  Register result = op->result_opr()->as_pointer_register();\n+\n+  CodeEmitInfo* info = op->info();\n+  if (info != NULL) {\n+    add_debug_info_for_null_check_here(info);\n+  }\n+\n+#ifdef _LP64\n+  if (UseCompressedClassPointers) {\n+    __ movl(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n+    __ decode_klass_not_null(result, rscratch1);\n+  } else\n+#endif\n+    __ movptr(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -6199,1 +6199,1 @@\n-  predicate(Matcher::vector_length(n) <= 8 && VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(Matcher::vector_length(n) <= 8 && !n->as_ShiftV()->is_var_shift());\n@@ -6219,1 +6219,1 @@\n-  predicate(Matcher::vector_length(n) == 16 && VectorNode::is_vshift_cnt(n->in(2)) &&\n+  predicate(Matcher::vector_length(n) == 16 && !n->as_ShiftV()->is_var_shift() &&\n@@ -6244,1 +6244,1 @@\n-  predicate(Matcher::vector_length(n) == 16 && VectorNode::is_vshift_cnt(n->in(2)) &&\n+  predicate(Matcher::vector_length(n) == 16 && !n->as_ShiftV()->is_var_shift() &&\n@@ -6265,1 +6265,1 @@\n-  predicate(Matcher::vector_length(n) == 32 && VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(Matcher::vector_length(n) == 32 && !n->as_ShiftV()->is_var_shift());\n@@ -6290,1 +6290,1 @@\n-  predicate(Matcher::vector_length(n) == 64 && VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(Matcher::vector_length(n) == 64 && !n->as_ShiftV()->is_var_shift());\n@@ -6323,1 +6323,1 @@\n-  predicate(VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(!n->as_ShiftV()->is_var_shift());\n@@ -6354,1 +6354,1 @@\n-  predicate(VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(!n->as_ShiftV()->is_var_shift());\n@@ -6408,1 +6408,1 @@\n-  predicate(VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(!n->as_ShiftV()->is_var_shift());\n@@ -6449,1 +6449,1 @@\n-  predicate(VectorNode::is_vshift_cnt(n->in(2)) && UseAVX <= 2);\n+  predicate(!n->as_ShiftV()->is_var_shift() && UseAVX <= 2);\n@@ -6478,1 +6478,1 @@\n-  predicate(VectorNode::is_vshift_cnt(n->in(2)) && UseAVX > 2);\n+  predicate(!n->as_ShiftV()->is_var_shift() && UseAVX > 2);\n@@ -6492,1 +6492,1 @@\n-            !VectorNode::is_vshift_cnt(n->in(2)) &&\n+            n->as_ShiftV()->is_var_shift() &&\n@@ -6512,1 +6512,1 @@\n-            !VectorNode::is_vshift_cnt(n->in(2)) &&\n+            n->as_ShiftV()->is_var_shift() &&\n@@ -6540,1 +6540,1 @@\n-            !VectorNode::is_vshift_cnt(n->in(2)) &&\n+            n->as_ShiftV()->is_var_shift() &&\n@@ -6576,1 +6576,1 @@\n-            !VectorNode::is_vshift_cnt(n->in(2)) &&\n+            n->as_ShiftV()->is_var_shift() &&\n@@ -6595,1 +6595,1 @@\n-            !VectorNode::is_vshift_cnt(n->in(2)) &&\n+            n->as_ShiftV()->is_var_shift() &&\n@@ -6619,1 +6619,1 @@\n-            !VectorNode::is_vshift_cnt(n->in(2)) &&\n+            n->as_ShiftV()->is_var_shift() &&\n@@ -6644,1 +6644,1 @@\n-            !VectorNode::is_vshift_cnt(n->in(2)) &&\n+            n->as_ShiftV()->is_var_shift() &&\n@@ -6679,1 +6679,1 @@\n-  predicate(!VectorNode::is_vshift_cnt(n->in(2)) &&\n+  predicate(n->as_ShiftV()->is_var_shift() &&\n@@ -6700,1 +6700,1 @@\n-  predicate(!VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(n->as_ShiftV()->is_var_shift());\n@@ -6717,1 +6717,1 @@\n-  predicate(!VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(n->as_ShiftV()->is_var_shift());\n@@ -6734,1 +6734,1 @@\n-            !VectorNode::is_vshift_cnt(n->in(2)) &&\n+            n->as_ShiftV()->is_var_shift() &&\n@@ -6749,1 +6749,1 @@\n-  predicate(!VectorNode::is_vshift_cnt(n->in(2)) &&\n+  predicate(n->as_ShiftV()->is_var_shift() &&\n@@ -9036,0 +9036,1 @@\n+  predicate(!n->as_ShiftV()->is_var_shift());\n@@ -9044,1 +9045,0 @@\n-    bool is_varshift = !VectorNode::is_vshift_cnt_opcode(in(2)->isa_Mach()->ideal_Opcode());\n@@ -9046,1 +9046,17 @@\n-                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, is_varshift);\n+                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, false);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vlshiftv_reg_masked(vec dst, vec src2, kReg mask) %{\n+  predicate(n->as_ShiftV()->is_var_shift());\n+  match(Set dst (LShiftVS (Binary dst src2) mask));\n+  match(Set dst (LShiftVI (Binary dst src2) mask));\n+  match(Set dst (LShiftVL (Binary dst src2) mask));\n+  format %{ \"vplshiftv_masked $dst, $dst, $src2, $mask\\t! lshift masked operation\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int opc = this->ideal_Opcode();\n+    __ evmasked_op(opc, bt, $mask$$KRegister, $dst$$XMMRegister,\n+                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, true);\n@@ -9082,0 +9098,1 @@\n+  predicate(!n->as_ShiftV()->is_var_shift());\n@@ -9090,1 +9107,0 @@\n-    bool is_varshift = !VectorNode::is_vshift_cnt_opcode(in(2)->isa_Mach()->ideal_Opcode());\n@@ -9092,1 +9108,17 @@\n-                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, is_varshift);\n+                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, false);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vrshiftv_reg_masked(vec dst, vec src2, kReg mask) %{\n+  predicate(n->as_ShiftV()->is_var_shift());\n+  match(Set dst (RShiftVS (Binary dst src2) mask));\n+  match(Set dst (RShiftVI (Binary dst src2) mask));\n+  match(Set dst (RShiftVL (Binary dst src2) mask));\n+  format %{ \"vprshiftv_masked $dst, $dst, $src2, $mask\\t! rshift masked operation\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int opc = this->ideal_Opcode();\n+    __ evmasked_op(opc, bt, $mask$$KRegister, $dst$$XMMRegister,\n+                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, true);\n@@ -9128,0 +9160,1 @@\n+  predicate(!n->as_ShiftV()->is_var_shift());\n@@ -9136,1 +9169,0 @@\n-    bool is_varshift = !VectorNode::is_vshift_cnt_opcode(in(2)->isa_Mach()->ideal_Opcode());\n@@ -9138,1 +9170,17 @@\n-                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, is_varshift);\n+                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, false);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vurshiftv_reg_masked(vec dst, vec src2, kReg mask) %{\n+  predicate(n->as_ShiftV()->is_var_shift());\n+  match(Set dst (URShiftVS (Binary dst src2) mask));\n+  match(Set dst (URShiftVI (Binary dst src2) mask));\n+  match(Set dst (URShiftVL (Binary dst src2) mask));\n+  format %{ \"vpurshiftv_masked $dst, $dst, $src2, $mask\\t! urshift masked operation\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int opc = this->ideal_Opcode();\n+    __ evmasked_op(opc, bt, $mask$$KRegister, $dst$$XMMRegister,\n+                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, true);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":76,"deletions":28,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -72,2 +72,1 @@\n-\/\/ No performance work done here yet.\n-define_pd_global(bool, CompactStrings, false);\n+define_pd_global(bool, CompactStrings, true);\n","filename":"src\/hotspot\/cpu\/zero\/globals_zero.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1269,1 +1269,1 @@\n-  BlockListList* _predecessors;\n+  BlockListList* _predecessors; \/\/ Each index i will hold predecessors of block with id i\n@@ -1280,1 +1280,1 @@\n-    _blocks = new BlockList();\n+    _blocks = new BlockList(BlockBegin::number_of_blocks());\n@@ -1282,1 +1282,0 @@\n-    int i;\n@@ -1286,1 +1285,1 @@\n-      for (i = 0; i < _blocks->length(); i++) {\n+      for (int i = 0; i < _blocks->length(); i++) {\n@@ -1291,1 +1290,1 @@\n-    for (i = 0; i < _blocks->length(); i++) {\n+    for (int i = 0; i < _blocks->length(); i++) {\n@@ -1293,21 +1292,1 @@\n-      BlockList* preds = _predecessors->at(block->block_id());\n-      if (preds == NULL) {\n-        assert(block->number_of_preds() == 0, \"should be the same\");\n-        continue;\n-      }\n-\n-      \/\/ clone the pred list so we can mutate it\n-      BlockList* pred_copy = new BlockList();\n-      int j;\n-      for (j = 0; j < block->number_of_preds(); j++) {\n-        pred_copy->append(block->pred_at(j));\n-      }\n-      \/\/ sort them in the same order\n-      preds->sort(cmp);\n-      pred_copy->sort(cmp);\n-      int length = MIN2(preds->length(), block->number_of_preds());\n-      for (j = 0; j < block->number_of_preds(); j++) {\n-        assert(preds->at(j) == pred_copy->at(j), \"must match\");\n-      }\n-\n-      assert(preds->length() == block->number_of_preds(), \"should be the same\");\n+      verify_block_preds_against_collected_preds(block);\n@@ -1319,13 +1298,11 @@\n-    BlockEnd* be = block->end();\n-    int n = be->number_of_sux();\n-    int i;\n-    for (i = 0; i < n; i++) {\n-      BlockBegin* sux = be->sux_at(i);\n-      assert(!sux->is_set(BlockBegin::exception_entry_flag), \"must not be xhandler\");\n-\n-      BlockList* preds = _predecessors->at_grow(sux->block_id(), NULL);\n-      if (preds == NULL) {\n-        preds = new BlockList();\n-        _predecessors->at_put(sux->block_id(), preds);\n-      }\n-      preds->append(block);\n+    verify_successor_xentry_flag(block);\n+    collect_predecessors(block);\n+  }\n+\n+ private:\n+  void verify_successor_xentry_flag(const BlockBegin* block) const {\n+    for (int i = 0; i < block->end()->number_of_sux(); i++) {\n+      assert(!block->end()->sux_at(i)->is_set(BlockBegin::exception_entry_flag), \"must not be xhandler\");\n+    }\n+    for (int i = 0; i < block->number_of_exception_handlers(); i++) {\n+      assert(block->exception_handler_at(i)->is_set(BlockBegin::exception_entry_flag), \"must be xhandler\");\n@@ -1333,0 +1310,1 @@\n+  }\n@@ -1334,4 +1312,8 @@\n-    n = block->number_of_exception_handlers();\n-    for (i = 0; i < n; i++) {\n-      BlockBegin* sux = block->exception_handler_at(i);\n-      assert(sux->is_set(BlockBegin::exception_entry_flag), \"must be xhandler\");\n+  void collect_predecessors(BlockBegin* block) {\n+    for (int i = 0; i < block->end()->number_of_sux(); i++) {\n+      collect_predecessor(block, block->end()->sux_at(i));\n+    }\n+    for (int i = 0; i < block->number_of_exception_handlers(); i++) {\n+      collect_predecessor(block, block->exception_handler_at(i));\n+    }\n+  }\n@@ -1339,6 +1321,27 @@\n-      BlockList* preds = _predecessors->at_grow(sux->block_id(), NULL);\n-      if (preds == NULL) {\n-        preds = new BlockList();\n-        _predecessors->at_put(sux->block_id(), preds);\n-      }\n-      preds->append(block);\n+  void collect_predecessor(BlockBegin* const pred, const BlockBegin* sux) {\n+    BlockList* preds = _predecessors->at_grow(sux->block_id(), NULL);\n+    if (preds == NULL) {\n+      preds = new BlockList();\n+      _predecessors->at_put(sux->block_id(), preds);\n+    }\n+    preds->append(pred);\n+  }\n+\n+  void verify_block_preds_against_collected_preds(const BlockBegin* block) const {\n+    BlockList* preds = _predecessors->at(block->block_id());\n+    if (preds == NULL) {\n+      assert(block->number_of_preds() == 0, \"should be the same\");\n+      return;\n+    }\n+    assert(preds->length() == block->number_of_preds(), \"should be the same\");\n+\n+    \/\/ clone the pred list so we can mutate it\n+    BlockList* pred_copy = new BlockList();\n+    for (int j = 0; j < block->number_of_preds(); j++) {\n+      pred_copy->append(block->pred_at(j));\n+    }\n+    \/\/ sort them in the same order\n+    preds->sort(cmp);\n+    pred_copy->sort(cmp);\n+    for (int j = 0; j < block->number_of_preds(); j++) {\n+      assert(preds->at(j) == pred_copy->at(j), \"must match\");\n","filename":"src\/hotspot\/share\/c1\/c1_IR.cpp","additions":52,"deletions":49,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2001,8 +2001,0 @@\n-  void swap_sux() {\n-    assert(number_of_sux() == 2, \"wrong number of successors\");\n-    BlockList* s = sux();\n-    BlockBegin* t = s->at(0); s->at_put(0, s->at(1)); s->at_put(1, t);\n-    _cond = negate(_cond);\n-    set_flag(UnorderedIsTrueFlag, !check_flag(UnorderedIsTrueFlag));\n-  }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -883,0 +883,13 @@\n+\/\/ LIR_OpLoadKlass\n+    case lir_load_klass:\n+    {\n+      LIR_OpLoadKlass* opLoadKlass = op->as_OpLoadKlass();\n+      assert(opLoadKlass != NULL, \"must be\");\n+\n+      do_input(opLoadKlass->_obj);\n+      do_output(opLoadKlass->_result);\n+      if (opLoadKlass->_info) do_info(opLoadKlass->_info);\n+      break;\n+    }\n+\n+\n@@ -1052,0 +1065,4 @@\n+void LIR_OpLoadKlass::emit_code(LIR_Assembler* masm) {\n+  masm->emit_load_klass(this);\n+}\n+\n@@ -1973,0 +1990,5 @@\n+void LIR_OpLoadKlass::print_instr(outputStream* out) const {\n+  obj()->print(out);        out->print(\" \");\n+  result_opr()->print(out); out->print(\" \");\n+}\n+\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -898,0 +898,1 @@\n+class    LIR_OpLoadKlass;\n@@ -942,0 +943,1 @@\n+      , lir_load_klass\n@@ -1151,0 +1153,1 @@\n+  virtual LIR_OpLoadKlass* as_OpLoadKlass() { return NULL; }\n@@ -1823,0 +1826,19 @@\n+class LIR_OpLoadKlass: public LIR_Op {\n+  friend class LIR_OpVisitState;\n+\n+ private:\n+  LIR_Opr _obj;\n+  CodeEmitInfo* _info;\n+ public:\n+  LIR_OpLoadKlass(LIR_Opr obj, LIR_Opr result, CodeEmitInfo* info)\n+    : LIR_Op(lir_load_klass, result, NULL)\n+    , _obj(obj)\n+    , _info(info) {}\n+\n+  LIR_Opr obj()        const { return _obj;  }\n+  CodeEmitInfo* info() const { return _info; }\n+\n+  virtual LIR_OpLoadKlass* as_OpLoadKlass() { return this; }\n+  virtual void emit_code(LIR_Assembler* masm);\n+  void print_instr(outputStream* out) const PRODUCT_RETURN;\n+};\n@@ -2265,0 +2287,3 @@\n+\n+  void load_klass(LIR_Opr obj, LIR_Opr result, CodeEmitInfo* info) { append(new LIR_OpLoadKlass(obj, result, info)); }\n+\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -200,0 +200,1 @@\n+  void emit_load_klass(LIR_OpLoadKlass* op);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1234,0 +1234,4 @@\n+void LIRGenerator::load_klass(LIR_Opr obj, LIR_Opr klass, CodeEmitInfo* null_check_info) {\n+  __ load_klass(obj, klass, null_check_info);\n+}\n+\n@@ -1240,1 +1244,1 @@\n-  LIR_Opr temp = new_register(T_METADATA);\n+  LIR_Opr temp = new_register(T_ADDRESS);\n@@ -1249,4 +1253,3 @@\n-  \/\/ FIXME T_ADDRESS should actually be T_METADATA but it can't because the\n-  \/\/ meaning of these two is mixed up (see JDK-8026837).\n-  __ move(new LIR_Address(rcvr.result(), oopDesc::klass_offset_in_bytes(), T_ADDRESS), temp, info);\n-  __ move_wide(new LIR_Address(temp, in_bytes(Klass::java_mirror_offset()), T_ADDRESS), temp);\n+  LIR_Opr klass = new_register(T_METADATA);\n+  load_klass(rcvr.result(), klass, info);\n+  __ move_wide(new LIR_Address(klass, in_bytes(Klass::java_mirror_offset()), T_ADDRESS), temp);\n@@ -1325,1 +1328,1 @@\n-  __ move(new LIR_Address(value.result(), oopDesc::klass_offset_in_bytes(), T_ADDRESS), klass, NULL);\n+  load_klass(value.result(), klass, NULL);\n@@ -3575,1 +3578,1 @@\n-  __ move(new LIR_Address(array, oopDesc::klass_offset_in_bytes(), T_ADDRESS), klass, null_check_info);\n+  load_klass(array, klass, null_check_info);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -242,0 +242,2 @@\n+  void load_klass(LIR_Opr obj, LIR_Opr klass, CodeEmitInfo* null_check_info);\n+\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1655,0 +1655,1 @@\n+\n@@ -1657,1 +1658,2 @@\n-  out->print_cr(\"instanceKlass %s\", CURRENT_ENV->replay_name(task()->method()->method_holder()));\n+  ciInstanceKlass::dump_replay_instanceKlass(out, task()->method()->method_holder());\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -735,0 +735,13 @@\n+void ciInstanceKlass::dump_replay_instanceKlass(outputStream* out, InstanceKlass* ik) {\n+  if (ik->is_hidden()) {\n+    const char *name = CURRENT_ENV->dyno_name(ik);\n+    if (name != NULL) {\n+      out->print_cr(\"instanceKlass %s # %s\", name, ik->name()->as_quoted_ascii());\n+    } else {\n+      out->print_cr(\"# instanceKlass %s\", ik->name()->as_quoted_ascii());\n+    }\n+  } else {\n+    out->print_cr(\"instanceKlass %s\", ik->name()->as_quoted_ascii());\n+  }\n+}\n+\n@@ -746,10 +759,1 @@\n-      if (isub->is_hidden()) {\n-        const char *name = CURRENT_ENV->dyno_name(isub);\n-        if (name != NULL) {\n-          out->print_cr(\"instanceKlass %s # %s\", name, sub->name()->as_quoted_ascii());\n-        } else {\n-          out->print_cr(\"# instanceKlass %s\", sub->name()->as_quoted_ascii());\n-        }\n-      } else {\n-        out->print_cr(\"instanceKlass %s\", sub->name()->as_quoted_ascii());\n-      }\n+      dump_replay_instanceKlass(out, isub);\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -296,0 +296,3 @@\n+  static void dump_replay_instanceKlass(outputStream* out, InstanceKlass* ik);\n+\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+  bool _inline_late;\n@@ -723,1 +724,1 @@\n-  \/\/ compile <klass> <name> <signature> <entry_bci> <comp_level> inline <count> (<depth> <bci> <klass> <name> <signature>)*\n+  \/\/ compile <klass> <name> <signature> <entry_bci> <comp_level> inline <count> (<depth> <bci> <inline_late> <klass> <name> <signature>)*\n@@ -765,0 +766,8 @@\n+        int inline_late = 0;\n+        if (_version >= 2) {\n+          inline_late = parse_int(\"inline_late\");\n+          if (had_error()) {\n+              break;\n+          }\n+        }\n+\n@@ -769,1 +778,1 @@\n-        new_ciInlineRecord(inl_method, bci, depth);\n+        new_ciInlineRecord(inl_method, bci, depth, inline_late);\n@@ -1230,1 +1239,1 @@\n-  ciInlineRecord* new_ciInlineRecord(Method* method, int bci, int depth) {\n+  ciInlineRecord* new_ciInlineRecord(Method* method, int bci, int depth, int inline_late) {\n@@ -1237,0 +1246,1 @@\n+    rec->_inline_late = inline_late;\n@@ -1473,1 +1483,1 @@\n-bool ciReplay::should_inline(void* data, ciMethod* method, int bci, int inline_depth) {\n+bool ciReplay::should_inline(void* data, ciMethod* method, int bci, int inline_depth, bool& should_delay) {\n@@ -1475,1 +1485,1 @@\n-    GrowableArray<ciInlineRecord*>*  records = (GrowableArray<ciInlineRecord*>*)data;\n+    GrowableArray<ciInlineRecord*>* records = (GrowableArray<ciInlineRecord*>*)data;\n@@ -1478,1 +1488,6 @@\n-    return CompileReplay::find_ciInlineRecord(records, method->get_Method(), bci, inline_depth) != NULL;\n+    ciInlineRecord* record = CompileReplay::find_ciInlineRecord(records, method->get_Method(), bci, inline_depth);\n+    if (record == NULL) {\n+      return false;\n+    }\n+    should_delay = record->_inline_late;\n+    return true;\n@@ -1482,1 +1497,6 @@\n-    return replay_state->find_ciInlineRecord(method->get_Method(), bci, inline_depth) != NULL;\n+    ciInlineRecord* record = replay_state->find_ciInlineRecord(method->get_Method(), bci, inline_depth);\n+    if (record == NULL) {\n+      return false;\n+    }\n+    should_delay = record->_inline_late;\n+    return true;\n@@ -1489,1 +1509,1 @@\n-    GrowableArray<ciInlineRecord*>*  records = (GrowableArray<ciInlineRecord*>*)data;\n+    GrowableArray<ciInlineRecord*>* records = (GrowableArray<ciInlineRecord*>*)data;\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-  static bool should_inline(void* data, ciMethod* method, int bci, int inline_depth);\n+  static bool should_inline(void* data, ciMethod* method, int bci, int inline_depth, bool& should_delay);\n@@ -138,1 +138,2 @@\n-#define REPLAY_VERSION 1 \/\/ current version, bump up for incompatible changes\n+\/\/ 2: incremental inlining support (8254108)\n+#define REPLAY_VERSION 2 \/\/ current version, bump up for incompatible changes\n","filename":"src\/hotspot\/share\/ci\/ciReplay.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,12 +29,17 @@\n- *\n- * SipHash reference C implementation\n- *\n- * Copyright (c) 2016 Jean-Philippe Aumasson <jeanphilippe.aumasson@gmail.com>\n- *\n- * To the extent possible under law, the author(s) have dedicated all copyright\n- * and related and neighboring rights to this software to the public domain\n- * worldwide. This software is distributed without any warranty.\n- *\n- * You should have received a copy of the CC0 Public Domain Dedication along\n- * with this software. If not, see\n- * <http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/>.\n+ *\/\n+\n+\/*\n+   SipHash reference C implementation\n+\n+   Copyright (c) 2012-2021 Jean-Philippe Aumasson\n+   <jeanphilippe.aumasson@gmail.com>\n+   Copyright (c) 2012-2014 Daniel J. Bernstein <djb@cr.yp.to>\n+\n+   To the extent possible under law, the author(s) have dedicated all copyright\n+   and related and neighboring rights to this software to the public domain\n+   worldwide. This software is distributed without any warranty.\n+\n+   You should have received a copy of the CC0 Public Domain Dedication along\n+   with\n+   this software. If not, see\n+   <http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/>.\n@@ -138,1 +143,3 @@\n-uint32_t AltHashing::halfsiphash_32(uint64_t seed, const uint8_t* data, int len) {\n+uint32_t AltHashing::halfsiphash_32(uint64_t seed, const void* in, int len) {\n+\n+  const unsigned char* data = (const unsigned char*)in;\n","filename":"src\/hotspot\/share\/classfile\/altHashing.cpp","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-  static uint32_t halfsiphash_32(uint64_t seed, const uint8_t* data, int len);\n+  static uint32_t halfsiphash_32(uint64_t seed, const void* in, int len);\n","filename":"src\/hotspot\/share\/classfile\/altHashing.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,0 +94,2 @@\n+\n+#ifdef USE_LIBRARY_BASED_TLS_ONLY\n@@ -95,0 +97,5 @@\n+#else\n+\/\/ \"_lookup_shared_first\" can get highly contended with many cores if multiple threads\n+\/\/ are updating \"lookup success history\" in a global shared variable. If built-in TLS is available, use it.\n+static THREAD_LOCAL bool _lookup_shared_first = false;\n+#endif\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -354,1 +354,0 @@\n-  template(jdk_incubator_foreign_MemoryAccess,       \"jdk\/incubator\/foreign\/MemoryAccess\")        \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -481,0 +481,4 @@\n+    } else {\n+      \/\/ This inline cache is a megamorphic vtable call. Those ICs never hold\n+      \/\/ any Metadata and should therefore never be cleaned by this function.\n+      return true;\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -414,0 +414,1 @@\n+  _last = NULL;\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,3 @@\n+  \/\/ Initialize card size before initializing alignments\n+  CardTable::initialize_card_size();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  uint log2_card_region_per_heap_region = 0;\n+  uint log2_card_regions_per_heap_region = 0;\n@@ -52,1 +52,1 @@\n-    log2_card_region_per_heap_region = (uint)HeapRegion::LogCardsPerRegion - card_container_limit;\n+    log2_card_regions_per_heap_region = (uint)HeapRegion::LogCardsPerRegion - card_container_limit;\n@@ -55,1 +55,1 @@\n-  return log2_card_region_per_heap_region;\n+  return log2_card_regions_per_heap_region;\n@@ -67,1 +67,1 @@\n-  assert((_log2_card_region_per_heap_region + _log2_cards_per_card_region) == (uint)HeapRegion::LogCardsPerRegion,\n+  assert((_log2_card_regions_per_heap_region + _log2_cards_per_card_region) == (uint)HeapRegion::LogCardsPerRegion,\n@@ -94,1 +94,1 @@\n-                                               uint log2_card_region_per_heap_region) :\n+                                               uint log2_card_regions_per_heap_region) :\n@@ -104,2 +104,2 @@\n-  _log2_card_region_per_heap_region(log2_card_region_per_heap_region),\n-  _log2_cards_per_card_region(log2i_exact(_max_cards_in_card_set) - _log2_card_region_per_heap_region) {\n+  _log2_card_regions_per_heap_region(log2_card_regions_per_heap_region),\n+  _log2_cards_per_card_region(log2i_exact(_max_cards_in_card_set) - _log2_card_regions_per_heap_region) {\n@@ -137,1 +137,1 @@\n-                          (uint)1 << log2_card_region_per_heap_region(),\n+                          (uint)1 << log2_card_regions_per_heap_region(),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-  uint _log2_card_region_per_heap_region;\n+  uint _log2_card_regions_per_heap_region;\n@@ -72,1 +72,1 @@\n-                         uint log2_card_region_per_heap_region);\n+                         uint log2_card_regions_per_heap_region);\n@@ -130,2 +130,2 @@\n-  \/\/ The log2 of the amount of card regions per heap region configured.\n-  uint log2_card_region_per_heap_region() const { return _log2_card_region_per_heap_region; }\n+  \/\/ The log2 of the number of card regions per heap region configured.\n+  uint log2_card_regions_per_heap_region() const { return _log2_card_regions_per_heap_region; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"logging\/log.hpp\"\n@@ -31,1 +31,0 @@\n-#include \"utilities\/formatBuffer.hpp\"\n@@ -145,160 +144,0 @@\n-G1CardSetMemoryStats::G1CardSetMemoryStats() {\n-  clear();\n-}\n-\n-void G1CardSetMemoryStats::clear() {\n-  for (uint i = 0; i < num_pools(); i++) {\n-    _num_mem_sizes[i] = 0;\n-    _num_buffers[i] = 0;\n-  }\n-}\n-\n-void G1CardSetFreePool::update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processor) {\n-  uint num_free_lists = _freelist_pool.num_free_lists();\n-\n-  for (uint i = 0; i < num_free_lists; i++) {\n-    unlink_processor->at(i)->visit_free_list(_freelist_pool.free_list(i));\n-  }\n-}\n-\n-void G1CardSetFreePool::G1ReturnMemoryProcessor::visit_free_list(G1CardSetBufferList* source) {\n-  assert(_source == nullptr, \"already visited\");\n-  if (_return_to_vm_size > 0) {\n-    _source = source;\n-  } else {\n-    assert(_source == nullptr, \"must be\");\n-  }\n-  if (source->mem_size() > _return_to_vm_size) {\n-    _first = source->get_all(_num_unlinked, _unlinked_bytes);\n-  } else {\n-    assert(_first == nullptr, \"must be\");\n-  }\n-  \/\/ Above we were racing with other threads getting the contents of the free list,\n-  \/\/ so while we might have been asked to return something to the OS initially,\n-  \/\/ the free list might be empty anyway. In this case just reset internal values\n-  \/\/ used for checking whether there is work available.\n-  if (_first == nullptr) {\n-    _source = nullptr;\n-    _return_to_vm_size = 0;\n-  }\n-}\n-\n-bool G1CardSetFreePool::G1ReturnMemoryProcessor::return_to_vm(jlong deadline) {\n-  assert(!finished_return_to_vm(), \"already returned everything to the VM\");\n-  assert(_first != nullptr, \"must have element to return\");\n-\n-  size_t keep_size = 0;\n-  size_t keep_num = 0;\n-\n-  G1CardSetBuffer* cur = _first;\n-  G1CardSetBuffer* last = nullptr;\n-\n-  while (cur != nullptr && _return_to_vm_size > 0) {\n-    size_t cur_size = cur->mem_size();\n-    _return_to_vm_size -= MIN2(_return_to_vm_size, cur_size);\n-\n-    keep_size += cur_size;\n-    keep_num++;\n-\n-    last = cur;\n-    cur = cur->next();\n-    \/\/ To ensure progress, perform the deadline check here.\n-    if (os::elapsed_counter() > deadline) {\n-      break;\n-    }\n-  }\n-\n-  assert(_first != nullptr, \"must be\");\n-  assert(last != nullptr, \"must be\");\n-\n-  last->set_next(nullptr);\n-\n-  \/\/ Wait for any in-progress pops to avoid ABA for them.\n-  GlobalCounter::write_synchronize();\n-  _source->bulk_add(*_first, *last, keep_num, keep_size);\n-  _first = cur;\n-\n-  log_trace(gc, task)(\"Card Set Free Memory: Returned to VM %zu buffers size %zu\", keep_num, keep_size);\n-\n-  \/\/ _return_to_vm_size may be larger than what is available in the list at the\n-  \/\/ time we actually get the list. I.e. the list and _return_to_vm_size may be\n-  \/\/ inconsistent.\n-  \/\/ So also check if we actually already at the end of the list for the exit\n-  \/\/ condition.\n-  if (_return_to_vm_size == 0 || _first == nullptr) {\n-    _source = nullptr;\n-    _return_to_vm_size = 0;\n-  }\n-  return _source != nullptr;\n-}\n-\n-bool G1CardSetFreePool::G1ReturnMemoryProcessor::return_to_os(jlong deadline) {\n-  assert(finished_return_to_vm(), \"not finished returning to VM\");\n-  assert(!finished_return_to_os(), \"already returned everything to the OS\");\n-\n-  \/\/ Now delete the rest.\n-  size_t num_delete = 0;\n-  size_t mem_size_deleted = 0;\n-\n-  while (_first != nullptr) {\n-    G1CardSetBuffer* next = _first->next();\n-    num_delete++;\n-    mem_size_deleted += _first->mem_size();\n-    delete _first;\n-    _first = next;\n-\n-    \/\/ To ensure progress, perform the deadline check here.\n-    if (os::elapsed_counter() > deadline) {\n-      break;\n-    }\n-  }\n-\n-  log_trace(gc, task)(\"Card Set Free Memory: Return to OS %zu buffers size %zu\", num_delete, mem_size_deleted);\n-\n-  return _first != nullptr;\n-}\n-\n-G1CardSetFreePool G1CardSetFreePool::_freelist_pool(G1CardSetConfiguration::num_mem_object_types());\n-\n-G1CardSetFreePool::G1CardSetFreePool(uint num_free_lists) :\n-  _num_free_lists(num_free_lists) {\n-\n-  _free_lists = NEW_C_HEAP_ARRAY(G1CardSetBufferList, _num_free_lists, mtGC);\n-  for (uint i = 0; i < _num_free_lists; i++) {\n-    new (&_free_lists[i]) G1CardSetBufferList();\n-  }\n-}\n-\n-G1CardSetFreePool::~G1CardSetFreePool() {\n-  for (uint i = 0; i < _num_free_lists; i++) {\n-    _free_lists[i].~G1CardSetBufferList();\n-  }\n-  FREE_C_HEAP_ARRAY(mtGC, _free_lists);\n-}\n-\n-G1CardSetMemoryStats G1CardSetFreePool::memory_sizes() const {\n-  G1CardSetMemoryStats free_list_stats;\n-  assert(free_list_stats.num_pools() == num_free_lists(), \"must be\");\n-  for (uint i = 0; i < num_free_lists(); i++) {\n-    free_list_stats._num_mem_sizes[i] = _free_lists[i].mem_size();\n-    free_list_stats._num_buffers[i] = _free_lists[i].num_buffers();\n-  }\n-  return free_list_stats;\n-}\n-\n-size_t G1CardSetFreePool::mem_size() const {\n-  size_t result = 0;\n-  for (uint i = 0; i < _num_free_lists; i++) {\n-    result += _free_lists[i].mem_size();\n-  }\n-  return result;\n-}\n-\n-void G1CardSetFreePool::print_on(outputStream* out) {\n-  out->print_cr(\"  Free Pool: size %zu\", free_list_pool()->mem_size());\n-  for (uint i = 0; i < _num_free_lists; i++) {\n-    FormatBuffer<> fmt(\"    %s\", G1CardSetConfiguration::mem_object_type_name_str(i));\n-    _free_lists[i].print_on(out, fmt);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.cpp","additions":1,"deletions":162,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"gc\/g1\/g1SegmentedArrayFreePool.hpp\"\n@@ -139,93 +139,0 @@\n-\/\/ Statistics for a fixed set of buffer lists. Contains the number of buffers and memory\n-\/\/ used for each. Note that statistics are typically not taken atomically so there\n-\/\/ can be inconsistencies. The user must be prepared for them.\n-class G1CardSetMemoryStats {\n-public:\n-\n-  size_t _num_mem_sizes[G1CardSetConfiguration::num_mem_object_types()];\n-  size_t _num_buffers[G1CardSetConfiguration::num_mem_object_types()];\n-\n-  \/\/ Returns all-zero statistics.\n-  G1CardSetMemoryStats();\n-\n-  void add(G1CardSetMemoryStats const other) {\n-    STATIC_ASSERT(ARRAY_SIZE(_num_buffers) == ARRAY_SIZE(_num_mem_sizes));\n-    for (uint i = 0; i < ARRAY_SIZE(_num_mem_sizes); i++) {\n-      _num_mem_sizes[i] += other._num_mem_sizes[i];\n-      _num_buffers[i] += other._num_buffers[i];\n-    }\n-  }\n-\n-  void clear();\n-\n-  uint num_pools() const { return G1CardSetConfiguration::num_mem_object_types(); }\n-};\n-\n-\/\/ A set of free lists holding memory buffers for use by G1CardSetAllocators.\n-class G1CardSetFreePool {\n-  \/\/ The global free pool.\n-  static G1CardSetFreePool _freelist_pool;\n-\n-  const uint _num_free_lists;\n-  G1CardSetBufferList* _free_lists;\n-\n-public:\n-  static G1CardSetFreePool* free_list_pool() { return &_freelist_pool; }\n-  static G1CardSetMemoryStats free_list_sizes() { return _freelist_pool.memory_sizes(); }\n-\n-  class G1ReturnMemoryProcessor;\n-  typedef GrowableArrayCHeap<G1ReturnMemoryProcessor*, mtGC> G1ReturnMemoryProcessorSet;\n-\n-  static void update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processors);\n-\n-  explicit G1CardSetFreePool(uint num_free_lists);\n-  ~G1CardSetFreePool();\n-\n-  G1CardSetBufferList* free_list(uint i) {\n-    assert(i < _num_free_lists, \"must be\");\n-    return &_free_lists[i];\n-  }\n-\n-  uint num_free_lists() const { return _num_free_lists; }\n-\n-  G1CardSetMemoryStats memory_sizes() const;\n-  size_t mem_size() const;\n-\n-  void print_on(outputStream* out);\n-};\n-\n-\/\/ Data structure containing current in-progress state for returning memory to the\n-\/\/ operating system for a single G1CardSetBufferList.\n-class G1CardSetFreePool::G1ReturnMemoryProcessor : public CHeapObj<mtGC> {\n-  G1CardSetBufferList* _source;\n-  size_t _return_to_vm_size;\n-\n-  G1CardSetBuffer* _first;\n-  size_t _unlinked_bytes;\n-  size_t _num_unlinked;\n-\n-public:\n-  explicit G1ReturnMemoryProcessor(size_t return_to_vm) :\n-    _source(nullptr), _return_to_vm_size(return_to_vm), _first(nullptr), _unlinked_bytes(0), _num_unlinked(0) {\n-  }\n-\n-  \/\/ Updates the instance members about the given card set buffer list for the purpose\n-  \/\/ of giving back memory. Only necessary members are updated, e.g. if there is\n-  \/\/ nothing to return to the VM, do not set the source list.\n-  void visit_free_list(G1CardSetBufferList* source);\n-\n-  bool finished_return_to_vm() const { return _return_to_vm_size == 0; }\n-  bool finished_return_to_os() const { return _first == nullptr; }\n-\n-  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n-  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n-  \/\/ has been processed after returning.\n-  \/\/ return_to_vm() re-adds buffers to the respective free list.\n-  bool return_to_vm(jlong deadline);\n-  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n-  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n-  \/\/ has been processed after returning.\n-  \/\/ return_to_os() gives back buffers to the OS.\n-  bool return_to_os(jlong deadline);\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.hpp","additions":1,"deletions":94,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -1663,1 +1663,1 @@\n-  guarantee(heap_rs.base() >= (char*)G1CardTable::card_size, \"Java heap must not start within the first card.\");\n+  guarantee((uintptr_t)(heap_rs.base()) >= G1CardTable::card_size, \"Java heap must not start within the first card.\");\n@@ -2263,1 +2263,1 @@\n-class G1ParallelObjectIterator : public ParallelObjectIterator {\n+class G1ParallelObjectIterator : public ParallelObjectIteratorImpl {\n@@ -2278,1 +2278,1 @@\n-ParallelObjectIterator* G1CollectedHeap::parallel_object_iterator(uint thread_num) {\n+ParallelObjectIteratorImpl* G1CollectedHeap::parallel_object_iterator(uint thread_num) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1080,1 +1080,1 @@\n-  ParallelObjectIterator* parallel_object_iterator(uint thread_num) override;\n+  ParallelObjectIteratorImpl* parallel_object_iterator(uint thread_num) override;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,6 @@\n+inline bool G1STWIsAliveClosure::do_object_b(oop p) {\n+  \/\/ An object is reachable if it is outside the collection set,\n+  \/\/ or is inside and copied.\n+  return !_g1h->is_in_cset(p) || p->is_forwarded();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n+#include \"gc\/g1\/g1SegmentedArrayFreePool.hpp\"\n+#include \"gc\/g1\/g1SegmentedArray.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/formatBuffer.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+\n+G1CardSetMemoryStats::G1CardSetMemoryStats() {\n+  clear();\n+}\n+\n+void G1CardSetMemoryStats::clear() {\n+  for (uint i = 0; i < num_pools(); i++) {\n+    _num_mem_sizes[i] = 0;\n+    _num_buffers[i] = 0;\n+  }\n+}\n+\n+void G1CardSetFreePool::update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processor) {\n+  uint num_free_lists = _freelist_pool.num_free_lists();\n+\n+  for (uint i = 0; i < num_free_lists; i++) {\n+    unlink_processor->at(i)->visit_free_list(_freelist_pool.free_list(i));\n+  }\n+}\n+\n+void G1CardSetFreePool::G1ReturnMemoryProcessor::visit_free_list(G1CardSetBufferList* source) {\n+  assert(_source == nullptr, \"already visited\");\n+  if (_return_to_vm_size > 0) {\n+    _source = source;\n+  } else {\n+    assert(_source == nullptr, \"must be\");\n+  }\n+  if (source->mem_size() > _return_to_vm_size) {\n+    _first = source->get_all(_num_unlinked, _unlinked_bytes);\n+  } else {\n+    assert(_first == nullptr, \"must be\");\n+  }\n+  \/\/ Above we were racing with other threads getting the contents of the free list,\n+  \/\/ so while we might have been asked to return something to the OS initially,\n+  \/\/ the free list might be empty anyway. In this case just reset internal values\n+  \/\/ used for checking whether there is work available.\n+  if (_first == nullptr) {\n+    _source = nullptr;\n+    _return_to_vm_size = 0;\n+  }\n+}\n+\n+bool G1CardSetFreePool::G1ReturnMemoryProcessor::return_to_vm(jlong deadline) {\n+  assert(!finished_return_to_vm(), \"already returned everything to the VM\");\n+  assert(_first != nullptr, \"must have element to return\");\n+\n+  size_t keep_size = 0;\n+  size_t keep_num = 0;\n+\n+  G1CardSetBuffer* cur = _first;\n+  G1CardSetBuffer* last = nullptr;\n+\n+  while (cur != nullptr && _return_to_vm_size > 0) {\n+    size_t cur_size = cur->mem_size();\n+    _return_to_vm_size -= MIN2(_return_to_vm_size, cur_size);\n+\n+    keep_size += cur_size;\n+    keep_num++;\n+\n+    last = cur;\n+    cur = cur->next();\n+    \/\/ To ensure progress, perform the deadline check here.\n+    if (os::elapsed_counter() > deadline) {\n+      break;\n+    }\n+  }\n+\n+  assert(_first != nullptr, \"must be\");\n+  assert(last != nullptr, \"must be\");\n+\n+  last->set_next(nullptr);\n+\n+  \/\/ Wait for any in-progress pops to avoid ABA for them.\n+  GlobalCounter::write_synchronize();\n+  _source->bulk_add(*_first, *last, keep_num, keep_size);\n+  _first = cur;\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Returned to VM %zu buffers size %zu\", keep_num, keep_size);\n+\n+  \/\/ _return_to_vm_size may be larger than what is available in the list at the\n+  \/\/ time we actually get the list. I.e. the list and _return_to_vm_size may be\n+  \/\/ inconsistent.\n+  \/\/ So also check if we actually already at the end of the list for the exit\n+  \/\/ condition.\n+  if (_return_to_vm_size == 0 || _first == nullptr) {\n+    _source = nullptr;\n+    _return_to_vm_size = 0;\n+  }\n+  return _source != nullptr;\n+}\n+\n+bool G1CardSetFreePool::G1ReturnMemoryProcessor::return_to_os(jlong deadline) {\n+  assert(finished_return_to_vm(), \"not finished returning to VM\");\n+  assert(!finished_return_to_os(), \"already returned everything to the OS\");\n+\n+  \/\/ Now delete the rest.\n+  size_t num_delete = 0;\n+  size_t mem_size_deleted = 0;\n+\n+  while (_first != nullptr) {\n+    G1CardSetBuffer* next = _first->next();\n+    num_delete++;\n+    mem_size_deleted += _first->mem_size();\n+    delete _first;\n+    _first = next;\n+\n+    \/\/ To ensure progress, perform the deadline check here.\n+    if (os::elapsed_counter() > deadline) {\n+      break;\n+    }\n+  }\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Return to OS %zu buffers size %zu\", num_delete, mem_size_deleted);\n+\n+  return _first != nullptr;\n+}\n+\n+G1CardSetFreePool G1CardSetFreePool::_freelist_pool(G1CardSetConfiguration::num_mem_object_types());\n+\n+G1CardSetFreePool::G1CardSetFreePool(uint num_free_lists) :\n+  _num_free_lists(num_free_lists) {\n+\n+  _free_lists = NEW_C_HEAP_ARRAY(G1CardSetBufferList, _num_free_lists, mtGC);\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    new (&_free_lists[i]) G1CardSetBufferList();\n+  }\n+}\n+\n+G1CardSetFreePool::~G1CardSetFreePool() {\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    _free_lists[i].~G1CardSetBufferList();\n+  }\n+  FREE_C_HEAP_ARRAY(mtGC, _free_lists);\n+}\n+\n+G1CardSetBufferList* G1CardSetFreePool::free_list(uint i) {\n+  assert(i < _num_free_lists, \"must be\");\n+  return &_free_lists[i];\n+}\n+\n+G1CardSetMemoryStats G1CardSetFreePool::memory_sizes() const {\n+  G1CardSetMemoryStats free_list_stats;\n+  assert(free_list_stats.num_pools() == num_free_lists(), \"must be\");\n+  for (uint i = 0; i < num_free_lists(); i++) {\n+    free_list_stats._num_mem_sizes[i] = _free_lists[i].mem_size();\n+    free_list_stats._num_buffers[i] = _free_lists[i].num_buffers();\n+  }\n+  return free_list_stats;\n+}\n+\n+size_t G1CardSetFreePool::mem_size() const {\n+  size_t result = 0;\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    result += _free_lists[i].mem_size();\n+  }\n+  return result;\n+}\n+\n+void G1CardSetFreePool::print_on(outputStream* out) {\n+  out->print_cr(\"  Free Pool: size %zu\", free_list_pool()->mem_size());\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    FormatBuffer<> fmt(\"    %s\", G1CardSetConfiguration::mem_object_type_name_str(i));\n+    _free_lists[i].print_on(out, fmt);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArrayFreePool.cpp","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#ifndef SHARE_GC_G1_G1SEGMENTEDARRAYFREEPOOL_HPP\n+#define SHARE_GC_G1_G1SEGMENTEDARRAYFREEPOOL_HPP\n+\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1SegmentedArray.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+\/\/ Statistics for a fixed set of buffer lists. Contains the number of buffers and memory\n+\/\/ used for each. Note that statistics are typically not taken atomically so there\n+\/\/ can be inconsistencies. The user must be prepared for them.\n+class G1CardSetMemoryStats {\n+public:\n+\n+  size_t _num_mem_sizes[G1CardSetConfiguration::num_mem_object_types()];\n+  size_t _num_buffers[G1CardSetConfiguration::num_mem_object_types()];\n+\n+  \/\/ Returns all-zero statistics.\n+  G1CardSetMemoryStats();\n+\n+  void add(G1CardSetMemoryStats const other) {\n+    STATIC_ASSERT(ARRAY_SIZE(_num_buffers) == ARRAY_SIZE(_num_mem_sizes));\n+    for (uint i = 0; i < ARRAY_SIZE(_num_mem_sizes); i++) {\n+      _num_mem_sizes[i] += other._num_mem_sizes[i];\n+      _num_buffers[i] += other._num_buffers[i];\n+    }\n+  }\n+\n+  void clear();\n+\n+  uint num_pools() const { return G1CardSetConfiguration::num_mem_object_types(); }\n+};\n+\n+typedef G1SegmentedArrayBuffer<mtGCCardSet> G1CardSetBuffer;\n+typedef G1SegmentedArrayBufferList<mtGCCardSet> G1CardSetBufferList;\n+\n+\/\/ A set of free lists holding memory buffers for use by G1CardSetAllocators.\n+class G1CardSetFreePool {\n+  \/\/ The global free pool.\n+  static G1CardSetFreePool _freelist_pool;\n+\n+  const uint _num_free_lists;\n+  G1CardSetBufferList* _free_lists;\n+\n+public:\n+  static G1CardSetFreePool* free_list_pool() { return &_freelist_pool; }\n+  static G1CardSetMemoryStats free_list_sizes() { return _freelist_pool.memory_sizes(); }\n+\n+  class G1ReturnMemoryProcessor;\n+  typedef GrowableArrayCHeap<G1ReturnMemoryProcessor*, mtGC> G1ReturnMemoryProcessorSet;\n+\n+  static void update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processors);\n+\n+  explicit G1CardSetFreePool(uint num_free_lists);\n+  ~G1CardSetFreePool();\n+\n+  G1CardSetBufferList* free_list(uint i);\n+\n+  uint num_free_lists() const { return _num_free_lists; }\n+\n+  G1CardSetMemoryStats memory_sizes() const;\n+  size_t mem_size() const;\n+\n+  void print_on(outputStream* out);\n+};\n+\n+\/\/ Data structure containing current in-progress state for returning memory to the\n+\/\/ operating system for a single G1CardSetBufferList.\n+class G1CardSetFreePool::G1ReturnMemoryProcessor : public CHeapObj<mtGC> {\n+  G1CardSetBufferList* _source;\n+  size_t _return_to_vm_size;\n+\n+  G1CardSetBuffer* _first;\n+  size_t _unlinked_bytes;\n+  size_t _num_unlinked;\n+\n+public:\n+  explicit G1ReturnMemoryProcessor(size_t return_to_vm) :\n+    _source(nullptr), _return_to_vm_size(return_to_vm), _first(nullptr), _unlinked_bytes(0), _num_unlinked(0) {\n+  }\n+\n+  \/\/ Updates the instance members about the given card set buffer list for the purpose\n+  \/\/ of giving back memory. Only necessary members are updated, e.g. if there is\n+  \/\/ nothing to return to the VM, do not set the source list.\n+  void visit_free_list(G1CardSetBufferList* source);\n+\n+  bool finished_return_to_vm() const { return _return_to_vm_size == 0; }\n+  bool finished_return_to_os() const { return _first == nullptr; }\n+\n+  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n+  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n+  \/\/ has been processed after returning.\n+  \/\/ return_to_vm() re-adds buffers to the respective free list.\n+  bool return_to_vm(jlong deadline);\n+  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n+  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n+  \/\/ has been processed after returning.\n+  \/\/ return_to_os() gives back buffers to the OS.\n+  bool return_to_os(jlong deadline);\n+};\n+\n+#endif \/\/SHARE_GC_G1_G1SEGMENTEDARRAYFREEPOOL_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArrayFreePool.hpp","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n@@ -990,6 +990,0 @@\n-bool G1STWIsAliveClosure::do_object_b(oop p) {\n-  \/\/ An object is reachable if it is outside the collection set,\n-  \/\/ or is inside and copied.\n-  return !_g1h->is_in_cset(p) || p->is_forwarded();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-                                                                                       _card_set.config()->log2_card_region_per_heap_region(),\n+                                                                                       _card_set.config()->log2_card_regions_per_heap_region(),\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,10 @@\n+uint ObjectStartArray::block_shift = 0;\n+uint ObjectStartArray::block_size = 0;\n+uint ObjectStartArray::block_size_in_words = 0;\n+\n+void ObjectStartArray::initialize_block_size(uint card_shift) {\n+  block_shift = card_shift;\n+  block_size = 1 << block_shift;\n+  block_size_in_words = block_size \/ sizeof(HeapWord);\n+}\n+\n@@ -38,1 +48,1 @@\n-  assert((int)block_size <= 512, \"block_size must be less than or equal to 512\");\n+  assert(block_size <= MaxBlockSize, \"block_size must be less than or equal to \" UINT32_FORMAT, MaxBlockSize);\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -55,5 +55,11 @@\n-  enum BlockSizeConstants {\n-    block_shift                  = 9,\n-    block_size                   = 1 << block_shift,\n-    block_size_in_words          = block_size \/ sizeof(HeapWord)\n-  };\n+  static uint block_shift;\n+  static uint block_size;\n+  static uint block_size_in_words;\n+\n+  \/\/ Maximum size an offset table entry can cover. This maximum is derived from that\n+  \/\/ we need an extra bit for possible offsets in the byte for backskip values, leaving 2^7 possible offsets.\n+  \/\/ Minimum object alignment is 8 bytes (2^3), so we can at most represent 2^10 offsets within a BOT value.\n+  static const uint MaxBlockSize = 1024;\n+\n+  \/\/ Initialize block size based on card size\n+  static void initialize_block_size(uint card_shift);\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.hpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -100,0 +100,2 @@\n+  \/\/ Initialize card size before initializing alignments\n+  CardTable::initialize_card_size();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelArguments.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -603,1 +603,1 @@\n-class PSScavengeParallelObjectIterator : public ParallelObjectIterator {\n+class PSScavengeParallelObjectIterator : public ParallelObjectIteratorImpl {\n@@ -618,1 +618,1 @@\n-ParallelObjectIterator* ParallelScavengeHeap::parallel_object_iterator(uint thread_num) {\n+ParallelObjectIteratorImpl* ParallelScavengeHeap::parallel_object_iterator(uint thread_num) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -234,1 +234,1 @@\n-  virtual ParallelObjectIterator* parallel_object_iterator(uint thread_num);\n+  virtual ParallelObjectIteratorImpl* parallel_object_iterator(uint thread_num);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,12 @@\n+uint BOTConstants::LogN = 0;\n+uint BOTConstants::LogN_words = 0;\n+uint BOTConstants::N_bytes = 0;\n+uint BOTConstants::N_words = 0;\n+\n+void BOTConstants::initialize_bot_size(uint card_shift) {\n+  LogN =  card_shift;\n+  LogN_words = LogN - LogHeapWordSize;\n+  N_bytes = 1 << LogN;\n+  N_words = 1 << LogN_words;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/blockOffsetTable.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/cardTable.hpp\"\n@@ -52,4 +53,5 @@\n-  static const uint LogN = 9;\n-  static const uint LogN_words = LogN - LogHeapWordSize;\n-  static const uint N_bytes = 1 << LogN;\n-  static const uint N_words = 1 << LogN_words;\n+  static uint LogN;\n+  static uint LogN_words;\n+  static uint N_bytes;\n+  static uint N_words;\n+\n@@ -62,0 +64,3 @@\n+  \/\/ Initialize bot size based on card size\n+  static void initialize_bot_size(uint card_shift);\n+\n@@ -96,0 +101,1 @@\n+    assert(BOTConstants::N_bytes == CardTable::card_size, \"sanity\");\n","filename":"src\/hotspot\/share\/gc\/shared\/blockOffsetTable.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -337,1 +337,1 @@\n-      __ move(new LIR_Address(base_reg, oopDesc::klass_offset_in_bytes(), T_ADDRESS), src_klass);\n+      gen->load_klass(base_reg, src_klass, NULL);\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/barrierSetC1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"gc\/shared\/gcLogPrecious.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -35,0 +37,26 @@\n+#if INCLUDE_PARALLELGC\n+#include \"gc\/parallel\/objectStartArray.hpp\"\n+#endif\n+\n+uint CardTable::card_shift = 0;\n+uint CardTable::card_size = 0;\n+uint CardTable::card_size_in_words = 0;\n+\n+void CardTable::initialize_card_size() {\n+  assert(UseG1GC || UseParallelGC || UseSerialGC,\n+         \"Initialize card size should only be called by card based collectors.\");\n+\n+  card_size = GCCardSizeInBytes;\n+  card_shift = log2i_exact(card_size);\n+  card_size_in_words = card_size \/ sizeof(HeapWord);\n+\n+  \/\/ Set blockOffsetTable size based on card table entry size\n+  BOTConstants::initialize_bot_size(card_shift);\n+\n+#if INCLUDE_PARALLELGC\n+  \/\/ Set ObjectStartArray block size based on card table entry size\n+  ObjectStartArray::initialize_block_size(card_shift);\n+#endif\n+\n+  log_info_p(gc, init)(\"CardTable entry size: \" UINT32_FORMAT,  card_size);\n+}\n@@ -59,2 +87,0 @@\n-\n-  assert(card_size <= 512, \"card_size must be less than 512\"); \/\/ why?\n@@ -431,1 +457,2 @@\n-  return card_size * os::vm_page_size();\n+  \/\/ Calculate maximum alignment using GCCardSizeInBytes as card_size hasn't been set yet\n+  return GCCardSizeInBytes * os::vm_page_size();\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.cpp","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -231,6 +231,4 @@\n-  \/\/ Constants\n-  enum SomePublicConstants {\n-    card_shift                  = 9,\n-    card_size                   = 1 << card_shift,\n-    card_size_in_words          = card_size \/ sizeof(HeapWord)\n-  };\n+  \/\/ CardTable entry size\n+  static uint card_shift;\n+  static uint card_size;\n+  static uint card_size_in_words;\n@@ -242,0 +240,3 @@\n+  \/\/ Initialize card size\n+  static void initialize_card_size();\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -113,0 +113,12 @@\n+ParallelObjectIterator::ParallelObjectIterator(uint thread_num) :\n+  _impl(Universe::heap()->parallel_object_iterator(thread_num))\n+{}\n+\n+ParallelObjectIterator::~ParallelObjectIterator() {\n+  delete _impl;\n+}\n+\n+void ParallelObjectIterator::object_iterate(ObjectClosure* cl, uint worker_id) {\n+  _impl->object_iterate(cl, worker_id);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-class ParallelObjectIterator : public CHeapObj<mtGC> {\n+class ParallelObjectIteratorImpl : public CHeapObj<mtGC> {\n@@ -67,0 +67,1 @@\n+  virtual ~ParallelObjectIteratorImpl() {}\n@@ -68,1 +69,13 @@\n-  virtual ~ParallelObjectIterator() {}\n+};\n+\n+\/\/ User facing parallel object iterator. This is a StackObj, which ensures that\n+\/\/ the _impl is allocated and deleted in the scope of this object. This ensures\n+\/\/ the life cycle of the implementation is as required by ThreadsListHandle,\n+\/\/ which is sometimes used by the root iterators.\n+class ParallelObjectIterator : public StackObj {\n+  ParallelObjectIteratorImpl* _impl;\n+\n+public:\n+  ParallelObjectIterator(uint thread_num);\n+  ~ParallelObjectIterator();\n+  void object_iterate(ObjectClosure* cl, uint worker_id);\n@@ -85,0 +98,1 @@\n+  friend class ParallelObjectIterator;\n@@ -387,1 +401,2 @@\n-  virtual ParallelObjectIterator* parallel_object_iterator(uint thread_num) {\n+ protected:\n+  virtual ParallelObjectIteratorImpl* parallel_object_iterator(uint thread_num) {\n@@ -391,0 +406,1 @@\n+ public:\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -695,3 +695,7 @@\n-          range(0, max_juint)\n-\n-\/\/ end of GC_FLAGS\n+          range(0, max_juint)                                               \\\n+                                                                            \\\n+  product(uint, GCCardSizeInBytes, 512,                                     \\\n+          \"Card table entry size (in bytes) for card based collectors\")     \\\n+          range(128, 1024)                                                  \\\n+          constraint(GCCardSizeInBytesConstraintFunc,AtParse)\n+  \/\/ end of GC_FLAGS\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/shared\/cardTable.hpp\"\n@@ -64,0 +65,2 @@\n+  \/\/ Initialize card size before initializing alignments\n+  CardTable::initialize_card_size();\n","filename":"src\/hotspot\/share\/gc\/shared\/genArguments.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -427,0 +427,12 @@\n+JVMFlag::Error GCCardSizeInBytesConstraintFunc(uint value, bool verbose) {\n+  if (!is_power_of_2(value)) {\n+    JVMFlag::printError(verbose,\n+                        \"GCCardSizeInBytes ( %u ) must be \"\n+                        \"a power of 2\\n\",\n+                        value);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  } else {\n+    return JVMFlag::SUCCESS;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -69,1 +69,2 @@\n- f(size_t, MaxMetaspaceSizeConstraintFunc)\n+ f(size_t, MaxMetaspaceSizeConstraintFunc)                     \\\n+ f(uint, GCCardSizeInBytesConstraintFunc)\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -201,0 +201,2 @@\n+  phase_times.set_processing_is_mt(processing_is_mt());\n+\n@@ -733,2 +735,0 @@\n-  phase_times.set_processing_is_mt(processing_is_mt());\n-\n@@ -767,1 +767,0 @@\n-  phase_times.set_processing_is_mt(processing_is_mt());\n@@ -794,1 +793,0 @@\n-  phase_times.set_processing_is_mt(processing_is_mt());\n@@ -1057,9 +1055,0 @@\n-bool ReferenceProcessor::has_discovered_references() {\n-  for (uint i = 0; i < _max_num_queues * number_of_subclasses_of_ref(); i++) {\n-    if (!_discovered_refs[i].is_empty()) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -424,3 +424,0 @@\n-  \/\/ Has discovered references that need handling\n-  bool has_discovered_references();\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -203,1 +203,0 @@\n-    _sub_phases_total_time_ms[i] = uninitialized();\n@@ -230,11 +229,0 @@\n-double ReferenceProcessorPhaseTimes::sub_phase_total_time_ms(ReferenceProcessor::RefProcSubPhases sub_phase) const {\n-  ASSERT_SUB_PHASE(sub_phase);\n-  return _sub_phases_total_time_ms[sub_phase];\n-}\n-\n-void ReferenceProcessorPhaseTimes::set_sub_phase_total_phase_time_ms(ReferenceProcessor::RefProcSubPhases sub_phase,\n-                                                                     double time_ms) {\n-  ASSERT_SUB_PHASE(sub_phase);\n-  _sub_phases_total_time_ms[sub_phase] = time_ms;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessorPhaseTimes.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -44,2 +44,0 @@\n-  \/\/ Total time of each sub phase.\n-  double                   _sub_phases_total_time_ms[ReferenceProcessor::RefSubPhaseMax];\n@@ -65,1 +63,0 @@\n-  double sub_phase_total_time_ms(ReferenceProcessor::RefProcSubPhases sub_phase) const;\n@@ -86,2 +83,0 @@\n-\n-  void set_sub_phase_total_phase_time_ms(ReferenceProcessor::RefProcSubPhases sub_phase, double ref_proc_time_ms);\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessorPhaseTimes.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,10 +39,0 @@\n-template <>\n-void WorkerDataArray<double>::WDAPrinter::summary(outputStream* out, double time) {\n-  out->print_cr(\" %.1lfms\", time * MILLIUNITS);\n-}\n-\n-template <>\n-void WorkerDataArray<size_t>::WDAPrinter::summary(outputStream* out, size_t value) {\n-  out->print_cr(\" \" SIZE_FORMAT, value);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/workerDataArray.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  WorkerDataArray(const char* short_name, const char* title, uint length, bool is_serial = false);\n+  WorkerDataArray(const char* short_name, const char* title, uint length);\n@@ -94,1 +94,0 @@\n-    static void summary(outputStream* out, double time);\n@@ -96,1 +95,0 @@\n-    static void summary(outputStream* out, size_t value);\n","filename":"src\/hotspot\/share\/gc\/shared\/workerDataArray.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-WorkerDataArray<T>::WorkerDataArray(const char* short_name, const char* title, uint length, bool is_serial) :\n+WorkerDataArray<T>::WorkerDataArray(const char* short_name, const char* title, uint length) :\n@@ -38,2 +38,1 @@\n- _title(title),\n- _is_serial(is_serial) {\n+ _title(title) {\n@@ -41,1 +40,0 @@\n-  assert(!is_serial || length == 1, \"Serial phase must only have a single entry.\");\n@@ -161,5 +159,1 @@\n-  if (_is_serial) {\n-    out->print(\"%s:\", title());\n-  } else {\n-    out->print(\"%-30s\", title());\n-  }\n+  out->print(\"%-30s\", title());\n@@ -172,15 +166,11 @@\n-    if (_is_serial) {\n-      WDAPrinter::summary(out, get(0));\n-    } else {\n-      T min = get(start);\n-      T max = min;\n-      T sum = 0;\n-      uint contributing_threads = 0;\n-      for (uint i = start; i < _length; ++i) {\n-        T value = get(i);\n-        if (value != uninitialized()) {\n-          max = MAX2(max, value);\n-          min = MIN2(min, value);\n-          sum += value;\n-          contributing_threads++;\n-        }\n+    T min = get(start);\n+    T max = min;\n+    T sum = 0;\n+    uint contributing_threads = 0;\n+    for (uint i = start; i < _length; ++i) {\n+      T value = get(i);\n+      if (value != uninitialized()) {\n+        max = MAX2(max, value);\n+        min = MIN2(min, value);\n+        sum += value;\n+        contributing_threads++;\n@@ -188,5 +178,0 @@\n-      T diff = max - min;\n-      assert(contributing_threads != 0, \"Must be since we found a used value for the start index\");\n-      double avg = sum \/ (double) contributing_threads;\n-      WDAPrinter::summary(out, min, avg, max, diff, sum, print_sum);\n-      out->print_cr(\", Workers: %d\", contributing_threads);\n@@ -194,0 +179,5 @@\n+    T diff = max - min;\n+    assert(contributing_threads != 0, \"Must be since we found a used value for the start index\");\n+    double avg = sum \/ (double) contributing_threads;\n+    WDAPrinter::summary(out, min, avg, max, diff, sum, print_sum);\n+    out->print_cr(\", Workers: %d\", contributing_threads);\n","filename":"src\/hotspot\/share\/gc\/shared\/workerDataArray.inline.hpp","additions":19,"deletions":29,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1369,1 +1369,1 @@\n-class ShenandoahParallelObjectIterator : public ParallelObjectIterator {\n+class ShenandoahParallelObjectIterator : public ParallelObjectIteratorImpl {\n@@ -1468,1 +1468,1 @@\n-ParallelObjectIterator* ShenandoahHeap::parallel_object_iterator(uint workers) {\n+ParallelObjectIteratorImpl* ShenandoahHeap::parallel_object_iterator(uint workers) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -487,1 +487,1 @@\n-  virtual ParallelObjectIterator* parallel_object_iterator(uint workers);\n+  virtual ParallelObjectIteratorImpl* parallel_object_iterator(uint workers);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-ParallelObjectIterator* ZCollectedHeap::parallel_object_iterator(uint nworkers) {\n+ParallelObjectIteratorImpl* ZCollectedHeap::parallel_object_iterator(uint nworkers) {\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-  virtual ParallelObjectIterator* parallel_object_iterator(uint nworkers);\n+  virtual ParallelObjectIteratorImpl* parallel_object_iterator(uint nworkers);\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -442,1 +442,1 @@\n-ParallelObjectIterator* ZHeap::parallel_object_iterator(uint nworkers, bool visit_weaks) {\n+ParallelObjectIteratorImpl* ZHeap::parallel_object_iterator(uint nworkers, bool visit_weaks) {\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-  ParallelObjectIterator* parallel_object_iterator(uint nworkers, bool visit_weaks);\n+  ParallelObjectIteratorImpl* parallel_object_iterator(uint nworkers, bool visit_weaks);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-class ZHeapIterator : public ParallelObjectIterator {\n+class ZHeapIterator : public ParallelObjectIteratorImpl {\n","filename":"src\/hotspot\/share\/gc\/z\/zHeapIterator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/z\/zThread.inline.hpp\"\n@@ -739,2 +740,7 @@\n-  LogTarget(Debug, gc, phases, start) log;\n-  log_start(log, true \/* thread *\/);\n+  if (ZThread::is_worker()) {\n+    LogTarget(Trace, gc, phases, start) log;\n+    log_start(log, true \/* thread *\/);\n+  } else {\n+    LogTarget(Debug, gc, phases, start) log;\n+    log_start(log, false \/* thread *\/);\n+  }\n@@ -753,2 +759,7 @@\n-  LogTarget(Debug, gc, phases) log;\n-  log_end(log, duration, true \/* thread *\/);\n+  if (ZThread::is_worker()) {\n+    LogTarget(Trace, gc, phases) log;\n+    log_end(log, duration, true \/* thread *\/);\n+  } else {\n+    LogTarget(Debug, gc, phases) log;\n+    log_end(log, duration, false \/* thread *\/);\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.cpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -134,0 +134,13 @@\n+\n+void ZTracer::send_thread_debug(const char* name, const Ticks& start, const Ticks& end) {\n+  NoSafepointVerifier nsv;\n+\n+  EventZThreadDebug e(UNTIMED);\n+  if (e.should_commit()) {\n+    e.set_gcId(GCId::current_or_undefined());\n+    e.set_name(name);\n+    e.set_starttime(start);\n+    e.set_endtime(end);\n+    e.commit();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zTracer.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+  void send_thread_debug(const char* name, const Ticks& start, const Ticks& end);\n@@ -50,0 +51,1 @@\n+  void report_thread_debug(const char* name, const Ticks& start, const Ticks& end);\n@@ -52,1 +54,2 @@\n-class ZTraceThreadPhase : public StackObj {\n+\/\/ For temporary latency measurements during development and debugging\n+class ZTraceThreadDebug : public StackObj {\n@@ -58,2 +61,2 @@\n-  ZTraceThreadPhase(const char* name);\n-  ~ZTraceThreadPhase();\n+  ZTraceThreadDebug(const char* name);\n+  ~ZTraceThreadDebug();\n","filename":"src\/hotspot\/share\/gc\/z\/zTracer.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -53,1 +53,7 @@\n-inline ZTraceThreadPhase::ZTraceThreadPhase(const char* name) :\n+inline void ZTracer::report_thread_debug(const char* name, const Ticks& start, const Ticks& end) {\n+  if (EventZThreadDebug::is_enabled()) {\n+    send_thread_debug(name, start, end);\n+  }\n+}\n+\n+inline ZTraceThreadDebug::ZTraceThreadDebug(const char* name) :\n@@ -57,2 +63,2 @@\n-inline ZTraceThreadPhase::~ZTraceThreadPhase() {\n-  ZTracer::tracer()->report_thread_phase(_name, _start, Ticks::now());\n+inline ZTraceThreadDebug::~ZTraceThreadDebug() {\n+  ZTracer::tracer()->report_thread_debug(_name, _start, Ticks::now());\n","filename":"src\/hotspot\/share\/gc\/z\/zTracer.inline.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2808,1 +2808,1 @@\n-      CASE(_fast_faccess_0): {\n+      CASE(_fast_iaccess_0): {\n@@ -2823,1 +2823,1 @@\n-      CASE(_fast_iaccess_0): {\n+      CASE(_fast_faccess_0): {\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1037,0 +1037,5 @@\n+  <Event name=\"ZThreadDebug\" category=\"Java Virtual Machine, GC, Detailed\" label=\"ZGC Thread Event\" description=\"Temporary latency measurements used during development and debugging of ZGC\" thread=\"true\" experimental=\"true\">\n+    <Field type=\"uint\" name=\"gcId\" label=\"GC Identifier\" relation=\"GcId\"\/>\n+    <Field type=\"string\" name=\"name\" label=\"Name\" \/>\n+  <\/Event>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -581,12 +581,6 @@\n-      ParallelObjectIterator* poi = Universe::heap()->parallel_object_iterator(workers->active_workers());\n-      if (poi != NULL) {\n-        \/\/ The GC supports parallel object iteration.\n-\n-        ParHeapInspectTask task(poi, cit, filter);\n-        \/\/ Run task with the active workers.\n-        workers->run_task(&task);\n-\n-        delete poi;\n-        if (task.success()) {\n-          return task.missed_count();\n-        }\n+      ParallelObjectIterator poi(workers->active_workers());\n+      ParHeapInspectTask task(&poi, cit, filter);\n+      \/\/ Run task with the active workers.\n+      workers->run_task(&task);\n+      if (task.success()) {\n+        return task.missed_count();\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -116,4 +116,6 @@\n-  MutexLocker ml(MetaspaceCritical_lock, Mutex::_no_safepoint_check_flag);\n-  if (_requests_head == request) {\n-    \/\/ The first request can't opportunistically ride on a previous GC\n-    return false;\n+  {\n+    MutexLocker ml(MetaspaceCritical_lock, Mutex::_no_safepoint_check_flag);\n+    if (_requests_head == request) {\n+      \/\/ The first request can't opportunistically ride on a previous GC\n+      return false;\n+    }\n@@ -127,2 +129,6 @@\n-  while (!request->has_result()) {\n-    ThreadBlockInVM tbivm(JavaThread::current());\n+  ThreadBlockInVM tbivm(JavaThread::current());\n+  MutexLocker ml(MetaspaceCritical_lock, Mutex::_no_safepoint_check_flag);\n+  for (;;) {\n+    if (request->has_result()) {\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/memory\/metaspaceCriticalAllocation.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2064,2 +2064,2 @@\n-\/* jni_id_for_impl for jfieldIds only *\/\n-JNIid* InstanceKlass::jni_id_for_impl(int offset) {\n+\/* jni_id_for for jfieldIds only *\/\n+JNIid* InstanceKlass::jni_id_for(int offset) {\n@@ -2067,1 +2067,0 @@\n-  \/\/ Retry lookup after we got the lock\n@@ -2070,1 +2069,1 @@\n-    \/\/ Slow case, allocate new static field identifier\n+    \/\/ Allocate new static field identifier\n@@ -2077,10 +2076,0 @@\n-\n-\/* jni_id_for for jfieldIds only *\/\n-JNIid* InstanceKlass::jni_id_for(int offset) {\n-  JNIid* probe = jni_ids() == NULL ? NULL : jni_ids()->find(offset);\n-  if (probe == NULL) {\n-    probe = jni_id_for_impl(offset);\n-  }\n-  return probe;\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1202,2 +1202,0 @@\n-  \/* jni_id_for_impl for jfieldID only *\/\n-  JNIid* jni_id_for_impl                         (int offset);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1589,12 +1589,0 @@\n-bool MethodData::profile_memory_access(const methodHandle& m, int bci) {\n-  Bytecode_invoke inv(m , bci);\n-  if (inv.is_invokestatic()) {\n-    if (inv.klass() == vmSymbols::jdk_incubator_foreign_MemoryAccess()) {\n-      if (inv.name()->starts_with(\"get\") || inv.name()->starts_with(\"set\")) {\n-        return true;\n-      }\n-    }\n-  }\n-  return false;\n-}\n-\n@@ -1630,4 +1618,0 @@\n-  if (profile_memory_access(m, bci)) {\n-    return true;\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  _late_inline(false),\n@@ -116,1 +117,1 @@\n-                               int caller_bci, ciCallProfile& profile) {\n+                               int caller_bci, NOT_PRODUCT_ARG(bool& should_delay) ciCallProfile& profile) {\n@@ -131,3 +132,7 @@\n-  int inline_depth = inline_level()+1;\n-  if (ciReplay::should_inline(C->replay_inline_data(), callee_method, caller_bci, inline_depth)) {\n-    set_msg(\"force inline by ciReplay\");\n+  int inline_depth = inline_level() + 1;\n+  if (ciReplay::should_inline(C->replay_inline_data(), callee_method, caller_bci, inline_depth, should_delay)) {\n+    if (should_delay) {\n+      set_msg(\"force (incremental) inline by ciReplay\");\n+    } else {\n+      set_msg(\"force inline by ciReplay\");\n+    }\n@@ -197,1 +202,1 @@\n-                                   int caller_bci, ciCallProfile& profile) {\n+                                   int caller_bci, NOT_PRODUCT_ARG(bool& should_delay) ciCallProfile& profile) {\n@@ -235,3 +240,7 @@\n-  int inline_depth = inline_level()+1;\n-  if (ciReplay::should_inline(C->replay_inline_data(), callee_method, caller_bci, inline_depth)) {\n-    set_msg(\"force inline by ciReplay\");\n+  int inline_depth = inline_level() + 1;\n+  if (ciReplay::should_inline(C->replay_inline_data(), callee_method, caller_bci, inline_depth, should_delay)) {\n+    if (should_delay) {\n+      set_msg(\"force (incremental) inline by ciReplay\");\n+    } else {\n+      set_msg(\"force inline by ciReplay\");\n+    }\n@@ -372,1 +381,3 @@\n-  if (!should_inline(callee_method, caller_method, caller_bci, profile)) {\n+\n+  \/\/ 'should_delay' can be overridden during replay compilation\n+  if (!should_inline(callee_method, caller_method, caller_bci, NOT_PRODUCT_ARG(should_delay) profile)) {\n@@ -375,1 +386,2 @@\n-  if (should_not_inline(callee_method, caller_method, caller_bci, profile)) {\n+  \/\/ 'should_delay' can be overridden during replay compilation\n+  if (should_not_inline(callee_method, caller_method, caller_bci, NOT_PRODUCT_ARG(should_delay) profile)) {\n@@ -560,2 +572,0 @@\n-  assert(callee_method != NULL, \"caller checks for optimized virtual!\");\n-  assert(!should_delay, \"should be initialized to false\");\n@@ -563,0 +573,1 @@\n+  assert(callee_method != NULL, \"caller checks for optimized virtual!\");\n@@ -598,1 +609,5 @@\n-    build_inline_tree_for_callee(callee_method, jvms, caller_bci);\n+    InlineTree* callee_tree = build_inline_tree_for_callee(callee_method, jvms, caller_bci);\n+    if (should_delay) {\n+      \/\/ Record late inlining decision in order to dump it for compiler replay\n+      callee_tree->set_late_inline();\n+    }\n@@ -703,1 +718,1 @@\n-  out->print(\" %d %d \", inline_level(), caller_bci());\n+  out->print(\" %d %d %d \", inline_level(), caller_bci(), _late_inline);\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":29,"deletions":14,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-      bool should_delay = false;\n+      bool should_delay = AlwaysIncrementalInline;\n@@ -192,1 +192,1 @@\n-          } else if ((should_delay || AlwaysIncrementalInline)) {\n+          } else if (should_delay) {\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -344,1 +344,1 @@\n-    ProjNode* fast_proj = clone_skeleton_predicate_for_unswitched_loops(iff, predicate_proj, uncommon_proj, reason, iffast_pred, loop);\n+    ProjNode* fast_proj = clone_skeleton_predicate_for_unswitched_loops(iff, predicate_proj, reason, iffast_pred);\n@@ -346,1 +346,1 @@\n-    ProjNode* slow_proj = clone_skeleton_predicate_for_unswitched_loops(iff, predicate_proj, uncommon_proj, reason, ifslow_pred, loop);\n+    ProjNode* slow_proj = clone_skeleton_predicate_for_unswitched_loops(iff, predicate_proj, reason, ifslow_pred);\n@@ -400,4 +400,4 @@\n-ProjNode* PhaseIdealLoop::clone_skeleton_predicate_for_unswitched_loops(Node* iff, ProjNode* predicate, Node* uncommon_proj,\n-                                                                    Deoptimization::DeoptReason reason, ProjNode* output_proj,\n-                                                                    IdealLoopTree* loop) {\n-  Node* bol = clone_skeleton_predicate_bool(iff, NULL, NULL, predicate, uncommon_proj, output_proj, loop);\n+ProjNode* PhaseIdealLoop::clone_skeleton_predicate_for_unswitched_loops(Node* iff, ProjNode* predicate,\n+                                                                        Deoptimization::DeoptReason reason,\n+                                                                        ProjNode* output_proj) {\n+  Node* bol = clone_skeleton_predicate_bool(iff, NULL, NULL, output_proj);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1290,1 +1290,2 @@\n-        prev_proj = clone_skeleton_predicate_for_main_loop(iff, opaque_init, NULL, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);\n+        prev_proj = clone_skeleton_predicate_for_main_or_post_loop(iff, opaque_init, NULL, predicate, uncommon_proj,\n+                                                                   current_proj, outer_loop, prev_proj);\n@@ -1293,1 +1294,2 @@\n-        prev_proj = clone_skeleton_predicate_for_main_loop(iff, init, stride, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);\n+        prev_proj = clone_skeleton_predicate_for_main_or_post_loop(iff, init, stride, predicate, uncommon_proj,\n+                                                                   current_proj, outer_loop, prev_proj);\n@@ -1370,2 +1372,1 @@\n-Node* PhaseIdealLoop::clone_skeleton_predicate_bool(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj,\n-                                                    Node* control, IdealLoopTree* outer_loop) {\n+Node* PhaseIdealLoop::clone_skeleton_predicate_bool(Node* iff, Node* new_init, Node* new_stride, Node* control) {\n@@ -1447,3 +1448,3 @@\n-Node* PhaseIdealLoop::clone_skeleton_predicate_for_main_loop(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj,\n-                                                             Node* control, IdealLoopTree* outer_loop, Node* input_proj) {\n-  Node* result = clone_skeleton_predicate_bool(iff, new_init, new_stride, predicate, uncommon_proj, control, outer_loop);\n+Node* PhaseIdealLoop::clone_skeleton_predicate_for_main_or_post_loop(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj,\n+                                                                     Node* control, IdealLoopTree* outer_loop, Node* input_proj) {\n+  Node* result = clone_skeleton_predicate_bool(iff, new_init, new_stride, control);\n@@ -1463,2 +1464,2 @@\n-  register_control(new_iff, outer_loop->_parent, input_proj);\n-  register_control(proj, outer_loop->_parent, new_iff);\n+  register_control(new_iff, outer_loop == _ltree_root ? _ltree_root : outer_loop->_parent, input_proj);\n+  register_control(proj, outer_loop == _ltree_root ? _ltree_root : outer_loop->_parent, new_iff);\n@@ -1547,1 +1548,2 @@\n-  Node *main_exit = insert_post_loop(loop, old_new, main_head, main_end, incr, limit, post_head);\n+  Node* post_incr = incr;\n+  Node* main_exit = insert_post_loop(loop, old_new, main_head, main_end, post_incr, limit, post_head);\n@@ -1646,0 +1648,1 @@\n+  copy_skeleton_predicates_to_post_loop(outer_main_head, post_head, post_incr, stride);\n@@ -1768,0 +1771,1 @@\n+  copy_skeleton_predicates_to_post_loop(main_head->skip_strip_mined(), post_head, incr, main_head->stride());\n@@ -1814,0 +1818,1 @@\n+  copy_skeleton_predicates_to_post_loop(main_head->skip_strip_mined(), post_head, incr, main_head->stride());\n@@ -1830,3 +1835,3 @@\n-Node *PhaseIdealLoop::insert_post_loop(IdealLoopTree *loop, Node_List &old_new,\n-                                       CountedLoopNode *main_head, CountedLoopEndNode *main_end,\n-                                       Node *incr, Node *limit, CountedLoopNode *&post_head) {\n+Node *PhaseIdealLoop::insert_post_loop(IdealLoopTree* loop, Node_List& old_new,\n+                                       CountedLoopNode* main_head, CountedLoopEndNode* main_end,\n+                                       Node*& incr, Node* limit, CountedLoopNode*& post_head) {\n@@ -1916,2 +1921,2 @@\n-  Node* castii = cast_incr_before_loop(zer_opaq->in(1), zer_taken, post_head);\n-  assert(castii != NULL, \"no castII inserted\");\n+  incr = cast_incr_before_loop(zer_opaq->in(1), zer_taken, post_head);\n+  assert(incr != NULL, \"no castII inserted\");\n@@ -1959,1 +1964,2 @@\n-        prev_proj = clone_skeleton_predicate_for_main_loop(iff, init, max_value, entry, proj, ctrl, outer_loop, prev_proj);\n+        prev_proj = clone_skeleton_predicate_for_main_or_post_loop(iff, init, max_value, entry, proj, ctrl, outer_loop,\n+                                                                   prev_proj);\n@@ -1971,0 +1977,28 @@\n+void PhaseIdealLoop::copy_skeleton_predicates_to_post_loop(LoopNode* main_loop_head, CountedLoopNode* post_loop_head, Node* init, Node* stride) {\n+  \/\/ Go over the skeleton predicates of the main loop and make a copy for the post loop with its initial iv value and\n+  \/\/ stride as inputs.\n+  Node* post_loop_entry = post_loop_head->in(LoopNode::EntryControl);\n+  Node* main_loop_entry = main_loop_head->in(LoopNode::EntryControl);\n+  IdealLoopTree* post_loop = get_loop(post_loop_head);\n+\n+  Node* ctrl = main_loop_entry;\n+  Node* prev_proj = post_loop_entry;\n+  while (ctrl != NULL && ctrl->is_Proj() && ctrl->in(0)->is_If()) {\n+    IfNode* iff = ctrl->in(0)->as_If();\n+    ProjNode* proj = iff->proj_out(1 - ctrl->as_Proj()->_con);\n+    if (proj->unique_ctrl_out()->Opcode() != Op_Halt) {\n+      break;\n+    }\n+    if (iff->in(1)->Opcode() == Op_Opaque4 && skeleton_predicate_has_opaque(iff)) {\n+      prev_proj = clone_skeleton_predicate_for_main_or_post_loop(iff, init, stride, ctrl, proj, post_loop_entry,\n+                                                                 post_loop, prev_proj);\n+      assert(!skeleton_predicate_has_opaque(prev_proj->in(0)->as_If()), \"unexpected\");\n+    }\n+    ctrl = ctrl->in(0)->in(0);\n+  }\n+  if (prev_proj != post_loop_entry) {\n+    _igvn.replace_input_of(post_loop_head, LoopNode::EntryControl, prev_proj);\n+    set_idom(post_loop_head, prev_proj, dom_depth(post_loop_head));\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":50,"deletions":16,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2392,0 +2392,1 @@\n+  Node* ctrl = in(LoopNode::EntryControl);\n@@ -2393,2 +2394,3 @@\n-    Node* ctrl = skip_strip_mined()->in(LoopNode::EntryControl);\n-\n+    ctrl = skip_strip_mined()->in(LoopNode::EntryControl);\n+  }\n+  if (is_main_loop() || is_post_loop()) {\n@@ -2397,1 +2399,1 @@\n-  return in(LoopNode::EntryControl);\n+  return ctrl;\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -920,4 +920,3 @@\n-  Node* clone_skeleton_predicate_for_main_loop(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj, Node* control,\n-                                               IdealLoopTree* outer_loop, Node* input_proj);\n-  Node* clone_skeleton_predicate_bool(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj, Node* control,\n-                                      IdealLoopTree* outer_loop);\n+  Node* clone_skeleton_predicate_for_main_or_post_loop(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj, Node* control,\n+                                                       IdealLoopTree* outer_loop, Node* input_proj);\n+  Node* clone_skeleton_predicate_bool(Node* iff, Node* new_init, Node* new_stride, Node* control);\n@@ -927,0 +926,1 @@\n+  void copy_skeleton_predicates_to_post_loop(LoopNode* main_loop_head, CountedLoopNode* post_loop_head, Node* init, Node* stride);\n@@ -1249,3 +1249,3 @@\n-  Node *insert_post_loop(IdealLoopTree *loop, Node_List &old_new,\n-                         CountedLoopNode *main_head, CountedLoopEndNode *main_end,\n-                         Node *incr, Node *limit, CountedLoopNode *&post_head);\n+  Node *insert_post_loop(IdealLoopTree* loop, Node_List& old_new,\n+                         CountedLoopNode* main_head, CountedLoopEndNode* main_end,\n+                         Node*& incr, Node* limit, CountedLoopNode*& post_head);\n@@ -1596,2 +1596,3 @@\n-  ProjNode* clone_skeleton_predicate_for_unswitched_loops(Node* iff, ProjNode* predicate, Node* uncommon_proj, Deoptimization::DeoptReason reason,\n-                                                          ProjNode* output_proj, IdealLoopTree* loop);\n+  ProjNode* clone_skeleton_predicate_for_unswitched_loops(Node* iff, ProjNode* predicate,\n+                                                          Deoptimization::DeoptReason reason,\n+                                                          ProjNode* output_proj);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2369,0 +2369,1 @@\n+               n->Opcode() == Op_Opaque4   ||\n@@ -2430,0 +2431,13 @@\n+      } else if (n->Opcode() == Op_Opaque4) {\n+        \/\/ With Opaque4 nodes, the expectation is that the test of input 1\n+        \/\/ is always equal to the constant value of input 2. So we can\n+        \/\/ remove the Opaque4 and replace it by input 2. In debug builds,\n+        \/\/ leave the non constant test in instead to sanity check that it\n+        \/\/ never fails (if it does, that subgraph was constructed so, at\n+        \/\/ runtime, a Halt node is executed).\n+#ifdef ASSERT\n+        _igvn.replace_node(n, n->in(1));\n+#else\n+        _igvn.replace_node(n, n->in(2));\n+#endif\n+        success = true;\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -637,6 +637,7 @@\n-    \/\/ Exclude last input arg stack slots to avoid spilling vector register there,\n-    \/\/ otherwise RegVectMask spills could stomp over stack slots in caller frame.\n-    for (; (in >= init_in) && (k < scalable_predicate_reg_slots()); k++) {\n-      scalable_stack_mask.Remove(in);\n-      in = OptoReg::add(in, -1);\n-    }\n+    if (Matcher::has_predicated_vectors()) {\n+      \/\/ Exclude last input arg stack slots to avoid spilling vector register there,\n+      \/\/ otherwise RegVectMask spills could stomp over stack slots in caller frame.\n+      for (; (in >= init_in) && (k < scalable_predicate_reg_slots()); k++) {\n+        scalable_stack_mask.Remove(in);\n+        in = OptoReg::add(in, -1);\n+      }\n@@ -644,5 +645,6 @@\n-    \/\/ For RegVectMask\n-    scalable_stack_mask.clear_to_sets(scalable_predicate_reg_slots());\n-    assert(scalable_stack_mask.is_AllStack(), \"should be infinite stack\");\n-    *idealreg2spillmask[Op_RegVectMask] = *idealreg2regmask[Op_RegVectMask];\n-    idealreg2spillmask[Op_RegVectMask]->OR(scalable_stack_mask);\n+      \/\/ For RegVectMask\n+      scalable_stack_mask.clear_to_sets(scalable_predicate_reg_slots());\n+      assert(scalable_stack_mask.is_AllStack(), \"should be infinite stack\");\n+      *idealreg2spillmask[Op_RegVectMask] = *idealreg2regmask[Op_RegVectMask];\n+      idealreg2spillmask[Op_RegVectMask]->OR(scalable_stack_mask);\n+    }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -178,0 +178,1 @@\n+class ShiftVNode;\n@@ -714,0 +715,1 @@\n+        DEFINE_CLASS_ID(ShiftV, Vector, 3)\n@@ -948,0 +950,1 @@\n+  DEFINE_CLASS_QUERY(ShiftV)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,19 +63,0 @@\n-Node* Opaque4Node::Identity(PhaseGVN* phase) {\n-  if (phase->C->post_loop_opts_phase()) {\n-    \/\/ With Opaque4 nodes, the expectation is that the test of input 1\n-    \/\/ is always equal to the constant value of input 2. So we can\n-    \/\/ remove the Opaque4 and replace it by input 2. In debug builds,\n-    \/\/ leave the non constant test in instead to sanity check that it\n-    \/\/ never fails (if it does, that subgraph was constructed so, at\n-    \/\/ runtime, a Halt node is executed).\n-#ifdef ASSERT\n-    return this->in(1);\n-#else\n-    return this->in(2);\n-#endif\n-  } else {\n-    phase->C->record_for_post_loop_opts_igvn(this);\n-  }\n-  return this;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -117,1 +117,4 @@\n-  Opaque4Node(Compile* C, Node *tst, Node* final_tst) : Node(NULL, tst, final_tst) {}\n+  Opaque4Node(Compile* C, Node *tst, Node* final_tst) : Node(NULL, tst, final_tst) {\n+    init_flags(Flag_is_macro);\n+    C->add_macro_node(this);\n+  }\n@@ -121,1 +124,0 @@\n-  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  bool        _late_inline;       \/\/ method is inlined incrementally\n@@ -78,0 +79,1 @@\n+                            NOT_PRODUCT_ARG(bool& should_delay)\n@@ -82,0 +84,1 @@\n+                                NOT_PRODUCT_ARG(bool& should_delay)\n@@ -115,0 +118,4 @@\n+  void set_late_inline() {\n+    _late_inline = true;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -529,1 +529,1 @@\n-        operation = VectorNode::make(sopc, opd1, opd2, vt, is_vector_mask(vbox_klass));\n+        operation = VectorNode::make(sopc, opd1, opd2, vt, is_vector_mask(vbox_klass), VectorNode::is_shift_opcode(opc));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -483,1 +483,1 @@\n-VectorNode* VectorNode::make(int vopc, Node* n1, Node* n2, const TypeVect* vt, bool is_mask) {\n+VectorNode* VectorNode::make(int vopc, Node* n1, Node* n2, const TypeVect* vt, bool is_mask, bool is_var_shift) {\n@@ -537,4 +537,4 @@\n-  case Op_LShiftVB: return new LShiftVBNode(n1, n2, vt);\n-  case Op_LShiftVS: return new LShiftVSNode(n1, n2, vt);\n-  case Op_LShiftVI: return new LShiftVINode(n1, n2, vt);\n-  case Op_LShiftVL: return new LShiftVLNode(n1, n2, vt);\n+  case Op_LShiftVB: return new LShiftVBNode(n1, n2, vt, is_var_shift);\n+  case Op_LShiftVS: return new LShiftVSNode(n1, n2, vt, is_var_shift);\n+  case Op_LShiftVI: return new LShiftVINode(n1, n2, vt, is_var_shift);\n+  case Op_LShiftVL: return new LShiftVLNode(n1, n2, vt, is_var_shift);\n@@ -542,4 +542,4 @@\n-  case Op_RShiftVB: return new RShiftVBNode(n1, n2, vt);\n-  case Op_RShiftVS: return new RShiftVSNode(n1, n2, vt);\n-  case Op_RShiftVI: return new RShiftVINode(n1, n2, vt);\n-  case Op_RShiftVL: return new RShiftVLNode(n1, n2, vt);\n+  case Op_RShiftVB: return new RShiftVBNode(n1, n2, vt, is_var_shift);\n+  case Op_RShiftVS: return new RShiftVSNode(n1, n2, vt, is_var_shift);\n+  case Op_RShiftVI: return new RShiftVINode(n1, n2, vt, is_var_shift);\n+  case Op_RShiftVL: return new RShiftVLNode(n1, n2, vt, is_var_shift);\n@@ -547,4 +547,4 @@\n-  case Op_URShiftVB: return new URShiftVBNode(n1, n2, vt);\n-  case Op_URShiftVS: return new URShiftVSNode(n1, n2, vt);\n-  case Op_URShiftVI: return new URShiftVINode(n1, n2, vt);\n-  case Op_URShiftVL: return new URShiftVLNode(n1, n2, vt);\n+  case Op_URShiftVB: return new URShiftVBNode(n1, n2, vt, is_var_shift);\n+  case Op_URShiftVS: return new URShiftVSNode(n1, n2, vt, is_var_shift);\n+  case Op_URShiftVI: return new URShiftVINode(n1, n2, vt, is_var_shift);\n+  case Op_URShiftVL: return new URShiftVLNode(n1, n2, vt, is_var_shift);\n@@ -566,1 +566,1 @@\n-VectorNode* VectorNode::make(int opc, Node* n1, Node* n2, uint vlen, BasicType bt) {\n+VectorNode* VectorNode::make(int opc, Node* n1, Node* n2, uint vlen, BasicType bt, bool is_var_shift) {\n@@ -571,1 +571,1 @@\n-  return make(vopc, n1, n2, vt);\n+  return make(vopc, n1, n2, vt, false, is_var_shift);\n@@ -1300,2 +1300,2 @@\n-  return new OrVNode(phase->transform(VectorNode::make(shiftLOpc, src, shiftLCnt, vlen, bt)),\n-                     phase->transform(VectorNode::make(shiftROpc, src, shiftRCnt, vlen, bt)),\n+  return new OrVNode(phase->transform(VectorNode::make(shiftLOpc, src, shiftLCnt, vlen, bt, is_binary_vector_op)),\n+                     phase->transform(VectorNode::make(shiftROpc, src, shiftRCnt, vlen, bt, is_binary_vector_op)),\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -75,2 +75,2 @@\n-  static VectorNode* make(int opc, Node* n1, Node* n2, uint vlen, BasicType bt);\n-  static VectorNode* make(int vopc, Node* n1, Node* n2, const TypeVect* vt, bool is_mask = false);\n+  static VectorNode* make(int opc, Node* n1, Node* n2, uint vlen, BasicType bt, bool is_var_shift = false);\n+  static VectorNode* make(int vopc, Node* n1, Node* n2, const TypeVect* vt, bool is_mask = false, bool is_var_shift = false);\n@@ -534,0 +534,1 @@\n+ bool _is_var_shift;\n@@ -535,1 +536,4 @@\n-  ShiftVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n+  ShiftVNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift) :\n+    VectorNode(in1,in2,vt), _is_var_shift(is_var_shift) {\n+    init_class_id(Class_ShiftV);\n+  }\n@@ -538,0 +542,2 @@\n+  bool is_var_shift() { return _is_var_shift;}\n+  virtual  uint  size_of() const { return sizeof(ShiftVNode); }\n@@ -544,1 +550,2 @@\n-  LShiftVBNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  LShiftVBNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -552,1 +559,2 @@\n-  LShiftVSNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  LShiftVSNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -560,1 +568,2 @@\n-  LShiftVINode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  LShiftVINode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -568,1 +577,2 @@\n-  LShiftVLNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  LShiftVLNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -576,1 +586,2 @@\n-  RShiftVBNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  RShiftVBNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -584,1 +595,2 @@\n-  RShiftVSNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  RShiftVSNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -592,1 +604,2 @@\n-  RShiftVINode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  RShiftVINode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -600,1 +613,2 @@\n-  RShiftVLNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  RShiftVLNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -608,1 +622,2 @@\n-  URShiftVBNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  URShiftVBNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -616,1 +631,2 @@\n-  URShiftVSNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  URShiftVSNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -624,1 +640,2 @@\n-  URShiftVINode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  URShiftVINode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -632,1 +649,2 @@\n-  URShiftVLNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  URShiftVLNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+     ShiftVNode(in1,in2,vt,is_var_shift) {}\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":33,"deletions":15,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1396,0 +1396,3 @@\n+  if (java_thread->is_exiting()) {\n+    return; \/* JVMTI_ERROR_THREAD_NOT_ALIVE (default) *\/\n+  }\n@@ -1526,0 +1529,4 @@\n+\n+  if (java_thread->is_exiting()) {\n+    return; \/* JVMTI_ERROR_THREAD_NOT_ALIVE (default) *\/\n+  }\n@@ -1602,8 +1609,6 @@\n-  if (!java_thread->is_exiting() && java_thread->threadObj() != NULL) {\n-    _state->update_for_pop_top_frame();\n-    java_thread->set_popframe_condition(JavaThread::popframe_pending_bit);\n-    \/\/ Set pending step flag for this popframe and it is cleared when next\n-    \/\/ step event is posted.\n-    _state->set_pending_step_for_popframe();\n-    _result = JVMTI_ERROR_NONE;\n-  }\n+  _state->update_for_pop_top_frame();\n+  java_thread->set_popframe_condition(JavaThread::popframe_pending_bit);\n+  \/\/ Set pending step flag for this popframe and it is cleared when next\n+  \/\/ step event is posted.\n+  _state->set_pending_step_for_popframe();\n+  _result = JVMTI_ERROR_NONE;\n@@ -1617,0 +1622,3 @@\n+  if (java_thread->is_exiting()) {\n+    return; \/* JVMTI_ERROR_THREAD_NOT_ALIVE (default) *\/\n+  }\n@@ -1636,3 +1644,0 @@\n-  if (java_thread->is_exiting() || java_thread->threadObj() == NULL) {\n-    return; \/* JVMTI_ERROR_THREAD_NOT_ALIVE (default) *\/\n-  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"prims\/jvmtiExport.hpp\"\n@@ -332,0 +333,1 @@\n+  JvmtiVMObjectAllocEventCollector oam;\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -672,1 +672,2 @@\n-  size_t            nmt_header_size = MemTracker::malloc_header_size(level);\n+  const size_t nmt_overhead =\n+      MemTracker::malloc_header_size(level) + MemTracker::malloc_footer_size(level);\n@@ -675,1 +676,1 @@\n-  const size_t alloc_size = size + nmt_header_size;\n+  const size_t alloc_size = size + nmt_overhead;\n@@ -677,2 +678,2 @@\n-  const size_t alloc_size = GuardedMemory::get_total_size(size + nmt_header_size);\n-  if (size + nmt_header_size > alloc_size) { \/\/ Check for rollover.\n+  const size_t alloc_size = GuardedMemory::get_total_size(size + nmt_overhead);\n+  if (size + nmt_overhead > alloc_size) { \/\/ Check for rollover.\n@@ -696,1 +697,1 @@\n-  GuardedMemory guarded(ptr, size + nmt_header_size);\n+  GuardedMemory guarded(ptr, size + nmt_overhead);\n@@ -744,2 +745,3 @@\n-  size_t  nmt_header_size = MemTracker::malloc_header_size(level);\n-  void* ptr = ::realloc(membase, size + nmt_header_size);\n+  const size_t nmt_overhead =\n+      MemTracker::malloc_header_size(level) + MemTracker::malloc_footer_size(level);\n+  void* ptr = ::realloc(membase, size + nmt_overhead);\n@@ -764,1 +766,4 @@\n-    size_t memblock_size = guarded.get_user_size() - MemTracker::malloc_header_size(memblock);\n+    NMT_TrackingLevel level = MemTracker::tracking_level();\n+    const size_t nmt_overhead =\n+        MemTracker::malloc_header_size(level) + MemTracker::malloc_footer_size(level);\n+    size_t memblock_size = guarded.get_user_size() - nmt_overhead;\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1913,1 +1913,0 @@\n-      _poi = Universe::heap()->parallel_object_iterator(_num_dumper_threads);\n@@ -2002,4 +2001,0 @@\n-    if (_poi != NULL) {\n-      delete _poi;\n-      _poi = NULL;\n-    }\n@@ -2255,1 +2250,8 @@\n-    workers->run_task(this);\n+    if (_num_dumper_threads > 1) {\n+      ParallelObjectIterator poi(_num_dumper_threads);\n+      _poi = &poi;\n+      workers->run_task(this);\n+      _poi = NULL;\n+    } else {\n+      workers->run_task(this);\n+    }\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-\n@@ -52,1 +51,0 @@\n-  assert((size_t)table_size <= MAX_MALLOCSITE_TABLE_SIZE, \"Hashtable overflow\");\n","filename":"src\/hotspot\/share\/services\/mallocSiteTable.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -117,0 +117,3 @@\n+  \/\/ The table must not be wider than the maximum value the bucket_idx field\n+  \/\/ in the malloc header can hold.\n+  STATIC_ASSERT(table_size <= MAX_MALLOCSITE_TABLE_SIZE);\n","filename":"src\/hotspot\/share\/services\/mallocSiteTable.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -30,0 +31,2 @@\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/ostream.hpp\"\n@@ -106,1 +109,7 @@\n-void MallocHeader::release() const {\n+void MallocHeader::mark_block_as_dead() {\n+  _canary = _header_canary_dead_mark;\n+  NOT_LP64(_alt_canary = _header_alt_canary_dead_mark);\n+  set_footer(_footer_canary_dead_mark);\n+}\n+\n+void MallocHeader::release() {\n@@ -110,0 +119,2 @@\n+  check_block_integrity();\n+\n@@ -115,0 +126,95 @@\n+\n+  mark_block_as_dead();\n+}\n+\n+void MallocHeader::print_block_on_error(outputStream* st, address bad_address) const {\n+  assert(bad_address >= (address)this, \"sanity\");\n+\n+  \/\/ This function prints block information, including hex dump, in case of a detected\n+  \/\/ corruption. The hex dump should show both block header and corruption site\n+  \/\/ (which may or may not be close together or identical). Plus some surrounding area.\n+  \/\/\n+  \/\/ Note that we use os::print_hex_dump(), which is able to cope with unmapped\n+  \/\/ memory (it uses SafeFetch).\n+\n+  st->print_cr(\"NMT Block at \" PTR_FORMAT \", corruption at: \" PTR_FORMAT \": \",\n+               p2i(this), p2i(bad_address));\n+  static const size_t min_dump_length = 256;\n+  address from1 = align_down((address)this, sizeof(void*)) - (min_dump_length \/ 2);\n+  address to1 = from1 + min_dump_length;\n+  address from2 = align_down(bad_address, sizeof(void*)) - (min_dump_length \/ 2);\n+  address to2 = from2 + min_dump_length;\n+  if (from2 > to1) {\n+    \/\/ Dump gets too large, split up in two sections.\n+    os::print_hex_dump(st, from1, to1, 1);\n+    st->print_cr(\"...\");\n+    os::print_hex_dump(st, from2, to2, 1);\n+  } else {\n+    \/\/ print one hex dump\n+    os::print_hex_dump(st, from1, to2, 1);\n+  }\n+}\n+\n+\/\/ Check block integrity. If block is broken, print out a report\n+\/\/ to tty (optionally with hex dump surrounding the broken block),\n+\/\/ then trigger a fatal error.\n+void MallocHeader::check_block_integrity() const {\n+\n+#define PREFIX \"NMT corruption: \"\n+  \/\/ Note: if you modify the error messages here, make sure you\n+  \/\/ adapt the associated gtests too.\n+\n+  \/\/ Weed out obviously wrong block addresses of NULL or very low\n+  \/\/ values. Note that we should not call this for ::free(NULL),\n+  \/\/ which should be handled by os::free() above us.\n+  if (((size_t)p2i(this)) < K) {\n+    fatal(PREFIX \"Block at \" PTR_FORMAT \": invalid block address\", p2i(this));\n+  }\n+\n+  \/\/ From here on we assume the block pointer to be valid. We could\n+  \/\/ use SafeFetch but since this is a hot path we don't. If we are\n+  \/\/ wrong, we will crash when accessing the canary, which hopefully\n+  \/\/ generates distinct crash report.\n+\n+  \/\/ Weed out obviously unaligned addresses. NMT blocks, being the result of\n+  \/\/ malloc calls, should adhere to malloc() alignment. Malloc alignment is\n+  \/\/ specified by the standard by this requirement:\n+  \/\/ \"malloc returns a pointer which is suitably aligned for any built-in type\"\n+  \/\/ For us it means that it is *at least* 64-bit on all of our 32-bit and\n+  \/\/ 64-bit platforms since we have native 64-bit types. It very probably is\n+  \/\/ larger than that, since there exist scalar types larger than 64bit. Here,\n+  \/\/ we test the smallest alignment we know.\n+  \/\/ Should we ever start using std::max_align_t, this would be one place to\n+  \/\/ fix up.\n+  if (!is_aligned(this, sizeof(uint64_t))) {\n+    print_block_on_error(tty, (address)this);\n+    fatal(PREFIX \"Block at \" PTR_FORMAT \": block address is unaligned\", p2i(this));\n+  }\n+\n+  \/\/ Check header canary\n+  if (_canary != _header_canary_life_mark) {\n+    print_block_on_error(tty, (address)this);\n+    fatal(PREFIX \"Block at \" PTR_FORMAT \": header canary broken.\", p2i(this));\n+  }\n+\n+#ifndef _LP64\n+  \/\/ On 32-bit we have a second canary, check that one too.\n+  if (_alt_canary != _header_alt_canary_life_mark) {\n+    print_block_on_error(tty, (address)this);\n+    fatal(PREFIX \"Block at \" PTR_FORMAT \": header alternate canary broken.\", p2i(this));\n+  }\n+#endif\n+\n+  \/\/ Does block size seems reasonable?\n+  if (_size >= max_reasonable_malloc_size) {\n+    print_block_on_error(tty, (address)this);\n+    fatal(PREFIX \"Block at \" PTR_FORMAT \": header looks invalid (weirdly large block size)\", p2i(this));\n+  }\n+\n+  \/\/ Check footer canary\n+  if (get_footer() != _footer_canary_life_mark) {\n+    print_block_on_error(tty, footer_address());\n+    fatal(PREFIX \"Block at \" PTR_FORMAT \": footer canary broken at \" PTR_FORMAT \" (buffer overflow?)\",\n+          p2i(this), p2i(footer_address()));\n+  }\n+#undef PREFIX\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":107,"deletions":1,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -242,2 +242,50 @@\n- * To satisfy malloc alignment requirement, NMT uses 2 machine words for tracking purpose,\n- * which ensures 8-bytes alignment on 32-bit systems and 16-bytes on 64-bit systems (Product build).\n+ *\n+ * If NMT is active (state >= minimal), we need to track allocations. A simple and cheap way to\n+ * do this is by using malloc headers.\n+ *\n+ * The user allocation is preceded by a header and is immediately followed by a (possibly unaligned)\n+ *  footer canary:\n+ *\n+ * +--------------+-------------  ....  ------------------+-----+\n+ * |    header    |               user                    | can |\n+ * |              |             allocation                | ary |\n+ * +--------------+-------------  ....  ------------------+-----+\n+ *     16 bytes              user size                      2 byte\n+ *\n+ * Alignment:\n+ *\n+ * The start of the user allocation needs to adhere to malloc alignment. We assume 128 bits\n+ * on both 64-bit\/32-bit to be enough for that. So the malloc header is 16 bytes long on both\n+ * 32-bit and 64-bit.\n+ *\n+ * Layout on 64-bit:\n+ *\n+ *     0        1        2        3        4        5        6        7\n+ * +--------+--------+--------+--------+--------+--------+--------+--------+\n+ * |                            64-bit size                                |  ...\n+ * +--------+--------+--------+--------+--------+--------+--------+--------+\n+ *\n+ *           8        9        10       11       12       13       14       15          16 ++\n+ *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n+ *  ...  |   bucket idx    |     pos idx     | flags  | unused |     canary      |  ... User payload ....\n+ *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n+ *\n+ * Layout on 32-bit:\n+ *\n+ *     0        1        2        3        4        5        6        7\n+ * +--------+--------+--------+--------+--------+--------+--------+--------+\n+ * |            alt. canary            |           32-bit size             |  ...\n+ * +--------+--------+--------+--------+--------+--------+--------+--------+\n+ *\n+ *           8        9        10       11       12       13       14       15          16 ++\n+ *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n+ *  ...  |   bucket idx    |     pos idx     | flags  | unused |     canary      |  ... User payload ....\n+ *       +--------+--------+--------+--------+--------+--------+--------+--------+  ------------------------\n+ *\n+ * Notes:\n+ * - We have a canary in the two bytes directly preceding the user payload. That allows us to\n+ *   catch negative buffer overflows.\n+ * - On 32-bit, due to the smaller size_t, we have some bits to spare. So we also have a second\n+ *   canary at the very start of the malloc header (generously sized 32 bits).\n+ * - The footer canary consists of two bytes. Since the footer location may be unaligned to 16 bits,\n+ *   the bytes are stored individually.\n@@ -247,15 +295,34 @@\n-#ifdef _LP64\n-  size_t           _size      : 64;\n-  size_t           _flags     : 8;\n-  size_t           _pos_idx   : 16;\n-  size_t           _bucket_idx: 40;\n-#define MAX_MALLOCSITE_TABLE_SIZE right_n_bits(40)\n-#define MAX_BUCKET_LENGTH         right_n_bits(16)\n-#else\n-  size_t           _size      : 32;\n-  size_t           _flags     : 8;\n-  size_t           _pos_idx   : 8;\n-  size_t           _bucket_idx: 16;\n-#define MAX_MALLOCSITE_TABLE_SIZE  right_n_bits(16)\n-#define MAX_BUCKET_LENGTH          right_n_bits(8)\n-#endif  \/\/ _LP64\n+\n+  NOT_LP64(uint32_t _alt_canary);\n+  size_t _size;\n+  uint16_t _bucket_idx;\n+  uint16_t _pos_idx;\n+  uint8_t _flags;\n+  uint8_t _unused;\n+  uint16_t _canary;\n+\n+#define MAX_MALLOCSITE_TABLE_SIZE (USHRT_MAX - 1)\n+#define MAX_BUCKET_LENGTH         (USHRT_MAX - 1)\n+\n+  static const uint16_t _header_canary_life_mark = 0xE99E;\n+  static const uint16_t _header_canary_dead_mark = 0xD99D;\n+  static const uint16_t _footer_canary_life_mark = 0xE88E;\n+  static const uint16_t _footer_canary_dead_mark = 0xD88D;\n+  NOT_LP64(static const uint32_t _header_alt_canary_life_mark = 0xE99EE99E;)\n+  NOT_LP64(static const uint32_t _header_alt_canary_dead_mark = 0xD88DD88D;)\n+\n+  \/\/ We discount sizes larger than these\n+  static const size_t max_reasonable_malloc_size = LP64_ONLY(256 * G) NOT_LP64(3500 * M);\n+\n+  \/\/ Check block integrity. If block is broken, print out a report\n+  \/\/ to tty (optionally with hex dump surrounding the broken block),\n+  \/\/ then trigger a fatal error.\n+  void check_block_integrity() const;\n+  void print_block_on_error(outputStream* st, address bad_address) const;\n+  void mark_block_as_dead();\n+\n+  static uint16_t build_footer(uint8_t b1, uint8_t b2) { return ((uint16_t)b1 << 8) | (uint16_t)b2; }\n+\n+  uint8_t* footer_address() const   { return ((address)this) + sizeof(MallocHeader) + _size; }\n+  uint16_t get_footer() const       { return build_footer(footer_address()[0], footer_address()[1]); }\n+  void set_footer(uint16_t v)       { footer_address()[0] = v >> 8; footer_address()[1] = (uint8_t)v; }\n@@ -264,0 +331,1 @@\n+\n@@ -265,2 +333,2 @@\n-    assert(sizeof(MallocHeader) == sizeof(void*) * 2,\n-      \"Wrong header size\");\n+\n+    assert(size < max_reasonable_malloc_size, \"Too large allocation size?\");\n@@ -280,2 +348,2 @@\n-        _bucket_idx = bucket_idx;\n-        _pos_idx = pos_idx;\n+        _bucket_idx = (uint16_t)bucket_idx;\n+        _pos_idx = (uint16_t)pos_idx;\n@@ -285,0 +353,7 @@\n+    _unused = 0;\n+    _canary = _header_canary_life_mark;\n+    \/\/ On 32-bit we have some bits more, use them for a second canary\n+    \/\/ guarding the start of the header.\n+    NOT_LP64(_alt_canary = _header_alt_canary_life_mark;)\n+    set_footer(_footer_canary_life_mark); \/\/ set after initializing _size\n+\n@@ -293,2 +368,2 @@\n-  \/\/ Cleanup tracking information before the memory is released.\n-  void release() const;\n+  \/\/ Cleanup tracking information and mark block as dead before the memory is released.\n+  void release();\n@@ -304,0 +379,3 @@\n+\/\/ This needs to be true on both 64-bit and 32-bit platforms\n+STATIC_ASSERT(sizeof(MallocHeader) == (sizeof(uint64_t) * 2));\n+\n@@ -318,0 +396,5 @@\n+  \/\/ malloc tracking footer size for specific tracking level\n+  static inline size_t malloc_footer_size(NMT_TrackingLevel level) {\n+    return (level == NMT_off) ? 0 : sizeof(uint16_t);\n+  }\n+\n@@ -352,5 +435,0 @@\n-  \/\/ Get header size\n-  static inline size_t get_header_size(void* memblock) {\n-    return (memblock == NULL) ? 0 : sizeof(MallocHeader);\n-  }\n-\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":106,"deletions":28,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+  static inline size_t malloc_footer_size(NMT_TrackingLevel level) { return 0; }\n@@ -160,5 +161,3 @@\n-  static size_t malloc_header_size(void* memblock) {\n-    if (tracking_level() != NMT_off) {\n-      return MallocTracker::get_header_size(memblock);\n-    }\n-    return 0;\n+  \/\/ malloc tracking footer size for specific tracking level\n+  static inline size_t malloc_footer_size(NMT_TrackingLevel level) {\n+    return MallocTracker::malloc_footer_size(level);\n","filename":"src\/hotspot\/share\/services\/memTracker.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -240,1 +240,0 @@\n-#ifdef ASSERT\n@@ -265,1 +264,0 @@\n-#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -300,0 +300,9 @@\n+        \/**\n+         * Property to control {@link GetField#get(String, Object)} conversion of\n+         * {@link ClassNotFoundException} to {@code null}. If set to {@code true}\n+         * {@link GetField#get(String, Object)} returns null otherwise\n+         * throwing {@link ClassNotFoundException}.\n+         *\/\n+        private static final boolean GETFIELD_CNFE_RETURNS_NULL = GetBooleanAction\n+                .privilegedGetProperty(\"jdk.serialGetFieldCnfeReturnsNull\");\n+\n@@ -1599,0 +1608,1 @@\n+         * @throws ClassNotFoundException Class of a serialized object cannot be found.\n@@ -1604,1 +1614,1 @@\n-        public abstract Object get(String name, Object val) throws IOException;\n+        public abstract Object get(String name, Object val) throws IOException, ClassNotFoundException;\n@@ -2648,1 +2658,1 @@\n-        public Object get(String name, Object val) {\n+        public Object get(String name, Object val) throws ClassNotFoundException {\n@@ -2653,2 +2663,8 @@\n-                return (handles.lookupException(objHandle) == null) ?\n-                    objValues[off] : null;\n+                ClassNotFoundException ex = handles.lookupException(objHandle);\n+                if (ex == null)\n+                    return objValues[off];\n+                if (Caches.GETFIELD_CNFE_RETURNS_NULL) {\n+                    \/\/ Revert to the prior behavior; return null instead of CNFE\n+                    return null;\n+                }\n+                throw ex;\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n@@ -115,2 +113,1 @@\n-    \/\/ true, if this module allows restricted native access; @Stable makes sure that modules that allow native\n-    \/\/ access capture this property as a constant.\n+    \/\/ true, if this module allows restricted native access\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1583,0 +1583,5 @@\n+            @Override\n+            public void ensureCustomized(MethodHandle mh) {\n+                mh.customize();\n+            }\n+\n@@ -1624,0 +1629,1 @@\n+\n@@ -2274,8 +2280,8 @@\n-            MH_cast                               = 0,\n-            MH_selectAlternative                  = 1,\n-            MH_countedLoopPred                    = 2,\n-            MH_countedLoopStep                    = 3,\n-            MH_initIterator                       = 4,\n-            MH_iteratePred                        = 5,\n-            MH_iterateNext                        = 6,\n-            MH_Array_newInstance                  = 7,\n+            MH_cast                  =              0,\n+            MH_selectAlternative     =              1,\n+            MH_countedLoopPred       =              2,\n+            MH_countedLoopStep       =              3,\n+            MH_initIterator          =              4,\n+            MH_iteratePred           =              5,\n+            MH_iterateNext           =              6,\n+            MH_Array_newInstance     =              7,\n@@ -2283,1 +2289,1 @@\n-            MH_LIMIT                              = 9;\n+            MH_LIMIT                 =              9;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.invoke.StringConcatFactory;\n@@ -35,0 +36,1 @@\n+import java.util.ArrayList;\n@@ -55,0 +57,2 @@\n+    private static final int MAX_STRING_CONCAT_SLOTS = 20;\n+\n@@ -254,2 +258,3 @@\n-    private static MethodHandle makeToString(Class<?> receiverClass,\n-                                            List<MethodHandle> getters,\n+    private static MethodHandle makeToString(MethodHandles.Lookup lookup,\n+                                            Class<?> receiverClass,\n+                                            MethodHandle[] getters,\n@@ -257,20 +262,6 @@\n-        \/\/ This is a pretty lousy algorithm; we spread the receiver over N places,\n-        \/\/ apply the N getters, apply N toString operations, and concat the result with String.format\n-        \/\/ Better to use String.format directly, or delegate to StringConcatFactory\n-        \/\/ Also probably want some quoting around String components\n-\n-        assert getters.size() == names.size();\n-\n-        int[] invArgs = new int[getters.size()];\n-        Arrays.fill(invArgs, 0);\n-        MethodHandle[] filters = new MethodHandle[getters.size()];\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(receiverClass.getSimpleName()).append(\"[\");\n-        for (int i=0; i<getters.size(); i++) {\n-            MethodHandle getter = getters.get(i); \/\/ (R)T\n-            MethodHandle stringify = stringifier(getter.type().returnType()); \/\/ (T)String\n-            MethodHandle stringifyThisField = MethodHandles.filterArguments(stringify, 0, getter);    \/\/ (R)String\n-            filters[i] = stringifyThisField;\n-            sb.append(names.get(i)).append(\"=%s\");\n-            if (i != getters.size() - 1)\n-                sb.append(\", \");\n+        assert getters.length == names.size();\n+        if (getters.length == 0) {\n+            \/\/ special case\n+            MethodHandle emptyRecordCase = MethodHandles.constant(String.class, receiverClass.getSimpleName() + \"[]\");\n+            emptyRecordCase = MethodHandles.dropArguments(emptyRecordCase, 0, receiverClass); \/\/ (R)S\n+            return emptyRecordCase;\n@@ -278,7 +269,85 @@\n-        sb.append(']');\n-        String formatString = sb.toString();\n-        MethodHandle formatter = MethodHandles.insertArguments(STRING_FORMAT, 0, formatString)\n-                                              .asCollector(String[].class, getters.size()); \/\/ (R*)String\n-        if (getters.size() == 0) {\n-            \/\/ Add back extra R\n-            formatter = MethodHandles.dropArguments(formatter, 0, receiverClass);\n+\n+        boolean firstTime = true;\n+        MethodHandle[] mhs;\n+        List<List<MethodHandle>> splits;\n+        MethodHandle[] toSplit = getters;\n+        int namesIndex = 0;\n+        do {\n+            \/* StringConcatFactory::makeConcatWithConstants can only deal with 200 slots, longs and double occupy two\n+             * the rest 1 slot, we need to chop the current `getters` into chunks, it could be that for records with\n+             * a lot of components that we need to do a couple of iterations. The main difference between the first\n+             * iteration and the rest would be on the recipe\n+             *\/\n+            splits = split(toSplit);\n+            mhs = new MethodHandle[splits.size()];\n+            for (int splitIndex = 0; splitIndex < splits.size(); splitIndex++) {\n+                String recipe = \"\";\n+                if (firstTime && splitIndex == 0) {\n+                    recipe = receiverClass.getSimpleName() + \"[\";\n+                }\n+                for (int i = 0; i < splits.get(splitIndex).size(); i++) {\n+                    recipe += firstTime ? names.get(namesIndex) + \"=\" + \"\\1\" : \"\\1\";\n+                    if (firstTime && namesIndex != names.size() - 1) {\n+                        recipe += \", \";\n+                    }\n+                    namesIndex++;\n+                }\n+                if (firstTime && splitIndex == splits.size() - 1) {\n+                    recipe += \"]\";\n+                }\n+                Class<?>[] concatTypeArgs = new Class<?>[splits.get(splitIndex).size()];\n+                \/\/ special case: no need to create another getters if there is only one split\n+                MethodHandle[] currentSplitGetters = new MethodHandle[splits.get(splitIndex).size()];\n+                for (int j = 0; j < splits.get(splitIndex).size(); j++) {\n+                    concatTypeArgs[j] = splits.get(splitIndex).get(j).type().returnType();\n+                    currentSplitGetters[j] = splits.get(splitIndex).get(j);\n+                }\n+                MethodType concatMT = MethodType.methodType(String.class, concatTypeArgs);\n+                try {\n+                    mhs[splitIndex] = StringConcatFactory.makeConcatWithConstants(\n+                            lookup, \"\",\n+                            concatMT,\n+                            recipe,\n+                            new Object[0]\n+                    ).getTarget();\n+                    mhs[splitIndex] = MethodHandles.filterArguments(mhs[splitIndex], 0, currentSplitGetters);\n+                    \/\/ this will spread the receiver class across all the getters\n+                    mhs[splitIndex] = MethodHandles.permuteArguments(\n+                            mhs[splitIndex],\n+                            MethodType.methodType(String.class, receiverClass),\n+                            new int[splits.get(splitIndex).size()]\n+                    );\n+                } catch (Throwable t) {\n+                    throw new RuntimeException(t);\n+                }\n+            }\n+            toSplit = mhs;\n+            firstTime = false;\n+        } while (splits.size() > 1);\n+        return mhs[0];\n+    }\n+\n+    \/**\n+     * Chops the getters into smaller chunks according to the maximum number of slots\n+     * StringConcatFactory::makeConcatWithConstants can chew\n+     * @param getters the current getters\n+     * @return chunks that wont surpass the maximum number of slots StringConcatFactory::makeConcatWithConstants can chew\n+     *\/\n+    private static List<List<MethodHandle>> split(MethodHandle[] getters) {\n+        List<List<MethodHandle>> splits = new ArrayList<>();\n+\n+        int slots = 0;\n+\n+        \/\/ Need to peel, so that neither call has more than acceptable number\n+        \/\/ of slots for the arguments.\n+        List<MethodHandle> cArgs = new ArrayList<>();\n+        for (MethodHandle methodHandle : getters) {\n+            Class<?> returnType = methodHandle.type().returnType();\n+            int needSlots = (returnType == long.class || returnType == double.class) ? 2 : 1;\n+            if (slots + needSlots > MAX_STRING_CONCAT_SLOTS) {\n+                splits.add(cArgs);\n+                cArgs = new ArrayList<>();\n+                slots = 0;\n+            }\n+            cArgs.add(methodHandle);\n+            slots += needSlots;\n@@ -286,3 +355,4 @@\n-        else {\n-            MethodHandle filtered = MethodHandles.filterArguments(formatter, 0, filters);\n-            formatter = MethodHandles.permuteArguments(filtered, MethodType.methodType(String.class, receiverClass), invArgs);\n+\n+        \/\/ Flush the tail slice\n+        if (!cArgs.isEmpty()) {\n+            splits.add(cArgs);\n@@ -291,1 +361,1 @@\n-        return formatter;\n+        return splits;\n@@ -370,1 +440,1 @@\n-                yield makeToString(recordClass, getterList, nameList);\n+                yield makeToString(lookup, recordClass, getters, nameList);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ObjectMethods.java","additions":104,"deletions":34,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -1081,1 +1081,1 @@\n-        if (header.indexOf(\"expires=\") != -1) {\n+        if (header.contains(\"expires=\")) {\n@@ -1084,1 +1084,1 @@\n-        } else if (header.indexOf(\"version=\") != -1) {\n+        } else if (header.contains(\"version=\")) {\n@@ -1087,1 +1087,1 @@\n-        } else if (header.indexOf(\"max-age\") != -1) {\n+        } else if (header.contains(\"max-age\")) {\n","filename":"src\/java.base\/share\/classes\/java\/net\/HttpCookie.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -603,1 +603,1 @@\n-            if (dateString.indexOf(\"GMT\") == -1) {\n+            if (!dateString.contains(\"GMT\")) {\n","filename":"src\/java.base\/share\/classes\/java\/net\/HttpURLConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.net.InetAddress;\n@@ -38,1 +37,0 @@\n-import java.security.Security;\n@@ -336,1 +334,1 @@\n-                    } else if (tokens == 8 && host.indexOf(\"::\") == -1) {\n+                    } else if (tokens == 8 && !host.contains(\"::\")) {\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketPermission.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1065,1 +1065,1 @@\n-    @jdk.internal.ValueBased\n+    \/\/ Not a jdk.internal.ValueBased class; disqualified by fields in superclass AbstractMap\n@@ -1096,1 +1096,1 @@\n-    @jdk.internal.ValueBased\n+    \/\/ Not a jdk.internal.ValueBased class; disqualified by fields in superclass AbstractMap\n@@ -1163,1 +1163,1 @@\n-    @jdk.internal.ValueBased\n+    \/\/ Not a jdk.internal.ValueBased class; disqualified by fields in superclass AbstractMap\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1199,1 +1199,1 @@\n-         * @implSpec The default implementation calls {@link JumpableGenerator#jump jump}().\n+         * @implSpec The default implementation calls {@link JumpableGenerator#jumps jumps}().\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/RandomGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -350,1 +350,3 @@\n- * interface {@link RandomGenerator.LeapableGenerator}. There is also an interface\n+ * interface {@link RandomGenerator.LeapableGenerator}. In this package,\n+ * implementations of this interface include \"Xoroshiro128PlusPlus\" and\n+ * \"Xoshiro256PlusPlus\". There is also an interface\n@@ -352,4 +354,2 @@\n- * jumping along the state cycle by any user-specified distance. In this package,\n- * implementations of these interfaces include\n- * \"Xoroshiro128PlusPlus\", and\n- * \"Xoshiro256PlusPlus\".\n+ * jumping along the state cycle by any user-specified distance; there are currently\n+ * no implementations of this interface in this package.\n@@ -385,2 +385,2 @@\n- * Vigna in \"Scrambled Linear Pseudorandom Number Generators\", ACM Transactions\n- * on Mathematical Software, 2021) with an LCG that uses one of the best\n+ * Vigna in \"Scrambled Linear Pseudorandom Number Generators\", <i>ACM Transactions\n+ * on Mathematical Software<\/i>, 2021) with an LCG that uses one of the best\n@@ -388,4 +388,9 @@\n- * in 2019 by Steele and Vigna), and then applies either a mixing function\n- * identified by Doug Lea or a simple scrambler proposed by Blackman and Vigna.\n- * Testing has confirmed that the LXM algorithm is far superior in quality to\n- * the SplitMix algorithm (2014) used by {@code SplittableRandom}.\n+ * in 2019 by Steele and Vigna, described in \"Computationally Easy, Spectrally\n+ * Good Multipliers for Congruential Pseudorandom Number Generators\",\n+ * <i>Software: Practice and Experience<\/i> (2021), doi:10.1002\/spe.3030),\n+ * and then applies either a mixing function identified by Doug Lea or\n+ * or a simple scrambler proposed by Blackman and Vigna. Testing has\n+ * confirmed that the LXM algorithm is far superior in quality to the\n+ * SplitMix algorithm (2014) used by {@code SplittableRandom}\n+ * (see Steele and Vigna, \"LXM: Better Splittable Pseudorandom Number\n+ * Generators (and Almost as Fast)\", <i>Proc. 2021 ACM OOPSLA Conference<\/i>).\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/package-info.java","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -5608,0 +5608,31 @@\n+    private static CharPredicate and(CharPredicate p1, CharPredicate p2,\n+                                     boolean bmpChar) {\n+        if (bmpChar) {\n+            return (BmpCharPredicate)(ch -> p1.is(ch) && p2.is(ch));\n+        } else {\n+            return (CharPredicate)(ch -> p1.is(ch) && p2.is(ch));\n+        }\n+    }\n+\n+    private static CharPredicate union(CharPredicate p1, CharPredicate p2,\n+                                       boolean bmpChar) {\n+        if (bmpChar) {\n+            return (BmpCharPredicate)(ch -> p1.is(ch) || p2.is(ch));\n+        } else {\n+            return (CharPredicate)(ch -> p1.is(ch) || p2.is(ch));\n+        }\n+    }\n+\n+    private static CharPredicate union(CharPredicate p1, CharPredicate p2,\n+                                       CharPredicate p3, boolean bmpChar) {\n+        if (bmpChar) {\n+            return (BmpCharPredicate)(ch -> p1.is(ch) || p2.is(ch) || p3.is(ch));\n+        } else {\n+            return (CharPredicate)(ch -> p1.is(ch) || p2.is(ch) || p3.is(ch));\n+        }\n+    }\n+\n+    private static CharPredicate negate(CharPredicate p1) {\n+        return (CharPredicate)(ch -> !p1.is(ch));\n+    }\n+\n@@ -5613,1 +5644,1 @@\n-            return ch -> is(ch) && p.is(ch);\n+            return Pattern.and(this, p, false);\n@@ -5616,1 +5647,1 @@\n-            return ch -> is(ch) || p.is(ch);\n+            return Pattern.union(this, p, false);\n@@ -5620,1 +5651,1 @@\n-            return ch -> is(ch) || p1.is(ch) || p2.is(ch);\n+            return Pattern.union(this, p1, p2, false);\n@@ -5623,1 +5654,1 @@\n-            return ch -> !is(ch);\n+            return Pattern.negate(this);\n@@ -5630,3 +5661,1 @@\n-            if (p instanceof BmpCharPredicate)\n-                return (BmpCharPredicate)(ch -> is(ch) && p.is(ch));\n-            return ch -> is(ch) && p.is(ch);\n+            return Pattern.and(this, p, p instanceof BmpCharPredicate);\n@@ -5635,17 +5664,7 @@\n-            if (p instanceof BmpCharPredicate)\n-                return (BmpCharPredicate)(ch -> is(ch) || p.is(ch));\n-            return ch -> is(ch) || p.is(ch);\n-        }\n-        static CharPredicate union(CharPredicate... predicates) {\n-            CharPredicate cp = ch -> {\n-                for (CharPredicate p : predicates) {\n-                    if (!p.is(ch))\n-                        return false;\n-                }\n-                return true;\n-            };\n-            for (CharPredicate p : predicates) {\n-                if (! (p instanceof BmpCharPredicate))\n-                    return cp;\n-            }\n-            return (BmpCharPredicate)cp;\n+            return Pattern.union(this, p, p instanceof BmpCharPredicate);\n+        }\n+        default CharPredicate union(CharPredicate p1,\n+                                    CharPredicate p2) {\n+            return Pattern.union(this, p1, p2,\n+                                 p1 instanceof BmpCharPredicate &&\n+                                 p2 instanceof BmpCharPredicate);\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Pattern.java","additions":43,"deletions":24,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -147,0 +147,1 @@\n+        byte[] bytes = null;\n@@ -148,3 +149,4 @@\n-            this.comment = zc.getBytes(comment);\n-            if (this.comment.length > 0xffff)\n-                throw new IllegalArgumentException(\"ZIP file comment too long.\");\n+            bytes = zc.getBytes(comment);\n+            if (bytes.length > 0xffff) {\n+                throw new IllegalArgumentException(\"ZIP file comment too long\");\n+            }\n@@ -152,0 +154,1 @@\n+        this.comment = bytes;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipOutputStream.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -139,3 +139,3 @@\n-     * A best-effort method that tries to find any exceptions thrown by the given method handle.\n-     * @param handle the handle to check\n-     * @return an array of exceptions, or {@code null}.\n+     * Ensure given method handle is customized\n+     *\n+     * @param mh the method handle\n@@ -143,1 +143,1 @@\n-    Class<?>[] exceptionTypes(MethodHandle handle);\n+    void ensureCustomized(MethodHandle mh);\n@@ -183,0 +183,7 @@\n+\n+    \/**\n+     * A best-effort method that tries to find any exceptions thrown by the given method handle.\n+     * @param handle the handle to check\n+     * @return an array of exceptions, or {@code null}.\n+     *\/\n+    Class<?>[] exceptionTypes(MethodHandle handle);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -488,1 +488,1 @@\n-        if (length == 0 || (path.indexOf(\".\/\") == -1 && path.charAt(length - 1) != '.')) {\n+        if (length == 0 || (!path.contains(\".\/\") && path.charAt(length - 1) != '.')) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/JrtPath.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -564,1 +564,1 @@\n-                        perm.getActions().indexOf(\"read\") != -1) {\n+                        perm.getActions().contains(\"read\")) {\n@@ -568,1 +568,1 @@\n-                        perm.getActions().indexOf(\"connect\") != -1) {\n+                        perm.getActions().contains(\"connect\")) {\n@@ -1257,1 +1257,1 @@\n-                if (name.indexOf(\"..\") != -1) {\n+                if (name.contains(\"..\")) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-    private String getQualifiedFieldName() {\n+    protected String getQualifiedFieldName() {\n@@ -226,10 +226,0 @@\n-    protected String getMessage(boolean getter, String attemptedType) {\n-        String err = \"Can not \" + (getter ? \"get\" : \"set\");\n-        if (Modifier.isStatic(field.getModifiers()))\n-            err += \" static\";\n-        if (Modifier.isFinal(field.getModifiers()))\n-            err += \" final\";\n-        err += \" \" + field.getType().getName() + \" field \" + getQualifiedFieldName() + \" on \" + attemptedType;\n-        return err;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/FieldAccessorImpl.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-        ensureObj(obj);\n@@ -69,1 +68,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -125,1 +124,0 @@\n-        ensureObj(obj);\n@@ -127,0 +125,1 @@\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -138,1 +137,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleBooleanFieldAccessorImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -130,1 +130,0 @@\n-        ensureObj(obj);\n@@ -132,0 +131,1 @@\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -143,1 +143,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleByteFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -105,0 +105,1 @@\n+        ensureObj(obj);\n@@ -106,1 +107,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -149,1 +149,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleCharacterFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -105,0 +105,1 @@\n+        ensureObj(obj);\n@@ -106,1 +107,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -198,1 +198,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleDoubleFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.reflect.Modifier;\n@@ -67,0 +68,13 @@\n+    private String getMessage(boolean getter, Class<?> type) {\n+        String err = \"Can not \" + (getter ? \"get\" : \"set\");\n+        if (Modifier.isStatic(field.getModifiers()))\n+            err += \" static\";\n+        if (Modifier.isFinal(field.getModifiers()))\n+            err += \" final\";\n+        err += \" \" + field.getType().getName() + \" field \" + getQualifiedFieldName();\n+        if (type != null) {\n+            err += \" on \" + type.getName();\n+        }\n+        return err;\n+    }\n+\n@@ -71,2 +85,2 @@\n-    protected IllegalArgumentException newGetIllegalArgumentException(Class<?> type) {\n-        return new IllegalArgumentException(getMessage(true, type.getName()));\n+    protected IllegalArgumentException newGetIllegalArgumentException(Object o) {\n+        return new IllegalArgumentException(getMessage(true, o != null ? o.getClass() : null));\n@@ -79,2 +93,2 @@\n-    protected IllegalArgumentException newSetIllegalArgumentException(Class<?> type) {\n-        return new IllegalArgumentException(getMessage(false, type.getName()));\n+    protected IllegalArgumentException newSetIllegalArgumentException(Object o) {\n+        return new IllegalArgumentException(getMessage(false, o != null ? o.getClass() : null));\n@@ -82,2 +96,0 @@\n-\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleFieldAccessorImpl.java","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -105,0 +105,1 @@\n+        ensureObj(obj);\n@@ -106,1 +107,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -189,1 +189,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleFloatFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -105,0 +105,1 @@\n+        ensureObj(obj);\n@@ -106,1 +107,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -171,1 +171,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleIntegerFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -105,0 +105,1 @@\n+        ensureObj(obj);\n@@ -106,1 +107,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -180,1 +180,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleLongFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -101,0 +101,1 @@\n+        ensureObj(obj);\n@@ -102,1 +103,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -114,1 +114,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ already ensure the receiver type.  So this CCE is due to the value.\n+            throwSetIllegalArgumentException(value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleObjectFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -105,0 +105,1 @@\n+        ensureObj(obj);\n@@ -106,1 +107,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -159,1 +159,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleShortFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -37,5 +37,0 @@\n-\/**\n- * A utility package for the java(1), javaw(1) launchers.\n- * The following are helper methods that the native launcher uses\n- * to perform checks etc. using JNI, see src\/share\/bin\/java.c\n- *\/\n@@ -91,1 +86,5 @@\n-\n+\/**\n+ * A utility package for the java(1), javaw(1) launchers.\n+ * The following are helper methods that the native launcher uses\n+ * to perform checks etc. using JNI, see src\/share\/bin\/java.c\n+ *\/\n@@ -157,2 +156,2 @@\n-        String opts[] = optionFlag.split(\":\");\n-        String optStr = (opts.length > 1 && opts[1] != null)\n+        String[] opts = optionFlag.split(\":\");\n+        String optStr = opts.length > 1\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-                if (f.indexOf(\"%d\") >= 0) {\n+                if (f.contains(\"%d\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/HttpCapture.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -648,1 +648,1 @@\n-        if ((cipher != null) && (cipher.indexOf(\"_anon_\") != -1)) {\n+        if ((cipher != null) && (cipher.contains(\"_anon_\"))) {\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/https\/HttpsClient.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,2 +79,3 @@\n-     * The key is the AlgorithmId of the algorithm, and the value is the name of\n-     * the field or attribute.\n+     * The key is the AlgorithmId of the algorithm, and the value is a record\n+     * containing the name of the field or attribute and whether the key\n+     * should also be checked (ex: if it is a signature algorithm).\n@@ -82,1 +83,2 @@\n-    private Map<AlgorithmId, String> algorithms = new HashMap<>();\n+    private record AlgorithmInfo(String field, boolean checkKey) {}\n+    private Map<AlgorithmId, AlgorithmInfo> algorithms = new HashMap<>();\n@@ -353,1 +355,2 @@\n-            algorithms.put(digestAlgorithmId, \"SignerInfo digestAlgorithm field\");\n+            algorithms.put(digestAlgorithmId,\n+                new AlgorithmInfo(\"SignerInfo digestAlgorithm field\", false));\n@@ -424,1 +427,2 @@\n-                    \"SignerInfo digestEncryptionAlgorithm field\");\n+                    new AlgorithmInfo(\n+                        \"SignerInfo digestEncryptionAlgorithm field\", true));\n@@ -680,1 +684,2 @@\n-        algorithms.put(digestAlgId, \"TimestampToken digestAlgorithm field\");\n+        algorithms.put(digestAlgId,\n+            new AlgorithmInfo(\"TimestampToken digestAlgorithm field\", false));\n@@ -737,1 +742,1 @@\n-        Map<AlgorithmId, String> algorithms = new HashMap<>();\n+        Map<AlgorithmId, AlgorithmInfo> algorithms = new HashMap<>();\n@@ -744,3 +749,4 @@\n-            for (Map.Entry<AlgorithmId, String> algorithm : algorithms.entrySet()) {\n-                params.setExtendedExceptionMsg(name, algorithm.getValue());\n-                AlgorithmId algId = algorithm.getKey();\n+            for (var algEntry : algorithms.entrySet()) {\n+                AlgorithmInfo info = algEntry.getValue();\n+                params.setExtendedExceptionMsg(name, info.field());\n+                AlgorithmId algId = algEntry.getKey();\n@@ -748,1 +754,1 @@\n-                    algId.getParameters(), params);\n+                    algId.getParameters(), params, info.checkKey());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/SignerInfo.java","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -726,1 +726,1 @@\n-                    if (pe.name != null && pe.name.indexOf(SELF) != -1) {\n+                    if (pe.name != null && pe.name.contains(SELF)) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/PolicyFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.security.cert.X509CRL;\n@@ -60,1 +59,0 @@\n-import sun.security.x509.X509CRLImpl;\n@@ -229,1 +227,1 @@\n-                dac.permits(trustedPubKey.getAlgorithm(), cp);\n+                dac.permits(trustedPubKey.getAlgorithm(), cp, true);\n@@ -235,1 +233,1 @@\n-            dac.permits(currSigAlg, currSigAlgParams, cp);\n+            dac.permits(currSigAlg, currSigAlgParams, cp, true);\n@@ -365,23 +363,0 @@\n-    \/**\n-     * Check the signature algorithm with the specified public key.\n-     *\n-     * @param key the public key to verify the CRL signature\n-     * @param crl the target CRL\n-     * @param variant the Validator variant of the operation. A null value\n-     *                passed will set it to Validator.GENERIC.\n-     * @param anchor the trust anchor selected to validate the CRL issuer\n-     *\/\n-    static void check(PublicKey key, X509CRL crl, String variant,\n-                      TrustAnchor anchor) throws CertPathValidatorException {\n-\n-        X509CRLImpl x509CRLImpl = null;\n-        try {\n-            x509CRLImpl = X509CRLImpl.toImpl(crl);\n-        } catch (CRLException ce) {\n-            throw new CertPathValidatorException(ce);\n-        }\n-\n-        AlgorithmId algorithmId = x509CRLImpl.getSigAlgId();\n-        check(key, algorithmId, variant, anchor);\n-    }\n-\n@@ -402,1 +377,1 @@\n-            new CertPathConstraintsParameters(key, variant, anchor, null));\n+            new CertPathConstraintsParameters(key, variant, anchor, null), true);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/AlgorithmChecker.java","additions":3,"deletions":28,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -656,1 +656,2 @@\n-            AlgorithmChecker.check(prevKey, crl, variant, anchor);\n+            AlgorithmChecker.check(prevKey, crlImpl.getSigAlgId(),\n+                                   variant, anchor);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/DistributionPointFetcher.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-        if (givenAlg.indexOf(\"-\") != -1) {\n+        if (givenAlg.contains(\"-\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPSSSignature.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.IOException;\n@@ -64,1 +63,1 @@\n-            if (name.indexOf(\"PSS\") != -1) {\n+            if (name.contains(\"PSS\")) {\n@@ -66,1 +65,1 @@\n-            } else if (name.indexOf(\"RSA\") != -1) {\n+            } else if (name.contains(\"RSA\")) {\n@@ -154,1 +153,1 @@\n-            if (algName.indexOf(\"RSA\") != -1) {\n+            if (algName.contains(\"RSA\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAUtil.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1476,1 +1476,1 @@\n-            if (s.startsWith(\"-----BEGIN\") && s.indexOf(\"REQUEST\") >= 0) {\n+            if (s.startsWith(\"-----BEGIN\") && s.contains(\"REQUEST\")) {\n@@ -1479,1 +1479,1 @@\n-            } else if (s.startsWith(\"-----END\") && s.indexOf(\"REQUEST\") >= 0) {\n+            } else if (s.startsWith(\"-----END\") && s.contains(\"REQUEST\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/Main.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-            if (transToken == null || transToken.isEmpty()) {\n+            if (transToken.isEmpty()) {\n@@ -73,1 +73,1 @@\n-                if (token == null || token.isEmpty()) {\n+                if (token.isEmpty()) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/AlgorithmDecomposer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-            if (args.indexOf(\"all\") != -1)\n+            if (args.contains(\"all\"))\n@@ -167,1 +167,1 @@\n-                return (args.indexOf(option) != -1);\n+                return (args.contains(option));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Debug.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -195,3 +195,3 @@\n-        ConstraintsParameters cp) throws CertPathValidatorException {\n-\n-        permits(algorithm, cp);\n+            ConstraintsParameters cp, boolean checkKey)\n+            throws CertPathValidatorException {\n+        permits(algorithm, cp, checkKey);\n@@ -222,1 +222,1 @@\n-            permits(digestAlg, cp);\n+            permits(digestAlg, cp, false);\n@@ -228,1 +228,1 @@\n-                    permits(mgfDigestAlg, cp);\n+                    permits(mgfDigestAlg, cp, false);\n@@ -236,8 +236,8 @@\n-    public final void permits(String algorithm, ConstraintsParameters cp)\n-            throws CertPathValidatorException {\n-\n-        \/\/ Check if named curves in the key are disabled.\n-        for (Key key : cp.getKeys()) {\n-            for (String curve : getNamedCurveFromKey(key)) {\n-                if (!checkAlgorithm(disabledAlgorithms, curve, decomposer)) {\n-                    throw new CertPathValidatorException(\n+    public final void permits(String algorithm, ConstraintsParameters cp,\n+            boolean checkKey) throws CertPathValidatorException {\n+        if (checkKey) {\n+            \/\/ Check if named curves in the key are disabled.\n+            for (Key key : cp.getKeys()) {\n+                for (String curve : getNamedCurveFromKey(key)) {\n+                    if (!checkAlgorithm(disabledAlgorithms, curve, decomposer)) {\n+                        throw new CertPathValidatorException(\n@@ -247,0 +247,1 @@\n+                    }\n@@ -250,2 +251,1 @@\n-\n-        algorithmConstraints.permits(algorithm, cp);\n+        algorithmConstraints.permits(algorithm, cp, checkKey);\n@@ -484,2 +484,2 @@\n-        public void permits(String algorithm, ConstraintsParameters cp)\n-                throws CertPathValidatorException {\n+        public void permits(String algorithm, ConstraintsParameters cp,\n+                boolean checkKey) throws CertPathValidatorException {\n@@ -499,2 +499,4 @@\n-            for (Key key : cp.getKeys()) {\n-                algorithms.add(key.getAlgorithm());\n+            if (checkKey) {\n+                for (Key key : cp.getKeys()) {\n+                    algorithms.add(key.getAlgorithm());\n+                }\n@@ -510,0 +512,3 @@\n+                    if (!checkKey && constraint instanceof KeySizeConstraint) {\n+                        continue;\n+                    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DisabledAlgorithmConstraints.java","additions":24,"deletions":19,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-    public JarConstraintsParameters(List<X509Certificate> chain, Timestamp timestamp) {\n+    public JarConstraintsParameters(List<X509Certificate> chain, Date timestamp) {\n@@ -105,6 +105,1 @@\n-        if (timestamp != null) {\n-            addToCertsAndKeys(timestamp.getSignerCertPath());\n-            this.timestamp = timestamp.getTimestamp();\n-        } else {\n-            this.timestamp = null;\n-        }\n+        this.timestamp = timestamp;\n@@ -181,1 +176,1 @@\n-        return message;\n+        return message == null ? \".\" : message;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/JarConstraintsParameters.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -220,1 +220,1 @@\n-                           .permits(digest.getAlgorithm(), params);\n+                           .permits(digest.getAlgorithm(), params, false);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/ManifestEntryVerifier.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n-                    .jarConstraints().permits(algorithm, params);\n+                    .jarConstraints().permits(algorithm, params, false);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SignatureFileVerifier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        if (algName.indexOf(\".\") == -1) {\n+        if (!algName.contains(\".\")) {\n@@ -103,1 +103,1 @@\n-            if (params.getAlgorithm().indexOf(\".\") != -1) {\n+            if (params.getAlgorithm().contains(\".\")) {\n@@ -112,1 +112,1 @@\n-            if (sigName.indexOf(\"RSA\") != -1) {\n+            if (sigName.contains(\"RSA\")) {\n@@ -114,1 +114,1 @@\n-            } else if (sigName.indexOf(\"ECDSA\") != -1) {\n+            } else if (sigName.contains(\"ECDSA\")) {\n@@ -144,1 +144,1 @@\n-            if (sigName.indexOf(\"RSA\") != -1) {\n+            if (sigName.contains(\"RSA\")) {\n@@ -148,1 +148,1 @@\n-            } else if (sigName.indexOf(\"ECDSA\") != -1) {\n+            } else if (sigName.contains(\"ECDSA\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SignatureUtil.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -523,1 +523,1 @@\n-        if (name.indexOf(\".\") == -1) {\n+        if (!name.contains(\".\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AlgorithmId.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-                    || range.indexOf(\"-*\") != -1) { \/\/ Extended range\n+                    || range.contains(\"-*\")) { \/\/ Extended range\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/LocaleMatcher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n-                            perm.getActions().indexOf(\"read\") != -1) {\n+                            perm.getActions().contains(\"read\")) {\n@@ -210,1 +210,1 @@\n-                            perm.getActions().indexOf(\"connect\") != -1) {\n+                            perm.getActions().contains(\"connect\")) {\n","filename":"src\/java.base\/unix\/classes\/sun\/net\/www\/protocol\/jar\/JarFileFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-                            perm.getActions().indexOf(\"read\") != -1) {\n+                            perm.getActions().contains(\"read\")) {\n@@ -233,1 +233,1 @@\n-                            perm.getActions().indexOf(\"connect\") != -1) {\n+                            perm.getActions().contains(\"connect\")) {\n","filename":"src\/java.base\/windows\/classes\/sun\/net\/www\/protocol\/jar\/JarFileFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,7 @@\n- * attempt to create a new file.  For example, if an annotation\n+ * attempt to create a new file.\n+ * In other words, the originating elements are intended to have the\n+ * granularity of <em>compilation units<\/em> (JLS section {@jls 7.3}),\n+ * essentially file-level granularity, rather than finer-scale\n+ * granularity of, say, a method or field declaration.\n+ *\n+ * <p>For example, if an annotation\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/Filer.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,0 +134,6 @@\n+    \/**\n+     * {@return the class or interface defining the executable}\n+     *\/\n+    @Override\n+    Element getEnclosingElement();\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/ExecutableElement.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,13 +39,14 @@\n- * <p>When used in the context of annotation processing, an accurate\n- * model of the element being represented must be returned.  As this\n- * is a language model, the source code provides the fiducial\n- * (reference) representation of the construct in question rather than\n- * a representation in an executable output like a class file.\n- * Executable output may serve as the basis for creating a modeling\n- * element.  However, the process of translating source code to\n- * executable output may not permit recovering some aspects of the\n- * source code representation.  For example, annotations with\n- * {@linkplain java.lang.annotation.RetentionPolicy#SOURCE source}\n- * {@linkplain java.lang.annotation.Retention retention} cannot be\n- * recovered from class files and class files might not be able to\n- * provide source position information.\n+ * <p id=\"accurate_model\">When used in the context of annotation\n+ * processing, an accurate model of the element being represented must\n+ * be returned.  As this is a language model, the source code provides\n+ * the fiducial (reference) representation of the construct in\n+ * question rather than a representation in an executable output like\n+ * a class file.  Executable output may serve as the basis for\n+ * creating a modeling element.  However, the process of translating\n+ * source code to executable output may not permit recovering some\n+ * aspects of the source code representation.  For example,\n+ * annotations with {@linkplain\n+ * java.lang.annotation.RetentionPolicy#SOURCE source} {@linkplain\n+ * java.lang.annotation.Retention retention} cannot be recovered from\n+ * class files and class files might not be able to provide source\n+ * position information.\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/package-info.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-     * If this process leads to a list with a single element,\n-     * the single element is returned, otherwise null is returned.\n+     * If this process leads to a list with a single element, the\n+     * single element is returned, otherwise {@code null} is returned.\n@@ -158,2 +158,2 @@\n-     * If this process leads to a list with a single element,\n-     * the single element is returned, otherwise null is returned.\n+     * If this process leads to a list with a single element, the\n+     * single element is returned, otherwise {@code null} is returned.\n@@ -738,2 +738,3 @@\n-     * Returns the record component for the given accessor. Returns null if the\n-     * given method is not a record component accessor.\n+     * Returns the record component for the given accessor. Returns\n+     * {@code null} if the given method is not a record component\n+     * accessor.\n@@ -750,2 +751,2 @@\n-     * @return the record component, or null if the given method is not a record\n-     * component accessor\n+     * @return the record component, or {@code null} if the given\n+     * method is not a record component accessor\n@@ -764,0 +765,96 @@\n+\n+    \/**\n+     * {@return the file object for this element or {@code null} if\n+     * there is no such file object}\n+     *\n+     * <p>The returned file object is for the <a\n+     * href=\"..\/element\/package-summary.html#accurate_model\">reference\n+     * representation<\/a> of the information used to construct the\n+     * element. For example, if during compilation or annotation\n+     * processing, a source file for class {@code Foo} is compiled\n+     * into a class file, the file object returned for the element\n+     * representing {@code Foo} would be for the source file and\n+     * <em>not<\/em> for the class file.\n+     *\n+     * <p>An implementation may choose to not support the\n+     * functionality of this method, in which case {@link\n+     * UnsupportedOperationException} is thrown.\n+     *\n+     * <p>In the context of annotation processing, a non-{@code null}\n+     * value is returned if the element was included as part of the\n+     * initial inputs or the containing file was created during the\n+     * run of the annotation processing tool. Otherwise, a {@code\n+     * null} may be returned. In annotation processing, if a\n+     * {@linkplain javax.annotation.processing.Filer#createClassFile\n+     * class file is created}, that class file can serve as the\n+     * reference representation for elements.\n+     *\n+     * <p>If it has a file object, the file object for a package will\n+     * be a {@code package-info} file. A package may exist and not\n+     * have any {@code package-info} file even if the package is\n+     * (implicitly) created during an annotation processing run from\n+     * the creation of source or class files in that package.  An\n+     * {@linkplain PackageElement#isUnnamed unnamed package} will have\n+     * a {@code null} file since it cannot be declared in a\n+     * compilation unit.\n+     *\n+     * <p>If it has a file object, the file object for a module will\n+     * be a {@code module-info} file.  An {@linkplain\n+     * ModuleElement#isUnnamed unnamed module} will have a {@code\n+     * null} file since it cannot be declared in a compilation unit.\n+     * An {@linkplain #isAutomaticModule automatic module} will have a\n+     * {@code null} file since it is implicitly declared.\n+     *\n+     * <p>If it has a file object, the file object for a top-level\n+     * {@code public} class or interface will be a source or class\n+     * file corresponding to that class or interface. In this case,\n+     * typically the leading portion of the name of the file will\n+     * match the name of the class or interface. A single compilation\n+     * unit can define multiple top-level classes and interfaces, such\n+     * as a primary {@code public} class or interfaces whose name\n+     * corresponds to the file name and one or more <em>auxiliary<\/em>\n+     * classes or interfaces whose names do not correspond to the file\n+     * name. If a source file is providing the reference\n+     * representation of an auxiliary class or interface, the file for\n+     * the primary class is returned. (An auxiliary class or interface\n+     * can also be defined in a {@code package-info} source file, in\n+     * which case the file for the {@code package-info} file is\n+     * returned.)  If a class file is providing the reference\n+     * representation of an auxiliary class or interface, the separate\n+     * class file for the auxiliary class is returned.\n+     *\n+     * <p>For a nested class or interface, if it has a file object:\n+     *\n+     * <ul>\n+     *\n+     * <li>if a source file is providing the reference representation,\n+     * the file object will be that of the {@linkplain\n+     * #getOutermostTypeElement(Element) outermost enclosing} class or\n+     * interface\n+     *\n+     * <li>if a class file is providing the reference representation,\n+     * the file object will be that of the nested class or interface\n+     * itself\n+     *\n+     * <\/ul>\n+     *\n+     * <p>For other lexically enclosed elements, such as {@linkplain\n+     * VariableElement#getEnclosingElement() variables}, {@linkplain\n+     * ExecutableElement#getEnclosingElement() methods, and\n+     * constructors}, if they have a file object, the file object will\n+     * be the object associated with the {@linkplain\n+     * Element#getEnclosingElement() enclosing element} of the\n+     * lexically enclosed element.\n+     *\n+     * @implSpec The default implementation unconditionally throws\n+     * {@link UnsupportedOperationException}.\n+     *\n+     * @throws UnsupportedOperationException if this functionality is\n+     * not supported\n+     *\n+     * @param e the element to find a file object for\n+     * @since 18\n+     *\/\n+    default javax.tools.JavaFileObject getFileObjectOf(Element e) {\n+        throw new UnsupportedOperationException();\n+    }\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":105,"deletions":8,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-    rolesMap = [[NSMutableDictionary alloc] initWithCapacity:50];\n+    rolesMap = [[NSMutableDictionary alloc] initWithCapacity:51];\n@@ -159,0 +159,1 @@\n+    [rolesMap setObject:@\"ProgressIndicatorAccessibility\" forKey:@\"progressbar\"];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/CommonComponentAccessibility.m","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"JavaComponentAccessibility.h\"\n+#import \"GroupAccessibility.h\"\n+\n+#import <AppKit\/AppKit.h>\n+\n+@interface ProgressIndicatorAccessibility : GroupAccessibility {\n+\n+};\n+- (NSAccessibilityRole _Nonnull)accessibilityRole;\n+- (NSString * _Nullable)accessibilityValue;\n+@end\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/ProgressIndicatorAccessibility.h","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"ProgressIndicatorAccessibility.h\"\n+\n+\/*\n+ * Implementation of the accessibility peer for the NSProgressIndicator role.\n+ * Main usage is JProgressBar\n+ *\/\n+@implementation ProgressIndicatorAccessibility\n+\n+- (NSAccessibilityRole _Nonnull)accessibilityRole\n+{\n+    return NSAccessibilityProgressIndicatorRole;\n+}\n+\n+- (NSString * _Nullable)accessibilityValue\n+{\n+    return [super accessibilityValue];\n+}\n+\n+@end\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/ProgressIndicatorAccessibility.m","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -523,1 +523,1 @@\n-                String trimmedText = trimTrailingSpaces(text);\n+                String trimmedText = text.stripTrailing();\n@@ -869,1 +869,1 @@\n-                    String trimmedText = trimTrailingSpaces(text);\n+                    String trimmedText = text.stripTrailing();\n@@ -1324,8 +1324,0 @@\n-    private static String trimTrailingSpaces(String s) {\n-        int i = s.length() - 1;\n-        while(i >= 0 && Character.isWhitespace(s.charAt(i))) {\n-            i--;\n-        }\n-        return s.substring(0, i + 1);\n-    }\n-\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/SwingUtilities2.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -112,1 +112,2 @@\n-        systemHeaders = HttpHeaders.of(systemHeaders.map(), (k,v) -> uh.firstValue(k).isEmpty());\n+        final HttpHeaders sh = HttpHeaders.of(systemHeaders.map(),\n+                (k,v) -> uh.firstValue(k).isEmpty());\n@@ -118,1 +119,1 @@\n-        collectHeaders1(sb, systemHeaders, nocookies);\n+        collectHeaders1(sb, sh, nocookies);\n@@ -123,1 +124,1 @@\n-        collectHeaders1(sb, userHeaders, nocookies);\n+        collectHeaders1(sb, uh, nocookies);\n@@ -125,2 +126,2 @@\n-        \/\/ Gather all 'Cookie:' headers and concatenate their\n-        \/\/ values in a single line.\n+        \/\/ Gather all 'Cookie:' headers from the unfiltered system headers,\n+        \/\/ and the user headers, and concatenate their values in a single line\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Request.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+    private static final String COOKIE_HEADER = \"Cookie\";\n@@ -248,1 +249,1 @@\n-                Log.logError(\"Subscriber::onError threw exception: {0}\", (Object) t);\n+                Log.logError(\"Subscriber::onError threw exception: {0}\", t);\n@@ -331,4 +332,1 @@\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"streamid: \")\n-                .append(streamid);\n-        return sb.toString();\n+        return \"streamid: \" + streamid;\n@@ -401,1 +399,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -458,1 +455,1 @@\n-            default -> throw new IOException(\"Unexpected frame: \" + frame.toString());\n+            default -> throw new IOException(\"Unexpected frame: \" + frame);\n@@ -655,0 +652,1 @@\n+        \/\/ Don't override Cookie values that have been set by the CookieHandler.\n@@ -656,0 +654,3 @@\n+        BiPredicate<String, String> overrides =\n+                (k, v) -> COOKIE_HEADER.equalsIgnoreCase(k)\n+                          || uh.firstValue(k).isEmpty();\n@@ -658,1 +659,3 @@\n-        sysh = HttpHeaders.of(sysh.map(), (k,v) -> uh.firstValue(k).isEmpty());\n+        \/\/   except for \"Cookie:\" - user cookies will be appended to system\n+        \/\/   cookies\n+        sysh = HttpHeaders.of(sysh.map(), overrides);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -697,4 +697,2 @@\n-                Error error = new LinkageError(\n-                    \"provider class not assignable to RMIClassLoaderSpi\");\n-                error.initCause(e);\n-                throw error;\n+                throw new LinkageError(\n+                    \"provider class not assignable to RMIClassLoaderSpi\", e);\n@@ -714,4 +712,2 @@\n-                Error error = new LinkageError(\n-                    \"provider class not assignable to RMIClassLoaderSpi\");\n-                error.initCause(e);\n-                throw error;\n+                throw new LinkageError(\n+                    \"provider class not assignable to RMIClassLoaderSpi\", e);\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/server\/RMIClassLoader.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -224,2 +224,1 @@\n-                    throw (IllegalArgumentException)\n-                        new IllegalArgumentException().initCause(nsme);\n+                    throw new IllegalArgumentException(nsme);\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/server\/RemoteObjectInvocationHandler.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -136,2 +136,1 @@\n-                throw (IOException)\n-                    new IOException(e.getMessage()).initCause(e);\n+                throw new IOException(e.getMessage(), e);\n@@ -154,2 +153,1 @@\n-                throw (IOException)\n-                    new IOException(e.getMessage()).initCause(e);\n+                throw new IOException(e.getMessage(), e);\n","filename":"src\/java.rmi\/share\/classes\/javax\/rmi\/ssl\/SslRMIClientSocketFactory.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -188,2 +188,1 @@\n-                throw (IllegalArgumentException)\n-                new IllegalArgumentException(msg).initCause(e);\n+                throw new IllegalArgumentException(msg, e);\n","filename":"src\/java.rmi\/share\/classes\/javax\/rmi\/ssl\/SslRMIServerSocketFactory.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -288,2 +288,1 @@\n-            throw (IOException)\n-                new IOException(\"write update failed\").initCause(e);\n+            throw new IOException(\"write update failed\", e);\n@@ -550,2 +549,1 @@\n-            throw (IOException) new IOException(\n-                \"unable to construct LogFile instance\").initCause(e);\n+            throw new IOException(\"unable to construct LogFile instance\", e);\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/log\/ReliableLog.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1683,1 +1683,2 @@\n-            List<Type> coveredTypes = List.nil();\n+            List<Type> coveredTypesForPatterns = List.nil();\n+            List<Type> coveredTypesForConstants = List.nil();\n@@ -1721,1 +1722,1 @@\n-                                checkCaseLabelDominated(pat.pos(), coveredTypes, sym.type);\n+                                checkCaseLabelDominated(pat.pos(), coveredTypesForConstants, sym.type);\n@@ -1754,1 +1755,1 @@\n-                                    checkCaseLabelDominated(pat.pos(), coveredTypes, types.boxedTypeOrType(pattype));\n+                                    checkCaseLabelDominated(pat.pos(), coveredTypesForConstants, types.boxedTypeOrType(pattype));\n@@ -1787,3 +1788,6 @@\n-                        checkCaseLabelDominated(pat.pos(), coveredTypes, patternType);\n-                        if (primary.unconditional() && !patternType.isErroneous()) {\n-                            coveredTypes = coveredTypes.prepend(patternType);\n+                        checkCaseLabelDominated(pat.pos(), coveredTypesForPatterns, patternType);\n+                        if (!patternType.isErroneous()) {\n+                            coveredTypesForConstants = coveredTypesForConstants.prepend(patternType);\n+                            if (primary.unconditional()) {\n+                                coveredTypesForPatterns = coveredTypesForPatterns.prepend(patternType);\n+                            }\n@@ -3953,1 +3957,1 @@\n-        Symbol operator = tree.operator = operators.resolveUnary(tree, tree.getTag(), argtype);\n+        OperatorSymbol operator = tree.operator = operators.resolveUnary(tree, tree.getTag(), argtype);\n@@ -3960,1 +3964,1 @@\n-            int opc = ((OperatorSymbol)operator).opcode;\n+            int opc = operator.opcode;\n@@ -4007,1 +4011,1 @@\n-        Symbol operator = tree.operator = operators.resolveBinary(tree, tree.getTag(), left, right);\n+        OperatorSymbol operator = tree.operator = operators.resolveBinary(tree, tree.getTag(), left, right);\n@@ -4013,1 +4017,1 @@\n-            int opc = ((OperatorSymbol)operator).opcode;\n+            int opc = operator.opcode;\n@@ -5497,1 +5501,1 @@\n-                Symbol sym = null;\n+                VarSymbol sym = null;\n@@ -5501,1 +5505,1 @@\n-                        ((VarSymbol) sym).getConstValue() == null)\n+                        sym.getConstValue() == null)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -379,1 +379,1 @@\n-                c.sourcefile = tree.sourcefile;\n+                c.classfile = c.sourcefile = tree.sourcefile;\n@@ -498,1 +498,1 @@\n-        c.sourcefile = env.toplevel.sourcefile;\n+        c.classfile = c.sourcefile = env.toplevel.sourcefile;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -754,1 +754,1 @@\n-        private void transitiveCovers(Set<Symbol> covered) {\n+        private void transitiveCovers(Type seltype, Set<Symbol> covered) {\n@@ -776,1 +776,1 @@\n-                                if (isTransitivelyCovered(sup.tsym, covered) &&\n+                                if (isTransitivelyCovered(seltype, sup.tsym, covered) &&\n@@ -787,1 +787,1 @@\n-        private boolean isTransitivelyCovered(Symbol sealed, Set<Symbol> covered) {\n+        private boolean isTransitivelyCovered(Type seltype, Symbol sealed, Set<Symbol> covered) {\n@@ -796,1 +796,4 @@\n-                                                 .allMatch(s -> isTransitivelyCovered(s, covered));\n+                                                 .filter(s -> {\n+                                                     return types.isCastable(seltype, s.type\/*, types.noWarnings*\/);\n+                                                 })\n+                                                 .allMatch(s -> isTransitivelyCovered(seltype, s, covered));\n@@ -808,1 +811,1 @@\n-            transitiveCovers(covered);\n+            transitiveCovers(seltype, covered);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -427,2 +427,2 @@\n-                JCTree captured_local = make.Ident(fv).setType(fv.type);\n-                syntheticInits.append((JCExpression) captured_local);\n+                JCExpression captured_local = make.Ident(fv).setType(fv.type);\n+                syntheticInits.append(captured_local);\n@@ -433,2 +433,2 @@\n-            JCTree captured_local = make.QualThis(fv.type);\n-            syntheticInits.append((JCExpression) captured_local);\n+            JCExpression captured_local = make.QualThis(fv.type);\n+            syntheticInits.append(captured_local);\n@@ -1187,1 +1187,1 @@\n-            Symbol bsm = rs.resolveInternalMethod(pos, attrEnv, site,\n+            MethodSymbol bsm = rs.resolveInternalMethod(pos, attrEnv, site,\n@@ -1193,1 +1193,1 @@\n-                                            ((MethodSymbol)bsm).asHandle(),\n+                                            bsm.asHandle(),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+    private final boolean optimizeOuterThis;\n@@ -122,0 +123,3 @@\n+        optimizeOuterThis =\n+            target.optimizeOuterThis() ||\n+            options.getBoolean(\"optimizeOuterThis\", false);\n@@ -1483,0 +1487,4 @@\n+        \/\/ Set NOOUTERTHIS for all synthetic outer instance variables, and unset\n+        \/\/ it when the variable is accessed. If the variable is never accessed,\n+        \/\/ we skip creating an outer instance field and saving the constructor\n+        \/\/ parameter to it.\n@@ -1484,1 +1492,1 @@\n-            new VarSymbol(flags, outerThisName(target, owner), target, owner);\n+            new VarSymbol(flags | NOOUTERTHIS, outerThisName(target, owner), target, owner);\n@@ -1731,0 +1739,1 @@\n+        ot.flags_field &= ~NOOUTERTHIS;\n@@ -1748,0 +1757,1 @@\n+            ot.flags_field &= ~NOOUTERTHIS;\n@@ -1787,0 +1797,1 @@\n+        ot.flags_field &= ~NOOUTERTHIS;\n@@ -1799,0 +1810,1 @@\n+            ot.flags_field &= ~NOOUTERTHIS;\n@@ -1820,2 +1832,1 @@\n-    JCStatement initOuterThis(int pos) {\n-        VarSymbol rhs = outerThisStack.head;\n+    JCStatement initOuterThis(int pos, VarSymbol rhs) {\n@@ -1823,1 +1834,1 @@\n-        VarSymbol lhs = outerThisStack.tail.head;\n+        VarSymbol lhs = outerThisStack.head;\n@@ -2227,1 +2238,1 @@\n-        \/\/ Add this$n and free variables proxy definitions to class.\n+        \/\/ Add free variables proxy definitions to class.\n@@ -2233,1 +2244,3 @@\n-        if (currentClass.hasOuterInstance()) {\n+        \/\/ If this$n was accessed, add the field definition and\n+        \/\/ update initial constructors to initialize it\n+        if (currentClass.hasOuterInstance() && shouldEmitOuterThis(currentClass)) {\n@@ -2236,0 +2249,8 @@\n+\n+           for (JCTree def : tree.defs) {\n+                if (TreeInfo.isInitialConstructor(def)) {\n+                  JCMethodDecl mdef = (JCMethodDecl) def;\n+                  mdef.body.stats = mdef.body.stats.prepend(\n+                      initOuterThis(mdef.body.pos, mdef.params.head.sym));\n+                }\n+            }\n@@ -2252,0 +2273,33 @@\n+    private boolean shouldEmitOuterThis(ClassSymbol sym) {\n+      if (!optimizeOuterThis) {\n+        \/\/ Optimization is disabled\n+        return true;\n+      }\n+      if ((outerThisStack.head.flags_field & NOOUTERTHIS) == 0)  {\n+        \/\/ Enclosing instance field is used\n+        return true;\n+      }\n+      if (rs.isSerializable(sym.type) && !hasSerialVersionUID(sym)) {\n+        \/\/ Class is serializable and does not have a stable serialVersionUID\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    private boolean hasSerialVersionUID(ClassSymbol sym) {\n+      VarSymbol svuid = (VarSymbol) sym.members().findFirst(names.serialVersionUID, f -> f.kind == VAR);\n+      if (svuid == null) {\n+        return false;\n+      }\n+      if ((svuid.flags() & (STATIC | FINAL)) != (STATIC | FINAL)) {\n+        return false;\n+      }\n+      if (!svuid.type.hasTag(LONG)) {\n+        return false;\n+      }\n+      if (svuid.getConstValue() == null) {\n+        return false;\n+      }\n+      return true;\n+    }\n+\n@@ -2318,1 +2372,1 @@\n-        Symbol valuesSym = lookupMethod(tree.pos(), names.values,\n+        MethodSymbol valuesSym = lookupMethod(tree.pos(), names.values,\n@@ -2369,1 +2423,1 @@\n-             make.MethodDef((MethodSymbol)valuesSym, make.Block(0, valuesBody));\n+             make.MethodDef(valuesSym, make.Block(0, valuesBody));\n@@ -2584,1 +2638,1 @@\n-        Symbol bsm = rs.resolveInternalMethod(tree.pos(), attrEnv, site,\n+        MethodSymbol bsm = rs.resolveInternalMethod(tree.pos(), attrEnv, site,\n@@ -2596,1 +2650,1 @@\n-                ((MethodSymbol)bsm).asHandle(),\n+                bsm.asHandle(),\n@@ -2706,5 +2760,0 @@\n-            if (currentClass.hasOuterInstance() &&\n-                TreeInfo.isInitialConstructor(tree))\n-            {\n-                added = added.prepend(initOuterThis(tree.body.pos));\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":64,"deletions":15,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-            sym.module_info.sourcefile = toplevel.sourcefile;\n+            sym.module_info.classfile = sym.module_info.sourcefile = toplevel.sourcefile;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -374,1 +374,1 @@\n-            Symbol bsm = rs.resolveInternalMethod(tree.pos(), env, syms.switchBootstrapsType,\n+            MethodSymbol bsm = rs.resolveInternalMethod(tree.pos(), env, syms.switchBootstrapsType,\n@@ -385,1 +385,1 @@\n-                    ((MethodSymbol)bsm).asHandle(),\n+                    bsm.asHandle(),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -374,1 +374,1 @@\n-                Symbol bsm = rs.resolveInternalMethod(pos,\n+                MethodSymbol bsm = rs.resolveInternalMethod(pos,\n@@ -383,1 +383,1 @@\n-                        ((MethodSymbol)bsm).asHandle(),\n+                        bsm.asHandle(),\n@@ -490,1 +490,1 @@\n-                Symbol bsm = rs.resolveInternalMethod(pos,\n+                MethodSymbol bsm = rs.resolveInternalMethod(pos,\n@@ -499,1 +499,1 @@\n-                        ((MethodSymbol)bsm).asHandle(),\n+                        bsm.asHandle(),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/StringConcat.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -206,0 +206,7 @@\n+\n+    \/** Omit unused enclosing instance fields from inner classes that don't access enclosing\n+     * instance state.\n+     *\/\n+    public boolean optimizeOuterThis() {\n+        return compareTo(JDK1_18) >= 0;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Target.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -357,0 +357,1 @@\n+        javacOpts.add(\"-Xlint:-options\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/Main.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -513,0 +513,5 @@\n+\n+        @Override\n+        public void process(OptionHelper helper, String option, String arg) throws InvalidValueException {\n+            throw helper.newInvalidValueException(Errors.InvalidFlag(option + arg));\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/Option.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -730,0 +730,24 @@\n+    @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+    public JavaFileObject getFileObjectOf(Element e) {\n+        Symbol sym = (Symbol) e;\n+        return switch(sym.kind) {\n+            case PCK -> {\n+                PackageSymbol psym = (PackageSymbol) sym;\n+                if (psym.package_info == null) {\n+                    yield null;\n+                }\n+                yield psym.package_info.classfile;\n+            }\n+\n+            case MDL -> {\n+                ModuleSymbol msym = (ModuleSymbol) sym;\n+                if (msym.module_info == null) {\n+                    yield null;\n+                }\n+                yield msym.module_info.classfile;\n+            }\n+            case TYP -> ((ClassSymbol) sym).classfile;\n+            default -> sym.enclClass().classfile;\n+        };\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacElements.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import sun.jvm.hotspot.memory.SystemDictionary;\n@@ -97,1 +96,0 @@\n-import sun.jvm.hotspot.utilities.CompactHashTable;\n@@ -101,1 +99,0 @@\n-import sun.jvm.hotspot.utilities.ObjectReader;\n@@ -135,1 +132,1 @@\n-                \/\/ together duplicate classes are a possibilty.  For\n+                \/\/ together duplicate classes are a possibility.  For\n@@ -439,1 +436,0 @@\n-                    String format = \"\";\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/CommandProcessor.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import sun.jvm.hotspot.memory.*;\n@@ -1740,1 +1739,0 @@\n-    sun.jvm.hotspot.oops.ObjectHistogram histo = new sun.jvm.hotspot.oops.ObjectHistogram();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/HSDB.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -429,1 +429,0 @@\n-    long size = 0;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/HotSpotTypeDataBase.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -353,1 +353,0 @@\n-    int RADIX = (1 << LOG2_RADIX);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/NMethod.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import java.util.*;\n@@ -91,1 +90,0 @@\n-      int i = 0;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/StubQueue.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -420,1 +420,0 @@\n-    int moduleNumber = 0; \/\/ Debugging\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/WindbgCDebugInfoBuilder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -313,1 +313,1 @@\n-  boolean  _got_error;      \/\/ True, if an error occured during interpretation.\n+  boolean  _got_error;      \/\/ True, if an error occurred during interpretation.\n@@ -316,1 +316,1 @@\n-  \/\/  bool     _did_relocation; \/\/ was relocation neccessary\n+  \/\/  bool     _did_relocation; \/\/ was relocation necessary\n@@ -532,1 +532,0 @@\n-    boolean change = false;\n@@ -1897,1 +1896,1 @@\n-  boolean  _report_result_for_send;         \/\/ Unfortunatly, stackmaps for sends are special, so we need some extra\n+  boolean  _report_result_for_send;         \/\/ Unfortunately, stackmaps for sends are special, so we need some extra\n@@ -1950,1 +1949,1 @@\n-  boolean   _conflict;                      \/\/ True, if a conflict occured during interpretation\n+  boolean   _conflict;                      \/\/ True, if a conflict occurred during interpretation\n@@ -2134,1 +2133,1 @@\n-    \/\/ We have to initialize all variables here, that can be queried direcly\n+    \/\/ We have to initialize all variables here, that can be queried directly\n@@ -2207,1 +2206,1 @@\n-      \/\/ an exception thrown in this part of the code is likly to mean that we are executing some\n+      \/\/ an exception thrown in this part of the code is likely to mean that we are executing some\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/GenerateOopMap.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1284,2 +1284,0 @@\n-            boolean isFloat = (type == Location.Type.FLOAT_IN_DBL ||\n-                               type == Location.Type.DBL);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ui\/classbrowser\/HTMLGenerator.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.invoke.MethodType;\n@@ -57,3 +58,4 @@\n- * The Java {@link java.lang.invoke.MethodType method type} associated with the returned method handle is derived from the\n- * argument and return layouts in the function descriptor. More specifically, given each layout {@code L} in the\n- * function descriptor, a corresponding carrier {@code C} is inferred, as described below:\n+ * The Java {@link java.lang.invoke.MethodType method type} associated with the returned method handle is\n+ * {@linkplain #downcallType(FunctionDescriptor) derived} from the argument and return layouts in the function descriptor.\n+ * More specifically, given each layout {@code L} in the function descriptor, a corresponding carrier {@code C} is inferred,\n+ * as described below:\n@@ -70,13 +72,9 @@\n- * Arguments of type {@link MemorySegment}, {@link VaList} and {@link NativeSymbol} passed by-reference to a downcall method handle\n- * are {@linkplain ResourceScope#keepAlive(ResourceScope) kept alive} by the linker implementation. That is, the resource\n- * scope associated with such arguments cannot be closed, either implicitly or {@linkplain ResourceScope#close() explicitly}\n- * until the downcall method handle completes.\n- * <p>\n- * Furthermore, if the function descriptor's return layout is a group layout, the resulting downcall method handle accepts\n- * an extra parameter of type {@link SegmentAllocator}, which is used by the linker runtime to allocate the\n- * memory region associated with the struct returned by  the downcall method handle.\n- * <p>\n- * Finally, downcall method handles feature a leading parameter of type {@link NativeSymbol}, from which the\n- * address of the target native function can be derived. The address, when known statically, can also be provided by\n- * clients at link time. As for other by-reference parameters (see above) this leading parameter will be\n- * {@linkplain ResourceScope#keepAlive(ResourceScope) kept alive} by the linker implementation.\n+ * The downcall method handle type, derived as above, might be decorated by additional leading parameters:\n+ * <ul>\n+ * <li>If the downcall method handle is created {@linkplain #downcallHandle(FunctionDescriptor) without specifying a native symbol},\n+ * the downcall method handle type features a leading parameter of type {@link NativeSymbol}, from which the\n+ * address of the target native function can be derived.<\/li>\n+ * <li>If the function descriptor's return layout is a group layout, the resulting downcall method handle accepts\n+ * an additional leading parameter of type {@link SegmentAllocator}, which is used by the linker runtime to allocate the\n+ * memory region associated with the struct returned by the downcall method handle.<\/li>\n+ * <\/ul>\n@@ -88,1 +86,1 @@\n- * using by passing a trailing parameter of type {@link VaList}.\n+ * by passing a trailing parameter of type {@link VaList}.\n@@ -118,0 +116,25 @@\n+ * <h2>Safety considerations<\/h2>\n+ *\n+ * Obtaining downcall method handle is intrinsically unsafe. A symbol in a native library does not, in general,\n+ * contain enough signature information (e.g. arity and types of native function parameters). As a consequence,\n+ * the linker runtime cannot validate linkage requests. When a client interacts with a downcall method handle obtained\n+ * through an invalid linkage request (e.g. by specifying a function descriptor featuring too many argument layouts),\n+ * the result of such interaction is unspecified and can lead to JVM crashes. On downcall handle invocation,\n+ * the linker runtime guarantees the following for any argument that is a memory resource {@code R} (of type {@link MemorySegment},\n+ * {@link NativeSymbol} or {@link VaList}):\n+ * <ul>\n+ *     <li>The resource scope of {@code R} is {@linkplain ResourceScope#isAlive() alive}. Otherwise, the invocation throws\n+ *     {@link IllegalStateException};<\/li>\n+ *     <li>The invocation occurs in same thread as the one {@link ResourceScope#ownerThread() owning} the resource scope of {@code R},\n+ *     if said scope is confined. Otherwise, the invocation throws {@link IllegalStateException}; and<\/li>\n+ *     <li>The scope of {@code R} is {@linkplain ResourceScope#keepAlive(ResourceScope) kept alive} (and cannot be closed) during the invocation.\n+ *<\/ul>\n+ * <p>\n+ * When creating upcall stubs the linker runtime validates the type of the target method handle against the provided\n+ * function descriptor and report an error if any mismatch is detected. As for downcalls, JVM crashes might occur,\n+ * if the native code casts the function pointer associated with an upcall stub to a type\n+ * that is incompatible with the provided function descriptor. Moreover, if the target method\n+ * handle associated with an upcall stub returns a {@linkplain MemoryAddress native address}, clients must ensure\n+ * that this address cannot become invalid after the upcall completes. This can lead to unspecified behavior,\n+ * and even JVM crashes, since an upcall is typically executed in the context of a downcall method handle invocation.\n+ *\n@@ -145,1 +168,1 @@\n-     * @return a linker-specific library lookup which is suitable to find symbols in the standard libraries associated with this linker.\n+     * @return a symbol in the standard libraries associated with this linker.\n@@ -225,0 +248,22 @@\n+\n+    \/**\n+     * Obtains the downcall method handle {@linkplain MethodType type} associated with a given function descriptor.\n+     * @param functionDescriptor a function descriptor.\n+     * @return the downcall method handle {@linkplain MethodType type} associated with a given function descriptor.\n+     * @throws IllegalArgumentException if one or more layouts in the function descriptor are not supported\n+     * (e.g. if they are sequence layouts or padding layouts).\n+     *\/\n+    static MethodType downcallType(FunctionDescriptor functionDescriptor) {\n+        return SharedUtils.inferMethodType(functionDescriptor, false);\n+    }\n+\n+    \/**\n+     * Obtains the method handle {@linkplain MethodType type} associated with an upcall stub with given function descriptor.\n+     * @param functionDescriptor a function descriptor.\n+     * @return the method handle {@linkplain MethodType type} associated with an upcall stub with given function descriptor.\n+     * @throws IllegalArgumentException if one or more layouts in the function descriptor are not supported\n+     * (e.g. if they are sequence layouts or padding layouts).\n+     *\/\n+    static MethodType upcallType(FunctionDescriptor functionDescriptor) {\n+        return SharedUtils.inferMethodType(functionDescriptor, true);\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":63,"deletions":18,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-    private final MemoryLayout[] argLayouts;\n+    private final List<MemoryLayout> argLayouts;\n@@ -51,1 +51,1 @@\n-    private FunctionDescriptor(MemoryLayout resLayout, MemoryLayout... argLayouts) {\n+    private FunctionDescriptor(MemoryLayout resLayout, List<MemoryLayout> argLayouts) {\n@@ -69,1 +69,1 @@\n-        return Arrays.asList(argLayouts);\n+        return argLayouts;\n@@ -82,1 +82,1 @@\n-        return new FunctionDescriptor(resLayout, argLayouts);\n+        return new FunctionDescriptor(resLayout, List.of(argLayouts));\n@@ -93,1 +93,1 @@\n-        return new FunctionDescriptor(null, argLayouts);\n+        return new FunctionDescriptor(null, List.of(argLayouts));\n@@ -127,1 +127,1 @@\n-        return insertArgumentLayouts(argLayouts.length, addedLayouts);\n+        return insertArgumentLayouts(argLayouts.size(), addedLayouts);\n@@ -141,1 +141,1 @@\n-        if (index < 0 || index > argLayouts.length)\n+        if (index < 0 || index > argLayouts.size())\n@@ -143,3 +143,4 @@\n-        MemoryLayout[] newLayouts = Arrays.copyOf(argLayouts, argLayouts.length + addedLayouts.length);\n-        System.arraycopy(newLayouts, index, newLayouts, index + addedLayouts.length, argLayouts.length - index);\n-        System.arraycopy(addedLayouts, 0, newLayouts, index, addedLayouts.length);\n+        List<MemoryLayout> newLayouts = new ArrayList<>(argLayouts.size() + addedLayouts.length);\n+        newLayouts.addAll(argLayouts.subList(0, index));\n+        newLayouts.addAll(List.of(addedLayouts));\n+        newLayouts.addAll(argLayouts.subList(index, argLayouts.size()));\n@@ -199,1 +200,1 @@\n-        return Objects.equals(resLayout, f.resLayout) && Arrays.equals(argLayouts, f.argLayouts);\n+        return Objects.equals(resLayout, f.resLayout) && Objects.equals(argLayouts, f.argLayouts);\n@@ -208,1 +209,1 @@\n-        int hashCode = Arrays.hashCode(argLayouts);\n+        int hashCode = Objects.hashCode(argLayouts);\n@@ -212,0 +213,8 @@\n+    \/**\n+     * Returns an {@link Optional} containing the nominal descriptor for this\n+     * function descriptor, if one can be constructed, or an empty {@link Optional}\n+     * if one cannot be constructed.\n+     *\n+     * @return An {@link Optional} containing the resulting nominal descriptor,\n+     * or an empty {@link Optional} if one cannot be constructed.\n+     *\/\n@@ -232,1 +241,1 @@\n-                    Stream.concat(descriptor.argumentLayouts().stream(), Stream.of(argLayouts)).toArray(MemoryLayout[]::new));\n+                    Stream.concat(descriptor.argumentLayouts().stream(), Stream.of(argLayouts)).toList());\n@@ -236,4 +245,1 @@\n-        public boolean isVariadicIndex(int pos) {\n-            return pos >= firstVariadicIndex;\n-        }\n-\n+        @Override\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/FunctionDescriptor.java","additions":24,"deletions":18,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -69,2 +69,0 @@\n- * <p>\n- * Non-platform classes should not implement {@linkplain MemoryAddress} directly.\n@@ -107,1 +105,1 @@\n-     * @return a Java UTF-8 string containing all the bytes read from the given starting address ({@code toRowLongValue() + offset})\n+     * @return a Java string constructed from the bytes read from the given starting address ({@code toRowLongValue() + offset})\n@@ -118,1 +116,1 @@\n-     * Writes a UTF-8 encoded, null-terminated string to this address at given offset.\n+     * Writes the given string to this address at given offset, converting it to a null-terminated byte sequence using UTF-8 encoding.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,2 +84,0 @@\n- * <p>\n- * Non-platform classes should not implement {@linkplain MemoryLayout} directly.\n@@ -552,2 +550,0 @@\n-     * <p>\n-     * Non-platform classes should not implement {@linkplain PathElement} directly.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayout.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n- * {@link MemoryAddress#ofLong(long)} and {@link MemorySegment#ofAddressNative(MemoryAddress, long, ResourceScope)}.\n+ * {@link MemoryAddress#ofLong(long)} and {@link MemorySegment#ofAddress(MemoryAddress, long, ResourceScope)}.\n@@ -110,1 +110,1 @@\n- * full spatial, temporal and confinement bounds. To do this, clients can {@link #ofAddressNative(MemoryAddress, long, ResourceScope) obtain}\n+ * full spatial, temporal and confinement bounds. To do this, clients can {@link #ofAddress(MemoryAddress, long, ResourceScope) obtain}\n@@ -327,2 +327,2 @@\n-     * <p>Two segments S1 and S2 are said to overlap if it is possible to find\n-     * at least two slices L1 (from S1) and L2 (from S2) that are backed by the\n+     * <p>Two segments {@code S1} and {@code S2} are said to overlap if it is possible to find\n+     * at least two slices {@code L1} (from {@code S1}) and {@code L2} (from {@code S2}) that are backed by the\n@@ -387,1 +387,1 @@\n-     * Performs an element-wise bulk copy from given source segment to this segment. More specifically, the bytes at\n+     * Performs a bulk copy from given source segment to this segment. More specifically, the bytes at\n@@ -397,4 +397,0 @@\n-     * @throws IllegalArgumentException if the element layouts have different sizes, if the source segment size is not\n-     * a multiple of the source element layout size, if the source segment is incompatible with the alignment constraints\n-     * in the source element layout, or if this segment is incompatible with the alignment constraints\n-     * in the destination element layout.\n@@ -633,1 +629,1 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -635,1 +631,1 @@\n-     * @return a Java UTF-8 string containing all the bytes read from the given starting address up to (but not including)\n+     * @return a Java string constructed from the bytes read from the given starting address up to (but not including)\n@@ -646,1 +642,1 @@\n-     * Writes a UTF-8 encoded, null-terminated string into this segment at given offset.\n+     * Writes the given string into this segment at given offset, converting it to a null-terminated byte sequence using UTF-8 encoding.\n@@ -652,1 +648,1 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -762,1 +758,1 @@\n-     * Creates a new native memory segment with given size and resource scope, and whose base address is this address.\n+     * Creates a new native memory segment with given size and resource scope, and whose base address is the given address.\n@@ -769,1 +765,1 @@\n-     * Clients should ensure that the address and bounds refers to a valid region of memory that is accessible for reading and,\n+     * Clients should ensure that the address and bounds refer to a valid region of memory that is accessible for reading and,\n@@ -791,1 +787,1 @@\n-    static MemorySegment ofAddressNative(MemoryAddress address, long bytesSize, ResourceScope scope) {\n+    static MemorySegment ofAddress(MemoryAddress address, long bytesSize, ResourceScope scope) {\n@@ -1035,1 +1031,1 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1052,1 +1048,1 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1068,1 +1064,1 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1085,1 +1081,1 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1087,1 +1083,1 @@\n-     * @param value the byte value to be written.\n+     * @param value the boolean value to be written.\n@@ -1101,1 +1097,1 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1118,1 +1114,1 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1120,1 +1116,1 @@\n-     * @param value the byte value to be written.\n+     * @param value the char value to be written.\n@@ -1134,1 +1130,1 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1151,1 +1147,1 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1153,1 +1149,1 @@\n-     * @param value the byte value to be written.\n+     * @param value the short value to be written.\n@@ -1167,1 +1163,1 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1184,1 +1180,1 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1186,1 +1182,1 @@\n-     * @param value the byte value to be written.\n+     * @param value the int value to be written.\n@@ -1200,1 +1196,1 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1217,1 +1213,1 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1219,1 +1215,1 @@\n-     * @param value the byte value to be written.\n+     * @param value the float value to be written.\n@@ -1233,1 +1229,1 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1250,1 +1246,1 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1252,1 +1248,1 @@\n-     * @param value the byte value to be written.\n+     * @param value the long value to be written.\n@@ -1266,1 +1262,1 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1283,1 +1279,1 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1285,1 +1281,1 @@\n-     * @param value the byte value to be written.\n+     * @param value the double value to be written.\n@@ -1299,1 +1295,1 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1316,1 +1312,1 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1318,1 +1314,1 @@\n-     * @param value the byte value to be written.\n+     * @param value the address value to be written.\n@@ -1332,1 +1328,1 @@\n-     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1349,1 +1345,1 @@\n-     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1351,1 +1347,1 @@\n-     * @param value the byte value to be written.\n+     * @param value the char value to be written.\n@@ -1365,1 +1361,1 @@\n-     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1382,1 +1378,1 @@\n-     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1384,1 +1380,1 @@\n-     * @param value the byte value to be written.\n+     * @param value the short value to be written.\n@@ -1398,1 +1394,1 @@\n-     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1415,1 +1411,1 @@\n-     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1417,1 +1413,1 @@\n-     * @param value the byte value to be written.\n+     * @param value the int value to be written.\n@@ -1431,1 +1427,1 @@\n-     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1448,1 +1444,1 @@\n-     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1450,1 +1446,1 @@\n-     * @param value the byte value to be written.\n+     * @param value the float value to be written.\n@@ -1464,1 +1460,1 @@\n-     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1481,1 +1477,1 @@\n-     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1483,1 +1479,1 @@\n-     * @param value the byte value to be written.\n+     * @param value the long value to be written.\n@@ -1497,1 +1493,1 @@\n-     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1514,1 +1510,1 @@\n-     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1516,1 +1512,1 @@\n-     * @param value the byte value to be written.\n+     * @param value the double value to be written.\n@@ -1530,1 +1526,1 @@\n-     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1547,1 +1543,1 @@\n-     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n@@ -1549,1 +1545,1 @@\n-     * @param value the byte value to be written.\n+     * @param value the address value to be written.\n@@ -1563,1 +1559,1 @@\n-     * Supported array types are {@code byte[]}, {@code char[]},{@code short[]},{@code int[]},{@code float[]},{@code long[]} and {@code double[]}.\n+     * Supported array types are {@code byte[]}, {@code char[]}, {@code short[]}, {@code int[]}, {@code float[]}, {@code long[]} and {@code double[]}.\n@@ -1604,1 +1600,1 @@\n-     * Supported array types are {@code byte[]}, {@code char[]},{@code short[]},{@code int[]},{@code float[]},{@code long[]} and {@code double[]}.\n+     * Supported array types are {@code byte[]}, {@code char[]}, {@code short[]}, {@code int[]}, {@code float[]}, {@code long[]} and {@code double[]}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":61,"deletions":65,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-        return ResourceScopeImpl.createConfined( Thread.currentThread(), null);\n+        return ResourceScopeImpl.createConfined(Thread.currentThread(), null);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ResourceScope.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,0 +77,2 @@\n+     * @implSpec the default implementation for this method copies the contents of the provided Java string\n+     * into a new memory segment obtained by calling {@code this.allocate(str.length() + 1)}.\n@@ -389,4 +391,0 @@\n-     * An allocator associated with a <em>shared<\/em> resource scope is thread-safe and allocation requests may be\n-     * performed concurrently; conversely, if the arena allocator is associated with a <em>confined<\/em> resource scope,\n-     * allocation requests can only occur from the thread owning the allocator's resource scope.\n-     * <p>\n@@ -394,2 +392,2 @@\n-     * exceeds the arena size, or the system capacity. Furthermore, the returned allocator is not thread safe, and all\n-     * allocation requests should occur within a single thread (regardless of the scope associated with the native arena).\n+     * exceeds the arena size, or the system capacity. Furthermore, the returned allocator is not thread safe.\n+     * Concurrent allocation needs to be guarded with synchronization primitives.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.ResourceScopeImpl;\n@@ -58,1 +59,3 @@\n-     * (that is, libraries loaded using {@link System#loadLibrary} or {@link System#load}).\n+     * (that is, libraries loaded using {@link System#loadLibrary} or {@link System#load}). The returned lookup\n+     * returns native symbols backed by a non-closeable, shared scope which keeps the caller's classloader\n+     * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">reachable<\/a>.\n@@ -75,0 +78,1 @@\n+        ResourceScope loaderScope = ResourceScopeImpl.heapScope(loader);\n@@ -79,1 +83,1 @@\n-            return addr == MemoryAddress.NULL? Optional.empty() : Optional.of(NativeSymbol.ofAddress(name, addr, ResourceScope.globalScope()));\n+            return addr == MemoryAddress.NULL? Optional.empty() : Optional.of(NativeSymbol.ofAddress(name, addr, loaderScope));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SymbolLookup.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-     * with the same scope as this variable argument list. using the segment provided allocator. Copying is useful to\n+     * with the same scope as this variable argument list. Copying is useful to\n@@ -144,1 +144,0 @@\n-     * @throws UnsupportedOperationException if this variable argument list has been allocated using heap segments.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/VaList.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -71,0 +71,2 @@\n+    private static final int ADDRESS_SIZE_BITS = Unsafe.ADDRESS_SIZE * 8;\n+\n@@ -172,3 +174,2 @@\n-        if (carrier == void.class) return;\n-        if (carrier == MemoryAddress.class && size != (Unsafe.ADDRESS_SIZE * 8)) {\n-            throw new IllegalArgumentException(\"Address size mismatch: \" + (Unsafe.ADDRESS_SIZE * 8) + \" != \" + size);\n+        if (carrier == MemoryAddress.class && size != ADDRESS_SIZE_BITS) {\n+            throw new IllegalArgumentException(\"Address size mismatch: \" + ADDRESS_SIZE_BITS + \" != \" + size);\n@@ -176,3 +177,5 @@\n-        if (carrier.isPrimitive() && Wrapper.forPrimitiveType(carrier).bitWidth() != size &&\n-                carrier != boolean.class && size != 8) {\n-            throw new IllegalArgumentException(\"Carrier size mismatch: \" + carrier.getName() + \" != \" + size);\n+        if (carrier.isPrimitive()) {\n+            int expectedSize =  carrier == boolean.class ? 8 : Wrapper.forPrimitiveType(carrier).bitWidth();\n+            if (size != expectedSize) {\n+                throw new IllegalArgumentException(\"Carrier size mismatch: \" + carrier.getName() + \" != \" + size);\n+            }\n@@ -183,2 +186,1 @@\n-        return carrier == void.class\n-                || carrier == boolean.class\n+        return carrier == boolean.class\n@@ -201,1 +203,2 @@\n-            handle = Utils.makeMemoryAccessVarHandle(carrier, false, byteAlignment() - 1, order());\n+            \/\/ this store to stable field is safe, because return value of 'makeMemoryAccessVarHandle' has stable identity\n+            handle = Utils.makeMemoryAccessVarHandle(this, false);\n@@ -483,1 +486,1 @@\n-            super(MemoryAddress.class, order, Unsafe.ADDRESS_SIZE * 8);\n+            super(MemoryAddress.class, order, ADDRESS_SIZE_BITS);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ValueLayout.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-   segment.setAtIndex(ValueLayout.JAVA_INT, i, 42);\n+   segment.setAtIndex(ValueLayout.JAVA_INT, i, i);\n@@ -55,5 +55,4 @@\n- * Inside a loop, we then initialize the contents of the memory segment using the\n- * {@link jdk.incubator.foreign.MemorySegment#setAtIndex(ValueLayout.OfInt, long, int)} dereference method. Note how\n- * the dereference method accepts a {@linkplain jdk.incubator.foreign.ValueLayout value layout},\n- * which specifies the size, alignment constraints, byte order as well\n- * as the Java type ({@code int}, in this case) associated with the dereference operation. More specifically,\n+ * Inside a loop, we then initialize the contents of the memory segment; note how the\n+ * {@linkplain jdk.incubator.foreign.MemorySegment#setAtIndex(ValueLayout.OfInt, long, int) dereference method}\n+ * accepts a {@linkplain jdk.incubator.foreign.ValueLayout value layout}, which specifies the size, alignment constraints,\n+ * byte order as well as the Java type ({@code int}, in this case) associated with the dereference operation. More specifically,\n@@ -77,1 +76,1 @@\n-        segment.setAtIndex(ValueLayout.JAVA_INT, i, 42);\n+        segment.setAtIndex(ValueLayout.JAVA_INT, i, i);\n@@ -135,3 +134,3 @@\n- * interacting with native code, such as converting Java strings into native strings and back\n- * (see {@link jdk.incubator.foreign.MemorySegment#setUtf8String(long, java.lang.String)} and\n- * {@link jdk.incubator.foreign.MemorySegment#getUtf8String(long)}, respectively), as demonstrated in the above example.\n+ * interacting with native code, such as converting Java strings\n+ * {@linkplain jdk.incubator.foreign.MemorySegment#setUtf8String(long, java.lang.String) into} native strings and\n+ * {@linkplain jdk.incubator.foreign.MemorySegment#getUtf8String(long) back}, as demonstrated in the above example.\n@@ -148,2 +147,3 @@\n- * using one of the many <em>unsafe<\/em> dereference methods provided\n- * (see {@link jdk.incubator.foreign.MemoryAddress#get(jdk.incubator.foreign.ValueLayout.OfInt, long)}):\n+ * using one of the many <em>unsafe<\/em>\n+ * {@linkplain jdk.incubator.foreign.MemoryAddress#get(jdk.incubator.foreign.ValueLayout.OfInt, long) dereference methods}\n+ * provided:\n@@ -157,4 +157,5 @@\n- * Alternatively, the client can create a memory segment <em>unsafely<\/em>, using the\n- * {@link jdk.incubator.foreign.MemorySegment#ofAddressNative(jdk.incubator.foreign.MemoryAddress, long, jdk.incubator.foreign.ResourceScope)} factory.\n- * This allows the client to inject extra knowledge about spatial bounds which might, for instance, be available in the documentation of the foreign function\n- * which produced the native address. Here is how an unsafe segment can be created from a native address:\n+ * Alternatively, the client can\n+ * {@linkplain jdk.incubator.foreign.MemorySegment#ofAddress(jdk.incubator.foreign.MemoryAddress, long, jdk.incubator.foreign.ResourceScope) create}\n+ * a memory segment <em>unsafely<\/em>. This allows the client to inject extra knowledge about spatial bounds which might,\n+ * for instance, be available in the documentation of the foreign function which produced the native address.\n+ * Here is how an unsafe segment can be created from a native address:\n@@ -165,1 +166,1 @@\n-MemorySegment segment = MemorySegment.ofAddressNative(addr, 4, scope); \/\/ segment is 4 bytes long\n+MemorySegment segment = MemorySegment.ofAddress(addr, 4, scope); \/\/ segment is 4 bytes long\n@@ -187,0 +188,1 @@\n+FunctionDescriptor intCompareDescriptor = FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.ADDRESS, ValueLayout.ADDRESS);\n@@ -189,1 +191,1 @@\n-                                                   MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class));\n+                                                   CLinker.upcallType(comparFunction));\n@@ -192,1 +194,7 @@\n- * Now that we have a method handle instance, we can link it into a fresh native memory address, using the {@link jdk.incubator.foreign.CLinker} interface, as follows:\n+ * As before, we need to create a {@link jdk.incubator.foreign.FunctionDescriptor} instance, this time describing the signature\n+ * of the function pointer we want to create. The descriptor can be used to\n+ * {@linkplain jdk.incubator.foreign.CLinker#upcallType(jdk.incubator.foreign.FunctionDescriptor) derive} a method type\n+ * that can be used to lookup the method handle for {@code IntComparator.intCompare}.\n+ * <p>\n+ * Now that we have a method handle instance, we can turn it into a fresh function pointer,\n+ * using the {@link jdk.incubator.foreign.CLinker} interface, as follows:\n@@ -197,3 +205,1 @@\n-     intCompareHandle,\n-     FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.ADDRESS, ValueLayout.ADDRESS),\n-     scope\n+     intCompareHandle, intCompareDescriptor, scope);\n@@ -203,7 +209,7 @@\n- * As before, we need to provide a {@link jdk.incubator.foreign.FunctionDescriptor} instance describing the signature\n- * of the function pointer we want to create; this descriptor allows the linker to determine the\n- * sequence of steps which allow foreign code to call the stub for {@code intCompareHandle} according to the rules specified\n- * by the platform C ABI. The lifecycle of the stub returned by\n- * {@link jdk.incubator.foreign.CLinker#upcallStub(java.lang.invoke.MethodHandle, jdk.incubator.foreign.FunctionDescriptor, jdk.incubator.foreign.ResourceScope)}\n- * is tied to the {@linkplain jdk.incubator.foreign.ResourceScope resource scope} parameter passed to that method. This\n- * is made available by the {@link jdk.incubator.foreign.NativeSymbol} instance returned by that method.\n+ * The {@link jdk.incubator.foreign.FunctionDescriptor} instance created in the previous step is then used to\n+ * {@linkplain jdk.incubator.foreign.CLinker#upcallStub(java.lang.invoke.MethodHandle, jdk.incubator.foreign.FunctionDescriptor, jdk.incubator.foreign.ResourceScope) create}\n+ * a new upcall stub; the layouts in the function descriptors allow the linker to determine the sequence of steps which\n+ * allow foreign code to call the stub for {@code intCompareHandle} according to the rules specified by the platform C ABI.\n+ * The lifecycle of the upcall stub returned by is tied to the {@linkplain jdk.incubator.foreign.ResourceScope resource scope}\n+ * provided when the upcall stub is created. This same scope is made available by the {@link jdk.incubator.foreign.NativeSymbol}\n+ * instance returned by that method.\n@@ -215,1 +221,1 @@\n- * the restricted method {@link jdk.incubator.foreign.MemorySegment#ofAddressNative(jdk.incubator.foreign.MemoryAddress, long, jdk.incubator.foreign.ResourceScope)}\n+ * the restricted method {@link MemorySegment#ofAddress(MemoryAddress, long, ResourceScope)}\n@@ -219,1 +225,1 @@\n- * For instance, in the case of {@link jdk.incubator.foreign.MemorySegment#ofAddressNative(jdk.incubator.foreign.MemoryAddress, long, jdk.incubator.foreign.ResourceScope)},\n+ * For instance, in the case of {@link MemorySegment#ofAddress(MemoryAddress, long, ResourceScope)},\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":37,"deletions":31,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    MemorySegment segment;\n+    private MemorySegment segment;\n@@ -38,5 +38,5 @@\n-    long sp = 0L;\n-    long size = 0;\n-    final long blockSize;\n-    final long arenaSize;\n-    final ResourceScope scope;\n+    private long sp = 0L;\n+    private long size = 0;\n+    private final long blockSize;\n+    private final long arenaSize;\n+    private final ResourceScope scope;\n@@ -67,2 +67,7 @@\n-    private MemorySegment newSegment(long size, long align) {\n-        return MemorySegment.allocateNative(size, align, scope);\n+    private MemorySegment newSegment(long bytesSize, long bytesAlignment) {\n+        long allocatedSize = Utils.alignUp(bytesSize, bytesAlignment);\n+        if (size + allocatedSize > arenaSize) {\n+            throw new OutOfMemoryError();\n+        }\n+        size += allocatedSize;\n+        return MemorySegment.allocateNative(bytesSize, bytesAlignment, scope);\n@@ -73,8 +78,9 @@\n-        long prevSp = sp;\n-        long allocatedSize = 0L;\n-        try {\n-            \/\/ try to slice from current segment first...\n-            MemorySegment slice = trySlice(bytesSize, bytesAlignment);\n-            if (slice != null) {\n-                allocatedSize = sp - prevSp;\n-                return slice;\n+        \/\/ try to slice from current segment first...\n+        MemorySegment slice = trySlice(bytesSize, bytesAlignment);\n+        if (slice != null) {\n+            return slice;\n+        } else {\n+            long maxPossibleAllocationSize = bytesSize + bytesAlignment - 1;\n+            if (maxPossibleAllocationSize > blockSize) {\n+                \/\/ too big\n+                return newSegment(bytesSize, bytesAlignment);\n@@ -82,22 +88,5 @@\n-                long maxPossibleAllocationSize = bytesSize + bytesAlignment - 1;\n-                if (maxPossibleAllocationSize > blockSize) {\n-                    \/\/ too big\n-                    allocatedSize = Utils.alignUp(bytesSize, bytesAlignment);\n-                    if (size > arenaSize) {\n-                        throw new OutOfMemoryError();\n-                    }\n-                    return newSegment(bytesSize, bytesAlignment);\n-                } else {\n-                    \/\/ allocate a new segment and slice from there\n-                    allocatedSize += segment.byteSize() - sp;\n-                    sp = 0L;\n-                    segment = newSegment(blockSize, 1L);\n-                    slice = trySlice(bytesSize, bytesAlignment);\n-                    allocatedSize += sp;\n-                    return slice;\n-                }\n-            }\n-        } finally {\n-            size += allocatedSize;\n-            if (size > arenaSize) {\n-                throw new OutOfMemoryError();\n+                \/\/ allocate a new segment and slice from there\n+                sp = 0L;\n+                segment = newSegment(blockSize, 1L);\n+                slice = trySlice(bytesSize, bytesAlignment);\n+                return slice;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ArenaAllocator.java","additions":27,"deletions":38,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -97,4 +97,1 @@\n-            int value;\n-            do {\n-                value = (int)ASYNC_RELEASE_COUNT.getVolatile(this);\n-            } while (!ASYNC_RELEASE_COUNT.compareAndSet(this, value, value + 1));\n+            ASYNC_RELEASE_COUNT.getAndAdd(this, 1);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ConfinedScope.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-        if (!(layout instanceof ValueLayout)) {\n+        if (!(layout instanceof ValueLayout valueLayout)) {\n@@ -161,2 +161,0 @@\n-        Class<?> carrier = ((ValueLayout)layout).carrier();\n-\n@@ -168,2 +166,1 @@\n-        VarHandle handle = Utils.makeMemoryAccessVarHandle(carrier, true, layout.byteAlignment() - 1,\n-                ((ValueLayout)layout).order());\n+        VarHandle handle = Utils.makeMemoryAccessVarHandle(valueLayout, true);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -117,0 +117,1 @@\n+        Objects.requireNonNull(target);\n@@ -191,1 +192,3 @@\n-        public GlobalScopeImpl() {\n+        final Object ref;\n+\n+        public GlobalScopeImpl(Object ref) {\n@@ -193,0 +196,1 @@\n+            this.ref = ref;\n@@ -218,1 +222,5 @@\n-    public static final ResourceScopeImpl GLOBAL = new GlobalScopeImpl();\n+    public static final ResourceScopeImpl GLOBAL = new GlobalScopeImpl(null);\n+\n+    public static ResourceScopeImpl heapScope(Object ref) {\n+        return new GlobalScopeImpl(ref);\n+    }\n@@ -245,1 +253,1 @@\n-        public static abstract class ResourceCleanup {\n+        public abstract static class ResourceCleanup {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ResourceScopeImpl.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-            value = (int) STATE.getVolatile(jdk.internal.foreign.SharedScope.this);\n+            value = (int) STATE.getVolatile(this);\n@@ -106,1 +106,1 @@\n-        } while (!STATE.compareAndSet(jdk.internal.foreign.SharedScope.this, value, value - 1));\n+        } while (!STATE.compareAndSet(this, value, value - 1));\n@@ -146,4 +146,2 @@\n-                ResourceCleanup prev = (ResourceCleanup) FST.getAcquire(this);\n-                cleanup.next = prev;\n-                ResourceCleanup newSegment = (ResourceCleanup) FST.compareAndExchangeRelease(this, prev, cleanup);\n-                if (newSegment == ResourceCleanup.CLOSED_LIST) {\n+                ResourceCleanup prev = (ResourceCleanup) FST.getVolatile(this);\n+                if (prev == ResourceCleanup.CLOSED_LIST) {\n@@ -152,1 +150,3 @@\n-                } else if (newSegment == prev) {\n+                }\n+                cleanup.next = prev;\n+                if (FST.compareAndSet(this, prev, cleanup)) {\n@@ -168,1 +168,1 @@\n-                    prev = (ResourceCleanup) FST.getAcquire(this);\n+                    prev = (ResourceCleanup) FST.getVolatile(this);\n@@ -170,1 +170,1 @@\n-                    if (FST.weakCompareAndSetRelease(this, prev, ResourceCleanup.CLOSED_LIST)) {\n+                    if (FST.compareAndSet(this, prev, ResourceCleanup.CLOSED_LIST)) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SharedScope.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    final static SystemLookup INSTANCE = new SystemLookup();\n+    static final SystemLookup INSTANCE = new SystemLookup();\n@@ -74,1 +74,1 @@\n-            MemorySegment funcs = MemorySegment.ofAddressNative(fallbackLibLookup.lookup(\"funcs\").orElseThrow().address(),\n+            MemorySegment funcs = MemorySegment.ofAddress(fallbackLibLookup.lookup(\"funcs\").orElseThrow().address(),\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,2 @@\n-import java.nio.ByteOrder;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -107,3 +108,12 @@\n-    public static VarHandle makeMemoryAccessVarHandle(Class<?> carrier, boolean skipAlignmentCheck, long alignmentMask, ByteOrder order) {\n-        Class<?> baseCarrier = carrier;\n-        if (carrier == MemoryAddress.class) {\n+    public static VarHandle makeMemoryAccessVarHandle(ValueLayout layout, boolean skipAlignmentCheck) {\n+        class VarHandleCache {\n+            private static final Map<ValueLayout, VarHandle> handleMap = new ConcurrentHashMap<>();\n+            private static final Map<ValueLayout, VarHandle> handleMapNoAlignCheck = new ConcurrentHashMap<>();\n+\n+            static VarHandle put(ValueLayout layout, VarHandle handle, boolean skipAlignmentCheck) {\n+                VarHandle prev = (skipAlignmentCheck ? handleMapNoAlignCheck : handleMap).putIfAbsent(layout, handle);\n+                return prev != null ? prev : handle;\n+            }\n+        }\n+        Class<?> baseCarrier = layout.carrier();\n+        if (layout.carrier() == MemoryAddress.class) {\n@@ -115,1 +125,1 @@\n-        } else if (carrier == boolean.class) {\n+        } else if (layout.carrier() == boolean.class) {\n@@ -119,1 +129,2 @@\n-        VarHandle handle = SharedSecrets.getJavaLangInvokeAccess().memoryAccessVarHandle(baseCarrier, skipAlignmentCheck, alignmentMask, order);\n+        VarHandle handle = SharedSecrets.getJavaLangInvokeAccess().memoryAccessVarHandle(baseCarrier, skipAlignmentCheck,\n+                layout.byteAlignment() - 1, layout.order());\n@@ -126,4 +137,4 @@\n-        if (carrier == boolean.class) {\n-            return MemoryHandles.filterValue(handle, BOOL_TO_BYTE, BYTE_TO_BOOL);\n-        } else if (carrier == MemoryAddress.class) {\n-            return MemoryHandles.filterValue(handle,\n+        if (layout.carrier() == boolean.class) {\n+            handle = MemoryHandles.filterValue(handle, BOOL_TO_BYTE, BYTE_TO_BOOL);\n+        } else if (layout.carrier() == MemoryAddress.class) {\n+            handle = MemoryHandles.filterValue(handle,\n@@ -132,2 +143,0 @@\n-        } else {\n-            return handle;\n@@ -135,0 +144,1 @@\n+        return VarHandleCache.put(layout, handle, skipAlignmentCheck);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":22,"deletions":12,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -493,1 +493,1 @@\n-    static abstract class Move extends Binding {\n+    abstract static class Move extends Binding {\n@@ -599,1 +599,1 @@\n-    private static abstract class Dereference extends Binding {\n+    private abstract static class Dereference extends Binding {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -66,0 +68,2 @@\n+    private static final JavaLangInvokeAccess JLI = SharedSecrets.getJavaLangInvokeAccess();\n+\n@@ -103,1 +107,1 @@\n-        doBindings = insertArguments(exactInvoker(doBindings.type()), 0, doBindings);\n+        JLI.ensureCustomized(doBindings);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-        MemorySegment gpRegsArea = MemorySegment.ofAddressNative(grTop(segment).addOffset(-MAX_GP_OFFSET),\n+        MemorySegment gpRegsArea = MemorySegment.ofAddress(grTop(segment).addOffset(-MAX_GP_OFFSET),\n@@ -118,1 +118,1 @@\n-        MemorySegment fpRegsArea = MemorySegment.ofAddressNative(vrTop(segment).addOffset(-MAX_FP_OFFSET),\n+        MemorySegment fpRegsArea = MemorySegment.ofAddress(vrTop(segment).addOffset(-MAX_FP_OFFSET),\n@@ -127,1 +127,1 @@\n-        MemorySegment ms = MemorySegment.ofAddressNative(MemoryAddress.ofLong(ptr),\n+        MemorySegment ms = MemorySegment.ofAddress(MemoryAddress.ofLong(ptr),\n@@ -250,1 +250,1 @@\n-                    MemorySegment slice = MemorySegment.ofAddressNative(stackPtr(), layout.byteSize(), scope());\n+                    MemorySegment slice = MemorySegment.ofAddress(stackPtr(), layout.byteSize(), scope());\n@@ -258,1 +258,1 @@\n-                    MemorySegment slice = MemorySegment.ofAddressNative(stackPtr(), layout.byteSize(), scope());\n+                    MemorySegment slice = MemorySegment.ofAddress(stackPtr(), layout.byteSize(), scope());\n@@ -300,1 +300,1 @@\n-                    MemorySegment slice = MemorySegment.ofAddressNative(ptr, layout.byteSize(), scope());\n+                    MemorySegment slice = MemorySegment.ofAddress(ptr, layout.byteSize(), scope());\n@@ -346,1 +346,1 @@\n-        return readFromSegment(MemorySegment.ofAddressNative(ma, LAYOUT.byteSize(), scope));\n+        return readFromSegment(MemorySegment.ofAddress(ma, LAYOUT.byteSize(), scope));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-                    MemorySegment struct = MemorySegment.ofAddressNative(structAddr, layout.byteSize(), scope());\n+                    MemorySegment struct = MemorySegment.ofAddress(structAddr, layout.byteSize(), scope());\n@@ -142,1 +142,1 @@\n-        MemorySegment segment = MemorySegment.ofAddressNative(addr, Long.MAX_VALUE, scope);\n+        MemorySegment segment = MemorySegment.ofAddress(addr, Long.MAX_VALUE, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-        MemorySegment base = MemorySegment.ofAddressNative(MemoryAddress.ofLong(ptr),\n+        MemorySegment base = MemorySegment.ofAddress(MemoryAddress.ofLong(ptr),\n@@ -173,1 +173,1 @@\n-        return MemorySegment.ofAddressNative(((MemoryAddress)VH_reg_save_area.get(segment)),\n+        return MemorySegment.ofAddress(((MemoryAddress)VH_reg_save_area.get(segment)),\n@@ -225,1 +225,1 @@\n-                    MemorySegment slice = MemorySegment.ofAddressNative(stackPtr(), layout.byteSize(), scope());\n+                    MemorySegment slice = MemorySegment.ofAddress(stackPtr(), layout.byteSize(), scope());\n@@ -234,1 +234,1 @@\n-                        MemorySegment slice = MemorySegment.ofAddressNative(stackPtr(), layout.byteSize(), localScope);\n+                        MemorySegment slice = MemorySegment.ofAddress(stackPtr(), layout.byteSize(), localScope);\n@@ -299,1 +299,1 @@\n-        return readFromSegment(MemorySegment.ofAddressNative(ma, LAYOUT.byteSize(), scope));\n+        return readFromSegment(MemorySegment.ofAddress(ma, LAYOUT.byteSize(), scope));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-                    MemorySegment struct = MemorySegment.ofAddressNative(structAddr, layout.byteSize(), scope());\n+                    MemorySegment struct = MemorySegment.ofAddress(structAddr, layout.byteSize(), scope());\n@@ -141,1 +141,1 @@\n-        MemorySegment segment = MemorySegment.ofAddressNative(addr, Long.MAX_VALUE, scope);\n+        MemorySegment segment = MemorySegment.ofAddress(addr, Long.MAX_VALUE, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1021,1 +1021,2 @@\n-                                c.setTime(tsTokenInfo.getDate());\n+                                Date tsDate = tsTokenInfo.getDate();\n+                                c.setTime(tsDate);\n@@ -1023,1 +1024,5 @@\n-                                    new JarConstraintsParameters(chain, si.getTimestamp());\n+                                    new JarConstraintsParameters(chain, tsDate);\n+                                JarConstraintsParameters jcpts =\n+                                    new JarConstraintsParameters(\n+                                        tsSi.getCertificateChain(tsToken),\n+                                        tsDate);\n@@ -1032,3 +1037,3 @@\n-                                        verifyWithWeak(tsDigestAlg, DIGEST_PRIMITIVE_SET, true, jcp),\n-                                        verifyWithWeak(tsSigAlg, SIG_PRIMITIVE_SET, true, jcp),\n-                                        verifyWithWeak(tsKey, jcp));\n+                                        verifyWithWeak(tsDigestAlg, DIGEST_PRIMITIVE_SET, true, jcpts),\n+                                        verifyWithWeak(tsSigAlg, SIG_PRIMITIVE_SET, true, jcpts),\n+                                        verifyWithWeak(tsKey, jcpts));\n@@ -1374,1 +1379,1 @@\n-            JAR_DISABLED_CHECK.permits(alg, jcp);\n+            JAR_DISABLED_CHECK.permits(alg, jcp, false);\n@@ -1380,1 +1385,1 @@\n-            LEGACY_CHECK.permits(alg, jcp);\n+            LEGACY_CHECK.permits(alg, jcp, false);\n@@ -1402,1 +1407,1 @@\n-            JAR_DISABLED_CHECK.permits(key.getAlgorithm(), jcp);\n+            JAR_DISABLED_CHECK.permits(key.getAlgorithm(), jcp, true);\n@@ -1408,1 +1413,1 @@\n-            LEGACY_CHECK.permits(key.getAlgorithm(), jcp);\n+            LEGACY_CHECK.permits(key.getAlgorithm(), jcp, true);\n@@ -1425,1 +1430,1 @@\n-            JAR_DISABLED_CHECK.permits(alg, jcp);\n+            JAR_DISABLED_CHECK.permits(alg, jcp, false);\n@@ -1427,1 +1432,1 @@\n-                LEGACY_CHECK.permits(alg, jcp);\n+                LEGACY_CHECK.permits(alg, jcp, false);\n@@ -1454,1 +1459,1 @@\n-            JAR_DISABLED_CHECK.permits(key.getAlgorithm(), jcp);\n+            JAR_DISABLED_CHECK.permits(key.getAlgorithm(), jcp, true);\n@@ -1456,1 +1461,1 @@\n-                LEGACY_CHECK.permits(key.getAlgorithm(), jcp);\n+                LEGACY_CHECK.permits(key.getAlgorithm(), jcp, true);\n@@ -1468,1 +1473,1 @@\n-            CERTPATH_DISABLED_CHECK.permits(key.getAlgorithm(), cpcp);\n+            CERTPATH_DISABLED_CHECK.permits(key.getAlgorithm(), cpcp, true);\n@@ -1473,1 +1478,1 @@\n-            LEGACY_CHECK.permits(key.getAlgorithm(), cpcp);\n+            LEGACY_CHECK.permits(key.getAlgorithm(), cpcp, true);\n@@ -1486,1 +1491,1 @@\n-            CERTPATH_DISABLED_CHECK.permits(alg, cpcp);\n+            CERTPATH_DISABLED_CHECK.permits(alg, cpcp, false);\n@@ -1491,1 +1496,1 @@\n-            LEGACY_CHECK.permits(alg, cpcp);\n+            LEGACY_CHECK.permits(alg, cpcp, false);\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Main.java","additions":22,"deletions":17,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+import java.nio.file.attribute.FileTime;\n@@ -123,1 +124,1 @@\n-    Map<String,byte[]> moduleInfos = new HashMap<>();\n+    Map<String, ModuleInfoEntry> moduleInfos = new HashMap<>();\n@@ -130,1 +131,4 @@\n-    Map<Integer,String[]> filesMap = new HashMap<>();\n+    \/\/ base version is the first entry and then follow with the version given\n+    \/\/ from the --release option in the command-line order.\n+    \/\/ The value of each entry is the files given in the command-line order.\n+    Map<Integer,String[]> filesMap = new LinkedHashMap<>();\n@@ -775,1 +779,1 @@\n-        if (files == null)\n+        if (files == null) {\n@@ -777,0 +781,1 @@\n+        }\n@@ -780,1 +785,1 @@\n-            if (dir == null)\n+            if (dir == null) {\n@@ -782,1 +787,1 @@\n-            else\n+            } else {\n@@ -784,0 +789,1 @@\n+            }\n@@ -804,2 +810,5 @@\n-                    moduleInfos.putIfAbsent(name, Files.readAllBytes(f.toPath()));\n-                    if (uflag)\n+                    Path path = f.toPath();\n+                    byte[] fileContent = Files.readAllBytes(path);\n+                    ModuleInfoEntry mie = new StreamedModuleInfoEntry(name, fileContent, Files.getLastModifiedTime(path));\n+                    moduleInfos.putIfAbsent(name, mie);\n+                    if (uflag) {\n@@ -807,0 +816,1 @@\n+                    }\n@@ -808,1 +818,1 @@\n-                    if (uflag)\n+                    if (uflag) {\n@@ -810,0 +820,1 @@\n+                    }\n@@ -816,1 +827,1 @@\n-                    \/\/ dir name confilict\/duplicate could happen with -C option.\n+                    \/\/ dir name conflict\/duplicate could happen with -C option.\n@@ -825,1 +836,6 @@\n-                    expand(f, f.list(), cpaths, version);\n+                    String[] dirFiles = f.list();\n+                    \/\/ Ensure files list is sorted for reproducible jar content\n+                    if (dirFiles != null) {\n+                        Arrays.sort(dirFiles);\n+                    }\n+                    expand(f, dirFiles, cpaths, version);\n@@ -898,1 +914,1 @@\n-                   Map<String,byte[]> moduleInfos,\n+                   Map<String, ModuleInfoEntry> moduleInfos,\n@@ -947,1 +963,1 @@\n-                moduleInfos.putIfAbsent(name, zis.readAllBytes());\n+                moduleInfos.putIfAbsent(name, new StreamedModuleInfoEntry(name, zis.readAllBytes(), e.getLastModifiedTime()));\n@@ -1031,1 +1047,1 @@\n-    private void updateModuleInfo(Map<String,byte[]> moduleInfos, ZipOutputStream zos)\n+    private void updateModuleInfo(Map<String, ModuleInfoEntry> moduleInfos, ZipOutputStream zos)\n@@ -1035,1 +1051,1 @@\n-        for (Map.Entry<String,byte[]> mi : moduleInfos.entrySet()) {\n+        for (Map.Entry<String, ModuleInfoEntry> mi : moduleInfos.entrySet()) {\n@@ -1037,1 +1053,2 @@\n-            byte[] bytes = mi.getValue();\n+            ModuleInfoEntry mie = mi.getValue();\n+            byte[] bytes = mie.readAllBytes();\n@@ -1039,1 +1056,6 @@\n-            e.setTime(System.currentTimeMillis());\n+            FileTime lastModified = mie.getLastModifiedTime();\n+            if (lastModified != null) {\n+                e.setLastModifiedTime(lastModified);\n+            } else {\n+                e.setLastModifiedTime(FileTime.fromMillis(System.currentTimeMillis()));\n+            }\n@@ -1734,1 +1756,1 @@\n-     * bytes and an optional URI. Used when describing modules.\n+     * bytes and an optional URI.\n@@ -1737,3 +1759,14 @@\n-       String name();\n-       Optional<String> uriString();\n-       InputStream bytes() throws IOException;\n+        String name();\n+        Optional<String> uriString();\n+        InputStream bytes() throws IOException;\n+        \/**\n+         * @return Returns the last modified time of the module-info.class.\n+         * Returns null if the last modified time is unknown or cannot be\n+         * determined.\n+         *\/\n+        FileTime getLastModifiedTime();\n+        default byte[] readAllBytes() throws IOException {\n+            try (InputStream is = bytes()) {\n+                return is.readAllBytes();\n+            }\n+        }\n@@ -1753,0 +1786,6 @@\n+\n+        @Override\n+        public FileTime getLastModifiedTime() {\n+            return entry.getLastModifiedTime();\n+        }\n+\n@@ -1764,1 +1803,3 @@\n-        StreamedModuleInfoEntry(String name, byte[] bytes) {\n+        private final FileTime lastModifiedTime;\n+\n+        StreamedModuleInfoEntry(String name, byte[] bytes, FileTime lastModifiedTime) {\n@@ -1767,0 +1808,1 @@\n+            this.lastModifiedTime = lastModifiedTime;\n@@ -1772,0 +1814,11 @@\n+\n+        @Override\n+        public byte[] readAllBytes() throws IOException {\n+            return bytes;\n+        }\n+\n+        @Override\n+        public FileTime getLastModifiedTime() {\n+            return lastModifiedTime;\n+        }\n+\n@@ -1823,1 +1876,1 @@\n-                    infos.add(new StreamedModuleInfoEntry(ename, zis.readAllBytes()));\n+                    infos.add(new StreamedModuleInfoEntry(ename, zis.readAllBytes(), e.getLastModifiedTime()));\n@@ -2036,1 +2089,1 @@\n-    private boolean checkModuleInfo(byte[] moduleInfoBytes, Set<String> entries)\n+    private boolean checkModuleInfo(ModuleInfoEntry moduleInfoEntry, Set<String> entries)\n@@ -2040,1 +2093,1 @@\n-        if (moduleInfoBytes != null) {  \/\/ no root module-info.class if null\n+        if (moduleInfoEntry != null) {  \/\/ no root module-info.class if null\n@@ -2043,1 +2096,1 @@\n-                ModuleDescriptor md = ModuleDescriptor.read(ByteBuffer.wrap(moduleInfoBytes));\n+                ModuleDescriptor md = ModuleDescriptor.read(moduleInfoEntry.bytes());\n@@ -2061,1 +2114,1 @@\n-     * Map values are updated in-place. Returns false if an error occurs.\n+     * Map values are updated in-place.\n@@ -2063,1 +2116,1 @@\n-    private void addExtendedModuleAttributes(Map<String,byte[]> moduleInfos,\n+    private void addExtendedModuleAttributes(Map<String, ModuleInfoEntry> moduleInfos,\n@@ -2067,3 +2120,7 @@\n-        for (Map.Entry<String,byte[]> e: moduleInfos.entrySet()) {\n-            ModuleDescriptor md = ModuleDescriptor.read(ByteBuffer.wrap(e.getValue()));\n-            e.setValue(extendedInfoBytes(md, e.getValue(), packages));\n+        for (Map.Entry<String, ModuleInfoEntry> e: moduleInfos.entrySet()) {\n+            ModuleInfoEntry mie = e.getValue();\n+            byte[] bytes = mie.readAllBytes();\n+            ModuleDescriptor md = ModuleDescriptor.read(ByteBuffer.wrap(bytes));\n+            byte[] extended = extendedInfoBytes(md, bytes, packages);\n+            \/\/ replace the entry value with the extended bytes\n+            e.setValue(new StreamedModuleInfoEntry(mie.name(), extended, mie.getLastModifiedTime()));\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":88,"deletions":31,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -432,1 +432,1 @@\n-                    Text whitespace = Text.of(line.substring(0, idx));\n+                    Text whitespace = Text.of(utils.normalizeNewlines(line.substring(0, idx)));\n@@ -441,1 +441,1 @@\n-                    c = HtmlTree.SPAN(Text.of(sequence));\n+                    c = HtmlTree.SPAN(Text.of(utils.normalizeNewlines(sequence)));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -364,0 +364,3 @@\n+doclet.tag.attribute.value.missing=\\\n+ missing value for attribute \"{0}\"\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.List;\n@@ -34,0 +33,1 @@\n+import java.util.Optional;\n@@ -67,0 +67,32 @@\n+    public enum Language {\n+\n+        JAVA(\"java\"),\n+        PROPERTIES(\"properties\");\n+\n+        private static final Map<String, Language> languages;\n+\n+        static {\n+            Map<String, Language> tmp = new HashMap<>();\n+            for (var language : values()) {\n+                String id = Objects.requireNonNull(language.identifier);\n+                if (tmp.put(id, language) != null)\n+                    throw new IllegalStateException(); \/\/ 1-1 correspondence\n+            }\n+            languages = Map.copyOf(tmp);\n+        }\n+\n+        Language(String id) {\n+            identifier = id;\n+        }\n+\n+        private final String identifier;\n+\n+        public static Optional<Language> of(String identifier) {\n+            if (identifier == null)\n+                return Optional.empty();\n+            return Optional.ofNullable(languages.get(identifier));\n+        }\n+\n+        public String getIdentifier() {return identifier;}\n+    }\n+\n@@ -87,0 +119,39 @@\n+        try {\n+            return generateContent(holder, tag, writer);\n+        } catch (BadSnippetException e) {\n+            error(writer, holder, e.tag(), e.key(), e.args());\n+            return badSnippet(writer);\n+        }\n+    }\n+\n+    private static final class BadSnippetException extends Exception {\n+\n+        @java.io.Serial\n+        private static final long serialVersionUID = 1;\n+\n+        private final transient DocTree tag;\n+        private final String key;\n+        private final transient Object[] args;\n+\n+        BadSnippetException(DocTree tag, String key, Object... args) {\n+            this.tag = tag;\n+            this.key = key;\n+            this.args = args;\n+        }\n+\n+        DocTree tag() {\n+            return tag;\n+        }\n+\n+        String key() {\n+            return key;\n+        }\n+\n+        Object[] args() {\n+            return args;\n+        }\n+    }\n+\n+    private Content generateContent(Element holder, DocTree tag, TagletWriter writer)\n+            throws BadSnippetException\n+    {\n@@ -101,3 +172,2 @@\n-            error(writer, holder, a, \"doclet.tag.attribute.repeated\",\n-                a.getName().toString());\n-            return badSnippet(writer);\n+            throw new BadSnippetException(a, \"doclet.tag.attribute.repeated\",\n+                    a.getName().toString());\n@@ -114,3 +184,2 @@\n-            error(writer, holder, attributes.get(CLASS),\n-                \"doclet.snippet.contents.ambiguity.external\");\n-            return badSnippet(writer);\n+            throw new BadSnippetException(attributes.get(CLASS),\n+                    \"doclet.snippet.contents.ambiguity.external\");\n@@ -118,2 +187,1 @@\n-            error(writer, holder, tag, \"doclet.snippet.contents.none\");\n-            return badSnippet(writer);\n+            throw new BadSnippetException(tag, \"doclet.snippet.contents.none\");\n@@ -125,1 +193,1 @@\n-            regionName = stringOf(region.getValue());\n+            regionName = stringValueOf(region);\n@@ -127,3 +195,2 @@\n-                error(writer, holder, region, \"doclet.tag.attribute.value.illegal\",\n-                    \"region\", region.getValue());\n-                return badSnippet(writer);\n+                throw new BadSnippetException(region, \"doclet.tag.attribute.value.illegal\",\n+                        \"region\", region.getValue());\n@@ -144,2 +211,2 @@\n-                ? stringOf((a = attributes.get(FILE)).getValue())\n-                : stringOf((a = attributes.get(CLASS)).getValue()).replace(\".\", \"\/\") + \".java\";\n+                    ? stringValueOf((a = attributes.get(FILE)))\n+                    : stringValueOf((a = attributes.get(CLASS))).replace(\".\", \"\/\") + \".java\";\n@@ -148,2 +215,2 @@\n-                error(writer, holder, a, \"doclet.tag.attribute.value.illegal\",\n-                    containsFile ? FILE : CLASS, v);\n+                throw new BadSnippetException(a, \"doclet.tag.attribute.value.illegal\",\n+                        containsFile ? FILE : CLASS, v);\n@@ -168,1 +235,1 @@\n-            } catch (IOException | IllegalArgumentException e) {\n+            } catch (IOException | IllegalArgumentException e) { \/\/ TODO: test this when JDK-8276892 is integrated\n@@ -170,2 +237,1 @@\n-                error(writer, holder, a, \"doclet.exception.read.file\", v, e.getCause());\n-                return badSnippet(writer);\n+                throw new BadSnippetException(a, \"doclet.exception.read.file\", v, e.getCause());\n@@ -176,2 +242,1 @@\n-                error(writer, holder, a, \"doclet.File_not_found\", v);\n-                return badSnippet(writer);\n+                throw new BadSnippetException(a, \"doclet.File_not_found\", v);\n@@ -182,4 +247,3 @@\n-            } catch (IOException e) {\n-                error(writer, holder, a, \"doclet.exception.read.file\",\n-                    fileObject.getName(), e.getCause());\n-                return badSnippet(writer);\n+            } catch (IOException e) {  \/\/ TODO: test this when JDK-8276892 is integrated\n+                throw new BadSnippetException(a, \"doclet.exception.read.file\",\n+                        fileObject.getName(), e.getCause());\n@@ -189,0 +253,13 @@\n+        String lang = null;\n+        AttributeTree langAttr = attributes.get(\"lang\");\n+        if (langAttr != null) {\n+            lang = stringValueOf(langAttr);\n+        } else if (containsClass) {\n+            lang = \"java\";\n+        } else if (containsFile) {\n+            lang = languageFromFileName(fileObject.getName());\n+        }\n+\n+        Optional<Language> language = Language.of(lang);\n+\n+\n@@ -196,1 +273,1 @@\n-                inlineSnippet = parse(writer.configuration().getDocResources(), inlineContent);\n+                inlineSnippet = parse(writer.configuration().getDocResources(), language, inlineContent);\n@@ -200,1 +277,1 @@\n-                .getDocTreePath(snippetTag.getBody());\n+                    .getDocTreePath(snippetTag.getBody());\n@@ -203,1 +280,1 @@\n-                .getText(\"doclet.snippet.markup\", e.getMessage());\n+                    .getText(\"doclet.snippet.markup\", e.getMessage());\n@@ -205,1 +282,1 @@\n-                path, e.getPosition(), e.getPosition(), e.getPosition(), msg);\n+                    path, e.getPosition(), e.getPosition(), e.getPosition(), msg);\n@@ -211,1 +288,1 @@\n-                externalSnippet = parse(writer.configuration().getDocResources(), externalContent);\n+                externalSnippet = parse(writer.configuration().getDocResources(), language, externalContent);\n@@ -216,1 +293,1 @@\n-                e.getPosition(), e.getPosition(), \"doclet.snippet.markup\", e.getMessage());\n+                    e.getPosition(), e.getPosition(), \"doclet.snippet.markup\", e.getMessage());\n@@ -238,2 +315,1 @@\n-                error(writer, holder, tag, \"doclet.snippet.region.not_found\", regionName);\n-                return badSnippet(writer);\n+                throw new BadSnippetException(tag, \"doclet.snippet.region.not_found\", regionName);\n@@ -255,3 +331,1 @@\n-                error(writer, holder, tag, \"doclet.snippet.contents.mismatch\", diff(inlineStr, externalStr));\n-                \/\/ output one above the other\n-                return badSnippet(writer);\n+                throw new BadSnippetException(tag, \"doclet.snippet.contents.mismatch\", diff(inlineStr, externalStr));\n@@ -264,9 +338,0 @@\n-        String lang = null;\n-        AttributeTree langAttr = attributes.get(\"lang\");\n-        if (langAttr != null && langAttr.getValueKind() != AttributeTree.ValueKind.EMPTY) {\n-            lang = stringOf(langAttr.getValue());\n-        } else if (containsClass) {\n-            lang = \"java\";\n-        } else if (containsFile) {\n-            lang = languageFromFileName(fileObject.getName());\n-        }\n@@ -274,3 +339,3 @@\n-        String id = idAttr == null || idAttr.getValueKind() == AttributeTree.ValueKind.EMPTY\n-                        ? null\n-                        : stringOf(idAttr.getValue());\n+        String id = idAttr == null\n+                ? null\n+                : stringValueOf(idAttr);\n@@ -301,2 +366,2 @@\n-    private StyledText parse(Resources resources, String content) throws ParseException {\n-        Parser.Result result = new Parser(resources).parse(content);\n+    private StyledText parse(Resources resources, Optional<Language> language, String content) throws ParseException {\n+        Parser.Result result = new Parser(resources).parse(language, content);\n@@ -307,2 +372,6 @@\n-    private static String stringOf(List<? extends DocTree> value) {\n-        return value.stream()\n+    private static String stringValueOf(AttributeTree at) throws BadSnippetException {\n+        if (at.getValueKind() == AttributeTree.ValueKind.EMPTY) {\n+            throw new BadSnippetException(at, \"doclet.tag.attribute.value.missing\",\n+                    at.getName().toString());\n+        }\n+        return at.getValue().stream()\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SnippetTaglet.java","additions":122,"deletions":53,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -61,2 +61,1 @@\n-\/\/ TODO: uncomment \/* sealed *\/ when minimum boot JDK version >= 17\n-public \/* sealed *\/ abstract class Attribute {\n+public abstract class Attribute {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Attribute.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -70,8 +70,0 @@\n-\n-    public int size() {\n-        return attributes.values().stream().mapToInt(List::size).sum();\n-    }\n-\n-    public boolean isEmpty() {\n-        return attributes.isEmpty();\n-    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Attributes.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.taglets.SnippetTaglet;\n@@ -79,4 +80,4 @@\n-    \/\/ next-line tag behaves as if it were specified on the next line\n-\n-    private String eolMarker;\n-    private Matcher markedUpLine;\n+    private static final Pattern JAVA_COMMENT = Pattern.compile(\n+            \"^(?<payload>.*)\/\/(?<markup>\\\\s*@\\\\s*\\\\w+.+?)$\");\n+    private static final Pattern PROPERTIES_COMMENT = Pattern.compile(\n+            \"^(?<payload>[ \\t]*([#!].*)?)[#!](?<markup>\\\\s*@\\\\s*\\\\w+.+?)$\");\n@@ -96,2 +97,7 @@\n-    public Result parse(String source) throws ParseException {\n-        return parse(\"\/\/\", source);\n+    public Result parse(Optional<SnippetTaglet.Language> language, String source) throws ParseException {\n+        SnippetTaglet.Language lang = language.orElse(SnippetTaglet.Language.JAVA);\n+        var p = switch (lang) {\n+            case JAVA -> JAVA_COMMENT;\n+            case PROPERTIES -> PROPERTIES_COMMENT;\n+        };\n+        return parse(p, source);\n@@ -103,2 +109,2 @@\n-    public Result parse(String eolMarker, String source) throws ParseException {\n-        Objects.requireNonNull(eolMarker);\n+    private Result parse(Pattern commentPattern, String source) throws ParseException {\n+        Objects.requireNonNull(commentPattern);\n@@ -106,16 +112,2 @@\n-        if (!Objects.equals(eolMarker, this.eolMarker)) {\n-            if (eolMarker.length() < 1) {\n-                throw new IllegalArgumentException();\n-            }\n-            for (int i = 0; i < eolMarker.length(); i++) {\n-                switch (eolMarker.charAt(i)) {\n-                    case '\\f', '\\n', '\\r' -> throw new IllegalArgumentException();\n-                }\n-            }\n-            this.eolMarker = eolMarker;\n-            \/\/ capture the rightmost eolMarker (e.g. \"\/\/\")\n-            \/\/ The below Pattern.compile should never throw PatternSyntaxException\n-            Pattern pattern = Pattern.compile(\"^(.*)(\" + Pattern.quote(eolMarker)\n-                    + \"(\\\\s*@\\\\s*\\\\w+.+?))$\");\n-            this.markedUpLine = pattern.matcher(\"\"); \/\/ reusable matcher\n-        }\n+\n+        Matcher markedUpLine = commentPattern.matcher(\"\"); \/\/ reusable matcher\n@@ -154,2 +146,2 @@\n-                String maybeMarkup = markedUpLine.group(3);\n-                List<Tag> parsedTags = null;\n+                String maybeMarkup = rawLine.substring(markedUpLine.start(\"markup\"));\n+                List<Tag> parsedTags;\n@@ -159,2 +151,2 @@\n-                    \/\/ adjust index\n-                    throw new ParseException(e::getMessage, markedUpLine.start(3) + e.getPosition());\n+                    \/\/ translate error position from markup to file line\n+                    throw new ParseException(e::getMessage, markedUpLine.start(\"markup\") + e.getPosition());\n@@ -163,2 +155,2 @@\n-                    t.lineSourceOffset = next.offset;\n-                    t.markupLineOffset = markedUpLine.start(3);\n+                    t.lineSourceOffset = next.offset();\n+                    t.markupLineOffset = markedUpLine.start(\"markup\");\n@@ -179,1 +171,1 @@\n-                    String payload = markedUpLine.group(1);\n+                    String payload = rawLine.substring(0, markedUpLine.end(\"payload\"));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Parser.java","additions":23,"deletions":31,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-        int off = 0; \/\/ offset because of the replacements (can be negative)\n+        int off = 0; \/\/ cumulative offset caused by replacements (can become negative)\n@@ -82,1 +82,1 @@\n-            text.subText(r.start, r.end).replace(Set.of(), r.value);\n+            text.subText(r.start(), r.end()).replace(Set.of(), r.value());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Replace.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,2 +36,1 @@\n-\/\/ TODO: uncomment \/* sealed *\/ when minimum boot JDK version >= 17\n-public \/* sealed *\/ interface Style {\n+public sealed interface Style {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Style.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -359,1 +359,2 @@\n-                if (jarfile.isMultiRelease()) {\n+                \/\/ exclude module-info.class since this jarFile is on classpath\n+                if (jarfile.isMultiRelease() && !cf.getName().equals(\"module-info\")) {\n@@ -440,1 +441,0 @@\n-    private static final String MODULE_INFO = \"module-info.class\";\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/ClassFileReader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -271,1 +271,8 @@\n-            throw new Error(e);\n+            Throwable cause = e.getCause();\n+            if (cause instanceof RuntimeException x) {\n+                throw x;\n+            } else if (cause instanceof Error x) {\n+                throw x;\n+            } else {\n+                throw new Error(e);\n+            }\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/DependencyFinder.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        super();\n+        super(JdepsTask.getMessage(key, params));\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/MultiReleaseException.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,9 +58,4 @@\n-                if (nameToVersion.containsKey(name)) {\n-                    if (!version.equals(nameToVersion.get(name))) {\n-                        throw new MultiReleaseException(\n-                                \"err.multirelease.version.associated\",\n-                                name, nameToVersion.get(name), version\n-                        );\n-                    }\n-                } else {\n-                    nameToVersion.put(name, version);\n+                String v = nameToVersion.computeIfAbsent(name, _n -> version);\n+                if (!version.equals(v)) {\n+                    throw new MultiReleaseException(\"err.multirelease.version.associated\",\n+                                name, nameToVersion.get(name), version);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/VersionHelper.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -778,0 +778,5 @@\n+    <event name=\"jdk.ZThreadDebug\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"threshold\">0 ms<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -778,0 +778,5 @@\n+    <event name=\"jdk.ZThreadDebug\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"threshold\">0 ms<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -285,1 +285,1 @@\n-    private class LastPoolManager extends ResourcePoolManager {\n+    private static class LastPoolManager extends ResourcePoolManager {\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImagePluginStack.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-    class ResourcePoolModuleImpl implements ResourcePoolModule {\n+    static class ResourcePoolModuleImpl implements ResourcePoolModule {\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ResourcePoolManager.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -480,1 +480,1 @@\n-        class ModuleInfoRewriter extends ByteArrayOutputStream {\n+        static class ModuleInfoRewriter extends ByteArrayOutputStream {\n@@ -628,1 +628,1 @@\n-         * Generate byteccode for no-arg constructor\n+         * Generate bytecode for no-arg constructor\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -770,0 +770,4 @@\n+            \/\/ Keep a sorted set of files to be processed, so that the jmod\n+            \/\/ content is reproducible as Files.walkFileTree order is not defined\n+            SortedMap<String, Path> filesToProcess = new TreeMap<String, Path>();\n+\n@@ -785,3 +789,1 @@\n-                                try (InputStream in = Files.newInputStream(file)) {\n-                                    out.writeEntry(in, section, name);\n-                                }\n+                                filesToProcess.put(name, file);\n@@ -793,0 +795,9 @@\n+\n+            \/\/ Process files in sorted order for deterministic jmod content\n+            for (Map.Entry<String, Path> entry : filesToProcess.entrySet()) {\n+                String name = entry.getKey();\n+                Path   file = entry.getValue();\n+                try (InputStream in = Files.newInputStream(file)) {\n+                    out.writeEntry(in, section, name);\n+                }\n+            }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jmod\/JmodTask.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-        try (InputStream resource = getResourceAsStream(\"libjpackageapplauncher.so\")) {\n+        try (InputStream resource = getResourceAsStream(\"libjpackageapplauncheraux.so\")) {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxAppImageBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -277,0 +277,1 @@\n+        ENABLE_NATIVE_ACCESS(\"--enable-native-access\", true, true, false, true, true),\n@@ -366,0 +367,1 @@\n+        private final OptionSpecBuilder  argEnableNativeAccess = parser.accepts(\"enable-native-access\");\n@@ -474,0 +476,4 @@\n+            if (options.has(argEnableNativeAccess)) {\n+                opts.addAll(OptionKind.ENABLE_NATIVE_ACCESS, List.of(\n+                        OptionKind.ENABLE_NATIVE_ACCESS.optionFlag, \"ALL-UNNAMED\"));\n+            }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/JShellTool.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -210,0 +210,2 @@\n+\\    --enable-native-access\\n\\\n+\\                          Allow code to run restricted native methods\\n\\\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/resources\/l10n.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"services\/memTracker.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"unittest.hpp\"\n+#include \"testutils.hpp\"\n+\n+#if INCLUDE_NMT\n+\n+\/\/ This prefix shows up on any c heap corruption NMT detects. If unsure which assert will\n+\/\/ come, just use this one.\n+#define COMMON_NMT_HEAP_CORRUPTION_MESSAGE_PREFIX \"NMT corruption\"\n+\n+\n+\n+#define DEFINE_TEST(test_function, expected_assertion_message)                            \\\n+  TEST_VM_FATAL_ERROR_MSG(NMT, test_function, \".*\" expected_assertion_message \".*\") {     \\\n+    if (MemTracker::tracking_level() > NMT_off) {                                         \\\n+      tty->print_cr(\"NMT overwrite death test, please ignore subsequent error dump.\");    \\\n+      test_function ();                                                                   \\\n+    } else {                                                                              \\\n+      \/* overflow detection requires NMT to be on. If off, fake assert. *\/                \\\n+      guarantee(false,                                                                    \\\n+                \"fake message ignore this - \" expected_assertion_message);                \\\n+    }                                                                                     \\\n+  }\n+\n+\/\/\/\/\/\/\/\n+\n+static void test_overwrite_front() {\n+  address p = (address) os::malloc(1, mtTest);\n+  *(p - 1) = 'a';\n+  os::free(p);\n+}\n+\n+DEFINE_TEST(test_overwrite_front, \"header canary broken\")\n+\n+\/\/\/\/\/\/\/\n+\n+static void test_overwrite_back() {\n+  address p = (address) os::malloc(1, mtTest);\n+  *(p + 1) = 'a';\n+  os::free(p);\n+}\n+\n+DEFINE_TEST(test_overwrite_back, \"footer canary broken\")\n+\n+\/\/\/\/\/\/\/\n+\n+\/\/ A overwrite farther away from the NMT header; the report should show the hex dump split up\n+\/\/ in two parts, containing both header and corruption site.\n+static void test_overwrite_back_long(size_t distance) {\n+  address p = (address) os::malloc(distance, mtTest);\n+  *(p + distance) = 'a';\n+  os::free(p);\n+}\n+static void test_overwrite_back_long_aligned_distance()   { test_overwrite_back_long(0x2000); }\n+DEFINE_TEST(test_overwrite_back_long_aligned_distance, \"footer canary broken\")\n+static void test_overwrite_back_long_unaligned_distance() { test_overwrite_back_long(0x2001); }\n+DEFINE_TEST(test_overwrite_back_long_unaligned_distance, \"footer canary broken\")\n+\n+\/\/\/\/\/\/\/\n+\n+static void test_double_free() {\n+  address p = (address) os::malloc(1, mtTest);\n+  os::free(p);\n+  \/\/ Now a double free. Note that this is susceptible to concurrency issues should\n+  \/\/ a concurrent thread have done a malloc and gotten the same address after the\n+  \/\/ first free. To decrease chance of this happening, we repeat the double free\n+  \/\/ several times.\n+  for (int i = 0; i < 100; i ++) {\n+    os::free(p);\n+  }\n+}\n+\n+\/\/ What assertion message we will see depends on whether the VM wipes the memory-to-be-freed\n+\/\/ on the first free(), and whether the libc uses the freed memory to store bookkeeping information.\n+\/\/ If the death marker in the header is still intact after the first free, we will recognize this as\n+\/\/ double free; if it got wiped, we should at least see a broken header canary.\n+\/\/ The message would be either\n+\/\/ - \"header canary broken\" or\n+\/\/ - \"header canary dead (double free?)\".\n+\/\/ However, since gtest regex expressions do not support unions (a|b), I search for a reasonable\n+\/\/ subset here.\n+DEFINE_TEST(test_double_free, \"header canary\")\n+\n+\/\/\/\/\/\/\/\n+\n+static void test_invalid_block_address() {\n+  \/\/ very low, like the result of an overflow or of accessing a NULL this pointer\n+  os::free((void*)0x100);\n+}\n+DEFINE_TEST(test_invalid_block_address, \"invalid block address\")\n+\n+\/\/\/\/\/\/\/\n+\n+static void test_unaliged_block_address() {\n+  address p = (address) os::malloc(1, mtTest);\n+  os::free(p + 6);\n+}\n+DEFINE_TEST(test_unaliged_block_address, \"block address is unaligned\");\n+\n+\/\/\/\/\/\/\/\n+\n+\/\/ Test that we notice block corruption on realloc too\n+static void test_corruption_on_realloc(size_t s1, size_t s2) {\n+  address p1 = (address) os::malloc(s1, mtTest);\n+  *(p1 + s1) = 'a';\n+  address p2 = (address) os::realloc(p1, s2, mtTest);\n+\n+  \/\/ Still here?\n+  tty->print_cr(\"NMT did not detect corruption on os::realloc?\");\n+  \/\/ Note: don't use ASSERT here, that does not work as expected in death tests. Just\n+  \/\/ let the test run its course, it should notice something is amiss.\n+}\n+static void test_corruption_on_realloc_growing()    { test_corruption_on_realloc(0x10, 0x11); }\n+DEFINE_TEST(test_corruption_on_realloc_growing, COMMON_NMT_HEAP_CORRUPTION_MESSAGE_PREFIX);\n+static void test_corruption_on_realloc_shrinking()  { test_corruption_on_realloc(0x11, 0x10); }\n+DEFINE_TEST(test_corruption_on_realloc_shrinking, COMMON_NMT_HEAP_CORRUPTION_MESSAGE_PREFIX);\n+\n+\/\/\/\/\/\/\/\n+\n+\/\/ realloc is the trickiest of the bunch. Test that realloc works and correctly takes over\n+\/\/ NMT header and footer to the resized block. We just test that nothing crashes - if the\n+\/\/ header\/footer get corrupted, NMT heap corruption checker will trigger alert on os::free()).\n+TEST_VM(NMT, test_realloc) {\n+  \/\/ We test both directions (growing and shrinking) and a small range for each to cover all\n+  \/\/ size alignment variants. Should not matter, but this should be cheap.\n+  for (size_t s1 = 0xF0; s1 < 0x110; s1 ++) {\n+    for (size_t s2 = 0x100; s2 > 0xF0; s2 --) {\n+      address p1 = (address) os::malloc(s1, mtTest);\n+      ASSERT_NOT_NULL(p1);\n+      GtestUtils::mark_range(p1, s1);       \/\/ mark payload range...\n+      address p2 = (address) os::realloc(p1, s2, mtTest);\n+      ASSERT_NOT_NULL(p2);\n+      ASSERT_RANGE_IS_MARKED(p2, MIN2(s1, s2))        \/\/ ... and check that it survived the resize\n+         << s1 << \"->\" << s2 << std::endl;\n+      os::free(p2);                         \/\/ <- if NMT headers\/footers got corrupted this asserts\n+    }\n+  }\n+}\n+\n+#endif \/\/ INCLUDE_NMT\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_buffer_overflow_detection.cpp","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -60,1 +60,2 @@\n-    tty->print_cr(\"wrong pattern around \" PTR_FORMAT, p2i(first_wrong));\n+    tty->print_cr(\"check_range [\" PTR_FORMAT \"..\" PTR_FORMAT \"), 0x%X, : wrong pattern around \" PTR_FORMAT,\n+                  p2i(p), p2i(p) + s, expected, p2i(first_wrong));\n","filename":"test\/hotspot\/gtest\/testutils.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-#define ASSERT_NOT_NULL(p)  ASSERT_NE(p, (char*)NULL)\n-#define ASSERT_NULL(p)      ASSERT_EQ(p, (char*)NULL)\n+#define ASSERT_NOT_NULL(p)  ASSERT_NE(p2i(p), 0)\n+#define ASSERT_NULL(p)      ASSERT_EQ(p2i(p), 0)\n","filename":"test\/hotspot\/gtest\/testutils.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -152,0 +152,17 @@\n+#define TEST_VM_FATAL_ERROR_MSG(category, name, msg)                \\\n+  static void test_  ## category ## _ ## name ## _();               \\\n+                                                                    \\\n+  static void child_ ## category ## _ ## name ## _() {              \\\n+    ::testing::GTEST_FLAG(throw_on_failure) = true;                 \\\n+    test_ ## category ## _ ## name ## _();                          \\\n+    exit(0);                                                        \\\n+  }                                                                 \\\n+                                                                    \\\n+  TEST(category, CONCAT(name, _vm_assert)) {                        \\\n+    ASSERT_EXIT(child_ ## category ## _ ## name ## _(),             \\\n+                ::testing::ExitedWithCode(1),                       \\\n+                msg);                            \\\n+  }                                                                 \\\n+                                                                    \\\n+  void test_ ## category ## _ ## name ## _()\n+\n","filename":"test\/hotspot\/gtest\/unittest.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-vmTestbase\/vm\/mlvm\/hiddenloader\/stress\/oome\/heap\/Test.java 8273095 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,3 +41,0 @@\n-vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach002a\/TestDescription.java 8265795 generic-all\n-vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach022\/TestDescription.java 8265795 generic-all\n-vmTestbase\/nsk\/jdi\/ObjectReference\/referringObjects\/referringObjects002\/referringObjects002.java 8265796  generic-all\n@@ -95,0 +92,2 @@\n+applications\/jcstress\/acqrel.java 8277434 linux-aarch64\n+\n@@ -108,1 +107,1 @@\n-runtime\/jni\/checked\/TestPrimitiveArrayCriticalWithBadParam.java 8277350 macosx-x64\n+runtime\/ErrorHandling\/CreateCoredumpOnCrash.java 8267433 macosx-x64\n@@ -153,0 +152,1 @@\n+vmTestbase\/nsk\/jdi\/TypeComponent\/isSynthetic\/issynthetic001\/TestDescription.java 8277803 generic-all\n@@ -163,2 +163,1 @@\n-vmTestbase\/nsk\/jvmti\/SuspendThread\/suspendthrd003\/TestDescription.java 8264605 generic-all\n-vmTestbase\/nsk\/jvmti\/PopFrame\/popframe011\/TestDescription.java 8266593 generic-all\n+vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach002a\/TestDescription.java 8277812 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,2 +27,7 @@\n-import java.io.IOException;\n-import java.io.File;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.util.CoreUtils;\n+\n@@ -30,0 +35,1 @@\n+import java.io.File;\n@@ -31,0 +37,1 @@\n+import java.io.IOException;\n@@ -39,8 +46,0 @@\n-import java.util.regex.Pattern;\n-import java.util.regex.Matcher;\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.util.CoreUtils;\n@@ -299,0 +298,37 @@\n+\n+    protected void removeVersionFromReplayFile() {\n+        setNewVersionLineInReplayFile(null);\n+    }\n+\n+    protected void setNewVersionInReplayFile(int newVersionNumber) {\n+        setNewVersionLineInReplayFile(\"version \" + newVersionNumber);\n+    }\n+\n+    private void setNewVersionLineInReplayFile(String firstLineString) {\n+        List<String> newLines = new ArrayList<>();\n+        Path replayFilePath = Paths.get(getReplayFileName());\n+        try (var br = Files.newBufferedReader(replayFilePath)) {\n+            String line;\n+            boolean firstLine = true;\n+            while ((line = br.readLine()) != null) {\n+                if (firstLine) {\n+                    firstLine = false;\n+                    Asserts.assertTrue(line.startsWith(\"version\"), \"version number must exist in a proper replay file\");\n+                    if (firstLineString != null) {\n+                        newLines.add(firstLineString);\n+                    }\n+                    \/\/ Else: Remove first line by skipping it.\n+                } else {\n+                    newLines.add(line);\n+                }\n+            }\n+            Asserts.assertFalse(firstLine, replayFilePath + \" should not be empty\");\n+        } catch (IOException e) {\n+            throw new Error(\"Failed to read replay data: \" + e, e);\n+        }\n+        try {\n+            Files.write(replayFilePath, newLines, StandardOpenOption.TRUNCATE_EXISTING);\n+        } catch (IOException e) {\n+            throw new Error(\"Failed to write replay data: \" + e, e);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/CiReplayBase.java","additions":46,"deletions":10,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.ciReplay;\n+\n+import jdk.test.lib.Asserts;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public abstract class InliningBase extends DumpReplayBase {\n+    public static final String LOG_FILE_NORMAL = \"hotspot_normal.log\";\n+    public static final String LOG_FILE_REPLAY = \"hotspot_replay.log\";\n+    protected final String[] commandLineReplay;\n+    protected final List<String> commandLineNormal;\n+    protected final Class<?> testClass;\n+\n+    protected InliningBase(Class<?> testClass) {\n+        this.testClass = testClass;\n+        commandLineNormal = new ArrayList<>(List.of(\"-XX:LogFile=\" + LOG_FILE_NORMAL + \"\", \"-XX:+LogCompilation\", \"-XX:-TieredCompilation\",\n+                                                                 \"-XX:CompileCommand=exclude,\" + testClass.getName() + \"::main\",\n+                                                                 \"-XX:CompileCommand=option,\" + testClass.getName() + \"::test,bool,PrintInlining,true\"));\n+        commandLineReplay = new String[]\n+                {\"-XX:LogFile=\" + LOG_FILE_REPLAY, \"-XX:+LogCompilation\",\n+                 \"-XX:CompileCommand=option,\" + testClass.getName()  + \"::test,bool,PrintInlining,true\"};\n+    }\n+\n+    protected void runTest() {\n+        runTest(commandLineNormal.toArray(new String[0]));\n+    }\n+\n+    @Override\n+    public String getTestClass() {\n+        return testClass.getName();\n+    }\n+\n+    @Override\n+    public void cleanup() {\n+        super.cleanup();\n+        remove(LOG_FILE_NORMAL);\n+        remove(LOG_FILE_REPLAY);\n+    }\n+\n+    static class InlineEntry {\n+        String klass;\n+        String method;\n+        String reason;\n+\n+        public InlineEntry(String klass, String method, String reason) {\n+            this.klass = klass;\n+            this.method = method;\n+            this.reason = reason;\n+        }\n+\n+        public boolean isNormalInline() {\n+            return reason.equals(\"inline (hot)\");\n+        }\n+\n+        public boolean isForcedByReplay() {\n+            return reason.equals(\"force inline by ciReplay\");\n+        }\n+\n+        public boolean isDisallowedByReplay() {\n+            return reason.equals(\"disallowed by ciReplay\");\n+        }\n+\n+        public boolean isUnloadedSignatureClasses() {\n+            return reason.equals(\"unloaded signature classes\");\n+        }\n+\n+        public boolean isForcedIncrementalInlineByReplay() {\n+            return reason.equals(\"force (incremental) inline by ciReplay\");\n+        }\n+\n+        public boolean isForcedInline() {\n+            return reason.equals(\"force inline by annotation\");\n+        }\n+\n+        public boolean isTooDeep() {\n+            return reason.equals(\"inlining too deep\");\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (other == this) {\n+                return true;\n+            }\n+\n+            if (!(other instanceof InlineEntry)) {\n+                return false;\n+            }\n+\n+            InlineEntry e = (InlineEntry)other;\n+            return klass.equals(e.klass) && method.equals(e.method);\n+        }\n+\n+        public boolean compare(String klass, String method, boolean kind) {\n+            return this.klass.equals(klass) && this.method.equals(method) && kind;\n+        }\n+    }\n+\n+    protected static List<InlineEntry> parseLogFile(String logFile, String rootMethod, String nmethodMatch, int inlineeCount) {\n+        String nmethodStart = \"<nmethod\";\n+        List<InlineEntry> inlinees = new ArrayList<>();\n+        int foundLines = 0;\n+        try (var br = Files.newBufferedReader(Paths.get(logFile))) {\n+            String line;\n+            boolean nmethodLine = false;\n+            boolean inlinineLine = false;\n+            while ((line = br.readLine()) != null) {\n+                if (nmethodLine) {\n+                    \/\/ Ignore other entries which could be in between nmethod entry and inlining statements\n+                    if (line.startsWith(\"             \")) {\n+                        inlinineLine = true;\n+                        Pattern p = Pattern.compile(\"(\\\\S+)::(\\\\S+).*bytes\\\\)\\s+(.*)\");\n+                        Matcher matcher = p.matcher(line);\n+                        Asserts.assertTrue(matcher.find(), \"must find inlinee method\");\n+                        inlinees.add(new InlineEntry(matcher.group(1), matcher.group(2), matcher.group(3).trim()));\n+                        foundLines++;\n+                    } else if (inlinineLine) {\n+                        Asserts.assertEQ(foundLines, inlineeCount, \"did not find all inlinees\");\n+                        return inlinees;\n+                    }\n+                } else {\n+                    nmethodLine = line.startsWith(nmethodStart) && line.contains(nmethodMatch);\n+                    if (nmethodLine) {\n+                        Asserts.assertTrue(line.contains(rootMethod), \"should only dump inline information for \" + rootMethod);\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new Error(\"Failed to read \" + logFile + \" data: \" + e, e);\n+        }\n+        Asserts.fail(\"Should have found inlinees\");\n+        return inlinees;\n+    }\n+\n+    protected void verifyLists(List<InlineEntry> inlineesNormal, List<InlineEntry> inlineesReplay, int expectedSize) {\n+        if (!inlineesNormal.equals(inlineesReplay)) {\n+            System.err.println(\"Normal entries:\");\n+            inlineesNormal.forEach(System.err::println);\n+            System.err.println(\"Replay entries:\");\n+            inlineesReplay.forEach(System.err::println);\n+            Asserts.fail(\"different inlining decision in normal run vs. replay run\");\n+        }\n+        Asserts.assertEQ(expectedSize, inlineesNormal.size(), \"unexpected number of inlinees found\");\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/InliningBase.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8254108\n+ * @library \/ \/test\/lib\n+ * @summary Testing of ciReplay with incremental inlining.\n+ * @requires vm.flightRecorder != true & vm.compMode != \"Xint\" & vm.compMode != \"Xcomp\" & vm.debug == true & vm.compiler2.enabled\n+ * @modules java.base\/jdk.internal.misc\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      compiler.ciReplay.TestIncrementalInlining\n+ *\/\n+\n+package compiler.ciReplay;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class TestIncrementalInlining extends InliningBase {\n+\n+    private List<InlineEntry> inlineesNormal;\n+    private List<InlineEntry> inlineesReplay;\n+    public static void main(String[] args) {\n+        new TestIncrementalInlining();\n+    }\n+\n+    TestIncrementalInlining() {\n+        super(IncrementalInliningTest.class);\n+        \/\/ Enable Whitebox access for test VM.\n+        commandLineNormal.add(\"-Dtest.jdk=\" + Utils.TEST_JDK);\n+        commandLineNormal.add(\"-cp\");\n+        commandLineNormal.add(Utils.TEST_CLASS_PATH);\n+        commandLineNormal.add(\"-Xbootclasspath\/a:.\");\n+        commandLineNormal.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        commandLineNormal.add(\"-XX:+WhiteBoxAPI\");\n+        commandLineNormal.add(\"-XX:MaxInlineLevel=2\");\n+        commandLineNormal.add(\"-XX:-AlwaysIncrementalInline\");\n+        runTest();\n+    }\n+\n+    @Override\n+    public void testAction() {\n+        positiveTest(commandLineReplay);\n+        inlineesNormal = parseLogFile(LOG_FILE_NORMAL, getTestClass() + \" \" + \"test\", \"compile_id='\" + getCompileIdFromFile(getReplayFileName()), 5);\n+        verify(true);\n+\n+        \/\/ Incremental inlining is supported in version 2+\n+        \/\/ Test replay file version 1.\n+        removeIncrementalInlineInfo();\n+        setNewVersionInReplayFile(1);\n+        positiveTest(commandLineReplay);\n+        verify(false);\n+\n+        \/\/ Test replay file without version.\n+        removeVersionFromReplayFile();\n+        positiveTest(commandLineReplay);\n+        verify(false);\n+    }\n+\n+    private void verify(boolean isNewFormat) {\n+        inlineesReplay = parseLogFile(LOG_FILE_REPLAY, getTestClass() + \" \" + \"test\", \"test ()V\", 5);\n+        verifyLists(inlineesNormal, inlineesReplay, 5);\n+        checkInlining(isNewFormat);\n+    }\n+\n+    \/\/ Check if inlining is done correctly in ciReplay.\n+    private void checkInlining(boolean isNewFormat) {\n+        String klass = getTestClass();\n+        Asserts.assertTrue(inlineesNormal.get(0).compare(klass, \"level0\", inlineesNormal.get(0).isForcedInline()));\n+        Asserts.assertTrue(inlineesReplay.get(0).compare(klass, \"level0\", inlineesReplay.get(0).isForcedByReplay()));\n+        Asserts.assertTrue(inlineesNormal.get(1).compare(klass, \"level1\", inlineesNormal.get(1).isNormalInline()));\n+        Asserts.assertTrue(inlineesReplay.get(1).compare(klass, \"level1\", inlineesReplay.get(1).isForcedByReplay()));\n+        Asserts.assertTrue(inlineesNormal.get(2).compare(klass, \"level2\", inlineesNormal.get(2).isForcedInline()));\n+        Asserts.assertTrue(inlineesReplay.get(2).compare(klass, \"level2\", inlineesReplay.get(2).isForcedByReplay()));\n+        Asserts.assertTrue(inlineesNormal.get(3).compare(klass, \"late\", inlineesNormal.get(3).isForcedInline()));\n+        Asserts.assertTrue(inlineesReplay.get(3).compare(klass, \"late\", isNewFormat ?\n+                inlineesReplay.get(3).isForcedIncrementalInlineByReplay()\n+                : inlineesReplay.get(3).isForcedByReplay()));\n+        Asserts.assertTrue(inlineesNormal.get(4).compare(klass, \"level4\", inlineesNormal.get(4).isTooDeep()));\n+        Asserts.assertTrue(inlineesReplay.get(4).compare(klass, \"level4\", inlineesReplay.get(4).isDisallowedByReplay()));\n+    }\n+\n+    private void removeIncrementalInlineInfo() {\n+        try {\n+            Path replayFilePath = Paths.get(getReplayFileName());\n+            List<String> replayContent = Files.readAllLines(replayFilePath);\n+            for (int i = 0; i < replayContent.size(); i++) {\n+                String line = replayContent.get(i);\n+                if (line.startsWith(\"compile \")) {\n+                    int lastIndex = 0;\n+                    StringBuilder newLine = new StringBuilder();\n+                    Pattern p = Pattern.compile(\"(\\\\d (-?\\\\d)) \\\\d compiler\");\n+                    Matcher m = p.matcher(line);\n+                    boolean firstMatch = true;\n+                    while (m.find()) {\n+                        newLine.append(line, lastIndex, m.start())\n+                              .append(m.group(1))\n+                              .append(\" compiler\");\n+                        lastIndex = m.end();\n+                        String bci = m.group(2);\n+                        Asserts.assertTrue(firstMatch ? bci.equals(\"-1\") : bci.equals(\"0\"), \"only root has -1\");\n+                        firstMatch = false;\n+                    }\n+                    Asserts.assertLessThan(lastIndex, line.length(), \"not reached end of line, yet\");\n+                    newLine.append(line, lastIndex, line.length());\n+                    replayContent.set(i, newLine.toString());\n+                }\n+            }\n+            Files.write(replayFilePath, replayContent, StandardOpenOption.TRUNCATE_EXISTING);\n+        } catch (IOException ioe) {\n+            throw new Error(\"Failed to read\/write replay data: \" + ioe, ioe);\n+        }\n+    }\n+}\n+\n+class IncrementalInliningTest {\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    private static String s;\n+\n+    public static void main(String[] args) throws NoSuchMethodException {\n+        WB.testSetForceInlineMethod(IncrementalInliningTest.class.getDeclaredMethod(\"level0\"), true);\n+        WB.testSetForceInlineMethod(IncrementalInliningTest.class.getDeclaredMethod(\"level2\"), true);\n+        WB.testSetForceInlineMethod(IncrementalInliningTest.class.getDeclaredMethod(\"late\"), true);\n+        for (int i = 0; i < 10000; i++) {\n+            test();\n+        }\n+    }\n+\n+    private static void test() {\n+        level0();\n+    }\n+\n+    public static void level0() {\n+        level1();\n+    }\n+\n+    public static void level1() {\n+        level2();\n+    }\n+\n+    public static void level2() {\n+        late();\n+    }\n+\n+    \/\/ Reached max inline level but forced to be inlined -> inline late.\n+    public static void late() {\n+        level4();\n+    }\n+\n+    \/\/ Reached max inline level and not forced to be inlined -> no inline.\n+    public static void level4() {\n+        s = \"HelloWorld\";\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/TestIncrementalInlining.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -31,4 +31,1 @@\n- * @build sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *      compiler.ciReplay.TestInliningProtectionDomain\n+ * @run driver compiler.ciReplay.TestInliningProtectionDomain\n@@ -41,4 +38,0 @@\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.util.ArrayList;\n@@ -46,2 +39,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -49,6 +40,1 @@\n-public class TestInliningProtectionDomain extends DumpReplayBase {\n-    public static final String LOG_FILE_NORMAL = \"hotspot_normal.log\";\n-    public static final String LOG_FILE_REPLAY = \"hotspot_replay.log\";\n-    private final String[] commandLineReplay;\n-\n-    private final String className;\n+public class TestInliningProtectionDomain extends InliningBase {\n@@ -57,4 +43,4 @@\n-        new TestInliningProtectionDomain(\"ProtectionDomainTestCompiledBefore\", true);\n-        new TestInliningProtectionDomain(\"ProtectionDomainTestNoOtherCompilationPublic\", false);\n-        new TestInliningProtectionDomain(\"ProtectionDomainTestNoOtherCompilationPrivate\", false);\n-        new TestInliningProtectionDomain(\"ProtectionDomainTestNoOtherCompilationPrivateString\", false);\n+        new TestInliningProtectionDomain(ProtectionDomainTestCompiledBefore.class, true);\n+        new TestInliningProtectionDomain(ProtectionDomainTestNoOtherCompilationPublic.class, false);\n+        new TestInliningProtectionDomain(ProtectionDomainTestNoOtherCompilationPrivate.class, false);\n+        new TestInliningProtectionDomain(ProtectionDomainTestNoOtherCompilationPrivateString.class, false);\n@@ -63,5 +49,2 @@\n-    public TestInliningProtectionDomain(String className, boolean compileBar) {\n-        this.className = className;\n-        List<String> commandLineNormal = new ArrayList<>(List.of(\"-XX:LogFile=\" + LOG_FILE_NORMAL + \"\", \"-XX:+LogCompilation\", \"-XX:-TieredCompilation\",\n-                                                           \"-XX:CompileCommand=exclude,\" + getTestClass() + \"::main\",\n-                                                           \"-XX:CompileCommand=option,\" + getTestClass()  + \"::test,bool,PrintInlining,true\"));\n+    public TestInliningProtectionDomain(Class<?> testClass, boolean compileBar) {\n+        super(testClass);\n@@ -69,1 +52,1 @@\n-            commandLineNormal.add(\"-XX:CompileCommand=compileonly,\" + getTestClass() + \"::bar\");\n+            commandLineNormal.add(\"-XX:CompileCommand=compileonly,\" + testClass.getName() + \"::bar\");\n@@ -71,4 +54,1 @@\n-        commandLineReplay = new String[]\n-                {\"-XX:LogFile=\" + LOG_FILE_REPLAY + \"\", \"-XX:+LogCompilation\",\n-                 \"-XX:CompileCommand=option,\" + getTestClass()  + \"::test,bool,PrintInlining,true\"};\n-        runTest(commandLineNormal.toArray(new String[0]));\n+        runTest();\n@@ -80,3 +60,2 @@\n-        String klass = \"compiler.ciReplay.\" + className;\n-        String entryString = klass + \" \" + \"test\";\n-        boolean inlineFails = className.equals(\"ProtectionDomainTestNoOtherCompilationPrivate\");\n+        String entryString = getTestClass() + \" \" + \"test\";\n+        boolean inlineFails = testClass == ProtectionDomainTestNoOtherCompilationPrivate.class;\n@@ -85,2 +64,2 @@\n-        List<Entry> inlineesNormal = parseLogFile(LOG_FILE_NORMAL, entryString, \"compile_id='\" + getCompileIdFromFile(getReplayFileName()), inlineeCount);\n-        List<Entry> inlineesReplay = parseLogFile(LOG_FILE_REPLAY, entryString, \"test ()V\", inlineeCount);\n+        List<InlineEntry> inlineesNormal = parseLogFile(LOG_FILE_NORMAL, entryString, \"compile_id='\" + getCompileIdFromFile(getReplayFileName()), inlineeCount);\n+        List<InlineEntry> inlineesReplay = parseLogFile(LOG_FILE_REPLAY, entryString, \"test ()V\", inlineeCount);\n@@ -90,4 +69,2 @@\n-            Asserts.assertTrue(compare(inlineesNormal.get(0), \"compiler.ciReplay.ProtectionDomainTestNoOtherCompilationPrivate\",\n-                                       \"bar\", inlineesNormal.get(0).isUnloadedSignatureClasses()));\n-            Asserts.assertTrue(compare(inlineesReplay.get(0), \"compiler.ciReplay.ProtectionDomainTestNoOtherCompilationPrivate\",\n-                                       \"bar\", inlineesReplay.get(0).isDisallowedByReplay()));\n+            Asserts.assertTrue(inlineesNormal.get(0).compare(\"compiler.ciReplay.ProtectionDomainTestNoOtherCompilationPrivate\", \"bar\", inlineesNormal.get(0).isUnloadedSignatureClasses()));\n+            Asserts.assertTrue(inlineesReplay.get(0).compare(\"compiler.ciReplay.ProtectionDomainTestNoOtherCompilationPrivate\", \"bar\", inlineesReplay.get(0).isDisallowedByReplay()));\n@@ -95,103 +72,2 @@\n-            Asserts.assertTrue(compare(inlineesNormal.get(4), \"compiler.ciReplay.InliningBar\", \"bar2\", inlineesNormal.get(4).isNormalInline()));\n-            Asserts.assertTrue(compare(inlineesReplay.get(4), \"compiler.ciReplay.InliningBar\", \"bar2\", inlineesReplay.get(4).isForcedByReplay()));\n-        }\n-        remove(LOG_FILE_NORMAL);\n-        remove(LOG_FILE_REPLAY);\n-    }\n-\n-    private void verifyLists(List<Entry> inlineesNormal, List<Entry> inlineesReplay, int expectedSize) {\n-        if (!inlineesNormal.equals(inlineesReplay)) {\n-            System.err.println(\"Normal entries:\");\n-            inlineesNormal.forEach(System.err::println);\n-            System.err.println(\"Replay entries:\");\n-            inlineesReplay.forEach(System.err::println);\n-            Asserts.fail(\"different inlining decision in normal run vs. replay run\");\n-        }\n-        Asserts.assertEQ(expectedSize, inlineesNormal.size(), \"unexpected number of inlinees found\");\n-    }\n-\n-    public static boolean compare(Entry e, String klass, String method, boolean kind) {\n-        return e.klass.equals(klass) && e.method.equals(method) && kind;\n-    }\n-\n-    public static List<Entry> parseLogFile(String logFile, String rootMethod, String nmethodMatch, int inlineeCount) {\n-        String nmethodStart = \"<nmethod\";\n-        List<Entry> inlinees = new ArrayList<>();\n-        int foundLines = 0;\n-        try (var br = Files.newBufferedReader(Paths.get(logFile))) {\n-            String line;\n-            boolean nmethodLine = false;\n-            boolean inlinineLine = false;\n-            while ((line = br.readLine()) != null) {\n-                if (nmethodLine) {\n-                    \/\/ Ignore other entries which could be in between nmethod entry and inlining statements\n-                    if (line.startsWith(\"             \")) {\n-                        inlinineLine = true;\n-                        Pattern p = Pattern.compile(\"(\\\\S+)::(\\\\S+).*bytes\\\\)\\s+(.*)\");\n-                        Matcher matcher = p.matcher(line);\n-                        Asserts.assertTrue(matcher.find(), \"must find inlinee method\");\n-                        inlinees.add(new Entry(matcher.group(1), matcher.group(2), matcher.group(3).trim()));\n-                        foundLines++;\n-                    } else if (inlinineLine) {\n-                        Asserts.assertEQ(foundLines, inlineeCount, \"did not find all inlinees\");\n-                        return inlinees;\n-                    }\n-                } else {\n-                    nmethodLine = line.startsWith(nmethodStart) && line.contains(nmethodMatch);\n-                    if (nmethodLine) {\n-                        Asserts.assertTrue(line.contains(rootMethod), \"should only dump inline information for \" + rootMethod);\n-                    }\n-                }\n-            }\n-        } catch (IOException e) {\n-            throw new Error(\"Failed to read \" + logFile + \" data: \" + e, e);\n-        }\n-        Asserts.fail(\"Should have found inlinees\");\n-        return inlinees;\n-    }\n-\n-\n-    @Override\n-    public String getTestClass() {\n-        return \"compiler.ciReplay.\" + className;\n-    }\n-\n-    static class Entry {\n-        String klass;\n-        String method;\n-        String reason;\n-\n-        public Entry(String klass, String method, String reason) {\n-            this.klass = klass;\n-            this.method = method;\n-            this.reason = reason;\n-        }\n-\n-        public boolean isNormalInline() {\n-            return reason.equals(\"inline (hot)\");\n-        }\n-\n-        public boolean isForcedByReplay() {\n-            return reason.equals(\"force inline by ciReplay\");\n-        }\n-\n-        public boolean isDisallowedByReplay() {\n-            return reason.equals(\"disallowed by ciReplay\");\n-        }\n-\n-        public boolean isUnloadedSignatureClasses() {\n-            return reason.equals(\"unloaded signature classes\");\n-        }\n-\n-        @Override\n-        public boolean equals(Object other) {\n-            if (other == this) {\n-                return true;\n-            }\n-\n-            if (!(other instanceof Entry)) {\n-                return false;\n-            }\n-\n-            Entry e = (Entry)other;\n-            return klass.equals(e.klass) && method.equals(e.method);\n+            Asserts.assertTrue(inlineesNormal.get(4).compare(\"compiler.ciReplay.InliningBar\", \"bar2\", inlineesNormal.get(4).isNormalInline()));\n+            Asserts.assertTrue(inlineesReplay.get(4).compare(\"compiler.ciReplay.InliningBar\", \"bar2\", inlineesReplay.get(4).isForcedByReplay()));\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/TestInliningProtectionDomain.java","additions":18,"deletions":142,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.lang.reflect.Field;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/*\n+ * @test\n+ * @bug 8276036 8277213 8277441\n+ * @summary test for the value of full_count in the message of insufficient codecache\n+ * @library \/test\/lib\n+ *\/\n+public class CodeCacheFullCountTest {\n+    public static void main(String args[]) throws Throwable {\n+        if (args.length == 1) {\n+            wasteCodeCache();\n+        } else {\n+            runTest();\n+        }\n+    }\n+\n+    public static void wasteCodeCache()  throws Exception {\n+        URL url = CodeCacheFullCountTest.class.getProtectionDomain().getCodeSource().getLocation();\n+\n+        for (int i = 0; i < 500; i++) {\n+            ClassLoader cl = new MyClassLoader(url);\n+            refClass(cl.loadClass(\"SomeClass\"));\n+        }\n+    }\n+\n+    public static void runTest() throws Throwable {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+          \"-XX:ReservedCodeCacheSize=2496k\", \"-XX:-UseCodeCacheFlushing\", \"CodeCacheFullCountTest\", \"WasteCodeCache\");\n+        OutputAnalyzer oa = ProcessTools.executeProcess(pb);\n+        oa.shouldHaveExitValue(0);\n+        String stdout = oa.getStdout();\n+\n+        Pattern pattern = Pattern.compile(\"full_count=(\\\\d)\");\n+        Matcher stdoutMatcher = pattern.matcher(stdout);\n+        if (stdoutMatcher.find()) {\n+            int fullCount = Integer.parseInt(stdoutMatcher.group(1));\n+            if (fullCount != 1) {\n+                throw new RuntimeException(\"the value of full_count is wrong.\");\n+            }\n+        } else {\n+            throw new RuntimeException(\"codecache shortage did not occur.\");\n+        }\n+    }\n+\n+    private static void refClass(Class clazz) throws Exception {\n+        Field name = clazz.getDeclaredField(\"NAME\");\n+        name.setAccessible(true);\n+        name.get(null);\n+    }\n+\n+    private static class MyClassLoader extends URLClassLoader {\n+        public MyClassLoader(URL url) {\n+            super(new URL[]{url}, null);\n+        }\n+        protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n+            try {\n+                return super.loadClass(name, resolve);\n+            } catch (ClassNotFoundException e) {\n+                return Class.forName(name, resolve, CodeCacheFullCountTest.class.getClassLoader());\n+            }\n+        }\n+    }\n+}\n+\n+abstract class Foo {\n+    public abstract int foo();\n+}\n+\n+class Foo1 extends Foo {\n+    private int a;\n+    public int foo() { return a; }\n+}\n+\n+class Foo2 extends Foo {\n+    private int a;\n+    public int foo() { return a; }\n+}\n+\n+class Foo3 extends Foo {\n+    private int a;\n+    public int foo() { return a; }\n+}\n+\n+class Foo4 extends Foo {\n+    private int a;\n+    public int foo() { return a; }\n+}\n+\n+class SomeClass {\n+    static final String NAME = \"name\";\n+\n+    static {\n+        int res =0;\n+        Foo[] foos = new Foo[] { new Foo1(), new Foo2(), new Foo3(), new Foo4() };\n+        for (int i = 0; i < 100000; i++) {\n+            res = foos[i % foos.length].foo();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CodeCacheFullCountTest.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8275330\n+ * @summary C2: assert(n->is_Root() || n->is_Region() || n->is_Phi() || n->is_MachMerge() || def_block->dominates(block)) failed: uses must be dominated by definitions\n+ *\n+ * @run main\/othervm -Xmx512m -XX:+UnlockDiagnosticVMOptions -Xcomp -XX:CompileOnly=TestDeadPostLoopBecausePredicate TestDeadPostLoopBecausePredicate\n+ *\n+ *\/\n+\n+\n+public class TestDeadPostLoopBecausePredicate {\n+\n+    public static final int N = 400;\n+\n+    public static int iFld=54270;\n+    public static int iFld1=-4;\n+    public int iFld2=201;\n+\n+    public int mainTest(String[] strArr1) {\n+\n+        int i=0, i17=8052, i19=22380, i20=60894, iArr[]=new int[N];\n+        init(iArr, 4);\n+\n+        i = 1;\n+        do {\n+            for (i17 = 5; i17 < 114; i17++) {\n+                switch ((i17 % 7) + 126) {\n+                case 126:\n+                    for (i19 = 2; i19 > i; i19 -= 3) {\n+                        try {\n+                            i20 = (iFld2 % TestDeadPostLoopBecausePredicate.iFld1);\n+                            i20 = (iArr[i19 - 1] % TestDeadPostLoopBecausePredicate.iFld);\n+                            TestDeadPostLoopBecausePredicate.iFld = (TestDeadPostLoopBecausePredicate.iFld1 % iArr[i19]);\n+                        } catch (ArithmeticException a_e) {}\n+                    }\n+                    break;\n+                }\n+            }\n+        } while (++i < 220);\n+\n+        return i20;\n+    }\n+\n+    public static void init(int[] a, int seed) {\n+        for (int j = 0; j < a.length; j++) {\n+            a[j] = (j % 2 == 0) ? seed + j : seed - j;\n+        }\n+    }\n+\n+    public static void main(String[] strArr) {\n+        TestDeadPostLoopBecausePredicate _instance = new TestDeadPostLoopBecausePredicate();\n+        for (int i = 0; i < 10; i++ ) {\n+            _instance.mainTest(strArr);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestDeadPostLoopBecausePredicate.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -90,1 +90,2 @@\n-            checkFinalFlagsEqualTo(ProcessTools.createJavaProcessBuilder(\"-XX:+PrintFlagsFinal\", \"-version\"), \"isb\", \"1\");\n+            checkFinalFlagsEqualTo(ProcessTools.createJavaProcessBuilder(\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+PrintFlagsFinal\", \"-version\"),\n+                \"isb\", \"1\");\n","filename":"test\/hotspot\/jtreg\/compiler\/onSpinWait\/TestOnSpinWaitAArch64DefaultFlags.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -45,3 +46,0 @@\n-import java.lang.invoke.MethodType;\n-\n-import static jdk.incubator.foreign.CLinker.C_INT;\n@@ -54,1 +52,1 @@\n-    final static CLinker abi = CLinker.getInstance();\n+    final static CLinker abi = CLinker.systemCLinker();\n@@ -57,2 +55,1 @@\n-            MethodType.methodType(int.class),\n-            FunctionDescriptor.of(C_INT));\n+            FunctionDescriptor.of(ValueLayout.JAVA_INT));\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestLinkToNativeRBP.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -44,6 +44,2 @@\n-      try {\n-        output.shouldContain(\"PrintTouchedMethodsJcmd.main:([Ljava\/lang\/String;)V\");\n-      } catch (RuntimeException e) {\n-        output.shouldContain(\"Unknown diagnostic command\");\n-      }\n-  }\n+      output.shouldContain(\"PrintTouchedMethodsJcmd.main:([Ljava\/lang\/String;)V\");\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/PrintTouchedMethodsJcmd.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4,1 +4,0 @@\n-import java.util.ArrayList;\n@@ -6,1 +5,0 @@\n-import java.util.List;\n@@ -143,0 +141,3 @@\n+        System.out.println(\"context used words \" + usageMeasured + \", committed words \" + committedMeasured\n+                + \".\");\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/Metaspace\/elastic\/MetaspaceTestContext.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -86,0 +86,13 @@\n+        \/\/ At this point a large number of Arenas will have died (see above), but we probably still have\n+        \/\/  some live arenas left. The chunk freelist will be full of free chunks. Maybe a bit fragmented,\n+        \/\/  with a healthy mixture of larger and smaller chunks, since we still have live arenas.\n+        \/\/ These chunks are all committed still, since we did nothing to reclaim the storage. We now purge\n+        \/\/  the context manually to uncommit those chunks, in order to get a realistic number for\n+        \/\/  committed words (see checkStatistics()).\n+        \/\/ Note: In real metaspace, this happens as part of the same GC which removes class loaders and\n+        \/\/  frees their metaspace arenas. All within CLDG::purge(). But since this test isolates the metaspace\n+        \/\/  context and does test it separately, GC and CLDG are not involved here. We need to purge manually.\n+        \/\/\n+        \/\/ Purging uncommits all free chunks >= 64K\/16K (MetaspaceReclaimPolicy=standard\/aggressive).\n+        context.purge();\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/Metaspace\/elastic\/MetaspaceTestManyArenasManyThreads.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -84,0 +84,5 @@\n+                \/\/ MonitorUsedDeflationThreshold == 10 means we'll request\n+                \/\/ deflations when 10% of monitors are used rather than the\n+                \/\/ default 90%. This should allow the test to tolerate a burst\n+                \/\/ of used monitors by threads not under this test's control.\n+                \"-XX:MonitorUsedDeflationThreshold=10\",\n@@ -92,2 +97,3 @@\n-                \/\/ reproduced the bug with JDK13. Anything above the\n-                \/\/ in_use_list_ceiling will do the trick.\n+                \/\/ reproduced the bug with JDK13. With inflate_count == 33, an\n+                \/\/ initial ceiling == 12 and MonitorUsedDeflationThreshold == 10,\n+                \/\/ we should hit NoAsyncDeflationProgressMax at least 3 times.\n@@ -114,0 +120,2 @@\n+            \/\/ Uncomment the following line for dumping test output in passing runs:\n+            \/\/ output_detail.reportDiagnosticSummary();\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/MonitorUsedDeflationThresholdTest.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+        pbArgs.add(\"-XX:-CreateCoredumpOnCrash\");\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/TestPrimitiveArrayCriticalWithBadParam.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Verifies that a VMObjectAlloc event is generated for object created using MethodHandle\n+ * @requires vm.jvmti\n+ * @run main\/othervm\/native -agentlib:VMObjectAlloc VMObjectAllocTest\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+public class VMObjectAllocTest {\n+\n+    private static native int getNumberOfAllocation();\n+\n+    public VMObjectAllocTest(String str) {\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+\n+        MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        MethodType mt = MethodType.methodType(void.class, String.class);\n+        MethodHandle mh = publicLookup.findConstructor(VMObjectAllocTest.class, mt);\n+        mh.invoke(\"str\");\n+\n+        if (getNumberOfAllocation() != 1) {\n+            throw new Exception(\"Number of allocation != 1\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/VMObjectAlloc\/VMObjectAllocTest.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include \"jvmti.h\"\n+\n+extern \"C\" {\n+\n+static int number_of_allocation = 0;\n+\n+extern JNIEXPORT void JNICALL\n+VMObjectAlloc(jvmtiEnv *jvmti,\n+              JNIEnv* jni,\n+              jthread thread,\n+              jobject object,\n+              jclass cls,\n+              jlong size) {\n+  char *signature = NULL;\n+  jvmtiError err = jvmti->GetClassSignature(cls, &signature, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    jni->FatalError(\"Failed during the GetClassSignature call\");\n+  }\n+\n+  printf(\"VMObjectAlloc called for %s\\n\", signature);\n+\n+  if (!strcmp(signature, \"LVMObjectAllocTest;\")) {\n+    number_of_allocation++;\n+  }\n+}\n+\n+\n+JNIEXPORT jint JNICALL\n+Java_VMObjectAllocTest_getNumberOfAllocation(JNIEnv *env, jclass cls) {\n+  return number_of_allocation;\n+}\n+\n+extern JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiEnv *jvmti;\n+  jvmtiEventCallbacks callbacks;\n+  jvmtiError err;\n+  jvmtiCapabilities caps;\n+\n+  if (jvm->GetEnv((void **) &jvmti, JVMTI_VERSION) != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+\n+  memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.VMObjectAlloc = &VMObjectAlloc;\n+  memset(&caps, 0, sizeof(caps));\n+  caps.can_generate_vm_object_alloc_events = 1;\n+\n+  err = jvmti->AddCapabilities( &caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(jvmtiEventCallbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_OBJECT_ALLOC , NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+} \/\/extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/VMObjectAlloc\/libVMObjectAlloc.cpp","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n- * In this test a 1000 classes are loaded and unloaded in a loop.\n+ * In this test 1000 classes are loaded and unloaded in a loop.\n@@ -33,1 +33,1 @@\n- * the way uptill class1000.  The classes should be unloaded whenever a\n+ * the way up to class1000.  The classes should be unloaded whenever a\n@@ -35,1 +35,1 @@\n- * at the end of the each loop iteration. The loop is repeated 1000 times.\n+ * at the end of each loop iteration. The loop is repeated 1000 times.\n@@ -48,0 +48,24 @@\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM Testbase gc\/gctests\/LoadUnloadGC.\n+ * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent, monitoring]\n+ * VM Testbase readme:\n+ * In this test 1000 classes are loaded and unloaded in a loop.\n+ * Class0 gets loaded which results in Class1 getting loaded and so on all\n+ * the way up to class1000.  The classes should be unloaded whenever a\n+ * garbage collection takes place because their classloader is made unreachable\n+ * at the end of each loop iteration. The loop is repeated 1000 times.\n+ *\n+ * @requires vm.opt.final.ClassUnloading\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ * @build nsk.share.gc.ClassChain\n+ * @run main\/othervm\n+ *      -XX:MaxMetaspaceSize=64M\n+ *      -XX:MetaspaceSize=64M\n+ *      -XX:CompressedClassSpaceSize=32M\n+ *      gc.gctests.LoadUnloadGC.LoadUnloadGC\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LoadUnloadGC\/LoadUnloadGC.java","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,2 @@\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n@@ -66,1 +68,2 @@\n- *      -debugee.vmkeys=\"-Xmx256M ${test.vm.opts} ${test.java.opts}\"\n+ *      -debugee.vmkeys=\"-Xmx256M -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                       -XX:+WhiteBoxAPI  ${test.vm.opts} ${test.java.opts}\"\n@@ -100,0 +103,4 @@\n+        log.display(\"References:\");\n+        for (ObjectReference ref: classObjectReference.referringObjects(0)) {\n+            log.display(ref);\n+        }\n@@ -140,1 +147,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ObjectReference\/referringObjects\/referringObjects002\/referringObjects002.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import sun.hotspot.WhiteBox;\n@@ -59,0 +60,2 @@\n+    private final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n@@ -79,0 +82,3 @@\n+        \/\/ force full GC with WB to ensure that weak refernces are collected\n+        \/\/ j.l.i.MethodType has ConcurrentWeakInternSet which might contain references to TestClass1\n+        WB.fullGC();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ObjectReference\/referringObjects\/referringObjects002\/referringObjects002a.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,8 +141,0 @@\n-\/* ============================================================================= *\/\n-static void set_agent_thread_state(thread_state_t value) {\n-    rawMonitorEnter(jvmti_env, agent_data.monitor);\n-    agent_data.thread_state = value;\n-    rawMonitorNotify(jvmti_env, agent_data.monitor);\n-    rawMonitorExit(jvmti_env, agent_data.monitor);\n-}\n-\n@@ -154,3 +146,4 @@\n-    \/* run user agent proc *\/\n-    {\n-        set_agent_thread_state(RUNNABLE);\n+    rawMonitorEnter(jvmti_env, agent_data.monitor);\n+    agent_data.thread_state = RUNNABLE;\n+    rawMonitorNotify(jvmti_env, agent_data.monitor);\n+    rawMonitorExit(jvmti_env, agent_data.monitor);\n@@ -158,1 +151,1 @@\n-        NSK_TRACE((*agentThreadProc)(jvmti_env, agentJNI, agentThreadArg));\n+    NSK_TRACE((*agentThreadProc)(jvmti_env, agentJNI, agentThreadArg));\n@@ -160,2 +153,6 @@\n-        set_agent_thread_state(TERMINATED);\n-    }\n+    rawMonitorEnter(jvmti_env, agent_data.monitor);\n+    agent_data.thread_state = TERMINATED;\n+    agentJNI->DeleteGlobalRef(agentThread);\n+    agentThread = NULL;\n+    rawMonitorNotify(jvmti_env, agent_data.monitor);\n+    rawMonitorExit(jvmti_env, agent_data.monitor);\n@@ -163,6 +160,0 @@\n-    \/* finalize agent thread *\/\n-    {\n-        \/* gelete global ref for agent thread *\/\n-        agentJNI->DeleteGlobalRef(agentThread);\n-        agentThread = NULL;\n-    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti\/agent_tools.cpp","additions":12,"deletions":21,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        if (!\"Java heap space\".equals(message)) {\n+        if (!message.startsWith(\"Java heap space\")) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/hiddenloader\/stress\/oome\/heap\/Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,0 +73,37 @@\n+    @Test\n+    public void testClosedStructAddr_6() throws Throwable {\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+                LOOKUP.lookup(\"addr_func_6\").get(),\n+                FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_POINTER, C_POINTER, C_POINTER, C_POINTER));\n+        for (int i = 0 ; i < 6 ; i++) {\n+            MemorySegment[] segments = new MemorySegment[]{\n+                    MemorySegment.allocateNative(POINT, ResourceScope.newImplicitScope()),\n+                    MemorySegment.allocateNative(POINT, ResourceScope.newImplicitScope()),\n+                    MemorySegment.allocateNative(POINT, ResourceScope.newImplicitScope()),\n+                    MemorySegment.allocateNative(POINT, ResourceScope.newImplicitScope()),\n+                    MemorySegment.allocateNative(POINT, ResourceScope.newImplicitScope()),\n+                    MemorySegment.allocateNative(POINT, ResourceScope.newImplicitScope())\n+            };\n+            \/\/ check liveness\n+            segments[i].scope().close();\n+            for (int j = 0 ; j < 6 ; j++) {\n+                if (i == j) {\n+                    assertFalse(segments[j].scope().isAlive());\n+                } else {\n+                    assertTrue(segments[j].scope().isAlive());\n+                }\n+            }\n+            try {\n+                handle.invokeWithArguments(segments);\n+                fail();\n+            } catch (IllegalStateException ex) {\n+                assertTrue(ex.getMessage().contains(\"Already closed\"));\n+            }\n+            for (int j = 0 ; j < 6 ; j++) {\n+                if (i != j) {\n+                    segments[j].scope().close(); \/\/ should succeed!\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-                        MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class));\n+                        CLinker.upcallType(qsortComparFunction));\n@@ -248,1 +248,1 @@\n-                this.base = MemorySegment.ofAddressNative(addr, SIZE, ResourceScope.globalScope());\n+                this.base = MemorySegment.ofAddress(addr, SIZE, ResourceScope.globalScope());\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- *  Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n@@ -5,3 +5,3 @@\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n@@ -9,5 +9,5 @@\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n@@ -15,3 +15,3 @@\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n@@ -19,3 +19,3 @@\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n","filename":"test\/jdk\/java\/foreign\/TestArrayCopy.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-        MemorySegment segment = MemorySegment.ofAddressNative(MemoryAddress.NULL, seq.byteSize(), ResourceScope.globalScope());\n+        MemorySegment segment = MemorySegment.ofAddress(MemoryAddress.NULL, seq.byteSize(), ResourceScope.globalScope());\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -491,1 +491,1 @@\n-        MemorySegment segment = MemorySegment.ofAddressNative(MemoryAddress.NULL, Integer.MAX_VALUE + 10L, ResourceScope.newImplicitScope());\n+        MemorySegment segment = MemorySegment.ofAddress(MemoryAddress.NULL, Integer.MAX_VALUE + 10L, ResourceScope.newImplicitScope());\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-        return MemorySegment.ofAddressNative(addr, numElements * layout.byteSize(), ResourceScope.globalScope());\n+        return MemorySegment.ofAddress(addr, numElements * layout.byteSize(), ResourceScope.globalScope());\n","filename":"test\/jdk\/java\/foreign\/TestFree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.constant.Constable;\n@@ -37,0 +38,1 @@\n+import java.util.stream.Collectors;\n","filename":"test\/jdk\/java\/foreign\/TestFunctionDescriptor.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -173,1 +173,1 @@\n-            MemorySegment mallocSegment = MemorySegment.ofAddressNative(addr, 12, scope);\n+            MemorySegment mallocSegment = MemorySegment.ofAddress(addr, 12, scope);\n@@ -184,1 +184,1 @@\n-            mallocSegment = MemorySegment.ofAddressNative(addr, 12, scope);\n+            mallocSegment = MemorySegment.ofAddress(addr, 12, scope);\n@@ -203,1 +203,1 @@\n-            MemorySegment.ofAddressNative(segment.address(), 0, ResourceScope.globalScope());\n+            MemorySegment.ofAddress(segment.address(), 0, ResourceScope.globalScope());\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-        Method method = MemorySegment.class.getDeclaredMethod(\"ofAddressNative\", MemoryAddress.class, long.class, ResourceScope.class);\n+        Method method = MemorySegment.class.getDeclaredMethod(\"ofAddress\", MemoryAddress.class, long.class, ResourceScope.class);\n@@ -66,1 +66,1 @@\n-        var mh = MethodHandles.lookup().findStatic(MemorySegment.class, \"ofAddressNative\",\n+        var mh = MethodHandles.lookup().findStatic(MemorySegment.class, \"ofAddress\",\n@@ -73,1 +73,1 @@\n-        MemorySegment.ofAddressNative(MemoryAddress.NULL, 4000, ResourceScope.globalScope());\n+        MemorySegment.ofAddress(MemoryAddress.NULL, 4000, ResourceScope.globalScope());\n","filename":"test\/jdk\/java\/foreign\/TestRestricted.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -237,1 +237,1 @@\n-            UNSAFE(scope -> MemorySegment.ofAddressNative(MemoryAddress.NULL, 10, scope));\n+            UNSAFE(scope -> MemorySegment.ofAddress(MemoryAddress.NULL, 10, scope));\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-    @Test(expectedExceptions = OutOfMemoryError.class)\n+    @Test\n@@ -123,1 +123,2 @@\n-            allocator.allocate(12);\n+            assertThrows(OutOfMemoryError.class, () -> allocator.allocate(12));\n+            allocator.allocate(5); \/\/ ok\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-            MemorySegment sharedSegment = MemorySegment.ofAddressNative(s.address(), s.byteSize(), scope);\n+            MemorySegment sharedSegment = MemorySegment.ofAddress(s.address(), s.byteSize(), scope);\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -65,1 +64,1 @@\n-        MemorySegment segment = MemorySegment.ofAddressNative(LOOKUP.lookup(\"c\").get().address(), ValueLayout.JAVA_INT.byteSize(), ResourceScope.globalScope());\n+        MemorySegment segment = MemorySegment.ofAddress(LOOKUP.lookup(\"c\").get().address(), ValueLayout.JAVA_INT.byteSize(), ResourceScope.globalScope());\n","filename":"test\/jdk\/java\/foreign\/TestSymbolLookup.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -165,1 +164,1 @@\n-            MethodHandle mh = reverse(downcallHandle(abi, addr, allocator, descriptor));\n+            MethodHandle mh = downcallHandle(abi, addr, allocator, descriptor);\n@@ -173,1 +172,1 @@\n-            NativeSymbol callback = abi.upcallStub(mh, callbackDesc, scope);\n+            NativeSymbol callback = abi.upcallStub(mh.asType(CLinker.upcallType(callbackDesc)), callbackDesc, scope);\n@@ -330,13 +329,0 @@\n-\n-    static MethodHandle reverse(MethodHandle handle) {\n-        MethodType type = handle.type();\n-        if (type.returnType().equals(MemoryAddress.class)) {\n-            type = type.changeReturnType(Addressable.class);\n-        }\n-        for (int i = 0 ; i < type.parameterCount() ; i++) {\n-            if (type.parameterType(i).equals(Addressable.class)) {\n-                type.changeParameterType(i, MemoryAddress.class);\n-            }\n-        }\n-        return handle.asType(type);\n-    }\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-                    { MethodHandles.lookup().findStatic(MemorySegment.class, \"ofAddressNative\",\n+                    { MethodHandles.lookup().findStatic(MemorySegment.class, \"ofAddress\",\n@@ -63,1 +63,1 @@\n-                            \"MemorySegment::ofAddressNative\" },\n+                            \"MemorySegment::ofAddress\" },\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+EXPORT void addr_func_6(struct Point* p1, struct Point* p2, struct Point* p3, struct Point* p4, struct Point* p5, struct Point* p6) { }\n+\n","filename":"test\/jdk\/java\/foreign\/libSafeAccess.c","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @compile --add-modules jdk.incubator.foreign lookup\/Lookup.java\n+ * @compile --add-modules jdk.incubator.foreign invoker\/Invoker.java\n+ * @run main\/othervm --enable-native-access=ALL-UNNAMED TestLoaderLookup\n+ *\/\n+\n+import java.lang.reflect.*;\n+import jdk.incubator.foreign.*;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Paths;\n+\n+public class TestLoaderLookup {\n+    public static void main(String[] args) throws ReflectiveOperationException {\n+        ClassLoader loader1 = newClassLoader(\"lookup\");\n+        Class<?> lookup = loader1.loadClass(\"lookup.Lookup\");\n+        Method fooSymbol = lookup.getDeclaredMethod(\"fooSymbol\");\n+        NativeSymbol foo = (NativeSymbol)fooSymbol.invoke(null);\n+\n+        ClassLoader loader2 = newClassLoader(\"invoker\");\n+        Class<?> invoker = loader2.loadClass(\"invoker.Invoker\");\n+        Method invoke = invoker.getDeclaredMethod(\"invoke\", NativeSymbol.class);\n+        invoke.invoke(null, foo);\n+\n+        loader1 = null;\n+        lookup = null;\n+        fooSymbol = null;\n+        \/\/ Make sure that the loader is kept reachable\n+        for (int i = 0 ; i < 1000 ; i++) {\n+            invoke.invoke(null, foo); \/\/ might crash if loader1 is GC'ed\n+            System.gc();\n+        }\n+    }\n+\n+    public static ClassLoader newClassLoader(String path) {\n+        try {\n+            return new URLClassLoader(new URL[] {\n+                    Paths.get(System.getProperty(\"test.classes\", path)).toUri().toURL(),\n+            }, null);\n+        } catch (MalformedURLException e){\n+            throw new RuntimeException(\"Unexpected URL conversion failure\", e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/TestLoaderLookup.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package invoker;\n+\n+import jdk.incubator.foreign.*;\n+\n+public class Invoker {\n+    public static void invoke(NativeSymbol symbol) throws Throwable {\n+        var linker = CLinker.systemCLinker();\n+        var handle = linker.downcallHandle(symbol, FunctionDescriptor.ofVoid());\n+        handle.invokeExact();\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/invoker\/Invoker.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package lookup;\n+\n+import jdk.incubator.foreign.*;\n+\n+public class Lookup {\n+    static {\n+        System.loadLibrary(\"Foo\");\n+    }\n+\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n+\n+    public static NativeSymbol fooSymbol() {\n+        return lookup.lookup(\"foo\").get();\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/lookup\/Lookup.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT void foo(void) {\n+    \/\/ do nothing\n+}\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/lookup\/libFoo.c","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -60,1 +60,1 @@\n-        MemorySegment seg = MemorySegment.ofAddressNative(ma, 4L, ResourceScope.newImplicitScope());\n+        MemorySegment seg = MemorySegment.ofAddress(ma, 4L, ResourceScope.newImplicitScope());\n","filename":"test\/jdk\/java\/foreign\/malloc\/TestMixedMallocFree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -745,1 +745,1 @@\n-                    MemorySegment ms = MemorySegment.ofAddressNative(intPtr, C_INT.byteSize(), ResourceScope.globalScope());\n+                    MemorySegment ms = MemorySegment.ofAddress(intPtr, C_INT.byteSize(), ResourceScope.globalScope());\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8273660\n+ * @summary Verify that ObjectInputStream ReadFields correctly reports ClassNotFoundException\n+ *    while getting the field value. The test uses Vector that calls ReadFields from its readObject.\n+ * @library \/test\/lib\n+ * @run testng ReadFieldsCNF\n+ * @run testng\/othervm -Djdk.serialGetFieldCnfeReturnsNull=true ReadFieldsCNF\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.io.StreamCorruptedException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Vector;\n+\n+import org.testng.annotations.Test;\n+import org.testng.Assert;\n+\n+import jdk.test.lib.hexdump.HexPrinter;\n+import jdk.test.lib.hexdump.ObjectStreamPrinter;\n+\n+public class ReadFieldsCNF {\n+\n+    private static final boolean GETFIELD_CNFE_RETURNS_NULL =\n+            Boolean.getBoolean(\"jdk.serialGetFieldCnfeReturnsNull\");\n+\n+\n+    \/**\n+     * Test a Vector holding a reference to a class instance that will not be found.\n+     * @throws IOException If any other exception occurs\n+     *\/\n+    @Test\n+    private static void testVectorWithRole() throws IOException {\n+        System.out.println(\"Property GETFIELD_CNFE_RETURNS_NULL: \" + GETFIELD_CNFE_RETURNS_NULL);\n+\n+        Role role = new Role();\n+        Vector<Role> vector = new Vector<>();\n+        vector.add(role);\n+\n+        \/\/ Modify the byte stream to change the classname to be deserialized to\n+        \/\/ XeadFieldsCNF$Role.\n+        byte[] bytes = writeObject(vector);\n+\n+        \/\/ Locate the name of the class to be deserialize\n+        String s = new String(bytes, StandardCharsets.ISO_8859_1);  \/\/ Map bytes to chars\n+        int off = s.indexOf(Role.class.getName());\n+        System.out.printf(\"Role offset: %d (0x%x) : %s%n\", off, off, Role.class.getName());\n+        if (off < 0) {\n+            HexPrinter.simple().formatter(ObjectStreamPrinter.formatter()).format(bytes);\n+            Assert.fail(\"classname not found\");\n+        }\n+\n+        bytes[off] = (byte) 'X';  \/\/ replace R with X -> Class not found\n+\n+        \/\/ Deserialize the Vector expecting a ClassNotFoundException\n+        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bytes));\n+        try {\n+            Object obj = in.readObject();\n+            System.out.println(\"Read: \" + obj);\n+            Assert.fail(\"Should not reach here, an exception should always occur\");\n+        } catch (ClassNotFoundException cnfe) {\n+            \/\/ Expected ClassNotFoundException\n+            String expected = \"XeadFieldsCNF$Role\";\n+            Assert.assertEquals(expected, cnfe.getMessage(), \"Wrong classname\");\n+            if (GETFIELD_CNFE_RETURNS_NULL) {\n+                Assert.fail(\"Expected IOException got ClassNotFoundException\", cnfe);\n+            }\n+            System.out.println(\"Normal:  OIS.readObject: \" + cnfe);\n+        } catch (StreamCorruptedException ioe) {\n+            if (!GETFIELD_CNFE_RETURNS_NULL) {\n+                Assert.fail(\"Expected ClassNotFoundException got StreamCorruptedException \", ioe);\n+            }\n+            System.out.println(\"Normal: \" + ioe);\n+        }\n+        \/\/ Other exceptions cause the test to fail\n+    }\n+\n+    \/**\n+     * For an object holding a reference to a class that will not be found.\n+     * @throws IOException If any other exception occurs\n+     *\/\n+    @Test\n+    private static void testHolderWithRole() throws IOException {\n+        System.out.println(\"Property GETFIELD_CNFE_RETURNS_NULL: \" + GETFIELD_CNFE_RETURNS_NULL);\n+        Role role = new Role();\n+        Holder holder = new Holder(role);\n+\n+        \/\/ Modify the byte stream to change the classname to be deserialized to\n+        \/\/ XeadFieldsCNF$Role.\n+        byte[] bytes = writeObject(holder);\n+\n+        String s = new String(bytes, StandardCharsets.ISO_8859_1);  \/\/ Map bytes to chars\n+        int off = s.indexOf(Role.class.getName(), 0);\n+        off = s.indexOf(Role.class.getName(), off + 1); \/\/ 2nd occurrence of classname\n+        System.out.printf(\"Role offset: %d (0x%x)%n\", off, off);\n+        if (off < 0) {\n+            HexPrinter.simple().formatter(ObjectStreamPrinter.formatter()).format(bytes);\n+            Assert.fail(\"classname found at index: \" + off + \" (0x\" + Integer.toHexString(off) + \")\");\n+        }\n+\n+        bytes[off] = (byte) 'X';  \/\/ replace R with X -> Class not found\n+\n+        \/\/ Deserialize the Vector expecting a ClassNotFoundException\n+        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bytes));\n+        try {\n+            Holder obj = (Holder)in.readObject();\n+            System.out.println(\"Read: \" + obj);\n+            Assert.fail(\"Should not reach here, an exception should always occur\");\n+        } catch (ClassNotFoundException cnfe) {\n+            \/\/ Expected ClassNotFoundException\n+            String expected = \"XeadFieldsCNF$Role\";\n+            Assert.assertEquals(expected, cnfe.getMessage(), \"Wrong classname\");\n+            System.out.println(\"Normal: OIS.readObject: \" + cnfe);\n+        } catch (StreamCorruptedException ioe) {\n+            if (!GETFIELD_CNFE_RETURNS_NULL) {\n+                Assert.fail(\"Expected ClassNotFoundException got StreamCorruptedException \", ioe);\n+            }\n+            System.out.println(\"Normal: \" + ioe);\n+        }\n+        \/\/ Other exceptions cause the test to fail\n+    }\n+\n+    private static byte[] writeObject(Object o) throws IOException {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (ObjectOutputStream os = new ObjectOutputStream(baos)) {\n+            os.writeObject(o);\n+        }\n+        return baos.toByteArray();\n+    }\n+\n+    static class Role implements Serializable {\n+        private static final long serialVersionUID = 0L;\n+\n+        Role() {}\n+    }\n+\n+    static class Holder implements Serializable {\n+        private static final long serialVersionUID = 1L;\n+\n+        Role role;\n+\n+        Holder(Role role) {\n+            this.role = role;\n+        }\n+\n+        private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n+            ObjectInputStream.GetField fields = ois.readFields();\n+            try {\n+                Object repl = new Object();\n+                role = (Role)fields.get(\"role\", repl);\n+                System.out.println(\"Holder.readObject Role: \" + role);\n+            } catch (Exception ex) {\n+                \/\/ Catch CNFE and ignore it; check elsewhere that CNFE is thrown from OIS.readObject\n+                System.out.println(\"Normal: exception in Holder.readObject, ignoring: \" + ex);\n+            }\n+        }\n+\n+        public String toString() {\n+            return \"role: \" + role;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Serializable\/GetField\/ReadFieldsCNF.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,582 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8277451\n+ * @run testng\/othervm -Djdk.reflect.useDirectMethodHandle=true NegativeTest\n+ * @run testng\/othervm -Djdk.reflect.useDirectMethodHandle=false NegativeTest\n+ * @summary Test exception thrown due to bad receiver and bad value on\n+ *          Field with and without setAccessible(true)\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class NegativeTest {\n+    static class Fields {\n+        public static int si;\n+        public static char sc;\n+        public static byte sb;\n+        public static short ss;\n+        public static long sl;\n+        public static double sd;\n+        public static float sf;\n+        public static boolean sz;\n+        public static String so;\n+\n+        public static final int sfi = 10;\n+        public static final char sfc = 'a';\n+        public static final byte sfb = 1;\n+        public static final short sfs = 2;\n+        public static final long sfl = 1000L;\n+        public static final double sfd = 1.0;\n+        public static final float sff = 2.0f;\n+        public static final boolean sfz = true;\n+        public static final String sfo = \"abc\";\n+\n+        public int i;\n+        public char c;\n+        public byte b;\n+        public short s;\n+        public long l;\n+        public double d;\n+        public float f;\n+        public boolean z;\n+        public String o;\n+\n+        public final int fi = 10;\n+        public final char fc = 'a';\n+        public final byte fb = 1;\n+        public final short fs = 2;\n+        public final long fl = 1000L;\n+        public final double fd = 1.0;\n+        public final float ff = 2.0f;\n+        public final boolean fz = true;\n+        public final String fo = \"abc\";\n+    }\n+\n+    static final Field i_field = field(\"i\", false);\n+    static final Field c_field = field(\"c\", false);\n+    static final Field b_field = field(\"b\", false);\n+    static final Field s_field = field(\"s\", false);\n+    static final Field l_field = field(\"l\", false);\n+    static final Field d_field = field(\"d\", false);\n+    static final Field f_field = field(\"f\", false);\n+    static final Field z_field = field(\"z\", false);\n+    static final Field o_field = field(\"o\", false);\n+    static final Field fi_field = field(\"fi\", false);\n+    static final Field fc_field = field(\"fc\", false);\n+    static final Field fb_field = field(\"fb\", false);\n+    static final Field fs_field = field(\"fs\", false);\n+    static final Field fl_field = field(\"fl\", false);\n+    static final Field fd_field = field(\"fd\", false);\n+    static final Field ff_field = field(\"ff\", false);\n+    static final Field fz_field = field(\"fz\", false);\n+    static final Field fo_field = field(\"fo\", false);\n+\n+    static final Field override_i_field = field(\"i\", true);\n+    static final Field override_c_field = field(\"c\", true);\n+    static final Field override_b_field = field(\"b\", true);\n+    static final Field override_s_field = field(\"s\", true);\n+    static final Field override_l_field = field(\"l\", true);\n+    static final Field override_d_field = field(\"d\", true);\n+    static final Field override_f_field = field(\"f\", true);\n+    static final Field override_z_field = field(\"z\", true);\n+    static final Field override_o_field = field(\"o\", true);\n+    static final Field override_fi_field = field(\"fi\", true);\n+    static final Field override_fc_field = field(\"fc\", true);\n+    static final Field override_fb_field = field(\"fb\", true);\n+    static final Field override_fs_field = field(\"fs\", true);\n+    static final Field override_fl_field = field(\"fl\", true);\n+    static final Field override_fd_field = field(\"fd\", true);\n+    static final Field override_ff_field = field(\"ff\", true);\n+    static final Field override_fz_field = field(\"fz\", true);\n+    static final Field override_fo_field = field(\"fo\", true);\n+\n+    static final Field si_field = field(\"si\", false);\n+    static final Field sc_field = field(\"sc\", false);\n+    static final Field sb_field = field(\"sb\", false);\n+    static final Field ss_field = field(\"ss\", false);\n+    static final Field sl_field = field(\"sl\", false);\n+    static final Field sd_field = field(\"sd\", false);\n+    static final Field sf_field = field(\"sf\", false);\n+    static final Field sz_field = field(\"sz\", false);\n+    static final Field so_field = field(\"so\", false);\n+    static final Field sfi_field = field(\"sfi\", false);\n+    static final Field sfc_field = field(\"sfc\", false);\n+    static final Field sfb_field = field(\"sfb\", false);\n+    static final Field sfs_field = field(\"sfs\", false);\n+    static final Field sfl_field = field(\"sfl\", false);\n+    static final Field sfd_field = field(\"sfd\", false);\n+    static final Field sff_field = field(\"sff\", false);\n+    static final Field sfz_field = field(\"sfz\", false);\n+    static final Field sfo_field = field(\"sfo\", false);\n+\n+    static final Field override_si_field = field(\"si\", true);\n+    static final Field override_sc_field = field(\"sc\", true);\n+    static final Field override_sb_field = field(\"sb\", true);\n+    static final Field override_ss_field = field(\"ss\", true);\n+    static final Field override_sl_field = field(\"sl\", true);\n+    static final Field override_sd_field = field(\"sd\", true);\n+    static final Field override_sf_field = field(\"sf\", true);\n+    static final Field override_sz_field = field(\"sz\", true);\n+    static final Field override_so_field = field(\"so\", true);\n+    static final Field override_sfi_field = field(\"sfi\", true);\n+    static final Field override_sfc_field = field(\"sfc\", true);\n+    static final Field override_sfb_field = field(\"sfb\", true);\n+    static final Field override_sfs_field = field(\"sfs\", true);\n+    static final Field override_sfl_field = field(\"sfl\", true);\n+    static final Field override_sfd_field = field(\"sfd\", true);\n+    static final Field override_sff_field = field(\"sff\", true);\n+    static final Field override_sfz_field = field(\"sfz\", true);\n+    static final Field override_sfo_field = field(\"sfo\", true);\n+\n+    private static Field field(String name, boolean suppressAccessCheck) {\n+        try {\n+            Field f = Fields.class.getDeclaredField(name);\n+            if (suppressAccessCheck) {\n+                f.setAccessible(true);\n+            }\n+            return f;\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @DataProvider(name = \"instanceFields\")\n+    private Object[][] instanceFields() {\n+        return new Object[][]{\n+                new Object[]{i_field},\n+                new Object[]{c_field},\n+                new Object[]{b_field},\n+                new Object[]{s_field},\n+                new Object[]{l_field},\n+                new Object[]{d_field},\n+                new Object[]{f_field},\n+                new Object[]{z_field},\n+                new Object[]{o_field},\n+                new Object[]{override_i_field},\n+                new Object[]{override_c_field},\n+                new Object[]{override_b_field},\n+                new Object[]{override_s_field},\n+                new Object[]{override_l_field},\n+                new Object[]{override_d_field},\n+                new Object[]{override_f_field},\n+                new Object[]{override_z_field},\n+                new Object[]{override_o_field},\n+                \/\/ final instance fields\n+                new Object[]{fi_field},\n+                new Object[]{fc_field},\n+                new Object[]{fb_field},\n+                new Object[]{fs_field},\n+                new Object[]{fl_field},\n+                new Object[]{fd_field},\n+                new Object[]{ff_field},\n+                new Object[]{fz_field},\n+                new Object[]{fo_field},\n+                new Object[]{override_fi_field},\n+                new Object[]{override_fc_field},\n+                new Object[]{override_fb_field},\n+                new Object[]{override_fs_field},\n+                new Object[]{override_fl_field},\n+                new Object[]{override_fd_field},\n+                new Object[]{override_ff_field},\n+                new Object[]{override_fz_field},\n+                new Object[]{override_fo_field},\n+        };\n+    }\n+    private static Fields INSTANCE = new Fields();\n+\n+    \/*\n+     * Test Field::get on a good receiver, a bad receiver and null.\n+     *\n+     * IllegalArgumentException is thrown if the receiver is of\n+     * a bad type.  NullPointerException is thrown if the receiver is null.\n+     *\/\n+    @Test(dataProvider = \"instanceFields\")\n+    public void testReceiver(Field f) throws ReflectiveOperationException {\n+        f.get(INSTANCE);     \/\/ good receiver\n+\n+        testBadReceiver(f);\n+        testNullReceiver(f);\n+    }\n+\n+    \/*\n+     * IllegalArgumentException should be thrown for bad receiver type\n+     *\/\n+    private void testBadReceiver(Field f) throws ReflectiveOperationException {\n+        assertFalse(Modifier.isStatic(f.getModifiers()));  \/\/ instance field\n+        Object badObj = new NegativeTest();\n+        try {\n+            f.get(badObj);\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            \/\/ expected\n+        }\n+        Class<?> fType = f.getType();\n+        if (fType.isPrimitive()) {\n+            try {\n+                switch (fType.descriptorString()) {\n+                    case \"B\" -> f.getByte(badObj);\n+                    case \"C\" -> f.getChar(badObj);\n+                    case \"D\" -> f.getDouble(badObj);\n+                    case \"F\" -> f.getFloat(badObj);\n+                    case \"I\" -> f.getInt(badObj);\n+                    case \"J\" -> f.getLong(badObj);\n+                    case \"S\" -> f.getShort(badObj);\n+                    case \"Z\" -> f.getBoolean(badObj);\n+                }\n+                fail(\"expected IllegalArgumentException\");\n+            } catch (IllegalArgumentException e) {\n+                \/\/ expected\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * NullPointerException should be thrown for null receiver\n+     *\/\n+    private void testNullReceiver(Field f) throws ReflectiveOperationException {\n+        assertFalse(Modifier.isStatic(f.getModifiers()));  \/\/ instance field\n+        try {\n+            f.get(null);\n+            fail(\"expected NullPointerException\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+\n+        Class<?> fType = f.getType();\n+        if (fType.isPrimitive()) {\n+            try {\n+                switch (fType.descriptorString()) {\n+                    case \"B\" -> f.getByte(null);\n+                    case \"C\" -> f.getChar(null);\n+                    case \"D\" -> f.getDouble(null);\n+                    case \"F\" -> f.getFloat(null);\n+                    case \"I\" -> f.getInt(null);\n+                    case \"J\" -> f.getLong(null);\n+                    case \"S\" -> f.getShort(null);\n+                    case \"Z\" -> f.getBoolean(null);\n+                }\n+                fail(\"expected NullPointerException\");\n+            } catch (NullPointerException e) {\n+                \/\/ expected\n+            }\n+        }\n+    }\n+\n+    @DataProvider(name = \"writeableFields\")\n+    private Object[][] writeableFields() {\n+        Fields obj = new Fields();\n+        return new Object[][]{\n+                \/\/ instance fields with and without setAccessible(true)\n+                new Object[]{i_field, obj, Integer.valueOf(10)},\n+                new Object[]{c_field, obj, Character.valueOf('c')},\n+                new Object[]{b_field, obj, Byte.valueOf((byte)1)},\n+                new Object[]{s_field, obj, Short.valueOf((short)2)},\n+                new Object[]{l_field, obj, Long.valueOf(1000)},\n+                new Object[]{d_field, obj, Double.valueOf(1.2)},\n+                new Object[]{f_field, obj, Float.valueOf(2.5f)},\n+                new Object[]{z_field, obj, Boolean.valueOf(true)},\n+                new Object[]{o_field, obj, \"good-value\"},\n+                new Object[]{override_i_field, obj, Integer.valueOf(10)},\n+                new Object[]{override_c_field, obj, Character.valueOf('c')},\n+                new Object[]{override_b_field, obj, Byte.valueOf((byte)1)},\n+                new Object[]{override_s_field, obj, Short.valueOf((short)2)},\n+                new Object[]{override_l_field, obj, Long.valueOf(1000)},\n+                new Object[]{override_d_field, obj, Double.valueOf(1.2)},\n+                new Object[]{override_f_field, obj, Float.valueOf(2.5f)},\n+                new Object[]{override_z_field, obj, Boolean.valueOf(true)},\n+                new Object[]{override_o_field, obj, \"good-value\"},\n+                \/\/ instance final fields with setAccessible(true)\n+                new Object[]{override_fi_field, obj, Integer.valueOf(10)},\n+                new Object[]{override_fc_field, obj, Character.valueOf('c')},\n+                new Object[]{override_fb_field, obj, Byte.valueOf((byte)1)},\n+                new Object[]{override_fs_field, obj, Short.valueOf((short)2)},\n+                new Object[]{override_fl_field, obj, Long.valueOf(1000)},\n+                new Object[]{override_fd_field, obj, Double.valueOf(1.2)},\n+                new Object[]{override_ff_field, obj, Float.valueOf(2.5f)},\n+                new Object[]{override_fz_field, obj, Boolean.valueOf(true)},\n+                new Object[]{override_fo_field, obj, \"good-value\"},\n+                \/\/ static fields with and without setAccessible(true)\n+                new Object[]{si_field, null, Integer.valueOf(10)},\n+                new Object[]{sc_field, null, Character.valueOf('c')},\n+                new Object[]{sb_field, null, Byte.valueOf((byte)1)},\n+                new Object[]{ss_field, null, Short.valueOf((short)2)},\n+                new Object[]{sl_field, null, Long.valueOf(1000)},\n+                new Object[]{sd_field, null, Double.valueOf(1.2)},\n+                new Object[]{sf_field, null, Float.valueOf(2.5f)},\n+                new Object[]{sz_field, null, Boolean.valueOf(true)},\n+                new Object[]{so_field, null, \"good-value\"},\n+                new Object[]{override_si_field, null, Integer.valueOf(10)},\n+                new Object[]{override_sc_field, null, Character.valueOf('c')},\n+                new Object[]{override_sb_field, null, Byte.valueOf((byte)1)},\n+                new Object[]{override_ss_field, null, Short.valueOf((short)2)},\n+                new Object[]{override_sl_field, null, Long.valueOf(1000)},\n+                new Object[]{override_sd_field, null, Double.valueOf(1.2)},\n+                new Object[]{override_sf_field, null, Float.valueOf(2.5f)},\n+                new Object[]{override_sz_field, null, Boolean.valueOf(true)},\n+                new Object[]{override_so_field, null, \"good-value\"},\n+        };\n+    }\n+\n+    \/*\n+     * Test Field::set with a good and bad value.\n+     * Test setting to null if the field type is primitive.\n+     *\n+     * IllegalArgumentException is thrown if the value is of a bad type or null.\n+     * NullPointerException is thrown if the receiver of an instance field is null.\n+     * The receiver is checked\n+     *\/\n+    @Test(dataProvider = \"writeableFields\")\n+    public void testSetValue(Field f, Object obj, Object value) throws IllegalAccessException {\n+        f.set(obj, value);\n+        Class<?> fType = f.getType();\n+        if (fType.isPrimitive()) {\n+            switch (fType.descriptorString()) {\n+                case \"B\" -> f.setByte(obj, ((Byte) value).byteValue());\n+                case \"C\" -> f.setChar(obj, ((Character) value).charValue());\n+                case \"D\" -> f.setDouble(obj, ((Double) value).doubleValue());\n+                case \"F\" -> f.setFloat(obj, ((Float) value).floatValue());\n+                case \"I\" -> f.setInt(obj, ((Integer) value).intValue());\n+                case \"J\" -> f.setLong(obj, ((Long) value).longValue());\n+                case \"S\" -> f.setShort(obj, ((Short) value).shortValue());\n+                case \"Z\" -> f.setBoolean(obj, ((Boolean) value).booleanValue());\n+            }\n+\n+            \/\/ test null value only if it's primitive type\n+            try {\n+                f.set(obj, null);\n+                fail(\"expected IllegalArgumentException\");\n+            } catch (IllegalArgumentException e) {\n+                \/\/ expected\n+            }\n+        }\n+\n+        Object badValue = new NegativeTest();\n+        try {\n+            f.set(obj, badValue);\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    @DataProvider(name = \"readOnlyFinalFields\")\n+    private Object[][] readOnlyFinalFields() {\n+        Object obj = INSTANCE;\n+        return new Object[][]{\n+                \/\/ instance final fields\n+                new Object[]{fi_field, obj, Integer.valueOf(10)},\n+                new Object[]{fc_field, obj, Character.valueOf('c')},\n+                new Object[]{fb_field, obj, Byte.valueOf((byte)1)},\n+                new Object[]{fs_field, obj, Short.valueOf((short)2)},\n+                new Object[]{fl_field, obj, Long.valueOf(1000)},\n+                new Object[]{fd_field, obj, Double.valueOf(1.2)},\n+                new Object[]{ff_field, obj, Float.valueOf(2.5f)},\n+                new Object[]{fz_field, obj, Boolean.valueOf(true)},\n+                new Object[]{fo_field, obj, \"good-value\"},\n+                \/\/ static final fields\n+                new Object[]{sfi_field, null, Integer.valueOf(10)},\n+                new Object[]{sfc_field, null, Character.valueOf('c')},\n+                new Object[]{sfb_field, null, Byte.valueOf((byte)1)},\n+                new Object[]{sfs_field, null, Short.valueOf((short)2)},\n+                new Object[]{sfl_field, null, Long.valueOf(1000)},\n+                new Object[]{sfd_field, null, Double.valueOf(1.2)},\n+                new Object[]{sff_field, null, Float.valueOf(2.5f)},\n+                new Object[]{sfz_field, null, Boolean.valueOf(true)},\n+                new Object[]{sfo_field, null, \"good-value\"},\n+                new Object[]{override_sfi_field, null, Integer.valueOf(10)},\n+                new Object[]{override_sfc_field, null, Character.valueOf('c')},\n+                new Object[]{override_sfb_field, null, Byte.valueOf((byte)1)},\n+                new Object[]{override_sfs_field, null, Short.valueOf((short)2)},\n+                new Object[]{override_sfl_field, null, Long.valueOf(1000)},\n+                new Object[]{override_sfd_field, null, Double.valueOf(1.2)},\n+                new Object[]{override_sff_field, null, Float.valueOf(2.5f)},\n+                new Object[]{override_sfz_field, null, Boolean.valueOf(true)},\n+                new Object[]{override_sfo_field, null, \"good-value\"},\n+        };\n+    }\n+\n+    \/*\n+     * Test Field::set on a read-only final field.\n+     * IllegalAccessException is thrown regardless of whether the value\n+     * is of a bad type or not.\n+     *\/\n+    @Test(dataProvider = \"readOnlyFinalFields\")\n+    public void testSetValueOnFinalField(Field f, Object obj, Object value) {\n+        assertTrue(Modifier.isFinal(f.getModifiers()));\n+        try {\n+            f.set(obj, value);\n+            fail(\"expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            \/\/ expected\n+        }\n+\n+        Class<?> fType = f.getType();\n+        if (fType.isPrimitive()) {\n+            try {\n+                switch (fType.descriptorString()) {\n+                    case \"B\" -> f.setByte(obj, ((Byte)value).byteValue());\n+                    case \"C\" -> f.setChar(obj, ((Character)value).charValue());\n+                    case \"D\" -> f.setDouble(obj, ((Double)value).doubleValue());\n+                    case \"F\" -> f.setFloat(obj, ((Float)value).floatValue());\n+                    case \"I\" -> f.setInt(obj, ((Integer)value).intValue());\n+                    case \"J\" -> f.setLong(obj, ((Long)value).longValue());\n+                    case \"S\" -> f.setShort(obj, ((Short)value).shortValue());\n+                    case \"Z\" -> f.setBoolean(obj, ((Boolean)value).booleanValue());\n+                }\n+                fail(\"expected IllegalAccessException\");\n+            } catch (IllegalAccessException e) {\n+                \/\/ expected\n+            }\n+\n+            \/\/ test null value only if it's primitive type\n+            try {\n+                f.set(obj, null);\n+                fail(\"expected IllegalAccessException\");\n+            } catch (IllegalAccessException e) {\n+                \/\/ expected\n+            }\n+        }\n+\n+        Object badValue = new NegativeTest();\n+        try {\n+            f.set(obj, badValue);\n+            fail(\"expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+\n+\n+    @DataProvider(name = \"finalInstanceFields\")\n+    private Object[][] finalInstanceFields() {\n+        return new Object[][]{\n+                new Object[]{fi_field, Integer.valueOf(10)},\n+                new Object[]{fc_field, Character.valueOf('c')},\n+                new Object[]{fb_field, Byte.valueOf((byte) 1)},\n+                new Object[]{fs_field, Short.valueOf((short) 2)},\n+                new Object[]{fl_field, Long.valueOf(1000)},\n+                new Object[]{fd_field, Double.valueOf(1.2)},\n+                new Object[]{ff_field, Float.valueOf(2.5f)},\n+                new Object[]{fz_field, Boolean.valueOf(true)},\n+                new Object[]{fo_field, \"good-value\"},\n+        };\n+    }\n+\n+    \/*\n+     * Test Field::set on a final instance field with either a bad receiver\n+     * or null.  IllegalArgumentException is thrown if the receiver is of\n+     * a bad type.  NullPointerException is thrown if the receiver is null.\n+     * The receiver is checked before the access check is performed and\n+     * also before the value is checked.\n+     *\/\n+    @Test(dataProvider = \"finalInstanceFields\")\n+    public void testReceiverOnFinalField(Field f, Object value) {\n+        assertTrue(Modifier.isFinal(f.getModifiers()));\n+        Object badReceiver = new NegativeTest();\n+        \/\/ set the field with a bad receiver with a good value\n+        try {\n+            f.set(badReceiver, value);\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            \/\/ expected\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(\"Expected IllegalArgumentException but got: \" + e.getMessage(), e);\n+        }\n+\n+        \/\/ set the field with a bad receiver with a bad value\n+        Object badValue = new NegativeTest();\n+        try {\n+            f.set(badReceiver, badValue);\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            \/\/ expected\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(\"Expected IllegalArgumentException but got: \" + e.getMessage(), e);\n+        }\n+\n+        \/\/ set the field with a null receiver with a good value\n+        try {\n+            f.set(null, value);\n+            fail(\"expected NullPointerException\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(\"Expected NullPointerException but got: \" + e.getMessage(), e);\n+        }\n+        \/\/ set the field with a null receiver with a bad value\n+        try {\n+            f.set(null, badValue);\n+            fail(\"expected NullPointerException\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(\"Expected NullPointerException but got: \" + e.getMessage(), e);\n+        }\n+\n+        Class<?> fType = f.getType();\n+        if (fType.isPrimitive()) {\n+            \/\/ test bad receiver\n+            try {\n+                switch (fType.descriptorString()) {\n+                    case \"B\" -> f.setByte(badReceiver, ((Byte) value).byteValue());\n+                    case \"C\" -> f.setChar(badReceiver, ((Character) value).charValue());\n+                    case \"D\" -> f.setDouble(badReceiver, ((Double) value).doubleValue());\n+                    case \"F\" -> f.setFloat(badReceiver, ((Float) value).floatValue());\n+                    case \"I\" -> f.setInt(badReceiver, ((Integer) value).intValue());\n+                    case \"J\" -> f.setLong(badReceiver, ((Long) value).longValue());\n+                    case \"S\" -> f.setShort(badReceiver, ((Short) value).shortValue());\n+                    case \"Z\" -> f.setBoolean(badReceiver, ((Boolean) value).booleanValue());\n+                }\n+            } catch (IllegalArgumentException e) {\n+            } catch (IllegalAccessException e) {\n+                throw new RuntimeException(\"Expected IllegalArgumentException but got: \" + e.getMessage(), e);\n+            }\n+            \/\/ test null receiver\n+            try {\n+                switch (fType.descriptorString()) {\n+                    case \"B\" -> f.setByte(null, ((Byte) value).byteValue());\n+                    case \"C\" -> f.setChar(null, ((Character) value).charValue());\n+                    case \"D\" -> f.setDouble(null, ((Double) value).doubleValue());\n+                    case \"F\" -> f.setFloat(null, ((Float) value).floatValue());\n+                    case \"I\" -> f.setInt(null, ((Integer) value).intValue());\n+                    case \"J\" -> f.setLong(null, ((Long) value).longValue());\n+                    case \"S\" -> f.setShort(null, ((Short) value).shortValue());\n+                    case \"Z\" -> f.setBoolean(null, ((Boolean) value).booleanValue());\n+                }\n+            } catch (NullPointerException e) {\n+                \/\/ expected\n+            } catch (IllegalAccessException e) {\n+                throw new RuntimeException(\"Expected NullPointerException but got: \" + e.getMessage(), e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/NegativeTest.java","additions":582,"deletions":0,"binary":false,"changes":582,"status":"added"},{"patch":"@@ -118,0 +118,2 @@\n+        private static String name = \"name\";\n+        private byte b = 9;\n@@ -133,0 +135,5 @@\n+        public Public(byte b) {\n+            this.b = b;\n+            this.i = 0;\n+            this.s = null;\n+        }\n@@ -165,0 +172,1 @@\n+                   \", b=\" + b +\n@@ -388,2 +396,5 @@\n-    private static final Throwable[] cannot_get_final_field = new Throwable[] {\n-            new IllegalArgumentException(\"Can not get final\")\n+    private static final Throwable[] cannot_get_field = new Throwable[] {\n+            new IllegalArgumentException(\"Can not get\")\n+    };\n+    private static final Throwable[] cannot_set_field = new Throwable[] {\n+            new IllegalArgumentException(\"Can not set\")\n@@ -391,2 +402,2 @@\n-    private static final Throwable[] cannot_set_final_field = new Throwable[] {\n-            new IllegalArgumentException(\"Can not set final\")\n+    private static final Throwable[] mismatched_field_type = new Throwable[] {\n+            new IllegalArgumentException(\"Can not set\")\n@@ -595,0 +606,1 @@\n+        String wrongInst = new String();\n@@ -598,2 +610,0 @@\n-                new Object[]{\"s\", new Object(), \"test\",\n-                             newImpl ? cannot_get_final_field : cannot_set_final_field},\n@@ -601,0 +611,4 @@\n+                new Object[]{\"s\", wrongInst, \"test\",\n+                        newImpl ? cannot_get_field : cannot_set_field},\n+                new Object[]{\"b\", wrongInst, 0,\n+                        newImpl ? cannot_get_field : cannot_set_field},\n@@ -605,0 +619,2 @@\n+        Object o = new Object();\n+        byte b = 1;\n@@ -607,0 +623,1 @@\n+                new Object[]{\"i\", new Public(100), 100, Integer.valueOf(10), noException},\n@@ -608,3 +625,0 @@\n-                \/\/ ## no exception thrown\n-                \/\/ new Object[]{\"i\", new Public(100), 100, new Object(), cannot_set_final_field},\n-                new Object[]{\"s\", new Object(), \"test\", \"dummy\", cannot_set_final_field},\n@@ -612,0 +626,4 @@\n+                new Object[]{\"b\", new Public(b), b, null, mismatched_field_type},\n+                new Object[]{\"b\", new Public(b), b, Long.valueOf(10), mismatched_field_type},\n+                new Object[]{\"name\", null, \"name\", o, mismatched_field_type},\n+                new Object[]{\"i\", new Public(100), 100, o, mismatched_field_type},\n","filename":"test\/jdk\/java\/lang\/reflect\/MethodHandleAccessorsTest.java","additions":27,"deletions":9,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -334,2 +334,2 @@\n-                } else if (cookie.size() == 2 && !cookie.get(1).equals(\"ORDER=BISCUITS\")) {\n-                    String msg = \"Incorrect cookie header value:[\" + cookie.get(0) + \"]\";\n+                } else if (cookie.size() > 1 && !cookie.get(1).equals(\"ORDER=BISCUITS\")) {\n+                    String msg = \"Incorrect cookie header value:[\" + cookie.get(1) + \"]\";\n","filename":"test\/jdk\/java\/net\/httpclient\/CookieHeaderTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,3 @@\n- * @bug 8199851\n- * @summary Test for multiple vs single cookie header for HTTP\/2 vs HTTP\/1.1\n+ * @bug 8276774\n+ * @summary Test that user-supplied cookies are appended to\n+ *          server-cookies for HTTP\/2 vs HTTP\/1.1\n@@ -40,1 +41,1 @@\n- *       CookieHeaderTest\n+ *       UserCookieTest\n@@ -43,11 +44,0 @@\n-import com.sun.net.httpserver.HttpServer;\n-import com.sun.net.httpserver.HttpsConfigurator;\n-import com.sun.net.httpserver.HttpsServer;\n-import jdk.test.lib.net.SimpleSSLContext;\n-import org.testng.annotations.AfterTest;\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import javax.net.ServerSocketFactory;\n-import javax.net.ssl.SSLContext;\n@@ -61,1 +51,0 @@\n-import java.net.CookieManager;\n@@ -75,1 +64,0 @@\n-import java.util.HashMap;\n@@ -85,0 +73,11 @@\n+import javax.net.ServerSocketFactory;\n+import javax.net.ssl.SSLContext;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n@@ -89,1 +88,0 @@\n-import static org.testng.Assert.assertTrue;\n@@ -91,1 +89,1 @@\n-public class CookieHeaderTest implements HttpServerAdapters {\n+public class UserCookieTest implements HttpServerAdapters {\n@@ -156,0 +154,5 @@\n+        String userCookie = \"PRICE=42\";\n+        List<String> expectedCookies =\n+                Stream.concat(cookies.stream(), Stream.of(userCookie)).toList();\n+\n+\n@@ -158,1 +161,2 @@\n-                .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet());\n+                .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                .header(\"Cookie\", userCookie);\n@@ -175,1 +179,1 @@\n-                    cookies.stream()\n+                    expectedCookies.stream()\n@@ -177,1 +181,1 @@\n-                            .collect(Collectors.toList()));\n+                            .toList());\n@@ -179,1 +183,2 @@\n-                    .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet());\n+                    .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                    .header(\"Cookie\", userCookie);\n@@ -245,1 +250,1 @@\n-        @Override\n+        @java.lang.Override\n@@ -252,1 +257,1 @@\n-        @Override\n+        @java.lang.Override\n@@ -263,1 +268,1 @@\n-        @Override\n+        @java.lang.Override\n@@ -334,2 +339,7 @@\n-                } else if (cookie.size() == 2 && !cookie.get(1).equals(\"ORDER=BISCUITS\")) {\n-                    String msg = \"Incorrect cookie header value:[\" + cookie.get(0) + \"]\";\n+                } else if (cookie.size() > 1 && !cookie.get(1).equals(\"ORDER=BISCUITS\")) {\n+                    String msg = \"Incorrect cookie header value:[\" + cookie.get(1) + \"]\";\n+                     (new RuntimeException(msg)).printStackTrace();\n+                    t.sendResponseHeaders(500, -1);\n+                    os.write(msg.getBytes(UTF_8));\n+                } else if (cookie.size() > 2 && !cookie.get(2).equals(\"PRICE=42\")) {\n+                    String msg = \"Incorrect cookie header value:[\" + cookie.get(2) + \"]\";\n@@ -339,1 +349,1 @@\n-                } else if (cookie.size() != 2) {\n+                } else if (cookie.size() != 3) {\n@@ -396,1 +406,1 @@\n-        @Override\n+        @java.lang.Override\n@@ -473,1 +483,1 @@\n-                        if (values.size() != 2) {\n+                        if (values.size() != 3) {\n@@ -482,0 +492,3 @@\n+                        } else if (!values.get(2).equals(\"PRICE=42\")) {\n+                            resp = \"Unexpected cookie: \" + values.get(1) + \" in \" + values;\n+                            status = \"500 Internal Server Error\";\n","filename":"test\/jdk\/java\/net\/httpclient\/UserCookieTest.java","additions":44,"deletions":31,"binary":false,"changes":75,"previous_filename":"test\/jdk\/java\/net\/httpclient\/CookieHeaderTest.java","status":"copied"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.function.Consumer;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertThrows;\n+\n+\/**\n+ * @test\n+ * @bug 8277087\n+ * @summary Verifies various use cases when the zip comment should be empty\n+ * @run testng EmptyComment\n+ *\/\n+public final class EmptyComment {\n+\n+    @DataProvider()\n+    Object[][] longLengths() {\n+        return new Object[][]{{0xFFFF + 1}, {0xFFFF + 2}, {0xFFFF * 2}};\n+    }\n+\n+    \/**\n+     * Overflow, the text is too long to be stored as a comment.\n+     *\/\n+    @Test(dataProvider = \"longLengths\")\n+    void testOverflow(int length) throws Exception {\n+        test(zos -> assertThrows(IllegalArgumentException.class, () -> {\n+            zos.setComment(\"X\".repeat(length));\n+        }));\n+    }\n+\n+    \/**\n+     * Simple cases where the comment is set to the empty text.\n+     *\/\n+    @Test\n+    void testSimpleCases() throws Exception {\n+        test(zos -> {\/* do nothing *\/});\n+        test(zos -> zos.setComment(null));\n+        test(zos -> zos.setComment(\"\"));\n+        test(zos -> {\n+            zos.setComment(\"\");\n+            zos.setComment(null);\n+        });\n+        test(zos -> {\n+            zos.setComment(null);\n+            zos.setComment(\"\");\n+        });\n+        test(zos -> {\n+            zos.setComment(\"Comment\");\n+            zos.setComment(null);\n+        });\n+        test(zos -> {\n+            zos.setComment(\"Comment\");\n+            zos.setComment(\"\");\n+        });\n+    }\n+\n+    private static void test(Consumer<ZipOutputStream> test) throws Exception {\n+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+             ZipOutputStream zos = new ZipOutputStream(baos)) {\n+\n+            test.accept(zos);\n+\n+            zos.putNextEntry(new ZipEntry(\"x\"));\n+            zos.finish();\n+\n+            byte[] data = baos.toByteArray();\n+\n+            if (data.length > 0xFFFF) { \/\/ just in case\n+                throw new RuntimeException(\"data is too big: \" + data.length);\n+            }\n+            int pk = data.length - ZipFile.ENDHDR;\n+            if (data[pk] != 'P' || data[pk + 1] != 'K') {\n+                throw new RuntimeException(\"PK is not found\");\n+            }\n+            \/\/ Since the comment is empty this will be two last bytes\n+            int pos = data.length - ZipFile.ENDHDR + ZipFile.ENDCOM;\n+\n+            int len = (data[pos] & 0xFF) + ((data[pos + 1] & 0xFF) << 8);\n+            if (len != 0) {\n+                throw new RuntimeException(\"zip comment is not empty: \" + len);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipOutputStream\/EmptyComment.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -58,1 +58,1 @@\n- *      8247960 8242068 8269039\n+ *      8247960 8242068 8269039 8275887\n@@ -343,0 +343,1 @@\n+                        .shouldNotMatch(\"Signature.*(disabled)\")\n@@ -359,0 +360,2 @@\n+                        .shouldNotContain(\"option is considered a security \" +\n+                            \"risk and is disabled\")\n@@ -422,0 +425,11 @@\n+                        .shouldNotContain(\"The SHA-256 algorithm specified \" +\n+                            \"for the -digestalg option is considered a \" +\n+                            \"security risk\")\n+                        .shouldNotContain(\"The SHA256withRSA algorithm \" +\n+                            \"specified for the -sigalg option is considered \" +\n+                            \"a security risk\")\n+                        .shouldNotContain(\"The SHA-256 algorithm specified \" +\n+                            \"for the -tsadigestalg option is considered a \" +\n+                            \"security risk\")\n+                        .shouldContain(\"The RSA signing key has a keysize \" +\n+                            \"of 1024 which is considered a security risk\")\n@@ -676,1 +690,1 @@\n-                .shouldMatch(\"SignatureException:.*keysize\");\n+                .shouldMatch(\"SignatureException:.*MD5\");\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/TimestampCheck.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8276764\n+ * @summary test that the jar content ordering is sorted\n+ * @library \/test\/lib\n+ * @modules jdk.jartool\n+ * @build jdk.test.lib.Platform\n+ *        jdk.test.lib.util.FileUtils\n+ * @run testng ContentOrder\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.UncheckedIOException;\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipException;\n+\n+import jdk.test.lib.util.FileUtils;\n+\n+public class ContentOrder {\n+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\")\n+        .orElseThrow(() ->\n+            new RuntimeException(\"jar tool not found\")\n+        );\n+\n+    private final String nl = System.lineSeparator();\n+    private final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    private final PrintStream out = new PrintStream(baos);\n+    private Runnable onCompletion;\n+\n+    @BeforeMethod\n+    public void reset() {\n+        onCompletion = null;\n+    }\n+\n+    @AfterMethod\n+    public void run() {\n+        if (onCompletion != null) {\n+            onCompletion.run();\n+        }\n+    }\n+\n+    \/\/ Test that the jar content ordering when processing a single directory is sorted\n+    @Test\n+    public void testSingleDir() throws IOException {\n+        mkdir(\"testjar\/Ctest1\", \"testjar\/Btest2\/subdir1\", \"testjar\/Atest3\");\n+        touch(\"testjar\/Ctest1\/testfile1\", \"testjar\/Ctest1\/testfile2\", \"testjar\/Ctest1\/testfile3\");\n+        touch(\"testjar\/Btest2\/subdir1\/testfileC\", \"testjar\/Btest2\/subdir1\/testfileB\", \"testjar\/Btest2\/subdir1\/testfileA\");\n+        touch(\"testjar\/Atest3\/fileZ\", \"testjar\/Atest3\/fileY\", \"testjar\/Atest3\/fileX\");\n+\n+        onCompletion = () -> rm(\"test.jar\", \"testjar\");\n+\n+        jar(\"cf test.jar testjar\");\n+        jar(\"tf test.jar\");\n+        System.out.println(new String(baos.toByteArray()));\n+        String output = \"META-INF\/\" + nl +\n+                \"META-INF\/MANIFEST.MF\" + nl +\n+                \"testjar\/\" + nl +\n+                \"testjar\/Atest3\/\" + nl +\n+                \"testjar\/Atest3\/fileX\" + nl +\n+                \"testjar\/Atest3\/fileY\" + nl +\n+                \"testjar\/Atest3\/fileZ\" + nl +\n+                \"testjar\/Btest2\/\" + nl +\n+                \"testjar\/Btest2\/subdir1\/\" + nl +\n+                \"testjar\/Btest2\/subdir1\/testfileA\" + nl +\n+                \"testjar\/Btest2\/subdir1\/testfileB\" + nl +\n+                \"testjar\/Btest2\/subdir1\/testfileC\" + nl +\n+                \"testjar\/Ctest1\/\" + nl +\n+                \"testjar\/Ctest1\/testfile1\" + nl +\n+                \"testjar\/Ctest1\/testfile2\" + nl +\n+                \"testjar\/Ctest1\/testfile3\" + nl;\n+        Assert.assertEquals(baos.toByteArray(), output.getBytes());\n+    }\n+\n+    \/\/ Test that when specifying multiple directories or releases that the sort\n+    \/\/ ordering is done on each directory and release, reserving the order of\n+    \/\/ the directories\/releases specified on the command line\n+    @Test\n+    public void testMultiDirWithReleases() throws IOException {\n+        mkdir(\"testjar\/foo\/classes\",\n+              \"testjar\/foo11\/classes\/Zclasses\",\n+              \"testjar\/foo11\/classes\/Yclasses\",\n+              \"testjar\/foo17\/classes\/Bclasses\",\n+              \"testjar\/foo17\/classes\/Aclasses\");\n+        touch(\"testjar\/foo\/classes\/testfile1\", \"testjar\/foo\/classes\/testfile2\");\n+        touch(\"testjar\/foo11\/classes\/Zclasses\/testfile1\", \"testjar\/foo11\/classes\/Zclasses\/testfile2\");\n+        touch(\"testjar\/foo11\/classes\/Yclasses\/testfileA\", \"testjar\/foo11\/classes\/Yclasses\/testfileB\");\n+        touch(\"testjar\/foo17\/classes\/Bclasses\/testfile1\", \"testjar\/foo17\/classes\/Bclasses\/testfile2\");\n+        touch(\"testjar\/foo17\/classes\/Aclasses\/testfileA\", \"testjar\/foo17\/classes\/Aclasses\/testfileB\");\n+\n+        onCompletion = () -> rm(\"test.jar\", \"testjar\");\n+\n+        jar(\"cf test.jar -C testjar\/foo classes \" +\n+            \"--release 17 -C testjar\/foo17 classes\/Bclasses -C testjar\/foo17 classes\/Aclasses \" +\n+            \"--release 11 -C testjar\/foo11 classes\/Zclasses -C testjar\/foo11 classes\/Yclasses\");\n+        jar(\"tf test.jar\");\n+        System.out.println(new String(baos.toByteArray()));\n+        String output = \"META-INF\/\" + nl +\n+                \"META-INF\/MANIFEST.MF\" + nl +\n+                \"classes\/\" + nl +\n+                \"classes\/testfile1\" + nl +\n+                \"classes\/testfile2\" + nl +\n+                \"META-INF\/versions\/17\/classes\/Bclasses\/\" + nl +\n+                \"META-INF\/versions\/17\/classes\/Bclasses\/testfile1\" + nl +\n+                \"META-INF\/versions\/17\/classes\/Bclasses\/testfile2\" + nl +\n+                \"META-INF\/versions\/17\/classes\/Aclasses\/\" + nl +\n+                \"META-INF\/versions\/17\/classes\/Aclasses\/testfileA\" + nl +\n+                \"META-INF\/versions\/17\/classes\/Aclasses\/testfileB\" + nl +\n+                \"META-INF\/versions\/11\/classes\/Zclasses\/\" + nl +\n+                \"META-INF\/versions\/11\/classes\/Zclasses\/testfile1\" + nl +\n+                \"META-INF\/versions\/11\/classes\/Zclasses\/testfile2\" + nl +\n+                \"META-INF\/versions\/11\/classes\/Yclasses\/\" + nl +\n+                \"META-INF\/versions\/11\/classes\/Yclasses\/testfileA\" + nl +\n+                \"META-INF\/versions\/11\/classes\/Yclasses\/testfileB\" + nl;\n+        Assert.assertEquals(baos.toByteArray(), output.getBytes());\n+    }\n+\n+    private Stream<Path> mkpath(String... args) {\n+        return Arrays.stream(args).map(d -> Paths.get(\".\", d.split(\"\/\")));\n+    }\n+\n+    private void mkdir(String... dirs) {\n+        System.out.println(\"mkdir -p \" + Arrays.toString(dirs));\n+        Arrays.stream(dirs).forEach(p -> {\n+            try {\n+                Files.createDirectories((new File(p)).toPath());\n+            } catch (IOException x) {\n+                throw new UncheckedIOException(x);\n+            }\n+        });\n+    }\n+\n+    private void touch(String... files) {\n+        System.out.println(\"touch \" + Arrays.toString(files));\n+        Arrays.stream(files).forEach(p -> {\n+            try {\n+                Files.createFile((new File(p)).toPath());\n+            } catch (IOException x) {\n+                throw new UncheckedIOException(x);\n+            }\n+        });\n+    }\n+\n+    private void rm(String... files) {\n+        System.out.println(\"rm -rf \" + Arrays.toString(files));\n+        Arrays.stream(files).forEach(p -> {\n+            try {\n+                Path path = (new File(p)).toPath();\n+                if (Files.isDirectory(path)) {\n+                    FileUtils.deleteFileTreeWithRetry(path);\n+                } else {\n+                    FileUtils.deleteFileIfExistsWithRetry(path);\n+                }\n+            } catch (IOException x) {\n+                throw new UncheckedIOException(x);\n+            }\n+        });\n+    }\n+\n+    private void jar(String cmdline) throws IOException {\n+        System.out.println(\"jar \" + cmdline);\n+        baos.reset();\n+\n+        \/\/ the run method catches IOExceptions, we need to expose them\n+        ByteArrayOutputStream baes = new ByteArrayOutputStream();\n+        PrintStream err = new PrintStream(baes);\n+        PrintStream saveErr = System.err;\n+        System.setErr(err);\n+        int rc = JAR_TOOL.run(out, err, cmdline.split(\" +\"));\n+        System.setErr(saveErr);\n+        if (rc != 0) {\n+            String s = baes.toString();\n+            if (s.startsWith(\"java.util.zip.ZipException: duplicate entry: \")) {\n+                throw new ZipException(s);\n+            }\n+            throw new IOException(s);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jar\/ContentOrder.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1096,3 +1096,0 @@\n-        if (!TOOL_VM_OPTIONS.isEmpty()) {\n-            commands.addAll(Arrays.asList(TOOL_VM_OPTIONS.split(\"\\\\s+\", -1)));\n-        }\n","filename":"test\/jdk\/tools\/jar\/modularJar\/Basic.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.module.ModuleDescriptor;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarInputStream;\n+import java.util.spi.ToolProvider;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/**\n+ * @test\n+ * @bug 8258117\n+ * @summary Tests that the content generated for module-info.class, using the jar command, is reproducible\n+ * @run testng JarToolModuleDescriptorReproducibilityTest\n+ *\/\n+public class JarToolModuleDescriptorReproducibilityTest {\n+\n+    private static final String MODULE_NAME = \"foo\";\n+    private static final String MODULE_VERSION = \"1.2.3\";\n+    private static final String UPDATED_MODULE_VERSION = \"1.2.4\";\n+    private static final String MAIN_CLASS = \"jdk.test.foo.Foo\";\n+    private static final Path MODULE_CLASSES_DIR = Path.of(\"8258117-module-classes\", MODULE_NAME).toAbsolutePath();\n+\n+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\")\n+            .orElseThrow(()\n+                    -> new RuntimeException(\"jar tool not found\")\n+            );\n+    private static final ToolProvider JAVAC_TOOL = ToolProvider.findFirst(\"javac\")\n+            .orElseThrow(()\n+                    -> new RuntimeException(\"javac tool not found\")\n+            );\n+\n+\n+    @BeforeClass\n+    public static void setup() throws Exception {\n+        compileModuleClasses();\n+    }\n+\n+    \/**\n+     * Launches a \"jar --create\" command multiple times with a module-info.class. The module-info.class\n+     * is internally updated by the jar tool to add additional data. Expects that each such generated\n+     * jar has the exact same bytes.\n+     *\/\n+    @Test\n+    public void testJarCreate() throws Exception {\n+        List<Path> jarFiles = new ArrayList<>();\n+        for (int i = 0; i < 3; i++) {\n+            Path targetJar = Files.createTempFile(Path.of(\".\"), \"8258117-jar-create\", \".jar\");\n+            jarFiles.add(targetJar);\n+            if (i > 0) {\n+                \/\/ the timestamp that gets embedded in (Zip\/Jar)Entry gets narrowed\n+                \/\/ down to SECONDS unit. So we make sure that there's at least a second\n+                \/\/ gap between the jar file creations, to be sure that the jar file\n+                \/\/ was indeed generated at \"different times\"\n+                Thread.sleep(1000);\n+            }\n+            \/\/ create a modular jar\n+            runJarCommand(\"--create\",\n+                    \"--file=\" + targetJar,\n+                    \"--main-class=\" + MAIN_CLASS,\n+                    \"--module-version=\" + MODULE_VERSION,\n+                    \"--no-manifest\",\n+                    \"-C\", MODULE_CLASSES_DIR.toString(), \".\");\n+            \/\/ verify the module descriptor in the jar\n+            assertExpectedModuleInfo(targetJar, MODULE_VERSION);\n+        }\n+        assertAllFileContentsAreSame(jarFiles);\n+    }\n+\n+    \/**\n+     * Launches a \"jar --update\" process multiple times to update the module-info.class\n+     * descriptor with the same content and then expects that the modular jar created by\n+     * each of these processes has the exact same bytes.\n+     *\/\n+    @Test\n+    public void testJarUpdate() throws Exception {\n+        List<Path> jarFiles = new ArrayList<>();\n+        for (int i = 0; i < 3; i++) {\n+            Path targetJar = Files.createTempFile(Path.of(\".\"), \"8258117-jar-update\", \".jar\");\n+            jarFiles.add(targetJar);\n+            if (i > 0) {\n+                \/\/ the timestamp that gets embedded in (Zip\/Jar)Entry gets narrowed\n+                \/\/ down to SECONDS unit. So we make sure that there's at least a second\n+                \/\/ gap between the jar file creations, to be sure that the jar file\n+                \/\/ was indeed generated at \"different times\"\n+                Thread.sleep(1000);\n+            }\n+            \/\/ first create the modular jar\n+            runJarCommand(\"--create\",\n+                    \"--file=\" + targetJar,\n+                    \"--module-version=\" + MODULE_VERSION,\n+                    \"--no-manifest\",\n+                    \"-C\", MODULE_CLASSES_DIR.toString(), \".\");\n+            assertExpectedModuleInfo(targetJar, MODULE_VERSION);\n+            \/\/ now update the same modular jar\n+            runJarCommand(\"--update\",\n+                    \"--file=\" + targetJar,\n+                    \"--module-version=\" + UPDATED_MODULE_VERSION,\n+                    \"--no-manifest\",\n+                    \"-C\", MODULE_CLASSES_DIR.toString(), \"module-info.class\");\n+            \/\/ verify the module descriptor in the jar\n+            assertExpectedModuleInfo(targetJar, UPDATED_MODULE_VERSION);\n+        }\n+        assertAllFileContentsAreSame(jarFiles);\n+    }\n+\n+    \/\/ compiles using javac tool the classes used in the test module\n+    private static void compileModuleClasses() throws Exception {\n+        Path sourcePath = Path.of(System.getProperty(\"test.src\", \".\"),\n+                \"src\", MODULE_NAME);\n+        List<String> sourceFiles = new ArrayList<>();\n+        Files.walkFileTree(sourcePath, new SimpleFileVisitor<>() {\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                if (file.toString().endsWith(\".java\")) {\n+                    sourceFiles.add(file.toString());\n+                }\n+                return FileVisitResult.CONTINUE;\n+            }\n+        });\n+        Path classesDir = Files.createDirectories(MODULE_CLASSES_DIR);\n+        List<String> javacArgs = new ArrayList<>();\n+        javacArgs.add(\"-d\");\n+        javacArgs.add(classesDir.toString());\n+        sourceFiles.forEach((f) -> javacArgs.add(f));\n+        System.out.println(\"Launching javac command with args: \" + javacArgs);\n+        StringWriter sw = new StringWriter();\n+        try (PrintWriter pw = new PrintWriter(sw)) {\n+            int exitCode = JAVAC_TOOL.run(pw, pw, javacArgs.toArray(new String[0]));\n+            assertEquals(exitCode, 0, \"Module compilation failed: \" + sw.toString());\n+        }\n+        System.out.println(\"Module classes successfully compiled to directory \" + classesDir);\n+    }\n+\n+    \/\/ runs the \"jar\" command passing it the \"jarArgs\" and verifying that the command\n+    \/\/ execution didn't fail\n+    private static void runJarCommand(String... jarArgs) {\n+        StringWriter sw = new StringWriter();\n+        System.out.println(\"Launching jar command with args: \" + Arrays.toString(jarArgs));\n+        try (PrintWriter pw = new PrintWriter(sw)) {\n+            int exitCode = JAR_TOOL.run(pw, pw, jarArgs);\n+            assertEquals(exitCode, 0, \"jar command execution failed: \" + sw.toString());\n+        }\n+    }\n+\n+    \/\/ verifies the byte equality of the contents in each of the files\n+    private static void assertAllFileContentsAreSame(List<Path> files) throws Exception {\n+        Path firstFile = files.get(0);\n+        for (int i = 1; i < files.size(); i++) {\n+            assertEquals(Files.mismatch(firstFile, files.get(i)), -1,\n+                    \"Content in file \" + files.get(i) + \" isn't the same as in file \" + firstFile);\n+        }\n+    }\n+\n+    \/\/ verifies that a module-info.class is present in the jar and the module name and version are the expected\n+    \/\/ ones\n+    private static void assertExpectedModuleInfo(Path jar, String expectedModuleVersion) throws Exception {\n+        try (JarInputStream jaris = new JarInputStream(Files.newInputStream(jar))) {\n+            JarEntry moduleInfoEntry = null;\n+            JarEntry entry = null;\n+            while ((entry = jaris.getNextJarEntry()) != null) {\n+                if (entry.getName().equals(\"module-info.class\")) {\n+                    moduleInfoEntry = entry;\n+                    break;\n+                }\n+            }\n+            assertNotNull(moduleInfoEntry, \"module-info.class is missing from jar \" + jar);\n+\n+            ModuleDescriptor md = ModuleDescriptor.read(jaris);\n+            assertEquals(md.name(), MODULE_NAME, \"Unexpected module name\");\n+            assertFalse(md.rawVersion().isEmpty(), \"Module version missing from descriptor\");\n+\n+            String actualVersion = md.rawVersion().get();\n+            assertEquals(actualVersion, expectedModuleVersion, \"Unexpected module version\");\n+\n+            System.out.println(moduleInfoEntry.getName() + \" has a timestamp of \"\n+                    + moduleInfoEntry.getTime() + \" for version \" + actualVersion);\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/tools\/jar\/modularJar\/JarToolModuleDescriptorReproducibilityTest.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,0 @@\n-        commands.addAll(Utils.getForwardVmOptions());\n","filename":"test\/jdk\/tools\/jar\/multiRelease\/MRTestBase.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8142968 8166568 8166286 8170618 8168149 8240910\n+ * @bug 8142968 8166568 8166286 8170618 8168149 8240910 8276764\n@@ -200,0 +200,11 @@\n+\n+                \/\/ JDK-8276764: Ensure the order is sorted for reproducible jmod content\n+                \/\/ module-info, followed by <sorted classes>\n+                int mod_info_i = r.output.indexOf(CLASSES_PREFIX + \"module-info.class\");\n+                int foo_cls_i  = r.output.indexOf(CLASSES_PREFIX + \"jdk\/test\/foo\/Foo.class\");\n+                int msg_i      = r.output.indexOf(CLASSES_PREFIX + \"jdk\/test\/foo\/internal\/Message.class\");\n+                int res_i      = r.output.indexOf(CLASSES_PREFIX + \"jdk\/test\/foo\/resources\/foo.properties\");\n+                System.out.println(\"jmod classes sort order check:\\n\"+r.output);\n+                assertTrue(mod_info_i < foo_cls_i);\n+                assertTrue(foo_cls_i < msg_i);\n+                assertTrue(msg_i < res_i);\n","filename":"test\/jdk\/tools\/jmod\/JmodTest.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.ObjIntConsumer;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class SnippetTester extends JavadocTester {\n+\n+    protected final ToolBox tb = new ToolBox();\n+\n+    protected void checkOrder(Output output, String... strings) {\n+        new OutputChecker(output).setExpectOrdered(true).check(strings);\n+    }\n+\n+    \/*\n+     * When checking for errors, it is important not to confuse one error with\n+     * another. This method checks that there are no crashes (which are also\n+     * errors) by checking for stack traces. We never expect crashes.\n+     *\/\n+    protected void checkNoCrashes() {\n+        checking(\"check crashes\");\n+        Matcher matcher = Pattern.compile(\"\\\\s*at.*\\\\(.*\\\\.java:\\\\d+\\\\)\")\n+                .matcher(getOutput(Output.STDERR));\n+        if (!matcher.find()) {\n+            passed(\"\");\n+        } else {\n+            failed(\"Looks like a stacktrace: \" + matcher.group());\n+        }\n+    }\n+\n+    \/*\n+     * This is a convenience method to iterate through a list.\n+     * Unlike List.forEach, this method provides the consumer not only with an\n+     * element but also that element's index.\n+     *\n+     * See JDK-8184707.\n+     *\/\n+    protected static <T> void forEachNumbered(List<T> list, ObjIntConsumer<? super T> action) {\n+        for (var iterator = list.listIterator(); iterator.hasNext(); ) {\n+            action.accept(iterator.next(), iterator.previousIndex());\n+        }\n+    }\n+\n+    \/\/ TODO:\n+    \/\/   Explore the toolbox.ToolBox.writeFile and toolbox.ToolBox.writeJavaFiles methods:\n+    \/\/   see if any of them could be used instead of this one\n+    protected static void addSnippetFile(Path srcDir, String packageName, String fileName, String content)\n+            throws UncheckedIOException\n+    {\n+        String[] components = packageName.split(\"\\\\.\");\n+        Path snippetFiles = Path.of(components[0], Arrays.copyOfRange(components, 1, components.length)).resolve(\"snippet-files\");\n+        try {\n+            Path p = Files.createDirectories(srcDir.resolve(snippetFiles));\n+            Files.writeString(p.resolve(fileName), content, StandardOpenOption.CREATE_NEW);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    protected void checkOutputEither(Output out, String first, String... other) {\n+        var strings = Stream.concat(Stream.of(first), Stream.of(other))\n+                .toArray(String[]::new);\n+        new OutputChecker(out).checkAnyOf(strings);\n+    }\n+\n+    protected String getSnippetHtmlRepresentation(String pathToHtmlFile,\n+                                                  String content) {\n+        return getSnippetHtmlRepresentation(pathToHtmlFile, content, Optional.empty(), Optional.empty());\n+    }\n+\n+    protected String getSnippetHtmlRepresentation(String pathToHtmlFile,\n+                                                  String content,\n+                                                  Optional<String> lang) {\n+        return getSnippetHtmlRepresentation(pathToHtmlFile, content, lang, Optional.empty());\n+    }\n+\n+    protected String getSnippetHtmlRepresentation(String pathToHtmlFile,\n+                                                  String content,\n+                                                  Optional<String> lang,\n+                                                  Optional<String> id) {\n+        \/\/ the further away from the root, the further to reach to common resources\n+        int nComponents = (int) pathToHtmlFile.chars().filter(c -> c == '\/').count();\n+        var svgString = \"..\/\".repeat(nComponents) + \"copy.svg\";\n+        var idString = id.isEmpty() ? \"\" : \" id=\\\"%s\\\"\".formatted(id.get());\n+        var langString = lang.isEmpty() ? \"\" : \" class=\\\"language-%s\\\"\".formatted(lang.get());\n+        return \"\"\"\n+                <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySnippet(this)\">\\\n+                <span data-copied=\"Copied!\">Copy<\/span><img src=\"%s\" alt=\"Copy\"><\/button>\n+                <pre class=\"snippet\"%s><code%s>%s<\/code><\/pre>\n+                <\/div>\"\"\".formatted(svgString, idString, langString, content);\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/SnippetTester.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266666\n+ * @summary Implementation for snippets\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build javadoc.tester.* toolbox.ToolBox toolbox.ModuleBuilder builder.ClassBuilder\n+ * @run main TestLangProperties\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public class TestLangProperties extends SnippetTester {\n+\n+    public static void main(String... args) throws Exception {\n+        new TestLangProperties().runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    @Test\n+    public void testPositiveOuterMarkup(Path base) throws Exception {\n+        var testCases = new ArrayList<TestSnippetMarkup.TestCase>();\n+        for (String whitespace1 : List.of(\"\", \" \", \"\\t\"))\n+            for (String commentIndicator1 : List.of(\"#\", \"!\"))\n+                for (String whitespace2 : List.of(\"\", \" \", \"\\t\")) {\n+                    String markup = whitespace1 + commentIndicator1\n+                            + whitespace2 + \"@highlight :\";\n+                    var t = new TestSnippetMarkup.TestCase(\n+                            \"\"\"\n+                                    %s\n+                                    coffee=espresso\n+                                    tea=black\n+                                    \"\"\".formatted(markup),\n+                            \"\"\"\n+\n+                                    <span class=\"bold\">coffee=espresso\n+                                    <\/span>tea=black\n+                                    \"\"\");\n+                    testCases.add(t);\n+                }\n+        testPositive(base, testCases);\n+    }\n+\n+    @Test\n+    public void testPositiveInnerMarkup(Path base) throws Exception {\n+        var testCases = new ArrayList<TestSnippetMarkup.TestCase>();\n+        for (String whitespace1 : List.of(\"\", \" \", \"\\t\"))\n+            for (String commentIndicator1 : List.of(\"#\", \"!\"))\n+                for (String whitespace2 : List.of(\"\", \" \", \"\\t\"))\n+                    for (String unrelatedComment : List.of(\"a comment\"))\n+                        for (String whitespace3 : List.of(\"\", \" \"))\n+                            for (String commentIndicator2 : List.of(\"#\", \"!\")) {\n+                                String payload = whitespace1 + commentIndicator1 + whitespace2 + unrelatedComment;\n+                                String markup = payload + whitespace3 + commentIndicator2 + \"@highlight :\";\n+                                var t = new TestSnippetMarkup.TestCase(\n+                                        \"\"\"\n+                                                %s\n+                                                coffee=espresso\n+                                                tea=black\n+                                                \"\"\".formatted(markup),\n+                                        \"\"\"\n+                                                %s\n+                                                <span class=\"bold\">coffee=espresso\n+                                                <\/span>tea=black\n+                                                \"\"\".formatted(payload));\n+                                testCases.add(t);\n+                            }\n+        testPositive(base, testCases);\n+    }\n+\n+    @Test\n+    public void testPositiveIneffectiveOuterMarkup(Path base) throws Exception {\n+        var testCases = new ArrayList<TestSnippetMarkup.TestCase>();\n+        for (String whitespace1 : List.of(\"\", \" \", \"\\t\"))\n+            for (String commentIndicator1 : List.of(\"#\", \"!\"))\n+                for (String whitespace2 : List.of(\"\", \" \", \"\\t\")) {\n+                    String ineffectiveMarkup = whitespace1\n+                            + commentIndicator1 + whitespace2\n+                            + \"@highlight :\";\n+                    var t = new TestSnippetMarkup.TestCase(\n+                            \"\"\"\n+                                    coffee=espresso%s\n+                                    tea=black\n+                                    \"\"\".formatted(ineffectiveMarkup),\n+                            \"\"\"\n+                                    coffee=espresso%s\n+                                    tea=black\n+                                    \"\"\".formatted(ineffectiveMarkup));\n+                    testCases.add(t);\n+                }\n+        testPositive(base, testCases);\n+    }\n+\n+    @Test\n+    public void testPositiveIneffectiveInnerMarkup(Path base) throws Exception {\n+        var testCases = new ArrayList<TestSnippetMarkup.TestCase>();\n+        for (String whitespace1 : List.of(\"\", \" \", \"\\t\"))\n+            for (String commentIndicator1 : List.of(\"#\", \"!\"))\n+                for (String whitespace2 : List.of(\"\", \" \", \"\\t\"))\n+                    for (String unrelatedComment : List.of(\"a comment\"))\n+                        for (String whitespace3 : List.of(\"\", \" \"))\n+                            for (String commentIndicator2 : List.of(\"#\", \"!\")) {\n+                                String ineffectiveMarkup = whitespace1\n+                                        + commentIndicator1 + whitespace2\n+                                        + unrelatedComment + whitespace3\n+                                        + commentIndicator2 + \"@highlight :\";\n+                                var t = new TestSnippetMarkup.TestCase(\n+                                        \"\"\"\n+                                                coffee=espresso%s\n+                                                tea=black\n+                                                \"\"\".formatted(ineffectiveMarkup),\n+                                        \"\"\"\n+                                                coffee=espresso%s\n+                                                tea=black\n+                                                \"\"\".formatted(ineffectiveMarkup));\n+                                testCases.add(t);\n+                            }\n+        testPositive(base, testCases);\n+    }\n+\n+    private void testPositive(Path base, List<TestSnippetMarkup.TestCase> testCases)\n+            throws IOException {\n+        StringBuilder methods = new StringBuilder();\n+        forEachNumbered(testCases, (i, n) -> {\n+            String r = i.region().isBlank() ? \"\" : \"region=\" + i.region();\n+            var methodDef = \"\"\"\n+\n+                    \/**\n+                    {@snippet lang=\"properties\" %s:\n+                    %s}*\/\n+                    public void case%s() {}\n+                    \"\"\".formatted(r, i.input(), n);\n+            methods.append(methodDef);\n+        });\n+        var classDef = \"\"\"\n+                public class A {\n+                %s\n+                }\n+                \"\"\".formatted(methods.toString());\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.writeJavaFiles(src, classDef);\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"A.java\").toString());\n+        checkExit(Exit.OK);\n+        checkNoCrashes();\n+        forEachNumbered(testCases, (t, index) -> {\n+            String html = \"\"\"\n+                    <span class=\"element-name\">case%s<\/span>()<\/div>\n+                    <div class=\"block\">\n+                    %s\n+                    <\/div>\"\"\".formatted(index, getSnippetHtmlRepresentation(\"A.html\",\n+                    t.expectedOutput(), Optional.of(\"properties\")));\n+            checkOutput(\"A.html\", true, html);\n+        });\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestLangProperties.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -0,0 +1,574 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266666\n+ * @summary Implementation for snippets\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build javadoc.tester.* toolbox.ToolBox toolbox.ModuleBuilder builder.ClassBuilder\n+ * @run main TestSnippetMarkup\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+import java.util.regex.MatchResult;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.NestingKind;\n+import javax.tools.FileObject;\n+import javax.tools.JavaFileObject;\n+import javax.tools.StandardJavaFileManager;\n+import javax.tools.ToolProvider;\n+\n+import builder.ClassBuilder;\n+import toolbox.ToolBox;\n+\n+import static javax.tools.DocumentationTool.Location.DOCUMENTATION_OUTPUT;\n+\n+public class TestSnippetMarkup extends SnippetTester {\n+\n+    public static void main(String... args) throws Exception {\n+        new TestSnippetMarkup().runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    \/*\n+     * The semantics of expectedOutput depends on the test case this record is\n+     * used in.\n+     *\/\n+    record TestCase(String region, String input, String expectedOutput) {\n+        TestCase(String input, String expectedOutput) {\n+            this(\"\", input, expectedOutput);\n+        }\n+    }\n+\n+    \/\/ @highlight [region|region=<name>]\n+    \/\/            [regex=<val>|substring=<val>]\n+    \/\/            [type=bold|italics|highlighted]\n+    \/\/            [:]\n+    @Test\n+    public void testHighlight(Path base) throws Exception {\n+        var testCases = List.of(\n+                new TestCase( \/\/ FIXME: newline should not be included\n+                        \"\"\"\n+                                First line  \/\/ @highlight\n+                                  Second line\n+                                \"\"\",\n+                        \"\"\"\n+                                <span class=\"bold\">First line\n+                                <\/span>  Second line\n+                                \"\"\"),\n+                new TestCase(\n+                        \"\"\"\n+                                First line  \/\/ @highlight regex=\"\\\\w\" type=\"bold\"\n+                                  Second line\n+                                \"\"\",\n+                        \"\"\"\n+                                <span class=\"bold\">First<\/span> <span class=\"bold\">line<\/span>\n+                                  Second line\n+                                \"\"\"),\n+                new TestCase( \/\/ FIXME: newline should not be included\n+                        \"\"\"\n+                                First line  \/\/ @highlight @highlight regex=\"\\\\w\" type=\"bold\"\n+                                  Second line\n+                                \"\"\",\n+                        \"\"\"\n+                                <span class=\"bold\">First line\n+                                <\/span>  Second line\n+                                \"\"\"\n+                ));\n+        testPositive(base, testCases);\n+    }\n+\n+    \/\/ @replace [region|region=<name>]\n+    \/\/          [regex=<val>|substring=<val>]\n+    \/\/          [replacement=<val>]\n+    \/\/          [:]\n+    @Test\n+    public void testReplace(Path base) throws Exception {\n+        var testCases = List.of(\n+                new TestCase(\n+                        \"\"\"\n+                                First line  \/\/ @replace regex=\"\\\\w\" replacement=\".\"\n+                                  Second line\n+                                \"\"\",\n+                        \"\"\"\n+                                ..... ....\n+                                  Second line\n+                                \"\"\"),\n+                new TestCase( \/\/ \"substring\" is not treated like \"regex\"\n+                        \"\"\"\n+                                First line  \/\/ @replace substring=\"\\\\w\" replacement=\".\"\n+                                  Second line\n+                                \"\"\",\n+                        \"\"\"\n+                                First line\n+                                  Second line\n+                                \"\"\"\n+                ),\n+                new TestCase(\n+                        \"\"\"\n+                                First line  \/\/ @replace substring=\"i\" replacement=\".\"\n+                                  Second line\n+                                \"\"\",\n+                        \"\"\"\n+                                F.rst l.ne\n+                                  Second line\n+                                \"\"\"\n+                ));\n+        testPositive(base, testCases);\n+    }\n+\n+    \/\/ @link [region|region=<name>]\n+    \/\/       [regex=<val>|substring=<val>]\n+    \/\/       [target=<val>]\n+    \/\/       [type=link|linkplain]\n+    \/\/       [:]\n+    @Test\n+    public void testLink(Path base) throws Exception {\n+        var testCases = List.of(\n+                new TestCase(\n+                        \"\"\"\n+                                First line  \/\/ @link regex=\"\\\\w\" target=\"java.lang.Object#Object\"\n+                                  Second line\n+                                \"\"\",\n+                        replace(\"\"\"\n+                                link(First) link(line)\n+                                  Second line\n+                                \"\"\", \"link\\\\((.+?)\\\\)\", r -> link(true, \"java.lang.Object#Object\", r.group(1)))\n+                ));\n+        testPositive(base, testCases);\n+    }\n+\n+    @Test\n+    public void testCornerCases(Path base) throws Exception {\n+        var testCases = List.of(\n+                new TestCase( \/\/ This is how one might represent a unicode escape sequence uninterpreted, if required.\n+                        \"\"\"\n+                                \\\\$0041  \/\/ @replace substring=\"$\" replacement=\"u\"\n+                                \"\"\",\n+                        \"\"\"\n+                                \\\\u0041\n+                                \"\"\"\n+                ),\n+                new TestCase( \/\/ This is how one might represent `*\/` without ending an enclosing comment, if required.\n+                              \/\/ A non-whitespace character that is also not `*` is needed before `*` so that `*`\n+                              \/\/ is not confused with the optional doc comment decoration.\n+                              \/\/ (We cannot use, for example, `**$` or ` *$`.)\n+                        \"\"\"\n+                                a*$  \/\/ @replace substring=\"$\" replacement=\"\/\"\n+                                \"\"\",\n+                        \"\"\"\n+                                a*\/\n+                                \"\"\"\n+                ),\n+                new TestCase( \/\/ This is how one might output markup, if required.\n+                              \/\/ Append a no-op markup since only the rightmost markup is parsed.\n+                        \"\"\"\n+                                \/\/ @highlight \/\/ @start region=throwaway @end\n+                                \"\"\",\n+                        \"\"\"\n+                                \/\/ @highlight\n+                                \"\"\"\n+                )\n+        );\n+        testPositive(base, testCases);\n+    }\n+\n+    \/*\n+     * For all but the last line of snippet source, next-line markup behaves\n+     * as if that markup without the next-line modifier were put on that\n+     * next line.\n+     *\/\n+\/\/    @Test\n+    public void testPositiveInlineExternalTagMarkup_NextLine(Path base) throws Exception {\n+        throw new RuntimeException(\"Not yet implemented\");\n+    }\n+\n+    \/*\n+     * If next-line markup is put on the last line of a snippet source,\n+     * an error occurs.\n+     *\/\n+    @Test\n+    public void testNegativeInlineExternalHybridTagMarkup_NextLinePutOnLastLine(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        var goodFile = \"good.txt\";\n+        var badFile = \"bad.txt\";\n+        var badFile2 = \"bad2.txt\"; \/\/ to workaround error deduplication\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        ClassBuilder.MethodBuilder\n+                                .parse(\"public void inline() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet :\n+                                             First line \/\/ @highlight :\n+                                             }\n+                                             \"\"\"))\n+                .addMembers(\n+                        ClassBuilder.MethodBuilder\n+                                .parse(\"public void external() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet file=\"%s\"}\n+                                             \"\"\".formatted(badFile)))\n+                .addMembers(\n+                        ClassBuilder.MethodBuilder\n+                                .parse(\"public void hybrid1() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet file=\"%s\":\n+                                             First line\n+                                             }\n+                                             \"\"\".formatted(badFile2)))\n+                .addMembers(\n+                        ClassBuilder.MethodBuilder\n+                                .parse(\"public void hybrid2() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet file=\"%s\":\n+                                             First line \/\/ @highlight :\n+                                             }\n+                                             \"\"\".formatted(goodFile)))\n+                \/\/ TODO: these two hybrids are to test what *this* test should not test.\n+                \/\/  Add a test that checks that an error in either part\n+                \/\/  of a hybrid snippet causes the snippet to fail (property-based testing)\n+                .write(srcDir);\n+        addSnippetFile(srcDir, \"pkg\", goodFile, \"\"\"\n+First line \/\/ @highlight\n+ \"\"\");\n+        addSnippetFile(srcDir, \"pkg\", badFile, \"\"\"\n+First line \/\/ @highlight :\n+ \"\"\");\n+        addSnippetFile(srcDir, \"pkg\", badFile2, \"\"\"\n+First line \/\/ @highlight :\n+ \"\"\");\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+\"\"\"\n+A.java:5: error: snippet markup: tag refers to non-existent lines\n+First line \/\/ @highlight :\n+               ^\"\"\",\n+\"\"\"\n+A.java:24: error: snippet markup: tag refers to non-existent lines\n+First line \/\/ @highlight :\n+               ^\"\"\",\n+\"\"\"\n+%s:1: error: snippet markup: tag refers to non-existent lines\n+First line \/\/ @highlight :\n+               ^\"\"\".formatted(badFile),\n+\"\"\"\n+%s:1: error: snippet markup: tag refers to non-existent lines\n+First line \/\/ @highlight :\n+               ^\"\"\".formatted(badFile2));\n+        checkNoCrashes();\n+    }\n+\n+    private void testPositive(Path base, List<TestCase> testCases)\n+            throws IOException {\n+        StringBuilder methods = new StringBuilder();\n+        forEachNumbered(testCases, (i, n) -> {\n+            String r = i.region.isBlank() ? \"\" : \"region=\" + i.region;\n+            var methodDef = \"\"\"\n+\n+                    \/**\n+                    {@snippet %s:\n+                    %s}*\/\n+                    public void case%s() {}\n+                    \"\"\".formatted(r, i.input, n);\n+            methods.append(methodDef);\n+        });\n+        var classDef = \"\"\"\n+                public class A {\n+                %s\n+                }\n+                \"\"\".formatted(methods.toString());\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.writeJavaFiles(src, classDef);\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"A.java\").toString());\n+        checkExit(Exit.OK);\n+        checkNoCrashes();\n+        forEachNumbered(testCases, (t, index) -> {\n+            String html = \"\"\"\n+                        <span class=\"element-name\">case%s<\/span>()<\/div>\n+                        <div class=\"block\">\n+                        %s\n+                        <\/div>\"\"\".formatted(index, getSnippetHtmlRepresentation(\"A.html\", t.expectedOutput()));\n+            checkOutput(\"A.html\", true, html);\n+        });\n+    }\n+\n+    \/\/ FIXME: move error (i.e. negative) tests from TestSnippetTag to here\n+\n+    \/\/ @start region=<name> ... @end [region|region=<name>]\n+    @Test\n+    public void testStart(Path base) throws Exception {\n+        var testCases = new ArrayList<TestCase>();\n+        for (var variant : generateStartEndVariants()) {\n+            var t = new TestCase(variant.region,\n+                    \"\"\"\n+                            First line\n+                              Second line \/\/ ###START\n+                              Third line\n+                              Fourth line \/\/ ###END\n+                            Fifth line\n+                            \"\"\".replaceFirst(\"###START\", variant.start)\n+                            .replaceFirst(\"###END\", variant.end),\n+                    \"\"\"\n+                            Second line\n+                            Third line\n+                            Fourth line\"\"\");\n+            testCases.add(t);\n+        }\n+        testPositive(base, testCases);\n+    }\n+\n+    private static String link(boolean linkPlain,\n+                               String targetReference,\n+                               String content)\n+            throws UncheckedIOException {\n+\n+        \/\/ The HTML <a> tag generated from the @link snippet markup tag is the\n+        \/\/ same as that of the {@link} Standard doclet tag. This is specified\n+        \/\/ and can be used for comparison and testing.\n+\n+        \/\/ generate documentation for {@link} to grab its HTML <a> tag;\n+        \/\/ generate documentation at low cost and do not interfere with the\n+        \/\/ calling test state; for that, do not create file trees, do not write\n+        \/\/ to std out\/err, and generally try to keep everything in memory\n+\n+        String source = \"\"\"\n+                \/** {@link %s %s} *\/\n+                public interface A { }\n+                \"\"\".formatted(targetReference, content);\n+\n+        JavaFileObject src = new JavaFileObject() {\n+            @Override\n+            public Kind getKind() {return Kind.SOURCE;}\n+\n+            @Override\n+            public boolean isNameCompatible(String simpleName, Kind kind) {\n+                return kind == Kind.SOURCE;\n+            }\n+\n+            @Override\n+            public NestingKind getNestingKind() {return NestingKind.TOP_LEVEL;}\n+\n+            @Override\n+            public Modifier getAccessLevel() {return Modifier.PUBLIC;}\n+\n+            @Override\n+            public URI toUri() {throw new UnsupportedOperationException();}\n+\n+            @Override\n+            public String getName() {return \"A.java\";}\n+\n+            @Override\n+            public InputStream openInputStream() {\n+                return new ByteArrayInputStream(source.getBytes(StandardCharsets.UTF_8));\n+            }\n+\n+            @Override\n+            public OutputStream openOutputStream() {\n+                throw new UnsupportedOperationException(\"Read only\");\n+            }\n+\n+            @Override\n+            public Reader openReader(boolean ignoreEncodingErrors) {\n+                return new StringReader(source);\n+            }\n+\n+            @Override\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+                return source;\n+            }\n+\n+            @Override\n+            public Writer openWriter() {\n+                throw new UnsupportedOperationException(\"Read only\");\n+            }\n+\n+            @Override\n+            public long getLastModified() {\n+                return 0;\n+            }\n+\n+            @Override\n+            public boolean delete() {\n+                throw new UnsupportedOperationException(\"Read only\");\n+            }\n+        };\n+\n+        var documentationTool = ToolProvider.getSystemDocumentationTool();\n+        var writer = new StringWriter();\n+\n+        \/\/ FileManager has to be StandardJavaFileManager; JavaDoc is adamant about it\n+        class InMemoryFileManager extends ToolBox.MemoryFileManager\n+                implements StandardJavaFileManager {\n+\n+            private final StandardJavaFileManager delegate = documentationTool\n+                    .getStandardFileManager(null, null, null);\n+\n+            @Override\n+            public Iterable<? extends JavaFileObject> getJavaFileObjectsFromFiles(Iterable<? extends File> files) {\n+                return delegate.getJavaFileObjectsFromFiles(files);\n+            }\n+\n+            @Override\n+            public Iterable<? extends JavaFileObject> getJavaFileObjects(File... files) {\n+                return delegate.getJavaFileObjects(files);\n+            }\n+\n+            @Override\n+            public Iterable<? extends JavaFileObject> getJavaFileObjectsFromStrings(Iterable<String> names) {\n+                return delegate.getJavaFileObjectsFromStrings(names);\n+            }\n+\n+            @Override\n+            public Iterable<? extends JavaFileObject> getJavaFileObjects(String... names) {\n+                return delegate.getJavaFileObjects(names);\n+            }\n+\n+            @Override\n+            public void setLocation(Location location, Iterable<? extends File> files) throws IOException {\n+                delegate.setLocation(location, files);\n+            }\n+\n+            @Override\n+            public Iterable<? extends File> getLocation(Location location) {\n+                return delegate.getLocation(location);\n+            }\n+\n+            @Override\n+            public FileObject getFileForOutput(Location location,\n+                                               String packageName,\n+                                               String relativeName,\n+                                               FileObject sibling) {\n+                return getJavaFileForOutput(location, packageName + relativeName, JavaFileObject.Kind.OTHER, null);\n+            }\n+        }\n+        try {\n+            var fileManager = new InMemoryFileManager();\n+            fileManager.setLocation(DOCUMENTATION_OUTPUT, Collections.singleton(new File(\".\")));\n+            \/\/ exclude extraneous output; we're only after @link\n+            List<String> options = List.of(\"--limit-modules\", \"java.base\",\n+                    \"-quiet\", \"-nohelp\", \"-noindex\", \"-nonavbar\", \"-nosince\",\n+                    \"-notimestamp\", \"-notree\", \"-Xdoclint:none\");\n+            var documentationTask = documentationTool.getTask(null, fileManager,\n+                    null, null, options, List.of(src));\n+            if (!documentationTask.call()) {\n+                throw new IOException(writer.toString());\n+            }\n+            String output = fileManager.getFileString(DOCUMENTATION_OUTPUT, \"A.html\");\n+            \/\/ use the [^<>] regex to select HTML elements that immediately enclose \"content\"\n+            Matcher m = Pattern.compile(\"(?is)<a href=\\\"[^<>]*\\\" title=\\\"[^<>]*\\\" class=\\\"[^<>]*\\\"><code>\"\n+                    + content + \"<\/code><\/a>\").matcher(output);\n+            if (!m.find()) {\n+                throw new IOException(output);\n+            }\n+            return m.group(0);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    private static String replace(String source,\n+                                  String regex,\n+                                  Function<MatchResult, String> replacer) {\n+        return Pattern.compile(regex).matcher(source).replaceAll(replacer);\n+    }\n+\n+    private static final AtomicLong UNIQUE_INTEGER_NUMBER = new AtomicLong();\n+\n+    private static Collection<StartEndVariant> generateStartEndVariants() {\n+        var variants = new ArrayList<StartEndVariant>();\n+        for (var start : startAttributes())\n+            for (var end : endAttributes()) {\n+                var region = uniqueValue();\n+                var v = new StartEndVariant(region,\n+                        \"@start\" + start.apply(region),\n+                        \"@end\" + end.apply(region));\n+                variants.add(v);\n+            }\n+        return variants;\n+    }\n+\n+    private static String uniqueValue() {\n+        return \"auto_generated_value_\" + UNIQUE_INTEGER_NUMBER.incrementAndGet();\n+    }\n+\n+    public static Collection<Function<String, String>> startAttributes() {\n+        return attributes(\"region\");\n+    }\n+\n+    private static Collection<Function<String, String>> endAttributes() {\n+        var variants = new ArrayList<Function<String, String>>();\n+        variants.add(value -> \"\");\n+        variants.add(value -> \" region\");\n+        variants.addAll(attributes(\"region\"));\n+        return variants;\n+    }\n+\n+    private static Collection<Function<String, String>> attributes(String name) {\n+        var variants = new ArrayList<Function<String, String>>();\n+        for (var whitespace1 : List.of(\" \", \"  \"))\n+            for (var whitespace2 : List.of(\"\", \" \"))\n+                for (var quote : List.of(\"\", \"'\", \"\\\"\"))\n+                    for (var whitespace3 : List.of(\"\", \" \")) {\n+                        Function<String, String> f = value ->\n+                                whitespace1 + name + whitespace2\n+                                        + \"=\" + whitespace3 + (quote + value + quote);\n+                        variants.add(f);\n+                    }\n+        return variants;\n+    }\n+\n+    record StartEndVariant(String region, String start, String end) {}\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestSnippetMarkup.java","additions":574,"deletions":0,"binary":false,"changes":574,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266666\n+ * @summary Implementation for snippets\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build javadoc.tester.* toolbox.ToolBox toolbox.ModuleBuilder builder.ClassBuilder\n+ * @run main TestSnippetPathOption\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class TestSnippetPathOption extends SnippetTester {\n+\n+    public static void main(String... args) throws Exception {\n+        new TestSnippetPathOption().runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    \/*\n+        #   snippet-files   snippet-path   result\n+       ---+--------------+--------------+---------------------\n+        1         +              +         snippet-files\n+        2         +           invalid      snippet-files\n+        3         -              +         snippet-path\n+        4         -           invalid      error\n+     *\/\n+\n+    @Test\n+    public void test1(Path base) throws Exception {\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.createDirectories(src.resolve(\"directoryA\"), src.resolve(\"directoryB\"));\n+        tb.writeFile(src.resolve(\"directoryA\/mysnippet.txt\"), \"Hello, directoryA!\");\n+        tb.writeFile(src.resolve(\"directoryB\/mysnippet.txt\"), \"Hello, directoryB!\");\n+        tb.writeFile(src.resolve(\"pkg\/snippet-files\/mysnippet.txt\"), \"Hello, snippet-files!\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                               package pkg;\n+\n+                               \/** {@snippet file=\"mysnippet.txt\"} *\/\n+                               public class X { }\n+                               \"\"\");\n+        String snippetPathValue = Stream.of(\"directoryA\", \"directoryB\")\n+                .map(src::resolve)\n+                .map(Path::toAbsolutePath)\n+                .map(Path::toString)\n+                .collect(Collectors.joining(File.pathSeparator));\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--snippet-path\", snippetPathValue,\n+                \"-sourcepath\", src.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"pkg\/X.html\", true, \"Hello, snippet-files!\");\n+        checkOutput(\"pkg\/X.html\", false, \"Hello, directoryA!\");\n+        checkOutput(\"pkg\/X.html\", false, \"Hello, directoryB!\");\n+    }\n+\n+    @Test\n+    public void test2(Path base) throws Exception {\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.createDirectories(src.resolve(\"directoryA\"), src.resolve(\"directoryB\"));\n+        tb.writeFile(src.resolve(\"pkg\/snippet-files\/mysnippet.txt\"), \"Hello, snippet-files!\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                               package pkg;\n+\n+                               \/** {@snippet file=\"mysnippet.txt\"} *\/\n+                               public class X { }\n+                               \"\"\");\n+        String snippetPathValue = Stream.of(\"directoryA\", \"directoryB\")\n+                .map(src::resolve)\n+                .map(Path::toAbsolutePath)\n+                .map(Path::toString)\n+                .collect(Collectors.joining(File.pathSeparator));\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--snippet-path\", snippetPathValue,\n+                \"-sourcepath\", src.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"pkg\/X.html\", true, \"Hello, snippet-files!\");\n+    }\n+\n+    @Test\n+    public void test3(Path base) throws Exception {\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.createDirectories(src.resolve(\"directoryA\"), src.resolve(\"directoryB\"));\n+        tb.writeFile(src.resolve(\"directoryA\/mysnippet.txt\"), \"Hello, directoryA!\");\n+        tb.writeFile(src.resolve(\"directoryB\/mysnippet.txt\"), \"Hello, directoryB!\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                               package pkg;\n+\n+                               \/** {@snippet file=\"mysnippet.txt\"} *\/\n+                               public class X { }\n+                               \"\"\");\n+        String snippetPathValue = Stream.of(\"directoryA\", \"directoryB\")\n+                .map(src::resolve)\n+                .map(Path::toAbsolutePath)\n+                .map(Path::toString)\n+                .collect(Collectors.joining(File.pathSeparator));\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--snippet-path\", snippetPathValue,\n+                \"-sourcepath\", src.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"pkg\/X.html\", true, \"Hello, directoryA!\");\n+        checkOutput(\"pkg\/X.html\", false, \"Hello, directoryB!\");\n+    }\n+\n+    @Test\n+    public void test4(Path base) throws Exception {\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.writeJavaFiles(src, \"\"\"\n+                               package pkg;\n+\n+                               \/** {@snippet file=\"mysnippet.txt\"} *\/\n+                               public class X { }\n+                               \"\"\");\n+        String snippetPathValue = Stream.of(\"directoryA\", \"directoryB\")\n+                .map(src::resolve)\n+                .map(Path::toAbsolutePath)\n+                .map(Path::toString)\n+                .collect(Collectors.joining(File.pathSeparator));\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--snippet-path\", snippetPathValue,\n+                \"-sourcepath\", src.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+    }\n+\n+    \/*\n+     * Tests that the elements of the snippet path are iteratively searched\n+     * until the file is found. In particular, tests that if the file is not\n+     * immediately found, the search is not abandoned.\n+     *\/\n+    @Test\n+    public void testSearchPath(Path base) throws Exception {\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.createDirectories(src.resolve(\"directoryA\"), src.resolve(\"directoryB\"));\n+        \/\/ do not put snippet in directoryA; only put snippet in directoryB\n+        tb.writeFile(src.resolve(\"directoryB\/mysnippet.txt\"), \"Hello, directoryB!\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                               package pkg;\n+\n+                               \/** {@snippet file=\"mysnippet.txt\"} *\/\n+                               public class X { }\n+                               \"\"\");\n+        \/\/ directoryA goes first, assuming that paths are searched in\n+        \/\/ the same order they are specified in\n+        String snippetPathValue = Stream.of(\"directoryA\", \"directoryB\")\n+                .map(src::resolve)\n+                .map(Path::toAbsolutePath)\n+                .map(Path::toString)\n+                .collect(Collectors.joining(File.pathSeparator));\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--snippet-path\", snippetPathValue,\n+                \"-sourcepath\", src.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"pkg\/X.html\", true, \"Hello, directoryB!\");\n+    }\n+\n+    \/*\n+     * Tests translation from FQN (the \"class\" attribute) to file path\n+     * (the \"file\" attribute).\n+     *\/\n+    @Test\n+    public void testClassToFile(Path base) throws Exception {\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        Path directoryA = Files.createDirectories(src.resolve(\"directoryA\"));\n+        tb.writeJavaFiles(directoryA, \"\"\"\n+                                      package com.example.snippet;\n+\n+                                      public interface Y { }\n+                                      \"\"\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                               package pkg;\n+\n+                               \/** {@snippet class=\"com.example.snippet.Y\"} *\/\n+                               public class X { }\n+                               \"\"\");\n+        String snippetPathValue = Stream.of(\"directoryA\")\n+                .map(src::resolve)\n+                .map(Path::toAbsolutePath)\n+                .map(Path::toString)\n+                .collect(Collectors.joining(File.pathSeparator));\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--snippet-path\", snippetPathValue,\n+                \"-sourcepath\", src.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"pkg\/X.html\", true, \"public interface Y { }\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestSnippetPathOption.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -36,6 +36,0 @@\n-import builder.ClassBuilder;\n-import builder.ClassBuilder.MethodBuilder;\n-import javadoc.tester.JavadocTester;\n-import toolbox.ModuleBuilder;\n-import toolbox.ToolBox;\n-\n@@ -43,1 +37,0 @@\n-import java.io.UncheckedIOException;\n@@ -48,1 +41,1 @@\n-import java.util.Arrays;\n+import java.util.ArrayList;\n@@ -53,2 +46,0 @@\n-import java.util.function.ObjIntConsumer;\n-import java.util.regex.Matcher;\n@@ -56,1 +47,4 @@\n-import java.util.stream.Stream;\n+\n+import builder.ClassBuilder;\n+import builder.ClassBuilder.MethodBuilder;\n+import toolbox.ModuleBuilder;\n@@ -66,1 +60,16 @@\n- * General notes.\n+ * General notes\n+ * =============\n+ *\n+ * To simplify maintenance of this test suite, a test name uses a convention.\n+ * By convention, a test name is a concatenation of the following parts:\n+ *\n+ *    1. \"test\"\n+ *    2. (\"Positive\", \"Negative\")\n+ *    3. (\"Inline\", \"External\", \"Hybrid\")\n+ *    4. (\"Tag\", \"Markup\")\n+ *    5. <custom string>\n+ *\n+ * A test can be either positive or negative; it cannot be both or neither.\n+ * A test can exercise inline, external or hybrid variant or any combination\n+ * thereof, including none at all. A test can exercise tag syntax, markup syntax\n+ * or both.\n@@ -76,5 +85,1 @@\n-public class TestSnippetTag extends JavadocTester {\n-\n-    private final ToolBox tb = new ToolBox();\n-\n-    private TestSnippetTag() { }\n+public class TestSnippetTag extends SnippetTester {\n@@ -87,2 +92,4 @@\n-     * Make sure the \"id\" and \"lang\" attributes defined in JEP 413 are rendered\n-     * properly as recommended by the HTML5 specification.\n+     * Make sure the \"id\" and \"lang\" attributes defined in JEP 413 are translated\n+     * to HTML. In particular, verify that the \"lang\" attribute is translated\n+     * to a value added to the \"class\" attribute as recommended by the HTML5 specification:\n+     * https:\/\/html.spec.whatwg.org\/multipage\/text-level-semantics.html#the-code-element\n@@ -91,1 +98,1 @@\n-    public void testIdAndLangAttributes(Path base) throws IOException {\n+    public void testPositiveInlineTag_IdAndLangAttributes(Path base) throws IOException {\n@@ -96,8 +103,1 @@\n-        record SnippetAttributes(String content, String id, String lang) {\n-            public String idAttribute() {\n-                return id == null ? \"\" : \" id=\\\"\" + id + \"\\\"\";\n-            }\n-            public String langAttribute() {\n-                return lang == null ? \"\" : \" class=\\\"language-\" + lang + \"\\\"\";\n-            }\n-        }\n+        record SnippetAttributes(String content, String id, String lang) { }\n@@ -105,0 +105,1 @@\n+        \/\/ TODO: use combinatorial methods, e.g. just like in TestSnippetMarkup\n@@ -221,1 +222,3 @@\n-            SnippetAttributes snippet = snippets.get(j);\n+            var attr = snippets.get(j);\n+            var snippetHtml = getSnippetHtmlRepresentation(\"pkg\/A.html\", \"    Hello, Snippet!\\n\",\n+                    Optional.ofNullable(attr.lang()), Optional.ofNullable(attr.id()));\n@@ -227,7 +230,2 @@\n-                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n-                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n-                        t=\"Copy\"><\/button>\n-                        <pre class=\"snippet\"%s><code%s>    Hello, Snippet!\n-                        <\/code><\/pre>\n-                        <\/div>\n-                        \"\"\".formatted(j, snippet.idAttribute(), snippet.langAttribute()));\n+                        %s\n+                        \"\"\".formatted(j, snippetHtml));\n@@ -238,3 +236,5 @@\n-     * Make sure the lang attribute is derived correctly from the snippet source file\n-     * for external snippets when it is not defined in the snippet. Defining the lang\n-     * attribute in the snippet should always override this mechanism.\n+     * If the \"lang\" attribute is absent in the snippet tag for an external snippet,\n+     * then the \"class\" attribute is derived from the snippet source file extension.\n+     *\n+     * If the \"class\" attribute can be derived both from the \"lang\" attribute and\n+     * the file extension, then it is derived from the \"lang\" attribute.\n@@ -242,0 +242,1 @@\n+    \/\/ TODO: restructure this as a list of TestCase records\n@@ -243,1 +244,1 @@\n-    public void testExternalImplicitAttributes(Path base) throws IOException {\n+    public void testPositiveInlineExternalTagMarkup_ImplicitAttributes(Path base) throws IOException {\n@@ -279,38 +280,1 @@\n-        checkOutput(\"com\/example\/Cls.html\", true,\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet1\"><code class=\"language-java\">\n-                    System.out.println(msg);\n-                    <\/code><\/pre>\"\"\",\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet2\"><code class=\"language-java\">\n-                    System.out.println(msg);\n-                    <\/code><\/pre>\"\"\",\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet3\"><code class=\"language-none\">\n-                    System.out.println(msg);\n-                    <\/code><\/pre>\"\"\",\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet4\"><code class=\"language-none\">\n-                    System.out.println(msg);\n-                    <\/code><\/pre>\"\"\",\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet5\"><code>\n-                    System.out.println(msg);\n-                    <\/code><\/pre>\"\"\",\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet6\"><code>\n-                    System.out.println(msg);\n-                    <\/code><\/pre>\"\"\",\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet7\"><code class=\"language-properties\">user=jane\n-                    home=\/home\/jane\n-                    <\/code><\/pre>\"\"\",\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet8\"><code class=\"language-none\">user=jane\n-                    home=\/home\/jane\n-                    <\/code><\/pre>\"\"\",\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet9\"><code>user=jane\n-                    home=\/home\/jane\n-                    <\/code><\/pre>\"\"\");\n-    }\n+        final var javaContent = \"\"\"\n@@ -318,11 +282,16 @@\n-    \/*\n-     * This is a convenience method to iterate through a list.\n-     * Unlike List.forEach, this method provides the consumer not only with an\n-     * element but also that element's index.\n-     *\n-     * See JDK-8184707.\n-     *\/\n-    private static <T> void forEachNumbered(List<T> list, ObjIntConsumer<? super T> action) {\n-        for (var iterator = list.listIterator(); iterator.hasNext(); ) {\n-            action.accept(iterator.next(), iterator.previousIndex());\n-        }\n+                System.out.println(msg);\n+                \"\"\";\n+        final var propertiesContent = \"\"\"\n+                user=jane\n+                home=\/home\/jane\n+                \"\"\";\n+        checkOutput(\"com\/example\/Cls.html\", true,\n+                getSnippetHtmlRepresentation(\"com\/example\/Cls.html\", javaContent, Optional.of(\"java\"), Optional.of(\"snippet1\")),\n+                getSnippetHtmlRepresentation(\"com\/example\/Cls.html\", javaContent, Optional.of(\"java\"), Optional.of(\"snippet2\")),\n+                getSnippetHtmlRepresentation(\"com\/example\/Cls.html\", javaContent, Optional.of(\"none\"), Optional.of(\"snippet3\")),\n+                getSnippetHtmlRepresentation(\"com\/example\/Cls.html\", javaContent, Optional.of(\"none\"), Optional.of(\"snippet4\")),\n+                getSnippetHtmlRepresentation(\"com\/example\/Cls.html\", javaContent, Optional.empty(), Optional.of(\"snippet5\")),\n+                getSnippetHtmlRepresentation(\"com\/example\/Cls.html\", javaContent, Optional.empty(), Optional.of(\"snippet6\")),\n+                getSnippetHtmlRepresentation(\"com\/example\/user.properties\", propertiesContent, Optional.of(\"properties\"), Optional.of(\"snippet7\")),\n+                getSnippetHtmlRepresentation(\"com\/example\/user.properties\", propertiesContent, Optional.of(\"none\"), Optional.of(\"snippet8\")),\n+                getSnippetHtmlRepresentation(\"com\/example\/user.properties\", propertiesContent, Optional.empty(), Optional.of(\"snippet9\")));\n@@ -332,1 +301,1 @@\n-    public void testBadTagSyntax(Path base) throws IOException {\n+    public void testNegativeInlineTag_BadTagSyntax(Path base) throws IOException {\n@@ -669,37 +638,0 @@\n-    \/\/ TODO This is a temporary method; it should be removed after JavadocTester has provided similar functionality (JDK-8273154).\n-    private void checkOrder(Output output, String... strings) {\n-        String outputString = getOutput(output);\n-        int prevIndex = -1;\n-        for (String s : strings) {\n-            s = s.replace(\"\\n\", NL); \/\/ normalize new lines\n-            int currentIndex = outputString.indexOf(s, prevIndex + 1);\n-            checking(\"output: \" + output + \": \" + s + \" at index \" + currentIndex);\n-            if (currentIndex == -1) {\n-                failed(output + \": \" + s + \" not found.\");\n-                continue;\n-            }\n-            if (currentIndex > prevIndex) {\n-                passed(output + \": \" + \" is in the correct order\");\n-            } else {\n-                failed(output + \": \" + \" is in the wrong order.\");\n-            }\n-            prevIndex = currentIndex;\n-        }\n-    }\n-\n-    \/*\n-     * When checking for errors, it is important not to confuse one error with\n-     * another. This method checks that there are no crashes (which are also\n-     * errors) by checking for stack traces. We never expect crashes.\n-     *\/\n-    private void checkNoCrashes() {\n-        checking(\"check crashes\");\n-        Matcher matcher = Pattern.compile(\"\\s*at.*\\\\(.*\\\\.java:\\\\d+\\\\)\")\n-                .matcher(getOutput(Output.STDERR));\n-        if (!matcher.find()) {\n-            passed(\"\");\n-        } else {\n-            failed(\"Looks like a stacktrace: \" + matcher.group());\n-        }\n-    }\n-\n@@ -712,1 +644,1 @@\n-    public void testUnknownTag(Path base) throws IOException {\n+    public void testNegativeInlineTagUnknownTag(Path base) throws IOException {\n@@ -749,1 +681,1 @@\n-    public void testInline(Path base) throws Exception {\n+    public void testPositiveInlineTag(Path base) throws Exception {\n@@ -951,5 +883,1 @@\n-                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n-                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n-                        t=\"Copy\"><\/button>\n-                        <pre class=\"snippet\"><code>%s<\/code><\/pre>\n-                        <\/div>\"\"\".formatted(id, t.expectedOutput()));\n+                        %s\"\"\".formatted(id, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput())));\n@@ -960,1 +888,1 @@\n-    public void testExternalFile(Path base) throws Exception {\n+    public void testPositiveExternalTag_File(Path base) throws Exception {\n@@ -1047,5 +975,1 @@\n-                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n-                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n-                        t=\"Copy\"><\/button>\n-                        <pre class=\"snippet\"><code>%s<\/code><\/pre>\n-                        <\/div>\"\"\".formatted(index, expectedOutput));\n+                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", expectedOutput)));\n@@ -1055,14 +979,0 @@\n-    \/\/ TODO:\n-    \/\/   Explore the toolbox.ToolBox.writeFile and toolbox.ToolBox.writeJavaFiles methods:\n-    \/\/   see if any of them could be used instead of this one\n-    private void addSnippetFile(Path srcDir, String packageName, String fileName, String content) throws UncheckedIOException {\n-        String[] components = packageName.split(\"\\\\.\");\n-        Path snippetFiles = Path.of(components[0], Arrays.copyOfRange(components, 1, components.length)).resolve(\"snippet-files\");\n-        try {\n-            Path p = Files.createDirectories(srcDir.resolve(snippetFiles));\n-            Files.writeString(p.resolve(fileName), content, StandardOpenOption.CREATE_NEW);\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-    }\n-\n@@ -1070,1 +980,1 @@\n-    public void testInlineSnippetInDocFiles(Path base) throws IOException {\n+    public void testPositiveInlineTag_InDocFiles(Path base) throws IOException {\n@@ -1112,1 +1022,1 @@\n-    public void testExternalSnippetInDocFiles(Path base) throws IOException {\n+    public void testPositiveExternalTag_InDocFiles(Path base) throws IOException {\n@@ -1154,1 +1064,1 @@\n-    public void testExternalFileNotFound(Path base) throws Exception {\n+    public void testNegativeExternalTag_FileNotFound(Path base) throws Exception {\n@@ -1177,2 +1087,2 @@\n-    @Test \/\/ TODO perhaps this could be unified with testExternalFile\n-    public void testExternalFileModuleSourcePath(Path base) throws Exception {\n+    @Test \/\/ TODO perhaps this could be unified with testPositiveExternalTagFile\n+    public void testNegativeExternalTag_FileModuleSourcePath(Path base) throws Exception {\n@@ -1203,2 +1113,2 @@\n-    @Test \/\/ TODO perhaps this could be unified with testExternalFileNotFound\n-    public void testExternalFileNotFoundModuleSourcePath(Path base) throws Exception {\n+    @Test \/\/ TODO perhaps this could be unified with testNegativeExternalTagFileNotFound\n+    public void testNegativeExternalTag_FileNotFoundModuleSourcePath(Path base) throws Exception {\n@@ -1233,1 +1143,1 @@\n-    public void testNoContents(Path base) throws Exception {\n+    public void testNegativeTag_NoContents(Path base) throws Exception {\n@@ -1253,1 +1163,31 @@\n-    public void testConflict20(Path base) throws Exception {\n+    public void testNegativeExternalTagMarkup(Path base) throws Exception {\n+        \/\/ External snippet issues are handled similarly to those of internal snippet\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        addSnippetFile(srcDir, \"pkg\", \"file.txt\", \"\"\"\n+                                                  \/\/ @start\n+                                                  \"\"\"\n+        );\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void case0() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet file=\"file.txt\"}\n+                                             \"\"\"));\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+\"\"\"\n+: error: snippet markup: missing attribute \"region\"\n+\/\/ @start\n+    ^\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testNegativeInlineTag_AttributeConflict20(Path base) throws Exception {\n@@ -1279,1 +1219,1 @@\n-    public void testConflict30(Path base) throws Exception {\n+    public void testNegativeInlineTag_AttributeConflict30(Path base) throws Exception {\n@@ -1300,13 +1240,0 @@\n-    \/\/ TODO: perhaps this method could be added to JavadocTester\n-    private void checkOutputEither(Output out, String first, String... other) {\n-        checking(\"checkOutputEither\");\n-        String output = getOutput(out);\n-        Stream<String> strings = Stream.concat(Stream.of(first), Stream.of(other));\n-        Optional<String> any = strings.filter(output::contains).findAny();\n-        if (any.isPresent()) {\n-            passed(\": following text is found:\\n\" + any.get());\n-        } else {\n-            failed(\": nothing found\");\n-        }\n-    }\n-\n@@ -1314,1 +1241,1 @@\n-    public void testConflict60(Path base) throws Exception {\n+    public void testNegativeInlineTag_AttributeConflict60(Path base) throws Exception {\n@@ -1334,1 +1261,1 @@\n-    public void testConflict70(Path base) throws Exception {\n+    public void testNegativeInlineTag_AttributeConflict70(Path base) throws Exception {\n@@ -1354,1 +1281,1 @@\n-    public void testConflict80(Path base) throws Exception {\n+    public void testNegativeInlineTag_AttributeConflict80(Path base) throws Exception {\n@@ -1378,1 +1305,1 @@\n-    public void testConflict90(Path base) throws Exception {\n+    public void testNegativeInlineTag_AttributeConflict90(Path base) throws Exception {\n@@ -1402,1 +1329,1 @@\n-    public void testErrorPositionResolution(Path base) throws Exception {\n+    public void testNegativeTag_PositionResolution(Path base) throws Exception {\n@@ -1430,1 +1357,1 @@\n-    public void testRegion(Path base) throws Exception {\n+    public void testPositiveInlineTag_AttributeConflictRegion(Path base) throws Exception {\n@@ -1608,5 +1535,1 @@\n-                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n-                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n-                        t=\"Copy\"><\/button>\n-                        <pre class=\"snippet\"><code>%s<\/code><\/pre>\n-                        <\/div>\"\"\".formatted(index, t.expectedOutput()));\n+                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput())));\n@@ -1650,1 +1573,1 @@\n-    public void testAttributeValueSyntaxUnquotedCurly(Path base) throws Exception {\n+    public void testNegativeInlineTagMarkup_AttributeValueSyntaxUnquotedCurly(Path base) throws Exception {\n@@ -1684,1 +1607,1 @@\n-    public void testAttributeValueSyntaxCurly(Path base) throws Exception {\n+    public void testPositiveInlineTagMarkup_SyntaxCurly(Path base) throws Exception {\n@@ -1725,5 +1648,1 @@\n-                    <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySnippet\\\n-                    (this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" alt=\"Copy\"\\\n-                    ><\/button>\n-                    <pre class=\"snippet\"><code><\/code><\/pre>\n-                    <\/div>\"\"\");\n+                    \"\"\" + getSnippetHtmlRepresentation(\"pkg\/A.html\", \"\"));\n@@ -1734,5 +1653,1 @@\n-                    <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySnippet\\\n-                    (this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" alt=\"Copy\"\\\n-                    ><\/button>\n-                    <pre class=\"snippet\"><code><\/code><\/pre>\n-                    <\/div>\"\"\");\n+                    \"\"\" + getSnippetHtmlRepresentation(\"pkg\/A.html\", \"\"));\n@@ -1741,2 +1656,2 @@\n-    @Test\n-    public void testAttributeValueSyntax(Path base) throws Exception {\n+    @Test \/\/ TODO: use combinatorial methods\n+    public void testPositiveExternalTagMarkup_AttributeValueSyntax(Path base) throws Exception {\n@@ -1835,6 +1750,2 @@\n-                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n-                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n-                        t=\"Copy\"><\/button>\n-                        <pre class=\"snippet\"><code>2<\/code><\/pre>\n-                        <\/div>\n-                        \"\"\".formatted(j));\n+                        %s\n+                        \"\"\".formatted(j, getSnippetHtmlRepresentation(\"pkg\/A.html\", \"2\")));\n@@ -1845,1 +1756,1 @@\n-    public void testComment(Path base) throws Exception {\n+    public void testPositiveInlineTagMarkup_Comment(Path base) throws Exception {\n@@ -1919,5 +1830,1 @@\n-                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n-                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n-                        t=\"Copy\"><\/button>\n-                        <pre class=\"snippet\"><code>%s<\/code><\/pre>\n-                        <\/div>\"\"\".formatted(index, t.expectedOutput()));\n+                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput())));\n@@ -1928,1 +1835,1 @@\n-    public void testRedundantFileNotFound(Path base) throws Exception {\n+    public void testNegativeHybridTag_FileNotFound(Path base) throws Exception {\n@@ -1953,1 +1860,104 @@\n-    public void testRedundantRegionNotFound(Path base) throws Exception {\n+    public void testNegativeTag_ValuelessAttributes(Path base) throws IOException {\n+        \/\/ none of these attributes should ever be valueless\n+        record TestCase(String input, String expectedError) { }\n+        var testCases = new ArrayList<TestCase>();\n+        for (String attrName : List.of(\"class\", \"file\", \"id\", \"lang\", \"region\")) {\n+            \/\/ special case: valueless region attribute\n+            TestCase t = new TestCase(\"\"\"\n+{@snippet %s:\n+    First line\n+      Second line\n+}\n+\"\"\".formatted(attrName),\n+\"\"\"\n+: error: missing value for attribute \"%s\"\n+{@snippet %s:\n+          ^\"\"\".formatted(attrName, attrName));\n+            testCases.add(t);\n+        }\n+\n+        List<String> inputs = testCases.stream().map(s -> s.input).toList();\n+        StringBuilder methods = new StringBuilder();\n+        forEachNumbered(inputs, (i, n) -> {\n+            methods.append(\n+                    \"\"\"\n+\n+                    \/**\n+                    %s*\/\n+                    public void case%s() {}\n+                    \"\"\".formatted(i, n));\n+        });\n+\n+        String classString =\n+                \"\"\"\n+                public class A {\n+                %s\n+                }\n+                \"\"\".formatted(methods.toString());\n+\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.writeJavaFiles(src, classString);\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"A.java\").toString());\n+        checkExit(Exit.ERROR);\n+        \/\/ use the facility from JDK-8273154 when it becomes available\n+        checkOutput(Output.OUT, true, testCases.stream().map(TestCase::expectedError).toArray(String[]::new));\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testNegativeTag_BlankRegion(Path base) throws Exception {\n+        \/\/ If a blank region were allowed, it could not be used without quotes\n+        record TestCase(String input, String expectedError) { }\n+\n+      var testCases = new ArrayList<TestCase>();\n+      for (String quote : List.of(\"\", \"'\", \"\\\"\"))\n+          for (String value : List.of(\"\", \" \")) {\n+              var t = new TestCase(\"\"\"\n+{@snippet region=%s%s%s:\n+    First line\n+      Second line\n+}\n+\"\"\".formatted(quote, value, quote),\n+                      \"\"\"\n+: error: illegal value for attribute \"region\": \"%s\"\n+{@snippet region=%s%s%s:\n+          ^\"\"\".formatted(quote.isEmpty() ? \"\" : value, quote, value, quote)); \/\/ unquoted whitespace translates to empty string\n+              testCases.add(t);\n+          }\n+\n+        List<String> inputs = testCases.stream().map(s -> s.input).toList();\n+        StringBuilder methods = new StringBuilder();\n+        forEachNumbered(inputs, (i, n) -> {\n+            methods.append(\n+                    \"\"\"\n+\n+                    \/**\n+                    %s*\/\n+                    public void case%s() {}\n+                    \"\"\".formatted(i, n));\n+        });\n+\n+        String classString =\n+                \"\"\"\n+                public class A {\n+                %s\n+                }\n+                \"\"\".formatted(methods.toString());\n+\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.writeJavaFiles(src, classString);\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"A.java\").toString());\n+        checkExit(Exit.ERROR);\n+        \/\/ use the facility from JDK-8273154 when it becomes available\n+        checkOutput(Output.OUT, true, testCases.stream().map(TestCase::expectedError).toArray(String[]::new));\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testNegativeHybridTagMarkup_RegionNotFound(Path base) throws Exception {\n@@ -1984,1 +1994,1 @@\n-    public void testRedundantMismatch(Path base) throws Exception {\n+    public void testNegativeHybridTag_Mismatch(Path base) throws Exception {\n@@ -2013,1 +2023,1 @@\n-    public void testRedundantRegionRegionMismatch(Path base) throws Exception {\n+    public void testNegativeHybridTagMarkup_RegionRegionMismatch(Path base) throws Exception {\n@@ -2053,1 +2063,1 @@\n-    public void testRedundantRegion1Mismatch(Path base) throws Exception {\n+    public void testNegativeHybridTagMarkup_Region1Mismatch(Path base) throws Exception {\n@@ -2087,1 +2097,1 @@\n-    public void testRedundantRegion2Mismatch(Path base) throws Exception {\n+    public void testNegativeHybridTagMarkup_Region2Mismatch(Path base) throws Exception {\n@@ -2124,1 +2134,1 @@\n-    public void testRedundant(Path base) throws Exception {\n+    public void testPositiveHybridTagMarkup(Path base) throws Exception {\n@@ -2251,5 +2261,1 @@\n-                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n-                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n-                        t=\"Copy\"><\/button>\n-                        <pre class=\"snippet\"><code>%s<\/code><\/pre>\n-                        <\/div>\"\"\".formatted(index, t.expectedOutput()));\n+                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput())));\n@@ -2260,1 +2266,1 @@\n-    public void testInvalidRegexDiagnostics(Path base) throws Exception {\n+    public void testNegativeInlineTagMarkup_InvalidRegexDiagnostics(Path base) throws Exception {\n@@ -2344,1 +2350,1 @@\n-    public void testErrorMessages(Path base) throws Exception {\n+    public void testNegativeInlineTagMarkup_ErrorMessages(Path base) throws Exception {\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestSnippetTag.java","additions":234,"deletions":228,"binary":false,"changes":462,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8268725\n+ * @summary Tests for the --enable-native-access option\n+ * @modules jdk.jshell\n+ * @run testng ToolEnableNativeAccessTest\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertTrue;\n+\n+public class ToolEnableNativeAccessTest extends ReplToolTesting {\n+\n+    @Test\n+    public void testOptionDebug() {\n+        test(\n+                (a) -> assertCommand(a, \"\/debug b\",\n+                        \"RemoteVM Options: []\\n\"\n+                        + \"Compiler options: []\"),\n+                (a) -> assertCommand(a, \"\/env --enable-native-access\",\n+                        \"|  Setting new options and restoring state.\"),\n+                (a) -> assertCommandCheckOutput(a, \"\/debug b\", s -> {\n+                    assertTrue(s.contains(\"RemoteVM Options: [--enable-native-access, ALL-UNNAMED]\"));\n+                    assertTrue(s.contains(\"Compiler options: []\"));\n+                })\n+        );\n+    }\n+\n+    @Test\n+    public void testCommandLineFlag() {\n+        test(new String[] {\"--enable-native-access\"},\n+                (a) -> assertCommandCheckOutput(a, \"\/debug b\", s -> {\n+                    assertTrue(s.contains(\"RemoteVM Options: [--enable-native-access, ALL-UNNAMED]\"));\n+                    assertTrue(s.contains(\"Compiler options: []\"));\n+                })\n+        );\n+    }\n+\n+}\n","filename":"test\/langtools\/jdk\/jshell\/ToolEnableNativeAccessTest.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -10,0 +10,2 @@\n+import java.util.Objects;\n+\n@@ -25,1 +27,6 @@\n-    class Outer {}\n+    class Outer {\n+        {\n+            \/\/ access enclosing instance so this$0 field is generated\n+            Objects.requireNonNull(T6521805.this);\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/6521805\/T6521805d.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-T6521805d.java:18:18: compiler.err.cannot.generate.class: T6521805.Inner, (compiler.misc.synthetic.name.conflict: this$0, T6521805.Inner)\n+T6521805d.java:20:18: compiler.err.cannot.generate.class: T6521805.Inner, (compiler.misc.synthetic.name.conflict: this$0, T6521805.Inner)\n","filename":"test\/langtools\/tools\/javac\/6521805\/T6521805d.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,0 +5,2 @@\n+import java.util.Objects;\n+\n@@ -6,1 +8,6 @@\n-    class Super {}\n+    class Super {\n+        {\n+            \/\/ access enclosing instance so this$0 field is generated\n+            Objects.requireNonNull(Outer.this);\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/6521805\/p\/Outer.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4,2 +4,0 @@\n-FIELD  this$0\n---- FINAL\n@@ -23,2 +21,0 @@\n-FIELD  this$1\n---- FINAL\n@@ -32,2 +28,0 @@\n-FIELD  this$0\n---- FINAL\n","filename":"test\/langtools\/tools\/javac\/ClassFileModifiers\/MemberModifiers.out","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-        if (!javapOut.contains(\"0: #22(): CLASS_EXTENDS, type_index=65535\"))\n+        if (!javapOut.contains(\"0: #20(): CLASS_EXTENDS, type_index=65535\"))\n@@ -65,1 +65,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/AnnotatedExtendsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-        expectedNumberOfSyntheticFields = 1,\n@@ -50,2 +49,1 @@\n-        expectedMethods = {\"<init>(AccessToPrivateInnerClassConstructorsTest)\"},\n-        expectedNumberOfSyntheticFields = 1)\n+        expectedMethods = {\"<init>(AccessToPrivateInnerClassConstructorsTest)\"})\n@@ -53,2 +51,1 @@\n-        expectedMethods = {\"<init>(AccessToPrivateInnerClassConstructorsTest)\"},\n-        expectedNumberOfSyntheticFields = 1)\n+        expectedMethods = {\"<init>(AccessToPrivateInnerClassConstructorsTest)\"})\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/Synthetic\/AccessToPrivateInnerClassConstructorsTest.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,2 +46,1 @@\n- * 6. field this in Inner1.\n- * 7. constructor for Inner*.\n+ * 6. constructor for Inner*.\n@@ -53,2 +52,1 @@\n-        expectedFields = \"var\",\n-        expectedNumberOfSyntheticFields = 1)\n+        expectedFields = \"var\")\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/Synthetic\/AccessToPrivateInnerClassMembersTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,2 +46,1 @@\n- * 6. field this in Inner1.\n- * 7. constructor for Inner*.\n+ * 6. constructor for Inner*.\n@@ -52,2 +51,1 @@\n-        expectedFields = \"var\",\n-        expectedNumberOfSyntheticFields = 1)\n+        expectedFields = \"var\")\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/Synthetic\/AccessToPrivateSiblingsTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,2 +58,1 @@\n-        expectedNumberOfSyntheticMethods = 1,\n-        expectedNumberOfSyntheticFields = 1)\n+        expectedNumberOfSyntheticMethods = 1)\n@@ -65,2 +64,1 @@\n-        expectedMethods = {\"<init>(BridgeMethodsForLambdaTest)\", \"function()\"},\n-        expectedNumberOfSyntheticFields = 1)\n+        expectedMethods = {\"<init>(BridgeMethodsForLambdaTest)\", \"function()\"})\n@@ -69,2 +67,1 @@\n-        expectedNumberOfSyntheticMethods = 1,\n-        expectedNumberOfSyntheticFields = 1)\n+        expectedNumberOfSyntheticMethods = 1)\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/Synthetic\/BridgeMethodsForLambdaTest.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import java.util.Objects;\n+\n@@ -52,0 +54,4 @@\n+            {\n+                \/\/ access enclosing instance so this$0 field is generated\n+                Objects.requireNonNull(ThisFieldTest.this);\n+            }\n@@ -55,0 +61,4 @@\n+            {\n+                \/\/ access enclosing instance so this$0 field is generated\n+                Objects.requireNonNull(ThisFieldTest.this);\n+            }\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/Synthetic\/ThisFieldTest.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.util.Objects;\n+\n@@ -33,1 +35,6 @@\n-    public class Inner extends Outer { }\n+    public class Inner extends Outer {\n+        {\n+            \/\/ access enclosing instance so this$0 field is generated\n+            Objects.requireNonNull(ErrSyntheticNameConflict.this);\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ErrSyntheticNameConflict.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8192920 8204588 8246774 8248843 8268869\n+ * @bug 8192920 8204588 8246774 8248843 8268869 8235876\n@@ -633,0 +633,14 @@\n+    @Test\n+    public void testNoOptionsWarnings(Path base) throws IOException {\n+        tb.writeJavaFiles(base, \"public class Main { public static void main(String... args) {}}\");\n+        String log = new JavaTask(tb)\n+                .vmOptions(\"--source\", \"7\")\n+                .className(base.resolve(\"Main.java\").toString())\n+                .run(Task.Expect.SUCCESS)\n+                .getOutput(Task.OutputKind.STDERR);\n+\n+        if (log.contains(\"warning: [options]\")) {\n+            error(\"Unexpected options warning in error output: \" + log);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2021, Google LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+\/**\n+ * @test\n+ * @bug 8271623\n+ *\n+ * @compile --release 17 DontOptimizeOuterThis.java InnerClasses.java\n+ * @run main DontOptimizeOuterThis\n+ *\/\n+public class DontOptimizeOuterThis extends InnerClasses {\n+\n+    public static void main(String[] args) {\n+        new DontOptimizeOuterThis().test();\n+    }\n+\n+    public void test() {\n+        checkInner(localCapturesParameter(0), true);\n+        checkInner(localCapturesLocal(), true);\n+        checkInner(localCapturesEnclosing(), true);\n+\n+        checkInner(anonCapturesParameter(0), true);\n+        checkInner(anonCapturesLocal(), true);\n+        checkInner(anonCapturesEnclosing(), true);\n+\n+        checkInner(StaticMemberClass.class, false); \/\/ static\n+        checkInner(NonStaticMemberClass.class, true);\n+        checkInner(NonStaticMemberClassCapturesEnclosing.class, true);\n+\n+        checkInner(N0.class, false); \/\/ static\n+        checkInner(N0.N1.class, true);\n+        checkInner(N0.N1.N2.class, true);\n+        checkInner(N0.N1.N2.N3.class, true);\n+        checkInner(N0.N1.N2.N3.N4.class, true);\n+        checkInner(N0.N1.N2.N3.N4.N5.class, true);\n+\n+        checkInner(SerializableCapture.class, true);\n+        checkInner(SerializableWithSerialVersionUID.class, true);\n+        checkInner(SerializableWithInvalidSerialVersionUIDType.class, true);\n+        checkInner(SerializableWithInvalidSerialVersionUIDNonFinal.class, true);\n+        checkInner(SerializableWithInvalidSerialVersionUIDNonStatic.class, true);\n+    }\n+\n+    private static void checkInner(Class<?> clazz, boolean expectOuterThis) {\n+        Optional<Field> outerThis = Arrays.stream(clazz.getDeclaredFields())\n+                .filter(f -> f.getName().startsWith(\"this$\")).findFirst();\n+        if (expectOuterThis) {\n+            if (outerThis.isEmpty()) {\n+                throw new AssertionError(\n+                        String.format(\n+                                \"expected %s to have an enclosing instance\", clazz.getName()));\n+            }\n+        } else {\n+            if (outerThis.isPresent()) {\n+                throw new AssertionError(\n+                        String.format(\"%s had an unexpected enclosing instance\", clazz.getName()));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/optimizeOuterThis\/DontOptimizeOuterThis.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2021, Google LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.Serializable;\n+\n+public class InnerClasses {\n+\n+    public Class<?> localCapturesParameter(final int x) {\n+        class Local {\n+            public void f() {\n+                System.err.println(x);\n+            }\n+        }\n+        return Local.class;\n+    }\n+\n+    public Class<?> localCapturesLocal() {\n+        final int x = 0;\n+        class Local {\n+            public void f() {\n+                System.err.println(x);\n+            }\n+        }\n+        return Local.class;\n+    }\n+\n+    public Class<?> localCapturesEnclosing() {\n+        class Local {\n+            public void f() {\n+                System.err.println(InnerClasses.this);\n+            }\n+        }\n+        return Local.class;\n+    }\n+\n+    public Class<?> anonCapturesParameter(final int x) {\n+        return new Object() {\n+            public void f() {\n+                System.err.println(x);\n+            }\n+        }.getClass();\n+    }\n+\n+    public Class<?> anonCapturesLocal() {\n+        final int x = 0;\n+        return new Object() {\n+            public void f() {\n+                System.err.println(x);\n+            }\n+        }.getClass();\n+    }\n+\n+    public Class<?> anonCapturesEnclosing() {\n+        return new Object() {\n+            public void f() {\n+                System.err.println(InnerClasses.this);\n+            }\n+        }.getClass();\n+    }\n+\n+    public static class StaticMemberClass {}\n+\n+    public class NonStaticMemberClass {}\n+\n+    public class NonStaticMemberClassCapturesEnclosing {\n+        public void f() {\n+            System.err.println(InnerClasses.this);\n+        }\n+    }\n+\n+    static class N0 {\n+        int x;\n+\n+        class N1 {\n+            class N2 {\n+                class N3 {\n+                    void f() {\n+                        System.err.println(x);\n+                    }\n+\n+                    class N4 {\n+                        class N5 {}\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    class SerializableCapture implements Serializable {\n+      void f() {\n+        System.err.println(InnerClasses.this);\n+      }\n+    }\n+\n+    class SerializableWithSerialVersionUID implements Serializable {\n+      private static final long serialVersionUID = 0;\n+    }\n+\n+    class SerializableWithInvalidSerialVersionUIDType implements Serializable {\n+      private static final int serialVersionUID = 0;\n+    }\n+\n+    class SerializableWithInvalidSerialVersionUIDNonFinal implements Serializable {\n+      private static long serialVersionUID = 0;\n+    }\n+\n+    class SerializableWithInvalidSerialVersionUIDNonStatic implements Serializable {\n+      private final long serialVersionUID = 0;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/optimizeOuterThis\/InnerClasses.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2021, Google LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+\/**\n+ * @test\n+ * @bug 8271623\n+ *\n+ * @clean *\n+ * @compile OptimizeOuterThis.java InnerClasses.java\n+ * @run main OptimizeOuterThis\n+ *\n+ * @clean *\n+ * @compile -XDoptimizeOuterThis=true --release 17 OptimizeOuterThis.java InnerClasses.java\n+ * @run main OptimizeOuterThis\n+ *\/\n+public class OptimizeOuterThis extends InnerClasses {\n+\n+    public static void main(String[] args) {\n+        new OptimizeOuterThis().test();\n+    }\n+\n+    public void test() {\n+        checkInner(localCapturesParameter(0), false);\n+        checkInner(localCapturesLocal(), false);\n+        checkInner(localCapturesEnclosing(), true);\n+\n+        checkInner(anonCapturesParameter(0), false);\n+        checkInner(anonCapturesLocal(), false);\n+        checkInner(anonCapturesEnclosing(), true);\n+\n+        checkInner(StaticMemberClass.class, false);\n+        checkInner(NonStaticMemberClass.class, false);\n+        checkInner(NonStaticMemberClassCapturesEnclosing.class, true);\n+\n+        checkInner(N0.class, false);\n+        checkInner(N0.N1.class, true);\n+        checkInner(N0.N1.N2.class, true);\n+        checkInner(N0.N1.N2.N3.class, true);\n+        checkInner(N0.N1.N2.N3.N4.class, false);\n+        checkInner(N0.N1.N2.N3.N4.N5.class, false);\n+\n+        checkInner(SerializableCapture.class, true);\n+        checkInner(SerializableWithSerialVersionUID.class, false);\n+        checkInner(SerializableWithInvalidSerialVersionUIDType.class, true);\n+        checkInner(SerializableWithInvalidSerialVersionUIDNonFinal.class, true);\n+        checkInner(SerializableWithInvalidSerialVersionUIDNonStatic.class, true);\n+    }\n+\n+    private static void checkInner(Class<?> clazz, boolean expectOuterThis) {\n+        Optional<Field> outerThis = Arrays.stream(clazz.getDeclaredFields())\n+                .filter(f -> f.getName().startsWith(\"this$\")).findFirst();\n+        if (expectOuterThis) {\n+            if (outerThis.isEmpty()) {\n+                throw new AssertionError(\n+                        String.format(\n+                                \"expected %s to have an enclosing instance\", clazz.getName()));\n+            }\n+        } else {\n+            if (outerThis.isPresent()) {\n+                throw new AssertionError(\n+                        String.format(\"%s had an unexpected enclosing instance %s\", clazz.getName(), outerThis.get()));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/optimizeOuterThis\/OptimizeOuterThis.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8044859\n+ * @bug 8044859 8272728\n@@ -36,0 +36,1 @@\n+import com.sun.tools.javac.main.Main;\n@@ -63,0 +64,12 @@\n+\n+    @Test\n+    void testAtFilesMustNotContainOptionJ() throws IOException {\n+        writeFile(\"args\", \"-J-verbose\");\n+\n+        String[] opts = { \"@args\", \"-version\" };\n+        String[] files = { };\n+\n+        runMain(opts, files)\n+            .checkResult(Main.Result.CMDERR.exitCode)\n+            .checkLog(Log.DIRECT, \"-J-verbose\");\n+    }\n","filename":"test\/langtools\/tools\/javac\/options\/modes\/AtFilesTest.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -71,0 +71,14 @@\n+    int testDominatesStringConstant2(String str) {\n+        switch (str) {\n+            case (String s && s.isEmpty()): return 1;\n+            case \"\": return -1;\n+        }\n+    }\n+\n+    int testDominatesStringConstant3(String str) {\n+        switch (str) {\n+            case (String s && !s.isEmpty()): return 1;\n+            case \"\": return -1;\n+        }\n+    }\n+\n@@ -78,0 +92,14 @@\n+    int testDominatesIntegerConstant2(Integer i) {\n+        switch (i) {\n+            case (Integer j && j == 0): return 1;\n+            case 0: return -1;\n+        }\n+    }\n+\n+    int testDominatesIntegerConstant3(Integer i) {\n+        switch (i) {\n+            case (Integer j && j == 1): return 1;\n+            case 0: return -1;\n+        }\n+    }\n+\n@@ -89,0 +117,22 @@\n+    int testDominatesEnumConstant2() {\n+        enum E {\n+            A, B;\n+        }\n+        E e = E.A;\n+        switch (e) {\n+            case (E d && d == E.A): return 1;\n+            case A: return -1;\n+        }\n+    }\n+\n+    int testDominatesEnumConstant3() {\n+        enum E {\n+            A, B;\n+        }\n+        E e = E.A;\n+        switch (e) {\n+            case (E d && d == E.B): return 1;\n+            case A: return -1;\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Domination.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -6,1 +6,7 @@\n-Domination.java:85:18: compiler.err.pattern.dominated\n+Domination.java:81:18: compiler.err.pattern.dominated\n+Domination.java:88:18: compiler.err.pattern.dominated\n+Domination.java:95:18: compiler.err.pattern.dominated\n+Domination.java:102:18: compiler.err.pattern.dominated\n+Domination.java:113:18: compiler.err.pattern.dominated\n+Domination.java:124:18: compiler.err.pattern.dominated\n+Domination.java:135:18: compiler.err.pattern.dominated\n@@ -9,1 +15,1 @@\n-6 errors\n+12 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/Domination.out","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-            case EnumTypeChangesEnum e1 && false -> throw new AssertionError();\n@@ -57,0 +56,1 @@\n+            case EnumTypeChangesEnum e1 && false -> throw new AssertionError();\n@@ -64,1 +64,0 @@\n-            case EnumTypeChangesEnum e1 && false -> throw new AssertionError();\n@@ -66,0 +65,1 @@\n+            case EnumTypeChangesEnum e1 && false -> throw new AssertionError();\n","filename":"test\/langtools\/tools\/javac\/patterns\/EnumTypeChanges.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -802,0 +802,88 @@\n+    @Test\n+    public void testOnlyApplicable(Path base) throws Exception {\n+        record TestCase(String cases, String... errors) {}\n+        TestCase[] subCases = new TestCase[] {\n+            new TestCase(\"\"\"\n+                                     case C3<Integer> c -> {}\n+                                     case C5<Integer, ?> c -> {}\n+                                     case C6<?, Integer> c -> {}\n+                         \"\"\"), \/\/OK\n+            new TestCase(\"\"\"\n+                                     case C5<Integer, ?> c -> {}\n+                                     case C6<?, Integer> c -> {}\n+                         \"\"\",\n+                         \"Test.java:11:9: compiler.err.not.exhaustive.statement\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case C3<Integer> c -> {}\n+                                     case C6<?, Integer> c -> {}\n+                         \"\"\",\n+                         \"Test.java:11:9: compiler.err.not.exhaustive.statement\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case C3<Integer> c -> {}\n+                                     case C5<Integer, ?> c -> {}\n+                         \"\"\",\n+                         \"Test.java:11:9: compiler.err.not.exhaustive.statement\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case C1 c -> {}\n+                                     case C3<Integer> c -> {}\n+                                     case C5<Integer, ?> c -> {}\n+                                     case C6<?, Integer> c -> {}\n+                         \"\"\",\n+                         \"Test.java:12:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: test.Test.I<java.lang.Integer>, test.Test.C1)\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case C2<?> c -> {}\n+                                     case C3<Integer> c -> {}\n+                                     case C5<Integer, ?> c -> {}\n+                                     case C6<?, Integer> c -> {}\n+                         \"\"\",\n+                         \"Test.java:12:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: test.Test.I<java.lang.Integer>, test.Test.C2<?>)\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                                     case C4<?, ?> c -> {}\n+                                     case C3<Integer> c -> {}\n+                                     case C5<Integer, ?> c -> {}\n+                                     case C6<?, Integer> c -> {}\n+                         \"\"\",\n+                         \"Test.java:12:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: test.Test.I<java.lang.Integer>, test.Test.C4<?,?>)\",\n+                         \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                         \"- compiler.note.preview.recompile\",\n+                         \"1 error\"),\n+        };\n+        for (TestCase tc : subCases) {\n+            doTest(base,\n+                   new String[0],\n+                   \"\"\"\n+                   package test;\n+                   public class Test {\n+                       sealed interface I<T> {}\n+                       final class C1 implements I<String> {}\n+                       final class C2<T> implements I<String> {}\n+                       final class C3<T> implements I<T> {}\n+                       final class C4<T, E> implements I<String> {}\n+                       final class C5<T, E> implements I<T> {}\n+                       final class C6<T, E> implements I<E> {}\n+                       void t(I<Integer> i) {\n+                           switch (i) {\n+                   ${cases}\n+                           }\n+                       }\n+                   }\n+                   \"\"\".replace(\"${cases}\", tc.cases),\n+                   tc.errors);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -188,1 +188,10 @@\n-    void test8269146a(Integer i) {\n+    void test8269146a1(Integer i) {\n+        switch (i) {\n+            \/\/error - illegal combination of pattern and constant:\n+            case 1, Integer o && o != null:\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+    void test8269146a2(Integer i) {\n@@ -213,1 +222,8 @@\n-    void test8269301(Integer i) {\n+    void test8269301a(Integer i) {\n+        switch (i) {\n+            \/\/error - illegal combination of pattern, constant and default\n+            case 1, Integer o && o != null, default:\n+                break;\n+        }\n+    }\n+    void test8269301b(Integer i) {\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -34,6 +34,9 @@\n-SwitchErrors.java:191:42: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:200:24: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:209:29: compiler.err.total.pattern.and.default\n-SwitchErrors.java:216:42: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:216:45: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:228:18: compiler.err.duplicate.total.pattern\n+SwitchErrors.java:191:21: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:200:42: compiler.err.pattern.dominated\n+SwitchErrors.java:209:24: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:218:29: compiler.err.total.pattern.and.default\n+SwitchErrors.java:225:21: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:225:45: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:232:42: compiler.err.pattern.dominated\n+SwitchErrors.java:232:45: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:244:18: compiler.err.duplicate.total.pattern\n@@ -51,1 +54,1 @@\n-SwitchErrors.java:221:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:237:9: compiler.err.not.exhaustive.statement\n@@ -54,1 +57,1 @@\n-51 errors\n+54 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.out","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -268,1 +268,0 @@\n-            case E x && \"A\".equals(x.name()): return \"broken\";\n@@ -270,0 +269,1 @@\n+            case E x && \"A\".equals(x.name()): return \"broken\";\n@@ -278,1 +278,0 @@\n-            case E x && \"A\".equals(x.name()) -> \"broken\";\n@@ -280,0 +279,1 @@\n+            case E x && \"A\".equals(x.name()) -> \"broken\";\n@@ -289,2 +289,1 @@\n-            case C: return \"broken\";\n-            case null, E x: return String.valueOf(x);\n+            case null, E x: return e == E.C ? \"broken\" : String.valueOf(x);\n@@ -299,2 +298,1 @@\n-            case C -> \"broken\";\n-            case null, E x -> String.valueOf(x);\n+            case null, E x -> e == E.C ? \"broken\" : String.valueOf(x);\n@@ -309,2 +307,1 @@\n-            case C: return \"broken\";\n-            case null, E x: return String.valueOf(x);\n+            case null, E x: return e == E.C ? \"broken\" : String.valueOf(x);\n@@ -319,2 +316,1 @@\n-            case C -> \"broken\";\n-            case null, E x -> String.valueOf(x);\n+            case null, E x -> e == E.C ? \"broken\" : String.valueOf(x);\n@@ -329,2 +325,1 @@\n-            case C: return \"broken\";\n-            case null, E x: return String.valueOf(x);\n+            case null, E x: return e == E.C ? \"broken\" : String.valueOf(x);\n@@ -339,2 +334,1 @@\n-            case C -> \"broken\";\n-            case null, E x -> String.valueOf(x);\n+            case null, E x -> e == E.C ? \"broken\" : String.valueOf(x);\n@@ -349,2 +343,1 @@\n-            case \"C\": return \"broken\";\n-            case null, String x: return String.valueOf(x);\n+            case null, String x: return \"C\".equals(x) ? \"broken\" : String.valueOf(x);\n@@ -359,2 +352,1 @@\n-            case \"C\" -> \"broken\";\n-            case null, String x -> String.valueOf(x);\n+            case null, String x -> e == E.C ? \"broken\" : String.valueOf(x);\n@@ -369,2 +361,1 @@\n-            case 2: return \"broken\";\n-            case null, Integer x: return String.valueOf(x);\n+            case null, Integer x: return Objects.equals(x, 2) ? \"broken\" : String.valueOf(x);\n@@ -379,2 +370,1 @@\n-            case 2 -> \"broken\";\n-            case null, Integer x -> String.valueOf(x);\n+            case null, Integer x -> Objects.equals(x, 2) ? \"broken\" : String.valueOf(x);\n@@ -415,1 +405,0 @@\n-            case -1: r = 1;\n@@ -427,1 +416,0 @@\n-            case -1: r = 1;\n","filename":"test\/langtools\/tools\/javac\/patterns\/Switches.java","additions":12,"deletions":24,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,596 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8224922\n+ * @summary Verify the behavior of the Elements.getFileObjectOf\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.jdeps\/com.sun.tools.classfile\n+ * @build toolbox.ToolBox toolbox.JavacTask toolbox.TestRunner\n+ * @build TestFileObjectOf\n+ * @run main TestFileObjectOf\n+ *\/\n+\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.TreePath;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayDeque;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.Set;\n+\n+import javax.annotation.processing.*;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.*;\n+import javax.lang.model.util.Elements;\n+\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n+import javax.tools.JavaFileObject;\n+import toolbox.JarTask;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+public class TestFileObjectOf extends TestRunner {\n+\n+    private final ToolBox tb;\n+\n+    TestFileObjectOf() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new TestFileObjectOf().runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testSourceFiles(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          module m {}\n+                          \"\"\",\n+                          \"\"\"\n+                          package test;\n+                          \"\"\",\n+                          \"\"\"\n+                          package test;\n+                          public class TestClass {\n+                              int fieldTestClass;\n+                              TestClass() { }\n+                              void methodTestClass(int parameterTestClass) {\n+                                  int localTestClass;\n+                              }\n+                              public static class InnerClass {\n+                                  int fieldInnerClass;\n+                                  InnerClass() {}\n+                                  void methodInnerClass(int parameterInnerClass) {\n+                                      int localInnerClass;\n+                                  }\n+                              }\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package test;\n+                          public enum TestEnum {\n+                              CONSTANT;\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package test2;\n+                          public class TestClass2 {}\n+                          \"\"\");\n+        Path classes = base.resolve(\"classes\").resolve(\"m\");\n+        tb.createDirectories(classes);\n+\n+        \/\/from source, implicit:\n+        {\n+            String moduleInfoSource = src.resolve(\"module-info.java\").toUri().toString();\n+            String packageInfoSource = src.resolve(\"test\").resolve(\"package-info.java\").toUri().toString();\n+            String testClassSource = src.resolve(\"test\").resolve(\"TestClass.java\").toUri().toString();\n+            String testEnumSource = src.resolve(\"test\").resolve(\"TestEnum.java\").toUri().toString();\n+            String testClass2Source = src.resolve(\"test2\").resolve(\"TestClass2.java\").toUri().toString();\n+\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-Xpkginfo:always\",\n+                         \"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", PrintFiles.class.getName(),\n+                         \"-sourcepath\", src.toString())\n+                .outdir(classes)\n+                .classes(\"java.lang.Object\")\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                    \"m: \" + moduleInfoSource,\n+                    \"test: \" + packageInfoSource,\n+                    \"test2: \" + \"<null>\",\n+                    \"TestClass: \" + testClassSource,\n+                    \"TestEnum: \" + testEnumSource,\n+                    \"TestClass2: \" + testClass2Source,\n+                    \"<init>: \" + testClassSource,\n+                    \"InnerClass: \" + testClassSource,\n+                    \"fieldTestClass: \" + testClassSource,\n+                    \"methodTestClass: \" + testClassSource,\n+                    \"parameterTestClass: \" + testClassSource,\n+                    \"localTestClass: \" + testClassSource,\n+                    \"<init>: \" + testEnumSource,\n+                    \"CONSTANT: \" + testEnumSource,\n+                    \"valueOf: \" + testEnumSource,\n+                    \"values: \" + testEnumSource,\n+                    \"<init>: \" + testClass2Source,\n+                    \"<init>: \" + testClassSource,\n+                    \"fieldInnerClass: \" + testClassSource,\n+                    \"methodInnerClass: \" + testClassSource,\n+                    \"parameterInnerClass: \" + testClassSource,\n+                    \"localInnerClass: \" + testClassSource\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+\n+        tb.cleanDirectory(classes);\n+\n+        \/\/from source, explicit:\n+        {\n+            String moduleInfoSource = src.resolve(\"module-info.java\").toUri().toString();\n+            String packageInfoSource = src.resolve(\"test\").resolve(\"package-info.java\").toUri().toString();\n+            String testClassSource = src.resolve(\"test\").resolve(\"TestClass.java\").toUri().toString();\n+            String testEnumSource = src.resolve(\"test\").resolve(\"TestEnum.java\").toUri().toString();\n+            String testClass2Source = src.resolve(\"test2\").resolve(\"TestClass2.java\").toUri().toString();\n+\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-Xpkginfo:always\",\n+                         \"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", PrintFiles.class.getName())\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                    \"m: \" + moduleInfoSource,\n+                    \"test: \" + packageInfoSource,\n+                    \"test2: \" + \"<null>\",\n+                    \"TestClass: \" + testClassSource,\n+                    \"TestEnum: \" + testEnumSource,\n+                    \"TestClass2: \" + testClass2Source,\n+                    \"<init>: \" + testClassSource,\n+                    \"InnerClass: \" + testClassSource,\n+                    \"fieldTestClass: \" + testClassSource,\n+                    \"methodTestClass: \" + testClassSource,\n+                    \"parameterTestClass: \" + testClassSource,\n+                    \"localTestClass: \" + testClassSource,\n+                    \"<init>: \" + testEnumSource,\n+                    \"CONSTANT: \" + testEnumSource,\n+                    \"valueOf: \" + testEnumSource,\n+                    \"values: \" + testEnumSource,\n+                    \"<init>: \" + testClass2Source,\n+                    \"<init>: \" + testClassSource,\n+                    \"fieldInnerClass: \" + testClassSource,\n+                    \"methodInnerClass: \" + testClassSource,\n+                    \"parameterInnerClass: \" + testClassSource,\n+                    \"localInnerClass: \" + testClassSource\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+\n+        \/\/from class:\n+        {\n+            String moduleInfoSource = classes.resolve(\"module-info.class\").toUri().toString();\n+            String packageInfoSource = classes.resolve(\"test\").resolve(\"package-info.class\").toUri().toString();\n+            String testClassSource = classes.resolve(\"test\").resolve(\"TestClass.class\").toUri().toString();\n+            String testInnerClassSource = classes.resolve(\"test\").resolve(\"TestClass$InnerClass.class\").toUri().toString();\n+            String testEnumSource = classes.resolve(\"test\").resolve(\"TestEnum.class\").toUri().toString();\n+            String testClass2Source = classes.resolve(\"test2\").resolve(\"TestClass2.class\").toUri().toString();\n+\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", PrintFiles.class.getName(),\n+                         \"--module-path\", classes.toString(),\n+                         \"--add-modules\", \"m\")\n+                .outdir(classes)\n+                .classes(\"java.lang.Object\")\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                    \"m: \" + moduleInfoSource,\n+                    \"test: \" + packageInfoSource,\n+                    \"test2: \" + \"<null>\",\n+                    \"TestClass: \" + testClassSource,\n+                    \"TestEnum: \" + testEnumSource,\n+                    \"TestClass2: \" + testClass2Source,\n+                    \"<init>: \" + testClassSource,\n+                    \"InnerClass: \" + testInnerClassSource,\n+                    \"fieldTestClass: \" + testClassSource,\n+                    \"methodTestClass: \" + testClassSource,\n+                    \"<clinit>: \" + testEnumSource,\n+                    \"<init>: \" + testEnumSource,\n+                    \"CONSTANT: \" + testEnumSource,\n+                    \"valueOf: \" + testEnumSource,\n+                    \"values: \" + testEnumSource,\n+                    \"<init>: \" + testClass2Source,\n+                    \"<init>: \" + testInnerClassSource,\n+                    \"fieldInnerClass: \" + testInnerClassSource,\n+                    \"methodInnerClass: \" + testInnerClassSource\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    @SupportedOptions(\"fromClass\")\n+    public static final class PrintFiles extends AbstractProcessor {\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            if (!roundEnv.processingOver())\n+                return false;\n+\n+            Elements elements = processingEnv.getElementUtils();\n+            Trees trees = Trees.instance(processingEnv);\n+            Queue<Element> q = new ArrayDeque<>();\n+            q.add(elements.getModuleElement(\"m\"));\n+\n+            while (!q.isEmpty()) {\n+                Element currentElement = q.remove();\n+\n+                handleDeclaration(currentElement);\n+\n+                switch (currentElement.getKind()) {\n+                    case METHOD -> {\n+                        ExecutableElement method = (ExecutableElement) currentElement;\n+                        TreePath tp = trees.getPath(method);\n+                        if (tp != null) {\n+                            new TreePathScanner<>() {\n+                                @Override\n+                                public Object visitVariable(VariableTree node, Object p) {\n+                                    Element el = trees.getElement(getCurrentPath());\n+                                    handleDeclaration(el);\n+                                    return super.visitVariable(node, p);\n+                                }\n+                            }.scan(tp, null);\n+                        }\n+                    }\n+                    case MODULE -> {\n+                        q.add(elements.getPackageElement(\"test\"));\n+                        q.add(elements.getPackageElement(\"test2\"));\n+                    }\n+                    default ->\n+                        currentElement.getEnclosedElements()\n+                                      .stream()\n+                                      .sorted((e1, e2) -> e1.getSimpleName().toString().compareTo(e2.getSimpleName().toString()))\n+                                      .forEach(q::add);\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        void handleDeclaration(Element el) {\n+            Elements elements = processingEnv.getElementUtils();\n+            JavaFileObject fileObjects = elements.getFileObjectOf(el);\n+            System.out.println(el.getSimpleName() + \": \" + (fileObjects != null ? fileObjects.toUri().toString() : \"<null>\"));\n+        }\n+\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latestSupported();\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testUnnamed(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          public class TestClass {\n+                          }\n+                          \"\"\");\n+        Path classes = base.resolve(\"classes\");\n+        tb.createDirectories(classes);\n+\n+        \/\/from source, implicit:\n+        {\n+            String testClassSource = src.resolve(\"TestClass.java\").toUri().toString();\n+\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-Xpkginfo:always\",\n+                         \"-classpath\", \"\",\n+                         \"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", UnnamedPrintFiles.class.getName(),\n+                         \"-sourcepath\", src.toString())\n+                .outdir(classes)\n+                .classes(\"java.lang.Object\")\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                    \": \" + \"<null>\",\n+                    \": \" + \"<null>\",\n+                    \"TestClass: \" + testClassSource,\n+                    \"<init>: \" + testClassSource\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+\n+        tb.cleanDirectory(classes);\n+\n+        \/\/from source, explicit:\n+        {\n+            String testClassSource = src.resolve(\"TestClass.java\").toUri().toString();\n+\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-Xpkginfo:always\",\n+                         \"-classpath\", \"\",\n+                         \"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", UnnamedPrintFiles.class.getName())\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                    \": \" + \"<null>\",\n+                    \": \" + \"<null>\",\n+                    \"TestClass: \" + testClassSource,\n+                    \"<init>: \" + testClassSource\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+\n+        \/\/from class:\n+        {\n+            String testClassSource = classes.resolve(\"TestClass.class\").toUri().toString();\n+\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", UnnamedPrintFiles.class.getName(),\n+                         \"-classpath\", classes.toString())\n+                .outdir(classes)\n+                .classes(\"java.lang.Object\")\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                    \": \" + \"<null>\",\n+                    \": \" + \"<null>\",\n+                    \"TestClass: \" + testClassSource,\n+                    \"<init>: \" + testClassSource\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    @SupportedOptions(\"fromClass\")\n+    public static final class UnnamedPrintFiles extends AbstractProcessor {\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            if (!roundEnv.processingOver())\n+                return false;\n+\n+            Elements elements = processingEnv.getElementUtils();\n+            Trees trees = Trees.instance(processingEnv);\n+            Queue<Element> q = new ArrayDeque<>();\n+            q.add(elements.getModuleElement(\"\"));\n+\n+            while (!q.isEmpty()) {\n+                Element currentElement = q.remove();\n+\n+                handleDeclaration(currentElement);\n+\n+                switch (currentElement.getKind()) {\n+                    case METHOD -> {\n+                        ExecutableElement method = (ExecutableElement) currentElement;\n+                        TreePath tp = trees.getPath(method);\n+                        if (tp != null) {\n+                            new TreePathScanner<>() {\n+                                @Override\n+                                public Object visitVariable(VariableTree node, Object p) {\n+                                    Element el = trees.getElement(getCurrentPath());\n+                                    handleDeclaration(el);\n+                                    return super.visitVariable(node, p);\n+                                }\n+                            }.scan(tp, null);\n+                        }\n+                    }\n+                    case MODULE -> {\n+                        q.add(elements.getPackageElement(\"\"));\n+                    }\n+                    default ->\n+                        currentElement.getEnclosedElements()\n+                                      .stream()\n+                                      .sorted((e1, e2) -> e1.getSimpleName().toString().compareTo(e2.getSimpleName().toString()))\n+                                      .forEach(q::add);\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        void handleDeclaration(Element el) {\n+            Elements elements = processingEnv.getElementUtils();\n+            JavaFileObject fileObjects = elements.getFileObjectOf(el);\n+            System.out.println(el.getSimpleName() + \": \" + (fileObjects != null ? fileObjects.toUri().toString() : \"<null>\"));\n+        }\n+\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latestSupported();\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testAutomaticModule(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          public class TestClass {\n+                          }\n+                          \"\"\");\n+        Path classes = base.resolve(\"classes\");\n+        tb.createDirectories(classes);\n+\n+        Path module = base.resolve(\"m.jar\");\n+\n+        new JavacTask(tb)\n+            .options(\"-classpath\", \"\")\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run()\n+            .writeAll();\n+        new JarTask(tb, module)\n+            .baseDir(classes)\n+            .files(\".\")\n+            .run();\n+\n+        String testClassSource = \"jar:\" + module.toUri().toString() + \"!\/test\/TestClass.class\";\n+\n+        List<String> log;\n+\n+        log = new JavacTask(tb)\n+            .options(\"-processorpath\", System.getProperty(\"test.classes\"),\n+                     \"-processor\", AutomaticModulePrintFiles.class.getName(),\n+                     \"--module-path\", module.toString(),\n+                     \"--add-modules\", \"m\")\n+            .outdir(classes)\n+            .classes(\"java.lang.Object\")\n+            .run()\n+            .writeAll()\n+            .getOutputLines(Task.OutputKind.STDOUT);\n+\n+        List<String> expected = List.of(\n+                \"m: \" + \"<null>\",\n+                \"test: \" + \"<null>\",\n+                \"TestClass: \" + testClassSource,\n+                \"<init>: \" + testClassSource\n+        );\n+\n+        if (!expected.equals(log))\n+            throw new AssertionError(\"expected output not found: \" + log);\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    @SupportedOptions(\"fromClass\")\n+    public static final class AutomaticModulePrintFiles extends AbstractProcessor {\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            if (!roundEnv.processingOver())\n+                return false;\n+\n+            Elements elements = processingEnv.getElementUtils();\n+            Trees trees = Trees.instance(processingEnv);\n+            Queue<Element> q = new ArrayDeque<>();\n+            q.add(elements.getModuleElement(\"m\"));\n+\n+            while (!q.isEmpty()) {\n+                Element currentElement = q.remove();\n+\n+                handleDeclaration(currentElement);\n+\n+                switch (currentElement.getKind()) {\n+                    case METHOD -> {\n+                        ExecutableElement method = (ExecutableElement) currentElement;\n+                        TreePath tp = trees.getPath(method);\n+                        if (tp != null) {\n+                            new TreePathScanner<>() {\n+                                @Override\n+                                public Object visitVariable(VariableTree node, Object p) {\n+                                    Element el = trees.getElement(getCurrentPath());\n+                                    handleDeclaration(el);\n+                                    return super.visitVariable(node, p);\n+                                }\n+                            }.scan(tp, null);\n+                        }\n+                    }\n+                    case MODULE -> {\n+                        q.add(elements.getPackageElement(\"test\"));\n+                    }\n+                    default ->\n+                        currentElement.getEnclosedElements()\n+                                      .stream()\n+                                      .sorted((e1, e2) -> e1.getSimpleName().toString().compareTo(e2.getSimpleName().toString()))\n+                                      .forEach(q::add);\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        void handleDeclaration(Element el) {\n+            Elements elements = processingEnv.getElementUtils();\n+            JavaFileObject fileObjects = elements.getFileObjectOf(el);\n+            System.out.println(el.getSimpleName() + \": \" + (fileObjects != null ? fileObjects.toUri().toString() : \"<null>\"));\n+        }\n+\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latestSupported();\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestFileObjectOf.java","additions":596,"deletions":0,"binary":false,"changes":596,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8261847\n+ * @summary test the output of the toString method of records with a large number of components\n+ * @run testng BigRecordsToStringTest\n+ *\/\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Parameter;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+import org.testng.annotations.*;\n+import static org.testng.Assert.*;\n+\n+@Test\n+public class BigRecordsToStringTest {\n+    record BigInt(\n+            int i1,int i2,int i3,int i4,int i5,int i6,int i7,int i8,int i9,int i10,\n+            int i11,int i12,int i13,int i14,int i15,int i16,int i17,int i18,int i19,int i20,\n+            int i21,int i22,int i23,int i24,int i25,int i26,int i27,int i28,int i29,int i30,\n+            int i31,int i32,int i33,int i34,int i35,int i36,int i37,int i38,int i39,int i40,\n+            int i41,int i42,int i43,int i44,int i45,int i46,int i47,int i48,int i49,int i50,\n+            int i51,int i52,int i53,int i54,int i55,int i56,int i57,int i58,int i59,int i60,\n+            int i61,int i62,int i63,int i64,int i65,int i66,int i67,int i68,int i69,int i70,\n+            int i71,int i72,int i73,int i74,int i75,int i76,int i77,int i78,int i79,int i80,\n+            int i81,int i82,int i83,int i84,int i85,int i86,int i87,int i88,int i89,int i90,\n+            int i91,int i92,int i93,int i94,int i95,int i96,int i97,int i98,int i99,int i100,\n+            int i101,int i102,int i103,int i104,int i105,int i106,int i107,int i108,int i109,int i110,\n+            int i111,int i112,int i113,int i114,int i115,int i116,int i117,int i118,int i119,int i120,\n+            int i121,int i122,int i123,int i124,int i125,int i126,int i127,int i128,int i129,int i130,\n+            int i131,int i132,int i133,int i134,int i135,int i136,int i137,int i138,int i139,int i140,\n+            int i141,int i142,int i143,int i144,int i145,int i146,int i147,int i148,int i149,int i150,\n+            int i151,int i152,int i153,int i154,int i155,int i156,int i157,int i158,int i159,int i160,\n+            int i161,int i162,int i163,int i164,int i165,int i166,int i167,int i168,int i169,int i170,\n+            int i171,int i172,int i173,int i174,int i175,int i176,int i177,int i178,int i179,int i180,\n+            int i181,int i182,int i183,int i184,int i185,int i186,int i187,int i188,int i189,int i190,\n+            int i191,int i192,int i193,int i194,int i195,int i196,int i197,int i198,int i199, int i200,\n+            int i201,int i202,int i203,int i204,int i205,int i206,int i207,int i208,int i209,int i210,\n+            int i211,int i212,int i213,int i214,int i215,int i216,int i217,int i218,int i219,int i220,\n+            int i221,int i222,int i223,int i224,int i225,int i226,int i227,int i228,int i229,int i230,\n+            int i231,int i232,int i233,int i234,int i235,int i236,int i237,int i238,int i239,int i240,\n+            int i241,int i242,int i243,int i244,int i245,int i246,int i247,int i248,int i249,int i250,\n+            int i251,int i252,int i253,int i254\n+    ) {}\n+\n+    BigInt bigInt= new BigInt(\n+            1,2,3,4,5,6,7,8,9,10,\n+            11,12,13,14,15,16,17,18,19,20,\n+            21,22,23,24,25,26,27,28,29,30,\n+            31,32,33,34,35,36,37,38,39,40,\n+            41,42,43,44,45,46,47,48,49,50,\n+            51,52,53,54,55,56,57,58,59,60,\n+            61,62,63,64,65,66,67,68,69,70,\n+            71,72,73,74,75,76,77,78,79,80,\n+            81,82,83,84,85,86,87,88,89,90,\n+            91,92,93,94,95,96,97,98,99,100,\n+            101,102,103,104,105,106,107,108,109,110,\n+            111,112,113,114,115,116,117,118,119,120,\n+            121,122,123,124,125,126,127,128,129,130,\n+            131,132,133,134,135,136,137,138,139,140,\n+            141,142,143,144,145,146,147,148,149,150,\n+            151,152,153,154,155,156,157,158,159,160,\n+            161,162,163,164,165,166,167,168,169,170,\n+            171,172,173,174,175,176,177,178,179,180,\n+            181,182,183,184,185,186,187,188,189,190,\n+            191,192,193,194,195,196,197,198,199, 200,\n+            201,202,203,204,205,206,207,208,209,210,\n+            211,212,213,214,215,216,217,218,219,220,\n+            221,222,223,224,225,226,227,228,229,230,\n+            231,232,233,234,235,236,237,238,239,240,\n+            241,242,243,244,245,246,247,248,249,250,\n+            251,252,253,254\n+    );\n+\n+    record BigLong(\n+            long i1,long i2,long i3,long i4,long i5,long i6,long i7,long i8,long i9,long i10,\n+            long i11,long i12,long i13,long i14,long i15,long i16,long i17,long i18,long i19,long i20,\n+            long i21,long i22,long i23,long i24,long i25,long i26,long i27,long i28,long i29,long i30,\n+            long i31,long i32,long i33,long i34,long i35,long i36,long i37,long i38,long i39,long i40,\n+            long i41,long i42,long i43,long i44,long i45,long i46,long i47,long i48,long i49,long i50,\n+            long i51,long i52,long i53,long i54,long i55,long i56,long i57,long i58,long i59,long i60,\n+            long i61,long i62,long i63,long i64,long i65,long i66,long i67,long i68,long i69,long i70,\n+            long i71,long i72,long i73,long i74,long i75,long i76,long i77,long i78,long i79,long i80,\n+            long i81,long i82,long i83,long i84,long i85,long i86,long i87,long i88,long i89,long i90,\n+            long i91,long i92,long i93,long i94,long i95,long i96,long i97,long i98,long i99,long i100,\n+            long i101,long i102,long i103,long i104,long i105,long i106,long i107,long i108,long i109,long i110,\n+            long i111,long i112,long i113,long i114,long i115,long i116,long i117,long i118,long i119,long i120,\n+            long i121,long i122,long i123,long i124,long i125,long i126,long i127\n+    ) {}\n+\n+    BigLong bigLong = new BigLong(\n+            1,2,3,4,5,6,7,8,9,10,\n+            11,12,13,14,15,16,17,18,19,20,\n+            21,22,23,24,25,26,27,28,29,30,\n+            31,32,33,34,35,36,37,38,39,40,\n+            41,42,43,44,45,46,47,48,49,50,\n+            51,52,53,54,55,56,57,58,59,60,\n+            61,62,63,64,65,66,67,68,69,70,\n+            71,72,73,74,75,76,77,78,79,80,\n+            81,82,83,84,85,86,87,88,89,90,\n+            91,92,93,94,95,96,97,98,99,100,\n+            101,102,103,104,105,106,107,108,109,110,\n+            111,112,113,114,115,116,117,118,119,120,\n+            121,122,123,124,125,126,127\n+    );\n+\n+    private static final String BIG_INT_TO_STRING_OUTPUT =\n+        \"BigInt[i1=1, i2=2, i3=3, i4=4, i5=5, i6=6, i7=7, i8=8, i9=9, i10=10, i11=11, i12=12, i13=13, i14=14, i15=15, i16=16, \" +\n+            \"i17=17, i18=18, i19=19, i20=20, i21=21, i22=22, i23=23, i24=24, i25=25, i26=26, i27=27, i28=28, i29=29, i30=30, \" +\n+            \"i31=31, i32=32, i33=33, i34=34, i35=35, i36=36, i37=37, i38=38, i39=39, i40=40, i41=41, i42=42, i43=43, i44=44, \" +\n+            \"i45=45, i46=46, i47=47, i48=48, i49=49, i50=50, i51=51, i52=52, i53=53, i54=54, i55=55, i56=56, i57=57, i58=58, \" +\n+            \"i59=59, i60=60, i61=61, i62=62, i63=63, i64=64, i65=65, i66=66, i67=67, i68=68, i69=69, i70=70, i71=71, i72=72, \" +\n+            \"i73=73, i74=74, i75=75, i76=76, i77=77, i78=78, i79=79, i80=80, i81=81, i82=82, i83=83, i84=84, i85=85, i86=86, \" +\n+            \"i87=87, i88=88, i89=89, i90=90, i91=91, i92=92, i93=93, i94=94, i95=95, i96=96, i97=97, i98=98, i99=99, i100=100, \" +\n+            \"i101=101, i102=102, i103=103, i104=104, i105=105, i106=106, i107=107, i108=108, i109=109, i110=110, i111=111, i112=112, \" +\n+            \"i113=113, i114=114, i115=115, i116=116, i117=117, i118=118, i119=119, i120=120, i121=121, i122=122, i123=123, i124=124, \" +\n+            \"i125=125, i126=126, i127=127, i128=128, i129=129, i130=130, i131=131, i132=132, i133=133, i134=134, i135=135, i136=136, \" +\n+            \"i137=137, i138=138, i139=139, i140=140, i141=141, i142=142, i143=143, i144=144, i145=145, i146=146, i147=147, i148=148, \" +\n+            \"i149=149, i150=150, i151=151, i152=152, i153=153, i154=154, i155=155, i156=156, i157=157, i158=158, i159=159, i160=160, \" +\n+            \"i161=161, i162=162, i163=163, i164=164, i165=165, i166=166, i167=167, i168=168, i169=169, i170=170, i171=171, i172=172, \" +\n+            \"i173=173, i174=174, i175=175, i176=176, i177=177, i178=178, i179=179, i180=180, i181=181, i182=182, i183=183, i184=184, \" +\n+            \"i185=185, i186=186, i187=187, i188=188, i189=189, i190=190, i191=191, i192=192, i193=193, i194=194, i195=195, i196=196, \" +\n+            \"i197=197, i198=198, i199=199, i200=200, i201=201, i202=202, i203=203, i204=204, i205=205, i206=206, i207=207, i208=208, \" +\n+            \"i209=209, i210=210, i211=211, i212=212, i213=213, i214=214, i215=215, i216=216, i217=217, i218=218, i219=219, i220=220, \" +\n+            \"i221=221, i222=222, i223=223, i224=224, i225=225, i226=226, i227=227, i228=228, i229=229, i230=230, i231=231, i232=232, \" +\n+            \"i233=233, i234=234, i235=235, i236=236, i237=237, i238=238, i239=239, i240=240, i241=241, i242=242, i243=243, i244=244, \" +\n+            \"i245=245, i246=246, i247=247, i248=248, i249=249, i250=250, i251=251, i252=252, i253=253, i254=254]\";\n+\n+    private static final String BIG_LONG_TO_STRING_OUTPUT =\n+        \"BigLong[i1=1, i2=2, i3=3, i4=4, i5=5, i6=6, i7=7, i8=8, i9=9, i10=10, i11=11, i12=12, i13=13, i14=14, i15=15, i16=16, i17=17, \" +\n+            \"i18=18, i19=19, i20=20, i21=21, i22=22, i23=23, i24=24, i25=25, i26=26, i27=27, i28=28, i29=29, i30=30, i31=31, i32=32, i33=33, \" +\n+            \"i34=34, i35=35, i36=36, i37=37, i38=38, i39=39, i40=40, i41=41, i42=42, i43=43, i44=44, i45=45, i46=46, i47=47, i48=48, i49=49, \" +\n+            \"i50=50, i51=51, i52=52, i53=53, i54=54, i55=55, i56=56, i57=57, i58=58, i59=59, i60=60, i61=61, i62=62, i63=63, i64=64, i65=65, \" +\n+            \"i66=66, i67=67, i68=68, i69=69, i70=70, i71=71, i72=72, i73=73, i74=74, i75=75, i76=76, i77=77, i78=78, i79=79, i80=80, i81=81, \" +\n+            \"i82=82, i83=83, i84=84, i85=85, i86=86, i87=87, i88=88, i89=89, i90=90, i91=91, i92=92, i93=93, i94=94, i95=95, i96=96, i97=97, \" +\n+            \"i98=98, i99=99, i100=100, i101=101, i102=102, i103=103, i104=104, i105=105, i106=106, i107=107, i108=108, i109=109, i110=110, \" +\n+            \"i111=111, i112=112, i113=113, i114=114, i115=115, i116=116, i117=117, i118=118, i119=119, i120=120, i121=121, i122=122, i123=123, \" +\n+            \"i124=124, i125=125, i126=126, i127=127]\";\n+\n+    public void testToStringOutput() {\n+        assertTrue(bigInt.toString().equals(BIG_INT_TO_STRING_OUTPUT));\n+        assertTrue(bigLong.toString().equals(BIG_LONG_TO_STRING_OUTPUT));\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/records\/BigRecordsToStringTest.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -92,1 +92,2 @@\n-            \"javax.annotation.processing.SupportedSourceVersion\"\n+            \"javax.annotation.processing.SupportedSourceVersion\",\n+            \"javax.tools.JavaFileObject\"\n","filename":"test\/langtools\/tools\/javac\/tree\/NoPrivateTypesExported.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-                \"  0: #21(#22=B#23)\\n\" +\n+                \"  0: #17(#18=B#19)\\n\" +\n@@ -56,1 +56,1 @@\n-                \"  1: #24(#22=S#25)\\n\" +\n+                \"  1: #20(#18=S#21)\\n\" +\n@@ -62,1 +62,1 @@\n-                \"  0: #27(#22=[J#28,J#30,J#32,J#34,J#36])\\n\" +\n+                \"  0: #23(#18=[J#24,J#26,J#28,J#30,J#32])\\n\" +\n@@ -66,1 +66,1 @@\n-                \"  1: #38(#22=Z#39)\\n\" +\n+                \"  1: #34(#18=Z#35)\\n\" +\n@@ -70,1 +70,1 @@\n-                \"  2: #40(#41=c#42)\\n\" +\n+                \"  2: #36(#37=c#38)\\n\" +\n@@ -74,1 +74,1 @@\n-                \"  3: #43(#44=e#45.#46)\\n\" +\n+                \"  3: #39(#40=e#41.#42)\\n\" +\n@@ -78,1 +78,1 @@\n-                \"  4: #47(#22=I#48)\\n\" +\n+                \"  4: #43(#18=I#44)\\n\" +\n@@ -82,1 +82,1 @@\n-                \"  5: #49()\\n\" +\n+                \"  5: #45()\\n\" +\n@@ -84,1 +84,1 @@\n-                \"  6: #50(#51=s#52)\\n\" +\n+                \"  6: #46(#47=s#48)\\n\" +\n@@ -88,1 +88,1 @@\n-                \"  7: #53(#54=D#55,#57=F#58)\\n\" +\n+                \"  7: #49(#50=D#51,#53=F#54)\\n\" +\n@@ -93,1 +93,1 @@\n-                \"  8: #59()\\n\" +\n+                \"  8: #55()\\n\" +\n@@ -95,1 +95,1 @@\n-                \"  9: #60(#22=@#47(#22=I#61))\\n\" +\n+                \"  9: #56(#18=@#43(#18=I#57))\\n\" +\n@@ -103,1 +103,1 @@\n-                \"  0: #63(): CLASS_EXTENDS, type_index=0\\n\" +\n+                \"  0: #59(): CLASS_EXTENDS, type_index=0\\n\" +\n","filename":"test\/langtools\/tools\/javap\/AnnoTest.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8277165\n+ * @library ..\/lib\n+ * @build CompilerUtils\n+ * @run testng MultiVersionError\n+ * @summary Tests multiple versions of the same class file\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Set;\n+import java.util.spi.ToolProvider;\n+\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertTrue;\n+\n+public class MultiVersionError {\n+    private static final String TEST_SRC = System.getProperty(\"test.src\");\n+    private static final Path SRC_DIR = Paths.get(TEST_SRC, \"src\");\n+\n+    private static final Path MODS_DIR = Paths.get(\"mods\");\n+\n+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\").orElseThrow();\n+    private static final Set<String> modules = Set.of(\"m1\", \"m2\");\n+\n+    \/**\n+     * Compiles classes used by the test\n+     *\/\n+    @BeforeTest\n+    public void compileAll() throws Exception {\n+        CompilerUtils.cleanDir(MODS_DIR);\n+        modules.forEach(mn ->\n+                assertTrue(CompilerUtils.compileModule(SRC_DIR, MODS_DIR, mn)));\n+\n+        \/\/ create a modular multi-release m1.jar\n+        Path m1 = MODS_DIR.resolve(\"m1\");\n+        Path m2 = MODS_DIR.resolve(\"m2\");\n+        jar(\"cf\", \"m1.jar\", \"-C\", m1.toString(), \"p\/Test.class\",\n+                \"--release\", \"9\", \"-C\", m1.toString(), \"module-info.class\",\n+                \"--release\", \"11\", \"-C\", m1.toString(), \"p\/internal\/P.class\");\n+        jar(\"cf\", \"m2.jar\", \"-C\", m2.toString(), \"q\/Q.class\",\n+                \"--release\", \"10\", \"-C\", m2.toString(), \"module-info.class\");\n+\n+        \/\/ package private p\/internal\/P.class in m1 instead\n+        jar(\"cf\", \"m3.jar\", \"-C\", m2.toString(), \"q\/Q.class\",\n+                \"--release\", \"12\", \"-C\", m2.toString(), \"module-info.class\",\n+                \"-C\", m1.toString(), \"p\/internal\/P.class\");\n+    }\n+\n+    \/*\n+     * multiple module-info.class from different versions should be excluded\n+     * from multiple version check.\n+     *\/\n+    @Test\n+    public void noMultiVersionClass() {\n+        \/\/ skip parsing p.internal.P to workaround JDK-8277681\n+        JdepsRunner jdepsRunner = new JdepsRunner(\"--print-module-deps\", \"--multi-release\", \"10\",\n+                                                  \"--ignore-missing-deps\",\n+                                                  \"--module-path\", \"m1.jar\", \"m2.jar\");\n+        int rc = jdepsRunner.run(true);\n+        assertTrue(rc == 0);\n+        assertTrue(jdepsRunner.outputContains(\"java.base,m1\"));\n+    }\n+\n+    \/*\n+     * Detect multiple versions of p.internal.P class\n+     *\/\n+    @Test\n+    public void classInMultiVersions() {\n+        JdepsRunner jdepsRunner = new JdepsRunner(\"--print-module-deps\", \"--multi-release\", \"13\",\n+                                                  \"--module-path\", \"m1.jar\", \"m3.jar\");\n+        int rc = jdepsRunner.run(true);\n+        assertTrue(rc != 0);\n+        assertTrue(jdepsRunner.outputContains(\"class p.internal.P already associated with version\"));\n+    }\n+\n+    private static void jar(String... options) {\n+        int rc = JAR_TOOL.run(System.out, System.err, options);\n+        assertTrue(rc == 0);\n+    }\n+}\n","filename":"test\/langtools\/tools\/jdeps\/multiVersion\/MultiVersionError.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module m1 {\n+    requires java.management;\n+    exports p;\n+}\n","filename":"test\/langtools\/tools\/jdeps\/multiVersion\/src\/m1\/module-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p;\n+\n+public class Test {\n+}\n","filename":"test\/langtools\/tools\/jdeps\/multiVersion\/src\/m1\/p\/Test.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p.internal;\n+\n+import java.lang.management.*;\n+\n+class P {\n+     private static RuntimeMXBean mxbean = ManagementFactory.getRuntimeMXBean();\n+}\n","filename":"test\/langtools\/tools\/jdeps\/multiVersion\/src\/m1\/p\/internal\/P.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module m2 {\n+    requires m1;\n+    requires java.logging;\n+}\n","filename":"test\/langtools\/tools\/jdeps\/multiVersion\/src\/m2\/module-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p.internal;\n+\n+import java.util.logging.Logger;\n+\n+public class P {\n+     private static final Logger LOGGER = Logger.getLogger(\"p\");\n+}\n","filename":"test\/langtools\/tools\/jdeps\/multiVersion\/src\/m2\/p\/internal\/P.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package q;\n+\n+public class Q {\n+    static p.Test t = new p.Test();\n+\n+    public Q() {\n+        Object o = new p.internal.P();\n+    }\n+}\n","filename":"test\/langtools\/tools\/jdeps\/multiVersion\/src\/m2\/q\/Q.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.arm.benchmarks.intrinsics;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+\/**\n+ * This benchmark modified from test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestStringCompareToDifferentLength.java\n+ * This benchmark can be used to measure performance of compareTo() in\n+ * (Latin1, Latin1), (Latin1, UTF16), (UTF16, Latin1), and (UTF16, UTF16)\n+ * comparisons.\n+ *\/\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Measurement(iterations = 3, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 3, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+public class StringCompareToDifferentLength {\n+\n+    @State(Scope.Benchmark)\n+    public static class Input {\n+        @Param({\"24\", \"36\", \"72\", \"128\", \"256\", \"512\"})\n+        public int size;\n+\n+        @Param({\"2\"})\n+        public int delta;\n+\n+        int count = 100000;\n+        String longLatin1;\n+        String shortLatin1;\n+        String longUTF16FirstChar;\n+        String shortUTF16FirstChar;\n+        String longUTF16LastChar;\n+        String shortUTF16LastChar;\n+\n+        \/**\n+         * Initialize. New array objects and set initial values.\n+         *\/\n+        @Setup(Level.Trial)\n+        public void setup() throws Exception {\n+            char[] strsrc = new char[size + delta];\n+            \/\/ generate ASCII string\n+            for (int i = 0; i < size + delta; i++) {\n+                strsrc[i] = (char) ('a' + (i % 26));\n+            }\n+\n+            longLatin1 = new String(strsrc);\n+            shortLatin1 = longLatin1.substring(0, size);\n+            longUTF16LastChar = longLatin1.substring(0, longLatin1.length() - 1) + '\\ubeef';\n+            longUTF16FirstChar = '\\ubeef' + longLatin1.substring(1, longLatin1.length());\n+            shortUTF16LastChar = shortLatin1.substring(0, shortLatin1.length() - 1) + '\\ubeef';\n+            shortUTF16FirstChar = longUTF16FirstChar.substring(0, size);\n+        }\n+    }\n+\n+    private int runCompareTo(String str2, String str1) {\n+        return str1.compareTo(str2);\n+    }\n+\n+    \/**\n+     * latin1-latin1\n+     *\/\n+    @Benchmark\n+    public void compareToLL(Input in, Blackhole blackhole) {\n+        int res = 0;\n+        for (int i = 0; i < in.count; ++i) {\n+            res += runCompareTo(in.longLatin1, in.shortLatin1);\n+        }\n+        blackhole.consume(res);\n+    }\n+\n+    \/**\n+     * UTF16-UTF16\n+     *\/\n+    @Benchmark\n+    public void compareToUU(Input in, Blackhole blackhole) {\n+        int res = 0;\n+        for (int i = 0; i < in.count; ++i) {\n+            res += runCompareTo(in.longUTF16FirstChar, in.shortUTF16FirstChar);\n+        }\n+        blackhole.consume(res);\n+    }\n+\n+    \/**\n+     * latin1-UTF16\n+     *\/\n+    @Benchmark\n+    public void compareToLU(Input in, Blackhole blackhole) {\n+        int res = 0;\n+        for (int i = 0; i < in.count; ++i) {\n+            res += runCompareTo(in.longUTF16LastChar, in.shortLatin1);\n+        }\n+        blackhole.consume(res);\n+    }\n+\n+    \/**\n+     * UTF16-latin1\n+     *\/\n+    @Benchmark\n+    public void compareToUL(Input in, Blackhole blackhole) {\n+        int res = 0;\n+        for (int i = 0; i < in.count; ++i) {\n+            res += runCompareTo(in.longLatin1, in.shortUTF16LastChar);\n+        }\n+        blackhole.consume(res);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringCompareToDifferentLength.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -196,0 +196,1 @@\n+        threadConsumer.join();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ThreadOnSpinWaitProducerConsumer.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.runtime;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Benchmark assesses Record.toString which is implemented by ObjectMethods::makeToString\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class ObjectMethods {\n+    record R0() {}\n+    record R1(int i) {}\n+    record R10(int i1,int i2,int i3,int i4,int i5,int i6,int i7,int i8,int i9,int i10) {}\n+    record R100(int i1,int i2,int i3,int i4,int i5,int i6,int i7,int i8,int i9,int i10,\n+                int i11,int i12,int i13,int i14,int i15,int i16,int i17,int i18,int i19,int i20,\n+                int i21,int i22,int i23,int i24,int i25,int i26,int i27,int i28,int i29,int i30,\n+                int i31,int i32,int i33,int i34,int i35,int i36,int i37,int i38,int i39,int i40,\n+                int i41,int i42,int i43,int i44,int i45,int i46,int i47,int i48,int i49,int i50,\n+                int i51,int i52,int i53,int i54,int i55,int i56,int i57,int i58,int i59,int i60,\n+                int i61,int i62,int i63,int i64,int i65,int i66,int i67,int i68,int i69,int i70,\n+                int i71,int i72,int i73,int i74,int i75,int i76,int i77,int i78,int i79,int i80,\n+                int i81,int i82,int i83,int i84,int i85,int i86,int i87,int i88,int i89,int i90,\n+                int i91,int i92,int i93,int i94,int i95,int i96,int i97,int i98,int i99,int i100) {}\n+    record R254(int i1,int i2,int i3,int i4,int i5,int i6,int i7,int i8,int i9,int i10,\n+                int i11,int i12,int i13,int i14,int i15,int i16,int i17,int i18,int i19,int i20,\n+                int i21,int i22,int i23,int i24,int i25,int i26,int i27,int i28,int i29,int i30,\n+                int i31,int i32,int i33,int i34,int i35,int i36,int i37,int i38,int i39,int i40,\n+                int i41,int i42,int i43,int i44,int i45,int i46,int i47,int i48,int i49,int i50,\n+                int i51,int i52,int i53,int i54,int i55,int i56,int i57,int i58,int i59,int i60,\n+                int i61,int i62,int i63,int i64,int i65,int i66,int i67,int i68,int i69,int i70,\n+                int i71,int i72,int i73,int i74,int i75,int i76,int i77,int i78,int i79,int i80,\n+                int i81,int i82,int i83,int i84,int i85,int i86,int i87,int i88,int i89,int i90,\n+                int i91,int i92,int i93,int i94,int i95,int i96,int i97,int i98,int i99,int i100,\n+                int i101,int i102,int i103,int i104,int i105,int i106,int i107,int i108,int i109,int i110,\n+                int i111,int i112,int i113,int i114,int i115,int i116,int i117,int i118,int i119,int i120,\n+                int i121,int i122,int i123,int i124,int i125,int i126,int i127,int i128,int i129,int i130,\n+                int i131,int i132,int i133,int i134,int i135,int i136,int i137,int i138,int i139,int i140,\n+                int i141,int i142,int i143,int i144,int i145,int i146,int i147,int i148,int i149,int i150,\n+                int i151,int i152,int i153,int i154,int i155,int i156,int i157,int i158,int i159,int i160,\n+                int i161,int i162,int i163,int i164,int i165,int i166,int i167,int i168,int i169,int i170,\n+                int i171,int i172,int i173,int i174,int i175,int i176,int i177,int i178,int i179,int i180,\n+                int i181,int i182,int i183,int i184,int i185,int i186,int i187,int i188,int i189,int i190,\n+                int i191,int i192,int i193,int i194,int i195,int i196,int i197,int i198,int i199, int i200,\n+                int i201,int i202,int i203,int i204,int i205,int i206,int i207,int i208,int i209,int i210,\n+                int i211,int i212,int i213,int i214,int i215,int i216,int i217,int i218,int i219,int i220,\n+                int i221,int i222,int i223,int i224,int i225,int i226,int i227,int i228,int i229,int i230,\n+                int i231,int i232,int i233,int i234,int i235,int i236,int i237,int i238,int i239,int i240,\n+                int i241,int i242,int i243,int i244,int i245,int i246,int i247,int i248,int i249,int i250,\n+                int i251,int i252,int i253,int i254) {}\n+\n+    R0 r0;\n+    R1 r1;\n+    R10 r10;\n+    R100 r100;\n+    R254 r254;\n+\n+    @Setup\n+    public void prepare() {\n+        r0 = new R0();\n+        r1 = new R1(1);\n+        r10 = new R10(1,2,3,4,5,6,7,8,9,10);\n+        r100 = new R100(1,2,3,4,5,6,7,8,9,10,\n+                        11,12,13,14,15,16,17,18,19,20,\n+                        21,22,23,24,25,26,27,28,29,30,\n+                        31,32,33,34,35,36,37,38,39,40,\n+                        41,42,43,44,45,46,47,48,49,50,\n+                        51,52,53,54,55,56,57,58,59,60,\n+                        61,62,63,64,65,66,67,68,69,70,\n+                        71,72,73,74,75,76,77,78,79,80,\n+                        81,82,83,84,85,86,87,88,89,90,\n+                        91,92,93,94,95,96,97,98,99,100);\n+        r254 = new R254(1,2,3,4,5,6,7,8,9,10,\n+                        11,12,13,14,15,16,17,18,19,20,\n+                        21,22,23,24,25,26,27,28,29,30,\n+                        31,32,33,34,35,36,37,38,39,40,\n+                        41,42,43,44,45,46,47,48,49,50,\n+                        51,52,53,54,55,56,57,58,59,60,\n+                        61,62,63,64,65,66,67,68,69,70,\n+                        71,72,73,74,75,76,77,78,79,80,\n+                        81,82,83,84,85,86,87,88,89,90,\n+                        91,92,93,94,95,96,97,98,99,100,\n+                        101,102,103,104,105,106,107,108,109,110,\n+                        111,112,113,114,115,116,117,118,119,120,\n+                        121,122,123,124,125,126,127,128,129,130,\n+                        131,132,133,134,135,136,137,138,139,140,\n+                        141,142,143,144,145,146,147,148,149,150,\n+                        151,152,153,154,155,156,157,158,159,160,\n+                        161,162,163,164,165,166,167,168,169,170,\n+                        171,172,173,174,175,176,177,178,179,180,\n+                        181,182,183,184,185,186,187,188,189,190,\n+                        191,192,193,194,195,196,197,198,199, 200,\n+                        201,202,203,204,205,206,207,208,209,210,\n+                        211,212,213,214,215,216,217,218,219,220,\n+                        221,222,223,224,225,226,227,228,229,230,\n+                        231,232,233,234,235,236,237,238,239,240,\n+                        241,242,243,244,245,246,247,248,249,250,\n+                        251,252,253,254);\n+    }\n+\n+    @Benchmark\n+    public String toString0() {\n+        return r0.toString();\n+    }\n+\n+    @Benchmark\n+    public String toString1() {\n+        return r1.toString();\n+    }\n+\n+    @Benchmark\n+    public String toString10() {\n+        return r10.toString();\n+    }\n+\n+    @Benchmark\n+    public String toString100() {\n+        return r100.toString();\n+    }\n+\n+    @Benchmark\n+    public String toString254() {\n+        return r254.toString();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/runtime\/ObjectMethods.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.util.regex;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value=1, jvmArgs= {\"-showversion\", \"-XX:+UseSerialGC\"})\n+@Warmup(iterations = 1, time = 10, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 10, timeUnit = TimeUnit.SECONDS)\n+public class FindPattern {\n+    @Param({\"[^A-Za-z0-9]\", \"[A-Za-z0-9]\"})\n+    static String patternString;\n+    @Param({\"abcdefghijklmnop1234567890ABCDEFGHIJKLMNOP\",\n+            \",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\"})\n+    static String text;\n+    static Pattern pattern;\n+\n+    @Setup(Level.Trial)\n+    public void setupTrial() {\n+        pattern = Pattern.compile(patternString);\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.AverageTime)\n+    public int testFind() {\n+        int counter = 0;\n+        Matcher m = pattern.matcher(text);\n+        while (m.find()) {\n+            counter++;\n+        }\n+        return counter;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/regex\/FindPattern.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -128,1 +128,1 @@\n-        MemorySegment str = MemorySegment.ofAddressNative(address, len + 1, ResourceScope.globalScope());\n+        MemorySegment str = MemorySegment.ofAddress(address, len + 1, ResourceScope.globalScope());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,2 +69,2 @@\n-            this.inputSegment = MemorySegment.ofAddressNative(MemoryAddress.ofLong(inputAddress), 8*SIZE, ResourceScope.globalScope());\n-            this.outputSegment = MemorySegment.ofAddressNative(MemoryAddress.ofLong(outputAddress), 8*SIZE, ResourceScope.globalScope());\n+            this.inputSegment = MemorySegment.ofAddress(MemoryAddress.ofLong(inputAddress), 8*SIZE, ResourceScope.globalScope());\n+            this.outputSegment = MemorySegment.ofAddress(MemoryAddress.ofLong(outputAddress), 8*SIZE, ResourceScope.globalScope());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/UnrolledAccess.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -243,2 +243,2 @@\n-      final var srcBufferSegmentConfined = MemorySegment.ofAddressNative(srcAddress, size, scope).asByteBuffer();\n-      final var dstBufferSegmentConfined = MemorySegment.ofAddressNative(dstAddress, size, scope).asByteBuffer();\n+      final var srcBufferSegmentConfined = MemorySegment.ofAddress(srcAddress, size, scope).asByteBuffer();\n+      final var dstBufferSegmentConfined = MemorySegment.ofAddress(dstAddress, size, scope).asByteBuffer();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -213,2 +213,2 @@\n-      final var srcBufferSegmentConfined = MemorySegment.ofAddressNative(srcAddress, size, scope).asByteBuffer();\n-      final var dstBufferSegmentConfined = MemorySegment.ofAddressNative(dstAddress, size, scope).asByteBuffer();\n+      final var srcBufferSegmentConfined = MemorySegment.ofAddress(srcAddress, size, scope).asByteBuffer();\n+      final var dstBufferSegmentConfined = MemorySegment.ofAddress(dstAddress, size, scope).asByteBuffer();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShort.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}