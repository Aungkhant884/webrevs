{"files":[{"patch":"@@ -31,0 +31,2 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n@@ -113,0 +115,1 @@\n+<<<<<<< HEAD\n@@ -114,0 +117,4 @@\n+=======\n+    \/\/ true, if this module allows restricted native access; @Stable makes sure that modules that allow native\n+    \/\/ access capture this property as a constant.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1583,5 +1583,0 @@\n-            @Override\n-            public void ensureCustomized(MethodHandle mh) {\n-                mh.customize();\n-            }\n-\n@@ -1595,2 +1590,2 @@\n-            public MethodHandle nativeMethodHandle(NativeEntryPoint nep, MethodHandle fallback) {\n-                return NativeMethodHandle.make(nep, fallback);\n+            public MethodHandle nativeMethodHandle(NativeEntryPoint nep) {\n+                return NativeMethodHandle.make(nep);\n@@ -1629,1 +1624,0 @@\n-\n@@ -2280,0 +2274,1 @@\n+<<<<<<< HEAD\n@@ -2290,0 +2285,12 @@\n+=======\n+            MH_cast                               = 0,\n+            MH_selectAlternative                  = 1,\n+            MH_countedLoopPred                    = 2,\n+            MH_countedLoopStep                    = 3,\n+            MH_initIterator                       = 4,\n+            MH_iteratePred                        = 5,\n+            MH_iterateNext                        = 6,\n+            MH_Array_newInstance                  = 7,\n+            MH_VarHandles_handleCheckedExceptions = 8,\n+            MH_LIMIT                              = 9;\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+<<<<<<< HEAD\n@@ -39,0 +40,2 @@\n+=======\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -47,0 +50,1 @@\n+<<<<<<< HEAD\n@@ -101,0 +105,20 @@\n+=======\n+ * <p>\n+ * On unsupported platforms this class will fail to initialize with an {@link ExceptionInInitializerError}.\n+ * <p>\n+ * Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\n+ * <h2><a id = \"downcall-method-handles\">Downcall method handles<\/a><\/h2>\n+ * <p>\n+ * {@linkplain #downcallHandle(FunctionDescriptor) Linking a foreign function} is a process which requires a function descriptor,\n+ * a set of memory layouts which, together, specify the signature of the foreign function to be linked, and returns,\n+ * when complete, a downcall method handle, that is, a method handle that can be used to invoke the target native function.\n+ * The Java {@link java.lang.invoke.MethodType method type} associated with the returned method handle is derived from the\n+ * argument and return layouts in the function descriptor. More specifically, given each layout {@code L} in the\n+ * function descriptor, a corresponding carrier {@code C} is inferred, as described below:\n+ * <ul>\n+ * <li>if {@code L} is a {@link ValueLayout} with carrier {@code E} then there are two cases:\n+ *     <ul>\n+ *         <li>if {@code L} occurs in a parameter position and {@code E} is {@code MemoryAddress.class},\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -106,0 +130,1 @@\n+<<<<<<< HEAD\n@@ -140,0 +165,50 @@\n+=======\n+ * <p>\n+ * Arguments of type {@link MemorySegment}, {@link VaList} and {@link NativeSymbol} passed by-reference to a downcall method handle\n+ * are {@linkplain ResourceScope#keepAlive(ResourceScope) kept alive} by the linker implementation. That is, the resource\n+ * scope associated with such arguments cannot be closed, either implicitly or {@linkplain ResourceScope#close() explicitly}\n+ * until the downcall method handle completes.\n+ * <p>\n+ * Furthermore, if the function descriptor's return layout is a group layout, the resulting downcall method handle accepts\n+ * an extra parameter of type {@link SegmentAllocator}, which is used by the linker runtime to allocate the\n+ * memory region associated with the struct returned by  the downcall method handle.\n+ * <p>\n+ * Finally, downcall method handles feature a leading parameter of type {@link NativeSymbol}, from which the\n+ * address of the target native function can be derived. The address, when known statically, can also be provided by\n+ * clients at link time. As for other by-reference parameters (see above) this leading parameter will be\n+ * {@linkplain ResourceScope#keepAlive(ResourceScope) kept alive} by the linker implementation.\n+ * <p>Variadic functions, declared in C either with a trailing ellipses ({@code ...}) at the end of the formal parameter\n+ * list or with an empty formal parameter list, are not supported directly. However, it is possible to link a native\n+ * variadic function by using a {@linkplain FunctionDescriptor#asVariadic(MemoryLayout...) <em>variadic<\/em>} function descriptor,\n+ * in which the specialized signature of a given variable arity callsite is described in full. Alternatively,\n+ * if the foreign library allows it, clients might also be able to interact with variable arity methods\n+ * using by passing a trailing parameter of type {@link VaList}.\n+ *\n+ * <h2><a id = \"upcall-stubs\">Upcall stubs<\/a><\/h2>\n+ *\n+ * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, ResourceScope) Creating an upcall stub} requires a method\n+ * handle and a function descriptor; in this case, the set of memory layouts in the function descriptor\n+ * specify the signature of the function pointer associated with the upcall stub.\n+ * <p>\n+ * The type of the provided method handle has to match the Java {@link java.lang.invoke.MethodType method type}\n+ * associated with the upcall stub, which is derived from the argument and return layouts in the function descriptor.\n+ * More specifically, given each layout {@code L} in the function descriptor, a corresponding carrier {@code C} is inferred, as described below:\n+ * <ul>\n+ * <li>if {@code L} is a {@link ValueLayout} with carrier {@code E} then there are two cases:\n+ *     <ul>\n+ *         <li>if {@code L} occurs in a return position and {@code E} is {@code MemoryAddress.class},\n+ *         then {@code C = Addressable.class};<\/li>\n+ *         <li>otherwise, {@code C = E};\n+ *     <\/ul><\/li>\n+ * <li>or, if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n+ * <\/ul>\n+ * Upcall stubs are modelled by instances of type {@link NativeSymbol}; upcall stubs can be passed by reference to other\n+ * downcall method handles (as {@link NativeSymbol} implements the {@link Addressable} interface) and,\n+ * when no longer required, they can be {@link ResourceScope#close() released}, via their {@linkplain NativeSymbol#scope() scope}.\n+ *\n+ * <h2>System lookup<\/h2>\n+ *\n+ * This class implements the {@link SymbolLookup} interface; as such clients can {@linkplain #lookup(String) lookup} symbols\n+ * in the standard libraries associated with this linker. The set of symbols available for lookup is unspecified,\n+ * as it depends on the platform and on the operating system.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -168,0 +243,1 @@\n+<<<<<<< HEAD\n@@ -169,0 +245,3 @@\n+=======\n+     * @return a linker-specific library lookup which is suitable to find symbols in the standard libraries associated with this linker.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -248,0 +327,1 @@\n+<<<<<<< HEAD\n@@ -270,0 +350,2 @@\n+=======\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+<<<<<<< HEAD\n@@ -52,0 +53,5 @@\n+=======\n+    private final MemoryLayout[] argLayouts;\n+\n+    private FunctionDescriptor(MemoryLayout resLayout, MemoryLayout... argLayouts) {\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -82,0 +88,1 @@\n+<<<<<<< HEAD\n@@ -83,0 +90,3 @@\n+=======\n+        return new FunctionDescriptor(resLayout, argLayouts);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -93,0 +103,1 @@\n+<<<<<<< HEAD\n@@ -94,0 +105,3 @@\n+=======\n+        return new FunctionDescriptor(null, argLayouts);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -126,1 +140,13 @@\n-    public FunctionDescriptor withAppendedArgumentLayouts(MemoryLayout... addedLayouts) {\n+    public FunctionDescriptor appendArgumentLayouts(MemoryLayout... addedLayouts) {\n+        return insertArgumentLayouts(argLayouts.length, addedLayouts);\n+    }\n+\n+    \/**\n+     * Create a new function descriptor with the given argument layouts inserted at the given index, into the argument\n+     * layout array of this function descriptor.\n+     * @param index the index at which to insert the arguments\n+     * @param addedLayouts the argument layouts to append.\n+     * @return the new function descriptor.\n+     * @throws IllegalArgumentException if {@code index < 0 || index > argumentLayouts().size()}.\n+     *\/\n+    public FunctionDescriptor insertArgumentLayouts(int index, MemoryLayout... addedLayouts) {\n@@ -129,0 +155,1 @@\n+<<<<<<< HEAD\n@@ -130,0 +157,7 @@\n+=======\n+        if (index < 0 || index > argLayouts.length)\n+            throw new IllegalArgumentException(\"Index out of bounds: \" + index);\n+        MemoryLayout[] newLayouts = Arrays.copyOf(argLayouts, argLayouts.length + addedLayouts.length);\n+        System.arraycopy(newLayouts, index, newLayouts, index + addedLayouts.length, argLayouts.length - index);\n+        System.arraycopy(addedLayouts, 0, newLayouts, index, addedLayouts.length);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -183,0 +217,1 @@\n+<<<<<<< HEAD\n@@ -184,0 +219,3 @@\n+=======\n+        return Objects.equals(resLayout, f.resLayout) && Arrays.equals(argLayouts, f.argLayouts);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -224,0 +262,1 @@\n+<<<<<<< HEAD\n@@ -229,0 +268,10 @@\n+=======\n+                    Stream.concat(descriptor.argumentLayouts().stream(), Stream.of(argLayouts)).toArray(MemoryLayout[]::new));\n+            this.firstVariadicIndex = descriptor.argumentLayouts().size();\n+        }\n+\n+        public boolean isVariadicIndex(int pos) {\n+            return pos >= firstVariadicIndex;\n+        }\n+\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -234,0 +283,1 @@\n+<<<<<<< HEAD\n@@ -235,0 +285,8 @@\n+=======\n+        public FunctionDescriptor appendArgumentLayouts(MemoryLayout... addedLayouts) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public FunctionDescriptor insertArgumentLayouts(int index, MemoryLayout... addedLayouts) {\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/FunctionDescriptor.java","additions":59,"deletions":1,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+<<<<<<< HEAD\n@@ -106,0 +107,3 @@\n+=======\n+     * @return a Java UTF-8 string containing all the bytes read from the given starting address ({@code toRowLongValue() + offset})\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -111,0 +115,1 @@\n+<<<<<<< HEAD\n@@ -193,0 +198,106 @@\n+=======\n+     *\/\n+    @CallerSensitive\n+    String getUtf8String(long offset);\n+\n+    \/**\n+     * Writes a UTF-8 encoded, null-terminated string to this address at given offset.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string.  The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param str the Java string to be written at this address.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+<<<<<<< HEAD\n+    void set(ValueLayout.OfByte layout, long offset, byte value);\n+\n+    \/**\n+     * Reads a boolean from this address and offset with given layout.\n+=======\n+    void setUtf8String(long offset, String str);\n+\n+    \/**\n+     * Compares the specified object with this address for equality. Returns {@code true} if and only if the specified\n+     * object is also an address, and it refers to the same memory location as this address.\n+     *\n+     * @param that the object to be compared for equality with this address.\n+     * @return {@code true} if the specified object is equal to this address.\n+     *\/\n+    @Override\n+    boolean equals(Object that);\n+\n+    \/**\n+     * Returns the hash code value for this address.\n+     * @return the hash code value for this address.\n+     *\/\n+    @Override\n+    int hashCode();\n+\n+    \/**\n+     * The native memory address instance modelling the {@code NULL} address.\n+     *\/\n+    MemoryAddress NULL = new MemoryAddressImpl(0L);\n+\n+    \/**\n+     * Obtain a native memory address instance from given long address.\n+     * @param value the long address.\n+     * @return the new memory address instance.\n+     *\/\n+    static MemoryAddress ofLong(long value) {\n+        return value == 0 ?\n+                NULL :\n+                new MemoryAddressImpl(value);\n+    }\n+\n+    \/**\n+     * Reads a byte from this address and offset with given layout.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+<<<<<<< HEAD\n+     * @return a boolean value read from this address.\n+=======\n+     * @return a byte value read from this address.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+<<<<<<< HEAD\n+    boolean get(ValueLayout.OfBoolean layout, long offset);\n+\n+    \/**\n+     * Writes a boolean to this address instance and offset with given layout.\n+=======\n+    byte get(ValueLayout.OfByte layout, long offset);\n+\n+    \/**\n+     * Writes a byte to this address instance and offset with given layout.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+<<<<<<< HEAD\n+     * @param value the boolean value to be written.\n+=======\n+     * @param value the byte value to be written.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -198,0 +309,6 @@\n+<<<<<<< HEAD\n+    void set(ValueLayout.OfBoolean layout, long offset, boolean value);\n+\n+    \/**\n+     * Reads a char from this address and offset with given layout.\n+=======\n@@ -202,0 +319,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -210,0 +328,3 @@\n+<<<<<<< HEAD\n+     * @return a char value read from this address.\n+=======\n@@ -211,0 +332,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -216,0 +338,6 @@\n+<<<<<<< HEAD\n+    char get(ValueLayout.OfChar layout, long offset);\n+\n+    \/**\n+     * Writes a char to this address instance and offset with given layout.\n+=======\n@@ -220,0 +348,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -228,0 +357,3 @@\n+<<<<<<< HEAD\n+     * @param value the char value to be written.\n+=======\n@@ -229,0 +361,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -234,0 +367,6 @@\n+<<<<<<< HEAD\n+    void set(ValueLayout.OfChar layout, long offset, char value);\n+\n+    \/**\n+     * Reads a short from this address and offset with given layout.\n+=======\n@@ -238,0 +377,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -246,0 +386,3 @@\n+<<<<<<< HEAD\n+     * @return a short value read from this address.\n+=======\n@@ -247,0 +390,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -252,0 +396,6 @@\n+<<<<<<< HEAD\n+    short get(ValueLayout.OfShort layout, long offset);\n+\n+    \/**\n+     * Writes a short to this address instance and offset with given layout.\n+=======\n@@ -256,0 +406,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -264,0 +415,3 @@\n+<<<<<<< HEAD\n+     * @param value the short value to be written.\n+=======\n@@ -265,0 +419,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -270,0 +425,6 @@\n+<<<<<<< HEAD\n+    void set(ValueLayout.OfShort layout, long offset, short value);\n+\n+    \/**\n+     * Reads an int from this address and offset with given layout.\n+=======\n@@ -274,0 +435,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -282,0 +444,3 @@\n+<<<<<<< HEAD\n+     * @return an int value read from this address.\n+=======\n@@ -283,0 +448,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -288,0 +454,6 @@\n+<<<<<<< HEAD\n+    int get(ValueLayout.OfInt layout, long offset);\n+\n+    \/**\n+     * Writes an int to this address instance and offset with given layout.\n+=======\n@@ -292,0 +464,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -300,0 +473,3 @@\n+<<<<<<< HEAD\n+     * @param value the int value to be written.\n+=======\n@@ -301,0 +477,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -306,0 +483,6 @@\n+<<<<<<< HEAD\n+    void set(ValueLayout.OfInt layout, long offset, int value);\n+\n+    \/**\n+     * Reads a float from this address and offset with given layout.\n+=======\n@@ -310,0 +493,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -318,0 +502,3 @@\n+<<<<<<< HEAD\n+     * @return a float value read from this address.\n+=======\n@@ -319,0 +506,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -324,0 +512,6 @@\n+<<<<<<< HEAD\n+    float get(ValueLayout.OfFloat layout, long offset);\n+\n+    \/**\n+     * Writes a float to this address instance and offset with given layout.\n+=======\n@@ -328,0 +522,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -336,0 +531,3 @@\n+<<<<<<< HEAD\n+     * @param value the float value to be written.\n+=======\n@@ -337,0 +535,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -342,0 +541,6 @@\n+<<<<<<< HEAD\n+    void set(ValueLayout.OfFloat layout, long offset, float value);\n+\n+    \/**\n+     * Reads a long from this address and offset with given layout.\n+=======\n@@ -346,0 +551,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -354,0 +560,3 @@\n+<<<<<<< HEAD\n+     * @return a long value read from this address.\n+=======\n@@ -355,0 +564,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -360,0 +570,6 @@\n+<<<<<<< HEAD\n+    long get(ValueLayout.OfLong layout, long offset);\n+\n+    \/**\n+     * Writes a long to this address instance and offset with given layout.\n+=======\n@@ -364,0 +580,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -372,0 +589,3 @@\n+<<<<<<< HEAD\n+     * @param value the long value to be written.\n+=======\n@@ -373,0 +593,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -378,0 +599,6 @@\n+<<<<<<< HEAD\n+    void set(ValueLayout.OfLong layout, long offset, long value);\n+\n+    \/**\n+     * Reads a double from this address and offset with given layout.\n+=======\n@@ -382,0 +609,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -390,0 +618,3 @@\n+<<<<<<< HEAD\n+     * @return a double value read from this address.\n+=======\n@@ -391,0 +622,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -396,0 +628,2 @@\n+<<<<<<< HEAD\n+=======\n@@ -432,0 +666,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":235,"deletions":0,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+<<<<<<< HEAD\n@@ -106,0 +107,3 @@\n+=======\n+ * {@link MemoryAddress#ofLong(long)} and {@link MemorySegment#ofAddressNative(MemoryAddress, long, ResourceScope)}.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -110,0 +114,1 @@\n+<<<<<<< HEAD\n@@ -111,0 +116,3 @@\n+=======\n+ * full spatial, temporal and confinement bounds. To do this, clients can {@link #ofAddressNative(MemoryAddress, long, ResourceScope) obtain}\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -327,0 +335,1 @@\n+<<<<<<< HEAD\n@@ -329,0 +338,4 @@\n+=======\n+     * <p>Two segments S1 and S2 are said to overlap if it is possible to find\n+     * at least two slices L1 (from S1) and L2 (from S2) that are backed by the\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -387,1 +400,1 @@\n-     * Performs a bulk copy from given source segment to this segment. More specifically, the bytes at\n+     * Performs an element-wise bulk copy from given source segment to this segment. More specifically, the bytes at\n@@ -397,0 +410,4 @@\n+     * @throws IllegalArgumentException if the element layouts have different sizes, if the source segment size is not\n+     * a multiple of the source element layout size, if the source segment is incompatible with the alignment constraints\n+     * in the source element layout, or if this segment is incompatible with the alignment constraints\n+     * in the destination element layout.\n@@ -629,0 +646,1 @@\n+<<<<<<< HEAD\n@@ -632,0 +650,5 @@\n+=======\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a Java UTF-8 string containing all the bytes read from the given starting address up to (but not including)\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -642,0 +665,1 @@\n+<<<<<<< HEAD\n@@ -643,0 +667,3 @@\n+=======\n+     * Writes a UTF-8 encoded, null-terminated string into this segment at given offset.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -648,0 +675,1 @@\n+<<<<<<< HEAD\n@@ -649,0 +677,3 @@\n+=======\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -758,0 +789,1 @@\n+<<<<<<< HEAD\n@@ -759,0 +791,3 @@\n+=======\n+     * Creates a new native memory segment with given size and resource scope, and whose base address is this address.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -765,0 +800,1 @@\n+<<<<<<< HEAD\n@@ -766,0 +802,3 @@\n+=======\n+     * Clients should ensure that the address and bounds refers to a valid region of memory that is accessible for reading and,\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -787,0 +826,1 @@\n+<<<<<<< HEAD\n@@ -788,0 +828,3 @@\n+=======\n+    static MemorySegment ofAddressNative(MemoryAddress address, long bytesSize, ResourceScope scope) {\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1031,0 +1074,1 @@\n+<<<<<<< HEAD\n@@ -1032,0 +1076,3 @@\n+=======\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1048,0 +1095,1 @@\n+<<<<<<< HEAD\n@@ -1049,0 +1097,3 @@\n+=======\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1064,0 +1115,1 @@\n+<<<<<<< HEAD\n@@ -1065,0 +1117,3 @@\n+=======\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1081,0 +1136,1 @@\n+<<<<<<< HEAD\n@@ -1084,0 +1140,5 @@\n+=======\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the byte value to be written.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1097,0 +1158,1 @@\n+<<<<<<< HEAD\n@@ -1098,0 +1160,3 @@\n+=======\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1114,0 +1179,1 @@\n+<<<<<<< HEAD\n@@ -1117,0 +1183,5 @@\n+=======\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the byte value to be written.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1130,0 +1201,1 @@\n+<<<<<<< HEAD\n@@ -1131,0 +1203,3 @@\n+=======\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1147,0 +1222,1 @@\n+<<<<<<< HEAD\n@@ -1150,0 +1226,5 @@\n+=======\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the byte value to be written.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1163,0 +1244,1 @@\n+<<<<<<< HEAD\n@@ -1164,0 +1246,3 @@\n+=======\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1180,0 +1265,1 @@\n+<<<<<<< HEAD\n@@ -1183,0 +1269,5 @@\n+=======\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the byte value to be written.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1196,0 +1287,1 @@\n+<<<<<<< HEAD\n@@ -1197,0 +1289,3 @@\n+=======\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1213,0 +1308,1 @@\n+<<<<<<< HEAD\n@@ -1216,0 +1312,5 @@\n+=======\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the byte value to be written.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1229,0 +1330,1 @@\n+<<<<<<< HEAD\n@@ -1230,0 +1332,3 @@\n+=======\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1246,0 +1351,1 @@\n+<<<<<<< HEAD\n@@ -1249,0 +1355,5 @@\n+=======\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the byte value to be written.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1262,0 +1373,1 @@\n+<<<<<<< HEAD\n@@ -1263,0 +1375,3 @@\n+=======\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1279,0 +1394,1 @@\n+<<<<<<< HEAD\n@@ -1282,0 +1398,5 @@\n+=======\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the byte value to be written.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1295,0 +1416,1 @@\n+<<<<<<< HEAD\n@@ -1296,0 +1418,3 @@\n+=======\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1312,0 +1437,1 @@\n+<<<<<<< HEAD\n@@ -1315,0 +1441,5 @@\n+=======\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the byte value to be written.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1328,0 +1459,1 @@\n+<<<<<<< HEAD\n@@ -1329,0 +1461,3 @@\n+=======\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1345,0 +1480,1 @@\n+<<<<<<< HEAD\n@@ -1348,0 +1484,5 @@\n+=======\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the byte value to be written.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1361,0 +1502,1 @@\n+<<<<<<< HEAD\n@@ -1362,0 +1504,3 @@\n+=======\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1378,0 +1523,1 @@\n+<<<<<<< HEAD\n@@ -1381,0 +1527,5 @@\n+=======\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the byte value to be written.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1394,0 +1545,1 @@\n+<<<<<<< HEAD\n@@ -1395,0 +1547,3 @@\n+=======\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1411,0 +1566,1 @@\n+<<<<<<< HEAD\n@@ -1414,0 +1570,5 @@\n+=======\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the byte value to be written.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1427,0 +1588,1 @@\n+<<<<<<< HEAD\n@@ -1428,0 +1590,3 @@\n+=======\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1444,0 +1609,1 @@\n+<<<<<<< HEAD\n@@ -1447,0 +1613,5 @@\n+=======\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the byte value to be written.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1460,0 +1631,1 @@\n+<<<<<<< HEAD\n@@ -1461,0 +1633,3 @@\n+=======\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1477,0 +1652,1 @@\n+<<<<<<< HEAD\n@@ -1480,0 +1656,5 @@\n+=======\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the byte value to be written.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1493,0 +1674,1 @@\n+<<<<<<< HEAD\n@@ -1494,0 +1676,3 @@\n+=======\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1510,0 +1695,1 @@\n+<<<<<<< HEAD\n@@ -1513,0 +1699,5 @@\n+=======\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the byte value to be written.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1526,0 +1717,1 @@\n+<<<<<<< HEAD\n@@ -1527,0 +1719,3 @@\n+=======\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1543,0 +1738,1 @@\n+<<<<<<< HEAD\n@@ -1546,0 +1742,5 @@\n+=======\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the byte value to be written.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1559,0 +1760,1 @@\n+<<<<<<< HEAD\n@@ -1560,0 +1762,3 @@\n+=======\n+     * Supported array types are {@code byte[]}, {@code char[]},{@code short[]},{@code int[]},{@code float[]},{@code long[]} and {@code double[]}.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -1600,0 +1805,1 @@\n+<<<<<<< HEAD\n@@ -1601,0 +1807,3 @@\n+=======\n+     * Supported array types are {@code byte[]}, {@code char[]},{@code short[]},{@code int[]},{@code float[]},{@code long[]} and {@code double[]}.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":210,"deletions":1,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -208,0 +208,1 @@\n+<<<<<<< HEAD\n@@ -209,0 +210,3 @@\n+=======\n+        return ResourceScopeImpl.createConfined( Thread.currentThread(), null);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ResourceScope.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+<<<<<<< HEAD\n@@ -79,0 +80,2 @@\n+=======\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -391,0 +394,1 @@\n+<<<<<<< HEAD\n@@ -394,0 +398,9 @@\n+=======\n+     * An allocator associated with a <em>shared<\/em> resource scope is thread-safe and allocation requests may be\n+     * performed concurrently; conversely, if the arena allocator is associated with a <em>confined<\/em> resource scope,\n+     * allocation requests can only occur from the thread owning the allocator's resource scope.\n+     * <p>\n+     * The returned allocator might throw an {@link OutOfMemoryError} if the total memory allocated with this allocator\n+     * exceeds the arena size, or the system capacity. Furthermore, the returned allocator is not thread safe, and all\n+     * allocation requests should occur within a single thread (regardless of the scope associated with the native arena).\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+<<<<<<< HEAD\n@@ -84,0 +85,3 @@\n+=======\n+            return addr == MemoryAddress.NULL? Optional.empty() : Optional.of(NativeSymbol.ofAddress(name, addr, ResourceScope.globalScope()));\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SymbolLookup.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+<<<<<<< HEAD\n@@ -133,0 +134,3 @@\n+=======\n+     * with the same scope as this variable argument list. using the segment provided allocator. Copying is useful to\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -144,0 +148,4 @@\n+<<<<<<< HEAD\n+=======\n+     * @throws UnsupportedOperationException if this variable argument list has been allocated using heap segments.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/VaList.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+<<<<<<< HEAD\n@@ -73,0 +74,2 @@\n+=======\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -174,0 +177,1 @@\n+<<<<<<< HEAD\n@@ -182,0 +186,9 @@\n+=======\n+        if (carrier == void.class) return;\n+        if (carrier == MemoryAddress.class && size != (Unsafe.ADDRESS_SIZE * 8)) {\n+            throw new IllegalArgumentException(\"Address size mismatch: \" + (Unsafe.ADDRESS_SIZE * 8) + \" != \" + size);\n+        }\n+        if (carrier.isPrimitive() && Wrapper.forPrimitiveType(carrier).bitWidth() != size &&\n+                carrier != boolean.class && size != 8) {\n+            throw new IllegalArgumentException(\"Carrier size mismatch: \" + carrier.getName() + \" != \" + size);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -186,0 +199,1 @@\n+<<<<<<< HEAD\n@@ -187,0 +201,4 @@\n+=======\n+        return carrier == void.class\n+                || carrier == boolean.class\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -203,0 +221,1 @@\n+<<<<<<< HEAD\n@@ -205,0 +224,3 @@\n+=======\n+            handle = Utils.makeMemoryAccessVarHandle(carrier, false, byteAlignment() - 1, order());\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -275,0 +297,107 @@\n+<<<<<<< HEAD\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code char.class}.\n+     *\/\n+    public static final class OfChar extends ValueLayout {\n+        OfChar(ByteOrder order) {\n+            super(char.class, order, 16);\n+        }\n+\n+        OfChar(ByteOrder order, long alignment, Optional<String> name) {\n+            super(char.class, order, 16, alignment, name);\n+        }\n+\n+        @Override\n+        OfChar dup(long alignment, Optional<String> name) {\n+            return new OfChar(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfChar withName(String name) {\n+            return (OfChar)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfChar withBitAlignment(long alignmentBits) {\n+            return (OfChar)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfChar withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfChar(order, alignment, name());\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code short.class}.\n+     *\/\n+    public static final class OfShort extends ValueLayout {\n+        OfShort(ByteOrder order) {\n+            super(short.class, order, 16);\n+        }\n+\n+        OfShort(ByteOrder order, long alignment, Optional<String> name) {\n+            super(short.class, order, 16, alignment, name);\n+        }\n+\n+        @Override\n+        OfShort dup(long alignment, Optional<String> name) {\n+            return new OfShort(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfShort withName(String name) {\n+            return (OfShort)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfShort withBitAlignment(long alignmentBits) {\n+            return (OfShort)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfShort withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfShort(order, alignment, name());\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code int.class}.\n+     *\/\n+    public static final class OfInt extends ValueLayout {\n+        OfInt(ByteOrder order) {\n+            super(int.class, order, 32);\n+        }\n+\n+        OfInt(ByteOrder order, long alignment, Optional<String> name) {\n+            super(int.class, order, 32, alignment, name);\n+        }\n+\n+        @Override\n+        OfInt dup(long alignment, Optional<String> name) {\n+            return new OfInt(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfInt withName(String name) {\n+            return (OfInt)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfInt withBitAlignment(long alignmentBits) {\n+            return (OfInt)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfInt withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfInt(order, alignment, name());\n+        }\n+    }\n+\n+    \/**\n+=======\n@@ -380,0 +509,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -486,0 +616,1 @@\n+<<<<<<< HEAD\n@@ -487,0 +618,3 @@\n+=======\n+            super(MemoryAddress.class, order, Unsafe.ADDRESS_SIZE * 8);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ValueLayout.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+<<<<<<< HEAD\n@@ -50,0 +51,3 @@\n+=======\n+   segment.setAtIndex(ValueLayout.JAVA_INT, i, 42);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -55,0 +59,1 @@\n+<<<<<<< HEAD\n@@ -59,0 +64,7 @@\n+=======\n+ * Inside a loop, we then initialize the contents of the memory segment using the\n+ * {@link jdk.incubator.foreign.MemorySegment#setAtIndex(ValueLayout.OfInt, long, int)} dereference method. Note how\n+ * the dereference method accepts a {@linkplain jdk.incubator.foreign.ValueLayout value layout},\n+ * which specifies the size, alignment constraints, byte order as well\n+ * as the Java type ({@code int}, in this case) associated with the dereference operation. More specifically,\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -76,0 +88,1 @@\n+<<<<<<< HEAD\n@@ -77,0 +90,3 @@\n+=======\n+        segment.setAtIndex(ValueLayout.JAVA_INT, i, 42);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -134,0 +150,1 @@\n+<<<<<<< HEAD\n@@ -137,0 +154,5 @@\n+=======\n+ * interacting with native code, such as converting Java strings into native strings and back\n+ * (see {@link jdk.incubator.foreign.MemorySegment#setUtf8String(long, java.lang.String)} and\n+ * {@link jdk.incubator.foreign.MemorySegment#getUtf8String(long)}, respectively), as demonstrated in the above example.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -147,0 +169,1 @@\n+<<<<<<< HEAD\n@@ -150,0 +173,4 @@\n+=======\n+ * using one of the many <em>unsafe<\/em> dereference methods provided\n+ * (see {@link jdk.incubator.foreign.MemoryAddress#get(jdk.incubator.foreign.ValueLayout.OfInt, long)}):\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -157,0 +184,1 @@\n+<<<<<<< HEAD\n@@ -162,0 +190,6 @@\n+=======\n+ * Alternatively, the client can create a memory segment <em>unsafely<\/em>, using the\n+ * {@link jdk.incubator.foreign.MemorySegment#ofAddressNative(jdk.incubator.foreign.MemoryAddress, long, jdk.incubator.foreign.ResourceScope)} factory.\n+ * This allows the client to inject extra knowledge about spatial bounds which might, for instance, be available in the documentation of the foreign function\n+ * which produced the native address. Here is how an unsafe segment can be created from a native address:\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -166,0 +200,1 @@\n+<<<<<<< HEAD\n@@ -167,0 +202,3 @@\n+=======\n+MemorySegment segment = MemorySegment.ofAddressNative(addr, 4, scope); \/\/ segment is 4 bytes long\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -205,0 +243,1 @@\n+<<<<<<< HEAD\n@@ -216,0 +255,15 @@\n+=======\n+     intCompareHandle,\n+     FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.ADDRESS, ValueLayout.ADDRESS),\n+     scope\n+);\n+ * }<\/pre>\n+ *\n+ * As before, we need to provide a {@link jdk.incubator.foreign.FunctionDescriptor} instance describing the signature\n+ * of the function pointer we want to create; this descriptor allows the linker to determine the\n+ * sequence of steps which allow foreign code to call the stub for {@code intCompareHandle} according to the rules specified\n+ * by the platform C ABI. The lifecycle of the stub returned by\n+ * {@link jdk.incubator.foreign.CLinker#upcallStub(java.lang.invoke.MethodHandle, jdk.incubator.foreign.FunctionDescriptor, jdk.incubator.foreign.ResourceScope)}\n+ * is tied to the {@linkplain jdk.incubator.foreign.ResourceScope resource scope} parameter passed to that method. This\n+ * is made available by the {@link jdk.incubator.foreign.NativeSymbol} instance returned by that method.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -221,0 +275,1 @@\n+<<<<<<< HEAD\n@@ -226,0 +281,7 @@\n+=======\n+ * the restricted method {@link jdk.incubator.foreign.MemorySegment#ofAddressNative(jdk.incubator.foreign.MemoryAddress, long, jdk.incubator.foreign.ResourceScope)}\n+ * can be used to create a fresh segment with given spatial bounds out of a native address.\n+ * <p>\n+ * Binding foreign data and\/or functions is generally unsafe and, if done incorrectly, can result in VM crashes, or memory corruption when the bound Java API element is accessed.\n+ * For instance, in the case of {@link jdk.incubator.foreign.MemorySegment#ofAddressNative(jdk.incubator.foreign.MemoryAddress, long, jdk.incubator.foreign.ResourceScope)},\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+<<<<<<< HEAD\n@@ -43,0 +44,9 @@\n+=======\n+    MemorySegment segment;\n+\n+    long sp = 0L;\n+    long size = 0;\n+    final long blockSize;\n+    final long arenaSize;\n+    final ResourceScope scope;\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -67,0 +77,1 @@\n+<<<<<<< HEAD\n@@ -74,0 +85,4 @@\n+=======\n+    private MemorySegment newSegment(long size, long align) {\n+        return MemorySegment.allocateNative(size, align, scope);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -78,0 +93,1 @@\n+<<<<<<< HEAD\n@@ -93,0 +109,33 @@\n+=======\n+        long prevSp = sp;\n+        long allocatedSize = 0L;\n+        try {\n+            \/\/ try to slice from current segment first...\n+            MemorySegment slice = trySlice(bytesSize, bytesAlignment);\n+            if (slice != null) {\n+                allocatedSize = sp - prevSp;\n+                return slice;\n+            } else {\n+                long maxPossibleAllocationSize = bytesSize + bytesAlignment - 1;\n+                if (maxPossibleAllocationSize > blockSize) {\n+                    \/\/ too big\n+                    allocatedSize = Utils.alignUp(bytesSize, bytesAlignment);\n+                    if (size > arenaSize) {\n+                        throw new OutOfMemoryError();\n+                    }\n+                    return newSegment(bytesSize, bytesAlignment);\n+                } else {\n+                    \/\/ allocate a new segment and slice from there\n+                    allocatedSize += segment.byteSize() - sp;\n+                    sp = 0L;\n+                    segment = newSegment(blockSize, 1L);\n+                    slice = trySlice(bytesSize, bytesAlignment);\n+                    allocatedSize += sp;\n+                    return slice;\n+                }\n+            }\n+        } finally {\n+            size += allocatedSize;\n+            if (size > arenaSize) {\n+                throw new OutOfMemoryError();\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ArenaAllocator.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+<<<<<<< HEAD\n@@ -98,0 +99,6 @@\n+=======\n+            int value;\n+            do {\n+                value = (int)ASYNC_RELEASE_COUNT.getVolatile(this);\n+            } while (!ASYNC_RELEASE_COUNT.compareAndSet(this, value, value + 1));\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ConfinedScope.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -156,0 +156,1 @@\n+<<<<<<< HEAD\n@@ -157,0 +158,3 @@\n+=======\n+        if (!(layout instanceof ValueLayout)) {\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -161,0 +165,2 @@\n+        Class<?> carrier = ((ValueLayout)layout).carrier();\n+\n@@ -166,0 +172,1 @@\n+<<<<<<< HEAD\n@@ -167,0 +174,4 @@\n+=======\n+        VarHandle handle = Utils.makeMemoryAccessVarHandle(carrier, true, layout.byteAlignment() - 1,\n+                ((ValueLayout)layout).order());\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -110,0 +110,1 @@\n+<<<<<<< HEAD\n@@ -113,0 +114,5 @@\n+=======\n+\n+    public abstract void release0();\n+\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -117,0 +123,1 @@\n+<<<<<<< HEAD\n@@ -118,0 +125,2 @@\n+=======\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -191,0 +200,1 @@\n+<<<<<<< HEAD\n@@ -197,0 +207,5 @@\n+=======\n+\n+        public GlobalScopeImpl() {\n+            super(null);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -222,0 +237,1 @@\n+<<<<<<< HEAD\n@@ -227,0 +243,3 @@\n+=======\n+    public static final ResourceScopeImpl GLOBAL = new GlobalScopeImpl();\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ResourceScopeImpl.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+<<<<<<< HEAD\n@@ -102,0 +103,3 @@\n+=======\n+            value = (int) STATE.getVolatile(jdk.internal.foreign.SharedScope.this);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -106,0 +110,1 @@\n+<<<<<<< HEAD\n@@ -107,0 +112,3 @@\n+=======\n+        } while (!STATE.compareAndSet(jdk.internal.foreign.SharedScope.this, value, value - 1));\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SharedScope.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+<<<<<<< HEAD\n@@ -75,0 +76,3 @@\n+=======\n+            MemorySegment funcs = MemorySegment.ofAddressNative(fallbackLibLookup.lookup(\"funcs\").orElseThrow().address(),\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+<<<<<<< HEAD\n@@ -40,0 +41,3 @@\n+=======\n+import java.nio.ByteOrder;\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -108,0 +112,1 @@\n+<<<<<<< HEAD\n@@ -120,0 +125,5 @@\n+=======\n+    public static VarHandle makeMemoryAccessVarHandle(Class<?> carrier, boolean skipAlignmentCheck, long alignmentMask, ByteOrder order) {\n+        Class<?> baseCarrier = carrier;\n+        if (carrier == MemoryAddress.class) {\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -125,0 +135,1 @@\n+<<<<<<< HEAD\n@@ -131,0 +142,7 @@\n+=======\n+        } else if (carrier == boolean.class) {\n+            baseCarrier = byte.class;\n+        }\n+\n+        VarHandle handle = SharedSecrets.getJavaLangInvokeAccess().memoryAccessVarHandle(baseCarrier, skipAlignmentCheck, alignmentMask, order);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -137,0 +155,1 @@\n+<<<<<<< HEAD\n@@ -145,0 +164,11 @@\n+=======\n+        if (carrier == boolean.class) {\n+            return MemoryHandles.filterValue(handle, BOOL_TO_BYTE, BYTE_TO_BOOL);\n+        } else if (carrier == MemoryAddress.class) {\n+            return MemoryHandles.filterValue(handle,\n+                    MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(baseCarrier, MemoryAddress.class)),\n+                    MethodHandles.explicitCastArguments(LONG_TO_ADDRESS, MethodType.methodType(MemoryAddress.class, baseCarrier)));\n+        } else {\n+            return handle;\n+        }\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+<<<<<<< HEAD\n@@ -31,0 +32,6 @@\n+=======\n+import jdk.incubator.foreign.MemoryHandles;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeSymbol;\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -43,0 +50,4 @@\n+<<<<<<< HEAD\n+=======\n+import java.nio.ByteOrder;\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -46,1 +57,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n@@ -51,1 +61,1 @@\n-import static java.lang.invoke.MethodHandles.filterArguments;\n+import static java.lang.invoke.MethodHandles.foldArguments;\n@@ -55,1 +65,0 @@\n-import static sun.security.action.GetBooleanAction.privilegedGetProperty;\n@@ -63,2 +72,0 @@\n-    private static final boolean DEBUG =\n-        privilegedGetProperty(\"jdk.internal.foreign.ProgrammableInvoker.DEBUG\");\n@@ -67,2 +74,0 @@\n-    private static final boolean USE_INTRINSICS = Boolean.parseBoolean(\n-        GetPropertyAction.privilegedGetProperty(\"jdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS\", \"true\"));\n@@ -72,0 +77,1 @@\n+<<<<<<< HEAD\n@@ -75,0 +81,2 @@\n+=======\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -76,1 +84,0 @@\n-    private static final MethodHandle MH_ADDR_TO_LONG;\n@@ -78,2 +85,2 @@\n-\n-    private static final Map<ABIDescriptor, Long> adapterStubs = new ConcurrentHashMap<>();\n+    private static final MethodHandle MH_ALLOCATE_RETURN_BUFFER;\n+    private static final MethodHandle MH_CHECK_SYMBOL;\n@@ -86,2 +93,0 @@\n-            MH_INVOKE_MOVES = lookup.findVirtual(ProgrammableInvoker.class, \"invokeMoves\",\n-                    methodType(Object.class, long.class, Object[].class, Binding.VMStore[].class, Binding.VMLoad[].class));\n@@ -89,0 +94,1 @@\n+<<<<<<< HEAD\n@@ -93,0 +99,9 @@\n+=======\n+                    methodType(Object.class, SegmentAllocator.class, Object[].class, InvocationData.class));\n+            MH_WRAP_ALLOCATOR = lookup.findStatic(Binding.Context.class, \"ofAllocator\",\n+                    methodType(Binding.Context.class, SegmentAllocator.class));\n+            MH_ALLOCATE_RETURN_BUFFER = lookup.findStatic(ProgrammableInvoker.class, \"allocateReturnBuffer\",\n+                    methodType(MemorySegment.class, Binding.Context.class, long.class));\n+            MH_CHECK_SYMBOL = lookup.findStatic(SharedUtils.class, \"checkSymbol\",\n+                    methodType(void.class, NativeSymbol.class));\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -99,3 +114,0 @@\n-    private final BufferLayout layout;\n-    private final long stackArgsBytes;\n-\n@@ -104,4 +116,0 @@\n-    private final long stubAddress;\n-\n-    private final long bufferCopySize;\n-\n@@ -110,3 +118,0 @@\n-        this.layout = BufferLayout.of(abi);\n-        this.stubAddress = adapterStubs.computeIfAbsent(abi, key -> generateAdapter(key, layout));\n-\n@@ -114,8 +119,0 @@\n-\n-        this.stackArgsBytes = argMoveBindingsStream(callingSequence)\n-                .map(Binding.VMStore::storage)\n-                .filter(s -> abi.arch.isStackType(s.type()))\n-                .count()\n-                * abi.arch.typeSize(abi.arch.stackType());\n-\n-        this.bufferCopySize = SharedUtils.bufferCopySize(callingSequence);\n@@ -129,5 +126,1 @@\n-        Class<?> returnType = retMoves.length == 0\n-                ? void.class\n-                : retMoves.length == 1\n-                    ? retMoves[0].type()\n-                    : Object[].class;\n+        Class<?> returnType = retMoves.length == 1 ? retMoves[0].type() : void.class;\n@@ -136,22 +129,0 @@\n-        MethodType leafTypeWithAddress = leafType.insertParameterTypes(0, long.class);\n-\n-        MethodHandle handle = insertArguments(MH_INVOKE_MOVES.bindTo(this), 2, argMoves, retMoves);\n-        MethodHandle collector = makeCollectorHandle(leafType);\n-        handle = collectArguments(handle, 1, collector);\n-        handle = handle.asType(leafTypeWithAddress);\n-\n-        boolean isSimple = !(retMoves.length > 1);\n-        boolean usesStackArgs = stackArgsBytes != 0;\n-        if (USE_INTRINSICS && isSimple && !usesStackArgs) {\n-            NativeEntryPoint nep = NativeEntryPoint.make(\n-                \"native_call\",\n-                abi,\n-                toStorageArray(argMoves),\n-                toStorageArray(retMoves),\n-                !callingSequence.isTrivial(),\n-                leafTypeWithAddress\n-            );\n-\n-            handle = JLIA.nativeMethodHandle(nep, handle);\n-        }\n-        handle = filterArguments(handle, 0, MH_ADDR_TO_LONG);\n@@ -159,1 +130,12 @@\n-        if (USE_SPEC && isSimple) {\n+        NativeEntryPoint nep = NativeEntryPoint.make(\n+            \"native_invoker_\" + leafType.descriptorString(),\n+            abi,\n+            toStorageArray(argMoves),\n+            toStorageArray(retMoves),\n+            !callingSequence.isTrivial(),\n+            leafType,\n+            callingSequence.needsReturnBuffer()\n+        );\n+        MethodHandle handle = JLIA.nativeMethodHandle(nep);\n+\n+        if (USE_SPEC) {\n@@ -165,4 +147,11 @@\n-            handle = insertArguments(MH_INVOKE_INTERP_BINDINGS.bindTo(this), 3, handle, argIndexMap, retIndexMap);\n-            MethodHandle collectorInterp = makeCollectorHandle(callingSequence.methodType());\n-            handle = collectArguments(handle, 2, collectorInterp);\n-            handle = handle.asType(handle.type().changeReturnType(callingSequence.methodType().returnType()));\n+            InvocationData invData = new InvocationData(handle, argIndexMap, retIndexMap);\n+            handle = insertArguments(MH_INVOKE_INTERP_BINDINGS.bindTo(this), 2, invData);\n+            MethodType interpType = callingSequence.methodType();\n+            if (callingSequence.needsReturnBuffer()) {\n+                \/\/ Return buffer is supplied by invokeInterpBindings\n+                assert interpType.parameterType(0) == MemorySegment.class;\n+                interpType.dropParameterTypes(0, 1);\n+            }\n+            MethodHandle collectorInterp = makeCollectorHandle(interpType);\n+            handle = collectArguments(handle, 1, collectorInterp);\n+            handle = handle.asType(handle.type().changeReturnType(interpType.returnType()));\n@@ -171,0 +160,6 @@\n+        assert handle.type().parameterType(0) == SegmentAllocator.class;\n+        assert handle.type().parameterType(1) == NativeSymbol.class;\n+        handle = foldArguments(handle, 1, MH_CHECK_SYMBOL);\n+\n+        handle = SharedUtils.swapArguments(handle, 0, 1); \/\/ normalize parameter order\n+\n@@ -174,0 +169,1 @@\n+<<<<<<< HEAD\n@@ -177,0 +173,4 @@\n+=======\n+    private static MemorySegment allocateReturnBuffer(Binding.Context context, long size) {\n+        return context.allocator().allocate(size);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -195,0 +195,4 @@\n+        return retMoveBindingsStream(callingSequence).toArray(Binding.VMLoad[]::new);\n+    }\n+\n+    private Stream<Binding.VMLoad> retMoveBindingsStream(CallingSequence callingSequence) {\n@@ -197,2 +201,1 @@\n-                .map(Binding.VMLoad.class::cast)\n-                .toArray(Binding.VMLoad[]::new);\n+                .map(Binding.VMLoad.class::cast);\n@@ -201,1 +204,0 @@\n-\n@@ -209,2 +211,2 @@\n-        int argInsertPos = 1;\n-        int argContextPos = 1;\n+        int argInsertPos = 0;\n+        int argContextPos = 0;\n@@ -213,1 +215,0 @@\n-\n@@ -230,0 +231,2 @@\n+            int retBufPos = -1;\n+            long retBufReadOffset = -1;\n@@ -232,0 +235,7 @@\n+            if (callingSequence.needsReturnBuffer()) {\n+                retBufPos = 0;\n+                retBufReadOffset = callingSequence.returnBufferSize();\n+                retContextPos++;\n+                retInsertPos++;\n+                returnFilter = dropArguments(returnFilter, retBufPos, MemorySegment.class);\n+            }\n@@ -236,1 +246,26 @@\n-                returnFilter = binding.specialize(returnFilter, retInsertPos, retContextPos);\n+                if (callingSequence.needsReturnBuffer() && binding.tag() == Binding.Tag.VM_LOAD) {\n+                    \/\/ spacial case this, since we need to update retBufReadOffset as well\n+                    Binding.VMLoad load = (Binding.VMLoad) binding;\n+                    ValueLayout layout = MemoryLayout.valueLayout(load.type(), ByteOrder.nativeOrder()).withBitAlignment(8);\n+                    \/\/ since we iterate the bindings in reverse, we have to compute the offset in reverse as well\n+                    retBufReadOffset -= abi.arch.typeSize(load.storage().type());\n+                    MethodHandle loadHandle = MemoryHandles.insertCoordinates(MemoryHandles.varHandle(layout), 1, retBufReadOffset)\n+                            .toMethodHandle(VarHandle.AccessMode.GET);\n+\n+                    returnFilter = MethodHandles.collectArguments(returnFilter, retInsertPos, loadHandle);\n+                    assert returnFilter.type().parameterType(retInsertPos - 1) == MemorySegment.class;\n+                    assert returnFilter.type().parameterType(retInsertPos - 2) == MemorySegment.class;\n+                    returnFilter = SharedUtils.mergeArguments(returnFilter, retBufPos, retInsertPos);\n+                    \/\/ to (... MemorySegment, MemorySegment, <primitive>, ...)\n+                    \/\/ from (... MemorySegment, MemorySegment, ...)\n+                    retInsertPos -= 2; \/\/ set insert pos back to the first MS (later DUP binding will merge the 2 MS)\n+                } else {\n+                    returnFilter = binding.specialize(returnFilter, retInsertPos, retContextPos);\n+                    if (callingSequence.needsReturnBuffer() && binding.tag() == Binding.Tag.BUFFER_STORE) {\n+                        \/\/ from (... MemorySegment, ...)\n+                        \/\/ to (... MemorySegment, MemorySegment, <primitive>, ...)\n+                        retInsertPos += 2; \/\/ set insert pos to <primitive>\n+                        assert returnFilter.type().parameterType(retInsertPos - 1) == MemorySegment.class;\n+                        assert returnFilter.type().parameterType(retInsertPos - 2) == MemorySegment.class;\n+                    }\n+                }\n@@ -238,2 +273,1 @@\n-            returnFilter = MethodHandles.filterArguments(returnFilter, retContextPos, MH_WRAP_ALLOCATOR);\n-            \/\/ (SegmentAllocator, Addressable, Context, ...) -> ...\n+            \/\/ (R, Context (ret)) -> (MemorySegment?, Context (ret), MemorySegment?, Context (arg), ...)\n@@ -241,2 +275,13 @@\n-            \/\/ (Addressable, SegmentAllocator, Context, ...) -> ...\n-            specializedHandle = SharedUtils.swapArguments(specializedHandle, 0, 1); \/\/ normalize parameter order\n+            if (callingSequence.needsReturnBuffer()) {\n+                \/\/ (MemorySegment, Context (ret), Context (arg), MemorySegment,  ...) -> (MemorySegment, Context (ret), Context (arg), ...)\n+                specializedHandle = SharedUtils.mergeArguments(specializedHandle, retBufPos, retBufPos + 3);\n+\n+                \/\/ allocate the return buffer from the binding context, and then merge the 2 allocator args\n+                MethodHandle retBufAllocHandle = MethodHandles.insertArguments(MH_ALLOCATE_RETURN_BUFFER, 1, callingSequence.returnBufferSize());\n+                \/\/ (MemorySegment, Context (ret), Context (arg), ...) -> (Context (arg), Context (ret), Context (arg), ...)\n+                specializedHandle = MethodHandles.filterArguments(specializedHandle, retBufPos, retBufAllocHandle);\n+                \/\/ (Context (arg), Context (ret), Context (arg), ...) -> (Context (ret), Context (arg), ...)\n+                specializedHandle = SharedUtils.mergeArguments(specializedHandle, argContextPos + 1, retBufPos); \/\/ +1 to skip return context\n+            }\n+            \/\/ (Context (ret), Context (arg), ...) -> (SegmentAllocator, Context (arg), ...)\n+            specializedHandle = MethodHandles.filterArguments(specializedHandle, 0, MH_WRAP_ALLOCATOR);\n@@ -244,1 +289,1 @@\n-            specializedHandle = MethodHandles.dropArguments(specializedHandle, 1, SegmentAllocator.class);\n+            specializedHandle = MethodHandles.dropArguments(specializedHandle, 0, SegmentAllocator.class);\n@@ -250,1 +295,1 @@\n-        specializedHandle = SharedUtils.wrapWithAllocator(specializedHandle, argContextPos, bufferCopySize, false);\n+        specializedHandle = SharedUtils.wrapWithAllocator(specializedHandle, argContextPos, callingSequence.allocationSize(), false);\n@@ -254,16 +299,1 @@\n-    \/**\n-     * Does a native invocation by moving primitive values from the arg array into an intermediate buffer\n-     * and calling the assembly stub that forwards arguments from the buffer to the target function\n-     *\n-     * @param args an array of primitive values to be copied in to the buffer\n-     * @param argBindings Binding.Move values describing how arguments should be copied\n-     * @param returnBindings Binding.Move values describing how return values should be copied\n-     * @return null, a single primitive value, or an Object[] of primitive values\n-     *\/\n-    Object invokeMoves(long addr, Object[] args, Binding.VMStore[] argBindings, Binding.VMLoad[] returnBindings) {\n-        MemorySegment stackArgsSeg = null;\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment argBuffer = MemorySegment.allocateNative(layout.size, 64, scope);\n-            if (stackArgsBytes > 0) {\n-                stackArgsSeg = MemorySegment.allocateNative(stackArgsBytes, 8, scope);\n-            }\n+    private record InvocationData(MethodHandle leaf, Map<VMStorage, Integer> argIndexMap, Map<VMStorage, Integer> retIndexMap) {}\n@@ -271,0 +301,1 @@\n+<<<<<<< HEAD\n@@ -319,0 +350,5 @@\n+=======\n+    Object invokeInterpBindings(SegmentAllocator allocator, Object[] args, InvocationData invData) throws Throwable {\n+        Binding.Context unboxContext = callingSequence.allocationSize() != 0\n+                ? Binding.Context.ofBoundedAllocator(callingSequence.allocationSize())\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -321,0 +357,2 @@\n+            MemorySegment returnBuffer = null;\n+\n@@ -322,0 +360,1 @@\n+<<<<<<< HEAD\n@@ -324,0 +363,11 @@\n+=======\n+            Object[] leafArgs = new Object[invData.leaf.type().parameterCount()];\n+            if (callingSequence.needsReturnBuffer()) {\n+                \/\/ we supply the return buffer (argument array does not contain it)\n+                Object[] prefixedArgs = new Object[args.length + 1];\n+                returnBuffer = unboxContext.allocator().allocate(callingSequence.returnBufferSize());\n+                prefixedArgs[0] = returnBuffer;\n+                System.arraycopy(args, 0, prefixedArgs, 1, args.length);\n+                args = prefixedArgs;\n+            }\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -328,0 +378,1 @@\n+<<<<<<< HEAD\n@@ -329,0 +380,3 @@\n+=======\n+                            leafArgs[invData.argIndexMap.get(storage)] = value;\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -333,0 +387,1 @@\n+<<<<<<< HEAD\n@@ -334,0 +389,3 @@\n+=======\n+            Object o = invData.leaf.invokeWithArguments(leafArgs);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -337,3 +395,4 @@\n-                return null;\n-            } else if (o instanceof Object[]) {\n-                Object[] oArr = (Object[]) o;\n+                if (!callingSequence.needsReturnBuffer()) {\n+                    return null;\n+                }\n+                MemorySegment finalReturnBuffer = returnBuffer;\n@@ -341,1 +400,9 @@\n-                        (storage, type) -> oArr[retIndexMap.get(storage)], Binding.Context.ofAllocator(allocator));\n+                        new BindingInterpreter.LoadFunc() {\n+                            int retBufReadOffset = 0;\n+                            @Override\n+                            public Object load(VMStorage storage, Class<?> type) {\n+                                Object result1 = SharedUtils.read(finalReturnBuffer.asSlice(retBufReadOffset), type);\n+                                retBufReadOffset += abi.arch.typeSize(storage.type());\n+                                return result1;\n+                            }\n+                        }, Binding.Context.ofAllocator(allocator));\n@@ -348,10 +415,0 @@\n-\n-    \/\/natives\n-\n-    static native void invokeNative(long adapterStub, long buff);\n-    static native long generateAdapter(ABIDescriptor abi, BufferLayout layout);\n-\n-    private static native void registerNatives();\n-    static {\n-        registerNatives();\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":162,"deletions":105,"binary":false,"changes":267,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+<<<<<<< HEAD\n@@ -29,0 +30,4 @@\n+=======\n+import jdk.incubator.foreign.MemoryHandles;\n+import jdk.incubator.foreign.MemoryLayout;\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -33,0 +38,1 @@\n+<<<<<<< HEAD\n@@ -36,0 +42,2 @@\n+=======\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -42,0 +50,1 @@\n+import java.nio.ByteOrder;\n@@ -48,0 +57,1 @@\n+import static java.lang.invoke.MethodHandles.collectArguments;\n@@ -49,0 +59,1 @@\n+<<<<<<< HEAD\n@@ -51,0 +62,4 @@\n+=======\n+import static java.lang.invoke.MethodHandles.empty;\n+import static java.lang.invoke.MethodHandles.exactInvoker;\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -58,5 +73,0 @@\n-\/**\n- * This class implements upcall invocation from native code through a so called 'universal adapter'. A universal upcall adapter\n- * takes an array of storage pointers, which describes the state of the CPU at the time of the upcall. This can be used\n- * by the Java code to fetch the upcall arguments and to store the results to the desired location, as per system ABI.\n- *\/\n@@ -68,0 +78,1 @@\n+<<<<<<< HEAD\n@@ -74,0 +85,2 @@\n+=======\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -75,1 +88,0 @@\n-    private static final MethodHandle MH_invokeMoves;\n@@ -81,3 +93,0 @@\n-            MH_invokeMoves = lookup.findStatic(ProgrammableUpcallHandler.class, \"invokeMoves\",\n-                    methodType(void.class, MemoryAddress.class, MethodHandle.class,\n-                               Binding.VMLoad[].class, Binding.VMStore[].class, ABIDescriptor.class, BufferLayout.class));\n@@ -85,2 +94,1 @@\n-                    methodType(Object.class, Object[].class, MethodHandle.class, Map.class, Map.class,\n-                            CallingSequence.class, long.class));\n+                    methodType(Object.class, Object[].class, InvocationData.class));\n@@ -96,7 +104,1 @@\n-        boolean isSimple = !(retMoves.length > 1);\n-\n-        Class<?> llReturn = !isSimple\n-            ? Object[].class\n-            : retMoves.length == 1\n-                ? retMoves[0].type()\n-                : void.class;\n+        Class<?> llReturn = retMoves.length == 1 ? retMoves[0].type() : void.class;\n@@ -104,1 +106,1 @@\n-        MethodType llType = MethodType.methodType(llReturn, llParams);\n+        MethodType llType = methodType(llReturn, llParams);\n@@ -107,3 +109,2 @@\n-        long bufferCopySize = SharedUtils.bufferCopySize(callingSequence);\n-        if (USE_SPEC && isSimple) {\n-            doBindings = specializedBindingHandle(target, callingSequence, llReturn, bufferCopySize);\n+        if (USE_SPEC) {\n+            doBindings = specializedBindingHandle(target, callingSequence, llReturn, abi);\n@@ -114,3 +115,7 @@\n-            target = target.asSpreader(Object[].class, callingSequence.methodType().parameterCount());\n-            doBindings = insertArguments(MH_invokeInterpBindings, 1, target, argIndices, retIndices, callingSequence,\n-                    bufferCopySize);\n+            int spreaderCount = callingSequence.methodType().parameterCount();\n+            if (callingSequence.needsReturnBuffer()) {\n+                spreaderCount--; \/\/ return buffer is dropped from the argument list\n+            }\n+            target = target.asSpreader(Object[].class, spreaderCount);\n+            InvocationData invData = new InvocationData(target, argIndices, retIndices, callingSequence, retMoves, abi);\n+            doBindings = insertArguments(MH_invokeInterpBindings, 1, invData);\n@@ -121,0 +126,1 @@\n+<<<<<<< HEAD\n@@ -138,0 +144,9 @@\n+=======\n+        checkPrimitive(doBindings.type());\n+        doBindings = insertArguments(exactInvoker(doBindings.type()), 0, doBindings);\n+        VMStorage[] args = Arrays.stream(argMoves).map(Binding.Move::storage).toArray(VMStorage[]::new);\n+        VMStorage[] rets = Arrays.stream(retMoves).map(Binding.Move::storage).toArray(VMStorage[]::new);\n+        CallRegs conv = new CallRegs(args, rets);\n+        long entryPoint = allocateOptimizedUpcallStub(doBindings, abi, conv,\n+                callingSequence.needsReturnBuffer(), callingSequence.returnBufferSize());\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -166,1 +181,1 @@\n-                                                         Class<?> llReturn, long bufferCopySize) {\n+                                                         Class<?> llReturn, ABIDescriptor abi) {\n@@ -171,0 +186,32 @@\n+        \/\/ we handle returns first since IMR adds an extra parameter that needs to be specialized as well\n+        if (llReturn != void.class || callingSequence.needsReturnBuffer()) {\n+            int retAllocatorPos = -1; \/\/ assumed not needed\n+            int retInsertPos;\n+            MethodHandle filter;\n+            if (callingSequence.needsReturnBuffer()) {\n+                retInsertPos = 1;\n+                filter = empty(methodType(void.class, MemorySegment.class));\n+            } else {\n+                retInsertPos = 0;\n+                filter = identity(llReturn);\n+            }\n+            long retBufWriteOffset = callingSequence.returnBufferSize();\n+            List<Binding> bindings = callingSequence.returnBindings();\n+            for (int j = bindings.size() - 1; j >= 0; j--) {\n+                Binding binding = bindings.get(j);\n+                if (callingSequence.needsReturnBuffer() && binding.tag() == Binding.Tag.VM_STORE) {\n+                    Binding.VMStore store = (Binding.VMStore) binding;\n+                    ValueLayout layout = MemoryLayout.valueLayout(store.type(), ByteOrder.nativeOrder()).withBitAlignment(8);\n+                    \/\/ since we iterate the bindings in reverse, we have to compute the offset in reverse as well\n+                    retBufWriteOffset -= abi.arch.typeSize(store.storage().type());\n+                    MethodHandle storeHandle = MemoryHandles.insertCoordinates(MemoryHandles.varHandle(layout), 1, retBufWriteOffset)\n+                            .toMethodHandle(VarHandle.AccessMode.SET);\n+                    filter = collectArguments(filter, retInsertPos, storeHandle);\n+                    filter = mergeArguments(filter, retInsertPos - 1, retInsertPos);\n+                } else {\n+                    filter = binding.specialize(filter, retInsertPos, retAllocatorPos);\n+                }\n+            }\n+            specializedHandle = collectArguments(filter, retInsertPos, specializedHandle);\n+        }\n+\n@@ -190,13 +237,1 @@\n-        if (llReturn != void.class) {\n-            int retAllocatorPos = -1; \/\/ assumed not needed\n-            int retInsertPos = 0;\n-            MethodHandle filter = identity(llReturn);\n-            List<Binding> bindings = callingSequence.returnBindings();\n-            for (int j = bindings.size() - 1; j >= 0; j--) {\n-                Binding binding = bindings.get(j);\n-                filter = binding.specialize(filter, retInsertPos, retAllocatorPos);\n-            }\n-            specializedHandle = filterReturnValue(specializedHandle, filter);\n-        }\n-\n-        specializedHandle = SharedUtils.wrapWithAllocator(specializedHandle, argAllocatorPos, bufferCopySize, true);\n+        specializedHandle = SharedUtils.wrapWithAllocator(specializedHandle, argAllocatorPos, callingSequence.allocationSize(), true);\n@@ -207,3 +242,6 @@\n-    public static void invoke(MethodHandle mh, long address) throws Throwable {\n-        mh.invokeExact(MemoryAddress.ofLong(address));\n-    }\n+    private record InvocationData(MethodHandle leaf,\n+                                  Map<VMStorage, Integer> argIndexMap,\n+                                  Map<VMStorage, Integer> retIndexMap,\n+                                  CallingSequence callingSequence,\n+                                  Binding.VMStore[] retMoves,\n+                                  ABIDescriptor abi) {}\n@@ -211,53 +249,3 @@\n-    private static void invokeMoves(MemoryAddress buffer, MethodHandle leaf,\n-                                    Binding.VMLoad[] argBindings, Binding.VMStore[] returnBindings,\n-                                    ABIDescriptor abi, BufferLayout layout) throws Throwable {\n-        MemorySegment bufferBase = MemoryAddressImpl.ofLongUnchecked(buffer.toRawLongValue(), layout.size);\n-\n-        if (DEBUG) {\n-            System.err.println(\"Buffer state before:\");\n-            layout.dump(abi.arch, bufferBase, System.err);\n-        }\n-\n-        MemorySegment stackArgsBase = MemoryAddressImpl.ofLongUnchecked((long)VH_LONG.get(bufferBase.asSlice(layout.stack_args)));\n-        Object[] moves = new Object[argBindings.length];\n-        for (int i = 0; i < moves.length; i++) {\n-            Binding.VMLoad binding = argBindings[i];\n-            VMStorage storage = binding.storage();\n-            MemorySegment ptr = abi.arch.isStackType(storage.type())\n-                ? stackArgsBase.asSlice(storage.index() * abi.arch.typeSize(abi.arch.stackType()))\n-                : bufferBase.asSlice(layout.argOffset(storage));\n-            moves[i] = SharedUtils.read(ptr, binding.type());\n-        }\n-\n-        \/\/ invokeInterpBindings, and then actual target\n-        Object o = leaf.invoke(moves);\n-\n-        if (o == null) {\n-            \/\/ nop\n-        } else if (o instanceof Object[] returns) {\n-            for (int i = 0; i < returnBindings.length; i++) {\n-                Binding.VMStore binding = returnBindings[i];\n-                VMStorage storage = binding.storage();\n-                MemorySegment ptr = bufferBase.asSlice(layout.retOffset(storage));\n-                SharedUtils.writeOverSized(ptr, binding.type(), returns[i]);\n-            }\n-        } else { \/\/ single Object\n-            Binding.VMStore binding = returnBindings[0];\n-            VMStorage storage = binding.storage();\n-            MemorySegment ptr = bufferBase.asSlice(layout.retOffset(storage));\n-            SharedUtils.writeOverSized(ptr, binding.type(), o);\n-        }\n-\n-        if (DEBUG) {\n-            System.err.println(\"Buffer state after:\");\n-            layout.dump(abi.arch, bufferBase, System.err);\n-        }\n-    }\n-\n-    private static Object invokeInterpBindings(Object[] moves, MethodHandle leaf,\n-                                               Map<VMStorage, Integer> argIndexMap,\n-                                               Map<VMStorage, Integer> retIndexMap,\n-                                               CallingSequence callingSequence,\n-                                               long bufferCopySize) throws Throwable {\n-        Binding.Context allocator = bufferCopySize != 0\n-                ? Binding.Context.ofBoundedAllocator(bufferCopySize)\n+    private static Object invokeInterpBindings(Object[] lowLevelArgs, InvocationData invData) throws Throwable {\n+        Binding.Context allocator = invData.callingSequence.allocationSize() != 0\n+                ? Binding.Context.ofBoundedAllocator(invData.callingSequence.allocationSize())\n@@ -267,4 +255,13 @@\n-            Object[] args = new Object[callingSequence.methodType().parameterCount()];\n-            for (int i = 0; i < args.length; i++) {\n-                args[i] = BindingInterpreter.box(callingSequence.argumentBindings(i),\n-                        (storage, type) -> moves[argIndexMap.get(storage)], allocator);\n+            Object[] highLevelArgs = new Object[invData.callingSequence.methodType().parameterCount()];\n+            for (int i = 0; i < highLevelArgs.length; i++) {\n+                highLevelArgs[i] = BindingInterpreter.box(invData.callingSequence.argumentBindings(i),\n+                        (storage, type) -> lowLevelArgs[invData.argIndexMap.get(storage)], allocator);\n+            }\n+\n+            MemorySegment returnBuffer = null;\n+            if (invData.callingSequence.needsReturnBuffer()) {\n+                \/\/ this one is for us\n+                returnBuffer = (MemorySegment) highLevelArgs[0];\n+                Object[] newArgs = new Object[highLevelArgs.length - 1];\n+                System.arraycopy(highLevelArgs, 1, newArgs, 0, newArgs.length);\n+                highLevelArgs = newArgs;\n@@ -275,1 +272,1 @@\n-                System.err.println(Arrays.toString(args).indent(2));\n+                System.err.println(Arrays.toString(highLevelArgs).indent(2));\n@@ -279,1 +276,1 @@\n-            Object o = leaf.invoke(args);\n+            Object o = invData.leaf.invoke(highLevelArgs);\n@@ -286,4 +283,4 @@\n-            Object[] returnMoves = new Object[retIndexMap.size()];\n-            if (leaf.type().returnType() != void.class) {\n-                BindingInterpreter.unbox(o, callingSequence.returnBindings(),\n-                        (storage, type, value) -> returnMoves[retIndexMap.get(storage)] = value, null);\n+            Object[] returnValues = new Object[invData.retIndexMap.size()];\n+            if (invData.leaf.type().returnType() != void.class) {\n+                BindingInterpreter.unbox(o, invData.callingSequence.returnBindings(),\n+                        (storage, type, value) -> returnValues[invData.retIndexMap.get(storage)] = value, null);\n@@ -292,1 +289,1 @@\n-            if (returnMoves.length == 0) {\n+            if (returnValues.length == 0) {\n@@ -294,2 +291,2 @@\n-            } else if (returnMoves.length == 1) {\n-                return returnMoves[0];\n+            } else if (returnValues.length == 1) {\n+                return returnValues[0];\n@@ -297,1 +294,16 @@\n-                return returnMoves;\n+                assert invData.callingSequence.needsReturnBuffer();\n+\n+                Binding.VMStore[] retMoves = invData.callingSequence.returnBindings().stream()\n+                        .filter(Binding.VMStore.class::isInstance)\n+                        .map(Binding.VMStore.class::cast)\n+                        .toArray(Binding.VMStore[]::new);\n+\n+                assert returnValues.length == retMoves.length;\n+                int retBufWriteOffset = 0;\n+                for (int i = 0; i < retMoves.length; i++) {\n+                    Binding.VMStore store = retMoves[i];\n+                    Object value = returnValues[i];\n+                    SharedUtils.writeOverSized(returnBuffer.asSlice(retBufWriteOffset), store.type(), value);\n+                    retBufWriteOffset += invData.abi.arch.typeSize(store.storage().type());\n+                }\n+                return null;\n@@ -308,3 +320,2 @@\n-    static native long allocateOptimizedUpcallStub(MethodHandle mh, ABIDescriptor abi, CallRegs conv);\n-    static native long allocateUpcallStub(MethodHandle mh, ABIDescriptor abi, BufferLayout layout);\n-    static native boolean supportsOptimizedUpcalls();\n+    static native long allocateOptimizedUpcallStub(MethodHandle mh, ABIDescriptor abi, CallRegs conv,\n+                                                   boolean needsReturnBuffer, long returnBufferSize);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":123,"deletions":112,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -299,21 +299,0 @@\n-    static long bufferCopySize(CallingSequence callingSequence) {\n-        \/\/ FIXME: > 16 bytes alignment might need extra space since the\n-        \/\/ starting address of the allocator might be un-aligned.\n-        long size = 0;\n-        for (int i = 0; i < callingSequence.argumentCount(); i++) {\n-            List<Binding> bindings = callingSequence.argumentBindings(i);\n-            for (Binding b : bindings) {\n-                if (b instanceof Binding.Copy) {\n-                    Binding.Copy c = (Binding.Copy) b;\n-                    size = Utils.alignUp(size, c.alignment());\n-                    size += c.size();\n-                } else if (b instanceof Binding.Allocate) {\n-                    Binding.Allocate c = (Binding.Allocate) b;\n-                    size = Utils.alignUp(size, c.alignment());\n-                    size += c.size();\n-                }\n-            }\n-        }\n-        return size;\n-    }\n-\n@@ -336,1 +315,2 @@\n-        assert destIndex > sourceIndex;\n+        if (destIndex < sourceIndex)\n+            sourceIndex--;\n@@ -374,1 +354,1 @@\n-                                          int allocatorPos, long bufferCopySize,\n+                                          int allocatorPos, long allocationSize,\n@@ -396,0 +376,1 @@\n+<<<<<<< HEAD\n@@ -403,0 +384,8 @@\n+=======\n+        \/\/ downcalls get the leading SegmentAllocator param as well\n+        if (!upcall) {\n+            closer = dropArguments(closer, insertPos++, SegmentAllocator.class); \/\/ (Throwable, V?, SegmentAllocator, NativeSymbol) -> V\/void\n+        }\n+\n+        closer = collectArguments(closer, insertPos, MH_CLOSE_CONTEXT); \/\/ (Throwable, V?, SegmentAllocator?, BindingContext) -> V\/void\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -406,2 +395,2 @@\n-        if (bufferCopySize > 0) {\n-            contextFactory = MethodHandles.insertArguments(MH_MAKE_CONTEXT_BOUNDED_ALLOCATOR, 0, bufferCopySize);\n+        if (allocationSize > 0) {\n+            contextFactory = MethodHandles.insertArguments(MH_MAKE_CONTEXT_BOUNDED_ALLOCATOR, 0, allocationSize);\n@@ -561,0 +550,11 @@\n+<<<<<<< HEAD\n+=======\n+    public static MethodHandle maybeInsertAllocator(MethodHandle handle) {\n+        if (!handle.type().returnType().equals(MemorySegment.class)) {\n+            \/\/ not returning segment, just insert a throwing allocator\n+            handle = insertArguments(handle, 1, THROWING_ALLOCATOR);\n+        }\n+        return handle;\n+    }\n+\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -676,0 +676,2 @@\n+<<<<<<< HEAD\n+=======\n@@ -681,0 +683,1 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -685,0 +688,3 @@\n+<<<<<<< HEAD\n+        public long nextVarg(ValueLayout.OfLong layout) {\n+=======\n@@ -686,0 +692,10 @@\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n+            throw uoe();\n+        }\n+\n+        @Override\n+<<<<<<< HEAD\n+        public double nextVarg(ValueLayout.OfDouble layout) {\n+=======\n+        public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -690,0 +706,1 @@\n+<<<<<<< HEAD\n@@ -695,0 +712,2 @@\n+=======\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":44,"deletions":25,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -91,1 +91,3 @@\n-        0    \/\/ No shadow space\n+        0,   \/\/ No shadow space\n+        r9,  \/\/ target addr reg\n+        r10  \/\/ return buffer addr reg\n@@ -119,0 +121,1 @@\n+<<<<<<< HEAD\n@@ -120,0 +123,3 @@\n+=======\n+        CallingSequenceBuilder csb = new CallingSequenceBuilder(C, forUpcall);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+<<<<<<< HEAD\n@@ -69,0 +70,3 @@\n+=======\n+        handle = SharedUtils.maybeInsertAllocator(handle);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,4 @@\n+<<<<<<< HEAD\n+=======\n+import java.lang.ref.Cleaner;\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -114,0 +118,1 @@\n+<<<<<<< HEAD\n@@ -118,0 +123,6 @@\n+=======\n+        MemorySegment gpRegsArea = MemorySegment.ofAddressNative(grTop(segment).addOffset(-MAX_GP_OFFSET),\n+                MAX_GP_OFFSET, segment.scope());\n+\n+        MemorySegment fpRegsArea = MemorySegment.ofAddressNative(vrTop(segment).addOffset(-MAX_FP_OFFSET),\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -126,0 +137,1 @@\n+<<<<<<< HEAD\n@@ -127,0 +139,3 @@\n+=======\n+        MemorySegment ms = MemorySegment.ofAddressNative(MemoryAddress.ofLong(ptr),\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -249,0 +264,1 @@\n+<<<<<<< HEAD\n@@ -250,0 +266,3 @@\n+=======\n+                    MemorySegment slice = MemorySegment.ofAddressNative(stackPtr(), layout.byteSize(), scope());\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -257,0 +276,1 @@\n+<<<<<<< HEAD\n@@ -258,0 +278,3 @@\n+=======\n+                    MemorySegment slice = MemorySegment.ofAddressNative(stackPtr(), layout.byteSize(), scope());\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -299,0 +322,1 @@\n+<<<<<<< HEAD\n@@ -300,0 +324,3 @@\n+=======\n+                    MemorySegment slice = MemorySegment.ofAddressNative(ptr, layout.byteSize(), scope());\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -345,0 +372,1 @@\n+<<<<<<< HEAD\n@@ -346,0 +374,3 @@\n+=======\n+        return readFromSegment(MemorySegment.ofAddressNative(ma, LAYOUT.byteSize(), scope));\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+<<<<<<< HEAD\n@@ -69,0 +70,3 @@\n+=======\n+        handle = SharedUtils.maybeInsertAllocator(handle);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+<<<<<<< HEAD\n@@ -106,0 +107,3 @@\n+=======\n+                    MemorySegment struct = MemorySegment.ofAddressNative(structAddr, layout.byteSize(), scope());\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -142,0 +146,1 @@\n+<<<<<<< HEAD\n@@ -143,0 +148,3 @@\n+=======\n+        MemorySegment segment = MemorySegment.ofAddressNative(addr, Long.MAX_VALUE, scope);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -73,1 +73,3 @@\n-        0 \/\/no shadow space\n+        0, \/\/no shadow space\n+        r10, \/\/ target addr reg\n+        r11  \/\/ ret buf addr reg\n@@ -90,0 +92,1 @@\n+<<<<<<< HEAD\n@@ -91,0 +94,3 @@\n+=======\n+        CallingSequenceBuilder csb = new CallingSequenceBuilder(CSysV, forUpcall);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,0 +36,4 @@\n+<<<<<<< HEAD\n+=======\n+import java.lang.ref.Cleaner;\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -130,0 +134,1 @@\n+<<<<<<< HEAD\n@@ -131,0 +136,3 @@\n+=======\n+        MemorySegment base = MemorySegment.ofAddressNative(MemoryAddress.ofLong(ptr),\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -172,0 +180,1 @@\n+<<<<<<< HEAD\n@@ -173,0 +182,3 @@\n+=======\n+        return MemorySegment.ofAddressNative(((MemoryAddress)VH_reg_save_area.get(segment)),\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -224,0 +236,1 @@\n+<<<<<<< HEAD\n@@ -225,0 +238,3 @@\n+=======\n+                    MemorySegment slice = MemorySegment.ofAddressNative(stackPtr(), layout.byteSize(), scope());\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -233,0 +249,1 @@\n+<<<<<<< HEAD\n@@ -234,0 +251,3 @@\n+=======\n+                        MemorySegment slice = MemorySegment.ofAddressNative(stackPtr(), layout.byteSize(), localScope);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -298,0 +318,1 @@\n+<<<<<<< HEAD\n@@ -299,0 +320,3 @@\n+=======\n+        return readFromSegment(MemorySegment.ofAddressNative(ma, LAYOUT.byteSize(), scope));\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+<<<<<<< HEAD\n@@ -32,0 +33,2 @@\n+=======\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -38,1 +41,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -75,0 +77,1 @@\n+<<<<<<< HEAD\n@@ -79,0 +82,3 @@\n+=======\n+        handle = SharedUtils.maybeInsertAllocator(handle);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+<<<<<<< HEAD\n@@ -116,0 +117,3 @@\n+=======\n+                    MemorySegment struct = MemorySegment.ofAddressNative(structAddr, layout.byteSize(), scope());\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -141,0 +145,1 @@\n+<<<<<<< HEAD\n@@ -142,0 +147,3 @@\n+=======\n+        MemorySegment segment = MemorySegment.ofAddressNative(addr, Long.MAX_VALUE, scope);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+<<<<<<< HEAD\n@@ -80,0 +81,3 @@\n+=======\n+        handle = SharedUtils.maybeInsertAllocator(handle);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.stream.Stream;\n@@ -52,0 +53,8 @@\n+<<<<<<< HEAD\n+=======\n+    static final List<MemoryLayout> STACK_PREFIX_LAYOUTS = Stream.concat(\n+            Stream.generate(() -> (MemoryLayout) C_LONG_LONG).limit(8),\n+            Stream.generate(() -> (MemoryLayout)  C_DOUBLE).limit(8)\n+        ).toList();\n+\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+<<<<<<< HEAD\n@@ -165,0 +166,54 @@\n+=======\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            list = VaList.make(b -> b.addVarg(C_INT, 42), scope);\n+        }\n+        assertFalse(list.scope().isAlive());\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+                LOOKUP.lookup(\"addr_func\").get(),\n+                FunctionDescriptor.ofVoid(C_POINTER));\n+\n+        handle.invokeExact((Addressable)list);\n+    }\n+\n+    @Test(expectedExceptions = IllegalStateException.class)\n+    public void testClosedUpcall() throws Throwable {\n+        NativeSymbol upcall;\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MethodHandle dummy = MethodHandles.lookup().findStatic(SafeFunctionAccessTest.class, \"dummy\", MethodType.methodType(void.class));\n+            upcall = CLinker.systemCLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), scope);\n+        }\n+        assertFalse(upcall.scope().isAlive());\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+                LOOKUP.lookup(\"addr_func\").get(),\n+                FunctionDescriptor.ofVoid(C_POINTER));\n+\n+        handle.invokeExact((Addressable)upcall);\n+    }\n+\n+    static void dummy() { }\n+\n+    @Test\n+    public void testClosedVaListCallback() throws Throwable {\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+                LOOKUP.lookup(\"addr_func_cb\").get(),\n+                FunctionDescriptor.ofVoid(C_POINTER, C_POINTER));\n+\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            VaList list = VaList.make(b -> b.addVarg(C_INT, 42), scope);\n+            handle.invoke(list, scopeChecker(scope));\n+        }\n+    }\n+\n+    @Test\n+    public void testClosedStructCallback() throws Throwable {\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+                LOOKUP.lookup(\"addr_func_cb\").get(),\n+                FunctionDescriptor.ofVoid(C_POINTER, C_POINTER));\n+\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(POINT, scope);\n+            handle.invoke(segment, scopeChecker(scope));\n+        }\n+    }\n+\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -191,0 +191,1 @@\n+<<<<<<< HEAD\n@@ -192,0 +193,3 @@\n+=======\n+                        MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class));\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -248,0 +252,1 @@\n+<<<<<<< HEAD\n@@ -249,0 +254,3 @@\n+=======\n+                this.base = MemorySegment.ofAddressNative(addr, SIZE, ResourceScope.globalScope());\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+<<<<<<< HEAD\n@@ -22,0 +23,22 @@\n+=======\n+ *  Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/jdk\/java\/foreign\/TestArrayCopy.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -121,0 +121,1 @@\n+<<<<<<< HEAD\n@@ -122,0 +123,3 @@\n+=======\n+        MemorySegment segment = MemorySegment.ofAddressNative(MemoryAddress.NULL, seq.byteSize(), ResourceScope.globalScope());\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -491,0 +491,1 @@\n+<<<<<<< HEAD\n@@ -492,0 +493,3 @@\n+=======\n+        MemorySegment segment = MemorySegment.ofAddressNative(MemoryAddress.NULL, Integer.MAX_VALUE + 10L, ResourceScope.newImplicitScope());\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,4 @@\n+<<<<<<< HEAD\n+=======\n+import jdk.incubator.foreign.GroupLayout;\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -42,1 +46,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -46,1 +49,0 @@\n-import java.lang.invoke.MethodType;\n@@ -50,0 +52,1 @@\n+import java.util.stream.Stream;\n@@ -61,0 +64,1 @@\n+        System.loadLibrary(\"TestDowncallStack\");\n@@ -69,0 +73,1 @@\n+<<<<<<< HEAD\n@@ -74,0 +79,6 @@\n+=======\n+        FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n+        Object[] args = makeArgs(paramTypes, fields, checks);\n+        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+            boolean needsScope = descriptor.returnLayout().map(GroupLayout.class::isInstance).orElse(false);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -88,0 +99,25 @@\n+<<<<<<< HEAD\n+=======\n+    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n+    public void testDowncallStack(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+        List<Consumer<Object>> checks = new ArrayList<>();\n+        NativeSymbol addr = LOOKUP.lookup(\"s\" + fName).get();\n+        FunctionDescriptor descriptor = functionStack(ret, paramTypes, fields);\n+        Object[] args = makeArgsStack(paramTypes, fields, checks);\n+        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+            boolean needsScope = descriptor.returnLayout().map(GroupLayout.class::isInstance).orElse(false);\n+            SegmentAllocator allocator = needsScope ?\n+                    SegmentAllocator.newNativeArena(scope) :\n+                    THROWING_ALLOCATOR;\n+            Object res = doCall(addr, allocator, descriptor, args);\n+            if (ret == Ret.NON_VOID) {\n+                checks.forEach(c -> c.accept(res));\n+                if (needsScope) {\n+                    \/\/ check that return struct has indeed been allocated in the native scope\n+                    assertEquals(((MemorySegment) res).scope(), scope);\n+                }\n+            }\n+        }\n+    }\n+\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -94,0 +130,1 @@\n+<<<<<<< HEAD\n@@ -101,0 +138,4 @@\n+=======\n+    static FunctionDescriptor functionStack(Ret ret, List<ParamType> params, List<StructFieldType> fields) {\n+        return function(ret, params, fields, STACK_PREFIX_LAYOUTS);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -104,1 +145,6 @@\n-        MemoryLayout[] paramLayouts = params.stream().map(p -> p.layout(fields)).toArray(MemoryLayout[]::new);\n+        return function(ret, params, fields, List.of());\n+    }\n+\n+    static FunctionDescriptor function(Ret ret, List<ParamType> params, List<StructFieldType> fields, List<MemoryLayout> prefix) {\n+        List<MemoryLayout> pLayouts = params.stream().map(p -> p.layout(fields)).toList();\n+        MemoryLayout[] paramLayouts = Stream.concat(prefix.stream(), pLayouts.stream()).toArray(MemoryLayout[]::new);\n@@ -107,1 +153,5 @@\n-                FunctionDescriptor.of(paramLayouts[0], paramLayouts);\n+                FunctionDescriptor.of(paramLayouts[prefix.size()], paramLayouts);\n+    }\n+\n+    static Object[] makeArgsStack(List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks) throws ReflectiveOperationException {\n+        return makeArgs(params, fields, checks, STACK_PREFIX_LAYOUTS);\n@@ -111,1 +161,9 @@\n-        Object[] args = new Object[params.size()];\n+        return makeArgs(params, fields, checks, List.of());\n+    }\n+\n+    static Object[] makeArgs(List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<MemoryLayout> prefix) throws ReflectiveOperationException {\n+        Object[] args = new Object[prefix.size() + params.size()];\n+        int argNum = 0;\n+        for (MemoryLayout layout : prefix) {\n+            args[argNum++] = makeArg(layout, null, false);\n+        }\n@@ -113,1 +171,1 @@\n-            args[i] = makeArg(params.get(i).layout(fields), checks, i == 0);\n+            args[argNum++] = makeArg(params.get(i).layout(fields), checks, i == 0);\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":64,"deletions":6,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+<<<<<<< HEAD\n@@ -42,0 +43,3 @@\n+=======\n+        return MemorySegment.ofAddressNative(addr, numElements * layout.byteSize(), ResourceScope.globalScope());\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/jdk\/java\/foreign\/TestFree.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.lang.constant.Constable;\n@@ -38,1 +37,0 @@\n-import java.util.stream.Collectors;\n@@ -70,0 +68,1 @@\n+<<<<<<< HEAD\n@@ -71,0 +70,3 @@\n+=======\n+        fd = fd.appendArgumentLayouts(C_POINTER);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/jdk\/java\/foreign\/TestFunctionDescriptor.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -173,0 +173,1 @@\n+<<<<<<< HEAD\n@@ -174,0 +175,3 @@\n+=======\n+            MemorySegment mallocSegment = MemorySegment.ofAddressNative(addr, 12, scope);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -184,0 +188,1 @@\n+<<<<<<< HEAD\n@@ -185,0 +190,3 @@\n+=======\n+            mallocSegment = MemorySegment.ofAddressNative(addr, 12, scope);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -203,0 +211,1 @@\n+<<<<<<< HEAD\n@@ -204,0 +213,3 @@\n+=======\n+            MemorySegment.ofAddressNative(segment.address(), 0, ResourceScope.globalScope());\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+<<<<<<< HEAD\n@@ -61,0 +62,3 @@\n+=======\n+        Method method = MemorySegment.class.getDeclaredMethod(\"ofAddressNative\", MemoryAddress.class, long.class, ResourceScope.class);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -66,0 +70,1 @@\n+<<<<<<< HEAD\n@@ -67,0 +72,3 @@\n+=======\n+        var mh = MethodHandles.lookup().findStatic(MemorySegment.class, \"ofAddressNative\",\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -73,0 +81,1 @@\n+<<<<<<< HEAD\n@@ -74,0 +83,3 @@\n+=======\n+        MemorySegment.ofAddressNative(MemoryAddress.NULL, 4000, ResourceScope.globalScope());\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/jdk\/java\/foreign\/TestRestricted.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -237,0 +237,1 @@\n+<<<<<<< HEAD\n@@ -238,0 +239,3 @@\n+=======\n+            UNSAFE(scope -> MemorySegment.ofAddressNative(MemoryAddress.NULL, 10, scope));\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+<<<<<<< HEAD\n@@ -125,0 +126,3 @@\n+=======\n+            allocator.allocate(12);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+<<<<<<< HEAD\n@@ -102,0 +103,3 @@\n+=======\n+            MemorySegment sharedSegment = MemorySegment.ofAddressNative(s.address(), s.byteSize(), scope);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -64,0 +65,1 @@\n+<<<<<<< HEAD\n@@ -65,0 +67,3 @@\n+=======\n+        MemorySegment segment = MemorySegment.ofAddressNative(LOOKUP.lookup(\"c\").get().address(), ValueLayout.JAVA_INT.byteSize(), ResourceScope.globalScope());\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/jdk\/java\/foreign\/TestSymbolLookup.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+<<<<<<< HEAD\n@@ -27,0 +28,3 @@\n+=======\n+ * @test id=scope\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -33,0 +37,1 @@\n+<<<<<<< HEAD\n@@ -37,0 +42,30 @@\n+=======\n+ *   -DUPCALL_TEST_TYPE=SCOPE\n+ *   TestUpcall\n+ *\/\n+\n+\/*\n+ * @test id=async\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ *\n+ * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n+ *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=17\n+ *   -DUPCALL_TEST_TYPE=ASYNC\n+ *   TestUpcall\n+ *\/\n+\n+\/*\n+ * @test id=stack\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ *\n+ * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n+ *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=17\n+ *   -DUPCALL_TEST_TYPE=STACK\n+ *   TestUpcall\n+ *\/\n+\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -62,0 +97,1 @@\n+import java.util.stream.Stream;\n@@ -66,1 +102,0 @@\n-\n@@ -71,0 +106,1 @@\n+<<<<<<< HEAD\n@@ -73,0 +109,4 @@\n+=======\n+        ASYNC,\n+        STACK\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -79,0 +119,4 @@\n+<<<<<<< HEAD\n+=======\n+        System.loadLibrary(\"TestUpcallStack\");\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -92,1 +136,1 @@\n-                    MethodType.methodType(Object.class, Object[].class, AtomicReference.class));\n+                    MethodType.methodType(Object.class, Object[].class, AtomicReference.class, int.class));\n@@ -107,0 +151,1 @@\n+<<<<<<< HEAD\n@@ -108,0 +153,3 @@\n+=======\n+            throw new SkipException(\"Skipping tests that were not selected\");\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -133,0 +181,1 @@\n+<<<<<<< HEAD\n@@ -154,0 +203,44 @@\n+=======\n+\n+        List<Consumer<Object>> returnChecks = new ArrayList<>();\n+        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n+        NativeSymbol addr = LOOKUP.lookup(fName).get();\n+        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+            FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n+            MethodHandle mh = reverse(downcallHandle(abi, addr, allocator, descriptor));\n+            Object[] args = makeArgs(ResourceScope.newImplicitScope(), ret, paramTypes, fields, returnChecks, argChecks);\n+\n+            mh = mh.asSpreader(Object[].class, args.length);\n+            mh = MethodHandles.insertArguments(mh, 0, (Object) args);\n+            FunctionDescriptor callbackDesc = descriptor.returnLayout()\n+                    .map(FunctionDescriptor::of)\n+                    .orElse(FunctionDescriptor.ofVoid());\n+            NativeSymbol callback = abi.upcallStub(mh, callbackDesc, scope);\n+\n+            MethodHandle invoker = asyncInvoker(ret, ret == Ret.VOID ? null : paramTypes.get(0), fields);\n+\n+            Object res = invoker.type().returnType() == MemorySegment.class\n+                    ? invoker.invoke(allocator, callback)\n+                    : invoker.invoke(callback);\n+            argChecks.forEach(c -> c.accept(args));\n+            if (ret == Ret.NON_VOID) {\n+                returnChecks.forEach(c -> c.accept(res));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n+    public void testUpcallsStack(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+        checkSelected(TestType.STACK);\n+\n+        List<Consumer<Object>> returnChecks = new ArrayList<>();\n+        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n+        NativeSymbol addr = LOOKUP.lookup(\"s\" + fName).get();\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+            MethodHandle mh = downcallHandle(abi, addr, allocator, functionStack(ret, paramTypes, fields));\n+            Object[] args = makeArgsStack(scope, ret, paramTypes, fields, returnChecks, argChecks);\n+            Object[] callArgs = args;\n+            Object res = mh.invokeWithArguments(callArgs);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -167,0 +260,1 @@\n+<<<<<<< HEAD\n@@ -170,0 +264,5 @@\n+=======\n+                    abi.downcallHandle(\n+                            LOOKUP.lookup(symbol).orElseThrow(),\n+                            FunctionDescriptor.ofVoid(C_POINTER)));\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -182,0 +281,7 @@\n+<<<<<<< HEAD\n+=======\n+    }\n+\n+    static FunctionDescriptor functionStack(Ret ret, List<ParamType> params, List<StructFieldType> fields) {\n+        return function(ret, params, fields, STACK_PREFIX_LAYOUTS);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -185,0 +291,4 @@\n+        return function(ret, params, fields, List.of());\n+    }\n+\n+    static FunctionDescriptor function(Ret ret, List<ParamType> params, List<StructFieldType> fields, List<MemoryLayout> prefix) {\n@@ -187,1 +297,1 @@\n-        MemoryLayout[] layouts = paramLayouts.toArray(new MemoryLayout[0]);\n+        MemoryLayout[] layouts = Stream.concat(prefix.stream(), paramLayouts.stream()).toArray(MemoryLayout[]::new);\n@@ -190,1 +300,5 @@\n-                FunctionDescriptor.of(layouts[0], layouts);\n+                FunctionDescriptor.of(layouts[prefix.size()], layouts);\n+    }\n+\n+    static Object[] makeArgsStack(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n+        return makeArgs(scope, ret, params, fields, checks, argChecks, STACK_PREFIX_LAYOUTS);\n@@ -194,1 +308,9 @@\n-        Object[] args = new Object[params.size() + 1];\n+        return makeArgs(scope, ret, params, fields, checks, argChecks, List.of());\n+    }\n+\n+    static Object[] makeArgs(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) throws ReflectiveOperationException {\n+        Object[] args = new Object[prefix.size() + params.size() + 1];\n+        int argNum = 0;\n+        for (MemoryLayout layout : prefix) {\n+            args[argNum++] = makeArg(layout, null, false);\n+        }\n@@ -196,1 +318,1 @@\n-            args[i] = makeArg(params.get(i).layout(fields), checks, i == 0);\n+            args[argNum++] = makeArg(params.get(i).layout(fields), checks, i == 0);\n@@ -198,1 +320,1 @@\n-        args[params.size()] = makeCallback(scope, ret, params, fields, checks, argChecks);\n+        args[argNum] = makeCallback(scope, ret, params, fields, checks, argChecks, prefix);\n@@ -202,0 +324,1 @@\n+<<<<<<< HEAD\n@@ -204,0 +327,3 @@\n+=======\n+    static NativeSymbol makeCallback(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -209,2 +335,6 @@\n-        MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box);\n-        mh = mh.asCollector(Object[].class, params.size());\n+        MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box, prefix.size());\n+        mh = mh.asCollector(Object[].class, prefix.size() + params.size());\n+\n+        for(int i = 0; i < prefix.size(); i++) {\n+            mh = mh.asType(mh.type().changeParameterType(i, carrier(prefix.get(i), false)));\n+        }\n@@ -216,0 +346,1 @@\n+<<<<<<< HEAD\n@@ -217,0 +348,3 @@\n+=======\n+            mh = mh.asType(mh.type().changeParameterType(prefix.size() + i, carrier));\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -218,1 +352,1 @@\n-            final int finalI = i;\n+            final int finalI = prefix.size() + i;\n@@ -231,1 +365,1 @@\n-            checks.add(o -> assertStructEquals((MemorySegment) box.get()[0], (MemorySegment) o, firstlayout));\n+            checks.add(o -> assertStructEquals((MemorySegment) box.get()[prefix.size()], (MemorySegment) o, firstlayout));\n@@ -233,1 +367,1 @@\n-            checks.add(o -> assertEquals(o, box.get()[0]));\n+            checks.add(o -> assertEquals(o, box.get()[prefix.size()]));\n@@ -238,1 +372,1 @@\n-        MemoryLayout[] paramLayouts = params.stream().map(p -> p.layout(fields)).toArray(MemoryLayout[]::new);\n+        MemoryLayout[] paramLayouts = Stream.concat(prefix.stream(), params.stream().map(p -> p.layout(fields))).toArray(MemoryLayout[]::new);\n@@ -245,1 +379,1 @@\n-    static Object passAndSave(Object[] o, AtomicReference<Object[]> ref) {\n+    static Object passAndSave(Object[] o, AtomicReference<Object[]> ref, int retArg) {\n@@ -255,1 +389,1 @@\n-        return o[0];\n+        return o[retArg];\n@@ -261,0 +395,13 @@\n+\n+    static MethodHandle reverse(MethodHandle handle) {\n+        MethodType type = handle.type();\n+        if (type.returnType().equals(MemoryAddress.class)) {\n+            type = type.changeReturnType(Addressable.class);\n+        }\n+        for (int i = 0 ; i < type.parameterCount() ; i++) {\n+            if (type.parameterType(i).equals(Addressable.class)) {\n+                type.changeParameterType(i, MemoryAddress.class);\n+            }\n+        }\n+        return handle.asType(type);\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":162,"deletions":15,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -46,0 +47,1 @@\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n@@ -63,2 +65,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -66,1 +68,3 @@\n-        checkArgumentBindings(callingSequence, new Binding[][]{});\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) }\n+        });\n@@ -85,2 +89,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -89,0 +93,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n@@ -114,2 +119,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -118,0 +123,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n@@ -135,2 +141,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -139,0 +145,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n@@ -194,2 +201,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -198,0 +205,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n@@ -224,2 +232,2 @@\n-        assertEquals(callingSequence.methodType(), MethodType.methodType(void.class, MemoryAddress.class));\n-        assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(C_POINTER));\n+        assertEquals(callingSequence.methodType(), MethodType.methodType(void.class, NativeSymbol.class, MemoryAddress.class));\n+        assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(ADDRESS, C_POINTER));\n@@ -228,0 +236,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n@@ -247,2 +256,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, MemorySegment.class, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS, ADDRESS));\n@@ -250,1 +259,4 @@\n-        checkArgumentBindings(callingSequence, new Binding[][]{});\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(MemorySegment.class), vmStore(r10, long.class) },\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) }\n+        });\n@@ -273,2 +285,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, MemorySegment.class, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS, ADDRESS));\n@@ -277,0 +289,2 @@\n+            { unboxAddress(MemorySegment.class), vmStore(r10, long.class) },\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n@@ -309,2 +323,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -313,0 +327,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n@@ -362,2 +377,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -366,0 +381,4 @@\n+<<<<<<< HEAD\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -385,0 +404,4 @@\n+<<<<<<< HEAD\n+=======\n+        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_INT).asVariadic(C_INT, C_FLOAT);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -389,0 +412,1 @@\n+<<<<<<< HEAD\n@@ -394,0 +418,8 @@\n+=======\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fdExpected);\n+\n+        \/\/ This is identical to the non-variadic calling sequence\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -406,0 +438,4 @@\n+<<<<<<< HEAD\n+=======\n+        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_INT).asVariadic(C_INT, C_FLOAT);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -410,0 +446,1 @@\n+<<<<<<< HEAD\n@@ -415,0 +452,8 @@\n+=======\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fdExpected);\n+\n+        \/\/ The two variadic arguments should be allocated on the stack\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":67,"deletions":22,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -46,0 +47,1 @@\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n@@ -62,2 +64,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -65,1 +67,3 @@\n-        checkArgumentBindings(callingSequence, new Binding[][]{});\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) }\n+        });\n@@ -77,2 +81,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -81,0 +85,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n@@ -98,2 +103,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -102,0 +107,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n@@ -121,2 +127,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -125,0 +131,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n@@ -151,2 +158,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -155,0 +162,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n@@ -181,0 +189,5 @@\n+<<<<<<< HEAD\n+=======\n+        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(\n+                ADDRESS, C_INT, C_DOUBLE).asVariadic(C_INT, C_DOUBLE, C_DOUBLE);\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n@@ -185,2 +198,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fdExpected);\n@@ -189,0 +202,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n@@ -218,2 +232,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -222,0 +236,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n@@ -247,2 +262,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -251,0 +266,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n@@ -277,2 +293,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -281,0 +297,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n@@ -297,2 +314,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -300,1 +317,3 @@\n-        checkArgumentBindings(callingSequence, new Binding[][]{});\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+        });\n@@ -319,2 +338,2 @@\n-        assertEquals(callingSequence.methodType(), MethodType.methodType(void.class, MemoryAddress.class));\n-        assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(C_POINTER));\n+        assertEquals(callingSequence.methodType(), MethodType.methodType(void.class, NativeSymbol.class, MemoryAddress.class));\n+        assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(ADDRESS, C_POINTER));\n@@ -323,0 +342,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n@@ -347,2 +367,2 @@\n-        assertEquals(callingSequence.methodType(), mt);\n-        assertEquals(callingSequence.functionDesc(), fd);\n+        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n@@ -351,0 +371,4 @@\n+<<<<<<< HEAD\n+=======\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":50,"deletions":26,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+<<<<<<< HEAD\n@@ -64,0 +65,5 @@\n+=======\n+                    { MethodHandles.lookup().findStatic(MemorySegment.class, \"ofAddressNative\",\n+                            MethodType.methodType(MemorySegment.class, MemoryAddress.class, long.class, ResourceScope.class)),\n+                            \"MemorySegment::ofAddressNative\" },\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+<<<<<<< HEAD\n@@ -42,0 +43,2 @@\n+=======\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/jdk\/java\/foreign\/libSafeAccess.c","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+<<<<<<< HEAD\n@@ -61,0 +62,3 @@\n+=======\n+        MemorySegment seg = MemorySegment.ofAddressNative(ma, 4L, ResourceScope.newImplicitScope());\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/jdk\/java\/foreign\/malloc\/TestMixedMallocFree.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -745,0 +745,1 @@\n+<<<<<<< HEAD\n@@ -746,0 +747,3 @@\n+=======\n+                    MemorySegment ms = MemorySegment.ofAddressNative(intPtr, C_INT.byteSize(), ResourceScope.globalScope());\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -128,0 +128,1 @@\n+<<<<<<< HEAD\n@@ -129,0 +130,3 @@\n+=======\n+        MemorySegment str = MemorySegment.ofAddressNative(address, len + 1, ResourceScope.globalScope());\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+<<<<<<< HEAD\n@@ -71,0 +72,4 @@\n+=======\n+            this.inputSegment = MemorySegment.ofAddressNative(MemoryAddress.ofLong(inputAddress), 8*SIZE, ResourceScope.globalScope());\n+            this.outputSegment = MemorySegment.ofAddressNative(MemoryAddress.ofLong(outputAddress), 8*SIZE, ResourceScope.globalScope());\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/UnrolledAccess.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -127,0 +127,1 @@\n+<<<<<<< HEAD\n@@ -128,0 +129,3 @@\n+=======\n+                baseDesc.appendArgumentLayouts(C_POINTER)\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/Upcalls.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -243,0 +243,1 @@\n+<<<<<<< HEAD\n@@ -245,0 +246,4 @@\n+=======\n+      final var srcBufferSegmentConfined = MemorySegment.ofAddressNative(srcAddress, size, scope).asByteBuffer();\n+      final var dstBufferSegmentConfined = MemorySegment.ofAddressNative(dstAddress, size, scope).asByteBuffer();\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -213,0 +213,1 @@\n+<<<<<<< HEAD\n@@ -215,0 +216,4 @@\n+=======\n+      final var srcBufferSegmentConfined = MemorySegment.ofAddressNative(srcAddress, size, scope).asByteBuffer();\n+      final var dstBufferSegmentConfined = MemorySegment.ofAddressNative(dstAddress, size, scope).asByteBuffer();\n+>>>>>>> 77dbcdb8991711f3a660bad16b5355a801779a81\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShort.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}