{"files":[{"patch":"@@ -357,0 +357,1 @@\n+<<<<<<< HEAD\n@@ -358,0 +359,2 @@\n+=======\n+>>>>>>> 5b860a41139a8f7a595e87077918d722fead630c\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+<<<<<<< HEAD\n@@ -64,0 +65,4 @@\n+=======\n+    thread = Thread::current();\n+    assert(!JavaThread::cast(thread)->has_last_Java_frame(), \"newly-attached thread not expected to have last Java frame\");\n+>>>>>>> 5b860a41139a8f7a595e87077918d722fead630c\n@@ -76,0 +81,1 @@\n+<<<<<<< HEAD\n@@ -78,0 +84,4 @@\n+=======\n+Thread* ProgrammableUpcallHandler::on_entry(OptimizedEntryBlob::FrameData* context) {\n+  JavaThread* thread = JavaThread::cast(maybe_attach_and_get_thread(&context->should_detach));\n+>>>>>>> 5b860a41139a8f7a595e87077918d722fead630c\n@@ -86,0 +96,1 @@\n+<<<<<<< HEAD\n@@ -87,0 +98,3 @@\n+=======\n+  \/\/ After this, we are official in Java Code. This needs to be done before we change any of the thread local\n+>>>>>>> 5b860a41139a8f7a595e87077918d722fead630c\n@@ -92,0 +106,1 @@\n+<<<<<<< HEAD\n@@ -93,0 +108,3 @@\n+=======\n+  \/\/ to prepare for stop\/suspend (flush register windows on sparcs, cache sp, or other state).\n+>>>>>>> 5b860a41139a8f7a595e87077918d722fead630c\n@@ -114,0 +132,1 @@\n+<<<<<<< HEAD\n@@ -116,0 +135,6 @@\n+=======\n+  assert (thread->thread_state() != _thread_in_native, \"cannot set native pc to NULL\");\n+\n+  \/\/ clear any pending exception in thread (native calls start with no exception pending)\n+  if(clear_pending_exception) {\n+>>>>>>> 5b860a41139a8f7a595e87077918d722fead630c\n@@ -138,0 +163,1 @@\n+<<<<<<< HEAD\n@@ -141,0 +167,11 @@\n+=======\n+  \/\/ Old thread-local info. has been restored. We are not back in native code.\n+  ThreadStateTransition::transition_from_java(thread, _thread_in_native);\n+\n+  \/\/ State has been restored now make the anchor frame visible for the profiler.\n+  \/\/ Do this after the transition because this allows us to put an assert\n+  \/\/ the Java->native transition which checks to see that stack is not walkable\n+  \/\/ on sparc\/ia64 which will catch violations of the reseting of last_Java_frame\n+  \/\/ invariants (i.e. _flags always cleared on return to Java)\n+\n+>>>>>>> 5b860a41139a8f7a595e87077918d722fead630c\n@@ -150,0 +187,1 @@\n+<<<<<<< HEAD\n@@ -151,0 +189,3 @@\n+=======\n+    detach_thread(thread);\n+>>>>>>> 5b860a41139a8f7a595e87077918d722fead630c\n@@ -190,0 +231,1 @@\n+  ResourceMark rm;\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.cpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+<<<<<<< HEAD\n@@ -55,0 +56,6 @@\n+=======\n+  static Thread* maybe_attach_and_get_thread(bool* should_detach);\n+  static void detach_thread(Thread* thread);\n+\n+  static Thread* on_entry(OptimizedEntryBlob::FrameData* context);\n+>>>>>>> 5b860a41139a8f7a595e87077918d722fead630c\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+<<<<<<< HEAD\n@@ -39,0 +40,2 @@\n+=======\n+>>>>>>> 5b860a41139a8f7a595e87077918d722fead630c\n","filename":"src\/hotspot\/share\/runtime\/javaFrameAnchor.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1936,0 +1936,1 @@\n+<<<<<<< HEAD\n@@ -1938,0 +1939,4 @@\n+=======\n+         \"unexpected frame info: has_last_frame=%d, java_call_counter=%d\",\n+         has_last_Java_frame(), java_call_counter());\n+>>>>>>> 5b860a41139a8f7a595e87077918d722fead630c\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}