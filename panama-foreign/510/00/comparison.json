{"files":[{"patch":"@@ -42,1 +42,1 @@\n- * <h2>Explicit closure<\/h2>\n+ * <h2>Explicit resource scopes<\/h2>\n@@ -44,1 +44,2 @@\n- * Resource scopes created using one of the factories in this class can be closed explicitly (see {@link ResourceScope#close()}).\n+ * Resource scopes obtained from {@link #newConfinedScope()}, {@link #newSharedScope()} support <em>deterministic deallocation<\/em>;\n+ * We call these resource scopes <em>explicit scopes<\/em>. Explicit resource scopes can be closed explicitly (see {@link ResourceScope#close()}).\n@@ -46,1 +47,1 @@\n- * resources derived from that scope (e.g. attempting to access a {@link MemorySegment} instance) will fail with {@link IllegalStateException}.\n+ * resources associated with that scope (e.g. attempting to access a {@link MemorySegment} instance) will fail with {@link IllegalStateException}.\n@@ -58,0 +59,9 @@\n+ * <p>\n+ * Sometimes, explicit scopes can be associated with a {@link Cleaner} instance (see {@link #newConfinedScope(Cleaner)} and\n+ * {@link #newSharedScope(Cleaner)}). We call these resource scopes <em>managed<\/em> resource scopes. A managed resource scope\n+ * is closed automatically once the scope instance becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n+ * <p>\n+ * Managed scopes can be useful to allow for predictable, deterministic resource deallocation, while still prevent accidental native memory leaks.\n+ * In case a managed resource scope is closed explicitly, no further action will be taken when the scope becomes unreachable;\n+ * that is, cleanup actions (see {@link #addOnClose(Runnable)}) associated with a resource scope, whether managed or not,\n+ * are called <em>exactly once<\/em>.\n@@ -59,1 +69,1 @@\n- * <h2><a id = \"implicit-closure\">Implicit closure<\/a><\/h2>\n+ * <h2>Implicit resource scopes<\/h2>\n@@ -61,8 +71,4 @@\n- * Resource scopes can be associated with a {@link Cleaner} instance (see {@link #newConfinedScope(Cleaner)}) - we call these\n- * resource scopes <em>managed<\/em> resource scopes. A managed resource scope is closed automatically once the scope instance\n- * becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n- * <p>\n- * Managed resource scopes can still be closed explicitly (see {@link #close()}); this can be useful to allow for predictable,\n- * deterministic resource deallocation, while still prevent accidental native memory leaks. In case a managed resource\n- * scope is closed explicitly, no further action will be taken when the scope becomes unreachable; that is, cleanup actions\n- * (see {@link #addOnClose(Runnable)}) associated with a resource scope, whether managed or not, are called <em>exactly once<\/em>.\n+ * Resource scopes obtained from {@link #newImplicitScope()} cannot be closed explicitly. We call these resource scopes\n+ * <em>implicit scopes<\/em>. Calling {@link #close()} on an implicit resource scope always results in an exception.\n+ * Resources associated with implicit scopes are released once the scope instance becomes\n+ * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n@@ -70,3 +76,3 @@\n- * Some managed resource scopes are implicitly managed (see {@link #newImplicitScope()}, {@link #globalScope()}, and are said to be <em>implicit scopes<\/em>.\n- * An implicit resource scope only features implicit closure, and always throws an {@link UnsupportedOperationException}\n- * when the {@link #close()} method is called directly.\n+ * An important implicit resource scope is the so called {@link #globalScope() global scope}; the global scope is\n+ * an implicit scope that is guaranteed to never become <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n+ * As a results, resources associated to the global scope are never cleaned up.\n@@ -85,5 +91,6 @@\n- * Shared resource scopes (see {@link #newSharedScope()}), on the other hand, have no owner thread; as such resources associated\n- * with this shared resource scopes can be accessed by multiple threads. This might be useful when multiple threads need\n- * to access the same resource concurrently (e.g. in the case of parallel processing). For instance, a client\n- * might obtain a {@link Spliterator} from a shared segment, which can then be used to slice the segment and allow multiple\n- * threads to work in parallel on disjoint segment slices. The following code can be used to sum all int values in a memory segment in parallel:\n+ * Shared resource scopes (see {@link #newSharedScope()} and {@link #newImplicitScope()}), on the other hand, have no owner thread;\n+ * as such resources associated with this shared resource scopes can be accessed by multiple threads.\n+ * This might be useful when multiple threads need to access the same resource concurrently (e.g. in the case of parallel processing).\n+ * For instance, a client might obtain a {@link Spliterator} from a shared segment, which can then be used to slice the\n+ * segment and allow multiple threads to work in parallel on disjoint segment slices. The following code can be used to sum\n+ * all int values in a memory segment in parallel:\n@@ -113,4 +120,4 @@\n- * {@link #acquire()}. A resource scope handle can be used to make sure that its corresponding scope cannot be closed\n- * (either explicitly, or implicitly) for a certain period of time - e.g. when one or more resources associated with\n- * the parent scope need to be accessed. A resource scope can be acquired multiple times; the resource scope can only be\n- * closed <em>after<\/em> all the handles acquired against that scope have been closed (see {@link Handle#close()}).\n+ * {@link #acquire()}. A resource scope handle can be used to make sure that resources associated with a given resource scope\n+ * (either explicit or implicit) cannot be released for a certain period of time - e.g. during a critical region of code\n+ * involving one or more resources associated with the scope. For instance, an explicit resource scope can only be closed\n+ * <em>after<\/em> all the handles acquired against that scope have been closed (see {@link Handle#close()}).\n@@ -186,3 +193,2 @@\n-     * to its resource scope; this means that if a resource scope features\n-     * <a href=\"ResourceScope.html#implicit-closure\"><em>implicit closure<\/em><\/a>, the scope cannot be implicitly closed\n-     * until all its acquired handles becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n+     * to its resource scope; in other words, resources associated with an implicit resource scopes cannot be released\n+     * until <em>all<\/em> the handles acquired from the implicit scope become <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n@@ -247,5 +253,3 @@\n-     * Create a new <em>implicit scope<\/em>. The implicit scope is a managed, shared, and non-closeable scope which only features\n-     * <a href=\"ResourceScope.html#implicit-closure\"><em>implicit closure<\/em><\/a>.\n-     * Since implicit scopes can only be closed implicitly by the garbage collector, it is recommended that implicit\n-     * scopes are only used in cases where deallocation performance is not a critical concern, to avoid unnecessary\n-     * memory pressure.\n+     * Create a new implicit, shared resource scope. Since implicit scopes can only be closed implicitly by the garbage collector,\n+     * it is recommended that implicit scopes are only used in cases where deallocation performance is not a critical concern,\n+     * to avoid unnecessary memory pressure.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ResourceScope.java","additions":36,"deletions":32,"binary":false,"changes":68,"status":"modified"}]}