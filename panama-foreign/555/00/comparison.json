{"files":[{"patch":"@@ -354,0 +354,1 @@\n+  template(jdk_incubator_foreign_MemoryCopy,         \"jdk\/incubator\/foreign\/MemoryCopy\")          \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1594,0 +1594,5 @@\n+    if (inv.klass() == vmSymbols::jdk_incubator_foreign_MemoryCopy()) {\n+      if (inv.name()->starts_with(\"copy\")) {\n+        return true;\n+      }\n+    }\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,574 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+package jdk.incubator.foreign;\n+\n+import java.nio.ByteOrder;\n+import java.util.Objects;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * This class provides convenient methods for copying data between primitive arrays and memory segments.\n+ *\n+ * <p>If the source (destination) segment is actually a view of the destination (source) array,\n+ * and if the copy region of the source overlaps with the copy region of the destination,\n+ * the copy of the overlapping region is performed as if the data in the overlapping region\n+ * were first copied into a temporary segment before being copied to the destination.<\/p>\n+ *\n+ * <p>\n+ * Copy operations defined in this class accept a <em>byte order<\/em> parameter. If the specified byte order is different\n+ * from the <em>native<\/em> byte order, a byte swap operation is performed on each array elements\n+ * as they are copied from the source (destination) segment to the destination (source) array.\n+ * Additional overloads are provided (see {@link #copyFromArray(double[], int, int, MemorySegment, long)}),\n+ * so that clients can omit the byte order parameter.\n+ *\n+ * <p>Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more\n+ * {@code null} elements to a method in this class causes a {@link NullPointerException NullPointerException}\n+ * to be thrown.<\/p>\n+ *\/\n+public final class MemoryCopy {\n+    private static final ByteOrder NATIVE_ORDER = ByteOrder.nativeOrder();\n+    private static final ByteOrder NON_NATIVE_ORDER = NATIVE_ORDER == ByteOrder.LITTLE_ENDIAN\n+            ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;\n+    private static final ValueLayout ARR_LAYOUT_16_N = MemoryLayout.valueLayout(16, NATIVE_ORDER);\n+    private static final ValueLayout ARR_LAYOUT_16_NN = MemoryLayout.valueLayout(16, NON_NATIVE_ORDER);\n+    private static final ValueLayout ARR_LAYOUT_32_N = MemoryLayout.valueLayout(32, NATIVE_ORDER);\n+    private static final ValueLayout ARR_LAYOUT_32_NN = MemoryLayout.valueLayout(32, NON_NATIVE_ORDER);\n+    private static final ValueLayout ARR_LAYOUT_64_N = MemoryLayout.valueLayout(64, NATIVE_ORDER);\n+    private static final ValueLayout ARR_LAYOUT_64_NN = MemoryLayout.valueLayout(64, NON_NATIVE_ORDER);\n+\n+    private MemoryCopy() { \/* singleton *\/ }\n+\n+    \/\/BYTE\n+    \/**\n+     * Copies a number of byte elements from a source byte array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source byte array.\n+     * @param srcIndexBytes the starting index of the source byte array.\n+     * @param srcCopyLengthBytes the number of byte elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            byte[] srcArray, int srcIndexBytes, int srcCopyLengthBytes,\n+            MemorySegment dstSegment, long dstOffsetBytes) {\n+        Objects.requireNonNull(dstSegment);\n+        MemorySegment srcSegmentSlice = MemorySegment.ofArray(srcArray).asSlice(srcIndexBytes, srcCopyLengthBytes);\n+        MemorySegment dstSegmentSlice = dstSegment.asSlice(dstOffsetBytes, srcCopyLengthBytes);\n+        dstSegmentSlice.copyFrom(srcSegmentSlice);\n+    }\n+\n+    \/**\n+     * Copies a number of byte elements from a source segment to a destination byte array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination byte array.\n+     * @param dstIndexBytes the starting index of the destination byte array.\n+     * @param dstCopyLengthBytes the number of byte elements to be copied.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            byte[] dstArray, int dstIndexBytes, int dstCopyLengthBytes) {\n+        Objects.requireNonNull(srcSegment);\n+        MemorySegment srcSegmentSlice = srcSegment.asSlice(srcOffsetBytes, dstCopyLengthBytes);\n+        MemorySegment dstSegmentSlice = MemorySegment.ofArray(dstArray).asSlice(dstIndexBytes, dstCopyLengthBytes);\n+        dstSegmentSlice.copyFrom(srcSegmentSlice);\n+    }\n+\n+    \/\/CHAR\n+    \/**\n+     * Copies a number of char elements from a source char array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source char array.\n+     * @param srcIndexChars the starting index of the source char array.\n+     * @param srcCopyLengthChars the number of char elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            char[] srcArray, int srcIndexChars, int srcCopyLengthChars,\n+            MemorySegment dstSegment, long dstOffsetBytes) {\n+        copyFromArray(srcArray, srcIndexChars, srcCopyLengthChars, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of char elements from a source char array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source char array.\n+     * @param srcIndexChars the starting index of the source char array.\n+     * @param srcCopyLengthChars the number of char elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            char[] srcArray, int srcIndexChars, int srcCopyLengthChars,\n+            MemorySegment dstSegment, long dstOffsetBytes,\n+            ByteOrder order) {\n+        Objects.requireNonNull(dstSegment);\n+        MemorySegment srcSegmentSlice =\n+                MemorySegment.ofArray(srcArray).asSlice(srcIndexChars * 2L, srcCopyLengthChars * 2L);\n+        MemorySegment dstSegmentSlice = dstSegment.asSlice(dstOffsetBytes, srcCopyLengthChars * 2L);\n+        dstSegmentSlice.copyFrom(order == NATIVE_ORDER ? ARR_LAYOUT_16_N : ARR_LAYOUT_16_NN, srcSegmentSlice, ARR_LAYOUT_16_N);\n+    }\n+\n+    \/**\n+     * Copies a number of char elements from a source segment to a destination char array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination char array.\n+     * @param dstIndexChars the starting index of the destination char array.\n+     * @param dstCopyLengthChars the number of char elements to be copied.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            char[] dstArray, int dstIndexChars, int dstCopyLengthChars) {\n+        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexChars, dstCopyLengthChars, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of char elements from a source segment to a destination char array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination char array.\n+     * @param dstIndexChars the starting index of the destination char array.\n+     * @param dstCopyLengthChars the number of char elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            char[] dstArray, int dstIndexChars, int dstCopyLengthChars,\n+            ByteOrder order) {\n+        Objects.requireNonNull(srcSegment);\n+        MemorySegment srcSegmentSlice = srcSegment.asSlice(srcOffsetBytes, dstCopyLengthChars * 2L);\n+        MemorySegment dstSegmentSlice =\n+                MemorySegment.ofArray(dstArray).asSlice(dstIndexChars * 2L, dstCopyLengthChars * 2L);\n+        dstSegmentSlice.copyFrom(ARR_LAYOUT_16_N, srcSegmentSlice, order == NATIVE_ORDER ? ARR_LAYOUT_16_N : ARR_LAYOUT_16_NN);\n+    }\n+\n+    \/\/SHORT\n+    \/**\n+     * Copies a number of short elements from a source short array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source short array.\n+     * @param srcIndexShorts the starting index of the source short array.\n+     * @param srcCopyLengthShorts the number of short elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            short[] srcArray, int srcIndexShorts, int srcCopyLengthShorts,\n+            MemorySegment dstSegment, long dstOffsetBytes) {\n+        copyFromArray(srcArray, srcIndexShorts, srcCopyLengthShorts, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of short elements from a source short array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source short array.\n+     * @param srcIndexShorts the starting index of the source short array.\n+     * @param srcCopyLengthShorts the number of short elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            short[] srcArray, int srcIndexShorts, int srcCopyLengthShorts,\n+            MemorySegment dstSegment, long dstOffsetBytes,\n+            ByteOrder order) {\n+        Objects.requireNonNull(dstSegment);\n+        MemorySegment srcSegmentSlice =\n+                MemorySegment.ofArray(srcArray).asSlice(srcIndexShorts * 2L, srcCopyLengthShorts * 2L);\n+        MemorySegment dstSegmentSlice = dstSegment.asSlice(dstOffsetBytes, srcCopyLengthShorts * 2L);\n+        dstSegmentSlice.copyFrom(order == NATIVE_ORDER ? ARR_LAYOUT_16_N : ARR_LAYOUT_16_NN, srcSegmentSlice, ARR_LAYOUT_16_N);\n+    }\n+\n+    \/**\n+     * Copies a number of short elements from a source segment to a destination short array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination short array.\n+     * @param dstIndexShorts the starting index of the destination short array.\n+     * @param dstCopyLengthShorts the number of short elements to be copied.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            short[] dstArray, int dstIndexShorts, int dstCopyLengthShorts) {\n+        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexShorts, dstCopyLengthShorts, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of short elements from a source segment to a destination short array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination short array.\n+     * @param dstIndexShorts the starting index of the destination short array.\n+     * @param dstCopyLengthShorts the number of short elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            short[] dstArray, int dstIndexShorts, int dstCopyLengthShorts,\n+            ByteOrder order) {\n+        Objects.requireNonNull(srcSegment);\n+        MemorySegment srcSegmentSlice = srcSegment.asSlice(srcOffsetBytes, dstCopyLengthShorts * 2L);\n+        MemorySegment dstSegmentSlice =\n+                MemorySegment.ofArray(dstArray).asSlice(dstIndexShorts * 2L, dstCopyLengthShorts * 2L);\n+        dstSegmentSlice.copyFrom(ARR_LAYOUT_16_N, srcSegmentSlice, order == NATIVE_ORDER ? ARR_LAYOUT_16_N : ARR_LAYOUT_16_NN);\n+    }\n+\n+    \/\/INT\n+    \/**\n+     * Copies a number of int elements from a source int array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source int array.\n+     * @param srcIndexInts the starting index of the source int array.\n+     * @param srcCopyLengthInts the number of int elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            int[] srcArray, int srcIndexInts, int srcCopyLengthInts,\n+            MemorySegment dstSegment, long dstOffsetBytes) {\n+        copyFromArray(srcArray, srcIndexInts, srcCopyLengthInts, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of int elements from a source int array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source int array.\n+     * @param srcIndexInts the starting index of the source int array.\n+     * @param srcCopyLengthInts the number of int elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            int[] srcArray, int srcIndexInts, int srcCopyLengthInts,\n+            MemorySegment dstSegment, long dstOffsetBytes,\n+            ByteOrder order) {\n+        Objects.requireNonNull(dstSegment);\n+        MemorySegment srcSegmentSlice =\n+                MemorySegment.ofArray(srcArray).asSlice(srcIndexInts * 4L, srcCopyLengthInts * 4L);\n+        MemorySegment dstSegmentSlice = dstSegment.asSlice(dstOffsetBytes, srcCopyLengthInts * 4L);\n+        dstSegmentSlice.copyFrom(order == NATIVE_ORDER ? ARR_LAYOUT_32_N : ARR_LAYOUT_32_NN, srcSegmentSlice, ARR_LAYOUT_32_N);\n+    }\n+\n+    \/**\n+     * Copies a number of int elements from a source segment to a destination int array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination int array.\n+     * @param dstIndexInts the starting index of the destination int array.\n+     * @param dstCopyLengthInts the number of int elements to be copied.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            int[] dstArray, int dstIndexInts, int dstCopyLengthInts) {\n+        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexInts, dstCopyLengthInts, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of int elements from a source segment to a destination int array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination int array.\n+     * @param dstIndexInts the starting index of the destination int array.\n+     * @param dstCopyLengthInts the number of int elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            int[] dstArray, int dstIndexInts, int dstCopyLengthInts,\n+            ByteOrder order) {\n+        Objects.requireNonNull(srcSegment);\n+        MemorySegment srcSegmentSlice = srcSegment.asSlice(srcOffsetBytes, dstCopyLengthInts * 4L);\n+        MemorySegment dstSegmentSlice =\n+                MemorySegment.ofArray(dstArray).asSlice(dstIndexInts * 4L, dstCopyLengthInts * 4L);\n+        dstSegmentSlice.copyFrom(ARR_LAYOUT_32_N, srcSegmentSlice, order == NATIVE_ORDER ? ARR_LAYOUT_32_N : ARR_LAYOUT_32_NN);\n+    }\n+\n+    \/\/FLOAT\n+    \/**\n+     * Copies a number of float elements from a source float array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source float array.\n+     * @param srcIndexFloats the starting index of the source float array.\n+     * @param srcCopyLengthFloats the number of float elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            float[] srcArray, int srcIndexFloats, int srcCopyLengthFloats,\n+            MemorySegment dstSegment, long dstOffsetBytes) {\n+        copyFromArray(srcArray, srcIndexFloats, srcCopyLengthFloats, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of float elements from a source float array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source float array.\n+     * @param srcIndexFloats the starting index of the source float array.\n+     * @param srcCopyLengthFloats the number of float elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            float[] srcArray, int srcIndexFloats, int srcCopyLengthFloats,\n+            MemorySegment dstSegment, long dstOffsetBytes,\n+            ByteOrder order) {\n+        Objects.requireNonNull(dstSegment);\n+        MemorySegment srcSegmentSlice =\n+                MemorySegment.ofArray(srcArray).asSlice(srcIndexFloats * 4L, srcCopyLengthFloats * 4L);\n+        MemorySegment dstSegmentSlice = dstSegment.asSlice(dstOffsetBytes, srcCopyLengthFloats * 4L);\n+        dstSegmentSlice.copyFrom(order == NATIVE_ORDER ? ARR_LAYOUT_32_N : ARR_LAYOUT_32_NN, srcSegmentSlice, ARR_LAYOUT_32_N);\n+    }\n+\n+    \/**\n+     * Copies a number of float elements from a source segment to a destination float array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination float array.\n+     * @param dstIndexFloats the starting index of the destination float array.\n+     * @param dstCopyLengthFloats the number of float elements to be copied.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            float[] dstArray, int dstIndexFloats, int dstCopyLengthFloats) {\n+        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexFloats, dstCopyLengthFloats, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of float elements from a source segment to a destination float array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination float array.\n+     * @param dstIndexFloats the starting index of the destination float array.\n+     * @param dstCopyLengthFloats the number of float elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a float swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            float[] dstArray, int dstIndexFloats, int dstCopyLengthFloats,\n+            ByteOrder order) {\n+        Objects.requireNonNull(srcSegment);\n+        MemorySegment srcSegmentSlice = srcSegment.asSlice(srcOffsetBytes, dstCopyLengthFloats * 4L);\n+        MemorySegment dstSegmentSlice =\n+                MemorySegment.ofArray(dstArray).asSlice(dstIndexFloats * 4L, dstCopyLengthFloats * 4L);\n+        dstSegmentSlice.copyFrom(ARR_LAYOUT_32_N, srcSegmentSlice, order == NATIVE_ORDER ? ARR_LAYOUT_32_N : ARR_LAYOUT_32_NN);\n+    }\n+\n+    \/\/LONG\n+    \/**\n+     * Copies a number of long elements from a source long array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source long array.\n+     * @param srcIndexLongs the starting index of the source long array.\n+     * @param srcCopyLengthLongs the number of long elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            long[] srcArray, int srcIndexLongs, int srcCopyLengthLongs,\n+            MemorySegment dstSegment, long dstOffsetBytes) {\n+        copyFromArray(srcArray, srcIndexLongs, srcCopyLengthLongs, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of long elements from a source long array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source long array.\n+     * @param srcIndexLongs the starting index of the source long array.\n+     * @param srcCopyLengthLongs the number of long elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            long[] srcArray, int srcIndexLongs, int srcCopyLengthLongs,\n+            MemorySegment dstSegment, long dstOffsetBytes,\n+            ByteOrder order) {\n+        Objects.requireNonNull(dstSegment);\n+        MemorySegment srcSegmentSlice =\n+                MemorySegment.ofArray(srcArray).asSlice(srcIndexLongs * 8L, srcCopyLengthLongs * 8L);\n+        MemorySegment dstSegmentSlice = dstSegment.asSlice(dstOffsetBytes, srcCopyLengthLongs * 8L);\n+        dstSegmentSlice.copyFrom(order == NATIVE_ORDER ? ARR_LAYOUT_64_N : ARR_LAYOUT_64_NN, srcSegmentSlice, ARR_LAYOUT_64_N);\n+    }\n+\n+    \/**\n+     * Copies a number of long elements from a source segment to a destination long array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination long array.\n+     * @param dstIndexLongs the starting index of the destination long array.\n+     * @param dstCopyLengthLongs the number of long elements to be copied.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            long[] dstArray, int dstIndexLongs, int dstCopyLengthLongs) {\n+        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexLongs, dstCopyLengthLongs, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of long elements from a source segment to a destination long array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination long array.\n+     * @param dstIndexLongs the starting index of the destination long array.\n+     * @param dstCopyLengthLongs the number of long elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            long[] dstArray, int dstIndexLongs, int dstCopyLengthLongs,\n+            ByteOrder order) {\n+        Objects.requireNonNull(srcSegment);\n+        MemorySegment srcSegmentSlice = srcSegment.asSlice(srcOffsetBytes, dstCopyLengthLongs * 8L);\n+        MemorySegment dstSegmentSlice =\n+                MemorySegment.ofArray(dstArray).asSlice(dstIndexLongs * 8L, dstCopyLengthLongs * 8L);\n+        dstSegmentSlice.copyFrom(ARR_LAYOUT_64_N, srcSegmentSlice, order == NATIVE_ORDER ? ARR_LAYOUT_64_N : ARR_LAYOUT_64_NN);\n+    }\n+\n+    \/\/DOUBLE\n+    \/**\n+     * Copies a number of double elements from a source double array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source double array.\n+     * @param srcIndexDoubles the starting index of the source double array.\n+     * @param srcCopyLengthDoubles the number of double elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            double[] srcArray, int srcIndexDoubles, int srcCopyLengthDoubles,\n+            MemorySegment dstSegment, long dstOffsetBytes) {\n+        copyFromArray(srcArray, srcIndexDoubles, srcCopyLengthDoubles, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of double elements from a source double array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source double array.\n+     * @param srcIndexDoubles the starting index of the source double array.\n+     * @param srcCopyLengthDoubles the number of double elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            double[] srcArray, int srcIndexDoubles, int srcCopyLengthDoubles,\n+            MemorySegment dstSegment, long dstOffsetBytes,\n+            ByteOrder order) {\n+        Objects.requireNonNull(dstSegment);\n+        MemorySegment srcSegmentSlice =\n+                MemorySegment.ofArray(srcArray).asSlice(srcIndexDoubles * 8L, srcCopyLengthDoubles * 8L);\n+        MemorySegment dstSegmentSlice = dstSegment.asSlice(dstOffsetBytes, srcCopyLengthDoubles * 8L);\n+        dstSegmentSlice.copyFrom(order == NATIVE_ORDER ? ARR_LAYOUT_64_N : ARR_LAYOUT_64_NN, srcSegmentSlice, ARR_LAYOUT_64_N);\n+    }\n+\n+    \/**\n+     * Copies a number of double elements from a source segment to a destination double array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination double array.\n+     * @param dstIndexDoubles the starting index of the destination double array.\n+     * @param dstCopyLengthDoubles the number of double elements to be copied.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            double[] dstArray, int dstIndexDoubles, int dstCopyLengthDoubles) {\n+        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexDoubles, dstCopyLengthDoubles, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of double elements from a source segment to a destination double array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination double array.\n+     * @param dstIndexDoubles the starting index of the destination double array.\n+     * @param dstCopyLengthDoubles the number of double elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            double[] dstArray, int dstIndexDoubles, int dstCopyLengthDoubles,\n+            ByteOrder order) {\n+        Objects.requireNonNull(srcSegment);\n+        MemorySegment srcSegmentSlice = srcSegment.asSlice(srcOffsetBytes, dstCopyLengthDoubles * 8L);\n+        MemorySegment dstSegmentSlice =\n+                MemorySegment.ofArray(dstArray).asSlice(dstIndexDoubles * 8L, dstCopyLengthDoubles * 8L);\n+        dstSegmentSlice.copyFrom(ARR_LAYOUT_64_N, srcSegmentSlice, order == NATIVE_ORDER ? ARR_LAYOUT_64_N : ARR_LAYOUT_64_NN);\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryCopy.java","additions":574,"deletions":0,"binary":false,"changes":574,"status":"added"},{"patch":"@@ -41,0 +41,1 @@\n+import java.nio.ByteOrder;\n@@ -376,0 +377,40 @@\n+    \/**\n+     * Performs an element-wise bulk copy from given source segment to this segment. More specifically, the bytes at\n+     * offset {@code 0} through {@code src.byteSize() - 1} in the source segment are copied into this segment\n+     * at offset {@code 0} through {@code src.byteSize() - 1}.\n+     * <p>\n+     * The copy occurs in an element-wise fashion: the source bytes are interpreted as a sequence of elements\n+     * whose layout is {@code srcElementLayout}, whereas the bytes in this segment are interpreted as a sequence of\n+     * elements whose layout is {@code dstElementLayout}. Both element layouts must have same size {@code S} and\n+     * alignment {@code A}, and the size of the source segment must be a multiple of {@code S} for the copy operation\n+     * to be correctly specified. If the byte order of the two element layouts differ, the bytes corresponding to each\n+     * element to be copied are swapped accordingly during the copy operation.\n+     * <p>\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code 0} through {@code src.byteSize() - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * this segment at offset {@code 0} through {@code src.byteSize() - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     *\n+     * @implSpec\n+     * If {@code srcElementLayout.byteSize() == 1}, or if {@code srcElementLayout.order() == dstElementLayout.order()}, calling\n+     * this method must be equivalent to calling {@link #copyFrom(MemorySegment)} with the same source segment.\n+     *\n+     * @param dstElementLayout the element layout associated with this segment.\n+     * @param src the source segment.\n+     * @param srcElementLayout the element layout associated with the source segment.\n+     * @throws IndexOutOfBoundsException if {@code src.byteSize() > this.byteSize()}.\n+     * @throws IllegalArgumentException if the element layouts have different sizes, if the source segment size is not\n+     * a multiple of the source element layout size, if the source segment is incompatible with the alignment constraints\n+     * in the source element layout, or if this segment is incompatible with the alignment constraints\n+     * in the destination element layout.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with this segment have been already closed, or if access occurs from a thread other than the thread owning either\n+     * scopes.\n+     * @throws UnsupportedOperationException if this segment is read-only (see {@link #isReadOnly()}).\n+     *\/\n+    void copyFrom(ValueLayout dstElementLayout, MemorySegment src, ValueLayout srcElementLayout);\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.foreign.AbstractMemorySegmentImpl;\n@@ -318,5 +317,1 @@\n-        if (elementLayout.byteSize() == 1 || (elementLayout.order() == ByteOrder.nativeOrder())) {\n-            addr.copyFrom(heapSegmentFactory.apply(array));\n-        } else {\n-            ((AbstractMemorySegmentImpl)addr).copyFromSwap(heapSegmentFactory.apply(array), elementLayout.byteSize());\n-        }\n+        addr.copyFrom(elementLayout, heapSegmentFactory.apply(array), elementLayout.withOrder(ByteOrder.nativeOrder()));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -153,8 +153,24 @@\n-    public void copyFromSwap(MemorySegment src, long elemSize) {\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;\n-        long size = that.byteSize();\n-        checkAccess(0, size, false);\n-        that.checkAccess(0, size, true);\n-        SCOPED_MEMORY_ACCESS.copySwapMemory(scope, that.scope,\n-                        that.base(), that.min(),\n-                        base(), min(), size, elemSize);\n+    public void copyFrom(ValueLayout dstElementLayout, MemorySegment src, ValueLayout srcElementLayout) {\n+        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n+            throw new IllegalArgumentException(\"Source and destination layouts must have same sizes\");\n+        }\n+        if (((AbstractMemorySegmentImpl)src).min() % srcElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n+        }\n+        if (min() % dstElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Target segment incompatible with alignment constraints\");\n+        }\n+        long size = src.byteSize();\n+        if (size % srcElementLayout.byteSize() != 0) {\n+            throw new IllegalArgumentException(\"Segment size is not a multiple of layout size\");\n+        }\n+        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n+            copyFrom(src);\n+        } else {\n+            AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl) src;\n+            checkAccess(0, size, false);\n+            that.checkAccess(0, size, true);\n+            SCOPED_MEMORY_ACCESS.copySwapMemory(scope, that.scope,\n+                    that.base(), that.min(),\n+                    base(), min(), size, srcElementLayout.byteSize());\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestCopyFrom\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryLayouts;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.IntFunction;\n+\n+import static org.testng.Assert.*;\n+\n+public class TestCopyFrom {\n+\n+    @Test(dataProvider = \"slices\")\n+    public void testByteCopy(SegmentSlice s1, SegmentSlice s2) {\n+        int size = Math.min(s1.byteSize(), s2.byteSize());\n+        \/\/prepare source and target segments\n+        for (int i = 0 ; i < size ; i++) {\n+            Type.BYTE.set(s2, i, 0);\n+        }\n+        for (int i = 0 ; i < size ; i++) {\n+            Type.BYTE.set(s1, i, i);\n+        }\n+        \/\/perform copy\n+        s2.segment.copyFrom(s1.segment.asSlice(0, size));\n+        \/\/check that copy actually worked\n+        for (int i = 0 ; i < size ; i++) {\n+            Type.BYTE.check(s2, i, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"slices\")\n+    public void testElementCopy(SegmentSlice s1, SegmentSlice s2) {\n+        if (s1.type.carrier != s2.type.carrier) return;\n+        int size = Math.min(s1.elementSize(), s2.elementSize());\n+        \/\/prepare source and target segments\n+        for (int i = 0 ; i < size ; i++) {\n+            s2.set(i, 0);\n+        }\n+        for (int i = 0 ; i < size ; i++) {\n+            s1.set(i, i);\n+        }\n+        \/\/perform copy\n+        s2.segment.copyFrom(s2.type.layout, s1.segment.asSlice(0, size * s1.type.size()), s1.type.layout);\n+        \/\/check that copy actually worked\n+        for (int i = 0; i < size; i++) {\n+            s2.check(i, i);\n+        }\n+    }\n+\n+    interface Getter<X> {\n+        X get(MemorySegment segment, long index, ByteOrder order);\n+    }\n+\n+    interface Setter<X> {\n+        void set(MemorySegment segment, long index, ByteOrder order, X val);\n+    }\n+\n+    enum Type {\n+        \/\/ Byte\n+        BYTE(byte.class, MemoryLayouts.JAVA_BYTE, (s, i, o) -> MemoryAccess.getByteAtOffset(s, i), (s, i, o, v) -> MemoryAccess.setByteAtOffset(s, i, v), i -> (byte)i),\n+        \/\/LE\n+        SHORT_LE(short.class, MemoryLayouts.BITS_16_LE, MemoryAccess::getShortAtOffset, MemoryAccess::setShortAtOffset, i -> (short)i),\n+        CHAR_LE(char.class, MemoryLayouts.BITS_16_LE, MemoryAccess::getCharAtOffset, MemoryAccess::setCharAtOffset, i -> (char)i),\n+        INT_LE(int.class, MemoryLayouts.BITS_32_LE, MemoryAccess::getIntAtOffset, MemoryAccess::setIntAtOffset, i -> i),\n+        FLOAT_LE(float.class, MemoryLayouts.BITS_32_LE, MemoryAccess::getFloatAtOffset, MemoryAccess::setFloatAtOffset, i -> (float)i),\n+        LONG_LE(long.class, MemoryLayouts.BITS_64_LE, MemoryAccess::getLongAtOffset, MemoryAccess::setLongAtOffset, i -> (long)i),\n+        DOUBLE_LE(double.class, MemoryLayouts.BITS_64_LE, MemoryAccess::getDoubleAtOffset, MemoryAccess::setDoubleAtOffset, i -> (double)i),\n+        \/\/BE\n+        SHORT_BE(short.class, MemoryLayouts.BITS_16_BE, MemoryAccess::getShortAtOffset, MemoryAccess::setShortAtOffset, i -> (short)i),\n+        CHAR_BE(char.class, MemoryLayouts.BITS_16_BE, MemoryAccess::getCharAtOffset, MemoryAccess::setCharAtOffset, i -> (char)i),\n+        INT_BE(int.class, MemoryLayouts.BITS_32_BE, MemoryAccess::getIntAtOffset, MemoryAccess::setIntAtOffset, i -> i),\n+        FLOAT_BE(float.class, MemoryLayouts.BITS_32_BE, MemoryAccess::getFloatAtOffset, MemoryAccess::setFloatAtOffset, i -> (float)i),\n+        LONG_BE(long.class, MemoryLayouts.BITS_64_BE, MemoryAccess::getLongAtOffset, MemoryAccess::setLongAtOffset, i -> (long)i),\n+        DOUBLE_BE(double.class, MemoryLayouts.BITS_64_BE, MemoryAccess::getDoubleAtOffset, MemoryAccess::setDoubleAtOffset, i -> (double)i);\n+\n+        final ValueLayout layout;\n+        final Getter<Object> getter;\n+        final Setter<Object> setter;\n+        final IntFunction<Object> valueConverter;\n+        final Class<?> carrier;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        <Z> Type(Class<Z> carrier, ValueLayout layout, Getter<Z> getter, Setter<Z> setter, IntFunction<Z> valueConverter) {\n+            this.carrier = carrier;\n+            this.layout = layout;\n+            this.getter = (Getter<Object>)getter;\n+            this.setter = (Setter<Object>)setter;\n+            this.valueConverter = (IntFunction<Object>)valueConverter;\n+        }\n+\n+        int size() {\n+            return (int)layout.byteSize();\n+        }\n+\n+        void set(SegmentSlice slice, int index, int val) {\n+            setter.set(slice.segment, index * size(), layout.order(), valueConverter.apply(val));\n+        }\n+\n+        void check(SegmentSlice slice, int index, int val) {\n+            assertEquals(getter.get(slice.segment, index * size(), layout.order()), valueConverter.apply(val));\n+        }\n+    }\n+\n+    static class SegmentSlice {\n+\n+        enum Kind {\n+            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope())),\n+            ARRAY(i -> MemorySegment.ofArray(new byte[i]));\n+\n+            final IntFunction<MemorySegment> segmentFactory;\n+\n+            Kind(IntFunction<MemorySegment> segmentFactory) {\n+                this.segmentFactory = segmentFactory;\n+            }\n+\n+            MemorySegment makeSegment(int elems) {\n+                return segmentFactory.apply(elems);\n+            }\n+        }\n+\n+        final Kind kind;\n+        final Type type;\n+        final int first;\n+        final int last;\n+        final MemorySegment segment;\n+\n+        public SegmentSlice(Kind kind, Type type, int first, int last, MemorySegment segment) {\n+            this.kind = kind;\n+            this.type = type;\n+            this.first = first;\n+            this.last = last;\n+            this.segment = segment;\n+        }\n+\n+        void set(int index, int val) {\n+            type.set(this, index, val);\n+        }\n+\n+        void check(int index, int val) {\n+            type.check(this, index, val);\n+        }\n+\n+        int byteSize() {\n+            return last - first + 1;\n+        }\n+\n+        int elementSize() {\n+            return byteSize() \/ type.size();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"SegmentSlice{%s, %d, %d}\", type, first, last);\n+        }\n+    }\n+\n+    @DataProvider(name = \"slices\")\n+    static Object[][] elementSlices() {\n+        List<SegmentSlice> slices = new ArrayList<>();\n+        for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {\n+            MemorySegment segment = kind.makeSegment(16);\n+            \/\/compute all slices\n+            for (Type type : Type.values()) {\n+                for (int index = 0; index < 16; index += type.size()) {\n+                    MemorySegment first = segment.asSlice(0, index);\n+                    slices.add(new SegmentSlice(kind, type, 0, index - 1, first));\n+                    MemorySegment second = segment.asSlice(index);\n+                    slices.add(new SegmentSlice(kind, type, index, 15, second));\n+                }\n+            }\n+        }\n+        Object[][] sliceArray = new Object[slices.size() * slices.size()][];\n+        for (int i = 0 ; i < slices.size() ; i++) {\n+            for (int j = 0 ; j < slices.size() ; j++) {\n+                sliceArray[i * slices.size() + j] = new Object[] { slices.get(i), slices.get(j) };\n+            }\n+        }\n+        return sliceArray;\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestCopyFrom.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -19,1 +19,1 @@\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n@@ -22,1 +22,0 @@\n- *\n@@ -30,5 +29,1 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n@@ -37,0 +32,1 @@\n+import java.nio.ByteOrder;\n@@ -38,0 +34,1 @@\n+import java.util.Arrays;\n@@ -39,1 +36,0 @@\n-import java.util.function.IntFunction;\n@@ -41,1 +37,4 @@\n-import static org.testng.Assert.*;\n+import jdk.incubator.foreign.MemoryCopy;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemoryLayouts;\n+import jdk.incubator.foreign.MemorySegment;\n@@ -43,0 +42,14 @@\n+import jdk.incubator.foreign.ValueLayout;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * These tests exercise the MemoryCopy copyFromArray(...) and copyToArray(...).\n+ * To make these tests more challenging the segment is a view of the given array,\n+ * which makes the copy operations overlapping self-copies.  Thus, this checks the claim:\n+ *\n+ * <p>If the source (destination) segment is actually a view of the destination (source) array,\n+ * and if the copy region of the source overlaps with the copy region of the destination,\n+ * the copy of the overlapping region is performed as if the data in the overlapping region\n+ * were first copied into a temporary segment before being copied to the destination.<\/p>\n+ *\/\n@@ -44,0 +57,6 @@\n+    private static final ByteOrder NATIVE_ORDER = ByteOrder.nativeOrder();\n+    private static final ByteOrder NON_NATIVE_ORDER = NATIVE_ORDER == ByteOrder.LITTLE_ENDIAN\n+            ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;\n+\n+    private static final int SEG_LENGTH_BYTES = 32;\n+    private static final int SEG_OFFSET_BYTES = 8;\n@@ -45,1 +64,27 @@\n-    final static VarHandle BYTE_HANDLE = MemoryLayouts.JAVA_BYTE.varHandle(byte.class);\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testSelfCopy(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        int indexShifts = SEG_OFFSET_BYTES \/ bytesPerElement;\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        MemorySegment truth = truthSegment(base, helper, indexShifts, mode);\n+        ByteOrder bo = mode.swap ? NON_NATIVE_ORDER : NATIVE_ORDER;\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        int srcIndex = mode.direction ? 0 : indexShifts;\n+        int srcCopyLen = helper.length(srcArr) - indexShifts;\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        long dstOffsetBytes = mode.direction ? SEG_OFFSET_BYTES : 0;\n+        helper.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+        assertEquals(truth.mismatch(dstSeg), -1);\n+        \/\/CopyTo\n+        long srcOffsetBytes = mode.direction ? 0 : SEG_OFFSET_BYTES;\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr);\n+        int dstIndex = mode.direction ? indexShifts : 0;\n+        int dstCopyLen = helper.length(dstArr) - indexShifts;\n+        helper.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+        MemorySegment result = helper.fromArray(dstArr);\n+        assertEquals(truth.mismatch(result), -1);\n+    }\n+\n+    \/***** Utilities *****\/\n@@ -47,6 +92,4 @@\n-    @Test(dataProvider = \"slices\")\n-    public void testCopy(SegmentSlice s1, SegmentSlice s2) {\n-        int size = Math.min(s1.size(), s2.size());\n-        \/\/prepare source and target segments\n-        for (int i = 0 ; i < size ; i++) {\n-            BYTE_HANDLE.set(s2.segment.asSlice(i), (byte)0);\n+    public static MemorySegment srcSegment(int bytesLength) {\n+        byte[] arr = new byte[bytesLength];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (byte)i;\n@@ -54,2 +97,34 @@\n-        for (int i = 0 ; i < size ; i++) {\n-            BYTE_HANDLE.set(s1.segment.asSlice(i), (byte) i);\n+        return MemorySegment.ofArray(arr);\n+    }\n+\n+    public static MemorySegment truthSegment(MemorySegment srcSeg, CopyHelper<?> helper, int indexShifts, CopyMode mode) {\n+        VarHandle indexedHandleNO = MemoryLayout.sequenceLayout(helper.elementLayout.withOrder(NATIVE_ORDER))\n+                                                .varHandle(helper.carrier.componentType(), MemoryLayout.PathElement.sequenceElement());\n+        VarHandle indexedHandleNNO = MemoryLayout.sequenceLayout(helper.elementLayout.withOrder(NON_NATIVE_ORDER))\n+                                                 .varHandle(helper.carrier.componentType(), MemoryLayout.PathElement.sequenceElement());\n+        MemorySegment dstSeg = MemorySegment.ofArray(srcSeg.toByteArray());\n+        int indexLength = (int) dstSeg.byteSize() \/ (int)helper.elementLayout.byteSize();\n+        if (mode.direction) {\n+            if (mode.swap) {\n+                for (int i = indexLength - 1; i >= indexShifts; i--) {\n+                    Object v = indexedHandleNNO.get(dstSeg, i - indexShifts);\n+                    indexedHandleNO.set(dstSeg, i, v);\n+                }\n+            } else {\n+                for (int i = indexLength - 1; i >= indexShifts; i--) {\n+                    Object v = indexedHandleNO.get(dstSeg, i - indexShifts);\n+                    indexedHandleNO.set(dstSeg, i, v);\n+                }\n+            }\n+        } else { \/\/down\n+            if (mode.swap) {\n+                for (int i = indexShifts; i < indexLength; i++) {\n+                    Object v = indexedHandleNNO.get(dstSeg, i);\n+                    indexedHandleNO.set(dstSeg, i - indexShifts, v);\n+                }\n+            } else {\n+                for (int i = indexShifts; i < indexLength; i++) {\n+                    Object v = indexedHandleNO.get(dstSeg, i);\n+                    indexedHandleNO.set(dstSeg, i - indexShifts, v);\n+                }\n+            }\n@@ -57,5 +132,15 @@\n-        \/\/perform copy\n-        s2.segment.copyFrom(s1.segment.asSlice(0, size));\n-        \/\/check that copy actually worked\n-        for (int i = 0 ; i < size ; i++) {\n-            assertEquals((byte)i, BYTE_HANDLE.get(s2.segment.asSlice(i)));\n+        return dstSeg;\n+    }\n+\n+    enum CopyMode {\n+        UP_NO_SWAP(true, false),\n+        UP_SWAP(true, true),\n+        DOWN_NO_SWAP(false, false),\n+        DOWN_SWAP(false, true);\n+\n+        final boolean direction;\n+        final boolean swap;\n+\n+        CopyMode(boolean direction, boolean swap) {\n+            this.direction = direction;\n+            this.swap = swap;\n@@ -65,1 +150,4 @@\n-    static class SegmentSlice {\n+    abstract static class CopyHelper<X> {\n+\n+        final ValueLayout elementLayout;\n+        final Class<?> carrier;\n@@ -67,3 +155,4 @@\n-        enum Kind {\n-            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope())),\n-            ARRAY(i -> MemorySegment.ofArray(new byte[i]));\n+        public CopyHelper(ValueLayout elementLayout, Class<X> carrier) {\n+            this.elementLayout = elementLayout;\n+            this.carrier = carrier;\n+        }\n@@ -71,1 +160,5 @@\n-            final IntFunction<MemorySegment> segmentFactory;\n+        abstract void copyFromArray(X srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo);\n+        abstract void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, X dstArr, int dstIndex, int dstCopyLen, ByteOrder bo);\n+        abstract X toArray(MemorySegment segment);\n+        abstract MemorySegment fromArray(X array);\n+        abstract int length(X arr);\n@@ -73,2 +166,12 @@\n-            Kind(IntFunction<MemorySegment> segmentFactory) {\n-                this.segmentFactory = segmentFactory;\n+        @Override\n+        public String toString() {\n+            return \"CopyHelper{\" +\n+                    \"elementLayout=\" + elementLayout +\n+                    \", carrier=\" + carrier.getName() +\n+                    '}';\n+        }\n+\n+        static final CopyHelper<byte[]> BYTE = new CopyHelper<>(MemoryLayouts.JAVA_BYTE, byte[].class) {\n+            @Override\n+            void copyFromArray(byte[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes);\n@@ -77,2 +180,3 @@\n-            MemorySegment makeSegment(int elems) {\n-                return segmentFactory.apply(elems);\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, byte[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n@@ -80,1 +184,0 @@\n-        }\n@@ -82,4 +185,4 @@\n-        final Kind kind;\n-        final int first;\n-        final int last;\n-        final MemorySegment segment;\n+            @Override\n+            byte[] toArray(MemorySegment segment) {\n+                return segment.toByteArray();\n+            }\n@@ -87,6 +190,4 @@\n-        public SegmentSlice(Kind kind, int first, int last, MemorySegment segment) {\n-            this.kind = kind;\n-            this.first = first;\n-            this.last = last;\n-            this.segment = segment;\n-        }\n+            @Override\n+            MemorySegment fromArray(byte[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n@@ -94,4 +195,5 @@\n-        int size() {\n-            return last - first + 1;\n-        }\n-    }\n+            @Override\n+            int length(byte[] arr) {\n+                return arr.length;\n+            }\n+        };\n@@ -99,12 +201,4 @@\n-    @DataProvider(name = \"slices\")\n-    static Object[][] slices() {\n-        int[] sizes = { 16, 8, 4, 2, 1 };\n-        List<SegmentSlice> slices = new ArrayList<>();\n-        for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {\n-            MemorySegment segment = kind.makeSegment(16);\n-            \/\/compute all slices\n-            for (int size : sizes) {\n-                for (int index = 0 ; index < 16 ; index += size) {\n-                    MemorySegment slice = segment.asSlice(index, size);\n-                    slices.add(new SegmentSlice(kind, index, index + size - 1, slice));\n-                }\n+        static final CopyHelper<char[]> CHAR = new CopyHelper<>(MemoryLayouts.JAVA_CHAR, char[].class) {\n+            @Override\n+            void copyFromArray(char[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n@@ -112,5 +206,173 @@\n-        }\n-        Object[][] sliceArray = new Object[slices.size() * slices.size()][];\n-        for (int i = 0 ; i < slices.size() ; i++) {\n-            for (int j = 0 ; j < slices.size() ; j++) {\n-                sliceArray[i * slices.size() + j] = new Object[] { slices.get(i), slices.get(j) };\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, char[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+            }\n+\n+            @Override\n+            char[] toArray(MemorySegment segment) {\n+                return segment.toCharArray();\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(char[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(char[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<short[]> SHORT = new CopyHelper<>(MemoryLayouts.JAVA_SHORT, short[].class) {\n+            @Override\n+            void copyFromArray(short[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, short[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+            }\n+\n+            @Override\n+            short[] toArray(MemorySegment segment) {\n+                return segment.toShortArray();\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(short[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(short[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<int[]> INT = new CopyHelper<>(MemoryLayouts.JAVA_INT, int[].class) {\n+            @Override\n+            void copyFromArray(int[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, int[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+            }\n+\n+            @Override\n+            int[] toArray(MemorySegment segment) {\n+                return segment.toIntArray();\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(int[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(int[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<float[]> FLOAT = new CopyHelper<>(MemoryLayouts.JAVA_FLOAT, float[].class) {\n+            @Override\n+            void copyFromArray(float[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, float[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+            }\n+\n+            @Override\n+            float[] toArray(MemorySegment segment) {\n+                return segment.toFloatArray();\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(float[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(float[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<long[]> LONG = new CopyHelper<>(MemoryLayouts.JAVA_LONG, long[].class) {\n+            @Override\n+            void copyFromArray(long[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, long[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+            }\n+\n+            @Override\n+            long[] toArray(MemorySegment segment) {\n+                return segment.toLongArray();\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(long[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(long[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<double[]> DOUBLE = new CopyHelper<>(MemoryLayouts.JAVA_DOUBLE, double[].class) {\n+            @Override\n+            void copyFromArray(double[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, double[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+            }\n+\n+            @Override\n+            double[] toArray(MemorySegment segment) {\n+                return segment.toDoubleArray();\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(double[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(double[] arr) {\n+                return arr.length;\n+            }\n+        };\n+    }\n+\n+    @DataProvider\n+    Object[][] copyModes() {\n+        return Arrays.stream(CopyMode.values())\n+                .map(mode -> new Object[] { mode })\n+                .toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    Object[][] copyModesAndHelpers() {\n+        CopyHelper<?>[] helpers = { CopyHelper.BYTE, CopyHelper.CHAR, CopyHelper.SHORT, CopyHelper.INT,\n+                                    CopyHelper.FLOAT, CopyHelper.LONG, CopyHelper.DOUBLE };\n+        List<Object[]> results = new ArrayList<>();\n+        for (CopyHelper<?> helper : helpers) {\n+            for (CopyMode mode : CopyMode.values()) {\n+                results.add(new Object[] { mode, helper, helper.toString() });\n@@ -119,1 +381,1 @@\n-        return sliceArray;\n+        return results.stream().toArray(Object[][]::new);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryCopy.java","additions":328,"deletions":66,"binary":false,"changes":394,"status":"modified"}]}