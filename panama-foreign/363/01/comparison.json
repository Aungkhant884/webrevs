{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n@@ -33,1 +34,1 @@\n-import java.util.Objects;\n+import java.lang.ref.Cleaner;\n@@ -92,2 +93,3 @@\n-     * where an address to some underlying memory region is typically obtained from native code\n-     * (often as a plain {@code long} value). The returned segment will feature all <a href=\"#access-modes\">access modes<\/a>\n+     * where an address to some underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n+     * <p>\n+     * The returned segment will feature all <a href=\"#access-modes\">access modes<\/a>\n@@ -101,5 +103,1 @@\n-     * memory resources which might implicitly be associated with the segment. If the client wants to specify\n-     * a cleanup action to be executed when the returned segment is closed, the {@link MemorySegment#withCleanupAction(Runnable)}\n-     * method should be used.\n-     * <p>\n-     * Equivalent to the following code:\n+     * memory resources which might implicitly be associated with the segment. This method is equivalent to the following code:\n@@ -107,1 +105,1 @@\n-    asSegmentRestricted(byteSize, null);\n+    asSegmentRestricted(byteSize, null, null);\n@@ -109,1 +107,0 @@\n-     * <p>\n@@ -114,2 +111,0 @@\n-     * @see #asSegmentRestricted(long, Object)\n-     *\n@@ -124,1 +119,1 @@\n-        return asSegmentRestricted(bytesSize, null);\n+        return asSegmentRestricted(bytesSize, null, null);\n@@ -130,6 +125,1 @@\n-     * where an address to some underlying memory region is typically obtained from native code\n-     * (often as a plain {@code long} value).\n-     * <p>\n-     * Clients should ensure that the address and bounds refers to a valid region of memory that is accessible for reading and,\n-     * if appropriate, writing; an attempt to access an invalid memory location from Java code will either return an arbitrary value,\n-     * have no visible effect, or cause an unspecified exception to be thrown.\n+     * where an address to some underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n@@ -139,1 +129,1 @@\n-     * Moreover, the returned segment will keep a strong reference to the supplied attachment object, which can\n+     * Moreover, the returned segment will keep a strong reference to the supplied attachment object (if any), which can\n@@ -142,0 +132,4 @@\n+     * Clients should ensure that the address and bounds refers to a valid region of memory that is accessible for reading and,\n+     * if appropriate, writing; an attempt to access an invalid memory location from Java code will either return an arbitrary value,\n+     * have no visible effect, or cause an unspecified exception to be thrown.\n+     * <p>\n@@ -143,3 +137,5 @@\n-     * memory resources which might implicitly be associated with the segment. If the client wants to specify\n-     * a cleanup action to be executed when the returned segment is closed, the {@link MemorySegment#withCleanupAction(Runnable)}\n-     * method should be used.\n+     * memory resources which might implicitly be associated with the segment, but will result in calling the\n+     * provided cleanup action (if any).\n+     * <p>\n+     * Both the cleanup action and the attachment object (if any) will be preserved under terminal operations such as\n+     * {@link MemorySegment#handoff(Thread)}, {@link MemorySegment#share()} and {@link MemorySegment#registerCleaner(Cleaner)}.\n@@ -152,0 +148,1 @@\n+     * @param cleanupAction the cleanup action; can be {@code null}.\n@@ -159,7 +156,1 @@\n-    default MemorySegment asSegmentRestricted(long bytesSize, Object attachment) {\n-        Utils.checkRestrictedAccess(\"MemoryAddress.asSegmentRestricted\");\n-        if (bytesSize <= 0) {\n-            throw new IllegalArgumentException(\"Invalid size : \" + bytesSize);\n-        }\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(this, bytesSize, attachment);\n-    }\n+    MemorySegment asSegmentRestricted(long bytesSize, Runnable cleanupAction, Object attachment);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":21,"deletions":30,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n- * <h2>Constructing memory segments from different sources<\/h2>\n+ * <h2>Constructing memory segments<\/h2>\n@@ -88,1 +88,1 @@\n- * <h2>Closing a memory segment<\/h2>\n+ * <h2>Explicit deallocation<\/h2>\n@@ -106,4 +106,0 @@\n- * Clients can register a memory segment against a {@link Cleaner}, to make sure that underlying resources associated with\n- * that segment will be released when the segment becomes <em>unreachable<\/em> (see {@link #registerCleaner(Cleaner)});\n- * this might be useful to prevent native memory leaks.\n- *\n@@ -152,3 +148,4 @@\n- * Memory segments support <em>serial thread confinement<\/em>; that is, ownership of a memory segment can change (see\n- * {@link #withOwnerThread(Thread)}). This allows, for instance, for two threads {@code A} and {@code B} to share\n- * a segment in a controlled, cooperative and race-free fashion.\n+ * The {@link #handoff(Thread)} method can be used to change the thread-confinement properties of a memory segment.\n+ * This method is, like {@link #close()}, a <em>terminal operation<\/em> which marks the original segment as not alive\n+ * (see {@link #isAlive()}) and creates a <em>new<\/em> segment with the desired thread-confinement properties. Calling\n+ * {@link #handoff(Thread)} is only possible if the segment features the corresponding {@link #HANDOFF} access mode.\n@@ -156,7 +153,26 @@\n- * In some cases, it might be useful for multiple threads to process the contents of the same memory segment concurrently\n- * (e.g. in the case of parallel processing); while memory segments provide strong confinement guarantees, it is possible\n- * to derive a <em>shared<\/em> segment from a confined one. This can be done again, by calling {@link #withOwnerThread(Thread)},\n- * and passing a {@code null} owner segment (this assumes that the access mode {@link #SHARE} of the original segment is set).\n- * For instance, a client might obtain a {@link Spliterator} from a shared segment, which can then be used to slice the\n- * segment and allow multiple thread to work in parallel on disjoint segment slices.\n- * For instance, the following code can be used to sum all int values in a memory segment in parallel:\n+ * For instance, if a client wants to transfer ownership of a segment to another (known) thread, it can do so as follows:\n+ *\n+ * <blockquote><pre>{@code\n+MemorySegment segment = ...\n+MemorySegment aSegment = segment.handoff(threadA);\n+ * }<\/pre><\/blockquote>\n+ *\n+ * By doing so, the original segment is marked as not alive, and a new segment is returned whose owner thread\n+ * is {@code threadA}; this allows, for instance, for two threads {@code A} and {@code B} to share\n+ * a segment in a controlled, cooperative and race-free fashion (also known as <em>serial thread confinement<\/em>).\n+ * <p>\n+ * Alternatively, the {@link #share()} method can be used to remove thread ownership altogether; this is only possible\n+ * if the segment features the corresponding {@link #SHARE} access mode. The following code shows how clients can\n+ * obtain a shared segment:\n+ *\n+ * <blockquote><pre>{@code\n+MemorySegment segment = ...\n+MemorySegment sharedSegment = segment.share();\n+ * }<\/pre><\/blockquote>\n+ *\n+ * Again here, the original segment is marked as not alive, and a new <em>shared<\/em> segment is returned which features no owner\n+ * thread (e.g. {@link #ownerThread()} returns {@code null}). This might be useful when multiple threads need to process\n+ * the contents of the same memory segment concurrently (e.g. in the case of parallel processing). For instance, a client\n+ * might obtain a {@link Spliterator} from a shared segment, which can then be used to slice the segment and allow multiple\n+ * threads to work in parallel on disjoint segment slices. The following code can be used to sum all int values in a memory segment in parallel:\n+ *\n@@ -165,1 +181,1 @@\n-try (MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT).withOwnerThread(null)) {\n+try (MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT).share()) {\n@@ -172,1 +188,2 @@\n- * Once shared, a segment can be claimed back by a given thread (see {@link #withOwnerThread(Thread)}); in fact, many threads\n+ *\n+ * Once shared, a segment can be claimed back by a given thread (again using {@link #handoff(Thread)}); in fact, many threads\n@@ -175,0 +192,16 @@\n+ * <h2>Implicit deallocation<\/h2>\n+ *\n+ * Clients can register a memory segment against a {@link Cleaner}, to make sure that underlying resources associated with\n+ * that segment will be released when the segment becomes <em>unreachable<\/em>, which can be useful to prevent native memory\n+ * leaks. This can be achieved using the {@link #registerCleaner(Cleaner)} method, as follows:\n+ *\n+ * <blockquote><pre>{@code\n+MemorySegment segment = ...\n+MemorySegment gcSegment = segment.registerCleaner(cleaner);\n+ * }<\/pre><\/blockquote>\n+ *\n+ * Here, the original segment is marked as not alive, and a new segment is returned (the owner thread of the returned\n+ * segment set is set to that of the current thread, see {@link #ownerThread()}); the new segment\n+ * will also be registered with the the {@link Cleaner} instance provided to the {@link #registerCleaner(Cleaner)} method;\n+ * as such, if not closed explicitly (see {@link #close()}), the new segment will be automatically closed by the cleaner.\n+ *\n@@ -195,14 +228,0 @@\n-    \/**\n-     * Register this memory segment instance against a {@link Cleaner} object. This allows for the segment to be closed\n-     * as soon as it becomes <em>unreachable<\/em>, which might be helpful in preventing native memory leaks.\n-     * @apiNote Calling this method multiple times, even concurrently (from multiple threads, if this segment is shared)\n-     * is allowed; the implementation guarantees that the memory resources associated with this segment will be released\n-     * at most once. Also, in case the segment has been closed explicitly (see {@link #close}) no further action will be\n-     * taken by the GC when the segment later becomes unreachable.\n-     * @param cleaner the {@link Cleaner} object responsible for cleaning up this memory segment.\n-     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n-     * thread owning this segment\n-     * @throws UnsupportedOperationException if this segment does not feature the {@link #CLOSE} access mode.\n-     *\/\n-    void registerCleaner(Cleaner cleaner);\n-\n@@ -221,1 +240,1 @@\n-     * be processed in parallel by multiple threads (if the access mode {@link #SHARE} is set).\n+     * be processed in parallel by multiple threads (if the segment is shared).\n@@ -243,44 +262,0 @@\n-    \/**\n-     * Obtains a new memory segment backed by the same underlying memory region as this segment,\n-     * but with different owner thread. As a side-effect, this segment will be marked as <em>not alive<\/em>,\n-     * and subsequent operations on this segment will result in runtime errors.\n-     *<p>If {@code newOwner} is {@code != null}, then the resulting segment will\n-     * be a confined segment, whose owner thread is {@code newOwner}. Otherwise, the resulting segment will be\n-     * a shared segment, and will be accessible concurrently from multiple threads.\n-     * <p>\n-     * Write accesses to the segment's content <a href=\"..\/..\/..\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happens-before<\/i><\/a>\n-     * hand-over from the current owner thread to the new owner thread, which in turn <i>happens before<\/i> read accesses to the segment's contents on\n-     * the new owner thread.\n-     *\n-     * @param newOwner the new owner thread (can be {@code null}).\n-     * @return a new memory segment backed by the same underlying memory region as this segment; the new segment can\n-     * be either a confined segment ({@code newOwner != null}) or a shared segment ({@code newOwner == null}).\n-     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n-     * thread owning this segment.\n-     * @throws IllegalArgumentException if the segment is already a confined segment owner by {@code newOnwer}\n-     * @throws UnsupportedOperationException if {@code newOwner != null} and this segment does not support the {@link #HANDOFF} access mode,\n-     * or if {@code newOwner == null} and this segment does not support the {@link #SHARE} access mode.\n-     *\/\n-    MemorySegment withOwnerThread(Thread newOwner);\n-\n-    \/**\n-     * Obtains a new memory segment backed by the same underlying memory region as this segment, and featuring\n-     * the same confinement thread (see {@link #ownerThread()} and access modes (see {@link #accessModes()}),\n-     * but with a different cleanup action. More specifically, the cleanup action associated with the returned segment will\n-     * first call the user-provided action, before delegating back to the original cleanup action associated with\n-     * this segment (if any). Any errors and\/or exceptions thrown by the user-provided action will be discarded, and will not prevent the\n-     * release of any memory resources associated with this segment.\n-     * <p>\n-     * As a side-effect, this segment will be marked as <em>not alive<\/em>,\n-     * and subsequent operations on this segment will result in runtime errors.\n-     *\n-     * @param action the new cleanup action\n-     * @return a new memory segment backed by the same underlying memory region as this segment; the cleanup action\n-     * associated with the new segment is the result of composing this segment's cleanup action with the\n-     * supplied {@code action}.\n-     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n-     * thread owning this segment.\n-     * @throws NullPointerException if {@code action == null}\n-     *\/\n-    MemorySegment withCleanupAction(Runnable action);\n-\n@@ -410,2 +385,2 @@\n-     * Closes this memory segment. Once a memory segment has been closed, any attempt to use the memory segment,\n-     * or to access any {@link MemoryAddress} instance associated with it will fail with {@link IllegalStateException}.\n+     * Closes this memory segment. This is a <em>terminal operation<\/em>; as a side-effect, this segment will be marked\n+     * as <em>not alive<\/em>, and subsequent operations on this segment will fail with {@link IllegalStateException}.\n@@ -421,0 +396,65 @@\n+    \/**\n+     * Obtains a new confined memory segment backed by the same underlying memory region as this segment. The returned segment will\n+     * be confined on the specified thread, and will feature the same spatial bounds and access modes (see {@link #accessModes()})\n+     * as this segment.\n+     * <p>\n+     * This is a <em>terminal operation<\/em>; as a side-effect, this segment will be\n+     * marked as <em>not alive<\/em>, and subsequent operations on this segment will fail with {@link IllegalStateException}.\n+     * <p>\n+     * In case where the owner thread of the returned segment differs from that of this segment, write accesses to this\n+     * segment's content <a href=\"..\/..\/..\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happens-before<\/i><\/a>\n+     * hand-over from the current owner thread to the new owner thread, which in turn <i>happens before<\/i> read accesses\n+     * to the returned segment's contents on the new owner thread.\n+     *\n+     * @param thread the new owner thread\n+     * @return a new confined memory segment whose owner thread is set to {@code thread}.\n+     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n+     * thread owning this segment.\n+     * @throws UnsupportedOperationException if this segment does not support the {@link #HANDOFF} access mode.\n+     * @throws NullPointerException if {@code thread == null}\n+     *\/\n+    MemorySegment handoff(Thread thread);\n+\n+    \/**\n+     * Obtains a new shared memory segment backed by the same underlying memory region as this segment. The returned segment will\n+     * not be confined on any thread and can therefore be accessed concurrently from multiple threads; moreover, the\n+     * returned segment will feature the same spatial bounds and access modes (see {@link #accessModes()})\n+     * as this segment.\n+     * <p>\n+     * This is a <em>terminal operation<\/em>; as a side-effect, this segment will be\n+     * marked as <em>not alive<\/em>, and subsequent operations on this segment will fail with {@link IllegalStateException}.\n+     * <p>\n+     * Write accesses to this segment's content <a href=\"..\/..\/..\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happens-before<\/i><\/a>\n+     * hand-over from the current owner thread to the new owner thread, which in turn <i>happens before<\/i> read accesses\n+     * to the returned segment's contents on a new thread.\n+     *\n+     * @return a new memory shared segment backed by the same underlying memory region as this segment.\n+     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n+     * thread owning this segment.\n+     * @throws NullPointerException if {@code thread == null}\n+     *\/\n+    MemorySegment share();\n+\n+    \/**\n+     * Register this memory segment instance against a {@link Cleaner} object, by returning a new memory segment backed\n+     * by the same underlying memory region as this segment. The returned segment will feature the same confinement,\n+     * spatial bounds and access modes (see {@link #accessModes()}) as this segment. Moreover, the returned segment\n+     * will be associated with the specified {@link Cleaner} object; this allows for the segment to be closed\n+     * as soon as it becomes <em>unreachable<\/em>, which might be helpful in preventing native memory leaks.\n+     * <p>\n+     * This is a <em>terminal operation<\/em>; as a side-effect, this segment will be\n+     * marked as <em>not alive<\/em>, and subsequent operations on this segment will fail with {@link IllegalStateException}.\n+     * <p>\n+     * The implicit deallocation behavior associated with the returned segment will be preserved under terminal\n+     * operations such as {@link #handoff(Thread)} and {@link #share()}.\n+     *\n+     * @param cleaner the cleaner object, responsible for implicit deallocation of the returned segment.\n+     * @return a new memory segment backed by the same underlying memory region as this segment, which features\n+     * implicit deallocation.\n+     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n+     * thread owning this segment, or if this segment is already associated with a cleaner.\n+     * @throws UnsupportedOperationException if this segment does not support the {@link #CLOSE} access mode.\n+     * @throws NullPointerException if {@code thread == null}\n+     *\/\n+    MemorySegment registerCleaner(Cleaner cleaner);\n+\n@@ -852,1 +892,1 @@\n-     * Share access mode; this segment support sharing with threads other than the owner thread (see {@link #withOwnerThread(Thread)}}).\n+     * Share access mode; this segment support sharing with threads other than the owner thread (see {@link #share()}).\n@@ -861,1 +901,1 @@\n-     * (see {@link #withOwnerThread(Thread)}).\n+     * (see {@link #handoff(Thread)}).\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":121,"deletions":81,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -90,2 +90,2 @@\n- * <a href=\"MemorySegment.html#thread-confinement\"><em>thread-confinement<\/em><\/a> guarantees on memory segments: each\n- * memory segment is associated with an owner thread, which is the only thread that can either access or close the segment.\n+ * <em>thread-confinement<\/em> guarantees on memory segments: upon creation, a memory segment is associated with an owner thread,\n+ * which is the only thread that can either access or close the segment.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,5 +28,1 @@\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.SequenceLayout;\n+import jdk.incubator.foreign.*;\n@@ -280,2 +276,2 @@\n-    @Override\n-    public MemorySegment withOwnerThread(Thread newOwner) {\n+    public MemorySegment handoff(Thread thread) {\n+        Objects.requireNonNull(thread);\n@@ -283,3 +279,2 @@\n-        int expectedMode = newOwner != null ? HANDOFF : SHARE;\n-        if (!isSet(expectedMode)) {\n-            throw unsupportedAccessMode(expectedMode);\n+        if (!isSet(HANDOFF)) {\n+            throw unsupportedAccessMode(HANDOFF);\n@@ -288,4 +283,1 @@\n-            return dup(0L, length, mask,\n-                    expectedMode == HANDOFF ?\n-                            scope.confineTo(newOwner) :\n-                            scope.share());\n+            return dup(0L, length, mask, scope.confineTo(thread));\n@@ -299,1 +291,1 @@\n-    public MemorySegment withCleanupAction(Runnable action) {\n+    public MemorySegment share() {\n@@ -301,1 +293,9 @@\n-        return dup(0L, length, mask, scope.wrapAction(action));\n+        if (!isSet(SHARE)) {\n+            throw unsupportedAccessMode(SHARE);\n+        }\n+        try {\n+            return dup(0L, length, mask, scope.share());\n+        } finally {\n+            \/\/flush read\/writes to segment memory before returning the new segment\n+            VarHandle.fullFence();\n+        }\n@@ -305,2 +305,2 @@\n-    public void registerCleaner(Cleaner cleaner) {\n-        checkAccessModes(CLOSE);\n+    public MemorySegment registerCleaner(Cleaner cleaner) {\n+        Objects.requireNonNull(cleaner);\n@@ -308,1 +308,4 @@\n-        cleaner.register(this.scope, scope.cleanupAction);\n+        if (!isSet(CLOSE)) {\n+            throw unsupportedAccessMode(CLOSE);\n+        }\n+        return dup(0L, length, mask, scope.cleanable(cleaner));\n@@ -460,1 +463,1 @@\n-            modes.add(\"ACQUIRE\");\n+            modes.add(\"SHARE\");\n@@ -584,1 +587,1 @@\n-            bufferScope = MemoryScope.createConfined(bb, MemoryScope.CleanupAction.DUMMY);\n+            bufferScope = MemoryScope.createConfined(bb, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n@@ -598,24 +601,0 @@\n-\n-    public static final AbstractMemorySegmentImpl NOTHING = new AbstractMemorySegmentImpl(\n-        0, 0, MemoryScope.createShared(null, MemoryScope.CleanupAction.DUMMY)\n-    ) {\n-        @Override\n-        ByteBuffer makeByteBuffer() {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        long min() {\n-            return 0;\n-        }\n-\n-        @Override\n-        Object base() {\n-            return null;\n-        }\n-\n-        @Override\n-        AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {\n-            throw new UnsupportedOperationException();\n-        }\n-    };\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":24,"deletions":45,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-        MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.CleanupAction.DUMMY);\n+        MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,6 +104,1 @@\n-            MemoryScope scope = MemoryScope.createConfined(null, new MemoryScope.CleanupAction.AtMostOnceOnly() {\n-                @Override\n-                void doCleanup() {\n-                    unmapperProxy.unmap();\n-                }\n-            });\n+            MemoryScope scope = MemoryScope.createConfined(null, unmapperProxy::unmap, null);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -94,0 +94,9 @@\n+\n+    @Override\n+    public MemorySegment asSegmentRestricted(long bytesSize, Runnable cleanupAction, Object attachment) {\n+        Utils.checkRestrictedAccess(\"MemoryAddress.asSegmentRestricted\");\n+        if (bytesSize <= 0) {\n+            throw new IllegalArgumentException(\"Invalid size : \" + bytesSize);\n+        }\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(this, bytesSize, cleanupAction, attachment);\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.ref.PhantomCleanable;\n@@ -34,0 +35,1 @@\n+import java.lang.ref.Cleaner;\n@@ -52,1 +54,3 @@\n-    private MemoryScope(Object ref, CleanupAction cleanupAction) {\n+    static final Runnable DUMMY_CLEANUP_ACTION = () -> { };\n+\n+    private MemoryScope(Object ref, Runnable cleanupAction, Cleaner cleaner) {\n@@ -56,0 +60,3 @@\n+        this.scopeCleanable = cleaner != null ?\n+                new ScopeCleanable(this, cleaner, cleanupAction) :\n+                null;\n@@ -65,2 +72,2 @@\n-    static MemoryScope createConfined(Object ref, CleanupAction cleanupAction) {\n-        return new ConfinedScope(Thread.currentThread(), ref, cleanupAction);\n+    static MemoryScope createConfined(Object ref, Runnable cleanupAction, Cleaner cleaner) {\n+        return new ConfinedScope(Thread.currentThread(), ref, cleanupAction, cleaner);\n@@ -75,2 +82,2 @@\n-    static MemoryScope createShared(Object ref, CleanupAction cleanupAction) {\n-        return new SharedScope(ref, cleanupAction);\n+    static MemoryScope createShared(Object ref, Runnable cleanupAction, Cleaner cleaner) {\n+        return new SharedScope(ref, cleanupAction, cleaner);\n@@ -80,1 +87,2 @@\n-    protected final CleanupAction cleanupAction;\n+    protected final ScopeCleanable scopeCleanable;\n+    protected final Runnable cleanupAction;\n@@ -100,1 +108,4 @@\n-            cleanupAction.cleanup();\n+            cleanupAction.run();\n+            if (scopeCleanable != null) {\n+                scopeCleanable.clear();\n+            }\n@@ -118,1 +129,5 @@\n-            return new ConfinedScope(newOwner, ref, cleanupAction.dup());\n+            if (scopeCleanable != null) {\n+                scopeCleanable.clear();\n+            }\n+            return new ConfinedScope(newOwner, ref, cleanupAction, scopeCleanable != null ?\n+                    scopeCleanable.cleaner : null);\n@@ -134,1 +149,5 @@\n-            return new SharedScope(ref, cleanupAction.dup());\n+            if (scopeCleanable != null) {\n+                scopeCleanable.clear();\n+            }\n+            return new SharedScope(ref, cleanupAction, scopeCleanable != null ?\n+                    scopeCleanable.cleaner : null);\n@@ -140,1 +159,4 @@\n-    final MemoryScope wrapAction(Runnable runnable) {\n+    MemoryScope cleanable(Cleaner cleaner) {\n+        if (scopeCleanable != null) {\n+            throw new IllegalStateException(\"Already registered with a cleaner\");\n+        }\n@@ -144,2 +166,2 @@\n-                    new SharedScope(ref, cleanupAction.wrap(runnable)) :\n-                    new ConfinedScope(ownerThread(), ref, cleanupAction.wrap(runnable));\n+                    new SharedScope(ref, cleanupAction, cleaner) :\n+                    new ConfinedScope(ownerThread(), ref, cleanupAction, cleaner);\n@@ -199,2 +221,2 @@\n-        public ConfinedScope(Thread owner, Object ref, CleanupAction cleanupAction) {\n-            super(ref, cleanupAction);\n+        public ConfinedScope(Thread owner, Object ref, Runnable cleanupAction, Cleaner cleaner) {\n+            super(ref, cleanupAction, cleaner);\n@@ -245,7 +267,2 @@\n-        SharedScope(Object ref, CleanupAction cleanupAction) {\n-            super(ref, cleanupAction);\n-        }\n-\n-        @Override\n-        MemoryScope share() {\n-            throw new IllegalStateException(\"Already shared\");\n+        SharedScope(Object ref, Runnable cleanupAction, Cleaner cleaner) {\n+            super(ref, cleanupAction, cleaner);\n@@ -272,7 +289,3 @@\n-    \/**\n-     * A functional interface modelling the cleanup action associated with a scope.\n-     *\/\n-    interface CleanupAction extends Runnable {\n-        void cleanup();\n-        CleanupAction dup();\n-        CleanupAction wrap(Runnable runnable);\n+    static class ScopeCleanable extends PhantomCleanable<MemoryScope> {\n+        final Cleaner cleaner;\n+        final Runnable cleanupAction;\n@@ -280,3 +293,4 @@\n-        @Override\n-        default void run() {\n-            cleanup();\n+        public ScopeCleanable(MemoryScope referent, Cleaner cleaner, Runnable cleanupAction) {\n+            super(referent, cleaner);\n+            this.cleaner = cleaner;\n+            this.cleanupAction = cleanupAction;\n@@ -285,107 +299,3 @@\n-        \/** Dummy cleanup action *\/\n-        CleanupAction DUMMY = new CleanupAction() {\n-            @Override\n-            public void cleanup() {\n-                \/\/ do nothing\n-            }\n-\n-            @Override\n-            public CleanupAction dup() {\n-                return this;\n-            }\n-\n-            @Override\n-            public CleanupAction wrap(Runnable runnable) {\n-                return AtMostOnceOnly.of(runnable);\n-            }\n-        };\n-\n-        \/**\n-         * A stateful cleanup action; this action can only be called at most once. The implementation\n-         * guarantees this invariant even when multiple threads race to call the {@link #cleanup()} method.\n-         *\/\n-        abstract class AtMostOnceOnly implements CleanupAction {\n-\n-            static final VarHandle CALLED;\n-\n-            static {\n-                try {\n-                    CALLED = MethodHandles.lookup().findVarHandle(AtMostOnceOnly.class, \"called\", boolean.class);\n-                } catch (Throwable ex) {\n-                    throw new ExceptionInInitializerError(ex);\n-                }\n-            }\n-\n-            private boolean called = false;\n-\n-            abstract void doCleanup();\n-\n-            public final void cleanup() {\n-                if (disable()) {\n-                    doCleanup();\n-                }\n-            };\n-\n-            @Override\n-            public CleanupAction dup() {\n-                disable();\n-                return new DupAction(this);\n-            }\n-\n-            @Override\n-            public CleanupAction wrap(Runnable runnable) {\n-                disable();\n-                return AtMostOnceOnly.of(() -> {\n-                    try {\n-                        runnable.run();\n-                    } catch (Throwable t) {\n-                        \/\/ ignore\n-                    } finally {\n-                        doCleanup();\n-                    }\n-                });\n-            }\n-\n-            \/\/where\n-            static class DupAction extends AtMostOnceOnly {\n-                final AtMostOnceOnly root;\n-\n-                DupAction(AtMostOnceOnly root) {\n-                    this.root = root;\n-                }\n-\n-                @Override\n-                void doCleanup() {\n-                    root.doCleanup();\n-                }\n-\n-                @Override\n-                public CleanupAction dup() {\n-                    disable();\n-                    return new DupAction(root);\n-                }\n-            }\n-\n-            final boolean disable() {\n-                \/\/ This can fail under normal circumstances. The only case where a failure can happen is when\n-                \/\/ when two cleaners race to cleanup the same scope. It is never possible to have a race\n-                \/\/ between explicit\/implicit close because all the scope terminal operations have\n-                \/\/ reachability fences which prevent a scope to be deemed unreachable before we are done\n-                \/\/ marking the original cleanup action as \"dead\".\n-                return CALLED.compareAndSet(this, false, true);\n-            }\n-\n-            \/**\n-             * Returns a custom {@code BasicCleanupAction} based on given {@link Runnable} instance.\n-             * @param runnable the runnable to be executed when {@link #cleanup()} is called on the returned cleanup action.\n-             * @return the new cleanup action.\n-             *\/\n-            static AtMostOnceOnly of(Runnable runnable) {\n-                Objects.requireNonNull(runnable);\n-                return new AtMostOnceOnly() {\n-                    @Override\n-                    void doCleanup() {\n-                        runnable.run();\n-                    }\n-                };\n-            }\n+        @Override\n+        protected void performCleanup() {\n+            cleanupAction.run();\n@@ -394,1 +304,0 @@\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryScope.java","additions":48,"deletions":139,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -44,2 +44,2 @@\n-    public static final MemorySegment EVERYTHING = makeNativeSegmentUnchecked(MemoryAddress.NULL, Long.MAX_VALUE, null)\n-            .withOwnerThread(null)\n+    public static final MemorySegment EVERYTHING = makeNativeSegmentUnchecked(MemoryAddress.NULL, Long.MAX_VALUE, MemoryScope.DUMMY_CLEANUP_ACTION, null)\n+            .share()\n@@ -101,3 +101,1 @@\n-        MemoryScope scope = MemoryScope.createConfined(null, new MemoryScope.CleanupAction.AtMostOnceOnly() {\n-            @Override\n-            void doCleanup() {\n+        MemoryScope scope = MemoryScope.createConfined(null, () -> {\n@@ -106,2 +104,1 @@\n-            }\n-        });\n+            }, null);\n@@ -117,1 +114,1 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, Object attachment) {\n+    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, Runnable cleanupAction, Object ref) {\n@@ -119,1 +116,1 @@\n-                MemoryScope.createConfined(attachment, MemoryScope.CleanupAction.DUMMY));\n+                MemoryScope.createConfined(ref, cleanupAction == null ? MemoryScope.DUMMY_CLEANUP_ACTION : cleanupAction, null));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run testng TestCleaner\n+ * @run testng\/othervm -Dforeign.restricted=permit TestCleaner\n@@ -33,1 +33,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -45,0 +44,1 @@\n+import java.util.stream.Stream;\n@@ -61,1 +61,1 @@\n-    public void test(int n, Supplier<Cleaner> cleanerFactory, SegmentFunction segmentFunction) {\n+    public void testAtMostOnce(RegisterKind registerKind, Supplier<Cleaner> cleanerFactory, SegmentFunction segmentFunction) {\n@@ -63,5 +63,9 @@\n-        MemorySegment segment = MemorySegment.allocateNative(10)\n-                .withCleanupAction(segmentState::cleanup);\n-        \/\/ register cleaners before\n-        for (int i = 0 ; i < n ; i++) {\n-            segment.registerCleaner(cleanerFactory.get());\n+        MemorySegment root = MemorySegment.allocateNative(10).share();\n+        MemorySegment segment = root.address().asSegmentRestricted(10, () -> {\n+            root.close();\n+            segmentState.cleanup();\n+        }, null);\n+\n+        if (registerKind == RegisterKind.BEFORE) {\n+            \/\/ register cleaners before\n+            segment = segment.registerCleaner(cleanerFactory.get());\n@@ -69,0 +73,3 @@\n+\n+        kickGCAndCheck(segmentState, segment);\n+\n@@ -70,5 +77,6 @@\n-        if (segment.isAlive()) {\n-            \/\/ also register cleaners after\n-            for (int i = 0; i < n; i++) {\n-                segment.registerCleaner(cleanerFactory.get());\n-            }\n+\n+        kickGCAndCheck(segmentState, segment);\n+\n+        if (segment.isAlive() && registerKind == RegisterKind.AFTER) {\n+            \/\/ register cleaners after\n+            segment = segment.registerCleaner(cleanerFactory.get());\n@@ -76,2 +84,2 @@\n-        \/\/check that cleanup has not been called by any cleaner yet!\n-        assertEquals(segmentState.cleanupCalls(), segment.isAlive() ? 0 : 1);\n+\n+        kickGCAndCheck(segmentState, segment);\n@@ -91,0 +99,27 @@\n+    private void kickGCAndCheck(SegmentState segmentState, MemorySegment segment) {\n+        for (int i = 0 ; i < 100 ; i++) {\n+            byte[] b = new byte[100];\n+            System.gc();\n+            Thread.onSpinWait();\n+        }\n+        \/\/check that cleanup has not been called by any cleaner yet!\n+        assertEquals(segmentState.cleanupCalls(), segment.isAlive() ? 0 : 1);\n+    }\n+\n+    @Test(dataProvider = \"segmentFunctions\")\n+    public void testBadDoubleRegister(Supplier<Cleaner> cleanerFactory, SegmentFunction segmentFunction) {\n+        MemorySegment segment = MemorySegment.allocateNative(10);\n+        segment = segment.registerCleaner(cleanerFactory.get());\n+        segment = segmentFunction.apply(segment);\n+        try {\n+            segment.registerCleaner(cleanerFactory.get()); \/\/ error here!\n+            fail();\n+        } catch (IllegalStateException ex) {\n+            if (!segment.isAlive()) {\n+                assertTrue(ex.getMessage().contains(\"This segment is already closed\"));\n+            } else {\n+                assertTrue(ex.getMessage().contains(\"Already registered with a cleaner\"));\n+            }\n+        }\n+    }\n+\n@@ -94,1 +129,1 @@\n-        SHARE(s -> { return s.withOwnerThread(null); });\n+        SHARE(s -> { return s.share(); });\n@@ -108,0 +143,25 @@\n+    @DataProvider\n+    static Object[][] segmentFunctions() {\n+        Supplier<?>[] cleaners = {\n+                (Supplier<Cleaner>)Cleaner::create,\n+                (Supplier<Cleaner>)CleanerFactory::cleaner\n+        };\n+\n+        SegmentFunction[] segmentFunctions = SegmentFunction.values();\n+        Object[][] data = new Object[cleaners.length * segmentFunctions.length][3];\n+\n+        for (int cleaner = 0 ; cleaner < cleaners.length ; cleaner++) {\n+            for (int segmentFunction = 0 ; segmentFunction < segmentFunctions.length ; segmentFunction++) {\n+                data[cleaner + (cleaners.length * segmentFunction)] =\n+                        new Object[] { cleaners[cleaner], segmentFunctions[segmentFunction] };\n+            }\n+        }\n+\n+        return data;\n+    }\n+\n+    enum RegisterKind {\n+        BEFORE,\n+        AFTER;\n+    }\n+\n@@ -115,1 +175,1 @@\n-        int[] ncleaners = { 1, 2, 4, 8, 16 };\n+        RegisterKind[] kinds = RegisterKind.values();\n@@ -118,1 +178,1 @@\n-        Object[][] data = new Object[cleaners.length * ncleaners.length * segmentFunctions.length][3];\n+        Object[][] data = new Object[cleaners.length * kinds.length * segmentFunctions.length][3];\n@@ -120,1 +180,1 @@\n-        for (int ncleaner = 0 ; ncleaner < ncleaners.length ; ncleaner++) {\n+        for (int kind = 0 ; kind < kinds.length ; kind++) {\n@@ -123,2 +183,2 @@\n-                    data[ncleaner + ncleaners.length * cleaner + (cleaners.length * ncleaners.length * segmentFunction)] =\n-                            new Object[] { ncleaners[ncleaner], cleaners[cleaner], segmentFunctions[segmentFunction] };\n+                    data[kind + kinds.length * cleaner + (cleaners.length * kinds.length * segmentFunction)] =\n+                            new Object[] { kinds[kind], cleaners[cleaner], segmentFunctions[segmentFunction] };\n","filename":"test\/jdk\/java\/foreign\/TestCleaner.java","additions":81,"deletions":21,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(SEGMENT_SIZE).withOwnerThread(null);\n+            MemorySegment segment = MemorySegment.allocateNative(SEGMENT_SIZE).share();\n@@ -148,1 +148,1 @@\n-            this.copy = MemorySegment.allocateNative(SEGMENT_SIZE).withOwnerThread(null);\n+            this.copy = MemorySegment.allocateNative(SEGMENT_SIZE).share();\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -170,2 +170,1 @@\n-        MemorySegment mallocSegment = addr.asSegmentRestricted(12)\n-                .withCleanupAction(() -> free(addr.toRawLongValue()));\n+        MemorySegment mallocSegment = addr.asSegmentRestricted(12, () -> free(addr.toRawLongValue()), null);\n@@ -188,2 +187,1 @@\n-        MemorySegment mallocSegment = addr.asSegmentRestricted(12)\n-                .withCleanupAction(() -> free(addr.toRawLongValue()));\n+        MemorySegment mallocSegment = addr.asSegmentRestricted(12, () -> free(addr.toRawLongValue()), null);\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -328,0 +328,2 @@\n+                \"handoff\",\n+                \"registerCleaner\",\n@@ -337,4 +339,1 @@\n-                \"toDoubleArray\",\n-                \"withOwnerThread\",\n-                \"registerCleaner\",\n-                \"withCleanupAction\"\n+                \"toDoubleArray\"\n@@ -398,1 +397,1 @@\n-                segment.withOwnerThread(null);\n+                segment.share();\n@@ -422,1 +421,1 @@\n-                segment.withOwnerThread(new Thread());\n+                segment.handoff(new Thread());\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.util.function.Consumer;\n@@ -61,1 +60,1 @@\n-                confined.set(confined.get().withOwnerThread(owner));\n+                confined.set(confined.get().handoff(owner));\n@@ -65,1 +64,1 @@\n-            confined.set(confined.get().withOwnerThread(t));\n+            confined.set(confined.get().handoff(t));\n@@ -79,1 +78,1 @@\n-        try (MemorySegment s = MemorySegment.allocateNative(layout).withOwnerThread(null)) {\n+        try (MemorySegment s = MemorySegment.allocateNative(layout).share()) {\n@@ -127,2 +126,1 @@\n-            MemorySegment sharedSegment = s.address().asSegmentRestricted(s.byteSize())\n-                    .withOwnerThread(null);\n+            MemorySegment sharedSegment = s.address().asSegmentRestricted(s.byteSize()).share();\n@@ -145,5 +143,0 @@\n-    @Test(expectedExceptions=IllegalArgumentException.class)\n-    public void testBadHandoffSameThread() {\n-        MemorySegment.ofArray(new int[4]).withOwnerThread(Thread.currentThread());\n-    }\n-\n@@ -153,8 +146,1 @@\n-            .withAccessModes(MemorySegment.CLOSE).withOwnerThread(new Thread());\n-    }\n-\n-    @Test(expectedExceptions=IllegalStateException.class)\n-    public void testBadShareAlreadyShared() {\n-        MemorySegment.ofArray(new int[4])\n-                .withOwnerThread(null)\n-                .withOwnerThread(null);\n+            .withAccessModes(MemorySegment.CLOSE).handoff(new Thread());\n@@ -166,26 +152,1 @@\n-                .withAccessModes(MemorySegment.CLOSE).withOwnerThread(null);\n-    }\n-\n-    private void withAcquired(Consumer<MemorySegment> acquiredAction) {\n-        CountDownLatch holder = new CountDownLatch(1);\n-        MemorySegment segment = MemorySegment.allocateNative(16).withOwnerThread(null);\n-        Spliterator<MemorySegment> spliterator = MemorySegment.spliterator(segment,\n-                MemoryLayout.ofSequence(16, MemoryLayouts.JAVA_BYTE));\n-        CountDownLatch acquired = new CountDownLatch(1);\n-        Runnable r = () -> spliterator.tryAdvance(s -> {\n-            try {\n-                acquired.countDown();\n-                holder.await();\n-            } catch (InterruptedException ex) {\n-                throw new AssertionError(ex);\n-            }\n-        });\n-        new Thread(r).start();\n-        try {\n-            acquired.await();\n-            acquiredAction.accept(segment);\n-        } catch (InterruptedException ex) {\n-            throw new AssertionError(ex);\n-        } finally {\n-            holder.countDown();\n-        }\n+                .withAccessModes(MemorySegment.CLOSE).share();\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":6,"deletions":45,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout).withOwnerThread(null);\n+        MemorySegment segment = MemorySegment.allocateNative(layout).share();\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE).withOwnerThread(null);\n+        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE).share();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNew.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,2 +74,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE)\n-                .withOwnerThread(null);\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE).share();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantShared.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -88,2 +88,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE)\n-                .withOwnerThread(null);\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE).share();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/ParallelSum.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}