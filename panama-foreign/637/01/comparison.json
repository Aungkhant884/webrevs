{"files":[{"patch":"@@ -73,1 +73,0 @@\n-  jobject _exception;\n@@ -78,1 +77,1 @@\n-  CloseScopedMemoryClosure(jobject deopt, jobject exception)\n+  CloseScopedMemoryClosure(jobject deopt)\n@@ -81,1 +80,0 @@\n-    , _exception(exception)\n@@ -150,2 +148,2 @@\n-JVM_ENTRY(jboolean, ScopedMemoryAccess_closeScope(JNIEnv *env, jobject receiver, jobject deopt, jobject exception))\n-  CloseScopedMemoryClosure cl(deopt, exception);\n+JVM_ENTRY(jboolean, ScopedMemoryAccess_closeScope(JNIEnv *env, jobject receiver, jobject deopt))\n+  CloseScopedMemoryClosure cl(deopt);\n@@ -163,1 +161,0 @@\n-#define SCOPED_ERR PKG_MISC MEMACCESS \"$ScopedAccessError;\"\n@@ -169,1 +166,1 @@\n-    {CC \"closeScope0\",   CC \"(\" SCOPE SCOPED_ERR \")Z\",           FN_PTR(ScopedMemoryAccess_closeScope)},\n+    {CC \"closeScope0\",   CC \"(\" SCOPE \")Z\",           FN_PTR(ScopedMemoryAccess_closeScope)},\n@@ -179,1 +176,0 @@\n-#undef SCOPED_ERR\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -82,2 +82,1 @@\n- *     <li>native symbols {@linkplain SymbolLookup#lookup(String) obtained} from a {@linkplain SymbolLookup#loaderLookup() loader lookup},\n- *     or from the {@link CLinker}.<\/li>\n+ *     <li>native symbols obtained from {@linkplain ClassLoader#findNative(String)}, or from {@link CLinker#lookup(String)}.<\/li>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ResourceScope.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * The main abstraction introduced to support foreign memory access is {@link jdk.incubator.foreign.MemorySegment}, which\n+ * The main abstraction introduced to support foreign memory access is {@link java.lang.foreign.MemorySegment}, which\n@@ -100,4 +100,4 @@\n- * The key abstractions introduced to support foreign function access are {@link java.lang.foreign.SymbolLookup},\n- * {@link java.lang.foreign.MemoryAddress} and {@link java.lang.foreign.CLinker}.\n- * The first is used to look up symbols inside native libraries; the second is used to model native addresses (more on that later),\n- * while the third provides linking capabilities which allows modelling foreign functions as {@link java.lang.invoke.MethodHandle} instances,\n+ * The key abstractions introduced to support foreign function access are {@link java.lang.foreign.MemoryAddress} and\n+ * {@link java.lang.foreign.CLinker}.\n+ * The first is used to model native addresses (more on that later), while the second provides linking capabilities\n+ * which allows modelling foreign functions as {@link java.lang.invoke.MethodHandle} instances,\n@@ -220,1 +220,1 @@\n- * the restricted method {@link MemorySegment#ofAddress(MemoryAddress, long, ResourceScope)}\n+ * the restricted method {@link java.lang.foreign.MemorySegment#ofAddress(MemoryAddress, long, ResourceScope)}\n@@ -224,1 +224,1 @@\n- * For instance, in the case of {@link MemorySegment#ofAddress(MemoryAddress, long, ResourceScope)},\n+ * For instance, in the case of {@link java.lang.foreign.MemorySegment#ofAddress(MemoryAddress, long, ResourceScope)},\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-        return closeScope0(scope, ScopedAccessError.INSTANCE);\n+        return closeScope0(scope);\n@@ -91,1 +91,1 @@\n-    native boolean closeScope0(ResourceScope scope, ScopedAccessError exception);\n+    native boolean closeScope0(ResourceScope scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}