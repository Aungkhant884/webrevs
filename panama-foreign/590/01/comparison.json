{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -204,0 +205,1 @@\n+        @ForceInline\n@@ -209,0 +211,1 @@\n+        @ForceInline\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ResourceScopeImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+import java.util.ArrayList;\n@@ -64,0 +65,1 @@\n+import java.util.function.UnaryOperator;\n@@ -72,1 +74,1 @@\n-import static java.lang.invoke.MethodHandles.filterArguments;\n+import static java.lang.invoke.MethodHandles.foldArguments;\n@@ -124,1 +126,1 @@\n-                    MethodType.methodType(Addressable.class, Addressable.class));\n+                    MethodType.methodType(void.class, Scoped[].class));\n@@ -126,1 +128,1 @@\n-                    MethodType.methodType(void.class, Addressable.class));\n+                    MethodType.methodType(void.class, Scoped[].class));\n@@ -412,3 +414,78 @@\n-    public static Addressable acquire(Addressable addressable) {\n-        ((ResourceScopeImpl)((Scoped)addressable).scope()).acquire0();\n-        return addressable;\n+    @SuppressWarnings(\"fallthrough\")\n+    public static void acquire(Scoped[] args) {\n+        ResourceScope scope4 = null;\n+        ResourceScope scope3 = null;\n+        ResourceScope scope2 = null;\n+        ResourceScope scope1 = null;\n+        ResourceScope scope0 = null;\n+        switch (args.length) {\n+            \/\/ fast path, acquire only scopes not seen in other parameters\n+            case 5:\n+                scope4 = args[4].scope();\n+                acquire(scope4);\n+            case 4:\n+                scope3 = args[3].scope();\n+                if (scope3 != scope4)\n+                    acquire(scope3);\n+            case 3:\n+                scope2 = args[2].scope();\n+                if (scope2 != scope3 && scope2 != scope4)\n+                    acquire(scope2);\n+            case 2:\n+                scope1 = args[1].scope();\n+                if (scope1 != scope2 && scope1 != scope3 && scope1 != scope4)\n+                    acquire(scope1);\n+            case 1:\n+                scope0 = args[0].scope();\n+                if (scope0 != scope1 && scope0 != scope2 && scope0 != scope3 && scope0 != scope4)\n+                    acquire(scope0);\n+            case 0: break;\n+            \/\/ slow path, acquire all remaining addressable parameters in isolation\n+            default:\n+                for (int i = 5 ; i < args.length ; i++) {\n+                    acquire(args[i].scope());\n+                }\n+        }\n+    }\n+\n+    @ForceInline\n+    @SuppressWarnings(\"fallthrough\")\n+    public static void release(Scoped[] args) {\n+        ResourceScope scope4 = null;\n+        ResourceScope scope3 = null;\n+        ResourceScope scope2 = null;\n+        ResourceScope scope1 = null;\n+        ResourceScope scope0 = null;\n+        switch (args.length) {\n+            \/\/ fast path, release only scopes not seen in other parameters\n+            case 5:\n+                scope4 = args[4].scope();\n+                release(scope4);\n+            case 4:\n+                scope3 = args[3].scope();\n+                if (scope3 != scope4)\n+                    release(scope3);\n+            case 3:\n+                scope2 = args[2].scope();\n+                if (scope2 != scope3 && scope2 != scope4)\n+                    release(scope2);\n+            case 2:\n+                scope1 = args[1].scope();\n+                if (scope1 != scope2 && scope1 != scope3 && scope1 != scope4)\n+                    release(scope1);\n+            case 1:\n+                scope0 = args[0].scope();\n+                if (scope0 != scope1 && scope0 != scope2 && scope0 != scope3 && scope0 != scope4)\n+                    release(scope0);\n+            case 0: break;\n+            \/\/ slow path, release all remaining addressable parameters in isolation\n+            default:\n+                for (int i = 5 ; i < args.length ; i++) {\n+                    release(args[i].scope());\n+                }\n+        }\n+    }\n+\n+    @ForceInline\n+    private static void acquire(ResourceScope scope) {\n+        ((ResourceScopeImpl)scope).acquire0();\n@@ -418,2 +495,2 @@\n-    public static void release(Addressable addressable) {\n-        ((ResourceScopeImpl)((Scoped)addressable).scope()).release0();\n+    private static void release(ResourceScope scope) {\n+        ((ResourceScopeImpl)scope).release0();\n@@ -429,1 +506,0 @@\n-        boolean hasAllocator = hasReturn && descriptor.returnLayout().get() instanceof GroupLayout;\n@@ -434,10 +510,6 @@\n-        for (int i = 0 ; i < descriptor.argumentLayouts().size() ; i++) {\n-            int paramIndex = i + (hasAllocator ? 2 : 1); \/\/ skip Addressable, and SegmentAllocator (if present)\n-            int cleanupIndex = i + (hasReturn ? 1 : 0); \/\/ skip Throwable and result (if present), and Addressable\n-            MemoryLayout layout = descriptor.argumentLayouts().get(i);\n-            Class<?> carrier = downcallHandle.type().parameterType(paramIndex);\n-            if (layout instanceof ValueLayout valueLayout && valueLayout.carrier() == MemoryAddress.class) {\n-                \/\/ add acquire filter\n-                tryBlock = filterArguments(tryBlock, paramIndex, ACQUIRE_MH);\n-                \/\/ add cleanup filter\n-                cleanup = collectArguments(cleanup, cleanupIndex, RELEASE_MH);\n+        int addressableCount = 0;\n+        List<UnaryOperator<MethodHandle>> adapters = new ArrayList<>();\n+        for (int i = 0 ; i < downcallHandle.type().parameterCount() ; i++) {\n+            Class<?> ptype = downcallHandle.type().parameterType(i);\n+            if (ptype == Addressable.class) {\n+                addressableCount++;\n@@ -445,1 +517,2 @@\n-                cleanup = dropArguments(cleanup, cleanupIndex, carrier);\n+                int pos = i;\n+                adapters.add(mh -> dropArguments(mh, pos, ptype));\n@@ -448,8 +521,24 @@\n-        cleanup = dropArguments(cleanup, 0, Throwable.class);\n-        \/\/ acquire\/release target addressable\n-        tryBlock = filterArguments(tryBlock, 0, ACQUIRE_MH);\n-        cleanup = collectArguments(cleanup, hasReturn ? 2 : 1, RELEASE_MH);\n-        \/\/ fixup allocator\n-        if (hasAllocator) {\n-            \/\/ cleanup always has a result here, of type MemorySegment\n-            cleanup = dropArguments(cleanup, 3, SegmentAllocator.class);\n+\n+        if (addressableCount > 0) {\n+            cleanup = dropArguments(cleanup, 0, Throwable.class);\n+\n+            MethodType adapterType = MethodType.methodType(void.class);\n+            for (int i = 0 ; i < addressableCount ; i++) {\n+                adapterType = adapterType.appendParameterTypes(Addressable.class);\n+            }\n+\n+            MethodHandle acquireHandle = ACQUIRE_MH.asCollector(Scoped[].class, addressableCount).asType(adapterType);\n+            MethodHandle releaseHandle = RELEASE_MH.asCollector(Scoped[].class, addressableCount).asType(adapterType);\n+\n+            for (UnaryOperator<MethodHandle> adapter : adapters) {\n+                acquireHandle = adapter.apply(acquireHandle);\n+                releaseHandle = adapter.apply(releaseHandle);\n+            }\n+\n+            \/\/ acquire\/release target addressable\n+            tryBlock = foldArguments(tryBlock, acquireHandle);\n+            cleanup = collectArguments(cleanup, hasReturn ? 2 : 1, releaseHandle);\n+\n+            return tryFinally(tryBlock, cleanup);\n+        } else {\n+            return downcallHandle;\n@@ -457,1 +546,0 @@\n-        return tryFinally(tryBlock, cleanup);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":117,"deletions":29,"binary":false,"changes":146,"status":"modified"}]}