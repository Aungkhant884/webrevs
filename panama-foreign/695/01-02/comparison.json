{"files":[{"patch":"@@ -1875,55 +1875,0 @@\n-    \/**\n-     * Returns a Stream of human-readable, lines with hexadecimal values for this memory segment.\n-     * <p>\n-     * Each element in the stream comprises the following characters:\n-     * <ol>\n-     *     <li>an initial 64-bit offset (e.g. \"0000000000000010\").<\/li>\n-     *     <li>a sequence of two spaces (i.e. \"  \").<\/li>\n-     *     <li>a sequence of at most eight bytes (e.g. \"66 6F 78 20 6A 75 6D 70\") where\n-     *     each byte is separated by a space.<\/li>\n-     *     <li>a sequence of two spaces (i.e. \"  \").<\/li>\n-     *     <li>a sequence of at most eight bytes (e.g. \"65 64 20 6F 76 65 72 20\") where\n-     *     each byte separated by a space.<\/li>\n-     *     <li>a sequence of N spaces (i.e. \"  \") such that the intermediate line is aligned to 68 characters<\/li>\n-     *     <li>a \"|\" separator.<\/li>\n-     *     <li>a sequence of at most 16 printable Ascii characters (values outside [32, 127] will be printed as \".\").<\/li>\n-     *     <li>a \"|\" separator.<\/li>\n-     * <\/ol>\n-     * All the values above are given in hexadecimal form with leading zeros. As there are at most 16 bytes\n-     * rendered for each line, there will be N = ({@link #byteSize()} + 15) \/ 16 elements in the returned stream.\n-     * <p>\n-     * As a consequence of the above, this method renders to a format similar to the *nix command \"hexdump -C\".\n-     * <p>\n-     * As an example, a memory segment created, initialized and used as follows\n-     * {@snippet lang = java:\n-     *   MemorySegment memorySegment = memorySession.allocate(64 + 4);\n-     *   memorySegment.setUtf8String(0, \"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\");\n-     *   memorySegment.hexDump()\n-     *       .forEach(System.out::println);\n-     *}\n-     * will be printed as:\n-     * {@snippet lang = text:\n-     * 0000000000000000  54 68 65 20 71 75 69 63  6B 20 62 72 6F 77 6E 20  |The quick brown |\n-     * 0000000000000010  66 6F 78 20 6A 75 6D 70  65 64 20 6F 76 65 72 20  |fox jumped over |\n-     * 0000000000000020  74 68 65 20 6C 61 7A 79  20 64 6F 67 0A 53 65 63  |the lazy dog.Sec|\n-     * 0000000000000030  6F 6E 64 20 6C 69 6E 65  09 3A 68 65 72 65 00 00  |ond line.:here..|\n-     * 0000000000000040  00 00 00 00                                       |....|\n-     *}\n-     * <p>\n-     * Use a {@linkplain MemorySegment#asSlice(long, long) slice} to inspect a specific region\n-     * of a memory segment.\n-     * <p>\n-     * This method can be used to dump the contents of various other memory containers such as\n-     * {@linkplain ByteBuffer ByteBuffers} and byte arrays by means of first wrapping the container\n-     * into a MemorySegment:\n-     * {@snippet lang = java:\n-     *   MemorySegment.ofArray(byteArray).hexDump();\n-     *   MemorySegment.ofBuffer(byteBuffer).hexDump();\n-     *}\n-     *\n-     * @return a Stream of human-readable, lines with hexadecimal values\n-     *\/\n-    default Stream<String> hexDump() {\n-        return MemorySegmentRenderUtil.hexStream(this);\n-    }\n-\n@@ -1932,1 +1877,1 @@\n-     * the provided memory layout {@code memoryLayout}.\n+     * the provided {@code memoryLayout}.\n@@ -1936,1 +1881,1 @@\n-     *     <li>tag\/value pairs are separated with \"=\"<\/li>\n+     *     <li>tag\/value pairs are separated with an \"=\" character.<\/li>\n@@ -1943,1 +1888,1 @@\n-     *             <li>Char values are rendered as chars.<\/li>\n+     *             <li>Character values are rendered as {@code char}.<\/li>\n@@ -1948,2 +1893,2 @@\n-     *     <li>Structure and sequence elements are separated with \",\".<\/li>\n-     *     <li>Union elements are separated with \"|\".<\/li>\n+     *     <li>Structure and sequence elements are separated with a \",\" character.<\/li>\n+     *     <li>Union elements are separated with a \"|\" character.<\/li>\n@@ -1952,1 +1897,0 @@\n-     * Lines are separated with the system-dependent line separator {@link System#lineSeparator() }.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":5,"deletions":61,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.ByteBuffer;\n@@ -52,1 +53,1 @@\n-     * Returns a Stream of human-readable, lines with hexadecimal values for the provided {@code memorySegment}.\n+     * Returns a Stream of human-readable, lines with hexadecimal values for this memory segment.\n@@ -54,3 +55,16 @@\n-     * The exact format of the stream elements is unspecified and should not\n-     * be acted upon programmatically. Loosely speaking, this method renders\n-     * a format similar to the *nix command \"hexdump -C\".\n+     * Each element in the stream comprises the following characters:\n+     * <ol>\n+     *     <li>an initial 64-bit offset (e.g. \"0000000000000010\").<\/li>\n+     *     <li>a sequence of two spaces (i.e. \"  \").<\/li>\n+     *     <li>a sequence of at most eight bytes (e.g. \"66 6F 78 20 6A 75 6D 70\") where\n+     *     each byte is separated by a space.<\/li>\n+     *     <li>a sequence of two spaces (i.e. \"  \").<\/li>\n+     *     <li>a sequence of at most eight bytes (e.g. \"65 64 20 6F 76 65 72 20\") where\n+     *     each byte separated by a space.<\/li>\n+     *     <li>a sequence of N spaces (i.e. \"  \") such that the intermediate line is aligned to 68 characters<\/li>\n+     *     <li>a \"|\" separator.<\/li>\n+     *     <li>a sequence of at most 16 printable Ascii characters (values outside [32, 127] will be printed as \".\").<\/li>\n+     *     <li>a \"|\" separator.<\/li>\n+     * <\/ol>\n+     * All the values above are given in hexadecimal form with leading zeros. As there are at most 16 bytes\n+     * rendered for each line, there will be N = ({@link MemorySegment#byteSize()} + 15) \/ 16 elements in the returned stream.\n@@ -58,1 +72,3 @@\n-     * As an example, a MemorySegment created and initialized as follows\n+     * As a consequence of the above, this method renders to a format similar to the *nix command \"hexdump -C\".\n+     * <p>\n+     * As an example, a memory segment created, initialized and used as follows\n@@ -60,4 +76,4 @@\n-     * MemorySegment memorySegment = memorySession.allocate(64 + 4);\n-     * memorySegment.setUtf8String(0, \"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\");\n-     * hexStream(memorySegment)\n-     *     .forEach(System.out::println);\n+     *   MemorySegment memorySegment = memorySession.allocate(64 + 4);\n+     *   memorySegment.setUtf8String(0, \"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\");\n+     *   memorySegment.hexDump()\n+     *       .forEach(System.out::println);\n@@ -65,1 +81,1 @@\n-     * might print to something like this:\n+     * will be printed as:\n@@ -76,2 +92,9 @@\n-     *\n-     * @param memorySegment the memory segment to generate hexadecimal values from\n+     * <p>\n+     * This method can be used to dump the contents of various other memory containers such as\n+     * {@linkplain ByteBuffer ByteBuffers} and byte arrays by means of first wrapping the container\n+     * into a MemorySegment:\n+     * {@snippet lang = java:\n+     *   MemorySegment.ofArray(byteArray).hexDump();\n+     *   MemorySegment.ofBuffer(byteBuffer).hexDump();\n+     *}\n+     * @param memorySegment to inspect\n@@ -80,1 +103,1 @@\n-    public static Stream<String> hexStream(MemorySegment memorySegment) {\n+    public static Stream<String> hexDump(MemorySegment memorySegment) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySegmentRenderUtil.java","additions":36,"deletions":13,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.util.Objects;\n@@ -38,3 +37,0 @@\n-import java.util.stream.Collectors;\n-\n-import java.lang.foreign.*;\n@@ -68,1 +64,1 @@\n-            return hexStream(segment)\n+            return hexDump(segment)\n","filename":"test\/jdk\/java\/foreign\/RenderTest.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"}]}