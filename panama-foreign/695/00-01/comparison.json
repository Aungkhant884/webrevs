{"files":[{"patch":"@@ -1878,3 +1878,18 @@\n-     * The exact format of the stream elements is unspecified and should not\n-     * be acted upon programmatically. Loosely speaking, this method renders\n-     * a format similar to the *nix command \"hexdump -C\".\n+     * Each element in the stream comprises the following characters:\n+     * <ol>\n+     *     <li>an initial 64-bit offset (e.g. \"0000000000000010\").<\/li>\n+     *     <li>a sequence of two spaces (i.e. \"  \").<\/li>\n+     *     <li>a sequence of at most eight bytes (e.g. \"66 6F 78 20 6A 75 6D 70\") where\n+     *     each byte is separated by a space.<\/li>\n+     *     <li>a sequence of two spaces (i.e. \"  \").<\/li>\n+     *     <li>a sequence of at most eight bytes (e.g. \"65 64 20 6F 76 65 72 20\") where\n+     *     each byte separated by a space.<\/li>\n+     *     <li>a sequence of N spaces (i.e. \"  \") such that the intermediate line is aligned to 68 characters<\/li>\n+     *     <li>a \"|\" separator.<\/li>\n+     *     <li>a sequence of at most 16 printable Ascii characters (values outside [32, 127] will be printed as \".\").<\/li>\n+     *     <li>a \"|\" separator.<\/li>\n+     * <\/ol>\n+     * All the values above are given in hexadecimal form with leading zeros. As there are at most 16 bytes\n+     * rendered for each line, there will be N = ({@link #byteSize()} + 15) \/ 16 elements in the returned stream.\n+     * <p>\n+     * As a consequence of the above, this method renders to a format similar to the *nix command \"hexdump -C\".\n@@ -1884,4 +1899,4 @@\n-     * MemorySegment memorySegment = memorySession.allocate(64 + 4);\n-     * memorySegment.setUtf8String(0, \"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\");\n-     * memorySegment.hexStream()\n-     *     .forEach(System.out::println);\n+     *   MemorySegment memorySegment = memorySession.allocate(64 + 4);\n+     *   memorySegment.setUtf8String(0, \"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\");\n+     *   memorySegment.hexDump()\n+     *       .forEach(System.out::println);\n@@ -1889,1 +1904,1 @@\n-     * might print to something like this:\n+     * will be printed as:\n@@ -1900,0 +1915,8 @@\n+     * <p>\n+     * This method can be used to dump the contents of various other memory containers such as\n+     * {@linkplain ByteBuffer ByteBuffers} and byte arrays by means of first wrapping the container\n+     * into a MemorySegment:\n+     * {@snippet lang = java:\n+     *   MemorySegment.ofArray(byteArray).hexDump();\n+     *   MemorySegment.ofBuffer(byteBuffer).hexDump();\n+     *}\n@@ -1903,1 +1926,1 @@\n-    default Stream<String> hexStream() {\n+    default Stream<String> hexDump() {\n@@ -1909,1 +1932,1 @@\n-     * the provided memory layout {@code lens}.\n+     * the provided memory layout {@code memoryLayout}.\n@@ -1911,0 +1934,18 @@\n+     * The format of the returned view is as follows:\n+     * <ol>\n+     *     <li>tag\/value pairs are separated with \"=\"<\/li>\n+     *     <li>Each element is tagged with its {@link MemoryLayout#name()} or, if no name exists,\n+     *     its {@link MemoryLayout#toString()} representation.<\/li>\n+     *     <li> Values are rendered differently depending on their type:\n+     *         <ul>\n+     *             <li>Numeric values are rendered in decimal form (e.g 1 or 1.2).<\/li>\n+     *             <li>Boolean values are rendered as {@code true} or {@code false}.<\/li>\n+     *             <li>Char values are rendered as chars.<\/li>\n+     *             <li>Address values are rendered according to their {@code toString()} values.<\/li>\n+     *         <\/ul>\n+     *     <\/li>\n+     *     <li>Grouped layouts are enclosed in curly brackets.<\/li>\n+     *     <li>Structure and sequence elements are separated with \",\".<\/li>\n+     *     <li>Union elements are separated with \"|\".<\/li>\n+     *     <li>Lines are separated with the system-dependent line separator {@link System#lineSeparator() }.<\/li>\n+     * <\/ol>\n@@ -1915,1 +1956,1 @@\n-     * As an example, a memory segment viewed though the following memory layout lens\n+     * As an example, a memory segment viewed though the following memory layout memoryLayout\n@@ -1917,4 +1958,9 @@\n-     * var lens = MemoryLayout.structLayout(\n-     *         ValueLayout.JAVA_INT.withName(\"x\"),\n-     *         ValueLayout.JAVA_INT.withName(\"y\")\n-     * ).withName(\"Point\");\n+     *   memorySegment.set(ValueLayout.JAVA_INT, 0, 1);\n+     *   memorySegment.set(ValueLayout.JAVA_INT, 4, 2);\n+     *\n+     *    var memoryLayout = MemoryLayout.structLayout(\n+     *           ValueLayout.JAVA_INT.withName(\"x\"),\n+     *           ValueLayout.JAVA_INT.withName(\"y\")\n+     *   ).withName(\"Point\");\n+     *\n+     *   System.out.println(memorySegment.toString(memoryLayout));\n@@ -1922,1 +1968,1 @@\n-     * might be rendered to something like this:\n+     * will print:\n@@ -1929,3 +1975,0 @@\n-     * <p>\n-     * This method is intended to view memory segments through small and medium-sized memory layout\n-     * lenses and is, in all cases, restricted by the inherent String capacity limit.\n@@ -1933,3 +1976,4 @@\n-     * @param lens  to use as a lens when viewing the memory segment\n-     * @return a view of the memory segment viewed through a memory layout lens\n-     * @throws OutOfMemoryError if the view exceeds the array size VM limit\n+     * @param memoryLayout  to use as a memoryLayout when viewing the memory segment\n+     * @return a view of the memory segment viewed through a memory layout memoryLayout\n+     * @throws OutOfMemoryError if the size of the UTF-8 string is greater than the largest string\n+     *         supported by the platform.\n@@ -1937,3 +1981,3 @@\n-    default String viewThrough(MemoryLayout lens) {\n-        Objects.requireNonNull(lens);\n-        return MemorySegmentRenderUtil.viewThrough(this, lens);\n+    default String toString(MemoryLayout memoryLayout) {\n+        Objects.requireNonNull(memoryLayout);\n+        return MemorySegmentRenderUtil.viewThrough(this, memoryLayout);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":69,"deletions":25,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-public final class PaddingLayout extends AbstractLayout implements MemoryLayout {\n+\/* package-private *\/ final class PaddingLayout extends AbstractLayout implements MemoryLayout {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/PaddingLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-     * the provided {@code lens}.\n+     * the provided {@code memoryLayout}.\n@@ -119,1 +119,1 @@\n-     * var lens = MemoryLayout.structLayout(\n+     * var memoryLayout = MemoryLayout.structLayout(\n@@ -136,1 +136,1 @@\n-     * @param lens  to use as a lens when viewing the memory segment\n+     * @param memoryLayout  to use as a memoryLayout when viewing the memory segment\n@@ -141,1 +141,1 @@\n-                                     MemoryLayout lens) {\n+                                     MemoryLayout memoryLayout) {\n@@ -143,1 +143,1 @@\n-        requireNonNull(lens);\n+        requireNonNull(memoryLayout);\n@@ -152,1 +152,1 @@\n-        renderView(memorySegment, lens, action, new ViewState(), \"\");\n+        renderView(memorySegment, memoryLayout, action, new ViewState(), \"\");\n@@ -200,3 +200,4 @@\n-        if (memoryLayout instanceof PaddingLayout paddingLayout) {\n-            action.accept(state.indentSpaces() + paddingLayout.bitSize() + \" padding bits\");\n-            state.indexAndAdd(paddingLayout);\n+        \/\/ PaddingLayout is package private.\n+        if (\"java.lang.foreign.PaddingLayout\".equals(memoryLayout.getClass().getName())) {\n+            action.accept(state.indentSpaces() + memoryLayout.bitSize() + \" padding bits\");\n+            state.indexAndAdd(memoryLayout);\n@@ -367,1 +368,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySegmentRenderUtil.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n@@ -42,0 +44,1 @@\n+import static java.util.stream.Collectors.joining;\n@@ -49,3 +52,5 @@\n-    @Test\n-    public void testHexStream() {\n-        var expect = platformLineSeparated(\"\"\"\n+    private static final int HEX_SEGMENT_SIZE = 64 + 4;\n+    private static final String THE_QUICK = \"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\";\n+\n+    private static final byte[] THE_QUICK_ARRAY = THE_QUICK.getBytes(StandardCharsets.UTF_8);\n+    private static final String EXPECTED_HEX = platformLineSeparated(\"\"\"\n@@ -58,2 +63,5 @@\n-        var actual = testWithFreshMemorySegment(64 + 4, segment -> {\n-            segment.setUtf8String(0, \"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\");\n+    @Test\n+    public void testHexStream() {\n+\n+        var actual = testWithFreshMemorySegment(HEX_SEGMENT_SIZE, segment -> {\n+            segment.setUtf8String(0, THE_QUICK);\n@@ -61,1 +69,1 @@\n-                    .collect(Collectors.joining(System.lineSeparator()));\n+                    .collect(joining(System.lineSeparator()));\n@@ -63,1 +71,1 @@\n-        assertEquals(expect, actual);\n+        assertEquals(EXPECTED_HEX, actual);\n@@ -66,0 +74,25 @@\n+    @Test\n+    public void testHexStreamByteArray() {\n+\n+        var array = new byte[HEX_SEGMENT_SIZE];\n+        System.arraycopy(THE_QUICK_ARRAY, 0, array, 0, THE_QUICK.length());\n+        var actual = MemorySegment.ofArray(array)\n+                .hexDump()\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(EXPECTED_HEX, actual);\n+    }\n+\n+    @Test\n+    public void testHexStreamByteBuffer() {\n+\n+        var array = new byte[HEX_SEGMENT_SIZE];\n+        System.arraycopy(THE_QUICK_ARRAY, 0, array, 0, THE_QUICK.length());\n+        var actual = MemorySegment.ofBuffer(ByteBuffer.wrap(array))\n+                .hexDump()\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(EXPECTED_HEX, actual);\n+    }\n+\n+\n@@ -216,1 +249,1 @@\n-                .collect(Collectors.joining(System.lineSeparator()));\n+                .collect(joining(System.lineSeparator()));\n","filename":"test\/jdk\/java\/foreign\/RenderTest.java","additions":41,"deletions":8,"binary":false,"changes":49,"status":"modified"}]}