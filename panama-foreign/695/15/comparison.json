{"files":[{"patch":"@@ -0,0 +1,206 @@\n+package java.lang.foreign;\n+\n+import jdk.internal.foreign.MemoryInspectionUtil;\n+\n+import java.util.stream.Stream;\n+\n+import static java.util.Objects.requireNonNull;\n+import static jdk.internal.foreign.MemoryInspectionUtil.*;\n+\n+\/**\n+ * Class that supports inspection of various memory abstractions such as memory of type\n+ * MemorySegment, ByteBuffer and byte arrays.\n+ * <p>\n+ * The methods in this class are not thread safe.\n+ *\/\n+public final class MemoryInspection {\n+\n+    \/\/ Suppresses default constructor, ensuring non-instantiability.\n+    private MemoryInspection() {\n+    }\n+\n+    \/**\n+     * Returns a human-readable view of the provided {@linkplain MemorySegment memory} viewed\n+     * through the provided {@code layout} using the provided {@linkplain ValueLayoutRenderer renderer}.\n+     * <p>\n+     * The exact format of the returned view is unspecified and should not\n+     * be acted upon programmatically.\n+     * <p>\n+     * As an example, a MemorySegment viewed though the following memory layout\n+     * {@snippet lang = java:\n+     * var layout = MemoryLayout.structLayout(\n+     *         ValueLayout.JAVA_INT.withName(\"x\"),\n+     *         ValueLayout.JAVA_INT.withName(\"y\")\n+     * ).withName(\"Point\");\n+     *\n+     * MemoryInspection.inspect(segment, layout, ValueLayoutRenderer.standard())\n+     *     .forEach(System.out::println);\n+     *\n+     *}\n+     * might be rendered to something like this:\n+     * {@snippet lang = text:\n+     * Point {\n+     *   x=1,\n+     *   y=2\n+     * }\n+     *}\n+     * <p>\n+     * This method is intended to view memory segments through small and medium-sized memory layouts.\n+     *\n+     * @param segment  to be viewed\n+     * @param layout   to use as a layout when viewing the memory segment\n+     * @param renderer to apply when rendering value layouts\n+     * @return a view of the memory abstraction viewed through the memory layout\n+     *\/\n+    public static Stream<String> inspect(MemorySegment segment,\n+                                         MemoryLayout layout,\n+                                         ValueLayoutRenderer renderer) {\n+        requireNonNull(segment);\n+        requireNonNull(layout);\n+        requireNonNull(renderer);\n+        return MemoryInspectionUtil.inspect(segment, layout, renderer);\n+    }\n+\n+    \/**\n+     * An interface that can be used to specify custom rendering of value\n+     * layouts via the {@link MemoryInspection#inspect(MemorySegment, MemoryLayout, ValueLayoutRenderer)} method.\n+     * <p>\n+     * The render methods take two parameters:\n+     * <ul>\n+     *     <li>layout: This can be used to select different formatting for different paths<\/li>\n+     *     <li>value: The actual value<\/li>\n+     * <\/ul>\n+     * <p>\n+     * The {@linkplain ValueLayoutRenderer#standard() standard() } value layout renderer is path\n+     * agnostic and will thus render all layouts of the same type the same way.\n+     *\n+     * @see MemoryInspection#inspect(MemorySegment, MemoryLayout, ValueLayoutRenderer)\n+     *\/\n+    public interface ValueLayoutRenderer {\n+        \/**\n+         * Renders the provided {@code booleanLayout} and {@code value} to a String.\n+         *\n+         * @param booleanLayout the layout to render\n+         * @param value         the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfBoolean booleanLayout, boolean value) {\n+            requireNonNull(booleanLayout);\n+            return Boolean.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code booleanLayout} and {@code value} to a String.\n+         *\n+         * @param booleanLayout the layout to render\n+         * @param value         the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfByte booleanLayout, byte value) {\n+            requireNonNull(booleanLayout);\n+            return Byte.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code charLayout} and {@code value} to a String.\n+         *\n+         * @param charLayout the layout to render\n+         * @param value      the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfChar charLayout, char value) {\n+            requireNonNull(charLayout);\n+            return Character.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code sortLayout} and {@code value} to a String.\n+         *\n+         * @param sortLayout the layout to render\n+         * @param value      the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfShort sortLayout, short value) {\n+            requireNonNull(sortLayout);\n+            return Short.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code intLayout} and {@code value} to a String.\n+         *\n+         * @param intLayout the layout to render\n+         * @param value     the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfInt intLayout, int value) {\n+            requireNonNull(intLayout);\n+            return Integer.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code longLayout} and {@code value} to a String.\n+         *\n+         * @param longLayout the layout to render\n+         * @param value      the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfLong longLayout, long value) {\n+            requireNonNull(longLayout);\n+            return Long.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code floatLayout} and {@code value} to a String.\n+         *\n+         * @param floatLayout the layout to render\n+         * @param value       the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfFloat floatLayout, float value) {\n+            requireNonNull(floatLayout);\n+            return Float.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code doubleLayout} and {@code value} to a String.\n+         *\n+         * @param doubleLayout the layout to render\n+         * @param value        the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfDouble doubleLayout, double value) {\n+            requireNonNull(doubleLayout);\n+            return Double.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code addressLayout} and {@code value} to a String.\n+         *\n+         * @param addressLayout the layout to render\n+         * @param value         the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfAddress addressLayout, MemorySegment value) {\n+            requireNonNull(addressLayout);\n+            return String.format(\"0x%0\" + (ValueLayout.ADDRESS.byteSize() * 2) + \"X\", value.address());\n+        }\n+\n+        \/**\n+         * {@return a standard value layout renderer that will render numeric values into decimal form and where\n+         * other value types are rendered to a reasonable \"natural\" form}\n+         * <p>\n+         * More specifically, values types are rendered as follows:\n+         * <ul>\n+         *     <li>Numeric values are rendered in decimal form (e.g 1 or 1.2).<\/li>\n+         *     <li>Boolean values are rendered as {@code true} or {@code false}.<\/li>\n+         *     <li>Character values are rendered as {@code char}.<\/li>\n+         *     <li>Address values are rendered in hexadecimal form e.g. {@code 0x0000000000000000} (on 64-bit platforms) or\n+         *     {@code 0x00000000} (on 32-bit platforms)<\/li>\n+         * <\/ul>\n+         *\/\n+        static ValueLayoutRenderer standard() {\n+            return STANDARD_VALUE_LAYOUT_RENDERER;\n+        }\n+\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryInspection.java","additions":206,"deletions":0,"binary":false,"changes":206,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,5 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n@@ -36,0 +41,6 @@\n+import java.util.function.ToLongFunction;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.util.Objects.requireNonNull;\n@@ -81,2 +92,1 @@\n- * @apiNote\n- * For example, an individual byte is converted to a string of hexadecimal digits using\n+ * @apiNote For example, an individual byte is converted to a string of hexadecimal digits using\n@@ -133,1 +143,0 @@\n- *\n@@ -157,1 +166,1 @@\n-             0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,\n+            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1,\n@@ -180,0 +189,2 @@\n+    private static final int DUMP_BYTES_PER_ROW = 16;\n+\n@@ -189,3 +200,3 @@\n-     * @param prefix a prefix, non-null\n-     * @param suffix a suffix, non-null\n-     * @param digits byte array of digits indexed by low nibble, non-null\n+     * @param prefix    a prefix, non-null\n+     * @param suffix    a suffix, non-null\n+     * @param digits    byte array of digits indexed by low nibble, non-null\n@@ -232,0 +243,1 @@\n+     *\n@@ -311,1 +323,1 @@\n-     *          otherwise {@code false}\n+     * otherwise {@code false}\n@@ -322,1 +334,1 @@\n-     *\n+     * <p>\n@@ -339,1 +351,1 @@\n-     * @param bytes a non-null array of bytes\n+     * @param bytes     a non-null array of bytes\n@@ -341,1 +353,1 @@\n-     * @param toIndex the final index of the range, exclusive\n+     * @param toIndex   the final index of the range, exclusive\n@@ -346,1 +358,1 @@\n-        Objects.requireNonNull(bytes,\"bytes\");\n+        Objects.requireNonNull(bytes, \"bytes\");\n@@ -370,2 +382,2 @@\n-     * @param <A> The type of {@code Appendable}\n-     * @param out an {@code Appendable}, non-null\n+     * @param <A>   The type of {@code Appendable}\n+     * @param out   an {@code Appendable}, non-null\n@@ -380,0 +392,72 @@\n+    \/**\n+     * Returns a hexadecimal string formatted from the provided {@linkplain MemorySegment segment}.\n+     * Each byte value is formatted as the prefix, two hexadecimal characters\n+     * {@linkplain #isUpperCase selected from} uppercase or lowercase digits, and the suffix.\n+     * A delimiter follows each formatted value, except the last.\n+     * <p>\n+     * The behavior is equivalent to\n+     * {@link #formatHex(Appendable, MemorySegment) formatHex(new StringBuilder(), segment).toString())}.\n+     * <p>\n+     * To view parts of a memory segment, use {@linkplain MemorySegment#asSlice(long) a slice}.\n+     *\n+     * @param segment a non-null memory segment\n+     * @return a string hexadecimal formatting of the byte array\n+     * @throws UncheckedIOException  if an I\/O exception occurs appending to the output\n+     * @throws IllegalStateException if the {@linkplain MemorySegment#session() session} associated with this\n+     *                               segment is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException  if this method is called from a thread other than the thread owning\n+     *                               the {@linkplain MemorySegment#session() session} associated with this segment.\n+     * @see #formatHex(Appendable, MemorySegment)\n+     *\/\n+    public String formatHex(MemorySegment segment) {\n+        return formatHex(new StringBuilder(), segment).toString();\n+    }\n+\n+    \/**\n+     * Appends formatted hexadecimal strings from the provided {@linkplain MemorySegment segment}\n+     * to the provided {@linkplain Appendable out}.\n+     * Each byte value is formatted as the prefix, two hexadecimal characters\n+     * {@linkplain #isUpperCase selected from} uppercase or lowercase digits, and the suffix.\n+     * A delimiter follows each formatted value, except the last.\n+     * The formatted hexadecimal strings are appended in zero or more calls to the {@link Appendable} methods.\n+     * <p>\n+     * To view parts of a memory segment, use {@linkplain MemorySegment#asSlice(long) a slice}.\n+     *\n+     * @param <A>     The type of {@code Appendable}\n+     * @param out     an {@code Appendable}, non-null\n+     * @param segment a memory segment\n+     * @return the {@code Appendable}\n+     * @throws UncheckedIOException  if an I\/O exception occurs appending to the output\n+     * @throws IllegalStateException if the {@linkplain MemorySegment#session() session} associated with this\n+     *                               segment is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException  if this method is called from a thread other than the thread owning\n+     *                               the {@linkplain MemorySegment#session() session} associated with this segment.\n+     *\/\n+    public <A extends Appendable> A formatHex(A out, MemorySegment segment) {\n+        Objects.requireNonNull(out, \"out\");\n+        Objects.requireNonNull(segment, \"segment\");\n+\n+        long length = segment.byteSize();\n+        if (length > 0) {\n+            try {\n+                String between = suffix + delimiter + prefix;\n+                out.append(prefix);\n+                toHexDigits(out, segment.get(ValueLayout.JAVA_BYTE, 0));\n+                if (between.isEmpty()) {\n+                    for (long i = 1; i < length; i++) {\n+                        toHexDigits(out, segment.get(ValueLayout.JAVA_BYTE, i));\n+                    }\n+                } else {\n+                    for (long i = 1; i < length; i++) {\n+                        out.append(between);\n+                        toHexDigits(out, segment.get(ValueLayout.JAVA_BYTE, i));\n+                    }\n+                }\n+                out.append(suffix);\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe.getMessage(), ioe);\n+            }\n+        }\n+        return out;\n+    }\n+\n@@ -387,3 +471,3 @@\n-     * @param <A> The type of {@code Appendable}\n-     * @param out an {@code Appendable}, non-null\n-     * @param bytes a byte array, non-null\n+     * @param <A>       The type of {@code Appendable}\n+     * @param out       an {@code Appendable}, non-null\n+     * @param bytes     a byte array, non-null\n@@ -391,1 +475,1 @@\n-     * @param toIndex the final index of the range, exclusive.\n+     * @param toIndex   the final index of the range, exclusive.\n@@ -394,1 +478,1 @@\n-     * @throws UncheckedIOException if an I\/O exception occurs appending to the output\n+     * @throws UncheckedIOException      if an I\/O exception occurs appending to the output\n@@ -431,1 +515,1 @@\n-     * @param bytes the bytes, non-null\n+     * @param bytes     the bytes, non-null\n@@ -433,1 +517,1 @@\n-     * @param toIndex the final index of the range, exclusive.\n+     * @param toIndex   the final index of the range, exclusive.\n@@ -435,1 +519,1 @@\n-     *         or non-empty prefix or suffix\n+     * or non-empty prefix or suffix\n@@ -447,2 +531,2 @@\n-                rep[i * 2] = (byte)toHighHexDigit(bytes[fromIndex + i]);\n-                rep[i * 2 + 1] = (byte)toLowHexDigit(bytes[fromIndex + i]);\n+                rep[i * 2] = (byte) toHighHexDigit(bytes[fromIndex + i]);\n+                rep[i * 2 + 1] = (byte) toLowHexDigit(bytes[fromIndex + i]);\n@@ -459,1 +543,1 @@\n-                rep[i * 3    ] = (byte) toHighHexDigit(bytes[fromIndex + i]);\n+                rep[i * 3] = (byte) toHighHexDigit(bytes[fromIndex + i]);\n@@ -486,1 +570,1 @@\n-        return (int)length;\n+        return (int) length;\n@@ -491,1 +575,1 @@\n-     *\n+     * <p>\n@@ -498,1 +582,1 @@\n-     *            and delimiters\n+     *               and delimiters\n@@ -501,2 +585,2 @@\n-     *          the byte values are not hexadecimal characters, or if the delimiter is not present\n-     *          after all but the last byte value\n+     *                                  the byte values are not hexadecimal characters, or if the delimiter is not present\n+     *                                  after all but the last byte value\n@@ -510,1 +594,1 @@\n-     *\n+     * <p>\n@@ -516,2 +600,2 @@\n-     * @param string a string range containing hexadecimal digits,\n-     *           delimiters, prefix, and suffix.\n+     * @param string    a string range containing hexadecimal digits,\n+     *                  delimiters, prefix, and suffix.\n@@ -519,1 +603,1 @@\n-     * @param toIndex the final index of the range, exclusive.\n+     * @param toIndex   the final index of the range, exclusive.\n@@ -521,3 +605,3 @@\n-     * @throws IllegalArgumentException if the prefix or suffix is not present for each byte value,\n-     *          the byte values are not hexadecimal characters, or if the delimiter is not present\n-     *          after all but the last byte value\n+     * @throws IllegalArgumentException  if the prefix or suffix is not present for each byte value,\n+     *                                   the byte values are not hexadecimal characters, or if the delimiter is not present\n+     *                                   after all but the last byte value\n@@ -549,1 +633,1 @@\n-        final int len = (int)((string.length() - valueChars) \/ stride + 1L);\n+        final int len = (int) ((string.length() - valueChars) \/ stride + 1L);\n@@ -564,1 +648,1 @@\n-     *\n+     * <p>\n@@ -570,2 +654,2 @@\n-     * @param chars a character array range containing an even number of hexadecimal digits,\n-     *          delimiters, prefix, and suffix.\n+     * @param chars     a character array range containing an even number of hexadecimal digits,\n+     *                  delimiters, prefix, and suffix.\n@@ -573,1 +657,1 @@\n-     * @param toIndex the final index of the range, exclusive.\n+     * @param toIndex   the final index of the range, exclusive.\n@@ -575,3 +659,3 @@\n-     * @throws IllegalArgumentException if the prefix or suffix is not present for each byte value,\n-     *          the byte values are not hexadecimal characters, or if the delimiter is not present\n-     *          after all but the last byte value\n+     * @throws IllegalArgumentException  if the prefix or suffix is not present for each byte value,\n+     *                                   the byte values are not hexadecimal characters, or if the delimiter is not present\n+     *                                   after all but the last byte value\n@@ -591,2 +675,2 @@\n-     * @param string a CharSequence\n-     * @param index the index of the literal in the CharSequence\n+     * @param string  a CharSequence\n+     * @param index   the index of the literal in the CharSequence\n@@ -597,1 +681,1 @@\n-        assert index <= string.length() - literal.length()  : \"pre-checked invariant error\";\n+        assert index <= string.length() - literal.length() : \"pre-checked invariant error\";\n@@ -607,1 +691,1 @@\n-                        \" ch: \" + (int)string.charAt(index + i)));\n+                        \" ch: \" + (int) string.charAt(index + i)));\n@@ -634,1 +718,1 @@\n-        return (char)digits[value & 0xf];\n+        return (char) digits[value & 0xf];\n@@ -648,1 +732,1 @@\n-        return (char)digits[(value >> 4) & 0xf];\n+        return (char) digits[(value >> 4) & 0xf];\n@@ -658,2 +742,2 @@\n-     * @param <A> The type of {@code Appendable}\n-     * @param out an {@code Appendable}, non-null\n+     * @param <A>   The type of {@code Appendable}\n+     * @param out   an {@code Appendable}, non-null\n@@ -686,2 +770,2 @@\n-        rep[0] = (byte)toHighHexDigit(value);\n-        rep[1] = (byte)toLowHexDigit(value);\n+        rep[0] = (byte) toHighHexDigit(value);\n+        rep[1] = (byte) toLowHexDigit(value);\n@@ -705,1 +789,1 @@\n-        return toHexDigits((short)value);\n+        return toHexDigits((short) value);\n@@ -719,4 +803,4 @@\n-        rep[0] = (byte)toHighHexDigit((byte)(value >> 8));\n-        rep[1] = (byte)toLowHexDigit((byte)(value >> 8));\n-        rep[2] = (byte)toHighHexDigit((byte)value);\n-        rep[3] = (byte)toLowHexDigit((byte)value);\n+        rep[0] = (byte) toHighHexDigit((byte) (value >> 8));\n+        rep[1] = (byte) toLowHexDigit((byte) (value >> 8));\n+        rep[2] = (byte) toHighHexDigit((byte) value);\n+        rep[3] = (byte) toLowHexDigit((byte) value);\n@@ -743,8 +827,8 @@\n-        rep[0] = (byte)toHighHexDigit((byte)(value >> 24));\n-        rep[1] = (byte)toLowHexDigit((byte)(value >> 24));\n-        rep[2] = (byte)toHighHexDigit((byte)(value >> 16));\n-        rep[3] = (byte)toLowHexDigit((byte)(value >> 16));\n-        rep[4] = (byte)toHighHexDigit((byte)(value >> 8));\n-        rep[5] = (byte)toLowHexDigit((byte)(value >> 8));\n-        rep[6] = (byte)toHighHexDigit((byte)value);\n-        rep[7] = (byte)toLowHexDigit((byte)value);\n+        rep[0] = (byte) toHighHexDigit((byte) (value >> 24));\n+        rep[1] = (byte) toLowHexDigit((byte) (value >> 24));\n+        rep[2] = (byte) toHighHexDigit((byte) (value >> 16));\n+        rep[3] = (byte) toLowHexDigit((byte) (value >> 16));\n+        rep[4] = (byte) toHighHexDigit((byte) (value >> 8));\n+        rep[5] = (byte) toLowHexDigit((byte) (value >> 8));\n+        rep[6] = (byte) toHighHexDigit((byte) value);\n+        rep[7] = (byte) toLowHexDigit((byte) value);\n@@ -771,16 +855,16 @@\n-        rep[0] = (byte)toHighHexDigit((byte)(value >>> 56));\n-        rep[1] = (byte)toLowHexDigit((byte)(value >>> 56));\n-        rep[2] = (byte)toHighHexDigit((byte)(value >>> 48));\n-        rep[3] = (byte)toLowHexDigit((byte)(value >>> 48));\n-        rep[4] = (byte)toHighHexDigit((byte)(value >>> 40));\n-        rep[5] = (byte)toLowHexDigit((byte)(value >>> 40));\n-        rep[6] = (byte)toHighHexDigit((byte)(value >>> 32));\n-        rep[7] = (byte)toLowHexDigit((byte)(value >>> 32));\n-        rep[8] = (byte)toHighHexDigit((byte)(value >>> 24));\n-        rep[9] = (byte)toLowHexDigit((byte)(value >>> 24));\n-        rep[10] = (byte)toHighHexDigit((byte)(value >>> 16));\n-        rep[11] = (byte)toLowHexDigit((byte)(value >>> 16));\n-        rep[12] = (byte)toHighHexDigit((byte)(value >>> 8));\n-        rep[13] = (byte)toLowHexDigit((byte)(value >>> 8));\n-        rep[14] = (byte)toHighHexDigit((byte)value);\n-        rep[15] = (byte)toLowHexDigit((byte)value);\n+        rep[0] = (byte) toHighHexDigit((byte) (value >>> 56));\n+        rep[1] = (byte) toLowHexDigit((byte) (value >>> 56));\n+        rep[2] = (byte) toHighHexDigit((byte) (value >>> 48));\n+        rep[3] = (byte) toLowHexDigit((byte) (value >>> 48));\n+        rep[4] = (byte) toHighHexDigit((byte) (value >>> 40));\n+        rep[5] = (byte) toLowHexDigit((byte) (value >>> 40));\n+        rep[6] = (byte) toHighHexDigit((byte) (value >>> 32));\n+        rep[7] = (byte) toLowHexDigit((byte) (value >>> 32));\n+        rep[8] = (byte) toHighHexDigit((byte) (value >>> 24));\n+        rep[9] = (byte) toLowHexDigit((byte) (value >>> 24));\n+        rep[10] = (byte) toHighHexDigit((byte) (value >>> 16));\n+        rep[11] = (byte) toLowHexDigit((byte) (value >>> 16));\n+        rep[12] = (byte) toHighHexDigit((byte) (value >>> 8));\n+        rep[13] = (byte) toLowHexDigit((byte) (value >>> 8));\n+        rep[14] = (byte) toHighHexDigit((byte) value);\n+        rep[15] = (byte) toLowHexDigit((byte) value);\n@@ -801,1 +885,1 @@\n-     * @param value a {@code long} value\n+     * @param value  a {@code long} value\n@@ -804,1 +888,1 @@\n-     * @throws  IllegalArgumentException if {@code digits} is negative or greater than 16\n+     * @throws IllegalArgumentException if {@code digits} is negative or greater than 16\n@@ -813,1 +897,1 @@\n-            rep[i] = (byte)toLowHexDigit((byte)(value));\n+            rep[i] = (byte) toLowHexDigit((byte) (value));\n@@ -830,1 +914,1 @@\n-     *          the string contains non-hexadecimal characters\n+     *                                  the string contains non-hexadecimal characters\n@@ -849,2 +933,2 @@\n-     * @param toIndex the final index of the range, exclusive.\n-     * @param limit the maximum allowed\n+     * @param toIndex   the final index of the range, exclusive.\n+     * @param limit     the maximum allowed\n@@ -869,0 +953,1 @@\n+     *\n@@ -871,1 +956,1 @@\n-     *          otherwise {@code false}\n+     * otherwise {@code false}\n@@ -888,1 +973,1 @@\n-     * @throws  NumberFormatException if the codepoint is not a hexadecimal character\n+     * @throws NumberFormatException if the codepoint is not a hexadecimal character\n@@ -904,1 +989,1 @@\n-     * @param index the index of the first character of the range\n+     * @param index  the index of the first character of the range\n@@ -906,4 +991,4 @@\n-     * @throws  NumberFormatException if any of the characters in the range\n-     *          is not a hexadecimal character\n-     * @throws  IndexOutOfBoundsException if the range is out of bounds\n-     *          for the {@code CharSequence}\n+     * @throws NumberFormatException     if any of the characters in the range\n+     *                                   is not a hexadecimal character\n+     * @throws IndexOutOfBoundsException if the range is out of bounds\n+     *                                   for the {@code CharSequence}\n@@ -923,2 +1008,3 @@\n-     * @apiNote\n-     * {@link Integer#parseInt(String, int) Integer.parseInt(s, 16)} and\n+     * @param string to parse\n+     * @return the parsed int value\n+     * @apiNote {@link Integer#parseInt(String, int) Integer.parseInt(s, 16)} and\n@@ -931,5 +1017,0 @@\n-     *\n-     * @param string a CharSequence containing up to eight hexadecimal characters\n-     * @return the value parsed from the string\n-     * @throws  IllegalArgumentException if the string length is greater than eight (8) or\n-     *      if any of the characters is not a hexadecimal character\n@@ -949,2 +1030,9 @@\n-     * @apiNote\n-     * {@link Integer#parseInt(String, int) Integer.parseInt(s, 16)} and\n+     * @param string    a CharSequence containing the characters\n+     * @param fromIndex the initial index of the range, inclusive\n+     * @param toIndex   the final index of the range, exclusive.\n+     * @return the value parsed from the string range\n+     * @throws IndexOutOfBoundsException if the range is out of bounds\n+     *                                   for the {@code CharSequence}\n+     * @throws IllegalArgumentException  if length of the range is greater than eight (8) or\n+     *                                   if any of the characters is not a hexadecimal character\n+     * @apiNote {@link Integer#parseInt(String, int) Integer.parseInt(s, 16)} and\n@@ -957,9 +1045,0 @@\n-     *\n-     * @param string a CharSequence containing the characters\n-     * @param fromIndex the initial index of the range, inclusive\n-     * @param toIndex the final index of the range, exclusive.\n-     * @return the value parsed from the string range\n-     * @throws  IndexOutOfBoundsException if the range is out of bounds\n-     *          for the {@code CharSequence}\n-     * @throws  IllegalArgumentException if length of the range is greater than eight (8) or\n-     *          if any of the characters is not a hexadecimal character\n@@ -984,2 +1063,3 @@\n-     * @apiNote\n-     * {@link Long#parseLong(String, int) Long.parseLong(s, 16)} and\n+     * @param string to parse\n+     * @return the parsed long value\n+     * @apiNote {@link Long#parseLong(String, int) Long.parseLong(s, 16)} and\n@@ -992,5 +1072,0 @@\n-     *\n-     * @param string a CharSequence containing up to sixteen hexadecimal characters\n-     * @return the value parsed from the string\n-     * @throws  IllegalArgumentException if the string length is greater than sixteen (16) or\n-     *         if any of the characters is not a hexadecimal character\n@@ -1010,2 +1085,9 @@\n-     * @apiNote\n-     * {@link Long#parseLong(String, int) Long.parseLong(s, 16)} and\n+     * @param string    a CharSequence containing the characters\n+     * @param fromIndex the initial index of the range, inclusive\n+     * @param toIndex   the final index of the range, exclusive.\n+     * @return the value parsed from the string range\n+     * @throws IndexOutOfBoundsException if the range is out of bounds\n+     *                                   for the {@code CharSequence}\n+     * @throws IllegalArgumentException  if the length of the range is greater than sixteen (16) or\n+     *                                   if any of the characters is not a hexadecimal character\n+     * @apiNote {@link Long#parseLong(String, int) Long.parseLong(s, 16)} and\n@@ -1018,9 +1100,0 @@\n-     *\n-     * @param string a CharSequence containing the characters\n-     * @param fromIndex the initial index of the range, inclusive\n-     * @param toIndex the final index of the range, exclusive.\n-     * @return the value parsed from the string range\n-     * @throws  IndexOutOfBoundsException if the range is out of bounds\n-     *          for the {@code CharSequence}\n-     * @throws  IllegalArgumentException if the length of the range is greater than sixteen (16) or\n-     *          if any of the characters is not a hexadecimal character\n@@ -1045,2 +1118,2 @@\n-     *         uppercase, delimiter, prefix, and suffix are equal;\n-     *         otherwise {@code false}\n+     * uppercase, delimiter, prefix, and suffix are equal;\n+     * otherwise {@code false}\n@@ -1086,0 +1159,675 @@\n+\n+    \/**\n+     * A class providing various memory abstractions (such as MemorySegments and byte arrays) to be dumped into\n+     * various formats.\n+     *\n+     * @author Per Minborg\n+     * @since 20\n+     *\/\n+    public interface MemoryDumper {\n+\n+        \/**\n+         * Returns a Stream of string elements with values for the provided {@code memory} byte array.\n+         * <p>\n+         * Each element in the stream depends on how this MemoryDumper was configured via its {@linkplain #builder()}.\n+         * <p>\n+         * As an example, an array created, initialized and used as follows\n+         * {@snippet lang = java:\n+         *   byte[] bytes = \"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\".getBytes(StandardCharsets.UTF_8);\n+         *   MemoryDumper.builder()\n+         *      .addIndexColumn()\n+         *      .addDataColumn()\n+         *      .withColumnPrefix(\"|\")\n+         *      .withColumnSuffix(\"|\")\n+         *      .addDataColumn(Builder.ColumnRenderer.ofAscii())\n+         *      .build()\n+         *      .dump(bytes)\n+         *      .forEach(System.out::println);\n+         *}\n+         * will be printed as:\n+         * {@snippet lang = text:\n+         * 0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 |The quick brown |\n+         * 0000000000000010 66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20 |fox jumped over |\n+         * 0000000000000020 74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63 |the lazy dog.Sec|\n+         * 0000000000000030 6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65 00    |ond line.:here._|\n+         *}\n+         *\n+         * @param bytes to dump\n+         * @return a Stream of string elements\n+         *\/\n+        Stream<String> dump(byte[] bytes);\n+\n+        \/**\n+         * Returns a Stream of string elements with values for the provided {@code memory} byte array staring\n+         * at the provided {@code fromIndex} (inclusive) and ending at the provided {@code toIndex} (exclusive).\n+         * <p>\n+         * Each element in the stream depends on how this MemoryDumper was configured via its {@linkplain #builder()}.\n+         * <p>\n+         * As an example, an array created, initialized and used as follows\n+         * {@snippet lang = java:\n+         *   byte[] bytes = \"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\".getBytes(StandardCharsets.UTF_8);\n+         *   MemoryDumper.builder()\n+         *      .addIndexColumn()\n+         *      .addDataColumn()\n+         *      .withColumnPrefix(\"|\")\n+         *      .withColumnSuffix(\"|\")\n+         *      .addDataColumn(Builder.ColumnRenderer.ofAscii())\n+         *      .build()\n+         *      .dump(bytes, 0, 16)\n+         *      .forEach(System.out::println);\n+         *}\n+         * will be printed as:\n+         * {@snippet lang = text:\n+         * 0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 |The quick brown |\n+         *}\n+         *\n+         * @param bytes     to dump\n+         * @param fromIndex the initial index of the range, inclusive\n+         * @param toIndex   the final index of the range, exclusive.\n+         * @return a Stream of string elements\n+         *\/\n+        Stream<String> dump(byte[] bytes, int fromIndex, int toIndex);\n+\n+        \/**\n+         * Returns a Stream of string elements with values for the provided {@code memory} segment.\n+         * <p>\n+         * Each element in the stream depends on how this MemoryDumper was configured via its {@linkplain #builder()}.\n+         * <p>\n+         * As an example, an array created, initialized and used as follows\n+         * {@snippet lang = java:\n+         * MemoryDumper dumper = MemoryDumper.builder()\n+         *            .addIndexColumn()\n+         *            .addDataColumn()\n+         *            .withColumnPrefix(\"|\")\n+         *            .withColumnSuffix(\"|\")\n+         *            .addDataColumn(Builder.ColumnRenderer.ofAscii())\n+         *            .build();\n+         *\n+         *    try (MemorySession session = MemorySession.openConfined()) {\n+         *       MemorySegment segment = session.allocateUtf8String(\"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\");\n+         *      dumper.dump(bytes)\n+         *          .forEach(System.out::println);\n+         *    }\n+         *}\n+         * will be printed as:\n+         * {@snippet lang = text:\n+         * 0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 |The quick brown |\n+         * 0000000000000010 66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20 |fox jumped over |\n+         * 0000000000000020 74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63 |the lazy dog.Sec|\n+         * 0000000000000030 6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65 00    |ond line.:here._|\n+         *}\n+         *\n+         * @param segment to dump\n+         * @return a Stream of string elements\n+         *\/\n+        Stream<String> dump(MemorySegment segment);\n+\n+\n+        \/**\n+         * Returns a Stream of string elements with values for the provided {@code buffer}.\n+         * <p>\n+         * Each element in the stream depends on how this MemoryDumper was configured via its {@linkplain #builder()}.\n+         * <p>\n+         * As an example, an array created, initialized and used as follows\n+         * {@snippet lang = java:\n+         * var buffer = ByteBuffer.wrap(\"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\".getBytes(StandardCharsets.UTF_8));\n+         * MemoryDumper dumper = MemoryDumper.builder()\n+         *            .addIndexColumn()\n+         *            .addDataColumn()\n+         *            .withColumnPrefix(\"|\")\n+         *            .withColumnSuffix(\"|\")\n+         *            .addDataColumn(Builder.ColumnRenderer.ofAscii())\n+         *            .build();\n+         * dumper.dump(bytes)\n+         *     .forEach(System.out::println);\n+         *}\n+         * will be printed as:\n+         * {@snippet lang = text:\n+         * 0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 |The quick brown |\n+         * 0000000000000010 66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20 |fox jumped over |\n+         * 0000000000000020 74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63 |the lazy dog.Sec|\n+         * 0000000000000030 6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65 00    |ond line.:here._|\n+         *}\n+         *\n+         * @param buffer to dump\n+         * @return a Stream of string elements\n+         *\/\n+        Stream<String> dump(ByteBuffer buffer);\n+\n+        \/**\n+         * {@return a new builder that can be used to configure and create MemoryDumper instances.}\n+         *\/\n+        static Builder builder() {\n+            return new StandardMemoryDumperBuilder();\n+        }\n+\n+        \/**\n+         * {@return a standard MemoryDumper that will format memory segments in human readable form}\n+         * <p>\n+         * As an example, a memory segment, initialized and used as follows\n+         * {@snippet lang = java:\n+         * MemoryDumper dumper = MemoryDumper.standard();\n+         *\n+         *    try (MemorySession session = MemorySession.openConfined()) {\n+         *       MemorySegment segment = session.allocateUtf8String(\"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\");\n+         *      dumper.dump(bytes)\n+         *          .forEach(System.out::println);\n+         *    }\n+         *}\n+         * will be printed as:\n+         * {@snippet lang = text:\n+         * 0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 |The quick brown |\n+         * 0000000000000010 66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20 |fox jumped over |\n+         * 0000000000000020 74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63 |the lazy dog.Sec|\n+         * 0000000000000030 6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65 00    |ond line.:here._|\n+         *}\n+         *\/\n+        static MemoryDumper standard() {\n+            return StandardMemoryDumper.STANDARD;\n+        }\n+\n+        \/**\n+         * A non-threadsafe builder for MemoryDumper instances.\n+         *\n+         * @since 20\n+         *\/\n+        interface Builder {\n+\n+            \/**\n+             * Configures the number of bytes per line in.\n+             * <p>\n+             * Unless configured otherwise, the default number of bytes per line is 16.\n+             *\n+             * @param bytesPerLine the number of bytes per line (non-negative)\n+             * @return this Builder\n+             * @throws IllegalArgumentException if the provided {@code bytes} are negative\n+             *\/\n+            Builder withBytesPerLine(int bytesPerLine);\n+\n+            \/**\n+             * Configures the column prefix for subsequent index and data columns.\n+             * <p>\n+             * Unless configured otherwise, the default column prefix is \"\" (an empty String).\n+             *\n+             * @param prefix the column prefix (non-null)\n+             * @return this Builder\n+             * @throws NullPointerException if the provided {@code prefix} is {@code null}\n+             *\/\n+            Builder withColumnPrefix(String prefix);\n+\n+            \/**\n+             * Configures the column suffix for subsequent index and data columns.\n+             * <p>\n+             * Unless configured otherwise, the default suffix is \"\" (an empty String).\n+             *\n+             * @param suffix the column suffix (non-null)\n+             * @return this Builder\n+             * @throws NullPointerException if the provided {@code suffix} is {@code null}\n+             *\/\n+            Builder withColumnSuffix(String suffix);\n+\n+            \/**\n+             * Configures the column delimiter for subsequent index and data columns.\n+             * <p>\n+             * The column delimiter will be inserted between columns (i.e. not after the last column).\n+             * Unless configured otherwise, the default suffix is \" \" (a single space).\n+             *\n+             * @param delimiter the column delimiter (non-null)\n+             * @return this Builder\n+             * @throws NullPointerException if the provided {@code delimiter} is {@code null}\n+             *\/\n+            Builder withColumnDelimiter(String delimiter);\n+\n+            \/**\n+             * Adds an index column with 8 bytes (64-bit) index with hexadecimal values formatted by\n+             * the default {@link HexFormat#of()} formatter.\n+             *\n+             * @return this Builder\n+             *\/\n+            Builder addIndexColumn();\n+\n+            \/**\n+             * Adds an index column with the provided {@code  bytes} index with hexadecimal values formatted by\n+             * the default {@link HexFormat#of()} formatter.\n+             *\n+             * @param bytes the number of bytes to render in the index (in the range [1, 8])\n+             * @return this Builder\n+             * @throws IllegalArgumentException if the provided {@code bytes} is outside the range [1, 8]\n+             *\/\n+            Builder addIndexColumn(int bytes);\n+\n+            \/**\n+             * Adds an index column with the provided {@code  bytes} index with hexadecimal values formatted by\n+             * the provided {@code formatter }.\n+             *\n+             * @param bytes     the number of bytes to render in the index (in the range [1, 8])\n+             * @param formatter the formatter to use for byte values in the index\n+             * @return this Builder\n+             * @throws IllegalArgumentException if the provided {@code bytes} is outside the range [1, 8]\n+             * @throws NullPointerException     if the provided {@code formatter} is {@code null}\n+             *\/\n+            Builder addIndexColumn(int bytes, HexFormat formatter);\n+\n+            \/**\n+             * Adds an index column with the provided {@code  bytes} index with hexadecimal values formatted by\n+             * the provided {@code renderer }.\n+             * <p>\n+             * Indexes used by the provided {@code renderer} are counted as byte indexes with the index value itself\n+             * and runs from the provided {@code bytes - 1} to 0.\n+             *\n+             * @param bytes    the number of bytes to render in the index (in the range [1, 8])\n+             * @param renderer the renderer to use for byte values in the index\n+             * @return this Builder\n+             * @throws IllegalArgumentException if the provided {@code bytes} is outside the range [1, 8]\n+             * @throws NullPointerException     if the provided {@code renderer} is {@code null}\n+             *\/\n+            Builder addIndexColumn(int bytes, ColumnRenderer renderer);\n+\n+            \/**\n+             * Adds a data column with hexadecimal values formatted by\n+             * a {@code HexFormat.ofDelimiter(\" \")} formatter.\n+             *\n+             * @return this Builder\n+             *\/\n+            Builder addDataColumn();\n+\n+            \/**\n+             * Adds a data column with hexadecimal values formatted by\n+             * the provided {@code formatter }.\n+             *\n+             * @param formatter the formatter to use for byte values in a row\n+             * @return this Builder\n+             * @throws NullPointerException if the provided {@code formatter} is {@code null}\n+             *\/\n+            Builder addDataColumn(HexFormat formatter);\n+\n+            \/**\n+             * Adds a data column with hexadecimal values formatted by\n+             * the provided {@code renderer }.\n+             *\n+             * @param renderer the renderer to use for byte values in a row\n+             * @return this Builder\n+             * @throws NullPointerException if the provided {@code renderer} is {@code null}\n+             *\/\n+            Builder addDataColumn(ColumnRenderer renderer);\n+\n+            \/**\n+             * {@return a new MemoryDumper instance with configurations made so far.}\n+             *\/\n+            MemoryDumper build();\n+\n+            \/**\n+             * Represents a function that accepts a long index and a byte value and produces a CharSequence such\n+             * as a String.\n+             *\n+             * @since 20\n+             *\/\n+            @FunctionalInterface\n+            interface ColumnRenderer {\n+\n+                \/**\n+                 * {@return a rendering of the provided {@code bytes} with the provided {@code BytesPerLine} }\n+                 * <p>\n+                 * Note: On the last line, chars may be padded using the ' ' character.\n+                 *\n+                 * @param bytesPerLine the bytes per line\n+                 * @param bytes        the byte array to render\n+                 *\/\n+                String render(int bytesPerLine, byte[] bytes);\n+\n+                \/**\n+                 * {@return a ByteRenderer that renders bytes into human readable characters.}\n+                 *\/\n+                static ColumnRenderer ofAscii() {\n+                    return (bytePerLine, bytes) -> {\n+                        StringBuilder sb = new StringBuilder();\n+                        for (int i = 0; i < bytePerLine; i++) {\n+                            if (i >= bytes.length) {\n+                                \/\/ Padding on the last line\n+                                sb.append(\" \");\n+                            } else {\n+                                final byte val = bytes[i];\n+                                if (val >= 32 && val < 127) {\n+                                    sb.append((char) val);\n+                                } else {\n+                                    sb.append(\".\");\n+                                }\n+                            }\n+                        }\n+                        return sb.toString();\n+                    };\n+                }\n+\n+                \/**\n+                 * {@return a ByteReader that renders bytes as per the provided {@code formatter}}\n+                 *\n+                 * @param formatter to use when formatting values\n+                 *\/\n+                static ColumnRenderer of(HexFormat formatter) {\n+                    requireNonNull(formatter);\n+                    return new ByteRenderedFromHexFormat(formatter);\n+                }\n+\n+            }\n+\n+        }\n+\n+    }\n+\n+    private static final class ByteRenderedFromHexFormat implements MemoryDumper.Builder.ColumnRenderer {\n+\n+        private final HexFormat formatter;\n+\n+        public ByteRenderedFromHexFormat(HexFormat formatter) {\n+            this.formatter = formatter;\n+        }\n+\n+        @Override\n+        public String render(int bytesPerLine, byte[] bytes) {\n+            final var sb = new StringBuilder();\n+            if (bytesPerLine == bytes.length) {\n+                formatter.formatHex(sb, bytes);\n+            } else {\n+                \/\/ We are on the last line which needs padding\n+                final var expanded = new byte[bytesPerLine];\n+                System.arraycopy(bytes, 0, expanded, 0, bytes.length);\n+                formatter.formatHex(sb, expanded);\n+                final int bytesToRemove = bytesPerLine - bytes.length;\n+                final int charsToRemove = bytesToRemove * (formatter.prefix().length()+formatter.suffix().length()+2) +\n+                                          (bytesToRemove -1) * formatter.delimiter().length();\n+                \/\/ Erase the excess part\n+                for (int i = 0; i < charsToRemove; i++) {\n+                    sb.setCharAt(sb.length() - i - 1, ' ');\n+                }\n+            }\n+            return sb.toString();\n+        }\n+    }\n+\n+    private static final class StandardMemoryDumperBuilder implements MemoryDumper.Builder {\n+\n+        private final List<Column> columns;\n+        private int bytesPerLine = 16;\n+        private String columnPrefix = \"\";\n+        private String columnSuffix = \"\";\n+        private String columnDelimiter = \" \";\n+\n+        StandardMemoryDumperBuilder() {\n+            columns = new ArrayList<>();\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder withBytesPerLine(int bytes) {\n+            bytesPerLine = requirePositive(bytes);\n+            return this;\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder withColumnPrefix(String prefix) {\n+            columnPrefix = requireNonNull(prefix);\n+            return this;\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder withColumnSuffix(String suffix) {\n+            columnSuffix = requireNonNull(suffix);\n+            return this;\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder withColumnDelimiter(String delimiter) {\n+            columnDelimiter = requireNonNull(delimiter);\n+            return this;\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder addIndexColumn() {\n+            return addIndexColumn(8);\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder addIndexColumn(int bytes) {\n+            requireBetweenClosed(1, 8, bytes);\n+            return addIndexColumn(bytes, HexFormat.of());\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder addIndexColumn(int bytes, HexFormat formatter) {\n+            requireBetweenClosed(1, 8, bytes);\n+            requireNonNull(formatter);\n+            return addIndexColumn(bytes, ColumnRenderer.of(formatter));\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder addIndexColumn(int bytes, ColumnRenderer renderer) {\n+            requireBetweenClosed(1, 8, bytes);\n+            requireNonNull(renderer);\n+            columns.add(new Column(ColumnType.INDEX, OptionalInt.of(bytes), columnPrefix, renderer, columnSuffix, columnDelimiter));\n+            return this;\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder addDataColumn() {\n+            return addDataColumn(HexFormat.ofDelimiter(\" \"));\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder addDataColumn(HexFormat formatter) {\n+            requireNonNull(formatter);\n+            return addDataColumn(ColumnRenderer.of(formatter));\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder addDataColumn(ColumnRenderer renderer) {\n+            requireNonNull(renderer);\n+            columns.add(new Column(ColumnType.DATA, OptionalInt.empty(), columnPrefix, renderer, columnSuffix, columnDelimiter));\n+            return this;\n+        }\n+\n+        @Override\n+        public MemoryDumper build() {\n+            return new StandardMemoryDumper(bytesPerLine, columns);\n+        }\n+\n+        enum ColumnType {\n+            INDEX, DATA;\n+        }\n+\n+        private record Column(ColumnType type,\n+                              OptionalInt indexByteLength,\n+                              String prefix,\n+                              ColumnRenderer renderer,\n+                              String suffix,\n+                              String delimiter) {\n+        }\n+\n+        private int requirePositive(int value) {\n+            if (value < 1)\n+                throw new IllegalArgumentException(\"Value must be positive:\" + value);\n+            return value;\n+        }\n+\n+        \/\/ We assume from < to\n+        private int requireBetweenClosed(int from, int to, int value) {\n+            if (value < from || value > to)\n+                throw new IllegalArgumentException(\"Value \" + value + \" is not in the range [\" + from + \", \" + to + \"]\");\n+            return value;\n+        }\n+\n+    }\n+\n+    private static final class StandardMemoryDumper implements MemoryDumper {\n+\n+        private static final MemoryDumper STANDARD = MemoryDumper.builder()\n+                .addIndexColumn()\n+                .addDataColumn()\n+                .withColumnPrefix(\"|\")\n+                .withColumnSuffix(\"|\")\n+                .addDataColumn(HexFormat.MemoryDumper.Builder.ColumnRenderer.ofAscii())\n+                .build();\n+\n+\n+        private final int bytesPerLine;\n+        private final List<StandardMemoryDumperBuilder.Column> columns;\n+\n+        StandardMemoryDumper(int bytesPerLine,\n+                             List<StandardMemoryDumperBuilder.Column> columns) {\n+            this.bytesPerLine = bytesPerLine;\n+            this.columns = new ArrayList<>(columns);\n+        }\n+\n+        @Override\n+        public Stream<String> dump(byte[] bytes) {\n+            return dump0(bytes, ba -> ba.length, (ba, index) -> ba[Math.toIntExact(index)]);\n+        }\n+\n+        @Override\n+        public Stream<String> dump(byte[] bytes, int fromIndex, int toIndex) {\n+            if (fromIndex == 0) {\n+                if (toIndex>bytes.length)\n+                    throw new IllegalArgumentException(\"fromIndex \" + fromIndex + \" is greater than the array length \" + bytes.length);\n+                return dump0(bytes, ba -> toIndex, (ba, index) -> ba[(int) index]);\n+            }\n+            return dump0(MemorySegment.ofArray(bytes).asSlice(fromIndex, toIndex - fromIndex),\n+                    MemorySegment::byteSize,\n+                    memorySegmentByteExtractor());\n+        }\n+\n+        @Override\n+        public Stream<String> dump(MemorySegment segment) {\n+            return dump0(segment, MemorySegment::byteSize, memorySegmentByteExtractor());\n+        }\n+\n+        @Override\n+        public Stream<String> dump(ByteBuffer buffer) {\n+            return dump0(buffer, ByteBuffer::remaining, (bb, index) -> bb.get(bb.position() + (int) (index)));\n+        }\n+\n+        private <M> Stream<String> dump0(M memory,\n+                                         ToLongFunction<M> byteSizeExtractor,\n+                                         DumpState.ByteExtractor<M> byteExtractor) {\n+            requireNonNull(memory);\n+\n+            final long lastIndex = byteSizeExtractor.applyAsLong(memory);\n+            final long lines = (lastIndex + bytesPerLine - 1) \/ bytesPerLine;\n+            final var state = new DumpState<>(memory, lastIndex, byteExtractor, bytesPerLine, columns, lines);\n+            return LongStream.range(0, lines)\n+                    .mapToObj(state::lineMapper);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"StandardMemoryDumper{\" +\n+                    \"bytesPerLine=\" + bytesPerLine +\n+                    \", columns=\" + columns +\n+                    '}';\n+        }\n+\n+        private static DumpState.ByteExtractor<MemorySegment> memorySegmentByteExtractor() {\n+            return (memory, index) -> memory.get(JAVA_BYTE, index);\n+        }\n+\n+    }\n+\n+    private static final class DumpState<M> {\n+\n+        private final M memory;\n+        private final long lastIndex;\n+        private final ByteExtractor<M> byteExtractor;\n+        private final int bytesPerLine;\n+        private final List<StandardMemoryDumperBuilder.Column> columns;\n+        private final long lines;\n+\n+        DumpState(M memory,\n+                  long lastIndex,\n+                  ByteExtractor<M> byteExtractor,\n+                  int bytesPerLine,\n+                  List<StandardMemoryDumperBuilder.Column> columns,\n+                  long lines) {\n+            this.memory = memory;\n+            this.lastIndex = lastIndex;\n+            this.byteExtractor = byteExtractor;\n+            this.bytesPerLine = bytesPerLine;\n+            this.columns = columns;\n+            this.lines = lines;\n+        }\n+\n+\n+        \/**\n+         * {@return a new complete line (either a full line or the last line) for the provided {@code line} number}.\n+         *\n+         * @param line the line to render (non-negative)\n+         * @return a new line or {@code null}\n+         *\/\n+        String lineMapper(long line) {\n+\n+            \/\/ Todo: Investigate how to handle mapped sparse files\n+\n+            final StringBuilder sb = new StringBuilder();\n+            int columnCount = 0;\n+            for (StandardMemoryDumperBuilder.Column c : columns) {\n+                if (columnCount > 0) {\n+                    sb.append(c.delimiter());\n+                }\n+                sb.append(c.prefix());\n+                if (c.type() == StandardMemoryDumperBuilder.ColumnType.INDEX) {\n+                    final int len = c.indexByteLength().orElseThrow();\n+                    sb.append(c.renderer().render(len, toByteArray(len, line * bytesPerLine)));\n+                }\n+                if (c.type() == StandardMemoryDumperBuilder.ColumnType.DATA) {\n+                    final int len;\n+                    final long overflow = (line + 1L) * bytesPerLine - lastIndex;\n+                    if (overflow > 0) {\n+                        \/\/ We are on the last line and the last line needs trimming\n+                        len = Math.toIntExact(bytesPerLine - overflow);\n+                    } else {\n+                        \/\/ We are on a line (last or not) and no trimming needs to be done\n+                        len = bytesPerLine;\n+                    }\n+                    final byte[] bytes = new byte[len];\n+                    for (int i = 0; i < len; i++) {\n+                        final long index = line * bytesPerLine + i;\n+                        bytes[i] = byteExtractor.extract(memory, index);\n+                    }\n+                    sb.append(c.renderer().render(bytesPerLine, bytes));\n+                }\n+                sb.append(c.suffix());\n+                columnCount++;\n+            }\n+            return sb.toString();\n+        }\n+\n+        long lastIndex() {\n+            return lastIndex;\n+        }\n+\n+        @FunctionalInterface\n+        interface ByteExtractor<M> {\n+            byte extract(M memory, long index);\n+\n+            static ByteExtractor<MemorySegment> ofMemorySegment() {\n+                return (memory, index) -> memory.get(JAVA_BYTE, index);\n+            }\n+\n+            static ByteExtractor<byte[]> ofByteArray() {\n+                return (memory, index) -> memory[Math.toIntExact(index)];\n+            }\n+        }\n+    }\n+\n+    private static byte[] toByteArray(int length, long l) {\n+        byte[] result = new byte[length];\n+        if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) {\n+            for (int i = (length - 1); i >= 0; i--) {\n+                result[i] = (byte) (l & 0xFF);\n+                l >>= 8;\n+            }\n+        } else {\n+            for (int i = 0; i < length; i++) {\n+                result[i] = (byte) (l & 0xFF);\n+                l >>= 8;\n+            }\n+        }\n+        return result;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/HexFormat.java","additions":884,"deletions":136,"binary":false,"changes":1020,"status":"modified"},{"patch":"@@ -0,0 +1,279 @@\n+\/*\n+ *  Copyright (c) 2022, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import java.lang.foreign.*;\n+import java.nio.ByteBuffer;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * Internal class to support inspection of memory abstractions like MemorySegments into various formats.\n+ *\/\n+public final class MemoryInspectionUtil {\n+\n+    public static final MemoryInspection.ValueLayoutRenderer STANDARD_VALUE_LAYOUT_RENDERER = new StandardValueLayoutRenderer();\n+\n+    private MemoryInspectionUtil() {\n+    }\n+\n+    \/**\n+     * Returns a human-readable view of the provided {@code segment} viewed through\n+     * the provided {@code layout}.\n+     * <p>\n+     * Lines are separated with the system-dependent line separator {@link System#lineSeparator() }.\n+     * Otherwise, the exact format of the returned view is unspecified and should not\n+     * be acted upon programmatically.\n+     * <p>\n+     * As an example, a MemorySegment viewed though the following memory layout\n+     * {@snippet lang = java:\n+     * var layout = MemoryLayout.structLayout(\n+     *         ValueLayout.JAVA_INT.withName(\"x\"),\n+     *         ValueLayout.JAVA_INT.withName(\"y\")\n+     * ).withName(\"Point\");\n+     *}\n+     * might be rendered to something like this:\n+     * {@snippet lang = text:\n+     * Point {\n+     *   x=1,\n+     *   y=2\n+     * }\n+     *}\n+     * <p>\n+     * This method is intended to view memory segments through small and medium-sized memory layouts\n+     * and is, in all cases, restricted by the inherent String capacity limit.\n+     *\n+     * @param segment to be viewed\n+     * @param layout  to use as a layout when viewing the memory segment\n+     * @return a view of the memory segment viewed through the memory layout\n+     * @throws OutOfMemoryError if the view exceeds the array size VM limit\n+     *\/\n+    private static String toString(MemorySegment segment,\n+                                  MemoryLayout layout,\n+                                  MemoryInspection.ValueLayoutRenderer renderer) {\n+        requireNonNull(segment);\n+        requireNonNull(layout);\n+        requireNonNull(renderer);\n+\n+        final var sb = new StringBuilder();\n+        final Consumer<String> action = line -> {\n+            if (!sb.isEmpty()) {\n+                sb.append(System.lineSeparator());\n+            }\n+            sb.append(line);\n+        };\n+        toString0(segment, layout, renderer, action, new ViewState(), \"\");\n+        return sb.toString();\n+    }\n+\n+    public static Stream<String> inspect(MemorySegment segment,\n+                                         MemoryLayout layout,\n+                                         MemoryInspection.ValueLayoutRenderer renderer) {\n+        requireNonNull(segment);\n+        requireNonNull(layout);\n+        requireNonNull(renderer);\n+\n+        final var builder = Stream.<String>builder();\n+        toString0(segment, layout, renderer, builder::add, new ViewState(), \"\");\n+        return builder.build();\n+    }\n+\n+    private static void toString0(MemorySegment segment,\n+                                 MemoryLayout layout,\n+                                 MemoryInspection.ValueLayoutRenderer renderer,\n+                                 Consumer<String> action,\n+                                 ViewState state,\n+                                 String suffix) {\n+\n+        \/\/ TODO: Replace with \"patterns in switch statement\" once this becomes available.\n+\n+        if (layout instanceof ValueLayout.OfBoolean ofBoolean) {\n+            action.accept(renderValueLayout(state, ofBoolean, renderer.render(ofBoolean, segment.get(ofBoolean, state.indexAndAdd(ofBoolean))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfByte ofByte) {\n+            action.accept(renderValueLayout(state, ofByte, renderer.render(ofByte, segment.get(ofByte, state.indexAndAdd(ofByte))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfShort ofShort) {\n+            action.accept(renderValueLayout(state, ofShort, renderer.render(ofShort, segment.get(ofShort, state.indexAndAdd(ofShort))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfInt ofInt) {\n+            action.accept(renderValueLayout(state, ofInt, renderer.render(ofInt, segment.get(ofInt, state.indexAndAdd(ofInt))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfLong ofLong) {\n+            action.accept(renderValueLayout(state, ofLong, renderer.render(ofLong, segment.get(ofLong, state.indexAndAdd(ofLong))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfFloat ofFloat) {\n+            action.accept(renderValueLayout(state, ofFloat, renderer.render(ofFloat, segment.get(ofFloat, state.indexAndAdd(ofFloat))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfDouble ofDouble) {\n+            action.accept(renderValueLayout(state, ofDouble, renderer.render(ofDouble, segment.get(ofDouble, state.indexAndAdd(ofDouble))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfChar ofChar) {\n+            action.accept(renderValueLayout(state, ofChar, renderer.render(ofChar, segment.get(ofChar, state.indexAndAdd(ofChar))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfAddress ofAddress) {\n+            action.accept(renderValueLayout(state, ofAddress, renderer.render(ofAddress, segment.get(ofAddress, state.indexAndAdd(ofAddress))), suffix));\n+            return;\n+        }\n+        \/\/ PaddingLayout is package private.\n+        if (layout instanceof PaddingLayout paddingLayout) {\n+            action.accept(state.indentSpaces() + paddingLayout.bitSize() + \" padding bits\");\n+            state.indexAndAdd(paddingLayout);\n+            return;\n+        }\n+        if (layout instanceof GroupLayout groupLayout) {\n+\n+            \/* Strictly, we should provide all permutations of unions.\n+             * So, if we have a union U =  (A|B),(C|D) then we should present:\n+             * (A,C), (A,D), (B,C) and (B,D)\n+             *\/\n+\n+            final var separator = groupLayout instanceof StructLayout\n+                    ? \",\"  \/\/ Struct separator\n+                    : \"|\"; \/\/ Union separator\n+\n+            action.accept(indentedLabel(state, groupLayout) + \" {\");\n+            state.incrementIndent();\n+            final var members = groupLayout.memberLayouts();\n+            final long initialIndex = state.index();\n+            long maxIndex = initialIndex;\n+            for (int i = 0; i < members.size(); i++) {\n+                if (groupLayout instanceof UnionLayout) {\n+                    \/\/ If it is a union, we need to reset the index for each member\n+                    state.index(initialIndex);\n+                    \/\/ We record the max index used for any union member so we can leave off from there\n+                    maxIndex = Math.max(maxIndex, state.index());\n+                }\n+                toString0(segment, members.get(i), renderer, action, state, (i != (members.size() - 1)) ? separator : \"\");\n+                if (groupLayout instanceof UnionLayout) {\n+                    \/\/ This is the best we can do.\n+                    state.index(maxIndex);\n+                }\n+            }\n+            state.decrementIndent();\n+            action.accept(state.indentSpaces() + \"}\" + suffix);\n+            return;\n+        }\n+        if (layout instanceof SequenceLayout sequenceLayout) {\n+            action.accept(indentedLabel(state, sequenceLayout) + \" [\");\n+            state.incrementIndent();\n+            final long elementCount = sequenceLayout.elementCount();\n+            for (long i = 0; i < elementCount; i++) {\n+                toString0(segment, sequenceLayout.elementLayout(), renderer, action, state, (i != (elementCount - 1L)) ? \",\" : \"\");\n+            }\n+            state.decrementIndent();\n+            action.accept(state.indentSpaces() + \"]\" + suffix);\n+            return;\n+        }\n+        action.accept(state.indentSpaces() + \"Unknown layout: \" + layout + \" at index \" + state.index());\n+        state.indexAndAdd(layout);\n+    }\n+\n+    static String renderValueLayout(ViewState state,\n+                                    ValueLayout layout,\n+                                    String value,\n+                                    String suffix) {\n+        return indentedLabel(state, layout) + \"=\" + value + suffix;\n+    }\n+\n+    static String indentedLabel(ViewState state,\n+                                MemoryLayout layout) {\n+        return state.indentSpaces() + layout.name()\n+                .orElseGet(layout::toString);\n+    }\n+\n+    static final class ViewState {\n+\n+        private static final int SPACES_PER_INDENT = 4;\n+\n+        \/\/ Holding a non-static indents allows simple thread-safe use\n+        private final StringBuilder indents = new StringBuilder();\n+\n+        private int indent;\n+        private long index;\n+\n+        void incrementIndent() {\n+            indent++;\n+        }\n+\n+        void decrementIndent() {\n+            indent--;\n+        }\n+\n+        String indentSpaces() {\n+            final int spaces = indent * SPACES_PER_INDENT;\n+            while (indents.length() < spaces) {\n+                \/\/ Expand as needed\n+                indents.append(\" \");\n+            }\n+            return indents.substring(0, spaces);\n+        }\n+\n+        long index() {\n+            return index;\n+        }\n+\n+        void index(long index) {\n+            this.index = index;\n+        }\n+\n+        long indexAndAdd(long delta) {\n+            final long val = index;\n+            index += delta;\n+            return val;\n+        }\n+\n+        long indexAndAdd(MemoryLayout layout) {\n+            return indexAndAdd(layout.byteSize());\n+        }\n+    }\n+\n+    private static final class StandardValueLayoutRenderer implements MemoryInspection.ValueLayoutRenderer {\n+        @Override\n+        public String toString() {\n+            return singletonToString(StandardValueLayoutRenderer.class);\n+        }\n+    }\n+\n+    private static String singletonToString(Class<?> implementingClass) {\n+        return \"The \" + implementingClass.getName() + \" singleton\";\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemoryInspectionUtil.java","additions":279,"deletions":0,"binary":false,"changes":279,"status":"added"},{"patch":"@@ -0,0 +1,290 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.foreign\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestMemoryInspection\n+ *\/\n+\n+import java.lang.foreign.*;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.foreign.MemoryInspectionUtil;\n+import org.testng.annotations.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.util.stream.Collectors.joining;\n+import static org.testng.Assert.*;\n+import static jdk.internal.foreign.MemoryInspectionUtil.*;\n+import static java.util.Objects.requireNonNull;\n+\n+@Test\n+public class TestMemoryInspection {\n+\n+    private static final String EXPECT_ADDRESS = \"0x\" + \"00\".repeat((int) ValueLayout.ADDRESS.byteSize());\n+\n+    @Test\n+    public void valueLayouts() {\n+\n+        record TestInput(ValueLayout layout, String stringValue) {\n+        }\n+\n+        List.of(\n+                new TestInput(ValueLayout.JAVA_BYTE, \"0\"),\n+                new TestInput(ValueLayout.JAVA_SHORT, \"0\"),\n+                new TestInput(ValueLayout.JAVA_INT, \"0\"),\n+                new TestInput(ValueLayout.JAVA_LONG, \"0\"),\n+                new TestInput(ValueLayout.JAVA_FLOAT, \"0.0\"),\n+                new TestInput(ValueLayout.JAVA_DOUBLE, \"0.0\"),\n+                new TestInput(ValueLayout.JAVA_CHAR, \"\" + (char) 0),\n+                new TestInput(JAVA_BOOLEAN, \"false\"),\n+                new TestInput(ValueLayout.ADDRESS, EXPECT_ADDRESS)\n+        ).forEach(ti -> {\n+            var expect = ti.layout() + \"=\" + ti.stringValue();\n+            var actual = testWithFreshMemorySegment(ti.layout().byteSize(), s -> MemoryInspection.inspect(s, ti.layout(), MemoryInspection.ValueLayoutRenderer.standard()))\n+                    .collect(joining(System.lineSeparator()));\n+            assertEquals(actual, expect);\n+        });\n+    }\n+\n+    @Test\n+    public void point() {\n+\n+        var expect = platformLineSeparated(\"\"\"\n+                Point {\n+                    x=1,\n+                    y=2\n+                }\"\"\");\n+\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 2, segment -> {\n+            final Point point = new Point(segment);\n+            point.x(1);\n+            point.y(2);\n+            return MemoryInspection.inspect(segment, Point.LAYOUT, MemoryInspection.ValueLayoutRenderer.standard())\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void pointCustomRenderer() {\n+\n+        var expect = platformLineSeparated(\"\"\"\n+                Point {\n+                    x=0x0001,\n+                    y=0x0002\n+                }\"\"\");\n+\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 2, segment -> {\n+            final Point point = new Point(segment);\n+            point.x(1);\n+            point.y(2);\n+            return MemoryInspectionUtil.inspect(segment, Point.LAYOUT, new MemoryInspection.ValueLayoutRenderer() {\n+                @Override\n+                public String render(ValueLayout.OfInt intLayout, int value) {\n+                    return String.format(\"0x%04x\", value);\n+                }\n+            })\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void standardCustomRenderer() {\n+\n+        MemoryLayout layout = MemoryLayout.structLayout(\n+                \/\/ These are in bit alignment order (descending) for all platforms\n+                \/\/ in order for each element to be aligned to its type's bit alignment.\n+                Stream.of(\n+                                JAVA_LONG,\n+                                JAVA_DOUBLE,\n+                                ADDRESS,\n+                                JAVA_INT,\n+                                JAVA_FLOAT,\n+                                JAVA_SHORT,\n+                                JAVA_CHAR,\n+                                JAVA_BOOLEAN,\n+                                JAVA_BYTE\n+                        )\n+                        .map(vl -> vl.withName(vl.carrier().getSimpleName()))\n+                        .toArray(MemoryLayout[]::new)\n+        ).withName(\"struct\");\n+\n+        System.out.println(\"layout = \" + layout);\n+        var expect = platformLineSeparated(\"\"\"\n+                struct {\n+                    long=0,\n+                    double=0.0,\n+                    MemorySegment=$1,\n+                    int=0,\n+                    float=0.0,\n+                    short=0,\n+                    char=\\u0000,\n+                    boolean=false,\n+                    byte=0\n+                }\"\"\").replace(\"$1\", EXPECT_ADDRESS);\n+\n+\n+        var actual = testWithFreshMemorySegment(layout.byteSize(), segment ->\n+                MemoryInspection.inspect(segment, layout, MemoryInspection.ValueLayoutRenderer.standard()))\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+\n+    @Test\n+    public void sequence() {\n+        final int arraySize = 4;\n+        var sequenceLayout = MemoryLayout.sequenceLayout(arraySize,\n+                MemoryLayout.structLayout(\n+                        ValueLayout.JAVA_INT.withName(\"x\"),\n+                        ValueLayout.JAVA_INT.withName(\"y\")\n+                ).withName(\"Point\")\n+        ).withName(\"PointArrayOfElements\");\n+\n+        var expect = platformLineSeparated(\"\"\"\n+                PointArrayOfElements [\n+                    Point {\n+                        x=0,\n+                        y=0\n+                    },\n+                    Point {\n+                        x=0,\n+                        y=0\n+                    },\n+                    Point {\n+                        x=0,\n+                        y=0\n+                    },\n+                    Point {\n+                        x=0,\n+                        y=0\n+                    }\n+                ]\"\"\");\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 2 * arraySize, segment ->\n+                MemoryInspection.inspect(segment, sequenceLayout, MemoryInspection.ValueLayoutRenderer.standard()))\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+\n+    @Test\n+    public void union() {\n+        var u0 = MemoryLayout.structLayout(\n+                ValueLayout.JAVA_INT.withName(\"x\"),\n+                ValueLayout.JAVA_INT.withName(\"y\"),\n+                MemoryLayout.paddingLayout(Integer.SIZE)\n+        ).withName(\"Point\");\n+\n+        var u1 = MemoryLayout.structLayout(\n+                ValueLayout.JAVA_INT.withName(\"x\"),\n+                ValueLayout.JAVA_INT.withName(\"y\"),\n+                ValueLayout.JAVA_INT.withName(\"z\")\n+        ).withName(\"3D-Point\");\n+\n+        var union = MemoryLayout.unionLayout(u0, u1).withName(\"Union\");\n+\n+        var expect = platformLineSeparated(\"\"\"\n+                Union {\n+                    Point {\n+                        x=0,\n+                        y=0,\n+                        32 padding bits\n+                    }|\n+                    3D-Point {\n+                        x=0,\n+                        y=0,\n+                        z=0\n+                    }\n+                }\"\"\");\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 3, segment ->\n+                MemoryInspectionUtil.inspect(segment, union, MemoryInspection.ValueLayoutRenderer.standard()))\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    static final class Point {\n+\n+        static final MemoryLayout LAYOUT = MemoryLayout.structLayout(\n+                ValueLayout.JAVA_INT.withName(\"x\"),\n+                ValueLayout.JAVA_INT.withName(\"y\")\n+        ).withName(\"Point\");\n+\n+        static final VarHandle xVH = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"x\"));\n+        static final VarHandle yVH = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"y\"));\n+\n+        private final MemorySegment memorySegment;\n+\n+        Point(MemorySegment memorySegment) {\n+            this.memorySegment = requireNonNull(memorySegment);\n+        }\n+\n+        int x() {\n+            return (int) xVH.get(memorySegment);\n+        }\n+\n+        int y() {\n+            return (int) yVH.get(memorySegment);\n+        }\n+\n+        void x(int x) {\n+            xVH.set(memorySegment, x);\n+        }\n+\n+        void y(int y) {\n+            yVH.set(memorySegment, y);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Point {x=\" + x() + \", y=\" + y() + \"}\";\n+        }\n+    }\n+\n+    private static String platformLineSeparated(String s) {\n+        return s.lines()\n+                .collect(joining(System.lineSeparator()));\n+    }\n+\n+    private static <T> T testWithFreshMemorySegment(long size,\n+                                                    Function<MemorySegment, T> mapper) {\n+        try (final MemorySession session = MemorySession.openConfined()) {\n+            var segment = session.allocate(size);\n+            return mapper.apply(segment);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryInspection.java","additions":290,"deletions":0,"binary":false,"changes":290,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,4 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteBuffer;\n@@ -32,0 +36,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -35,0 +40,1 @@\n+import java.util.function.Function;\n@@ -36,0 +42,1 @@\n+import static java.util.stream.Collectors.joining;\n@@ -45,0 +52,1 @@\n+ * @enablePreview\n@@ -271,1 +279,2 @@\n-        assertThrows(NPE, () -> HexFormat.of().formatHex(null));\n+        assertThrows(NPE, () -> HexFormat.of().formatHex((byte[])null));\n+        assertThrows(NPE, () -> HexFormat.of().formatHex((MemorySegment)null));\n@@ -273,1 +282,2 @@\n-        assertThrows(NPE, () -> HexFormat.of().formatHex(null, null));\n+        assertThrows(NPE, () -> HexFormat.of().formatHex(null, (byte[])null));\n+        assertThrows(NPE, () -> HexFormat.of().formatHex(null, (MemorySegment) null));\n@@ -276,1 +286,2 @@\n-        assertThrows(NPE, () -> HexFormat.of().formatHex(sb, null));\n+        assertThrows(NPE, () -> HexFormat.of().formatHex(sb, (byte[])null));\n+        assertThrows(NPE, () -> HexFormat.of().formatHex(sb, (MemorySegment)null));\n@@ -339,0 +350,16 @@\n+        testFormatter(expected, res, delimiter, prefix, suffix, uppercase);\n+    }\n+\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testFormatterMemorySegment(String delimiter, String prefix, String suffix,\n+                              boolean uppercase,\n+                              HexFormat hex) {\n+        byte[] expected = genBytes('A', 15);\n+        var segment = MemorySegment.ofArray(expected);\n+        String res = hex.formatHex(segment);\n+        testFormatter(expected, res, delimiter, prefix, suffix, uppercase);\n+    }\n+\n+    static void testFormatter(byte[] expected, String res,\n+                              String delimiter, String prefix, String suffix,\n+                              boolean uppercase) {\n@@ -434,0 +461,14 @@\n+        testFormatHexAppendable(expected, sb, s, hex);\n+    }\n+\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testFormatHexAppendableMemorySegment(String unused1, String unused2, String unused3,\n+                                     boolean unused4, HexFormat hex) {\n+        byte[] expected = genBytes('A', 15);\n+        var segment = MemorySegment.ofArray(expected);\n+        StringBuilder sb = new StringBuilder();\n+        StringBuilder s = hex.formatHex(sb, segment);\n+        testFormatHexAppendable(expected, sb, s, hex);\n+    }\n+\n+    static void testFormatHexAppendable(byte[] expected, StringBuilder sb, StringBuilder s, HexFormat hex) {\n@@ -559,0 +600,12 @@\n+\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testZeroLengthMemorySegment(String delimiter, String prefix, String suffix, boolean uppercase,\n+                                HexFormat hex) {\n+        \/\/ Test formatting of zero length byte arrays, should produce no output\n+        var segment = MemorySegment.ofArray(new byte[0]);\n+        StringBuilder sb = new StringBuilder();\n+        assertEquals(hex.formatHex(segment), \"\", \"Zero length\");\n+\n+        hex.formatHex(sb, segment);\n+        assertEquals(sb.length(), 0, \"length should not change\");\n+    }\n@@ -617,0 +670,2 @@\n+        assertThrows(UncheckedIOException.class,\n+                () -> hex.formatHex(throwingAppendable, MemorySegment.ofArray(new byte[1])));\n@@ -735,0 +790,366 @@\n+\n+    private static final int HEX_SEGMENT_SIZE = 64 + 4;\n+    private static final String THE_QUICK = \"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\";\n+\n+    private static final byte[] THE_QUICK_ARRAY = THE_QUICK.getBytes(StandardCharsets.UTF_8);\n+    private static final String EXPECTED_HEX = platformLineSeparated(\"\"\"\n+            0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 |The quick brown |\n+            0000000000000010 66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20 |fox jumped over |\n+            0000000000000020 74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63 |the lazy dog.Sec|\n+            0000000000000030 6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65 00 00 |ond line.:here..|\n+            0000000000000040 00 00 00 00                                     |....            |\"\"\");\n+\n+    private static final String EXPECTED_HEX_SPECIAL = platformLineSeparated(\"\"\"\n+            0000000000000000  54 68 65 20 71 75 69 63  6b 20 62 72 6f 77 6e 20  |The quick brown |\n+            0000000000000010  66 6f 78 20 6a 75 6d 70  65 64 20 6f 76 65 72 20  |fox jumped over |\n+            0000000000000020  74 68 65 20 6c 61 7a 79  20 64 6f 67 0a 53 65 63  |the lazy dog.Sec|\n+            0000000000000030  6f 6e 64 20 6c 69 6e 65  09 3a 68 65 72 65 00 00  |ond line.:here..|\n+            0000000000000040  00 00 00 00                                       |....            |\"\"\");\n+\n+    private static final String EXPECT_ADDRESS = \"0x\" + \"00\".repeat((int) ValueLayout.ADDRESS.byteSize());\n+\n+    @Test\n+    public void testDump64BitIndexToConsole() {\n+        System.out.println(\"***\");\n+        try (var session = MemorySession.openConfined()) {\n+            var segment = session.allocateUtf8String(THE_QUICK);\n+            HexFormat.MemoryDumper dumper = HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn()\n+                    .build();\n+\n+            System.out.println(dumper);\n+\n+            dumper.dump(segment)\n+                    .forEach(System.out::println);\n+        }\n+    }\n+\n+    @Test\n+    public void testDump64BitIndex() {\n+\n+        var expect = \"\"\"\n+                0000000000000000\n+                0000000000000010\n+                0000000000000020\n+                0000000000000030\n+                0000000000000040\"\"\";\n+\n+        var actual = testWithFreshMemorySegment(HEX_SEGMENT_SIZE, segment -> {\n+            segment.setUtf8String(0, THE_QUICK);\n+            return HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn()\n+                    .build()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testDump32BitIndex() {\n+\n+        var expect = \"\"\"\n+                00000000\n+                00000010\n+                00000020\n+                00000030\n+                00000040\"\"\";\n+\n+        var actual = testWithFreshMemorySegment(HEX_SEGMENT_SIZE, segment -> {\n+            segment.setUtf8String(0, THE_QUICK);\n+            return HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn(Integer.BYTES)\n+                    .build()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testDump8BitIndex() {\n+\n+        var expect = \"\"\"\n+                00\n+                10\n+                20\n+                30\n+                40\"\"\";\n+\n+        var actual = testWithFreshMemorySegment(HEX_SEGMENT_SIZE, segment -> {\n+            segment.setUtf8String(0, THE_QUICK);\n+            return HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn(1)\n+                    .build()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testHexStreamOneByte() {\n+\n+        var expect = platformLineSeparated(\"0000000000000000 41 00                                           |A.              |\");\n+\n+        var actual = testWithFreshMemorySegment(2, segment -> {\n+            segment.setUtf8String(0, \"A\");\n+            return HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn()\n+                    .addDataColumn()\n+                    .withColumnPrefix(\"|\")\n+                    .withColumnSuffix(\"|\")\n+                    .addDataColumn(HexFormat.MemoryDumper.Builder.ColumnRenderer.ofAscii())\n+                    .build()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testHexStreamOneByteWithStrangeFormatting() {\n+\n+        var expect = platformLineSeparated(\"0x00--,0x00--,0x00--,0x00--,0x00--,0x00--,0x00--,0x00-- 0x41--,0x00--,                                                                                                  |A.              |\");\n+\n+        var actual = testWithFreshMemorySegment(2, segment -> {\n+            segment.setUtf8String(0, \"A\");\n+            var formatter = HexFormat.ofDelimiter(\",\").withPrefix(\"0x\").withSuffix(\"--\");\n+            return HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn(8, formatter)\n+                    .addDataColumn(formatter)\n+                    .withColumnPrefix(\"|\")\n+                    .withColumnSuffix(\"|\")\n+                    .addDataColumn(HexFormat.MemoryDumper.Builder.ColumnRenderer.ofAscii())\n+                    .build()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testHexStream() {\n+\n+        var actual = testWithFreshMemorySegment(HEX_SEGMENT_SIZE, segment -> {\n+            segment.setUtf8String(0, THE_QUICK);\n+            return HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn()\n+                    .addDataColumn()\n+                    .withColumnPrefix(\"|\")\n+                    .withColumnSuffix(\"|\")\n+                    .addDataColumn(HexFormat.MemoryDumper.Builder.ColumnRenderer.ofAscii())\n+                    .build()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+        assertEquals(actual, EXPECTED_HEX);\n+    }\n+\n+    @Test\n+    public void testEmptyMemoryDump() {\n+        var actual = testWithFreshMemorySegment(0, segment ->\n+                HexFormat.MemoryDumper.builder()\n+                        .addIndexColumn()\n+                        .build()\n+                        .dump(segment)\n+                        .collect(joining())\n+        );\n+        assertEquals(actual, \"\");\n+    }\n+\n+    @Test\n+    public void testEmptyDumper() {\n+        var actual = testWithFreshMemorySegment(10, segment ->\n+                HexFormat.MemoryDumper.builder()\n+                        .build()\n+                        .dump(segment)\n+                        .collect(joining())\n+        );\n+        assertEquals(actual, \"\");\n+    }\n+\n+    @Test\n+    public void test256HexDump() {\n+        var expect = platformLineSeparated(\"\"\"\n+                0000000000000000 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n+                0000000000000010 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f |................|\n+                0000000000000020 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f | !\"#$%&'()*+,-.\/|\n+                0000000000000030 30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f |0123456789:;<=>?|\n+                0000000000000040 40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f |@ABCDEFGHIJKLMNO|\n+                0000000000000050 50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f |PQRSTUVWXYZ[\\\\]^_|\n+                0000000000000060 60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f |`abcdefghijklmno|\n+                0000000000000070 70 71 72 73 74 75 76 77 78 79 7a 7b 7c 7d 7e 7f |pqrstuvwxyz{|}~.|\n+                0000000000000080 80 81 82 83 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f |................|\n+                0000000000000090 90 91 92 93 94 95 96 97 98 99 9a 9b 9c 9d 9e 9f |................|\n+                00000000000000a0 a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 aa ab ac ad ae af |................|\n+                00000000000000b0 b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 ba bb bc bd be bf |................|\n+                00000000000000c0 c0 c1 c2 c3 c4 c5 c6 c7 c8 c9 ca cb cc cd ce cf |................|\n+                00000000000000d0 d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 da db dc dd de df |................|\n+                00000000000000e0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 ea eb ec ed ee ef |................|\n+                00000000000000f0 f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 fa fb fc fd fe ff |................|\"\"\");\n+\n+        try (var session = MemorySession.openConfined()) {\n+            var segment = session.allocate(256);\n+            for (int i = 0; i < segment.byteSize(); i++) {\n+                segment.set(ValueLayout.JAVA_BYTE, i, (byte) i);\n+            }\n+            var actual = HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn()\n+                    .addDataColumn()\n+                    .withColumnPrefix(\"|\")\n+                    .withColumnSuffix(\"|\")\n+                    .addDataColumn(HexFormat.MemoryDumper.Builder.ColumnRenderer.ofAscii())\n+                    .build()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+            assertEquals(actual, expect);\n+        }\n+    }\n+\n+    @Test\n+    public void test4kHexDump() {\n+        try (var session = MemorySession.openConfined()) {\n+            var segment = session.allocate(2048);\n+            for (int i = 0; i < segment.byteSize(); i++) {\n+                segment.set(ValueLayout.JAVA_BYTE, i, (byte) i);\n+            }\n+            var stat = HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn()\n+                    .addDataColumn()\n+                    .withColumnPrefix(\"|\")\n+                    .withColumnSuffix(\"|\")\n+                    .addDataColumn(HexFormat.MemoryDumper.Builder.ColumnRenderer.ofAscii())\n+                    .build()\n+                    .dump(segment)\n+                    .mapToInt(String::length)\n+                    .summaryStatistics();\n+\n+            \/\/ Every row is of equal length\n+            assertEquals(stat.getMax(), stat.getMin());\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testStandardDump() {\n+        var actual = testWithFreshMemorySegment(HEX_SEGMENT_SIZE, segment -> {\n+            segment.setUtf8String(0, THE_QUICK);\n+            return HexFormat.MemoryDumper.standard()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+        assertEquals(actual, EXPECTED_HEX);\n+    }\n+\n+    @Test\n+    public void testStandardDumpWithArray() {\n+        var expect = \"\"\"\n+                0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 |The quick brown |\n+                0000000000000010 66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20 |fox jumped over |\n+                0000000000000020 74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63 |the lazy dog.Sec|\n+                0000000000000030 6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65       |ond line.:here  |\"\"\";\n+        var actual = HexFormat.MemoryDumper.standard()\n+                    .dump(THE_QUICK_ARRAY)\n+                    .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testStandardDumpWithArrayFromToEndpoints() {\n+        var expect = \"\"\"\n+                0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 |The quick brown |\n+                0000000000000010 66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20 |fox jumped over |\n+                0000000000000020 74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63 |the lazy dog.Sec|\n+                0000000000000030 6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65       |ond line.:here  |\"\"\";\n+        var actual = HexFormat.MemoryDumper.standard()\n+                .dump(THE_QUICK_ARRAY, 0, THE_QUICK_ARRAY.length)\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testStandardDumpWithArrayFrom0To13() {\n+        var expect = \"\"\"\n+                0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f          |The quick bro   |\"\"\";\n+        var actual = HexFormat.MemoryDumper.standard()\n+                .dump(THE_QUICK_ARRAY, 0, 13)\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testStandardDumpWithArrayFrom2To9() {\n+        var expect = \"\"\"\n+                0000000000000000 65 20 71 75 69 63 6b                            |e quick         |\"\"\";\n+        var actual = HexFormat.MemoryDumper.standard()\n+                .dump(THE_QUICK_ARRAY, 2, 9)\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testStandardDumpByteBuffer() {\n+        var expect = \"\"\"\n+                0000000000000000 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 66 |he quick brown f|\n+                0000000000000010 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20 74 |ox jumped over t|\n+                0000000000000020 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63 6f |he lazy dog.Seco|\n+                0000000000000030 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65          |nd line.:here   |\"\"\";\n+        var buffer = ByteBuffer.wrap(THE_QUICK_ARRAY);\n+        \/\/ Consume a byte\n+        buffer.get();\n+        var actual = HexFormat.MemoryDumper.standard()\n+                .dump(buffer)\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    public void testSeveralColumns() {\n+        try (var session = MemorySession.openConfined()) {\n+            var segment = session.allocateUtf8String(THE_QUICK);\n+            var expect = \"\"\"\n++0000000000000000+ -00000000- \/54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20\/ *54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20* 0000\n++0000000000000010+ -00000010- \/66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20\/ *66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20* 0010\n++0000000000000020+ -00000020- \/74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63\/ *74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63* 0020\n++0000000000000030+ -00000030- \/6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65 00   \/ *6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65 00   * 0030\"\"\";\n+            var actual = HexFormat.MemoryDumper.builder()\n+                    .withColumnPrefix(\"+\")\n+                    .withColumnSuffix(\"+\")\n+                    .addIndexColumn()\n+                    .withColumnPrefix(\"-\")\n+                    .withColumnSuffix(\"-\")\n+                    .addIndexColumn(4)\n+                    .withColumnPrefix(\"\/\")\n+                    .withColumnSuffix(\"\/\")\n+                    .addDataColumn()\n+                    .withColumnPrefix(\"*\")\n+                    .withColumnSuffix(\"*\")\n+                    .addDataColumn()\n+                    .withColumnPrefix(\"\")\n+                    .withColumnSuffix(\"\")\n+                    .addIndexColumn(2)\n+                    .build()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+            assertEquals(actual, expect);\n+        }\n+    }\n+\n+    private static String platformLineSeparated(String s) {\n+        return s.lines()\n+                .collect(joining(System.lineSeparator()));\n+    }\n+\n+    private static <T> T testWithFreshMemorySegment(long size,\n+                                                    Function<MemorySegment, T> mapper) {\n+        try (final MemorySession session = MemorySession.openConfined()) {\n+            var segment = session.allocate(size);\n+            return mapper.apply(segment);\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/util\/HexFormat\/HexFormatTest.java","additions":425,"deletions":4,"binary":false,"changes":429,"status":"modified"}]}