{"files":[{"patch":"@@ -3,1 +3,1 @@\n-import jdk.internal.foreign.MemorySegmentRenderUtil;\n+import jdk.internal.foreign.MemoryInspectionUtil;\n@@ -6,0 +6,1 @@\n+import java.nio.ByteOrder;\n@@ -10,1 +11,1 @@\n-import static jdk.internal.foreign.MemorySegmentRenderUtil.*;\n+import static jdk.internal.foreign.MemoryInspectionUtil.*;\n@@ -13,1 +14,1 @@\n- * Class that support inspection of various memory abstractions such as\n+ * Class that supports inspection of various memory abstractions such as memory of type\n@@ -84,1 +85,1 @@\n-        return MemorySegmentRenderUtil.hexDump(memory, adapter);\n+        return MemoryInspectionUtil.hexDump(memory, adapter);\n@@ -131,1 +132,1 @@\n-            return MemorySegmentRenderUtil.toString(segment, layout, renderer);\n+            return MemoryInspectionUtil.toString(segment, layout, renderer);\n@@ -139,1 +140,1 @@\n-            return MemorySegmentRenderUtil.toString(segment, layout, renderer);\n+            return MemoryInspectionUtil.toString(segment, layout, renderer);\n@@ -189,0 +190,9 @@\n+        \/**\n+         * {@return a {@code MemoryAdapter<int[]> } that reads byte values from an int array}\n+         * <p>\n+         * Bytes are read according to the {@linkplain ByteOrder#nativeOrder() native order}\n+         *\/\n+        static Adapter<int[]> ofIntArray() {\n+            return INT_ARRAY_MEMORY_ADAPTER;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryInspection.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1925,1 +1925,1 @@\n-        return MemorySegmentRenderUtil.toString(this, layout, renderer);\n+        return MemoryInspectionUtil.toString(this, layout, renderer);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.nio.ByteOrder;\n@@ -38,1 +39,1 @@\n- * Internal class to support rendering of MemorySegments into various formats.\n+ * Internal class to support inspection of memory abstractions like MemorySegments into various formats.\n@@ -40,1 +41,1 @@\n-public final class MemorySegmentRenderUtil {\n+public final class MemoryInspectionUtil {\n@@ -53,0 +54,1 @@\n+    public static final MemoryInspection.Adapter<int[]> INT_ARRAY_MEMORY_ADAPTER = new IntArrayMemoryAdapter();\n@@ -54,1 +56,1 @@\n-    private MemorySegmentRenderUtil() {\n+    private MemoryInspectionUtil() {\n@@ -462,0 +464,1 @@\n+\n@@ -468,0 +471,24 @@\n+    private static final class IntArrayMemoryAdapter implements MemoryInspection.Adapter<int[]> {\n+\n+        @Override\n+        public byte get(int[] intArray, long offset) {\n+            int intOffset = Math.toIntExact(offset);\n+            int index = intOffset \/ Integer.BYTES;\n+            int subIndex = intOffset & (Integer.BYTES - 1);\n+            int value = ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN\n+                    ? Integer.reverseBytes(intArray[index])\n+                    : intArray[index];\n+            return (byte) ((value >> (8 * subIndex)) & 0xff);\n+        }\n+\n+        @Override\n+        public long length(int[] byteArray) {\n+            return byteArray.length * (long) Integer.BYTES;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return singletonToString(IntArrayMemoryAdapter.class);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemoryInspectionUtil.java","additions":30,"deletions":3,"binary":false,"changes":33,"previous_filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySegmentRenderUtil.java","status":"renamed"},{"patch":"@@ -1,375 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @modules java.base\/jdk.internal.foreign\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED RenderTest\n- *\/\n-\n-import java.lang.foreign.*;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteBuffer;\n-import java.nio.charset.StandardCharsets;\n-import java.util.List;\n-import java.util.function.Function;\n-import java.util.stream.Stream;\n-\n-import jdk.internal.foreign.MemorySegmentRenderUtil;\n-import org.testng.annotations.*;\n-\n-import static java.lang.foreign.ValueLayout.*;\n-import static java.util.stream.Collectors.joining;\n-import static org.testng.Assert.*;\n-import static jdk.internal.foreign.MemorySegmentRenderUtil.*;\n-import static java.util.Objects.requireNonNull;\n-\n-@Test\n-public class RenderTest {\n-\n-    private static final int HEX_SEGMENT_SIZE = 64 + 4;\n-    private static final String THE_QUICK = \"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\";\n-\n-    private static final byte[] THE_QUICK_ARRAY = THE_QUICK.getBytes(StandardCharsets.UTF_8);\n-    private static final String EXPECTED_HEX = platformLineSeparated(\"\"\"\n-            0000000000000000  54 68 65 20 71 75 69 63  6B 20 62 72 6F 77 6E 20  |The quick brown |\n-            0000000000000010  66 6F 78 20 6A 75 6D 70  65 64 20 6F 76 65 72 20  |fox jumped over |\n-            0000000000000020  74 68 65 20 6C 61 7A 79  20 64 6F 67 0A 53 65 63  |the lazy dog.Sec|\n-            0000000000000030  6F 6E 64 20 6C 69 6E 65  09 3A 68 65 72 65 00 00  |ond line.:here..|\n-            0000000000000040  00 00 00 00                                       |....|\"\"\");\n-\n-    private static final String EXPECT_ADDRESS = \"0x\" + \"00\".repeat((int) ValueLayout.ADDRESS.byteSize());\n-\n-    @Test\n-    public void testHexStream() {\n-\n-        var actual = testWithFreshMemorySegment(HEX_SEGMENT_SIZE, segment -> {\n-            segment.setUtf8String(0, THE_QUICK);\n-            return hexDump(segment, MemoryInspection.Adapter.ofMemorySegment())\n-                    .collect(joining(System.lineSeparator()));\n-        });\n-        assertEquals(actual, EXPECTED_HEX);\n-    }\n-\n-    @Test\n-    public void testHexStreamByteArray() {\n-\n-        final byte[] array = new byte[HEX_SEGMENT_SIZE];\n-        System.arraycopy(THE_QUICK_ARRAY, 0, array, 0, THE_QUICK.length());\n-        var actual = hexDump(array, MemoryInspection.Adapter.ofByteArray())\n-                .collect(joining(System.lineSeparator()));\n-\n-        assertEquals(actual, EXPECTED_HEX);\n-    }\n-\n-    @Test\n-    public void testHexStreamByteBuffer() {\n-\n-        var array = new byte[HEX_SEGMENT_SIZE];\n-        System.arraycopy(THE_QUICK_ARRAY, 0, array, 0, THE_QUICK.length());\n-        var bb = ByteBuffer.wrap(array);\n-        var actual = hexDump(bb, MemoryInspection.Adapter.ofByteBuffer())\n-                .collect(joining(System.lineSeparator()));\n-\n-        assertEquals(actual, EXPECTED_HEX);\n-    }\n-\n-\n-    @Test\n-    public void valueLayouts() {\n-\n-\n-\n-        record TestInput(ValueLayout layout, String stringValue) {\n-        }\n-\n-        List.of(\n-                new TestInput(ValueLayout.JAVA_BYTE, \"0\"),\n-                new TestInput(ValueLayout.JAVA_SHORT, \"0\"),\n-                new TestInput(ValueLayout.JAVA_INT, \"0\"),\n-                new TestInput(ValueLayout.JAVA_LONG, \"0\"),\n-                new TestInput(ValueLayout.JAVA_FLOAT, \"0.0\"),\n-                new TestInput(ValueLayout.JAVA_DOUBLE, \"0.0\"),\n-                new TestInput(ValueLayout.JAVA_CHAR, \"\" + (char) 0),\n-                new TestInput(JAVA_BOOLEAN, \"false\"),\n-                new TestInput(ValueLayout.ADDRESS, EXPECT_ADDRESS)\n-        ).forEach(ti -> {\n-            var expect = ti.layout() + \"=\" + ti.stringValue();\n-            var actual = testWithFreshMemorySegment(ti.layout().byteSize(), s -> MemorySegmentRenderUtil.toString(s, ti.layout(), MemoryInspection.ValueLayoutRenderer.standard()));\n-            assertEquals(actual, expect);\n-        });\n-    }\n-\n-    @Test\n-    public void test256HexDump() {\n-        var expect = platformLineSeparated(\"\"\"\n-                0000000000000000  00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F  |................|\n-                0000000000000010  10 11 12 13 14 15 16 17  18 19 1A 1B 1C 1D 1E 1F  |................|\n-                0000000000000020  20 21 22 23 24 25 26 27  28 29 2A 2B 2C 2D 2E 2F  | !\"#$%&'()*+,-.\/|\n-                0000000000000030  30 31 32 33 34 35 36 37  38 39 3A 3B 3C 3D 3E 3F  |0123456789:;<=>?|\n-                0000000000000040  40 41 42 43 44 45 46 47  48 49 4A 4B 4C 4D 4E 4F  |@ABCDEFGHIJKLMNO|\n-                0000000000000050  50 51 52 53 54 55 56 57  58 59 5A 5B 5C 5D 5E 5F  |PQRSTUVWXYZ[\\\\]^_|\n-                0000000000000060  60 61 62 63 64 65 66 67  68 69 6A 6B 6C 6D 6E 6F  |`abcdefghijklmno|\n-                0000000000000070  70 71 72 73 74 75 76 77  78 79 7A 7B 7C 7D 7E 7F  |pqrstuvwxyz{|}~.|\n-                0000000000000080  80 81 82 83 84 85 86 87  88 89 8A 8B 8C 8D 8E 8F  |................|\n-                0000000000000090  90 91 92 93 94 95 96 97  98 99 9A 9B 9C 9D 9E 9F  |................|\n-                00000000000000A0  A0 A1 A2 A3 A4 A5 A6 A7  A8 A9 AA AB AC AD AE AF  |................|\n-                00000000000000B0  B0 B1 B2 B3 B4 B5 B6 B7  B8 B9 BA BB BC BD BE BF  |................|\n-                00000000000000C0  C0 C1 C2 C3 C4 C5 C6 C7  C8 C9 CA CB CC CD CE CF  |................|\n-                00000000000000D0  D0 D1 D2 D3 D4 D5 D6 D7  D8 D9 DA DB DC DD DE DF  |................|\n-                00000000000000E0  E0 E1 E2 E3 E4 E5 E6 E7  E8 E9 EA EB EC ED EE EF  |................|\n-                00000000000000F0  F0 F1 F2 F3 F4 F5 F6 F7  F8 F9 FA FB FC FD FE FF  |................|\"\"\");\n-\n-        try (var session = MemorySession.openConfined()) {\n-            var segment = session.allocate(256);\n-            for (int i = 0; i < segment.byteSize(); i++) {\n-                segment.set(ValueLayout.JAVA_BYTE, i, (byte) i);\n-            }\n-            var actual = MemorySegmentRenderUtil.hexDump(segment, MemoryInspection.Adapter.ofMemorySegment())\n-                    .collect(joining(System.lineSeparator()));\n-            assertEquals(actual, expect);\n-        }\n-    }\n-\n-    @Test\n-    public void test4kHexDump() {\n-        try (var session = MemorySession.openConfined()) {\n-            var segment = session.allocate(2048);\n-            for (int i = 0; i < segment.byteSize(); i++) {\n-                segment.set(ValueLayout.JAVA_BYTE, i, (byte) i);\n-            }\n-            MemorySegmentRenderUtil.hexDump(segment, MemoryInspection.Adapter.ofMemorySegment())\n-                    .forEach(l -> assertEquals(l.length(), \"0000000000000000  00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F  |................|\".length()));\n-        }\n-    }\n-\n-    @Test\n-    public void point() {\n-\n-        var expect = platformLineSeparated(\"\"\"\n-                Point {\n-                    x=1,\n-                    y=2\n-                }\"\"\");\n-\n-        var actual = testWithFreshMemorySegment(Integer.BYTES * 2, segment -> {\n-            final Point point = new Point(segment);\n-            point.x(1);\n-            point.y(2);\n-            return MemorySegmentRenderUtil.toString(segment, Point.LAYOUT, MemoryInspection.ValueLayoutRenderer.standard());\n-        });\n-\n-        assertEquals(actual, expect);\n-    }\n-\n-    @Test\n-    public void pointCustomRenderer() {\n-\n-        var expect = platformLineSeparated(\"\"\"\n-                Point {\n-                    x=0x0001,\n-                    y=0x0002\n-                }\"\"\");\n-\n-        var actual = testWithFreshMemorySegment(Integer.BYTES * 2, segment -> {\n-            final Point point = new Point(segment);\n-            point.x(1);\n-            point.y(2);\n-            return MemorySegmentRenderUtil.toString(segment, Point.LAYOUT, new MemoryInspection.ValueLayoutRenderer() {\n-                @Override\n-                public String render(ValueLayout.OfInt layout, int value) {\n-                    return String.format(\"0x%04x\", value);\n-                }\n-            });\n-        });\n-\n-        assertEquals(actual, expect);\n-    }\n-\n-    @Test\n-    public void standardCustomRenderer() {\n-\n-        MemoryLayout layout = MemoryLayout.structLayout(\n-                \/\/ These are in bit alignment order (descending) for all platforms\n-                \/\/ in order for each element to be aligned to its type's bit alignment.\n-                Stream.of(\n-                                JAVA_LONG,\n-                                JAVA_DOUBLE,\n-                                ADDRESS,\n-                                JAVA_INT,\n-                                JAVA_FLOAT,\n-                                JAVA_SHORT,\n-                                JAVA_CHAR,\n-                                JAVA_BOOLEAN,\n-                                JAVA_BYTE\n-                        )\n-                        .map(vl -> vl.withName(vl.carrier().getSimpleName()))\n-                        .toArray(MemoryLayout[]::new)\n-        ).withName(\"struct\");\n-\n-        System.out.println(\"layout = \" + layout);\n-        var expect = platformLineSeparated(\"\"\"\n-                struct {\n-                    long=0,\n-                    double=0.0,\n-                    MemorySegment=$1,\n-                    int=0,\n-                    float=0.0,\n-                    short=0,\n-                    char=\\u0000,\n-                    boolean=false,\n-                    byte=0\n-                }\"\"\").replace(\"$1\", EXPECT_ADDRESS);\n-\n-\n-        var actual = testWithFreshMemorySegment(layout.byteSize(), segment ->\n-                MemorySegmentRenderUtil.toString(segment, layout, MemoryInspection.ValueLayoutRenderer.standard()));\n-\n-        assertEquals(actual, expect);\n-    }\n-\n-\n-    @Test\n-    public void sequence() {\n-        final int arraySize = 4;\n-        var sequenceLayout = MemoryLayout.sequenceLayout(arraySize,\n-                MemoryLayout.structLayout(\n-                        ValueLayout.JAVA_INT.withName(\"x\"),\n-                        ValueLayout.JAVA_INT.withName(\"y\")\n-                ).withName(\"Point\")\n-        ).withName(\"PointArrayOfElements\");\n-\n-        var expect = platformLineSeparated(\"\"\"\n-                PointArrayOfElements [\n-                    Point {\n-                        x=0,\n-                        y=0\n-                    },\n-                    Point {\n-                        x=0,\n-                        y=0\n-                    },\n-                    Point {\n-                        x=0,\n-                        y=0\n-                    },\n-                    Point {\n-                        x=0,\n-                        y=0\n-                    }\n-                ]\"\"\");\n-        var actual = testWithFreshMemorySegment(Integer.BYTES * 2 * arraySize, segment ->\n-                MemorySegmentRenderUtil.toString(segment, sequenceLayout, MemoryInspection.ValueLayoutRenderer.standard()));\n-\n-        assertEquals(actual, expect);\n-    }\n-\n-\n-    @Test\n-    public void union() {\n-        var u0 = MemoryLayout.structLayout(\n-                ValueLayout.JAVA_INT.withName(\"x\"),\n-                ValueLayout.JAVA_INT.withName(\"y\"),\n-                MemoryLayout.paddingLayout(Integer.SIZE)\n-        ).withName(\"Point\");\n-\n-        var u1 = MemoryLayout.structLayout(\n-                ValueLayout.JAVA_INT.withName(\"x\"),\n-                ValueLayout.JAVA_INT.withName(\"y\"),\n-                ValueLayout.JAVA_INT.withName(\"z\")\n-        ).withName(\"3D-Point\");\n-\n-        var union = MemoryLayout.unionLayout(u0, u1).withName(\"Union\");\n-\n-        var expect = platformLineSeparated(\"\"\"\n-                Union {\n-                    Point {\n-                        x=0,\n-                        y=0,\n-                        32 padding bits\n-                    }|\n-                    3D-Point {\n-                        x=0,\n-                        y=0,\n-                        z=0\n-                    }\n-                }\"\"\");\n-        var actual = testWithFreshMemorySegment(Integer.BYTES * 3, segment ->\n-                MemorySegmentRenderUtil.toString(segment, union, MemoryInspection.ValueLayoutRenderer.standard()));\n-\n-        assertEquals(actual, expect);\n-    }\n-\n-    static final class Point {\n-\n-        static final MemoryLayout LAYOUT = MemoryLayout.structLayout(\n-                ValueLayout.JAVA_INT.withName(\"x\"),\n-                ValueLayout.JAVA_INT.withName(\"y\")\n-        ).withName(\"Point\");\n-\n-        static final VarHandle xVH = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"x\"));\n-        static final VarHandle yVH = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"y\"));\n-\n-        private final MemorySegment memorySegment;\n-\n-        Point(MemorySegment memorySegment) {\n-            this.memorySegment = requireNonNull(memorySegment);\n-        }\n-\n-        int x() {\n-            return (int) xVH.get(memorySegment);\n-        }\n-\n-        int y() {\n-            return (int) yVH.get(memorySegment);\n-        }\n-\n-        void x(int x) {\n-            xVH.set(memorySegment, x);\n-        }\n-\n-        void y(int y) {\n-            yVH.set(memorySegment, y);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"Point {x=\" + x() + \", y=\" + y() + \"}\";\n-        }\n-    }\n-\n-    private static String platformLineSeparated(String s) {\n-        return s.lines()\n-                .collect(joining(System.lineSeparator()));\n-    }\n-\n-    private static <T> T testWithFreshMemorySegment(long size,\n-                                                    Function<MemorySegment, T> mapper) {\n-        try (final MemorySession session = MemorySession.openConfined()) {\n-            var segment = session.allocate(size);\n-            return mapper.apply(segment);\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/foreign\/RenderTest.java","additions":0,"deletions":375,"binary":false,"changes":375,"status":"deleted"},{"patch":"@@ -0,0 +1,416 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.foreign\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestMemoryInspection\n+ *\/\n+\n+import java.lang.foreign.*;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.foreign.MemoryInspectionUtil;\n+import org.testng.annotations.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.util.stream.Collectors.joining;\n+import static org.testng.Assert.*;\n+import static jdk.internal.foreign.MemoryInspectionUtil.*;\n+import static java.util.Objects.requireNonNull;\n+\n+@Test\n+public class TestMemoryInspection {\n+\n+    private static final int HEX_SEGMENT_SIZE = 64 + 4;\n+    private static final String THE_QUICK = \"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\";\n+\n+    private static final byte[] THE_QUICK_ARRAY = THE_QUICK.getBytes(StandardCharsets.UTF_8);\n+    private static final String EXPECTED_HEX = platformLineSeparated(\"\"\"\n+            0000000000000000  54 68 65 20 71 75 69 63  6B 20 62 72 6F 77 6E 20  |The quick brown |\n+            0000000000000010  66 6F 78 20 6A 75 6D 70  65 64 20 6F 76 65 72 20  |fox jumped over |\n+            0000000000000020  74 68 65 20 6C 61 7A 79  20 64 6F 67 0A 53 65 63  |the lazy dog.Sec|\n+            0000000000000030  6F 6E 64 20 6C 69 6E 65  09 3A 68 65 72 65 00 00  |ond line.:here..|\n+            0000000000000040  00 00 00 00                                       |....|\"\"\");\n+\n+    private static final String EXPECT_ADDRESS = \"0x\" + \"00\".repeat((int) ValueLayout.ADDRESS.byteSize());\n+\n+    @Test\n+    public void testHexStream() {\n+\n+        var actual = testWithFreshMemorySegment(HEX_SEGMENT_SIZE, segment -> {\n+            segment.setUtf8String(0, THE_QUICK);\n+            return hexDump(segment, MemoryInspection.Adapter.ofMemorySegment())\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+        assertEquals(actual, EXPECTED_HEX);\n+    }\n+\n+    @Test\n+    public void testHexStreamByteArray() {\n+\n+        final byte[] array = new byte[HEX_SEGMENT_SIZE];\n+        System.arraycopy(THE_QUICK_ARRAY, 0, array, 0, THE_QUICK.length());\n+        var actual = hexDump(array, MemoryInspection.Adapter.ofByteArray())\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, EXPECTED_HEX);\n+    }\n+\n+    public void testHexStreamIntArray() {\n+\n+        final byte[] byteArray = new byte[HEX_SEGMENT_SIZE];\n+        System.arraycopy(THE_QUICK_ARRAY, 0, byteArray, 0, THE_QUICK.length());\n+        final var intByteBuffer = ByteBuffer.wrap(byteArray).asIntBuffer();\n+        final int[] array = new int[HEX_SEGMENT_SIZE \/ Integer.BYTES];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = intByteBuffer.get(i);\n+        }\n+\n+        var actual = hexDump(array, MemoryInspection.Adapter.ofIntArray())\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, EXPECTED_HEX);\n+    }\n+\n+    @Test\n+    public void testHexStreamByteBuffer() {\n+\n+        var array = new byte[HEX_SEGMENT_SIZE];\n+        System.arraycopy(THE_QUICK_ARRAY, 0, array, 0, THE_QUICK.length());\n+        var bb = ByteBuffer.wrap(array);\n+        var actual = hexDump(bb, MemoryInspection.Adapter.ofByteBuffer())\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, EXPECTED_HEX);\n+    }\n+\n+\n+    @Test\n+    public void valueLayouts() {\n+\n+        record TestInput(ValueLayout layout, String stringValue) {\n+        }\n+\n+        List.of(\n+                new TestInput(ValueLayout.JAVA_BYTE, \"0\"),\n+                new TestInput(ValueLayout.JAVA_SHORT, \"0\"),\n+                new TestInput(ValueLayout.JAVA_INT, \"0\"),\n+                new TestInput(ValueLayout.JAVA_LONG, \"0\"),\n+                new TestInput(ValueLayout.JAVA_FLOAT, \"0.0\"),\n+                new TestInput(ValueLayout.JAVA_DOUBLE, \"0.0\"),\n+                new TestInput(ValueLayout.JAVA_CHAR, \"\" + (char) 0),\n+                new TestInput(JAVA_BOOLEAN, \"false\"),\n+                new TestInput(ValueLayout.ADDRESS, EXPECT_ADDRESS)\n+        ).forEach(ti -> {\n+            var expect = ti.layout() + \"=\" + ti.stringValue();\n+            var actual = testWithFreshMemorySegment(ti.layout().byteSize(), s -> MemoryInspectionUtil.toString(s, ti.layout(), MemoryInspection.ValueLayoutRenderer.standard()));\n+            assertEquals(actual, expect);\n+        });\n+    }\n+\n+    @Test\n+    public void test256HexDump() {\n+        var expect = platformLineSeparated(\"\"\"\n+                0000000000000000  00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F  |................|\n+                0000000000000010  10 11 12 13 14 15 16 17  18 19 1A 1B 1C 1D 1E 1F  |................|\n+                0000000000000020  20 21 22 23 24 25 26 27  28 29 2A 2B 2C 2D 2E 2F  | !\"#$%&'()*+,-.\/|\n+                0000000000000030  30 31 32 33 34 35 36 37  38 39 3A 3B 3C 3D 3E 3F  |0123456789:;<=>?|\n+                0000000000000040  40 41 42 43 44 45 46 47  48 49 4A 4B 4C 4D 4E 4F  |@ABCDEFGHIJKLMNO|\n+                0000000000000050  50 51 52 53 54 55 56 57  58 59 5A 5B 5C 5D 5E 5F  |PQRSTUVWXYZ[\\\\]^_|\n+                0000000000000060  60 61 62 63 64 65 66 67  68 69 6A 6B 6C 6D 6E 6F  |`abcdefghijklmno|\n+                0000000000000070  70 71 72 73 74 75 76 77  78 79 7A 7B 7C 7D 7E 7F  |pqrstuvwxyz{|}~.|\n+                0000000000000080  80 81 82 83 84 85 86 87  88 89 8A 8B 8C 8D 8E 8F  |................|\n+                0000000000000090  90 91 92 93 94 95 96 97  98 99 9A 9B 9C 9D 9E 9F  |................|\n+                00000000000000A0  A0 A1 A2 A3 A4 A5 A6 A7  A8 A9 AA AB AC AD AE AF  |................|\n+                00000000000000B0  B0 B1 B2 B3 B4 B5 B6 B7  B8 B9 BA BB BC BD BE BF  |................|\n+                00000000000000C0  C0 C1 C2 C3 C4 C5 C6 C7  C8 C9 CA CB CC CD CE CF  |................|\n+                00000000000000D0  D0 D1 D2 D3 D4 D5 D6 D7  D8 D9 DA DB DC DD DE DF  |................|\n+                00000000000000E0  E0 E1 E2 E3 E4 E5 E6 E7  E8 E9 EA EB EC ED EE EF  |................|\n+                00000000000000F0  F0 F1 F2 F3 F4 F5 F6 F7  F8 F9 FA FB FC FD FE FF  |................|\"\"\");\n+\n+        try (var session = MemorySession.openConfined()) {\n+            var segment = session.allocate(256);\n+            for (int i = 0; i < segment.byteSize(); i++) {\n+                segment.set(ValueLayout.JAVA_BYTE, i, (byte) i);\n+            }\n+            var actual = MemoryInspectionUtil.hexDump(segment, MemoryInspection.Adapter.ofMemorySegment())\n+                    .collect(joining(System.lineSeparator()));\n+            assertEquals(actual, expect);\n+        }\n+    }\n+\n+    @Test\n+    public void test4kHexDump() {\n+        try (var session = MemorySession.openConfined()) {\n+            var segment = session.allocate(2048);\n+            for (int i = 0; i < segment.byteSize(); i++) {\n+                segment.set(ValueLayout.JAVA_BYTE, i, (byte) i);\n+            }\n+            MemoryInspectionUtil.hexDump(segment, MemoryInspection.Adapter.ofMemorySegment())\n+                    .forEach(l -> assertEquals(l.length(), \"0000000000000000  00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F  |................|\".length()));\n+        }\n+    }\n+\n+    @Test\n+    public void point() {\n+\n+        var expect = platformLineSeparated(\"\"\"\n+                Point {\n+                    x=1,\n+                    y=2\n+                }\"\"\");\n+\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 2, segment -> {\n+            final Point point = new Point(segment);\n+            point.x(1);\n+            point.y(2);\n+            return MemoryInspectionUtil.toString(segment, Point.LAYOUT, MemoryInspection.ValueLayoutRenderer.standard());\n+        });\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+\n+    @Test\n+    public void pointByteBuffer() {\n+\n+        var expect = platformLineSeparated(\"\"\"\n+                Point {\n+                    x=1,\n+                    y=2\n+                }\"\"\");\n+\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 2, segment -> {\n+            final Point point = new Point(segment);\n+            point.x(1);\n+            point.y(2);\n+\n+            ByteBuffer byteBuffer = segment.asByteBuffer();\n+\n+            return MemoryInspection.toString(\n+                    byteBuffer,\n+                    MemoryInspection.Adapter.ofByteBuffer(),\n+                    Point.LAYOUT,\n+                    MemoryInspection.ValueLayoutRenderer.standard());\n+        });\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void pointCustomRenderer() {\n+\n+        var expect = platformLineSeparated(\"\"\"\n+                Point {\n+                    x=0x0001,\n+                    y=0x0002\n+                }\"\"\");\n+\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 2, segment -> {\n+            final Point point = new Point(segment);\n+            point.x(1);\n+            point.y(2);\n+            return MemoryInspectionUtil.toString(segment, Point.LAYOUT, new MemoryInspection.ValueLayoutRenderer() {\n+                @Override\n+                public String render(ValueLayout.OfInt layout, int value) {\n+                    return String.format(\"0x%04x\", value);\n+                }\n+            });\n+        });\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void standardCustomRenderer() {\n+\n+        MemoryLayout layout = MemoryLayout.structLayout(\n+                \/\/ These are in bit alignment order (descending) for all platforms\n+                \/\/ in order for each element to be aligned to its type's bit alignment.\n+                Stream.of(\n+                                JAVA_LONG,\n+                                JAVA_DOUBLE,\n+                                ADDRESS,\n+                                JAVA_INT,\n+                                JAVA_FLOAT,\n+                                JAVA_SHORT,\n+                                JAVA_CHAR,\n+                                JAVA_BOOLEAN,\n+                                JAVA_BYTE\n+                        )\n+                        .map(vl -> vl.withName(vl.carrier().getSimpleName()))\n+                        .toArray(MemoryLayout[]::new)\n+        ).withName(\"struct\");\n+\n+        System.out.println(\"layout = \" + layout);\n+        var expect = platformLineSeparated(\"\"\"\n+                struct {\n+                    long=0,\n+                    double=0.0,\n+                    MemorySegment=$1,\n+                    int=0,\n+                    float=0.0,\n+                    short=0,\n+                    char=\\u0000,\n+                    boolean=false,\n+                    byte=0\n+                }\"\"\").replace(\"$1\", EXPECT_ADDRESS);\n+\n+\n+        var actual = testWithFreshMemorySegment(layout.byteSize(), segment ->\n+                MemoryInspectionUtil.toString(segment, layout, MemoryInspection.ValueLayoutRenderer.standard()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+\n+    @Test\n+    public void sequence() {\n+        final int arraySize = 4;\n+        var sequenceLayout = MemoryLayout.sequenceLayout(arraySize,\n+                MemoryLayout.structLayout(\n+                        ValueLayout.JAVA_INT.withName(\"x\"),\n+                        ValueLayout.JAVA_INT.withName(\"y\")\n+                ).withName(\"Point\")\n+        ).withName(\"PointArrayOfElements\");\n+\n+        var expect = platformLineSeparated(\"\"\"\n+                PointArrayOfElements [\n+                    Point {\n+                        x=0,\n+                        y=0\n+                    },\n+                    Point {\n+                        x=0,\n+                        y=0\n+                    },\n+                    Point {\n+                        x=0,\n+                        y=0\n+                    },\n+                    Point {\n+                        x=0,\n+                        y=0\n+                    }\n+                ]\"\"\");\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 2 * arraySize, segment ->\n+                MemoryInspectionUtil.toString(segment, sequenceLayout, MemoryInspection.ValueLayoutRenderer.standard()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+\n+    @Test\n+    public void union() {\n+        var u0 = MemoryLayout.structLayout(\n+                ValueLayout.JAVA_INT.withName(\"x\"),\n+                ValueLayout.JAVA_INT.withName(\"y\"),\n+                MemoryLayout.paddingLayout(Integer.SIZE)\n+        ).withName(\"Point\");\n+\n+        var u1 = MemoryLayout.structLayout(\n+                ValueLayout.JAVA_INT.withName(\"x\"),\n+                ValueLayout.JAVA_INT.withName(\"y\"),\n+                ValueLayout.JAVA_INT.withName(\"z\")\n+        ).withName(\"3D-Point\");\n+\n+        var union = MemoryLayout.unionLayout(u0, u1).withName(\"Union\");\n+\n+        var expect = platformLineSeparated(\"\"\"\n+                Union {\n+                    Point {\n+                        x=0,\n+                        y=0,\n+                        32 padding bits\n+                    }|\n+                    3D-Point {\n+                        x=0,\n+                        y=0,\n+                        z=0\n+                    }\n+                }\"\"\");\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 3, segment ->\n+                MemoryInspectionUtil.toString(segment, union, MemoryInspection.ValueLayoutRenderer.standard()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    static final class Point {\n+\n+        static final MemoryLayout LAYOUT = MemoryLayout.structLayout(\n+                ValueLayout.JAVA_INT.withName(\"x\"),\n+                ValueLayout.JAVA_INT.withName(\"y\")\n+        ).withName(\"Point\");\n+\n+        static final VarHandle xVH = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"x\"));\n+        static final VarHandle yVH = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"y\"));\n+\n+        private final MemorySegment memorySegment;\n+\n+        Point(MemorySegment memorySegment) {\n+            this.memorySegment = requireNonNull(memorySegment);\n+        }\n+\n+        int x() {\n+            return (int) xVH.get(memorySegment);\n+        }\n+\n+        int y() {\n+            return (int) yVH.get(memorySegment);\n+        }\n+\n+        void x(int x) {\n+            xVH.set(memorySegment, x);\n+        }\n+\n+        void y(int y) {\n+            yVH.set(memorySegment, y);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Point {x=\" + x() + \", y=\" + y() + \"}\";\n+        }\n+    }\n+\n+    private static String platformLineSeparated(String s) {\n+        return s.lines()\n+                .collect(joining(System.lineSeparator()));\n+    }\n+\n+    private static <T> T testWithFreshMemorySegment(long size,\n+                                                    Function<MemorySegment, T> mapper) {\n+        try (final MemorySession session = MemorySession.openConfined()) {\n+            var segment = session.allocate(size);\n+            return mapper.apply(segment);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryInspection.java","additions":416,"deletions":0,"binary":false,"changes":416,"status":"added"}]}