{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,5 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n@@ -36,0 +41,6 @@\n+import java.util.function.ToLongFunction;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.util.Objects.requireNonNull;\n@@ -81,2 +92,1 @@\n- * @apiNote\n- * For example, an individual byte is converted to a string of hexadecimal digits using\n+ * @apiNote For example, an individual byte is converted to a string of hexadecimal digits using\n@@ -133,1 +143,0 @@\n- *\n@@ -157,1 +166,1 @@\n-             0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,\n+            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1,\n@@ -180,0 +189,2 @@\n+    private static final int DUMP_BYTES_PER_ROW = 16;\n+\n@@ -189,3 +200,3 @@\n-     * @param prefix a prefix, non-null\n-     * @param suffix a suffix, non-null\n-     * @param digits byte array of digits indexed by low nibble, non-null\n+     * @param prefix    a prefix, non-null\n+     * @param suffix    a suffix, non-null\n+     * @param digits    byte array of digits indexed by low nibble, non-null\n@@ -232,0 +243,1 @@\n+     *\n@@ -311,1 +323,1 @@\n-     *          otherwise {@code false}\n+     * otherwise {@code false}\n@@ -322,1 +334,1 @@\n-     *\n+     * <p>\n@@ -339,1 +351,1 @@\n-     * @param bytes a non-null array of bytes\n+     * @param bytes     a non-null array of bytes\n@@ -341,1 +353,1 @@\n-     * @param toIndex the final index of the range, exclusive\n+     * @param toIndex   the final index of the range, exclusive\n@@ -346,1 +358,1 @@\n-        Objects.requireNonNull(bytes,\"bytes\");\n+        Objects.requireNonNull(bytes, \"bytes\");\n@@ -370,2 +382,2 @@\n-     * @param <A> The type of {@code Appendable}\n-     * @param out an {@code Appendable}, non-null\n+     * @param <A>   The type of {@code Appendable}\n+     * @param out   an {@code Appendable}, non-null\n@@ -380,0 +392,72 @@\n+    \/**\n+     * Returns a hexadecimal string formatted from the provided {@linkplain MemorySegment segment}.\n+     * Each byte value is formatted as the prefix, two hexadecimal characters\n+     * {@linkplain #isUpperCase selected from} uppercase or lowercase digits, and the suffix.\n+     * A delimiter follows each formatted value, except the last.\n+     * <p>\n+     * The behavior is equivalent to\n+     * {@link #formatHex(Appendable, MemorySegment) formatHex(new StringBuilder(), segment).toString())}.\n+     * <p>\n+     * To view parts of a memory segment, use {@linkplain MemorySegment#asSlice(long) a slice}.\n+     *\n+     * @param segment a non-null memory segment\n+     * @return a string hexadecimal formatting of the byte array\n+     * @throws UncheckedIOException  if an I\/O exception occurs appending to the output\n+     * @throws IllegalStateException if the {@linkplain MemorySegment#session() session} associated with this\n+     *                               segment is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException  if this method is called from a thread other than the thread owning\n+     *                               the {@linkplain MemorySegment#session() session} associated with this segment.\n+     * @see #formatHex(Appendable, MemorySegment)\n+     *\/\n+    public String formatHex(MemorySegment segment) {\n+        return formatHex(new StringBuilder(), segment).toString();\n+    }\n+\n+    \/**\n+     * Appends formatted hexadecimal strings from the provided {@linkplain MemorySegment segment}\n+     * to the provided {@linkplain Appendable out}.\n+     * Each byte value is formatted as the prefix, two hexadecimal characters\n+     * {@linkplain #isUpperCase selected from} uppercase or lowercase digits, and the suffix.\n+     * A delimiter follows each formatted value, except the last.\n+     * The formatted hexadecimal strings are appended in zero or more calls to the {@link Appendable} methods.\n+     * <p>\n+     * To view parts of a memory segment, use {@linkplain MemorySegment#asSlice(long) a slice}.\n+     *\n+     * @param <A>     The type of {@code Appendable}\n+     * @param out     an {@code Appendable}, non-null\n+     * @param segment a memory segment\n+     * @return the {@code Appendable}\n+     * @throws UncheckedIOException  if an I\/O exception occurs appending to the output\n+     * @throws IllegalStateException if the {@linkplain MemorySegment#session() session} associated with this\n+     *                               segment is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException  if this method is called from a thread other than the thread owning\n+     *                               the {@linkplain MemorySegment#session() session} associated with this segment.\n+     *\/\n+    public <A extends Appendable> A formatHex(A out, MemorySegment segment) {\n+        Objects.requireNonNull(out, \"out\");\n+        Objects.requireNonNull(segment, \"segment\");\n+\n+        long length = segment.byteSize();\n+        if (length > 0) {\n+            try {\n+                String between = suffix + delimiter + prefix;\n+                out.append(prefix);\n+                toHexDigits(out, segment.get(ValueLayout.JAVA_BYTE, 0));\n+                if (between.isEmpty()) {\n+                    for (long i = 1; i < length; i++) {\n+                        toHexDigits(out, segment.get(ValueLayout.JAVA_BYTE, i));\n+                    }\n+                } else {\n+                    for (long i = 1; i < length; i++) {\n+                        out.append(between);\n+                        toHexDigits(out, segment.get(ValueLayout.JAVA_BYTE, i));\n+                    }\n+                }\n+                out.append(suffix);\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe.getMessage(), ioe);\n+            }\n+        }\n+        return out;\n+    }\n+\n@@ -387,3 +471,3 @@\n-     * @param <A> The type of {@code Appendable}\n-     * @param out an {@code Appendable}, non-null\n-     * @param bytes a byte array, non-null\n+     * @param <A>       The type of {@code Appendable}\n+     * @param out       an {@code Appendable}, non-null\n+     * @param bytes     a byte array, non-null\n@@ -391,1 +475,1 @@\n-     * @param toIndex the final index of the range, exclusive.\n+     * @param toIndex   the final index of the range, exclusive.\n@@ -394,1 +478,1 @@\n-     * @throws UncheckedIOException if an I\/O exception occurs appending to the output\n+     * @throws UncheckedIOException      if an I\/O exception occurs appending to the output\n@@ -431,1 +515,1 @@\n-     * @param bytes the bytes, non-null\n+     * @param bytes     the bytes, non-null\n@@ -433,1 +517,1 @@\n-     * @param toIndex the final index of the range, exclusive.\n+     * @param toIndex   the final index of the range, exclusive.\n@@ -435,1 +519,1 @@\n-     *         or non-empty prefix or suffix\n+     * or non-empty prefix or suffix\n@@ -447,2 +531,2 @@\n-                rep[i * 2] = (byte)toHighHexDigit(bytes[fromIndex + i]);\n-                rep[i * 2 + 1] = (byte)toLowHexDigit(bytes[fromIndex + i]);\n+                rep[i * 2] = (byte) toHighHexDigit(bytes[fromIndex + i]);\n+                rep[i * 2 + 1] = (byte) toLowHexDigit(bytes[fromIndex + i]);\n@@ -459,1 +543,1 @@\n-                rep[i * 3    ] = (byte) toHighHexDigit(bytes[fromIndex + i]);\n+                rep[i * 3] = (byte) toHighHexDigit(bytes[fromIndex + i]);\n@@ -486,1 +570,1 @@\n-        return (int)length;\n+        return (int) length;\n@@ -491,1 +575,1 @@\n-     *\n+     * <p>\n@@ -498,1 +582,1 @@\n-     *            and delimiters\n+     *               and delimiters\n@@ -501,2 +585,2 @@\n-     *          the byte values are not hexadecimal characters, or if the delimiter is not present\n-     *          after all but the last byte value\n+     *                                  the byte values are not hexadecimal characters, or if the delimiter is not present\n+     *                                  after all but the last byte value\n@@ -510,1 +594,1 @@\n-     *\n+     * <p>\n@@ -516,2 +600,2 @@\n-     * @param string a string range containing hexadecimal digits,\n-     *           delimiters, prefix, and suffix.\n+     * @param string    a string range containing hexadecimal digits,\n+     *                  delimiters, prefix, and suffix.\n@@ -519,1 +603,1 @@\n-     * @param toIndex the final index of the range, exclusive.\n+     * @param toIndex   the final index of the range, exclusive.\n@@ -521,3 +605,3 @@\n-     * @throws IllegalArgumentException if the prefix or suffix is not present for each byte value,\n-     *          the byte values are not hexadecimal characters, or if the delimiter is not present\n-     *          after all but the last byte value\n+     * @throws IllegalArgumentException  if the prefix or suffix is not present for each byte value,\n+     *                                   the byte values are not hexadecimal characters, or if the delimiter is not present\n+     *                                   after all but the last byte value\n@@ -549,1 +633,1 @@\n-        final int len = (int)((string.length() - valueChars) \/ stride + 1L);\n+        final int len = (int) ((string.length() - valueChars) \/ stride + 1L);\n@@ -564,1 +648,1 @@\n-     *\n+     * <p>\n@@ -570,2 +654,2 @@\n-     * @param chars a character array range containing an even number of hexadecimal digits,\n-     *          delimiters, prefix, and suffix.\n+     * @param chars     a character array range containing an even number of hexadecimal digits,\n+     *                  delimiters, prefix, and suffix.\n@@ -573,1 +657,1 @@\n-     * @param toIndex the final index of the range, exclusive.\n+     * @param toIndex   the final index of the range, exclusive.\n@@ -575,3 +659,3 @@\n-     * @throws IllegalArgumentException if the prefix or suffix is not present for each byte value,\n-     *          the byte values are not hexadecimal characters, or if the delimiter is not present\n-     *          after all but the last byte value\n+     * @throws IllegalArgumentException  if the prefix or suffix is not present for each byte value,\n+     *                                   the byte values are not hexadecimal characters, or if the delimiter is not present\n+     *                                   after all but the last byte value\n@@ -591,2 +675,2 @@\n-     * @param string a CharSequence\n-     * @param index the index of the literal in the CharSequence\n+     * @param string  a CharSequence\n+     * @param index   the index of the literal in the CharSequence\n@@ -597,1 +681,1 @@\n-        assert index <= string.length() - literal.length()  : \"pre-checked invariant error\";\n+        assert index <= string.length() - literal.length() : \"pre-checked invariant error\";\n@@ -607,1 +691,1 @@\n-                        \" ch: \" + (int)string.charAt(index + i)));\n+                        \" ch: \" + (int) string.charAt(index + i)));\n@@ -634,1 +718,1 @@\n-        return (char)digits[value & 0xf];\n+        return (char) digits[value & 0xf];\n@@ -648,1 +732,1 @@\n-        return (char)digits[(value >> 4) & 0xf];\n+        return (char) digits[(value >> 4) & 0xf];\n@@ -658,2 +742,2 @@\n-     * @param <A> The type of {@code Appendable}\n-     * @param out an {@code Appendable}, non-null\n+     * @param <A>   The type of {@code Appendable}\n+     * @param out   an {@code Appendable}, non-null\n@@ -686,2 +770,2 @@\n-        rep[0] = (byte)toHighHexDigit(value);\n-        rep[1] = (byte)toLowHexDigit(value);\n+        rep[0] = (byte) toHighHexDigit(value);\n+        rep[1] = (byte) toLowHexDigit(value);\n@@ -705,1 +789,1 @@\n-        return toHexDigits((short)value);\n+        return toHexDigits((short) value);\n@@ -719,4 +803,4 @@\n-        rep[0] = (byte)toHighHexDigit((byte)(value >> 8));\n-        rep[1] = (byte)toLowHexDigit((byte)(value >> 8));\n-        rep[2] = (byte)toHighHexDigit((byte)value);\n-        rep[3] = (byte)toLowHexDigit((byte)value);\n+        rep[0] = (byte) toHighHexDigit((byte) (value >> 8));\n+        rep[1] = (byte) toLowHexDigit((byte) (value >> 8));\n+        rep[2] = (byte) toHighHexDigit((byte) value);\n+        rep[3] = (byte) toLowHexDigit((byte) value);\n@@ -743,8 +827,8 @@\n-        rep[0] = (byte)toHighHexDigit((byte)(value >> 24));\n-        rep[1] = (byte)toLowHexDigit((byte)(value >> 24));\n-        rep[2] = (byte)toHighHexDigit((byte)(value >> 16));\n-        rep[3] = (byte)toLowHexDigit((byte)(value >> 16));\n-        rep[4] = (byte)toHighHexDigit((byte)(value >> 8));\n-        rep[5] = (byte)toLowHexDigit((byte)(value >> 8));\n-        rep[6] = (byte)toHighHexDigit((byte)value);\n-        rep[7] = (byte)toLowHexDigit((byte)value);\n+        rep[0] = (byte) toHighHexDigit((byte) (value >> 24));\n+        rep[1] = (byte) toLowHexDigit((byte) (value >> 24));\n+        rep[2] = (byte) toHighHexDigit((byte) (value >> 16));\n+        rep[3] = (byte) toLowHexDigit((byte) (value >> 16));\n+        rep[4] = (byte) toHighHexDigit((byte) (value >> 8));\n+        rep[5] = (byte) toLowHexDigit((byte) (value >> 8));\n+        rep[6] = (byte) toHighHexDigit((byte) value);\n+        rep[7] = (byte) toLowHexDigit((byte) value);\n@@ -771,16 +855,16 @@\n-        rep[0] = (byte)toHighHexDigit((byte)(value >>> 56));\n-        rep[1] = (byte)toLowHexDigit((byte)(value >>> 56));\n-        rep[2] = (byte)toHighHexDigit((byte)(value >>> 48));\n-        rep[3] = (byte)toLowHexDigit((byte)(value >>> 48));\n-        rep[4] = (byte)toHighHexDigit((byte)(value >>> 40));\n-        rep[5] = (byte)toLowHexDigit((byte)(value >>> 40));\n-        rep[6] = (byte)toHighHexDigit((byte)(value >>> 32));\n-        rep[7] = (byte)toLowHexDigit((byte)(value >>> 32));\n-        rep[8] = (byte)toHighHexDigit((byte)(value >>> 24));\n-        rep[9] = (byte)toLowHexDigit((byte)(value >>> 24));\n-        rep[10] = (byte)toHighHexDigit((byte)(value >>> 16));\n-        rep[11] = (byte)toLowHexDigit((byte)(value >>> 16));\n-        rep[12] = (byte)toHighHexDigit((byte)(value >>> 8));\n-        rep[13] = (byte)toLowHexDigit((byte)(value >>> 8));\n-        rep[14] = (byte)toHighHexDigit((byte)value);\n-        rep[15] = (byte)toLowHexDigit((byte)value);\n+        rep[0] = (byte) toHighHexDigit((byte) (value >>> 56));\n+        rep[1] = (byte) toLowHexDigit((byte) (value >>> 56));\n+        rep[2] = (byte) toHighHexDigit((byte) (value >>> 48));\n+        rep[3] = (byte) toLowHexDigit((byte) (value >>> 48));\n+        rep[4] = (byte) toHighHexDigit((byte) (value >>> 40));\n+        rep[5] = (byte) toLowHexDigit((byte) (value >>> 40));\n+        rep[6] = (byte) toHighHexDigit((byte) (value >>> 32));\n+        rep[7] = (byte) toLowHexDigit((byte) (value >>> 32));\n+        rep[8] = (byte) toHighHexDigit((byte) (value >>> 24));\n+        rep[9] = (byte) toLowHexDigit((byte) (value >>> 24));\n+        rep[10] = (byte) toHighHexDigit((byte) (value >>> 16));\n+        rep[11] = (byte) toLowHexDigit((byte) (value >>> 16));\n+        rep[12] = (byte) toHighHexDigit((byte) (value >>> 8));\n+        rep[13] = (byte) toLowHexDigit((byte) (value >>> 8));\n+        rep[14] = (byte) toHighHexDigit((byte) value);\n+        rep[15] = (byte) toLowHexDigit((byte) value);\n@@ -801,1 +885,1 @@\n-     * @param value a {@code long} value\n+     * @param value  a {@code long} value\n@@ -804,1 +888,1 @@\n-     * @throws  IllegalArgumentException if {@code digits} is negative or greater than 16\n+     * @throws IllegalArgumentException if {@code digits} is negative or greater than 16\n@@ -813,1 +897,1 @@\n-            rep[i] = (byte)toLowHexDigit((byte)(value));\n+            rep[i] = (byte) toLowHexDigit((byte) (value));\n@@ -830,1 +914,1 @@\n-     *          the string contains non-hexadecimal characters\n+     *                                  the string contains non-hexadecimal characters\n@@ -849,2 +933,2 @@\n-     * @param toIndex the final index of the range, exclusive.\n-     * @param limit the maximum allowed\n+     * @param toIndex   the final index of the range, exclusive.\n+     * @param limit     the maximum allowed\n@@ -869,0 +953,1 @@\n+     *\n@@ -871,1 +956,1 @@\n-     *          otherwise {@code false}\n+     * otherwise {@code false}\n@@ -888,1 +973,1 @@\n-     * @throws  NumberFormatException if the codepoint is not a hexadecimal character\n+     * @throws NumberFormatException if the codepoint is not a hexadecimal character\n@@ -904,1 +989,1 @@\n-     * @param index the index of the first character of the range\n+     * @param index  the index of the first character of the range\n@@ -906,4 +991,4 @@\n-     * @throws  NumberFormatException if any of the characters in the range\n-     *          is not a hexadecimal character\n-     * @throws  IndexOutOfBoundsException if the range is out of bounds\n-     *          for the {@code CharSequence}\n+     * @throws NumberFormatException     if any of the characters in the range\n+     *                                   is not a hexadecimal character\n+     * @throws IndexOutOfBoundsException if the range is out of bounds\n+     *                                   for the {@code CharSequence}\n@@ -923,2 +1008,3 @@\n-     * @apiNote\n-     * {@link Integer#parseInt(String, int) Integer.parseInt(s, 16)} and\n+     * @param string to parse\n+     * @return the parsed int value\n+     * @apiNote {@link Integer#parseInt(String, int) Integer.parseInt(s, 16)} and\n@@ -931,5 +1017,0 @@\n-     *\n-     * @param string a CharSequence containing up to eight hexadecimal characters\n-     * @return the value parsed from the string\n-     * @throws  IllegalArgumentException if the string length is greater than eight (8) or\n-     *      if any of the characters is not a hexadecimal character\n@@ -949,2 +1030,9 @@\n-     * @apiNote\n-     * {@link Integer#parseInt(String, int) Integer.parseInt(s, 16)} and\n+     * @param string    a CharSequence containing the characters\n+     * @param fromIndex the initial index of the range, inclusive\n+     * @param toIndex   the final index of the range, exclusive.\n+     * @return the value parsed from the string range\n+     * @throws IndexOutOfBoundsException if the range is out of bounds\n+     *                                   for the {@code CharSequence}\n+     * @throws IllegalArgumentException  if length of the range is greater than eight (8) or\n+     *                                   if any of the characters is not a hexadecimal character\n+     * @apiNote {@link Integer#parseInt(String, int) Integer.parseInt(s, 16)} and\n@@ -957,9 +1045,0 @@\n-     *\n-     * @param string a CharSequence containing the characters\n-     * @param fromIndex the initial index of the range, inclusive\n-     * @param toIndex the final index of the range, exclusive.\n-     * @return the value parsed from the string range\n-     * @throws  IndexOutOfBoundsException if the range is out of bounds\n-     *          for the {@code CharSequence}\n-     * @throws  IllegalArgumentException if length of the range is greater than eight (8) or\n-     *          if any of the characters is not a hexadecimal character\n@@ -984,2 +1063,3 @@\n-     * @apiNote\n-     * {@link Long#parseLong(String, int) Long.parseLong(s, 16)} and\n+     * @param string to parse\n+     * @return the parsed long value\n+     * @apiNote {@link Long#parseLong(String, int) Long.parseLong(s, 16)} and\n@@ -992,5 +1072,0 @@\n-     *\n-     * @param string a CharSequence containing up to sixteen hexadecimal characters\n-     * @return the value parsed from the string\n-     * @throws  IllegalArgumentException if the string length is greater than sixteen (16) or\n-     *         if any of the characters is not a hexadecimal character\n@@ -1010,2 +1085,9 @@\n-     * @apiNote\n-     * {@link Long#parseLong(String, int) Long.parseLong(s, 16)} and\n+     * @param string    a CharSequence containing the characters\n+     * @param fromIndex the initial index of the range, inclusive\n+     * @param toIndex   the final index of the range, exclusive.\n+     * @return the value parsed from the string range\n+     * @throws IndexOutOfBoundsException if the range is out of bounds\n+     *                                   for the {@code CharSequence}\n+     * @throws IllegalArgumentException  if the length of the range is greater than sixteen (16) or\n+     *                                   if any of the characters is not a hexadecimal character\n+     * @apiNote {@link Long#parseLong(String, int) Long.parseLong(s, 16)} and\n@@ -1018,9 +1100,0 @@\n-     *\n-     * @param string a CharSequence containing the characters\n-     * @param fromIndex the initial index of the range, inclusive\n-     * @param toIndex the final index of the range, exclusive.\n-     * @return the value parsed from the string range\n-     * @throws  IndexOutOfBoundsException if the range is out of bounds\n-     *          for the {@code CharSequence}\n-     * @throws  IllegalArgumentException if the length of the range is greater than sixteen (16) or\n-     *          if any of the characters is not a hexadecimal character\n@@ -1045,2 +1118,2 @@\n-     *         uppercase, delimiter, prefix, and suffix are equal;\n-     *         otherwise {@code false}\n+     * uppercase, delimiter, prefix, and suffix are equal;\n+     * otherwise {@code false}\n@@ -1086,0 +1159,669 @@\n+\n+    \/**\n+     * A class allowing various memory abstractions (such as MemorySegments and byte arrays) to be dumped into\n+     * various formats.\n+     *\n+     * @author Per Minborg\n+     * @since 20\n+     *\/\n+    public interface MemoryDumper {\n+\n+        \/**\n+         * Returns a Stream of string elements with values for the provided {@code bytes} array.\n+         * <p>\n+         * Each element in the stream depends on how this MemoryDumper was configured via its {@linkplain #builder()}.\n+         * <p>\n+         * As an example, an array created, initialized and used as follows\n+         * {@snippet lang = java:\n+         *   byte[] bytes = \"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\".getBytes(StandardCharsets.UTF_8);\n+         *\n+         *   MemoryDumper dumper = MemoryDumper.builder()\n+         *      .addIndexColumn()\n+         *      .addDataColumn()\n+         *      .withColumnPrefix(\"|\")\n+         *      .withColumnSuffix(\"|\")\n+         *      .addDataColumn(Builder.ColumnRenderer.ofAscii())\n+         *      .build();\n+         *\n+         *   dumper.dump(bytes)\n+         *      .forEach(System.out::println);\n+         *}\n+         * will be printed as:\n+         * {@snippet lang = text:\n+         * 0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 |The quick brown |\n+         * 0000000000000010 66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20 |fox jumped over |\n+         * 0000000000000020 74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63 |the lazy dog.Sec|\n+         * 0000000000000030 6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65 00    |ond line.:here._|\n+         *}\n+         *\n+         * @param bytes to dump\n+         * @return a Stream of string elements\n+         *\/\n+        Stream<String> dump(byte[] bytes);\n+\n+        \/**\n+         * Returns a Stream of string elements with values for the provided {@code bytes} array staring\n+         * at the provided {@code fromIndex} (inclusive) and ending at the provided {@code toIndex} (exclusive).\n+         * <p>\n+         * Each element in the stream depends on how this MemoryDumper was configured via its {@linkplain #builder()}.\n+         * <p>\n+         * As an example, an array created, initialized and used as follows\n+         * {@snippet lang = java:\n+         *   byte[] bytes = \"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\".getBytes(StandardCharsets.UTF_8);\n+         *\n+         *   MemoryDumper dumper = MemoryDumper.builder()\n+         *      .addIndexColumn()\n+         *      .addDataColumn()\n+         *      .withColumnPrefix(\"|\")\n+         *      .withColumnSuffix(\"|\")\n+         *      .addDataColumn(Builder.ColumnRenderer.ofAscii())\n+         *      .build();\n+         *\n+         *   dumper.dump(bytes, 0, 16)\n+         *      .forEach(System.out::println);\n+         *}\n+         * will be printed as:\n+         * {@snippet lang = text:\n+         * 0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 |The quick brown |\n+         *}\n+         *\n+         * @param bytes     to dump\n+         * @param fromIndex the initial index of the range, inclusive\n+         * @param toIndex   the final index of the range, exclusive.\n+         * @return a Stream of string elements\n+         *\/\n+        Stream<String> dump(byte[] bytes, int fromIndex, int toIndex);\n+\n+        \/**\n+         * Returns a Stream of string elements with values for the provided {@code memory} segment.\n+         * <p>\n+         * Each element in the stream depends on how this MemoryDumper was configured via its {@linkplain #builder()}.\n+         * <p>\n+         * As an example, an array created, initialized and used as follows\n+         * {@snippet lang = java:\n+         * MemoryDumper dumper = MemoryDumper.builder()\n+         *            .addIndexColumn()\n+         *            .addDataColumn()\n+         *            .withColumnPrefix(\"|\")\n+         *            .withColumnSuffix(\"|\")\n+         *            .addDataColumn(Builder.ColumnRenderer.ofAscii())\n+         *            .build();\n+         *\n+         * try (MemorySession session = MemorySession.openConfined()) {\n+         *     MemorySegment segment = session.allocateUtf8String(\"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\");\n+         *     dumper.dump(bytes)\n+         *         .forEach(System.out::println);\n+         * }\n+         *}\n+         * will be printed as:\n+         * {@snippet lang = text:\n+         * 0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 |The quick brown |\n+         * 0000000000000010 66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20 |fox jumped over |\n+         * 0000000000000020 74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63 |the lazy dog.Sec|\n+         * 0000000000000030 6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65 00    |ond line.:here._|\n+         *}\n+         *\n+         * @param segment to dump\n+         * @return a Stream of string elements\n+         *\/\n+        Stream<String> dump(MemorySegment segment);\n+\n+        \/**\n+         * Returns a Stream of string elements with values for the provided {@code buffer}.\n+         * <p>\n+         * Each element in the stream depends on how this MemoryDumper was configured via its {@linkplain #builder()}.\n+         * <p>\n+         * As an example, an array created, initialized and used as follows\n+         * {@snippet lang = java:\n+         * var buffer = ByteBuffer.wrap(\"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\".getBytes(StandardCharsets.UTF_8));\n+         * MemoryDumper dumper = MemoryDumper.builder()\n+         *            .addIndexColumn()\n+         *            .addDataColumn()\n+         *            .withColumnPrefix(\"|\")\n+         *            .withColumnSuffix(\"|\")\n+         *            .addDataColumn(Builder.ColumnRenderer.ofAscii())\n+         *            .build();\n+         * dumper.dump(bytes)\n+         *     .forEach(System.out::println);\n+         *}\n+         * will be printed as:\n+         * {@snippet lang = text:\n+         * 0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 |The quick brown |\n+         * 0000000000000010 66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20 |fox jumped over |\n+         * 0000000000000020 74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63 |the lazy dog.Sec|\n+         * 0000000000000030 6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65 00    |ond line.:here._|\n+         *}\n+         *\n+         * @param buffer to dump\n+         * @return a Stream of string elements\n+         *\/\n+        Stream<String> dump(ByteBuffer buffer);\n+\n+        \/**\n+         * {@return a new builder that can be used to configure and create MemoryDumper instances.}\n+         *\/\n+        static Builder builder() {\n+            return new StandardMemoryDumperBuilder();\n+        }\n+\n+        \/**\n+         * {@return a standard MemoryDumper that will format memory segments in human readable form}\n+         * <p>\n+         * As an example, a memory segment, initialized and used as follows\n+         * {@snippet lang = java:\n+         * MemoryDumper dumper = MemoryDumper.standard();\n+         *\n+         * try (MemorySession session = MemorySession.openConfined()) {\n+         *     MemorySegment segment = session.allocateUtf8String(\"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\");\n+         *     dumper.dump(bytes)\n+         *         .forEach(System.out::println);\n+         * }\n+         *}\n+         * will be printed as:\n+         * {@snippet lang = text:\n+         * 0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 |The quick brown |\n+         * 0000000000000010 66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20 |fox jumped over |\n+         * 0000000000000020 74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63 |the lazy dog.Sec|\n+         * 0000000000000030 6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65 00    |ond line.:here._|\n+         *}\n+         *\/\n+        static MemoryDumper standard() {\n+            return StandardMemoryDumper.STANDARD;\n+        }\n+\n+        \/**\n+         * A non-threadsafe builder for MemoryDumper instances.\n+         *\n+         * @since 20\n+         *\/\n+        interface Builder {\n+\n+            \/**\n+             * Configures the number of bytes per line rendered per element in the output Stream.\n+             * <p>\n+             * Unless configured otherwise, the default number of bytes per line is 16.\n+             *\n+             * @param bytesPerLine the number of bytes per line (non-negative)\n+             * @return this Builder\n+             * @throws IllegalArgumentException if the provided {@code bytesPerLine} is negative\n+             *\/\n+            Builder withBytesPerLine(int bytesPerLine);\n+\n+            \/**\n+             * Configures the column prefix for subsequent index and data columns.\n+             * <p>\n+             * Unless configured otherwise, the default column prefix is \"\" (an empty String).\n+             *\n+             * @param prefix the column prefix (non-null)\n+             * @return this Builder\n+             * @throws NullPointerException if the provided {@code prefix} is {@code null}\n+             *\/\n+            Builder withColumnPrefix(String prefix);\n+\n+            \/**\n+             * Configures the column suffix for subsequent index and data columns.\n+             * <p>\n+             * Unless configured otherwise, the default suffix is \"\" (an empty String).\n+             *\n+             * @param suffix the column suffix (non-null)\n+             * @return this Builder\n+             * @throws NullPointerException if the provided {@code suffix} is {@code null}\n+             *\/\n+            Builder withColumnSuffix(String suffix);\n+\n+            \/**\n+             * Configures the column delimiter for subsequent index and data columns.\n+             * <p>\n+             * The column delimiter will be inserted between columns (i.e. not after the last column).\n+             * Unless configured otherwise, the default suffix is \" \" (a single space).\n+             *\n+             * @param delimiter the column delimiter (non-null)\n+             * @return this Builder\n+             * @throws NullPointerException if the provided {@code delimiter} is {@code null}\n+             *\/\n+            Builder withColumnDelimiter(String delimiter);\n+\n+            \/**\n+             * Adds an index column with an 8-byte (64-bit) index with hexadecimal values formatted by\n+             * the default {@link HexFormat#of()} formatter.\n+             *\n+             * @return this Builder\n+             *\/\n+            Builder addIndexColumn();\n+\n+            \/**\n+             * Adds an index column with the provided {@code indexBytes} index with hexadecimal values formatted by\n+             * the default {@link HexFormat#of()} formatter.\n+             *\n+             * @param indexBytes the number of bytes to render in the index (in the range [1, 8])\n+             * @return this Builder\n+             * @throws IllegalArgumentException if the provided {@code bytes} is outside the range [1, 8]\n+             *\/\n+            Builder addIndexColumn(int indexBytes);\n+\n+            \/**\n+             * Adds an index column with the provided {@code indexBytes} index with hexadecimal values formatted by\n+             * the provided {@code formatter }.\n+             *\n+             * @param indexBytes the number of bytes to render in the index (in the range [1, 8])\n+             * @param formatter  the formatter to use for byte values in the index\n+             * @return this Builder\n+             * @throws IllegalArgumentException if the provided {@code bytes} is outside the range [1, 8]\n+             * @throws NullPointerException     if the provided {@code formatter} is {@code null}\n+             *\/\n+            Builder addIndexColumn(int indexBytes, HexFormat formatter);\n+\n+            \/**\n+             * Adds an index column with the provided {@code indexBytes} index with hexadecimal values formatted by\n+             * the provided {@code renderer }.\n+             * <p>\n+             * Indexes used by the provided {@code renderer} are counted as byte indexes with the index value itself\n+             * and runs from the provided {@code bytes - 1} to 0.\n+             *\n+             * @param indexBytes the number of bytes to render in the index (in the range [1, 8])\n+             * @param renderer   the renderer to use for byte values in the index\n+             * @return this Builder\n+             * @throws IllegalArgumentException if the provided {@code bytes} is outside the range [1, 8]\n+             * @throws NullPointerException     if the provided {@code renderer} is {@code null}\n+             *\/\n+            Builder addIndexColumn(int indexBytes, ColumnRenderer renderer);\n+\n+            \/**\n+             * Adds a data column with hexadecimal values formatted by\n+             * a {@code HexFormat.ofDelimiter(\" \")} formatter.\n+             *\n+             * @return this Builder\n+             *\/\n+            Builder addDataColumn();\n+\n+            \/**\n+             * Adds a data column with hexadecimal values formatted by\n+             * the provided {@code formatter }.\n+             *\n+             * @param formatter the formatter to use for byte values in a row\n+             * @return this Builder\n+             * @throws NullPointerException if the provided {@code formatter} is {@code null}\n+             *\/\n+            Builder addDataColumn(HexFormat formatter);\n+\n+            \/**\n+             * Adds a data column with hexadecimal values formatted by\n+             * the provided {@code renderer }.\n+             *\n+             * @param renderer the renderer to use for byte values in a row\n+             * @return this Builder\n+             * @throws NullPointerException if the provided {@code renderer} is {@code null}\n+             *\/\n+            Builder addDataColumn(ColumnRenderer renderer);\n+\n+            \/**\n+             * {@return a new MemoryDumper instance with configurations made so far.}\n+             *\/\n+            MemoryDumper build();\n+\n+            \/**\n+             * Represents a function that accepts a long index and a byte value and produces a String.\n+             *\n+             * @since 20\n+             *\/\n+            @FunctionalInterface\n+            interface ColumnRenderer {\n+\n+                \/**\n+                 * {@return a rendering of the provided {@code bytes} with the provided {@code bytesPerLine} }\n+                 * <p>\n+                 * Note: On the last line, chars may be padded using the ' ' character.\n+                 *\n+                 * @param bytesPerLine the bytes per line\n+                 * @param bytes        the byte array to render\n+                 *\/\n+                String render(int bytesPerLine, byte[] bytes);\n+\n+                \/**\n+                 * {@return a ByteRenderer that renders bytes into human readable characters.}\n+                 *\/\n+                static ColumnRenderer ofAscii() {\n+                    return (bytePerLine, bytes) -> {\n+                        StringBuilder sb = new StringBuilder();\n+                        for (int i = 0; i < bytePerLine; i++) {\n+                            if (i >= bytes.length) {\n+                                \/\/ Padding on the last line\n+                                sb.append(\" \");\n+                            } else {\n+                                final byte val = bytes[i];\n+                                if (val >= 32 && val < 127) {\n+                                    sb.append((char) val);\n+                                } else {\n+                                    sb.append(\".\");\n+                                }\n+                            }\n+                        }\n+                        return sb.toString();\n+                    };\n+                }\n+\n+                \/**\n+                 * {@return a ByteReader that renders bytes as per the provided {@code formatter}}\n+                 *\n+                 * @param formatter to use when formatting values\n+                 *\/\n+                static ColumnRenderer of(HexFormat formatter) {\n+                    requireNonNull(formatter);\n+                    return new ByteRenderedFromHexFormat(formatter);\n+                }\n+\n+            }\n+\n+        }\n+\n+    }\n+\n+    private static final class ByteRenderedFromHexFormat implements MemoryDumper.Builder.ColumnRenderer {\n+\n+        private final HexFormat formatter;\n+\n+        public ByteRenderedFromHexFormat(HexFormat formatter) {\n+            this.formatter = formatter;\n+        }\n+\n+        @Override\n+        public String render(int bytesPerLine, byte[] bytes) {\n+            final var sb = new StringBuilder();\n+            if (bytesPerLine == bytes.length) {\n+                formatter.formatHex(sb, bytes);\n+            } else {\n+                \/\/ We are on the last line which needs padding\n+                final var expanded = new byte[bytesPerLine];\n+                System.arraycopy(bytes, 0, expanded, 0, bytes.length);\n+                formatter.formatHex(sb, expanded);\n+                final int bytesToRemove = bytesPerLine - bytes.length;\n+                final int charsToRemove = bytesToRemove * (formatter.prefix().length()+formatter.suffix().length()+2) +\n+                                          (bytesToRemove -1) * formatter.delimiter().length();\n+                \/\/ Erase the excess part\n+                for (int i = 0; i < charsToRemove; i++) {\n+                    sb.setCharAt(sb.length() - i - 1, ' ');\n+                }\n+            }\n+            return sb.toString();\n+        }\n+    }\n+\n+    private static final class StandardMemoryDumperBuilder implements MemoryDumper.Builder {\n+\n+        private final List<Column> columns;\n+        private int bytesPerLine = 16;\n+        private String columnPrefix = \"\";\n+        private String columnSuffix = \"\";\n+        private String columnDelimiter = \" \";\n+\n+        StandardMemoryDumperBuilder() {\n+            columns = new ArrayList<>();\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder withBytesPerLine(int bytes) {\n+            bytesPerLine = requirePositive(bytes);\n+            return this;\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder withColumnPrefix(String prefix) {\n+            columnPrefix = requireNonNull(prefix);\n+            return this;\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder withColumnSuffix(String suffix) {\n+            columnSuffix = requireNonNull(suffix);\n+            return this;\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder withColumnDelimiter(String delimiter) {\n+            columnDelimiter = requireNonNull(delimiter);\n+            return this;\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder addIndexColumn() {\n+            return addIndexColumn(8);\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder addIndexColumn(int indexBytes) {\n+            requireBetweenClosed(1, 8, indexBytes);\n+            return addIndexColumn(indexBytes, HexFormat.of());\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder addIndexColumn(int indexBytes, HexFormat formatter) {\n+            requireBetweenClosed(1, 8, indexBytes);\n+            requireNonNull(formatter);\n+            return addIndexColumn(indexBytes, ColumnRenderer.of(formatter));\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder addIndexColumn(int indexBytes, ColumnRenderer renderer) {\n+            requireBetweenClosed(1, 8, indexBytes);\n+            requireNonNull(renderer);\n+            columns.add(new Column(ColumnType.INDEX, OptionalInt.of(indexBytes), columnPrefix, renderer, columnSuffix, columnDelimiter));\n+            return this;\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder addDataColumn() {\n+            return addDataColumn(HexFormat.ofDelimiter(\" \"));\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder addDataColumn(HexFormat formatter) {\n+            requireNonNull(formatter);\n+            return addDataColumn(ColumnRenderer.of(formatter));\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder addDataColumn(ColumnRenderer renderer) {\n+            requireNonNull(renderer);\n+            columns.add(new Column(ColumnType.DATA, OptionalInt.empty(), columnPrefix, renderer, columnSuffix, columnDelimiter));\n+            return this;\n+        }\n+\n+        @Override\n+        public MemoryDumper build() {\n+            return new StandardMemoryDumper(bytesPerLine, columns);\n+        }\n+\n+        enum ColumnType {\n+            INDEX, DATA;\n+        }\n+\n+        private record Column(ColumnType type,\n+                              OptionalInt indexByteLength,\n+                              String prefix,\n+                              ColumnRenderer renderer,\n+                              String suffix,\n+                              String delimiter) {\n+        }\n+\n+        private int requirePositive(int value) {\n+            if (value < 1)\n+                throw new IllegalArgumentException(\"Value must be positive:\" + value);\n+            return value;\n+        }\n+\n+        \/\/ We assume from < to\n+        private int requireBetweenClosed(int from, int to, int value) {\n+            if (value < from || value > to)\n+                throw new IllegalArgumentException(\"Value \" + value + \" is not in the range [\" + from + \", \" + to + \"]\");\n+            return value;\n+        }\n+\n+    }\n+\n+    private static final class StandardMemoryDumper implements MemoryDumper {\n+\n+        private static final MemoryDumper STANDARD = MemoryDumper.builder()\n+                .addIndexColumn()\n+                .addDataColumn()\n+                .withColumnPrefix(\"|\")\n+                .withColumnSuffix(\"|\")\n+                .addDataColumn(HexFormat.MemoryDumper.Builder.ColumnRenderer.ofAscii())\n+                .build();\n+\n+        private final int bytesPerLine;\n+        private final List<StandardMemoryDumperBuilder.Column> columns;\n+\n+        StandardMemoryDumper(int bytesPerLine,\n+                             List<StandardMemoryDumperBuilder.Column> columns) {\n+            this.bytesPerLine = bytesPerLine;\n+            this.columns = new ArrayList<>(columns);\n+        }\n+\n+        @Override\n+        public Stream<String> dump(byte[] bytes) {\n+            return dump0(bytes, ba -> ba.length, (ba, index) -> ba[Math.toIntExact(index)]);\n+        }\n+\n+        @Override\n+        public Stream<String> dump(byte[] bytes, int fromIndex, int toIndex) {\n+            if (fromIndex == 0) {\n+                if (toIndex>bytes.length)\n+                    throw new IllegalArgumentException(\"fromIndex \" + fromIndex + \" is greater than the array length \" + bytes.length);\n+                return dump0(bytes, ba -> toIndex, (ba, index) -> ba[(int) index]);\n+            }\n+            return dump0(MemorySegment.ofArray(bytes).asSlice(fromIndex, toIndex - fromIndex),\n+                    MemorySegment::byteSize,\n+                    memorySegmentByteExtractor());\n+        }\n+\n+        @Override\n+        public Stream<String> dump(MemorySegment segment) {\n+            return dump0(segment, MemorySegment::byteSize, memorySegmentByteExtractor());\n+        }\n+\n+        @Override\n+        public Stream<String> dump(ByteBuffer buffer) {\n+            return dump0(buffer, ByteBuffer::remaining, (bb, index) -> bb.get(bb.position() + (int) (index)));\n+        }\n+\n+        private <M> Stream<String> dump0(M memory,\n+                                         ToLongFunction<M> byteSizeExtractor,\n+                                         DumpState.ByteExtractor<M> byteExtractor) {\n+            requireNonNull(memory);\n+\n+            final long lastIndex = byteSizeExtractor.applyAsLong(memory);\n+            final long lines = (lastIndex + bytesPerLine - 1) \/ bytesPerLine;\n+            final var state = new DumpState<>(memory, lastIndex, byteExtractor, bytesPerLine, columns);\n+            return LongStream.range(0, lines)\n+                    .mapToObj(state::lineMapper);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"StandardMemoryDumper{\" +\n+                    \"bytesPerLine=\" + bytesPerLine +\n+                    \", columns=\" + columns +\n+                    '}';\n+        }\n+\n+        private static DumpState.ByteExtractor<MemorySegment> memorySegmentByteExtractor() {\n+            return (memory, index) -> memory.get(JAVA_BYTE, index);\n+        }\n+\n+    }\n+\n+    private static final class DumpState<M> {\n+\n+        private final M memory;\n+        private final long lastIndex;\n+        private final ByteExtractor<M> byteExtractor;\n+        private final int bytesPerLine;\n+        private final List<StandardMemoryDumperBuilder.Column> columns;\n+\n+        DumpState(M memory,\n+                  long lastIndex,\n+                  ByteExtractor<M> byteExtractor,\n+                  int bytesPerLine,\n+                  List<StandardMemoryDumperBuilder.Column> columns) {\n+            this.memory = memory;\n+            this.lastIndex = lastIndex;\n+            this.byteExtractor = byteExtractor;\n+            this.bytesPerLine = bytesPerLine;\n+            this.columns = columns;\n+        }\n+\n+\n+        \/**\n+         * {@return a new complete line (either a full line or the last line) for the provided {@code line} number}.\n+         *\n+         * @param line the line to render (non-negative)\n+         * @return a new line or {@code null}\n+         *\/\n+        String lineMapper(long line) {\n+\n+            \/\/ Todo: Investigate how to handle mapped sparse files\n+\n+            final StringBuilder sb = new StringBuilder();\n+            int columnCount = 0;\n+            for (StandardMemoryDumperBuilder.Column c : columns) {\n+                if (columnCount > 0) {\n+                    sb.append(c.delimiter());\n+                }\n+                sb.append(c.prefix());\n+                if (c.type() == StandardMemoryDumperBuilder.ColumnType.INDEX) {\n+                    final int len = c.indexByteLength().orElseThrow();\n+                    sb.append(c.renderer().render(len, toByteArray(len, line * bytesPerLine)));\n+                }\n+                if (c.type() == StandardMemoryDumperBuilder.ColumnType.DATA) {\n+                    final int len;\n+                    final long overflow = (line + 1L) * bytesPerLine - lastIndex;\n+                    if (overflow > 0) {\n+                        \/\/ We are on the last line and the last line needs trimming\n+                        len = Math.toIntExact(bytesPerLine - overflow);\n+                    } else {\n+                        \/\/ We are on a line (last or not) and no trimming needs to be done\n+                        len = bytesPerLine;\n+                    }\n+                    final byte[] bytes = new byte[len];\n+                    for (int i = 0; i < len; i++) {\n+                        final long index = line * bytesPerLine + i;\n+                        bytes[i] = byteExtractor.extract(memory, index);\n+                    }\n+                    sb.append(c.renderer().render(bytesPerLine, bytes));\n+                }\n+                sb.append(c.suffix());\n+                columnCount++;\n+            }\n+            return sb.toString();\n+        }\n+\n+        @FunctionalInterface\n+        interface ByteExtractor<M> {\n+            byte extract(M memory, long index);\n+\n+            static ByteExtractor<MemorySegment> ofMemorySegment() {\n+                return (memory, index) -> memory.get(JAVA_BYTE, index);\n+            }\n+\n+            static ByteExtractor<byte[]> ofByteArray() {\n+                return (memory, index) -> memory[Math.toIntExact(index)];\n+            }\n+        }\n+    }\n+\n+    private static byte[] toByteArray(int length, long l) {\n+        byte[] result = new byte[length];\n+        if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) {\n+            for (int i = (length - 1); i >= 0; i--) {\n+                result[i] = (byte) (l & 0xFF);\n+                l >>= 8;\n+            }\n+        } else {\n+            for (int i = 0; i < length; i++) {\n+                result[i] = (byte) (l & 0xFF);\n+                l >>= 8;\n+            }\n+        }\n+        return result;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/HexFormat.java","additions":878,"deletions":136,"binary":false,"changes":1014,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,4 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteBuffer;\n@@ -32,0 +36,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -35,0 +40,1 @@\n+import java.util.function.Function;\n@@ -36,0 +42,1 @@\n+import static java.util.stream.Collectors.joining;\n@@ -45,0 +52,1 @@\n+ * @enablePreview\n@@ -271,1 +279,2 @@\n-        assertThrows(NPE, () -> HexFormat.of().formatHex(null));\n+        assertThrows(NPE, () -> HexFormat.of().formatHex((byte[])null));\n+        assertThrows(NPE, () -> HexFormat.of().formatHex((MemorySegment)null));\n@@ -273,1 +282,2 @@\n-        assertThrows(NPE, () -> HexFormat.of().formatHex(null, null));\n+        assertThrows(NPE, () -> HexFormat.of().formatHex(null, (byte[])null));\n+        assertThrows(NPE, () -> HexFormat.of().formatHex(null, (MemorySegment) null));\n@@ -276,1 +286,2 @@\n-        assertThrows(NPE, () -> HexFormat.of().formatHex(sb, null));\n+        assertThrows(NPE, () -> HexFormat.of().formatHex(sb, (byte[])null));\n+        assertThrows(NPE, () -> HexFormat.of().formatHex(sb, (MemorySegment)null));\n@@ -339,0 +350,16 @@\n+        testFormatter(expected, res, delimiter, prefix, suffix, uppercase);\n+    }\n+\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testFormatterMemorySegment(String delimiter, String prefix, String suffix,\n+                              boolean uppercase,\n+                              HexFormat hex) {\n+        byte[] expected = genBytes('A', 15);\n+        var segment = MemorySegment.ofArray(expected);\n+        String res = hex.formatHex(segment);\n+        testFormatter(expected, res, delimiter, prefix, suffix, uppercase);\n+    }\n+\n+    static void testFormatter(byte[] expected, String res,\n+                              String delimiter, String prefix, String suffix,\n+                              boolean uppercase) {\n@@ -434,0 +461,14 @@\n+        testFormatHexAppendable(expected, sb, s, hex);\n+    }\n+\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testFormatHexAppendableMemorySegment(String unused1, String unused2, String unused3,\n+                                     boolean unused4, HexFormat hex) {\n+        byte[] expected = genBytes('A', 15);\n+        var segment = MemorySegment.ofArray(expected);\n+        StringBuilder sb = new StringBuilder();\n+        StringBuilder s = hex.formatHex(sb, segment);\n+        testFormatHexAppendable(expected, sb, s, hex);\n+    }\n+\n+    static void testFormatHexAppendable(byte[] expected, StringBuilder sb, StringBuilder s, HexFormat hex) {\n@@ -559,0 +600,12 @@\n+\n+    @Test(dataProvider=\"HexFormattersParsers\")\n+    static void testZeroLengthMemorySegment(String delimiter, String prefix, String suffix, boolean uppercase,\n+                                HexFormat hex) {\n+        \/\/ Test formatting of zero length byte arrays, should produce no output\n+        var segment = MemorySegment.ofArray(new byte[0]);\n+        StringBuilder sb = new StringBuilder();\n+        assertEquals(hex.formatHex(segment), \"\", \"Zero length\");\n+\n+        hex.formatHex(sb, segment);\n+        assertEquals(sb.length(), 0, \"length should not change\");\n+    }\n@@ -617,0 +670,2 @@\n+        assertThrows(UncheckedIOException.class,\n+                () -> hex.formatHex(throwingAppendable, MemorySegment.ofArray(new byte[1])));\n@@ -735,0 +790,366 @@\n+\n+    private static final int HEX_SEGMENT_SIZE = 64 + 4;\n+    private static final String THE_QUICK = \"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\";\n+\n+    private static final byte[] THE_QUICK_ARRAY = THE_QUICK.getBytes(StandardCharsets.UTF_8);\n+    private static final String EXPECTED_HEX = platformLineSeparated(\"\"\"\n+            0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 |The quick brown |\n+            0000000000000010 66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20 |fox jumped over |\n+            0000000000000020 74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63 |the lazy dog.Sec|\n+            0000000000000030 6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65 00 00 |ond line.:here..|\n+            0000000000000040 00 00 00 00                                     |....            |\"\"\");\n+\n+    private static final String EXPECTED_HEX_SPECIAL = platformLineSeparated(\"\"\"\n+            0000000000000000  54 68 65 20 71 75 69 63  6b 20 62 72 6f 77 6e 20  |The quick brown |\n+            0000000000000010  66 6f 78 20 6a 75 6d 70  65 64 20 6f 76 65 72 20  |fox jumped over |\n+            0000000000000020  74 68 65 20 6c 61 7a 79  20 64 6f 67 0a 53 65 63  |the lazy dog.Sec|\n+            0000000000000030  6f 6e 64 20 6c 69 6e 65  09 3a 68 65 72 65 00 00  |ond line.:here..|\n+            0000000000000040  00 00 00 00                                       |....            |\"\"\");\n+\n+    private static final String EXPECT_ADDRESS = \"0x\" + \"00\".repeat((int) ValueLayout.ADDRESS.byteSize());\n+\n+    @Test\n+    public void testDump64BitIndexToConsole() {\n+        System.out.println(\"***\");\n+        try (var session = MemorySession.openConfined()) {\n+            var segment = session.allocateUtf8String(THE_QUICK);\n+            HexFormat.MemoryDumper dumper = HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn()\n+                    .build();\n+\n+            System.out.println(dumper);\n+\n+            dumper.dump(segment)\n+                    .forEach(System.out::println);\n+        }\n+    }\n+\n+    @Test\n+    public void testDump64BitIndex() {\n+\n+        var expect = \"\"\"\n+                0000000000000000\n+                0000000000000010\n+                0000000000000020\n+                0000000000000030\n+                0000000000000040\"\"\";\n+\n+        var actual = testWithFreshMemorySegment(HEX_SEGMENT_SIZE, segment -> {\n+            segment.setUtf8String(0, THE_QUICK);\n+            return HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn()\n+                    .build()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testDump32BitIndex() {\n+\n+        var expect = \"\"\"\n+                00000000\n+                00000010\n+                00000020\n+                00000030\n+                00000040\"\"\";\n+\n+        var actual = testWithFreshMemorySegment(HEX_SEGMENT_SIZE, segment -> {\n+            segment.setUtf8String(0, THE_QUICK);\n+            return HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn(Integer.BYTES)\n+                    .build()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testDump8BitIndex() {\n+\n+        var expect = \"\"\"\n+                00\n+                10\n+                20\n+                30\n+                40\"\"\";\n+\n+        var actual = testWithFreshMemorySegment(HEX_SEGMENT_SIZE, segment -> {\n+            segment.setUtf8String(0, THE_QUICK);\n+            return HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn(1)\n+                    .build()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testHexStreamOneByte() {\n+\n+        var expect = platformLineSeparated(\"0000000000000000 41 00                                           |A.              |\");\n+\n+        var actual = testWithFreshMemorySegment(2, segment -> {\n+            segment.setUtf8String(0, \"A\");\n+            return HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn()\n+                    .addDataColumn()\n+                    .withColumnPrefix(\"|\")\n+                    .withColumnSuffix(\"|\")\n+                    .addDataColumn(HexFormat.MemoryDumper.Builder.ColumnRenderer.ofAscii())\n+                    .build()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testHexStreamOneByteWithStrangeFormatting() {\n+\n+        var expect = platformLineSeparated(\"0x00--,0x00--,0x00--,0x00--,0x00--,0x00--,0x00--,0x00-- 0x41--,0x00--,                                                                                                  |A.              |\");\n+\n+        var actual = testWithFreshMemorySegment(2, segment -> {\n+            segment.setUtf8String(0, \"A\");\n+            var formatter = HexFormat.ofDelimiter(\",\").withPrefix(\"0x\").withSuffix(\"--\");\n+            return HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn(8, formatter)\n+                    .addDataColumn(formatter)\n+                    .withColumnPrefix(\"|\")\n+                    .withColumnSuffix(\"|\")\n+                    .addDataColumn(HexFormat.MemoryDumper.Builder.ColumnRenderer.ofAscii())\n+                    .build()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testHexStream() {\n+\n+        var actual = testWithFreshMemorySegment(HEX_SEGMENT_SIZE, segment -> {\n+            segment.setUtf8String(0, THE_QUICK);\n+            return HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn()\n+                    .addDataColumn()\n+                    .withColumnPrefix(\"|\")\n+                    .withColumnSuffix(\"|\")\n+                    .addDataColumn(HexFormat.MemoryDumper.Builder.ColumnRenderer.ofAscii())\n+                    .build()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+        assertEquals(actual, EXPECTED_HEX);\n+    }\n+\n+    @Test\n+    public void testEmptyMemoryDump() {\n+        var actual = testWithFreshMemorySegment(0, segment ->\n+                HexFormat.MemoryDumper.builder()\n+                        .addIndexColumn()\n+                        .build()\n+                        .dump(segment)\n+                        .collect(joining())\n+        );\n+        assertEquals(actual, \"\");\n+    }\n+\n+    @Test\n+    public void testEmptyDumper() {\n+        var actual = testWithFreshMemorySegment(10, segment ->\n+                HexFormat.MemoryDumper.builder()\n+                        .build()\n+                        .dump(segment)\n+                        .collect(joining())\n+        );\n+        assertEquals(actual, \"\");\n+    }\n+\n+    @Test\n+    public void test256HexDump() {\n+        var expect = platformLineSeparated(\"\"\"\n+                0000000000000000 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n+                0000000000000010 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f |................|\n+                0000000000000020 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f | !\"#$%&'()*+,-.\/|\n+                0000000000000030 30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f |0123456789:;<=>?|\n+                0000000000000040 40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f |@ABCDEFGHIJKLMNO|\n+                0000000000000050 50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f |PQRSTUVWXYZ[\\\\]^_|\n+                0000000000000060 60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f |`abcdefghijklmno|\n+                0000000000000070 70 71 72 73 74 75 76 77 78 79 7a 7b 7c 7d 7e 7f |pqrstuvwxyz{|}~.|\n+                0000000000000080 80 81 82 83 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f |................|\n+                0000000000000090 90 91 92 93 94 95 96 97 98 99 9a 9b 9c 9d 9e 9f |................|\n+                00000000000000a0 a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 aa ab ac ad ae af |................|\n+                00000000000000b0 b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 ba bb bc bd be bf |................|\n+                00000000000000c0 c0 c1 c2 c3 c4 c5 c6 c7 c8 c9 ca cb cc cd ce cf |................|\n+                00000000000000d0 d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 da db dc dd de df |................|\n+                00000000000000e0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 ea eb ec ed ee ef |................|\n+                00000000000000f0 f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 fa fb fc fd fe ff |................|\"\"\");\n+\n+        try (var session = MemorySession.openConfined()) {\n+            var segment = session.allocate(256);\n+            for (int i = 0; i < segment.byteSize(); i++) {\n+                segment.set(ValueLayout.JAVA_BYTE, i, (byte) i);\n+            }\n+            var actual = HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn()\n+                    .addDataColumn()\n+                    .withColumnPrefix(\"|\")\n+                    .withColumnSuffix(\"|\")\n+                    .addDataColumn(HexFormat.MemoryDumper.Builder.ColumnRenderer.ofAscii())\n+                    .build()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+            assertEquals(actual, expect);\n+        }\n+    }\n+\n+    @Test\n+    public void test4kHexDump() {\n+        try (var session = MemorySession.openConfined()) {\n+            var segment = session.allocate(2048);\n+            for (int i = 0; i < segment.byteSize(); i++) {\n+                segment.set(ValueLayout.JAVA_BYTE, i, (byte) i);\n+            }\n+            var stat = HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn()\n+                    .addDataColumn()\n+                    .withColumnPrefix(\"|\")\n+                    .withColumnSuffix(\"|\")\n+                    .addDataColumn(HexFormat.MemoryDumper.Builder.ColumnRenderer.ofAscii())\n+                    .build()\n+                    .dump(segment)\n+                    .mapToInt(String::length)\n+                    .summaryStatistics();\n+\n+            \/\/ Every row is of equal length\n+            assertEquals(stat.getMax(), stat.getMin());\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testStandardDump() {\n+        var actual = testWithFreshMemorySegment(HEX_SEGMENT_SIZE, segment -> {\n+            segment.setUtf8String(0, THE_QUICK);\n+            return HexFormat.MemoryDumper.standard()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+        assertEquals(actual, EXPECTED_HEX);\n+    }\n+\n+    @Test\n+    public void testStandardDumpWithArray() {\n+        var expect = \"\"\"\n+                0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 |The quick brown |\n+                0000000000000010 66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20 |fox jumped over |\n+                0000000000000020 74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63 |the lazy dog.Sec|\n+                0000000000000030 6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65       |ond line.:here  |\"\"\";\n+        var actual = HexFormat.MemoryDumper.standard()\n+                    .dump(THE_QUICK_ARRAY)\n+                    .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testStandardDumpWithArrayFromToEndpoints() {\n+        var expect = \"\"\"\n+                0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 |The quick brown |\n+                0000000000000010 66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20 |fox jumped over |\n+                0000000000000020 74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63 |the lazy dog.Sec|\n+                0000000000000030 6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65       |ond line.:here  |\"\"\";\n+        var actual = HexFormat.MemoryDumper.standard()\n+                .dump(THE_QUICK_ARRAY, 0, THE_QUICK_ARRAY.length)\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testStandardDumpWithArrayFrom0To13() {\n+        var expect = \"\"\"\n+                0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f          |The quick bro   |\"\"\";\n+        var actual = HexFormat.MemoryDumper.standard()\n+                .dump(THE_QUICK_ARRAY, 0, 13)\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testStandardDumpWithArrayFrom2To9() {\n+        var expect = \"\"\"\n+                0000000000000000 65 20 71 75 69 63 6b                            |e quick         |\"\"\";\n+        var actual = HexFormat.MemoryDumper.standard()\n+                .dump(THE_QUICK_ARRAY, 2, 9)\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testStandardDumpByteBuffer() {\n+        var expect = \"\"\"\n+                0000000000000000 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 66 |he quick brown f|\n+                0000000000000010 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20 74 |ox jumped over t|\n+                0000000000000020 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63 6f |he lazy dog.Seco|\n+                0000000000000030 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65          |nd line.:here   |\"\"\";\n+        var buffer = ByteBuffer.wrap(THE_QUICK_ARRAY);\n+        \/\/ Consume a byte\n+        buffer.get();\n+        var actual = HexFormat.MemoryDumper.standard()\n+                .dump(buffer)\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    public void testSeveralColumns() {\n+        try (var session = MemorySession.openConfined()) {\n+            var segment = session.allocateUtf8String(THE_QUICK);\n+            var expect = \"\"\"\n++0000000000000000+ -00000000- \/54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20\/ *54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20* 0000\n++0000000000000010+ -00000010- \/66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20\/ *66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20* 0010\n++0000000000000020+ -00000020- \/74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63\/ *74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63* 0020\n++0000000000000030+ -00000030- \/6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65 00   \/ *6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65 00   * 0030\"\"\";\n+            var actual = HexFormat.MemoryDumper.builder()\n+                    .withColumnPrefix(\"+\")\n+                    .withColumnSuffix(\"+\")\n+                    .addIndexColumn()\n+                    .withColumnPrefix(\"-\")\n+                    .withColumnSuffix(\"-\")\n+                    .addIndexColumn(4)\n+                    .withColumnPrefix(\"\/\")\n+                    .withColumnSuffix(\"\/\")\n+                    .addDataColumn()\n+                    .withColumnPrefix(\"*\")\n+                    .withColumnSuffix(\"*\")\n+                    .addDataColumn()\n+                    .withColumnPrefix(\"\")\n+                    .withColumnSuffix(\"\")\n+                    .addIndexColumn(2)\n+                    .build()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+            assertEquals(actual, expect);\n+        }\n+    }\n+\n+    private static String platformLineSeparated(String s) {\n+        return s.lines()\n+                .collect(joining(System.lineSeparator()));\n+    }\n+\n+    private static <T> T testWithFreshMemorySegment(long size,\n+                                                    Function<MemorySegment, T> mapper) {\n+        try (final MemorySession session = MemorySession.openConfined()) {\n+            var segment = session.allocate(size);\n+            return mapper.apply(segment);\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/util\/HexFormat\/HexFormatTest.java","additions":425,"deletions":4,"binary":false,"changes":429,"status":"modified"}]}