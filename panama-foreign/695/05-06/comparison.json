{"files":[{"patch":"@@ -41,0 +41,1 @@\n+import java.util.function.Function;\n@@ -53,0 +54,1 @@\n+import static jdk.internal.foreign.MemorySegmentRenderUtil.STANDARD_VALUE_LAYOUT_RENDERER;\n@@ -1877,1 +1879,1 @@\n-     * the provided {@code layout}.\n+     * the provided {@code layout} and {@code renderer}.\n@@ -1884,8 +1886,1 @@\n-     *     <li> Values are rendered differently depending on their type:\n-     *         <ul>\n-     *             <li>Numeric values are rendered in decimal form (e.g 1 or 1.2).<\/li>\n-     *             <li>Boolean values are rendered as {@code true} or {@code false}.<\/li>\n-     *             <li>Character values are rendered as {@code char}.<\/li>\n-     *             <li>Address values are rendered in hexadecimal form e.g. {@code 0x0000000000000000}.<\/li>\n-     *         <\/ul>\n-     *     <\/li>\n+     *     <li>Values are rendered as specified by the provided {@code renderer}<\/li>\n@@ -1910,1 +1905,1 @@\n-     *   System.out.println(memorySegment.toString(layout));\n+     *   System.out.println(memorySegment.toString(layout, ValueLayoutRenderer.standard()));\n@@ -1920,2 +1915,4 @@\n-     * @param layout  to use as a layout when viewing the memory segment\n-     * @return a view of the memory segment viewed through a memory layout layout\n+     * @param layout   to use as a layout when viewing the memory segment\n+     * @param renderer to apply when formatting value layouts. {@link ValueLayoutRenderer#standard()} can\n+     *                 be used if no custom formatting is needed.\n+     * @return a view of the memory segment viewed through a memory layout\n@@ -1924,0 +1921,2 @@\n+     * @see ValueLayoutRenderer\n+     * @see ValueLayoutRenderer#standard()\n@@ -1925,1 +1924,1 @@\n-    default String toString(MemoryLayout layout) {\n+    default String toString(MemoryLayout layout, ValueLayoutRenderer renderer) {\n@@ -1927,1 +1926,2 @@\n-        return MemorySegmentRenderUtil.toString(this, layout);\n+        Objects.requireNonNull(renderer);\n+        return MemorySegmentRenderUtil.toString(this, layout, renderer);\n@@ -2158,0 +2158,142 @@\n+\n+    \/**\n+     * An interface that can be used to specify custom rendering of value\n+     * layouts via the {@link MemorySegment#toString(MemoryLayout, ValueLayoutRenderer)} method.\n+     * <p>\n+     * The render methods take two parameters:\n+     * <ul>\n+     *     <li>layout: This can be used to select different formatting for different paths<\/li>\n+     *     <li>value: The actual value<\/li>\n+     * <\/ul>\n+     * <p>\n+     * The {@linkplain ValueLayoutRenderer#standard() standard() } value layout renderer is path\n+     * agnostic and will thus render all layouts of the same type the same way.\n+     * @see MemorySegment#toString(MemoryLayout, ValueLayoutRenderer)\n+     *\/\n+    interface ValueLayoutRenderer {\n+        \/**\n+         * Renders the provided {@code layout} and {@code value} to a String.\n+         *\n+         * @param layout the layout to render\n+         * @param value  the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfBoolean layout, boolean value) {\n+            Objects.requireNonNull(layout);\n+            return Boolean.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code layout} and {@code value} to a String.\n+         *\n+         * @param layout the layout to render\n+         * @param value  the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfByte layout, byte value) {\n+            Objects.requireNonNull(layout);\n+            return Byte.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code layout} and {@code value} to a String.\n+         *\n+         * @param layout the layout to render\n+         * @param value  the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfChar layout, char value) {\n+            Objects.requireNonNull(layout);\n+            return Character.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code layout} and {@code value} to a String.\n+         *\n+         * @param layout the layout to render\n+         * @param value  the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfShort layout, short value) {\n+            Objects.requireNonNull(layout);\n+            return Short.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code layout} and {@code value} to a String.\n+         *\n+         * @param layout the layout to render\n+         * @param value  the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfInt layout, int value) {\n+            Objects.requireNonNull(layout);\n+            return Integer.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code layout} and {@code value} to a String.\n+         *\n+         * @param layout the layout to render\n+         * @param value  the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfLong layout, long value) {\n+            Objects.requireNonNull(layout);\n+            return Long.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code layout} and {@code value} to a String.\n+         *\n+         * @param layout the layout to render\n+         * @param value  the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfFloat layout, float value) {\n+            Objects.requireNonNull(layout);\n+            return Float.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code layout} and {@code value} to a String.\n+         *\n+         * @param layout the layout to render\n+         * @param value  the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfDouble layout, double value) {\n+            Objects.requireNonNull(layout);\n+            return Double.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code layout} and {@code value} to a String.\n+         *\n+         * @param layout the layout to render\n+         * @param value  the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfAddress layout, MemorySegment value) {\n+            Objects.requireNonNull(layout);\n+            return String.format(\"0x%0\" + (ValueLayout.ADDRESS.byteSize() * 2) + \"X\", value.address());\n+        }\n+\n+        \/**\n+         * {@return a standard value layout renderer that will render numeric values into decimal form and where\n+         * other value types are rendered to a reasonable \"natural\" form}\n+         * <p>\n+         * More specifically, values types are rendered as follows:\n+         * <ul>\n+         *     <li>Numeric values are rendered in decimal form (e.g 1 or 1.2).<\/li>\n+         *     <li>Boolean values are rendered as {@code true} or {@code false}.<\/li>\n+         *     <li>Character values are rendered as {@code char}.<\/li>\n+         *     <li>Address values are rendered in hexadecimal form e.g. {@code 0x0000000000000000} (on 64-bit platforms) or\n+         *     {@code 0x00000000} (on 32-bit platforms)<\/li>\n+         * <\/ul>\n+         *\/\n+        static ValueLayoutRenderer standard() {\n+            return STANDARD_VALUE_LAYOUT_RENDERER;\n+        }\n+\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":156,"deletions":14,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.function.Function;\n@@ -51,0 +52,2 @@\n+    public static final MemorySegment.ValueLayoutRenderer STANDARD_VALUE_LAYOUT_RENDERER = new StandardValueLayoutRenderer();\n+\n@@ -167,1 +170,2 @@\n-                                  MemoryLayout layout) {\n+                                  MemoryLayout layout,\n+                                  MemorySegment.ValueLayoutRenderer renderer) {\n@@ -170,0 +174,1 @@\n+        requireNonNull(renderer);\n@@ -178,1 +183,1 @@\n-        toString0(segment, layout, action, new ViewState(), \"\");\n+        toString0(segment, layout, renderer, action, new ViewState(), \"\");\n@@ -184,0 +189,1 @@\n+                                 MemorySegment.ValueLayoutRenderer renderer,\n@@ -190,0 +196,4 @@\n+        if (layout instanceof ValueLayout.OfBoolean ofBoolean) {\n+            action.accept(renderValueLayout(state, ofBoolean, renderer.render(ofBoolean, segment.get(ofBoolean, state.indexAndAdd(ofBoolean))), suffix));\n+            return;\n+        }\n@@ -191,1 +201,1 @@\n-            action.accept(renderValueLayout(state, ofByte, Byte.toString(segment.get(ofByte, state.indexAndAdd(ofByte))), suffix));\n+            action.accept(renderValueLayout(state, ofByte, renderer.render(ofByte, segment.get(ofByte, state.indexAndAdd(ofByte))), suffix));\n@@ -195,1 +205,1 @@\n-            action.accept(renderValueLayout(state, ofShort, Short.toString(segment.get(ofShort, state.indexAndAdd(ofShort))), suffix));\n+            action.accept(renderValueLayout(state, ofShort, renderer.render(ofShort, segment.get(ofShort, state.indexAndAdd(ofShort))), suffix));\n@@ -199,1 +209,1 @@\n-            action.accept(renderValueLayout(state, ofInt, Integer.toString(segment.get(ofInt, state.indexAndAdd(ofInt))), suffix));\n+            action.accept(renderValueLayout(state, ofInt, renderer.render(ofInt, segment.get(ofInt, state.indexAndAdd(ofInt))), suffix));\n@@ -203,1 +213,1 @@\n-            action.accept(renderValueLayout(state, ofLong, Long.toString(segment.get(ofLong, state.indexAndAdd(ofLong))), suffix));\n+            action.accept(renderValueLayout(state, ofLong, renderer.render(ofLong, segment.get(ofLong, state.indexAndAdd(ofLong))), suffix));\n@@ -207,1 +217,1 @@\n-            action.accept(renderValueLayout(state, ofFloat, Float.toString(segment.get(ofFloat, state.indexAndAdd(ofFloat))), suffix));\n+            action.accept(renderValueLayout(state, ofFloat, renderer.render(ofFloat, segment.get(ofFloat, state.indexAndAdd(ofFloat))), suffix));\n@@ -211,1 +221,1 @@\n-            action.accept(renderValueLayout(state, ofDouble, Double.toString(segment.get(ofDouble, state.indexAndAdd(ofDouble))), suffix));\n+            action.accept(renderValueLayout(state, ofDouble, renderer.render(ofDouble, segment.get(ofDouble, state.indexAndAdd(ofDouble))), suffix));\n@@ -215,5 +225,1 @@\n-            action.accept(renderValueLayout(state, ofChar, Character.toString(segment.get(ofChar, state.indexAndAdd(ofChar))), suffix));\n-            return;\n-        }\n-        if (layout instanceof ValueLayout.OfBoolean ofBoolean) {\n-            action.accept(renderValueLayout(state, ofBoolean, Boolean.toString(segment.get(ofBoolean, state.indexAndAdd(ofBoolean))), suffix));\n+            action.accept(renderValueLayout(state, ofChar, renderer.render(ofChar, segment.get(ofChar, state.indexAndAdd(ofChar))), suffix));\n@@ -223,2 +229,1 @@\n-            final long address = segment.get(ofAddress, state.indexAndAdd(ofAddress)).address();\n-            action.accept(renderValueLayout(state, ofAddress, String.format(ADDRESS_FORMATTING, address), suffix));\n+            action.accept(renderValueLayout(state, ofAddress, renderer.render(ofAddress, segment.get(ofAddress, state.indexAndAdd(ofAddress))), suffix));\n@@ -256,1 +261,1 @@\n-                toString0(segment, members.get(i), action, state, (i != (members.size() - 1)) ? separator : \"\");\n+                toString0(segment, members.get(i), renderer, action, state, (i != (members.size() - 1)) ? separator : \"\");\n@@ -271,1 +276,1 @@\n-                toString0(segment, sequenceLayout.elementLayout(), action, state, (i != (elementCount - 1L)) ? \",\" : \"\");\n+                toString0(segment, sequenceLayout.elementLayout(), renderer, action, state, (i != (elementCount - 1L)) ? \",\" : \"\");\n@@ -277,1 +282,2 @@\n-        action.accept(\"Unknown layout: \" + layout);\n+        action.accept(state.indentSpaces() + \"Unknown layout: \" + layout + \" at index \" + state.index());\n+        state.indexAndAdd(layout);\n@@ -387,2 +393,2 @@\n-        sb.append((char) UPPERCASE_HEX_DIGITS[(value >>> 4)]);\n-        sb.append((char) UPPERCASE_HEX_DIGITS[(value & (byte) 0x0f)]);\n+        sb.append((char) UPPERCASE_HEX_DIGITS[(value >>> 4) & 0x0f]);\n+        sb.append((char) UPPERCASE_HEX_DIGITS[(value & 0x0f)]);\n@@ -398,0 +404,7 @@\n+    private static final class StandardValueLayoutRenderer implements MemorySegment.ValueLayoutRenderer {\n+        @Override\n+        public String toString() {\n+            return StandardValueLayoutRenderer.class.getSimpleName();\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySegmentRenderUtil.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.Comparator;\n@@ -37,0 +38,1 @@\n+import java.util.stream.Stream;\n@@ -41,0 +43,1 @@\n+import static java.lang.foreign.ValueLayout.*;\n@@ -54,5 +57,7 @@\n-                0000000000000000  54 68 65 20 71 75 69 63  6B 20 62 72 6F 77 6E 20  |The quick brown |\n-                0000000000000010  66 6F 78 20 6A 75 6D 70  65 64 20 6F 76 65 72 20  |fox jumped over |\n-                0000000000000020  74 68 65 20 6C 61 7A 79  20 64 6F 67 0A 53 65 63  |the lazy dog.Sec|\n-                0000000000000030  6F 6E 64 20 6C 69 6E 65  09 3A 68 65 72 65 00 00  |ond line.:here..|\n-                0000000000000040  00 00 00 00                                       |....|\"\"\");\n+            0000000000000000  54 68 65 20 71 75 69 63  6B 20 62 72 6F 77 6E 20  |The quick brown |\n+            0000000000000010  66 6F 78 20 6A 75 6D 70  65 64 20 6F 76 65 72 20  |fox jumped over |\n+            0000000000000020  74 68 65 20 6C 61 7A 79  20 64 6F 67 0A 53 65 63  |the lazy dog.Sec|\n+            0000000000000030  6F 6E 64 20 6C 69 6E 65  09 3A 68 65 72 65 00 00  |ond line.:here..|\n+            0000000000000040  00 00 00 00                                       |....|\"\"\");\n+\n+    private static final String EXPECT_ADDRESS = \"0x\" + \"00\".repeat((int) ValueLayout.ADDRESS.byteSize());\n@@ -68,1 +73,1 @@\n-        assertEquals(EXPECTED_HEX, actual);\n+        assertEquals(actual, EXPECTED_HEX);\n@@ -79,1 +84,1 @@\n-        assertEquals(EXPECTED_HEX, actual);\n+        assertEquals(actual, EXPECTED_HEX);\n@@ -90,1 +95,1 @@\n-        assertEquals(EXPECTED_HEX, actual);\n+        assertEquals(actual, EXPECTED_HEX);\n@@ -97,1 +102,0 @@\n-        var expectAddress = \"0x\" + \"00\".repeat((int) ValueLayout.ADDRESS.byteSize());\n@@ -99,1 +103,4 @@\n-        record TestInput(ValueLayout layout, String stringValue){};\n+\n+        record TestInput(ValueLayout layout, String stringValue) {\n+        }\n+\n@@ -107,3 +114,3 @@\n-                new TestInput(ValueLayout.JAVA_CHAR, \"\"+(char)0),\n-                new TestInput(ValueLayout.JAVA_BOOLEAN, \"false\"),\n-                new TestInput(ValueLayout.ADDRESS, expectAddress)\n+                new TestInput(ValueLayout.JAVA_CHAR, \"\" + (char) 0),\n+                new TestInput(JAVA_BOOLEAN, \"false\"),\n+                new TestInput(ValueLayout.ADDRESS, EXPECT_ADDRESS)\n@@ -112,2 +119,2 @@\n-            var actual = testWithFreshMemorySegment(ti.layout().byteSize(), s -> MemorySegmentRenderUtil.toString(s, ti.layout()));\n-            assertEquals(expect, actual);\n+            var actual = testWithFreshMemorySegment(ti.layout().byteSize(), s -> MemorySegmentRenderUtil.toString(s, ti.layout(), MemorySegment.ValueLayoutRenderer.standard()));\n+            assertEquals(actual, expect);\n@@ -117,0 +124,31 @@\n+    @Test\n+    public void test256HexDump() {\n+        var expect = platformLineSeparated(\"\"\"\n+                0000000000000000  00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F  |................|\n+                0000000000000010  10 11 12 13 14 15 16 17  18 19 1A 1B 1C 1D 1E 1F  |................|\n+                0000000000000020  20 21 22 23 24 25 26 27  28 29 2A 2B 2C 2D 2E 2F  | !\"#$%&'()*+,-.\/|\n+                0000000000000030  30 31 32 33 34 35 36 37  38 39 3A 3B 3C 3D 3E 3F  |0123456789:;<=>?|\n+                0000000000000040  40 41 42 43 44 45 46 47  48 49 4A 4B 4C 4D 4E 4F  |@ABCDEFGHIJKLMNO|\n+                0000000000000050  50 51 52 53 54 55 56 57  58 59 5A 5B 5C 5D 5E 5F  |PQRSTUVWXYZ[\\\\]^_|\n+                0000000000000060  60 61 62 63 64 65 66 67  68 69 6A 6B 6C 6D 6E 6F  |`abcdefghijklmno|\n+                0000000000000070  70 71 72 73 74 75 76 77  78 79 7A 7B 7C 7D 7E 7F  |pqrstuvwxyz{|}~.|\n+                0000000000000080  80 81 82 83 84 85 86 87  88 89 8A 8B 8C 8D 8E 8F  |................|\n+                0000000000000090  90 91 92 93 94 95 96 97  98 99 9A 9B 9C 9D 9E 9F  |................|\n+                00000000000000A0  A0 A1 A2 A3 A4 A5 A6 A7  A8 A9 AA AB AC AD AE AF  |................|\n+                00000000000000B0  B0 B1 B2 B3 B4 B5 B6 B7  B8 B9 BA BB BC BD BE BF  |................|\n+                00000000000000C0  C0 C1 C2 C3 C4 C5 C6 C7  C8 C9 CA CB CC CD CE CF  |................|\n+                00000000000000D0  D0 D1 D2 D3 D4 D5 D6 D7  D8 D9 DA DB DC DD DE DF  |................|\n+                00000000000000E0  E0 E1 E2 E3 E4 E5 E6 E7  E8 E9 EA EB EC ED EE EF  |................|\n+                00000000000000F0  F0 F1 F2 F3 F4 F5 F6 F7  F8 F9 FA FB FC FD FE FF  |................|\"\"\");\n+\n+        try (var session = MemorySession.openConfined()) {\n+            var segment = session.allocate(256);\n+            for (int i = 0; i < segment.byteSize(); i++) {\n+                segment.set(ValueLayout.JAVA_BYTE, i, (byte) i);\n+            }\n+            var actual = MemorySegmentRenderUtil.hexDump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+            assertEquals(actual, expect);\n+        }\n+    }\n+\n@@ -121,0 +159,3 @@\n+            for (int i = 0; i < segment.byteSize(); i++) {\n+                segment.set(ValueLayout.JAVA_BYTE, i, (byte) i);\n+            }\n@@ -122,1 +163,1 @@\n-                    .forEach(System.out::println);\n+                    .forEach(l -> assertEquals(l.length(), \"0000000000000000  00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F  |................|\".length()));\n@@ -124,1 +165,0 @@\n-\n@@ -130,23 +170,5 @@\n-        final class Point {\n-\n-            private static final MemoryLayout LAYOUT = MemoryLayout.structLayout(\n-                    ValueLayout.JAVA_INT.withName(\"x\"),\n-                    ValueLayout.JAVA_INT.withName(\"y\")\n-            ).withName(\"Point\");\n-\n-            private static final VarHandle xVH = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"x\"));\n-            private static final VarHandle yVH = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"y\"));\n-\n-            private final MemorySegment memorySegment;\n-\n-            public Point(MemorySegment memorySegment) {\n-                this.memorySegment = requireNonNull(memorySegment);\n-            }\n-\n-            int x() {\n-                return (int) xVH.get(memorySegment);\n-            }\n-\n-            int y() {\n-                return (int) yVH.get(memorySegment);\n-            }\n+        var expect = platformLineSeparated(\"\"\"\n+                Point {\n+                    x=1,\n+                    y=2\n+                }\"\"\");\n@@ -154,3 +176,6 @@\n-            void x(int x) {\n-                xVH.set(memorySegment, x);\n-            }\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 2, segment -> {\n+            final Point point = new Point(segment);\n+            point.x(1);\n+            point.y(2);\n+            return MemorySegmentRenderUtil.toString(segment, Point.LAYOUT, MemorySegment.ValueLayoutRenderer.standard());\n+        });\n@@ -158,3 +183,2 @@\n-            void y(int y) {\n-                yVH.set(memorySegment, y);\n-            }\n+        assertEquals(actual, expect);\n+    }\n@@ -162,5 +186,2 @@\n-            @Override\n-            public String toString() {\n-                return \"Point {x=\" + x() + \", y=\" + y() + \"}\";\n-            }\n-        }\n+    @Test\n+    public void pointCustomRenderer() {\n@@ -170,2 +191,2 @@\n-                    x=1,\n-                    y=2\n+                    x=0x0001,\n+                    y=0x0002\n@@ -178,1 +199,6 @@\n-            return MemorySegmentRenderUtil.toString(segment, Point.LAYOUT);\n+            return MemorySegmentRenderUtil.toString(segment, Point.LAYOUT, new MemorySegment.ValueLayoutRenderer() {\n+                @Override\n+                public String render(ValueLayout.OfInt layout, int value) {\n+                    return String.format(\"0x%04x\", value);\n+                }\n+            });\n@@ -181,1 +207,1 @@\n-        assertEquals(expect, actual);\n+        assertEquals(actual, expect);\n@@ -184,0 +210,43 @@\n+    @Test\n+    public void standardCustomRenderer() {\n+\n+        MemoryLayout layout = MemoryLayout.structLayout(\n+                \/\/ These are in bit alignment order (descending) for all platforms\n+                \/\/ in order to be naturally aligned.\n+                Stream.of(\n+                                JAVA_LONG,\n+                                JAVA_DOUBLE,\n+                                ADDRESS,\n+                                JAVA_INT,\n+                                JAVA_FLOAT,\n+                                JAVA_SHORT,\n+                                JAVA_CHAR,\n+                                JAVA_BOOLEAN,\n+                                JAVA_BYTE\n+                        )\n+                        .map(vl -> vl.withName(vl.carrier().getSimpleName()))\n+                        .toArray(MemoryLayout[]::new)\n+        ).withName(\"struct\");\n+\n+        System.out.println(\"layout = \" + layout);\n+        var expect = platformLineSeparated(\"\"\"\n+                struct {\n+                    long=0,\n+                    double=0.0,\n+                    MemorySegment=$1,\n+                    int=0,\n+                    float=0.0,\n+                    short=0,\n+                    char=\\u0000,\n+                    boolean=false,\n+                    byte=0\n+                }\"\"\").replace(\"$1\", EXPECT_ADDRESS);\n+\n+\n+        var actual = testWithFreshMemorySegment(layout.byteSize(), segment ->\n+                MemorySegmentRenderUtil.toString(segment, layout, MemorySegment.ValueLayoutRenderer.standard()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+\n@@ -214,1 +283,1 @@\n-                MemorySegmentRenderUtil.toString(segment, sequenceLayout));\n+                MemorySegmentRenderUtil.toString(segment, sequenceLayout, MemorySegment.ValueLayoutRenderer.standard()));\n@@ -216,1 +285,1 @@\n-        assertEquals(expect, actual);\n+        assertEquals(actual, expect);\n@@ -250,1 +319,6 @@\n-                MemorySegmentRenderUtil.toString(segment, union));\n+                MemorySegmentRenderUtil.toString(segment, union, MemorySegment.ValueLayoutRenderer.standard()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    static final class Point {\n@@ -252,1 +326,34 @@\n-        assertEquals(expect, actual);\n+        static final MemoryLayout LAYOUT = MemoryLayout.structLayout(\n+                ValueLayout.JAVA_INT.withName(\"x\"),\n+                ValueLayout.JAVA_INT.withName(\"y\")\n+        ).withName(\"Point\");\n+\n+        static final VarHandle xVH = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"x\"));\n+        static final VarHandle yVH = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"y\"));\n+\n+        private final MemorySegment memorySegment;\n+\n+        Point(MemorySegment memorySegment) {\n+            this.memorySegment = requireNonNull(memorySegment);\n+        }\n+\n+        int x() {\n+            return (int) xVH.get(memorySegment);\n+        }\n+\n+        int y() {\n+            return (int) yVH.get(memorySegment);\n+        }\n+\n+        void x(int x) {\n+            xVH.set(memorySegment, x);\n+        }\n+\n+        void y(int y) {\n+            yVH.set(memorySegment, y);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Point {x=\" + x() + \", y=\" + y() + \"}\";\n+        }\n","filename":"test\/jdk\/java\/foreign\/RenderTest.java","additions":166,"deletions":59,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.MemoryAddress;\n","filename":"test\/jdk\/java\/foreign\/TestUnsupportedLinker.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}