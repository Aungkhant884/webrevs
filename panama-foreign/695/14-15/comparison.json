{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import java.nio.ByteOrder;\n@@ -40,0 +41,1 @@\n+import java.util.function.ToLongFunction;\n@@ -90,2 +92,1 @@\n- * @apiNote\n- * For example, an individual byte is converted to a string of hexadecimal digits using\n+ * @apiNote For example, an individual byte is converted to a string of hexadecimal digits using\n@@ -142,1 +143,0 @@\n- *\n@@ -166,1 +166,1 @@\n-             0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,\n+            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1,\n@@ -190,1 +190,0 @@\n-    private static final int DUMP_LINE_LENGTH_EXCLUDING_CHARS = Long.BYTES * 2 + DUMP_BYTES_PER_ROW * 3 + 4;\n@@ -201,3 +200,3 @@\n-     * @param prefix a prefix, non-null\n-     * @param suffix a suffix, non-null\n-     * @param digits byte array of digits indexed by low nibble, non-null\n+     * @param prefix    a prefix, non-null\n+     * @param suffix    a suffix, non-null\n+     * @param digits    byte array of digits indexed by low nibble, non-null\n@@ -244,0 +243,1 @@\n+     *\n@@ -323,1 +323,1 @@\n-     *          otherwise {@code false}\n+     * otherwise {@code false}\n@@ -334,1 +334,1 @@\n-     *\n+     * <p>\n@@ -351,1 +351,1 @@\n-     * @param bytes a non-null array of bytes\n+     * @param bytes     a non-null array of bytes\n@@ -353,1 +353,1 @@\n-     * @param toIndex the final index of the range, exclusive\n+     * @param toIndex   the final index of the range, exclusive\n@@ -358,1 +358,1 @@\n-        Objects.requireNonNull(bytes,\"bytes\");\n+        Objects.requireNonNull(bytes, \"bytes\");\n@@ -382,2 +382,2 @@\n-     * @param <A> The type of {@code Appendable}\n-     * @param out an {@code Appendable}, non-null\n+     * @param <A>   The type of {@code Appendable}\n+     * @param out   an {@code Appendable}, non-null\n@@ -405,1 +405,5 @@\n-     * @throws UncheckedIOException if an I\/O exception occurs appending to the output\n+     * @throws UncheckedIOException  if an I\/O exception occurs appending to the output\n+     * @throws IllegalStateException if the {@linkplain MemorySegment#session() session} associated with this\n+     *                               segment is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException  if this method is called from a thread other than the thread owning\n+     *                               the {@linkplain MemorySegment#session() session} associated with this segment.\n@@ -422,2 +426,2 @@\n-     * @param <A> The type of {@code Appendable}\n-     * @param out an {@code Appendable}, non-null\n+     * @param <A>     The type of {@code Appendable}\n+     * @param out     an {@code Appendable}, non-null\n@@ -426,1 +430,5 @@\n-     * @throws UncheckedIOException if an I\/O exception occurs appending to the output\n+     * @throws UncheckedIOException  if an I\/O exception occurs appending to the output\n+     * @throws IllegalStateException if the {@linkplain MemorySegment#session() session} associated with this\n+     *                               segment is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException  if this method is called from a thread other than the thread owning\n+     *                               the {@linkplain MemorySegment#session() session} associated with this segment.\n@@ -463,3 +471,3 @@\n-     * @param <A> The type of {@code Appendable}\n-     * @param out an {@code Appendable}, non-null\n-     * @param bytes a byte array, non-null\n+     * @param <A>       The type of {@code Appendable}\n+     * @param out       an {@code Appendable}, non-null\n+     * @param bytes     a byte array, non-null\n@@ -467,1 +475,1 @@\n-     * @param toIndex the final index of the range, exclusive.\n+     * @param toIndex   the final index of the range, exclusive.\n@@ -470,1 +478,1 @@\n-     * @throws UncheckedIOException if an I\/O exception occurs appending to the output\n+     * @throws UncheckedIOException      if an I\/O exception occurs appending to the output\n@@ -507,1 +515,1 @@\n-     * @param bytes the bytes, non-null\n+     * @param bytes     the bytes, non-null\n@@ -509,1 +517,1 @@\n-     * @param toIndex the final index of the range, exclusive.\n+     * @param toIndex   the final index of the range, exclusive.\n@@ -511,1 +519,1 @@\n-     *         or non-empty prefix or suffix\n+     * or non-empty prefix or suffix\n@@ -523,2 +531,2 @@\n-                rep[i * 2] = (byte)toHighHexDigit(bytes[fromIndex + i]);\n-                rep[i * 2 + 1] = (byte)toLowHexDigit(bytes[fromIndex + i]);\n+                rep[i * 2] = (byte) toHighHexDigit(bytes[fromIndex + i]);\n+                rep[i * 2 + 1] = (byte) toLowHexDigit(bytes[fromIndex + i]);\n@@ -535,1 +543,1 @@\n-                rep[i * 3    ] = (byte) toHighHexDigit(bytes[fromIndex + i]);\n+                rep[i * 3] = (byte) toHighHexDigit(bytes[fromIndex + i]);\n@@ -562,1 +570,1 @@\n-        return (int)length;\n+        return (int) length;\n@@ -567,1 +575,1 @@\n-     *\n+     * <p>\n@@ -574,1 +582,1 @@\n-     *            and delimiters\n+     *               and delimiters\n@@ -577,2 +585,2 @@\n-     *          the byte values are not hexadecimal characters, or if the delimiter is not present\n-     *          after all but the last byte value\n+     *                                  the byte values are not hexadecimal characters, or if the delimiter is not present\n+     *                                  after all but the last byte value\n@@ -586,1 +594,1 @@\n-     *\n+     * <p>\n@@ -592,2 +600,2 @@\n-     * @param string a string range containing hexadecimal digits,\n-     *           delimiters, prefix, and suffix.\n+     * @param string    a string range containing hexadecimal digits,\n+     *                  delimiters, prefix, and suffix.\n@@ -595,1 +603,1 @@\n-     * @param toIndex the final index of the range, exclusive.\n+     * @param toIndex   the final index of the range, exclusive.\n@@ -597,3 +605,3 @@\n-     * @throws IllegalArgumentException if the prefix or suffix is not present for each byte value,\n-     *          the byte values are not hexadecimal characters, or if the delimiter is not present\n-     *          after all but the last byte value\n+     * @throws IllegalArgumentException  if the prefix or suffix is not present for each byte value,\n+     *                                   the byte values are not hexadecimal characters, or if the delimiter is not present\n+     *                                   after all but the last byte value\n@@ -625,1 +633,1 @@\n-        final int len = (int)((string.length() - valueChars) \/ stride + 1L);\n+        final int len = (int) ((string.length() - valueChars) \/ stride + 1L);\n@@ -640,1 +648,1 @@\n-     *\n+     * <p>\n@@ -646,2 +654,2 @@\n-     * @param chars a character array range containing an even number of hexadecimal digits,\n-     *          delimiters, prefix, and suffix.\n+     * @param chars     a character array range containing an even number of hexadecimal digits,\n+     *                  delimiters, prefix, and suffix.\n@@ -649,1 +657,1 @@\n-     * @param toIndex the final index of the range, exclusive.\n+     * @param toIndex   the final index of the range, exclusive.\n@@ -651,3 +659,3 @@\n-     * @throws IllegalArgumentException if the prefix or suffix is not present for each byte value,\n-     *          the byte values are not hexadecimal characters, or if the delimiter is not present\n-     *          after all but the last byte value\n+     * @throws IllegalArgumentException  if the prefix or suffix is not present for each byte value,\n+     *                                   the byte values are not hexadecimal characters, or if the delimiter is not present\n+     *                                   after all but the last byte value\n@@ -667,2 +675,2 @@\n-     * @param string a CharSequence\n-     * @param index the index of the literal in the CharSequence\n+     * @param string  a CharSequence\n+     * @param index   the index of the literal in the CharSequence\n@@ -673,1 +681,1 @@\n-        assert index <= string.length() - literal.length()  : \"pre-checked invariant error\";\n+        assert index <= string.length() - literal.length() : \"pre-checked invariant error\";\n@@ -683,1 +691,1 @@\n-                        \" ch: \" + (int)string.charAt(index + i)));\n+                        \" ch: \" + (int) string.charAt(index + i)));\n@@ -710,1 +718,1 @@\n-        return (char)digits[value & 0xf];\n+        return (char) digits[value & 0xf];\n@@ -724,1 +732,1 @@\n-        return (char)digits[(value >> 4) & 0xf];\n+        return (char) digits[(value >> 4) & 0xf];\n@@ -734,2 +742,2 @@\n-     * @param <A> The type of {@code Appendable}\n-     * @param out an {@code Appendable}, non-null\n+     * @param <A>   The type of {@code Appendable}\n+     * @param out   an {@code Appendable}, non-null\n@@ -762,2 +770,2 @@\n-        rep[0] = (byte)toHighHexDigit(value);\n-        rep[1] = (byte)toLowHexDigit(value);\n+        rep[0] = (byte) toHighHexDigit(value);\n+        rep[1] = (byte) toLowHexDigit(value);\n@@ -781,1 +789,1 @@\n-        return toHexDigits((short)value);\n+        return toHexDigits((short) value);\n@@ -795,4 +803,4 @@\n-        rep[0] = (byte)toHighHexDigit((byte)(value >> 8));\n-        rep[1] = (byte)toLowHexDigit((byte)(value >> 8));\n-        rep[2] = (byte)toHighHexDigit((byte)value);\n-        rep[3] = (byte)toLowHexDigit((byte)value);\n+        rep[0] = (byte) toHighHexDigit((byte) (value >> 8));\n+        rep[1] = (byte) toLowHexDigit((byte) (value >> 8));\n+        rep[2] = (byte) toHighHexDigit((byte) value);\n+        rep[3] = (byte) toLowHexDigit((byte) value);\n@@ -819,8 +827,8 @@\n-        rep[0] = (byte)toHighHexDigit((byte)(value >> 24));\n-        rep[1] = (byte)toLowHexDigit((byte)(value >> 24));\n-        rep[2] = (byte)toHighHexDigit((byte)(value >> 16));\n-        rep[3] = (byte)toLowHexDigit((byte)(value >> 16));\n-        rep[4] = (byte)toHighHexDigit((byte)(value >> 8));\n-        rep[5] = (byte)toLowHexDigit((byte)(value >> 8));\n-        rep[6] = (byte)toHighHexDigit((byte)value);\n-        rep[7] = (byte)toLowHexDigit((byte)value);\n+        rep[0] = (byte) toHighHexDigit((byte) (value >> 24));\n+        rep[1] = (byte) toLowHexDigit((byte) (value >> 24));\n+        rep[2] = (byte) toHighHexDigit((byte) (value >> 16));\n+        rep[3] = (byte) toLowHexDigit((byte) (value >> 16));\n+        rep[4] = (byte) toHighHexDigit((byte) (value >> 8));\n+        rep[5] = (byte) toLowHexDigit((byte) (value >> 8));\n+        rep[6] = (byte) toHighHexDigit((byte) value);\n+        rep[7] = (byte) toLowHexDigit((byte) value);\n@@ -847,16 +855,16 @@\n-        rep[0] = (byte)toHighHexDigit((byte)(value >>> 56));\n-        rep[1] = (byte)toLowHexDigit((byte)(value >>> 56));\n-        rep[2] = (byte)toHighHexDigit((byte)(value >>> 48));\n-        rep[3] = (byte)toLowHexDigit((byte)(value >>> 48));\n-        rep[4] = (byte)toHighHexDigit((byte)(value >>> 40));\n-        rep[5] = (byte)toLowHexDigit((byte)(value >>> 40));\n-        rep[6] = (byte)toHighHexDigit((byte)(value >>> 32));\n-        rep[7] = (byte)toLowHexDigit((byte)(value >>> 32));\n-        rep[8] = (byte)toHighHexDigit((byte)(value >>> 24));\n-        rep[9] = (byte)toLowHexDigit((byte)(value >>> 24));\n-        rep[10] = (byte)toHighHexDigit((byte)(value >>> 16));\n-        rep[11] = (byte)toLowHexDigit((byte)(value >>> 16));\n-        rep[12] = (byte)toHighHexDigit((byte)(value >>> 8));\n-        rep[13] = (byte)toLowHexDigit((byte)(value >>> 8));\n-        rep[14] = (byte)toHighHexDigit((byte)value);\n-        rep[15] = (byte)toLowHexDigit((byte)value);\n+        rep[0] = (byte) toHighHexDigit((byte) (value >>> 56));\n+        rep[1] = (byte) toLowHexDigit((byte) (value >>> 56));\n+        rep[2] = (byte) toHighHexDigit((byte) (value >>> 48));\n+        rep[3] = (byte) toLowHexDigit((byte) (value >>> 48));\n+        rep[4] = (byte) toHighHexDigit((byte) (value >>> 40));\n+        rep[5] = (byte) toLowHexDigit((byte) (value >>> 40));\n+        rep[6] = (byte) toHighHexDigit((byte) (value >>> 32));\n+        rep[7] = (byte) toLowHexDigit((byte) (value >>> 32));\n+        rep[8] = (byte) toHighHexDigit((byte) (value >>> 24));\n+        rep[9] = (byte) toLowHexDigit((byte) (value >>> 24));\n+        rep[10] = (byte) toHighHexDigit((byte) (value >>> 16));\n+        rep[11] = (byte) toLowHexDigit((byte) (value >>> 16));\n+        rep[12] = (byte) toHighHexDigit((byte) (value >>> 8));\n+        rep[13] = (byte) toLowHexDigit((byte) (value >>> 8));\n+        rep[14] = (byte) toHighHexDigit((byte) value);\n+        rep[15] = (byte) toLowHexDigit((byte) value);\n@@ -877,1 +885,1 @@\n-     * @param value a {@code long} value\n+     * @param value  a {@code long} value\n@@ -880,1 +888,1 @@\n-     * @throws  IllegalArgumentException if {@code digits} is negative or greater than 16\n+     * @throws IllegalArgumentException if {@code digits} is negative or greater than 16\n@@ -889,1 +897,1 @@\n-            rep[i] = (byte)toLowHexDigit((byte)(value));\n+            rep[i] = (byte) toLowHexDigit((byte) (value));\n@@ -906,1 +914,1 @@\n-     *          the string contains non-hexadecimal characters\n+     *                                  the string contains non-hexadecimal characters\n@@ -925,2 +933,2 @@\n-     * @param toIndex the final index of the range, exclusive.\n-     * @param limit the maximum allowed\n+     * @param toIndex   the final index of the range, exclusive.\n+     * @param limit     the maximum allowed\n@@ -945,0 +953,1 @@\n+     *\n@@ -947,1 +956,1 @@\n-     *          otherwise {@code false}\n+     * otherwise {@code false}\n@@ -964,1 +973,1 @@\n-     * @throws  NumberFormatException if the codepoint is not a hexadecimal character\n+     * @throws NumberFormatException if the codepoint is not a hexadecimal character\n@@ -980,1 +989,1 @@\n-     * @param index the index of the first character of the range\n+     * @param index  the index of the first character of the range\n@@ -982,4 +991,4 @@\n-     * @throws  NumberFormatException if any of the characters in the range\n-     *          is not a hexadecimal character\n-     * @throws  IndexOutOfBoundsException if the range is out of bounds\n-     *          for the {@code CharSequence}\n+     * @throws NumberFormatException     if any of the characters in the range\n+     *                                   is not a hexadecimal character\n+     * @throws IndexOutOfBoundsException if the range is out of bounds\n+     *                                   for the {@code CharSequence}\n@@ -999,2 +1008,3 @@\n-     * @apiNote\n-     * {@link Integer#parseInt(String, int) Integer.parseInt(s, 16)} and\n+     * @param string to parse\n+     * @return the parsed int value\n+     * @apiNote {@link Integer#parseInt(String, int) Integer.parseInt(s, 16)} and\n@@ -1007,5 +1017,0 @@\n-     *\n-     * @param string a CharSequence containing up to eight hexadecimal characters\n-     * @return the value parsed from the string\n-     * @throws  IllegalArgumentException if the string length is greater than eight (8) or\n-     *      if any of the characters is not a hexadecimal character\n@@ -1025,2 +1030,9 @@\n-     * @apiNote\n-     * {@link Integer#parseInt(String, int) Integer.parseInt(s, 16)} and\n+     * @param string    a CharSequence containing the characters\n+     * @param fromIndex the initial index of the range, inclusive\n+     * @param toIndex   the final index of the range, exclusive.\n+     * @return the value parsed from the string range\n+     * @throws IndexOutOfBoundsException if the range is out of bounds\n+     *                                   for the {@code CharSequence}\n+     * @throws IllegalArgumentException  if length of the range is greater than eight (8) or\n+     *                                   if any of the characters is not a hexadecimal character\n+     * @apiNote {@link Integer#parseInt(String, int) Integer.parseInt(s, 16)} and\n@@ -1033,9 +1045,0 @@\n-     *\n-     * @param string a CharSequence containing the characters\n-     * @param fromIndex the initial index of the range, inclusive\n-     * @param toIndex the final index of the range, exclusive.\n-     * @return the value parsed from the string range\n-     * @throws  IndexOutOfBoundsException if the range is out of bounds\n-     *          for the {@code CharSequence}\n-     * @throws  IllegalArgumentException if length of the range is greater than eight (8) or\n-     *          if any of the characters is not a hexadecimal character\n@@ -1060,2 +1063,3 @@\n-     * @apiNote\n-     * {@link Long#parseLong(String, int) Long.parseLong(s, 16)} and\n+     * @param string to parse\n+     * @return the parsed long value\n+     * @apiNote {@link Long#parseLong(String, int) Long.parseLong(s, 16)} and\n@@ -1068,5 +1072,0 @@\n-     *\n-     * @param string a CharSequence containing up to sixteen hexadecimal characters\n-     * @return the value parsed from the string\n-     * @throws  IllegalArgumentException if the string length is greater than sixteen (16) or\n-     *         if any of the characters is not a hexadecimal character\n@@ -1086,2 +1085,9 @@\n-     * @apiNote\n-     * {@link Long#parseLong(String, int) Long.parseLong(s, 16)} and\n+     * @param string    a CharSequence containing the characters\n+     * @param fromIndex the initial index of the range, inclusive\n+     * @param toIndex   the final index of the range, exclusive.\n+     * @return the value parsed from the string range\n+     * @throws IndexOutOfBoundsException if the range is out of bounds\n+     *                                   for the {@code CharSequence}\n+     * @throws IllegalArgumentException  if the length of the range is greater than sixteen (16) or\n+     *                                   if any of the characters is not a hexadecimal character\n+     * @apiNote {@link Long#parseLong(String, int) Long.parseLong(s, 16)} and\n@@ -1094,9 +1100,0 @@\n-     *\n-     * @param string a CharSequence containing the characters\n-     * @param fromIndex the initial index of the range, inclusive\n-     * @param toIndex the final index of the range, exclusive.\n-     * @return the value parsed from the string range\n-     * @throws  IndexOutOfBoundsException if the range is out of bounds\n-     *          for the {@code CharSequence}\n-     * @throws  IllegalArgumentException if the length of the range is greater than sixteen (16) or\n-     *          if any of the characters is not a hexadecimal character\n@@ -1115,66 +1112,0 @@\n-    \/**\n-     * Returns a Stream of human-readable, string elements with hexadecimal and character values for\n-     * the provided {@code segment}.\n-     * <p>\n-     * Each element in the stream comprises the following characters:\n-     * <ol>\n-     *     <li>a 64-bit offset in hexadecimal form (e.g. \"0000000000000010\").<\/li>\n-     *     <li>a sequence of two spaces (i.e. \"  \").<\/li>\n-     *     <li>a sequence of at most eight bytes in hexadecimal form (e.g. \"66 6F 78 20 6A 75 6D 70\") where\n-     *     each byte is separated by a space.<\/li>\n-     *     <li>a sequence of two spaces (i.e. \"  \").<\/li>\n-     *     <li>a sequence of at most eight bytes in hexadecimal form (e.g. \"65 64 20 6F 76 65 72 20\") where\n-     *     each byte separated by a space.<\/li>\n-     *     <li>a sequence of N spaces (i.e. \"  \") such that the intermediate line is aligned to 68 characters<\/li>\n-     *     <li>a \"|\" separator.<\/li>\n-     *     <li>a sequence of at most 16 printable Ascii characters (values outside [32, 127] will be printed as \".\").<\/li>\n-     *     <li>a \"|\" separator.<\/li>\n-     * <\/ol>\n-     * All the values in hexadecimal form are in upper case and with leading zeros. As there are at most 16 bytes\n-     * rendered for each line, there will be N = ({@link MemorySegment#byteSize()} + 15) \/ 16 elements in the returned stream.\n-     * <p>\n-     * As a consequence of the above, this method renders to a format similar to the *nix command \"hexdump -C\".\n-     * <p>\n-     * As an example, a segment created, initialized and used as follows\n-     * {@snippet lang = java:\n-     *   MemorySegment segment = memorySession.allocateUtf8String(\"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\");\n-     *   HexFormat.dump(segment)\n-     *       .forEach(System.out::println);\n-     *}\n-     * will be printed as:\n-     * {@snippet lang = text:\n-     * 0000000000000000  54 68 65 20 71 75 69 63  6B 20 62 72 6F 77 6E 20  |The quick brown |\n-     * 0000000000000010  66 6F 78 20 6A 75 6D 70  65 64 20 6F 76 65 72 20  |fox jumped over |\n-     * 0000000000000020  74 68 65 20 6C 61 7A 79  20 64 6F 67 0A 53 65 63  |the lazy dog.Sec|\n-     * 0000000000000030  6F 6E 64 20 6C 69 6E 65  09 3A 68 65 72 65 00     |ond line.:here.|\n-     *}\n-     * <p>\n-     * Use a {@linkplain MemorySegment#asSlice(long, long) slice} to inspect a specific region\n-     * of a segment.\n-     * <p>\n-     * This method can be used to dump the contents of various other memory containers such as\n-     * {@linkplain ByteBuffer ByteBuffers} and byte arrays by means of first wrapping the container\n-     * into a MemorySegment:\n-     * {@snippet lang = java:\n-     *   HexFormat.dump(MemorySegment.ofArray(byteArray));\n-     *   HexFormat.dump(MemorySegment.ofBuffer(byteBuffer));\n-     *}\n-     *\n-     * @param segment to dump\n-     * @return a Stream of human-readable, string elements with hexadecimal values and characters\n-     * @throws IllegalStateException if the {@linkplain MemorySegment#session() session} associated with this\n-     *                               segment is not {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException  if this method is called from a thread other than the thread owning\n-     *                               the {@linkplain MemorySegment#session() session} associated with this segment.\n-     *\/\n-    public static Stream<String> dump(MemorySegment segment) {\n-        requireNonNull(segment);\n-\n-        \/\/ Todo: Investigate how to handle mapped sparse files\n-\n-        final var state = new DumpState(segment);\n-        return LongStream.range(0, state.lastIndex())\n-                .mapToObj(state::mapIndexToLineOrNull)\n-                .filter(Objects::nonNull);\n-    }\n-\n@@ -1187,2 +1118,2 @@\n-     *         uppercase, delimiter, prefix, and suffix are equal;\n-     *         otherwise {@code false}\n+     * uppercase, delimiter, prefix, and suffix are equal;\n+     * otherwise {@code false}\n@@ -1229,6 +1160,70 @@\n-    private static final class DumpState {\n-        private final StringBuilder line = new StringBuilder();\n-        private final StringBuilder chars = new StringBuilder();\n-        private final HexFormat hexFormat = HexFormat.of().withUpperCase();\n-        private final MemorySegment segment;\n-        private final long lastIndex;\n+    \/**\n+     * A class providing various memory abstractions (such as MemorySegments and byte arrays) to be dumped into\n+     * various formats.\n+     *\n+     * @author Per Minborg\n+     * @since 20\n+     *\/\n+    public interface MemoryDumper {\n+\n+        \/**\n+         * Returns a Stream of string elements with values for the provided {@code memory} byte array.\n+         * <p>\n+         * Each element in the stream depends on how this MemoryDumper was configured via its {@linkplain #builder()}.\n+         * <p>\n+         * As an example, an array created, initialized and used as follows\n+         * {@snippet lang = java:\n+         *   byte[] bytes = \"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\".getBytes(StandardCharsets.UTF_8);\n+         *   MemoryDumper.builder()\n+         *      .addIndexColumn()\n+         *      .addDataColumn()\n+         *      .withColumnPrefix(\"|\")\n+         *      .withColumnSuffix(\"|\")\n+         *      .addDataColumn(Builder.ColumnRenderer.ofAscii())\n+         *      .build()\n+         *      .dump(bytes)\n+         *      .forEach(System.out::println);\n+         *}\n+         * will be printed as:\n+         * {@snippet lang = text:\n+         * 0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 |The quick brown |\n+         * 0000000000000010 66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20 |fox jumped over |\n+         * 0000000000000020 74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63 |the lazy dog.Sec|\n+         * 0000000000000030 6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65 00    |ond line.:here._|\n+         *}\n+         *\n+         * @param bytes to dump\n+         * @return a Stream of string elements\n+         *\/\n+        Stream<String> dump(byte[] bytes);\n+\n+        \/**\n+         * Returns a Stream of string elements with values for the provided {@code memory} byte array staring\n+         * at the provided {@code fromIndex} (inclusive) and ending at the provided {@code toIndex} (exclusive).\n+         * <p>\n+         * Each element in the stream depends on how this MemoryDumper was configured via its {@linkplain #builder()}.\n+         * <p>\n+         * As an example, an array created, initialized and used as follows\n+         * {@snippet lang = java:\n+         *   byte[] bytes = \"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\".getBytes(StandardCharsets.UTF_8);\n+         *   MemoryDumper.builder()\n+         *      .addIndexColumn()\n+         *      .addDataColumn()\n+         *      .withColumnPrefix(\"|\")\n+         *      .withColumnSuffix(\"|\")\n+         *      .addDataColumn(Builder.ColumnRenderer.ofAscii())\n+         *      .build()\n+         *      .dump(bytes, 0, 16)\n+         *      .forEach(System.out::println);\n+         *}\n+         * will be printed as:\n+         * {@snippet lang = text:\n+         * 0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 |The quick brown |\n+         *}\n+         *\n+         * @param bytes     to dump\n+         * @param fromIndex the initial index of the range, inclusive\n+         * @param toIndex   the final index of the range, exclusive.\n+         * @return a Stream of string elements\n+         *\/\n+        Stream<String> dump(byte[] bytes, int fromIndex, int toIndex);\n@@ -1236,3 +1231,71 @@\n-        DumpState(MemorySegment segment) {\n-            this.segment = segment;\n-            this.lastIndex = segment.byteSize();\n+        \/**\n+         * Returns a Stream of string elements with values for the provided {@code memory} segment.\n+         * <p>\n+         * Each element in the stream depends on how this MemoryDumper was configured via its {@linkplain #builder()}.\n+         * <p>\n+         * As an example, an array created, initialized and used as follows\n+         * {@snippet lang = java:\n+         * MemoryDumper dumper = MemoryDumper.builder()\n+         *            .addIndexColumn()\n+         *            .addDataColumn()\n+         *            .withColumnPrefix(\"|\")\n+         *            .withColumnSuffix(\"|\")\n+         *            .addDataColumn(Builder.ColumnRenderer.ofAscii())\n+         *            .build();\n+         *\n+         *    try (MemorySession session = MemorySession.openConfined()) {\n+         *       MemorySegment segment = session.allocateUtf8String(\"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\");\n+         *      dumper.dump(bytes)\n+         *          .forEach(System.out::println);\n+         *    }\n+         *}\n+         * will be printed as:\n+         * {@snippet lang = text:\n+         * 0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 |The quick brown |\n+         * 0000000000000010 66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20 |fox jumped over |\n+         * 0000000000000020 74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63 |the lazy dog.Sec|\n+         * 0000000000000030 6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65 00    |ond line.:here._|\n+         *}\n+         *\n+         * @param segment to dump\n+         * @return a Stream of string elements\n+         *\/\n+        Stream<String> dump(MemorySegment segment);\n+\n+\n+        \/**\n+         * Returns a Stream of string elements with values for the provided {@code buffer}.\n+         * <p>\n+         * Each element in the stream depends on how this MemoryDumper was configured via its {@linkplain #builder()}.\n+         * <p>\n+         * As an example, an array created, initialized and used as follows\n+         * {@snippet lang = java:\n+         * var buffer = ByteBuffer.wrap(\"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\".getBytes(StandardCharsets.UTF_8));\n+         * MemoryDumper dumper = MemoryDumper.builder()\n+         *            .addIndexColumn()\n+         *            .addDataColumn()\n+         *            .withColumnPrefix(\"|\")\n+         *            .withColumnSuffix(\"|\")\n+         *            .addDataColumn(Builder.ColumnRenderer.ofAscii())\n+         *            .build();\n+         * dumper.dump(bytes)\n+         *     .forEach(System.out::println);\n+         *}\n+         * will be printed as:\n+         * {@snippet lang = text:\n+         * 0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 |The quick brown |\n+         * 0000000000000010 66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20 |fox jumped over |\n+         * 0000000000000020 74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63 |the lazy dog.Sec|\n+         * 0000000000000030 6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65 00    |ond line.:here._|\n+         *}\n+         *\n+         * @param buffer to dump\n+         * @return a Stream of string elements\n+         *\/\n+        Stream<String> dump(ByteBuffer buffer);\n+\n+        \/**\n+         * {@return a new builder that can be used to configure and create MemoryDumper instances.}\n+         *\/\n+        static Builder builder() {\n+            return new StandardMemoryDumperBuilder();\n@@ -1242,3 +1305,1 @@\n-         * Returns a new complete line (either a full line or the last line) for the provided {@code index}\n-         * or {@code null} if the provided {@code index} is not at the end of a full line or at the end of the\n-         * last line.\n+         * {@return a standard MemoryDumper that will format memory segments in human readable form}\n@@ -1246,1 +1307,3 @@\n-         * Note: This method is <em>stateful<\/em> and requires invocations with index in order 0, 1, ..., N\n+         * As an example, a memory segment, initialized and used as follows\n+         * {@snippet lang = java:\n+         * MemoryDumper dumper = MemoryDumper.standard();\n@@ -1248,2 +1311,13 @@\n-         * @param index the index\n-         * @return a new line or {@code null}\n+         *    try (MemorySession session = MemorySession.openConfined()) {\n+         *       MemorySegment segment = session.allocateUtf8String(\"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\");\n+         *      dumper.dump(bytes)\n+         *          .forEach(System.out::println);\n+         *    }\n+         *}\n+         * will be printed as:\n+         * {@snippet lang = text:\n+         * 0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 |The quick brown |\n+         * 0000000000000010 66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20 |fox jumped over |\n+         * 0000000000000020 74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63 |the lazy dog.Sec|\n+         * 0000000000000030 6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65 00    |ond line.:here._|\n+         *}\n@@ -1251,8 +1325,186 @@\n-        String mapIndexToLineOrNull(long index) {\n-            if (isEmpty()) {\n-                \/\/ We are on a new line: Append the index\n-                appendIndex(index);\n-            }\n-            if (index % (DUMP_BYTES_PER_ROW >>> 1) == 0) {\n-                \/\/ We are either at the beginning or halfway through: add an extra space for readability\n-                appendSpace();\n+        static MemoryDumper standard() {\n+            return StandardMemoryDumper.STANDARD;\n+        }\n+\n+        \/**\n+         * A non-threadsafe builder for MemoryDumper instances.\n+         *\n+         * @since 20\n+         *\/\n+        interface Builder {\n+\n+            \/**\n+             * Configures the number of bytes per line in.\n+             * <p>\n+             * Unless configured otherwise, the default number of bytes per line is 16.\n+             *\n+             * @param bytesPerLine the number of bytes per line (non-negative)\n+             * @return this Builder\n+             * @throws IllegalArgumentException if the provided {@code bytes} are negative\n+             *\/\n+            Builder withBytesPerLine(int bytesPerLine);\n+\n+            \/**\n+             * Configures the column prefix for subsequent index and data columns.\n+             * <p>\n+             * Unless configured otherwise, the default column prefix is \"\" (an empty String).\n+             *\n+             * @param prefix the column prefix (non-null)\n+             * @return this Builder\n+             * @throws NullPointerException if the provided {@code prefix} is {@code null}\n+             *\/\n+            Builder withColumnPrefix(String prefix);\n+\n+            \/**\n+             * Configures the column suffix for subsequent index and data columns.\n+             * <p>\n+             * Unless configured otherwise, the default suffix is \"\" (an empty String).\n+             *\n+             * @param suffix the column suffix (non-null)\n+             * @return this Builder\n+             * @throws NullPointerException if the provided {@code suffix} is {@code null}\n+             *\/\n+            Builder withColumnSuffix(String suffix);\n+\n+            \/**\n+             * Configures the column delimiter for subsequent index and data columns.\n+             * <p>\n+             * The column delimiter will be inserted between columns (i.e. not after the last column).\n+             * Unless configured otherwise, the default suffix is \" \" (a single space).\n+             *\n+             * @param delimiter the column delimiter (non-null)\n+             * @return this Builder\n+             * @throws NullPointerException if the provided {@code delimiter} is {@code null}\n+             *\/\n+            Builder withColumnDelimiter(String delimiter);\n+\n+            \/**\n+             * Adds an index column with 8 bytes (64-bit) index with hexadecimal values formatted by\n+             * the default {@link HexFormat#of()} formatter.\n+             *\n+             * @return this Builder\n+             *\/\n+            Builder addIndexColumn();\n+\n+            \/**\n+             * Adds an index column with the provided {@code  bytes} index with hexadecimal values formatted by\n+             * the default {@link HexFormat#of()} formatter.\n+             *\n+             * @param bytes the number of bytes to render in the index (in the range [1, 8])\n+             * @return this Builder\n+             * @throws IllegalArgumentException if the provided {@code bytes} is outside the range [1, 8]\n+             *\/\n+            Builder addIndexColumn(int bytes);\n+\n+            \/**\n+             * Adds an index column with the provided {@code  bytes} index with hexadecimal values formatted by\n+             * the provided {@code formatter }.\n+             *\n+             * @param bytes     the number of bytes to render in the index (in the range [1, 8])\n+             * @param formatter the formatter to use for byte values in the index\n+             * @return this Builder\n+             * @throws IllegalArgumentException if the provided {@code bytes} is outside the range [1, 8]\n+             * @throws NullPointerException     if the provided {@code formatter} is {@code null}\n+             *\/\n+            Builder addIndexColumn(int bytes, HexFormat formatter);\n+\n+            \/**\n+             * Adds an index column with the provided {@code  bytes} index with hexadecimal values formatted by\n+             * the provided {@code renderer }.\n+             * <p>\n+             * Indexes used by the provided {@code renderer} are counted as byte indexes with the index value itself\n+             * and runs from the provided {@code bytes - 1} to 0.\n+             *\n+             * @param bytes    the number of bytes to render in the index (in the range [1, 8])\n+             * @param renderer the renderer to use for byte values in the index\n+             * @return this Builder\n+             * @throws IllegalArgumentException if the provided {@code bytes} is outside the range [1, 8]\n+             * @throws NullPointerException     if the provided {@code renderer} is {@code null}\n+             *\/\n+            Builder addIndexColumn(int bytes, ColumnRenderer renderer);\n+\n+            \/**\n+             * Adds a data column with hexadecimal values formatted by\n+             * a {@code HexFormat.ofDelimiter(\" \")} formatter.\n+             *\n+             * @return this Builder\n+             *\/\n+            Builder addDataColumn();\n+\n+            \/**\n+             * Adds a data column with hexadecimal values formatted by\n+             * the provided {@code formatter }.\n+             *\n+             * @param formatter the formatter to use for byte values in a row\n+             * @return this Builder\n+             * @throws NullPointerException if the provided {@code formatter} is {@code null}\n+             *\/\n+            Builder addDataColumn(HexFormat formatter);\n+\n+            \/**\n+             * Adds a data column with hexadecimal values formatted by\n+             * the provided {@code renderer }.\n+             *\n+             * @param renderer the renderer to use for byte values in a row\n+             * @return this Builder\n+             * @throws NullPointerException if the provided {@code renderer} is {@code null}\n+             *\/\n+            Builder addDataColumn(ColumnRenderer renderer);\n+\n+            \/**\n+             * {@return a new MemoryDumper instance with configurations made so far.}\n+             *\/\n+            MemoryDumper build();\n+\n+            \/**\n+             * Represents a function that accepts a long index and a byte value and produces a CharSequence such\n+             * as a String.\n+             *\n+             * @since 20\n+             *\/\n+            @FunctionalInterface\n+            interface ColumnRenderer {\n+\n+                \/**\n+                 * {@return a rendering of the provided {@code bytes} with the provided {@code BytesPerLine} }\n+                 * <p>\n+                 * Note: On the last line, chars may be padded using the ' ' character.\n+                 *\n+                 * @param bytesPerLine the bytes per line\n+                 * @param bytes        the byte array to render\n+                 *\/\n+                String render(int bytesPerLine, byte[] bytes);\n+\n+                \/**\n+                 * {@return a ByteRenderer that renders bytes into human readable characters.}\n+                 *\/\n+                static ColumnRenderer ofAscii() {\n+                    return (bytePerLine, bytes) -> {\n+                        StringBuilder sb = new StringBuilder();\n+                        for (int i = 0; i < bytePerLine; i++) {\n+                            if (i >= bytes.length) {\n+                                \/\/ Padding on the last line\n+                                sb.append(\" \");\n+                            } else {\n+                                final byte val = bytes[i];\n+                                if (val >= 32 && val < 127) {\n+                                    sb.append((char) val);\n+                                } else {\n+                                    sb.append(\".\");\n+                                }\n+                            }\n+                        }\n+                        return sb.toString();\n+                    };\n+                }\n+\n+                \/**\n+                 * {@return a ByteReader that renders bytes as per the provided {@code formatter}}\n+                 *\n+                 * @param formatter to use when formatting values\n+                 *\/\n+                static ColumnRenderer of(HexFormat formatter) {\n+                    requireNonNull(formatter);\n+                    return new ByteRenderedFromHexFormat(formatter);\n+                }\n+\n@@ -1260,6 +1512,18 @@\n-            \/\/ Append the actual memory value\n-            appendValue(segment.get(JAVA_BYTE, index));\n-            final long nextCnt = index + 1;\n-            if (nextCnt % DUMP_BYTES_PER_ROW == 0 || nextCnt == lastIndex) {\n-                \/\/ We have a complete line (eiter a full line or the last line)\n-                return renderLineToStringAndReset();\n+\n+        }\n+\n+    }\n+\n+    private static final class ByteRenderedFromHexFormat implements MemoryDumper.Builder.ColumnRenderer {\n+\n+        private final HexFormat formatter;\n+\n+        public ByteRenderedFromHexFormat(HexFormat formatter) {\n+            this.formatter = formatter;\n+        }\n+\n+        @Override\n+        public String render(int bytesPerLine, byte[] bytes) {\n+            final var sb = new StringBuilder();\n+            if (bytesPerLine == bytes.length) {\n+                formatter.formatHex(sb, bytes);\n@@ -1267,2 +1531,11 @@\n-                \/\/ For this count, there was no line break so pass null and filter it away later\n-                return null;\n+                \/\/ We are on the last line which needs padding\n+                final var expanded = new byte[bytesPerLine];\n+                System.arraycopy(bytes, 0, expanded, 0, bytes.length);\n+                formatter.formatHex(sb, expanded);\n+                final int bytesToRemove = bytesPerLine - bytes.length;\n+                final int charsToRemove = bytesToRemove * (formatter.prefix().length()+formatter.suffix().length()+2) +\n+                                          (bytesToRemove -1) * formatter.delimiter().length();\n+                \/\/ Erase the excess part\n+                for (int i = 0; i < charsToRemove; i++) {\n+                    sb.setCharAt(sb.length() - i - 1, ' ');\n+                }\n@@ -1270,0 +1543,26 @@\n+            return sb.toString();\n+        }\n+    }\n+\n+    private static final class StandardMemoryDumperBuilder implements MemoryDumper.Builder {\n+\n+        private final List<Column> columns;\n+        private int bytesPerLine = 16;\n+        private String columnPrefix = \"\";\n+        private String columnSuffix = \"\";\n+        private String columnDelimiter = \" \";\n+\n+        StandardMemoryDumperBuilder() {\n+            columns = new ArrayList<>();\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder withBytesPerLine(int bytes) {\n+            bytesPerLine = requirePositive(bytes);\n+            return this;\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder withColumnPrefix(String prefix) {\n+            columnPrefix = requireNonNull(prefix);\n+            return this;\n@@ -1272,2 +1571,4 @@\n-        boolean isEmpty() {\n-            return line.isEmpty();\n+        @Override\n+        public MemoryDumper.Builder withColumnSuffix(String suffix) {\n+            columnSuffix = requireNonNull(suffix);\n+            return this;\n@@ -1276,3 +1577,4 @@\n-        void appendIndex(long index) {\n-            line.append(hexFormat.toHexDigits(index));\n-            appendSpace();\n+        @Override\n+        public MemoryDumper.Builder withColumnDelimiter(String delimiter) {\n+            columnDelimiter = requireNonNull(delimiter);\n+            return this;\n@@ -1281,4 +1583,3 @@\n-        void appendValue(byte val) {\n-            line.append(hexFormat.toHexDigits(val));\n-            chars.append(viewByteAsAscii(val));\n-            appendSpace();\n+        @Override\n+        public MemoryDumper.Builder addIndexColumn() {\n+            return addIndexColumn(8);\n@@ -1287,4 +1588,102 @@\n-        String renderLineToStringAndReset() {\n-            while (line.length() < DUMP_LINE_LENGTH_EXCLUDING_CHARS) {\n-                \/\/ Pad if necessary\n-                appendSpace();\n+        @Override\n+        public MemoryDumper.Builder addIndexColumn(int bytes) {\n+            requireBetweenClosed(1, 8, bytes);\n+            return addIndexColumn(bytes, HexFormat.of());\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder addIndexColumn(int bytes, HexFormat formatter) {\n+            requireBetweenClosed(1, 8, bytes);\n+            requireNonNull(formatter);\n+            return addIndexColumn(bytes, ColumnRenderer.of(formatter));\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder addIndexColumn(int bytes, ColumnRenderer renderer) {\n+            requireBetweenClosed(1, 8, bytes);\n+            requireNonNull(renderer);\n+            columns.add(new Column(ColumnType.INDEX, OptionalInt.of(bytes), columnPrefix, renderer, columnSuffix, columnDelimiter));\n+            return this;\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder addDataColumn() {\n+            return addDataColumn(HexFormat.ofDelimiter(\" \"));\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder addDataColumn(HexFormat formatter) {\n+            requireNonNull(formatter);\n+            return addDataColumn(ColumnRenderer.of(formatter));\n+        }\n+\n+        @Override\n+        public MemoryDumper.Builder addDataColumn(ColumnRenderer renderer) {\n+            requireNonNull(renderer);\n+            columns.add(new Column(ColumnType.DATA, OptionalInt.empty(), columnPrefix, renderer, columnSuffix, columnDelimiter));\n+            return this;\n+        }\n+\n+        @Override\n+        public MemoryDumper build() {\n+            return new StandardMemoryDumper(bytesPerLine, columns);\n+        }\n+\n+        enum ColumnType {\n+            INDEX, DATA;\n+        }\n+\n+        private record Column(ColumnType type,\n+                              OptionalInt indexByteLength,\n+                              String prefix,\n+                              ColumnRenderer renderer,\n+                              String suffix,\n+                              String delimiter) {\n+        }\n+\n+        private int requirePositive(int value) {\n+            if (value < 1)\n+                throw new IllegalArgumentException(\"Value must be positive:\" + value);\n+            return value;\n+        }\n+\n+        \/\/ We assume from < to\n+        private int requireBetweenClosed(int from, int to, int value) {\n+            if (value < from || value > to)\n+                throw new IllegalArgumentException(\"Value \" + value + \" is not in the range [\" + from + \", \" + to + \"]\");\n+            return value;\n+        }\n+\n+    }\n+\n+    private static final class StandardMemoryDumper implements MemoryDumper {\n+\n+        private static final MemoryDumper STANDARD = MemoryDumper.builder()\n+                .addIndexColumn()\n+                .addDataColumn()\n+                .withColumnPrefix(\"|\")\n+                .withColumnSuffix(\"|\")\n+                .addDataColumn(HexFormat.MemoryDumper.Builder.ColumnRenderer.ofAscii())\n+                .build();\n+\n+\n+        private final int bytesPerLine;\n+        private final List<StandardMemoryDumperBuilder.Column> columns;\n+\n+        StandardMemoryDumper(int bytesPerLine,\n+                             List<StandardMemoryDumperBuilder.Column> columns) {\n+            this.bytesPerLine = bytesPerLine;\n+            this.columns = new ArrayList<>(columns);\n+        }\n+\n+        @Override\n+        public Stream<String> dump(byte[] bytes) {\n+            return dump0(bytes, ba -> ba.length, (ba, index) -> ba[Math.toIntExact(index)]);\n+        }\n+\n+        @Override\n+        public Stream<String> dump(byte[] bytes, int fromIndex, int toIndex) {\n+            if (fromIndex == 0) {\n+                if (toIndex>bytes.length)\n+                    throw new IllegalArgumentException(\"fromIndex \" + fromIndex + \" is greater than the array length \" + bytes.length);\n+                return dump0(bytes, ba -> toIndex, (ba, index) -> ba[(int) index]);\n@@ -1292,1 +1691,14 @@\n-            line.append('|').append(chars).append('|');\n+            return dump0(MemorySegment.ofArray(bytes).asSlice(fromIndex, toIndex - fromIndex),\n+                    MemorySegment::byteSize,\n+                    memorySegmentByteExtractor());\n+        }\n+\n+        @Override\n+        public Stream<String> dump(MemorySegment segment) {\n+            return dump0(segment, MemorySegment::byteSize, memorySegmentByteExtractor());\n+        }\n+\n+        @Override\n+        public Stream<String> dump(ByteBuffer buffer) {\n+            return dump0(buffer, ByteBuffer::remaining, (bb, index) -> bb.get(bb.position() + (int) (index)));\n+        }\n@@ -1294,4 +1706,47 @@\n-            final String result = line.toString();\n-            line.setLength(0);\n-            chars.setLength(0);\n-            return result;\n+        private <M> Stream<String> dump0(M memory,\n+                                         ToLongFunction<M> byteSizeExtractor,\n+                                         DumpState.ByteExtractor<M> byteExtractor) {\n+            requireNonNull(memory);\n+\n+            final long lastIndex = byteSizeExtractor.applyAsLong(memory);\n+            final long lines = (lastIndex + bytesPerLine - 1) \/ bytesPerLine;\n+            final var state = new DumpState<>(memory, lastIndex, byteExtractor, bytesPerLine, columns, lines);\n+            return LongStream.range(0, lines)\n+                    .mapToObj(state::lineMapper);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"StandardMemoryDumper{\" +\n+                    \"bytesPerLine=\" + bytesPerLine +\n+                    \", columns=\" + columns +\n+                    '}';\n+        }\n+\n+        private static DumpState.ByteExtractor<MemorySegment> memorySegmentByteExtractor() {\n+            return (memory, index) -> memory.get(JAVA_BYTE, index);\n+        }\n+\n+    }\n+\n+    private static final class DumpState<M> {\n+\n+        private final M memory;\n+        private final long lastIndex;\n+        private final ByteExtractor<M> byteExtractor;\n+        private final int bytesPerLine;\n+        private final List<StandardMemoryDumperBuilder.Column> columns;\n+        private final long lines;\n+\n+        DumpState(M memory,\n+                  long lastIndex,\n+                  ByteExtractor<M> byteExtractor,\n+                  int bytesPerLine,\n+                  List<StandardMemoryDumperBuilder.Column> columns,\n+                  long lines) {\n+            this.memory = memory;\n+            this.lastIndex = lastIndex;\n+            this.byteExtractor = byteExtractor;\n+            this.bytesPerLine = bytesPerLine;\n+            this.columns = columns;\n+            this.lines = lines;\n@@ -1300,2 +1755,43 @@\n-        void appendSpace() {\n-            line.append(' ');\n+\n+        \/**\n+         * {@return a new complete line (either a full line or the last line) for the provided {@code line} number}.\n+         *\n+         * @param line the line to render (non-negative)\n+         * @return a new line or {@code null}\n+         *\/\n+        String lineMapper(long line) {\n+\n+            \/\/ Todo: Investigate how to handle mapped sparse files\n+\n+            final StringBuilder sb = new StringBuilder();\n+            int columnCount = 0;\n+            for (StandardMemoryDumperBuilder.Column c : columns) {\n+                if (columnCount > 0) {\n+                    sb.append(c.delimiter());\n+                }\n+                sb.append(c.prefix());\n+                if (c.type() == StandardMemoryDumperBuilder.ColumnType.INDEX) {\n+                    final int len = c.indexByteLength().orElseThrow();\n+                    sb.append(c.renderer().render(len, toByteArray(len, line * bytesPerLine)));\n+                }\n+                if (c.type() == StandardMemoryDumperBuilder.ColumnType.DATA) {\n+                    final int len;\n+                    final long overflow = (line + 1L) * bytesPerLine - lastIndex;\n+                    if (overflow > 0) {\n+                        \/\/ We are on the last line and the last line needs trimming\n+                        len = Math.toIntExact(bytesPerLine - overflow);\n+                    } else {\n+                        \/\/ We are on a line (last or not) and no trimming needs to be done\n+                        len = bytesPerLine;\n+                    }\n+                    final byte[] bytes = new byte[len];\n+                    for (int i = 0; i < len; i++) {\n+                        final long index = line * bytesPerLine + i;\n+                        bytes[i] = byteExtractor.extract(memory, index);\n+                    }\n+                    sb.append(c.renderer().render(bytesPerLine, bytes));\n+                }\n+                sb.append(c.suffix());\n+                columnCount++;\n+            }\n+            return sb.toString();\n@@ -1308,5 +1804,26 @@\n-        static char viewByteAsAscii(byte b) {\n-            final int value = Byte.toUnsignedInt(b);\n-            return (value >= 32 && value < 127)\n-                    ? (char) value\n-                    : '.';\n+        @FunctionalInterface\n+        interface ByteExtractor<M> {\n+            byte extract(M memory, long index);\n+\n+            static ByteExtractor<MemorySegment> ofMemorySegment() {\n+                return (memory, index) -> memory.get(JAVA_BYTE, index);\n+            }\n+\n+            static ByteExtractor<byte[]> ofByteArray() {\n+                return (memory, index) -> memory[Math.toIntExact(index)];\n+            }\n+        }\n+    }\n+\n+    private static byte[] toByteArray(int length, long l) {\n+        byte[] result = new byte[length];\n+        if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) {\n+            for (int i = (length - 1); i >= 0; i--) {\n+                result[i] = (byte) (l & 0xFF);\n+                l >>= 8;\n+            }\n+        } else {\n+            for (int i = 0; i < length; i++) {\n+                result[i] = (byte) (l & 0xFF);\n+                l >>= 8;\n+            }\n@@ -1314,0 +1831,1 @@\n+        return result;\n","filename":"src\/java.base\/share\/classes\/java\/util\/HexFormat.java","additions":781,"deletions":263,"binary":false,"changes":1044,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.nio.ByteBuffer;\n@@ -795,5 +796,12 @@\n-            0000000000000000  54 68 65 20 71 75 69 63  6B 20 62 72 6F 77 6E 20  |The quick brown |\n-            0000000000000010  66 6F 78 20 6A 75 6D 70  65 64 20 6F 76 65 72 20  |fox jumped over |\n-            0000000000000020  74 68 65 20 6C 61 7A 79  20 64 6F 67 0A 53 65 63  |the lazy dog.Sec|\n-            0000000000000030  6F 6E 64 20 6C 69 6E 65  09 3A 68 65 72 65 00 00  |ond line.:here..|\n-            0000000000000040  00 00 00 00                                       |....|\"\"\");\n+            0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 |The quick brown |\n+            0000000000000010 66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20 |fox jumped over |\n+            0000000000000020 74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63 |the lazy dog.Sec|\n+            0000000000000030 6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65 00 00 |ond line.:here..|\n+            0000000000000040 00 00 00 00                                     |....            |\"\"\");\n+\n+    private static final String EXPECTED_HEX_SPECIAL = platformLineSeparated(\"\"\"\n+            0000000000000000  54 68 65 20 71 75 69 63  6b 20 62 72 6f 77 6e 20  |The quick brown |\n+            0000000000000010  66 6f 78 20 6a 75 6d 70  65 64 20 6f 76 65 72 20  |fox jumped over |\n+            0000000000000020  74 68 65 20 6c 61 7a 79  20 64 6f 67 0a 53 65 63  |the lazy dog.Sec|\n+            0000000000000030  6f 6e 64 20 6c 69 6e 65  09 3a 68 65 72 65 00 00  |ond line.:here..|\n+            0000000000000040  00 00 00 00                                       |....            |\"\"\");\n@@ -803,0 +811,120 @@\n+    @Test\n+    public void testDump64BitIndexToConsole() {\n+        System.out.println(\"***\");\n+        try (var session = MemorySession.openConfined()) {\n+            var segment = session.allocateUtf8String(THE_QUICK);\n+            HexFormat.MemoryDumper dumper = HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn()\n+                    .build();\n+\n+            System.out.println(dumper);\n+\n+            dumper.dump(segment)\n+                    .forEach(System.out::println);\n+        }\n+    }\n+\n+    @Test\n+    public void testDump64BitIndex() {\n+\n+        var expect = \"\"\"\n+                0000000000000000\n+                0000000000000010\n+                0000000000000020\n+                0000000000000030\n+                0000000000000040\"\"\";\n+\n+        var actual = testWithFreshMemorySegment(HEX_SEGMENT_SIZE, segment -> {\n+            segment.setUtf8String(0, THE_QUICK);\n+            return HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn()\n+                    .build()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testDump32BitIndex() {\n+\n+        var expect = \"\"\"\n+                00000000\n+                00000010\n+                00000020\n+                00000030\n+                00000040\"\"\";\n+\n+        var actual = testWithFreshMemorySegment(HEX_SEGMENT_SIZE, segment -> {\n+            segment.setUtf8String(0, THE_QUICK);\n+            return HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn(Integer.BYTES)\n+                    .build()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testDump8BitIndex() {\n+\n+        var expect = \"\"\"\n+                00\n+                10\n+                20\n+                30\n+                40\"\"\";\n+\n+        var actual = testWithFreshMemorySegment(HEX_SEGMENT_SIZE, segment -> {\n+            segment.setUtf8String(0, THE_QUICK);\n+            return HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn(1)\n+                    .build()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testHexStreamOneByte() {\n+\n+        var expect = platformLineSeparated(\"0000000000000000 41 00                                           |A.              |\");\n+\n+        var actual = testWithFreshMemorySegment(2, segment -> {\n+            segment.setUtf8String(0, \"A\");\n+            return HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn()\n+                    .addDataColumn()\n+                    .withColumnPrefix(\"|\")\n+                    .withColumnSuffix(\"|\")\n+                    .addDataColumn(HexFormat.MemoryDumper.Builder.ColumnRenderer.ofAscii())\n+                    .build()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testHexStreamOneByteWithStrangeFormatting() {\n+\n+        var expect = platformLineSeparated(\"0x00--,0x00--,0x00--,0x00--,0x00--,0x00--,0x00--,0x00-- 0x41--,0x00--,                                                                                                  |A.              |\");\n+\n+        var actual = testWithFreshMemorySegment(2, segment -> {\n+            segment.setUtf8String(0, \"A\");\n+            var formatter = HexFormat.ofDelimiter(\",\").withPrefix(\"0x\").withSuffix(\"--\");\n+            return HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn(8, formatter)\n+                    .addDataColumn(formatter)\n+                    .withColumnPrefix(\"|\")\n+                    .withColumnSuffix(\"|\")\n+                    .addDataColumn(HexFormat.MemoryDumper.Builder.ColumnRenderer.ofAscii())\n+                    .build()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+        assertEquals(actual, expect);\n+    }\n+\n@@ -808,1 +936,8 @@\n-            return HexFormat.dump(segment)\n+            return HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn()\n+                    .addDataColumn()\n+                    .withColumnPrefix(\"|\")\n+                    .withColumnSuffix(\"|\")\n+                    .addDataColumn(HexFormat.MemoryDumper.Builder.ColumnRenderer.ofAscii())\n+                    .build()\n+                    .dump(segment)\n@@ -813,0 +948,24 @@\n+\n+    @Test\n+    public void testEmptyMemoryDump() {\n+        var actual = testWithFreshMemorySegment(0, segment ->\n+                HexFormat.MemoryDumper.builder()\n+                        .addIndexColumn()\n+                        .build()\n+                        .dump(segment)\n+                        .collect(joining())\n+        );\n+        assertEquals(actual, \"\");\n+    }\n+\n+    @Test\n+    public void testEmptyDumper() {\n+        var actual = testWithFreshMemorySegment(10, segment ->\n+                HexFormat.MemoryDumper.builder()\n+                        .build()\n+                        .dump(segment)\n+                        .collect(joining())\n+        );\n+        assertEquals(actual, \"\");\n+    }\n+\n@@ -816,16 +975,16 @@\n-                0000000000000000  00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F  |................|\n-                0000000000000010  10 11 12 13 14 15 16 17  18 19 1A 1B 1C 1D 1E 1F  |................|\n-                0000000000000020  20 21 22 23 24 25 26 27  28 29 2A 2B 2C 2D 2E 2F  | !\"#$%&'()*+,-.\/|\n-                0000000000000030  30 31 32 33 34 35 36 37  38 39 3A 3B 3C 3D 3E 3F  |0123456789:;<=>?|\n-                0000000000000040  40 41 42 43 44 45 46 47  48 49 4A 4B 4C 4D 4E 4F  |@ABCDEFGHIJKLMNO|\n-                0000000000000050  50 51 52 53 54 55 56 57  58 59 5A 5B 5C 5D 5E 5F  |PQRSTUVWXYZ[\\\\]^_|\n-                0000000000000060  60 61 62 63 64 65 66 67  68 69 6A 6B 6C 6D 6E 6F  |`abcdefghijklmno|\n-                0000000000000070  70 71 72 73 74 75 76 77  78 79 7A 7B 7C 7D 7E 7F  |pqrstuvwxyz{|}~.|\n-                0000000000000080  80 81 82 83 84 85 86 87  88 89 8A 8B 8C 8D 8E 8F  |................|\n-                0000000000000090  90 91 92 93 94 95 96 97  98 99 9A 9B 9C 9D 9E 9F  |................|\n-                00000000000000A0  A0 A1 A2 A3 A4 A5 A6 A7  A8 A9 AA AB AC AD AE AF  |................|\n-                00000000000000B0  B0 B1 B2 B3 B4 B5 B6 B7  B8 B9 BA BB BC BD BE BF  |................|\n-                00000000000000C0  C0 C1 C2 C3 C4 C5 C6 C7  C8 C9 CA CB CC CD CE CF  |................|\n-                00000000000000D0  D0 D1 D2 D3 D4 D5 D6 D7  D8 D9 DA DB DC DD DE DF  |................|\n-                00000000000000E0  E0 E1 E2 E3 E4 E5 E6 E7  E8 E9 EA EB EC ED EE EF  |................|\n-                00000000000000F0  F0 F1 F2 F3 F4 F5 F6 F7  F8 F9 FA FB FC FD FE FF  |................|\"\"\");\n+                0000000000000000 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n+                0000000000000010 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f |................|\n+                0000000000000020 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f | !\"#$%&'()*+,-.\/|\n+                0000000000000030 30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f |0123456789:;<=>?|\n+                0000000000000040 40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f |@ABCDEFGHIJKLMNO|\n+                0000000000000050 50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f |PQRSTUVWXYZ[\\\\]^_|\n+                0000000000000060 60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f |`abcdefghijklmno|\n+                0000000000000070 70 71 72 73 74 75 76 77 78 79 7a 7b 7c 7d 7e 7f |pqrstuvwxyz{|}~.|\n+                0000000000000080 80 81 82 83 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f |................|\n+                0000000000000090 90 91 92 93 94 95 96 97 98 99 9a 9b 9c 9d 9e 9f |................|\n+                00000000000000a0 a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 aa ab ac ad ae af |................|\n+                00000000000000b0 b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 ba bb bc bd be bf |................|\n+                00000000000000c0 c0 c1 c2 c3 c4 c5 c6 c7 c8 c9 ca cb cc cd ce cf |................|\n+                00000000000000d0 d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 da db dc dd de df |................|\n+                00000000000000e0 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 ea eb ec ed ee ef |................|\n+                00000000000000f0 f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 fa fb fc fd fe ff |................|\"\"\");\n@@ -838,1 +997,8 @@\n-            var actual = HexFormat.dump(segment)\n+            var actual = HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn()\n+                    .addDataColumn()\n+                    .withColumnPrefix(\"|\")\n+                    .withColumnSuffix(\"|\")\n+                    .addDataColumn(HexFormat.MemoryDumper.Builder.ColumnRenderer.ofAscii())\n+                    .build()\n+                    .dump(segment)\n@@ -851,2 +1017,123 @@\n-            HexFormat.dump(segment)\n-                    .forEach(l -> assertEquals(l.length(), \"0000000000000000  00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F  |................|\".length()));\n+            var stat = HexFormat.MemoryDumper.builder()\n+                    .addIndexColumn()\n+                    .addDataColumn()\n+                    .withColumnPrefix(\"|\")\n+                    .withColumnSuffix(\"|\")\n+                    .addDataColumn(HexFormat.MemoryDumper.Builder.ColumnRenderer.ofAscii())\n+                    .build()\n+                    .dump(segment)\n+                    .mapToInt(String::length)\n+                    .summaryStatistics();\n+\n+            \/\/ Every row is of equal length\n+            assertEquals(stat.getMax(), stat.getMin());\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testStandardDump() {\n+        var actual = testWithFreshMemorySegment(HEX_SEGMENT_SIZE, segment -> {\n+            segment.setUtf8String(0, THE_QUICK);\n+            return HexFormat.MemoryDumper.standard()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+        assertEquals(actual, EXPECTED_HEX);\n+    }\n+\n+    @Test\n+    public void testStandardDumpWithArray() {\n+        var expect = \"\"\"\n+                0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 |The quick brown |\n+                0000000000000010 66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20 |fox jumped over |\n+                0000000000000020 74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63 |the lazy dog.Sec|\n+                0000000000000030 6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65       |ond line.:here  |\"\"\";\n+        var actual = HexFormat.MemoryDumper.standard()\n+                    .dump(THE_QUICK_ARRAY)\n+                    .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testStandardDumpWithArrayFromToEndpoints() {\n+        var expect = \"\"\"\n+                0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 |The quick brown |\n+                0000000000000010 66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20 |fox jumped over |\n+                0000000000000020 74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63 |the lazy dog.Sec|\n+                0000000000000030 6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65       |ond line.:here  |\"\"\";\n+        var actual = HexFormat.MemoryDumper.standard()\n+                .dump(THE_QUICK_ARRAY, 0, THE_QUICK_ARRAY.length)\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testStandardDumpWithArrayFrom0To13() {\n+        var expect = \"\"\"\n+                0000000000000000 54 68 65 20 71 75 69 63 6b 20 62 72 6f          |The quick bro   |\"\"\";\n+        var actual = HexFormat.MemoryDumper.standard()\n+                .dump(THE_QUICK_ARRAY, 0, 13)\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testStandardDumpWithArrayFrom2To9() {\n+        var expect = \"\"\"\n+                0000000000000000 65 20 71 75 69 63 6b                            |e quick         |\"\"\";\n+        var actual = HexFormat.MemoryDumper.standard()\n+                .dump(THE_QUICK_ARRAY, 2, 9)\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void testStandardDumpByteBuffer() {\n+        var expect = \"\"\"\n+                0000000000000000 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20 66 |he quick brown f|\n+                0000000000000010 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20 74 |ox jumped over t|\n+                0000000000000020 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63 6f |he lazy dog.Seco|\n+                0000000000000030 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65          |nd line.:here   |\"\"\";\n+        var buffer = ByteBuffer.wrap(THE_QUICK_ARRAY);\n+        \/\/ Consume a byte\n+        buffer.get();\n+        var actual = HexFormat.MemoryDumper.standard()\n+                .dump(buffer)\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    public void testSeveralColumns() {\n+        try (var session = MemorySession.openConfined()) {\n+            var segment = session.allocateUtf8String(THE_QUICK);\n+            var expect = \"\"\"\n++0000000000000000+ -00000000- \/54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20\/ *54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20* 0000\n++0000000000000010+ -00000010- \/66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20\/ *66 6f 78 20 6a 75 6d 70 65 64 20 6f 76 65 72 20* 0010\n++0000000000000020+ -00000020- \/74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63\/ *74 68 65 20 6c 61 7a 79 20 64 6f 67 0a 53 65 63* 0020\n++0000000000000030+ -00000030- \/6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65 00   \/ *6f 6e 64 20 6c 69 6e 65 09 3a 68 65 72 65 00   * 0030\"\"\";\n+            var actual = HexFormat.MemoryDumper.builder()\n+                    .withColumnPrefix(\"+\")\n+                    .withColumnSuffix(\"+\")\n+                    .addIndexColumn()\n+                    .withColumnPrefix(\"-\")\n+                    .withColumnSuffix(\"-\")\n+                    .addIndexColumn(4)\n+                    .withColumnPrefix(\"\/\")\n+                    .withColumnSuffix(\"\/\")\n+                    .addDataColumn()\n+                    .withColumnPrefix(\"*\")\n+                    .withColumnSuffix(\"*\")\n+                    .addDataColumn()\n+                    .withColumnPrefix(\"\")\n+                    .withColumnSuffix(\"\")\n+                    .addIndexColumn(2)\n+                    .build()\n+                    .dump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+            assertEquals(actual, expect);\n","filename":"test\/jdk\/java\/util\/HexFormat\/HexFormatTest.java","additions":312,"deletions":25,"binary":false,"changes":337,"status":"modified"}]}