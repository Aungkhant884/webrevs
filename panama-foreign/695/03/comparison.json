{"files":[{"patch":"@@ -42,4 +42,2 @@\n-import jdk.internal.foreign.AbstractMemorySegmentImpl;\n-import jdk.internal.foreign.HeapMemorySegmentImpl;\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n-import jdk.internal.foreign.Utils;\n+\n+import jdk.internal.foreign.*;\n@@ -1877,0 +1875,55 @@\n+    \/**\n+     * Returns a human-readable view of this memory segment viewed through\n+     * the provided {@code layout}.\n+     * <p>\n+     * The format of the returned view is as follows:\n+     * <ol>\n+     *     <li>tag\/value pairs are separated with an \"=\" character.<\/li>\n+     *     <li>Each element is tagged with its {@link MemoryLayout#name()} or, if no name exists,\n+     *     its {@link MemoryLayout#toString()} representation.<\/li>\n+     *     <li> Values are rendered differently depending on their type:\n+     *         <ul>\n+     *             <li>Numeric values are rendered in decimal form (e.g 1 or 1.2).<\/li>\n+     *             <li>Boolean values are rendered as {@code true} or {@code false}.<\/li>\n+     *             <li>Character values are rendered as {@code char}.<\/li>\n+     *             <li>Address values are rendered according to their {@code toString()} values.<\/li>\n+     *         <\/ul>\n+     *     <\/li>\n+     *     <li>Grouped layouts are enclosed in curly brackets.<\/li>\n+     *     <li>Structure and sequence elements are separated with a \",\" character.<\/li>\n+     *     <li>Union elements are separated with a \"|\" character.<\/li>\n+     *     <li>Lines are separated with the system-dependent line separator {@link System#lineSeparator() }.<\/li>\n+     * <\/ol>\n+     * Otherwise, the exact format of the returned view is unspecified and should not\n+     * be acted upon programmatically.\n+     * <p>\n+     * As an example, a memory segment viewed though the following memory layout\n+     * {@snippet lang = java:\n+     *   memorySegment.set(ValueLayout.JAVA_INT, 0, 1);\n+     *   memorySegment.set(ValueLayout.JAVA_INT, 4, 2);\n+     *\n+     *    var layout = MemoryLayout.structLayout(\n+     *           ValueLayout.JAVA_INT.withName(\"x\"),\n+     *           ValueLayout.JAVA_INT.withName(\"y\")\n+     *   ).withName(\"Point\");\n+     *\n+     *   System.out.println(memorySegment.toString(layout));\n+     *}\n+     * will print:\n+     * {@snippet lang = text:\n+     * Point {\n+     *   x=1,\n+     *   y=2\n+     * }\n+     *}\n+     *\n+     * @param layout  to use as a layout when viewing the memory segment\n+     * @return a view of the memory segment viewed through a memory layout layout\n+     * @throws OutOfMemoryError if the size of the UTF-8 string is greater than the largest string\n+     *         supported by the platform.\n+     *\/\n+    default String toString(MemoryLayout layout) {\n+        Objects.requireNonNull(layout);\n+        return MemorySegmentRenderUtil.viewThrough(this, layout);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":57,"deletions":4,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,394 @@\n+\/*\n+ *  Copyright (c) 2022, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import java.lang.foreign.*;\n+import java.nio.ByteBuffer;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * Internal class to support rendering of MemorySegments into various formats.\n+ *\/\n+public final class MemorySegmentRenderUtil {\n+\n+    private static final byte[] UPPERCASE_HEX_DIGITS = {\n+            '0', '1', '2', '3', '4', '5', '6', '7',\n+            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n+    };\n+\n+    private static final int HEX_STREAM_BYTES_PER_ROW = 1 << 4; \/\/ Should be a power of 2\n+    private static final int HEX_LINE_LENGTH_EXCLUDING_CHARS = Long.BYTES * 2 + HEX_STREAM_BYTES_PER_ROW * 3 + 4;\n+\n+    private MemorySegmentRenderUtil() {\n+    }\n+\n+    \/**\n+     * Returns a Stream of human-readable, lines with hexadecimal values for this memory segment.\n+     * <p>\n+     * Each element in the stream comprises the following characters:\n+     * <ol>\n+     *     <li>an initial 64-bit offset (e.g. \"0000000000000010\").<\/li>\n+     *     <li>a sequence of two spaces (i.e. \"  \").<\/li>\n+     *     <li>a sequence of at most eight bytes (e.g. \"66 6F 78 20 6A 75 6D 70\") where\n+     *     each byte is separated by a space.<\/li>\n+     *     <li>a sequence of two spaces (i.e. \"  \").<\/li>\n+     *     <li>a sequence of at most eight bytes (e.g. \"65 64 20 6F 76 65 72 20\") where\n+     *     each byte separated by a space.<\/li>\n+     *     <li>a sequence of N spaces (i.e. \"  \") such that the intermediate line is aligned to 68 characters<\/li>\n+     *     <li>a \"|\" separator.<\/li>\n+     *     <li>a sequence of at most 16 printable Ascii characters (values outside [32, 127] will be printed as \".\").<\/li>\n+     *     <li>a \"|\" separator.<\/li>\n+     * <\/ol>\n+     * All the values above are given in hexadecimal form with leading zeros. As there are at most 16 bytes\n+     * rendered for each line, there will be N = ({@link MemorySegment#byteSize()} + 15) \/ 16 elements in the returned stream.\n+     * <p>\n+     * As a consequence of the above, this method renders to a format similar to the *nix command \"hexdump -C\".\n+     * <p>\n+     * As an example, a memory segment created, initialized and used as follows\n+     * {@snippet lang = java:\n+     *   MemorySegment segment = memorySession.allocate(64 + 4);\n+     *   segment.setUtf8String(0, \"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\");\n+     *   segment.hexDump()\n+     *       .forEach(System.out::println);\n+     *}\n+     * will be printed as:\n+     * {@snippet lang = text:\n+     * 0000000000000000  54 68 65 20 71 75 69 63  6B 20 62 72 6F 77 6E 20  |The quick brown |\n+     * 0000000000000010  66 6F 78 20 6A 75 6D 70  65 64 20 6F 76 65 72 20  |fox jumped over |\n+     * 0000000000000020  74 68 65 20 6C 61 7A 79  20 64 6F 67 0A 53 65 63  |the lazy dog.Sec|\n+     * 0000000000000030  6F 6E 64 20 6C 69 6E 65  09 3A 68 65 72 65 00 00  |ond line.:here..|\n+     * 0000000000000040  00 00 00 00                                       |....|\n+     *}\n+     * <p>\n+     * Use a {@linkplain MemorySegment#asSlice(long, long) slice} to inspect a specific region\n+     * of a memory segment.\n+     * <p>\n+     * This method can be used to dump the contents of various other memory containers such as\n+     * {@linkplain ByteBuffer ByteBuffers} and byte arrays by means of first wrapping the container\n+     * into a MemorySegment:\n+     * {@snippet lang = java:\n+     *   MemorySegment.ofArray(byteArray).hexDump();\n+     *   MemorySegment.ofBuffer(byteBuffer).hexDump();\n+     *}\n+     * @param segment to inspect\n+     * @return a Stream of human-readable, lines with hexadecimal values\n+     *\/\n+    public static Stream<String> hexDump(MemorySegment segment) {\n+        requireNonNull(segment);\n+        \/\/ Todo: Investigate how to handle mapped sparse files\n+\n+        final var state = new HexStreamState();\n+        return LongStream.range(0, segment.byteSize())\n+                .mapToObj(index -> {\n+                    if (state.isEmpty()) {\n+                        \/\/ We are on a new line: Append the index\n+                        state.appendIndex(index);\n+                    }\n+                    if (index % (HEX_STREAM_BYTES_PER_ROW >>> 1) == 0) {\n+                        \/\/ We are either at the beginning or halfway through: add an extra space for readability\n+                        state.appendSpace();\n+                    }\n+                    \/\/ Append the actual memory value\n+                    state.appendValue(segment.get(ValueLayout.JAVA_BYTE, index));\n+                    final long nextCnt = index + 1;\n+                    if (nextCnt % HEX_STREAM_BYTES_PER_ROW == 0 || nextCnt == segment.byteSize()) {\n+                        \/\/ We have a complete line (eiter a full line or the last line)\n+                        return state.renderLineToStringAndReset();\n+                    } else {\n+                        \/\/ For this count, there was no line break so pass null and filter it away later\n+                        return null;\n+                    }\n+                })\n+                .filter(Objects::nonNull);\n+    }\n+\n+    \/**\n+     * Returns a human-readable view of the provided {@code segment} viewed through\n+     * the provided {@code layout}.\n+     * <p>\n+     * Lines are separated with the system-dependent line separator {@link System#lineSeparator() }.\n+     * Otherwise, the exact format of the returned view is unspecified and should not\n+     * be acted upon programmatically.\n+     * <p>\n+     * As an example, a MemorySegment viewed though the following memory layout\n+     * {@snippet lang = java:\n+     * var layout = MemoryLayout.structLayout(\n+     *         ValueLayout.JAVA_INT.withName(\"x\"),\n+     *         ValueLayout.JAVA_INT.withName(\"y\")\n+     * ).withName(\"Point\");\n+     *}\n+     * might be rendered to something like this:\n+     * {@snippet lang = text:\n+     * Point {\n+     *   x=1,\n+     *   y=2\n+     * }\n+     *}\n+     * <p>\n+     * This method is intended to view memory segments through small and medium-sized memory layouts\n+     * and is, in all cases, restricted by the inherent String capacity limit.\n+     *\n+     * @param segment to be viewed\n+     * @param layout  to use as a layout when viewing the memory segment\n+     * @return a view of the memory segment viewed through the memory layout\n+     * @throws OutOfMemoryError if the view exceeds the array size VM limit\n+     *\/\n+    public static String viewThrough(MemorySegment segment,\n+                                     MemoryLayout layout) {\n+        requireNonNull(segment);\n+        requireNonNull(layout);\n+\n+        final var sb = new StringBuilder();\n+        final Consumer<CharSequence> action = line -> {\n+            if (!sb.isEmpty()) {\n+                sb.append(System.lineSeparator());\n+            }\n+            sb.append(line);\n+        };\n+        renderView(segment, layout, action, new ViewState(), \"\");\n+        return sb.toString();\n+    }\n+\n+    public static void renderView(MemorySegment segment,\n+                                  MemoryLayout layout,\n+                                  Consumer<? super CharSequence> action,\n+                                  ViewState state,\n+                                  String suffix) {\n+\n+        \/\/ TODO: Replace with \"patterns in switch statement\" once this becomes available.\n+\n+        if (layout instanceof ValueLayout.OfByte ofByte) {\n+            action.accept(renderValueLayout(state, ofByte, Byte.toString(segment.get(ofByte, state.indexAndAdd(ofByte))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfShort ofShort) {\n+            action.accept(renderValueLayout(state, ofShort, Short.toString(segment.get(ofShort, state.indexAndAdd(ofShort))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfInt ofInt) {\n+            action.accept(renderValueLayout(state, ofInt, Integer.toString(segment.get(ofInt, state.indexAndAdd(ofInt))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfLong ofLong) {\n+            action.accept(renderValueLayout(state, ofLong, Long.toString(segment.get(ofLong, state.indexAndAdd(ofLong))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfFloat ofFloat) {\n+            action.accept(renderValueLayout(state, ofFloat, Float.toString(segment.get(ofFloat, state.indexAndAdd(ofFloat))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfDouble ofDouble) {\n+            action.accept(renderValueLayout(state, ofDouble, Double.toString(segment.get(ofDouble, state.indexAndAdd(ofDouble))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfChar ofChar) {\n+            action.accept(renderValueLayout(state, ofChar, Character.toString(segment.get(ofChar, state.indexAndAdd(ofChar))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfBoolean ofBoolean) {\n+            action.accept(renderValueLayout(state, ofBoolean, Boolean.toString(segment.get(ofBoolean, state.indexAndAdd(ofBoolean))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfAddress ofAddress) {\n+            action.accept(renderValueLayout(state, ofAddress, segment.get(ofAddress, state.indexAndAdd(ofAddress)).toString(), suffix));\n+            return;\n+        }\n+        \/\/ PaddingLayout is package private.\n+        if (\"java.lang.foreign.PaddingLayout\".equals(layout.getClass().getName())) {\n+            action.accept(state.indentSpaces() + layout.bitSize() + \" padding bits\");\n+            state.indexAndAdd(layout);\n+            return;\n+        }\n+        if (layout instanceof GroupLayout groupLayout) {\n+\n+            \/* Strictly, we should provide all permutations of unions.\n+             * So, if we have a union U =  (A|B),(C|D) then we should present:\n+             * (A,C), (A,D), (B,C) and (B,D)\n+             *\/\n+\n+            final var separator = groupLayout.isStruct()\n+                    ? \",\"  \/\/ Struct separator\n+                    : \"|\"; \/\/ Union separator\n+\n+            action.accept(indentedLabel(state, groupLayout) + \" {\");\n+            state.incrementIndent();\n+            final var members = groupLayout.memberLayouts();\n+            final long initialIndex = state.index();\n+            long maxIndex = initialIndex;\n+            for (int i = 0; i < members.size(); i++) {\n+                if (groupLayout.isUnion()) {\n+                    \/\/ If it is a union, we need to reset the index for each member\n+                    state.index(initialIndex);\n+                    \/\/ We record the max index used for any union member so we can leave off from there\n+                    maxIndex = Math.max(maxIndex, state.index());\n+                }\n+                renderView(segment, members.get(i), action, state, (i != (members.size() - 1)) ? separator : \"\");\n+                if (groupLayout.isUnion()) {\n+                    \/\/ This is the best we can do.\n+                    state.index(maxIndex);\n+                }\n+            }\n+            state.decrementIndent();\n+            action.accept(state.indentSpaces() + \"}\" + suffix);\n+            return;\n+        }\n+        if (layout instanceof SequenceLayout sequenceLayout) {\n+            action.accept(indentedLabel(state, sequenceLayout) + \" [\");\n+            state.incrementIndent();\n+            final long elementCount = sequenceLayout.elementCount();\n+            for (long i = 0; i < elementCount; i++) {\n+                renderView(segment, sequenceLayout.elementLayout(), action, state, (i != (elementCount - 1L)) ? \",\" : \"\");\n+            }\n+            state.decrementIndent();\n+            action.accept(state.indentSpaces() + \"]\" + suffix);\n+            return;\n+        }\n+        action.accept(\"Unknown layout: \" + layout);\n+    }\n+\n+    static String renderValueLayout(ViewState state,\n+                                    ValueLayout layout,\n+                                    String value,\n+                                    String suffix) {\n+        return indentedLabel(state, layout) + \"=\" + value + suffix;\n+    }\n+\n+    static String indentedLabel(ViewState state,\n+                                MemoryLayout layout) {\n+        return state.indentSpaces() + layout.name()\n+                .orElseGet(layout::toString);\n+    }\n+\n+    static final class HexStreamState {\n+        private final StringBuilder line = new StringBuilder();\n+        private final StringBuilder chars = new StringBuilder();\n+\n+        boolean isEmpty() {\n+            return line.isEmpty();\n+        }\n+\n+        void appendIndex(long index) {\n+            appendHexTo(line, index);\n+            appendSpace();\n+        }\n+\n+        void appendValue(byte val) {\n+            appendHexTo(line, val);\n+            chars.append(viewByteAsAscii(val));\n+            appendSpace();\n+        }\n+\n+        String renderLineToStringAndReset() {\n+            while (line.length() < HEX_LINE_LENGTH_EXCLUDING_CHARS) {\n+                \/\/ Pad if necessary\n+                appendSpace();\n+            }\n+            line.append('|').append(chars).append('|');\n+\n+            final String result = line.toString();\n+            line.setLength(0);\n+            chars.setLength(0);\n+            return result;\n+        }\n+\n+        void appendSpace() {\n+            line.append(' ');\n+        }\n+    }\n+\n+    static final class ViewState {\n+\n+        private static final int SPACES_PER_INDENT = 4;\n+\n+        \/\/ Holding a non-static indents allows simple thread-safe use\n+        private final StringBuilder indents = new StringBuilder();\n+\n+        private int indent;\n+        private long index;\n+\n+        void incrementIndent() {\n+            indent++;\n+        }\n+\n+        void decrementIndent() {\n+            indent--;\n+        }\n+\n+        String indentSpaces() {\n+            final int spaces = indent * SPACES_PER_INDENT;\n+            while (indents.length() < spaces) {\n+                \/\/ Expand as needed\n+                indents.append(\" \");\n+            }\n+            return indents.substring(0, spaces);\n+        }\n+\n+        long index() {\n+            return index;\n+        }\n+\n+        void index(long index) {\n+            this.index = index;\n+        }\n+\n+        long indexAndAdd(long delta) {\n+            final long val = index;\n+            index += delta;\n+            return val;\n+        }\n+\n+        long indexAndAdd(MemoryLayout layout) {\n+            return indexAndAdd(layout.byteSize());\n+        }\n+    }\n+\n+    static void appendHexTo(StringBuilder sb,\n+                            long value) {\n+        long reversed = Long.reverseBytes(value);\n+        for (int i = 0; i < Long.BYTES; i++) {\n+            appendHexTo(sb, (byte) (reversed & 0xff));\n+            reversed >>>= Byte.SIZE;\n+        }\n+    }\n+\n+    static void appendHexTo(StringBuilder sb,\n+                            byte value) {\n+        sb.append((char) UPPERCASE_HEX_DIGITS[(value >>> 4)]);\n+        sb.append((char) UPPERCASE_HEX_DIGITS[(value & (byte) 0x0f)]);\n+    }\n+\n+    static char viewByteAsAscii(byte b) {\n+        final int value = Byte.toUnsignedInt(b);\n+        return (value >= 32 && value < 127)\n+                ? (char) value\n+                : '.';\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySegmentRenderUtil.java","additions":394,"deletions":0,"binary":false,"changes":394,"status":"added"},{"patch":"@@ -0,0 +1,260 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.foreign\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED RenderTest\n+ *\/\n+\n+import java.lang.foreign.*;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import jdk.internal.foreign.MemorySegmentRenderUtil;\n+import org.testng.annotations.*;\n+\n+import static java.util.stream.Collectors.joining;\n+import static org.testng.Assert.*;\n+import static jdk.internal.foreign.MemorySegmentRenderUtil.*;\n+import static java.util.Objects.requireNonNull;\n+\n+@Test\n+public class RenderTest {\n+\n+    private static final int HEX_SEGMENT_SIZE = 64 + 4;\n+    private static final String THE_QUICK = \"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\";\n+\n+    private static final byte[] THE_QUICK_ARRAY = THE_QUICK.getBytes(StandardCharsets.UTF_8);\n+    private static final String EXPECTED_HEX = platformLineSeparated(\"\"\"\n+                0000000000000000  54 68 65 20 71 75 69 63  6B 20 62 72 6F 77 6E 20  |The quick brown |\n+                0000000000000010  66 6F 78 20 6A 75 6D 70  65 64 20 6F 76 65 72 20  |fox jumped over |\n+                0000000000000020  74 68 65 20 6C 61 7A 79  20 64 6F 67 0A 53 65 63  |the lazy dog.Sec|\n+                0000000000000030  6F 6E 64 20 6C 69 6E 65  09 3A 68 65 72 65 00 00  |ond line.:here..|\n+                0000000000000040  00 00 00 00                                       |....|\"\"\");\n+\n+    @Test\n+    public void testHexStream() {\n+\n+        var actual = testWithFreshMemorySegment(HEX_SEGMENT_SIZE, segment -> {\n+            segment.setUtf8String(0, THE_QUICK);\n+            return hexDump(segment)\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+        assertEquals(EXPECTED_HEX, actual);\n+    }\n+\n+    @Test\n+    public void testHexStreamByteArray() {\n+\n+        var array = new byte[HEX_SEGMENT_SIZE];\n+        System.arraycopy(THE_QUICK_ARRAY, 0, array, 0, THE_QUICK.length());\n+        var actual = hexDump(MemorySegment.ofArray(array))\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(EXPECTED_HEX, actual);\n+    }\n+\n+    @Test\n+    public void testHexStreamByteBuffer() {\n+\n+        var array = new byte[HEX_SEGMENT_SIZE];\n+        System.arraycopy(THE_QUICK_ARRAY, 0, array, 0, THE_QUICK.length());\n+        var actual = hexDump(MemorySegment.ofBuffer(ByteBuffer.wrap(array)))\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(EXPECTED_HEX, actual);\n+    }\n+\n+\n+    @Test\n+    public void valueLayouts() {\n+\n+        var addressStringValue = MemorySegment.allocateNative(Long.BYTES, ValueLayout.ADDRESS.byteAlignment(), MemorySession.openImplicit())\n+                .get(ValueLayout.ADDRESS, 0)\n+                .toString();\n+\n+        record TestInput(ValueLayout layout, String stringValue){};\n+        List.of(\n+                new TestInput(ValueLayout.JAVA_BYTE, \"0\"),\n+                new TestInput(ValueLayout.JAVA_SHORT, \"0\"),\n+                new TestInput(ValueLayout.JAVA_INT, \"0\"),\n+                new TestInput(ValueLayout.JAVA_LONG, \"0\"),\n+                new TestInput(ValueLayout.JAVA_FLOAT, \"0.0\"),\n+                new TestInput(ValueLayout.JAVA_DOUBLE, \"0.0\"),\n+                new TestInput(ValueLayout.JAVA_CHAR, \"\"+(char)0),\n+                new TestInput(ValueLayout.JAVA_BOOLEAN, \"false\"),\n+                new TestInput(ValueLayout.ADDRESS, addressStringValue)\n+        ).forEach(ti -> {\n+            var expect = ti.layout() + \"=\" + ti.stringValue();\n+            var actual = testWithFreshMemorySegment(ti.layout().byteSize(), s -> viewThrough(s, ti.layout()));\n+            assertEquals(expect, actual);\n+        });\n+    }\n+\n+    @Test\n+    public void point() {\n+\n+        final class Point {\n+\n+            private static final MemoryLayout LAYOUT = MemoryLayout.structLayout(\n+                    ValueLayout.JAVA_INT.withName(\"x\"),\n+                    ValueLayout.JAVA_INT.withName(\"y\")\n+            ).withName(\"Point\");\n+\n+            private static final VarHandle xVH = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"x\"));\n+            private static final VarHandle yVH = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"y\"));\n+\n+            private final MemorySegment memorySegment;\n+\n+            public Point(MemorySegment memorySegment) {\n+                this.memorySegment = requireNonNull(memorySegment);\n+            }\n+\n+            int x() {\n+                return (int) xVH.get(memorySegment);\n+            }\n+\n+            int y() {\n+                return (int) yVH.get(memorySegment);\n+            }\n+\n+            void x(int x) {\n+                xVH.set(memorySegment, x);\n+            }\n+\n+            void y(int y) {\n+                yVH.set(memorySegment, y);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return \"Point {x=\" + x() + \", y=\" + y() + \"}\";\n+            }\n+        }\n+\n+        var expect = platformLineSeparated(\"\"\"\n+                Point {\n+                    x=1,\n+                    y=2\n+                }\"\"\");\n+\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 2, segment -> {\n+            final Point point = new Point(segment);\n+            point.x(1);\n+            point.y(2);\n+            return viewThrough(segment, Point.LAYOUT);\n+        });\n+\n+        assertEquals(expect, actual);\n+    }\n+\n+    @Test\n+    public void sequence() {\n+        final int arraySize = 4;\n+        var sequenceLayout = MemoryLayout.sequenceLayout(arraySize,\n+                MemoryLayout.structLayout(\n+                        ValueLayout.JAVA_INT.withName(\"x\"),\n+                        ValueLayout.JAVA_INT.withName(\"y\")\n+                ).withName(\"Point\")\n+        ).withName(\"PointArrayOfElements\");\n+\n+        var expect = platformLineSeparated(\"\"\"\n+                PointArrayOfElements [\n+                    Point {\n+                        x=0,\n+                        y=0\n+                    },\n+                    Point {\n+                        x=0,\n+                        y=0\n+                    },\n+                    Point {\n+                        x=0,\n+                        y=0\n+                    },\n+                    Point {\n+                        x=0,\n+                        y=0\n+                    }\n+                ]\"\"\");\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 2 * arraySize, segment ->\n+                viewThrough(segment, sequenceLayout));\n+\n+        assertEquals(expect, actual);\n+    }\n+\n+\n+    @Test\n+    public void union() {\n+        var u0 = MemoryLayout.structLayout(\n+                ValueLayout.JAVA_INT.withName(\"x\"),\n+                ValueLayout.JAVA_INT.withName(\"y\"),\n+                MemoryLayout.paddingLayout(Integer.SIZE)\n+        ).withName(\"Point\");\n+\n+        var u1 = MemoryLayout.structLayout(\n+                ValueLayout.JAVA_INT.withName(\"x\"),\n+                ValueLayout.JAVA_INT.withName(\"y\"),\n+                ValueLayout.JAVA_INT.withName(\"z\")\n+        ).withName(\"3D-Point\");\n+\n+        var union = MemoryLayout.unionLayout(u0, u1).withName(\"Union\");\n+\n+        var expect = platformLineSeparated(\"\"\"\n+                Union {\n+                    Point {\n+                        x=0,\n+                        y=0,\n+                        32 padding bits\n+                    }|\n+                    3D-Point {\n+                        x=0,\n+                        y=0,\n+                        z=0\n+                    }\n+                }\"\"\");\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 3, segment ->\n+                viewThrough(segment, union));\n+\n+        assertEquals(expect, actual);\n+    }\n+\n+    private static String platformLineSeparated(String s) {\n+        return s.lines()\n+                .collect(joining(System.lineSeparator()));\n+    }\n+\n+    private static <T> T testWithFreshMemorySegment(long size,\n+                                                    Function<MemorySegment, T> mapper) {\n+        try (final MemorySession session = MemorySession.openConfined()) {\n+            var segment = session.allocate(size);\n+            return mapper.apply(segment);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/RenderTest.java","additions":260,"deletions":0,"binary":false,"changes":260,"status":"added"}]}