{"files":[{"patch":"@@ -0,0 +1,333 @@\n+package java.lang.foreign;\n+\n+import jdk.internal.foreign.MemorySegmentRenderUtil;\n+\n+import java.nio.ByteBuffer;\n+import java.util.stream.Stream;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.util.Objects.requireNonNull;\n+import static jdk.internal.foreign.MemorySegmentRenderUtil.*;\n+\n+\/**\n+ * Class that support inspection of various memory abstractions such as\n+ * MemorySegment, ByteBuffer and byte arrays.\n+ * <p>\n+ * The methods in this class are not thread safe.\n+ *\/\n+public final class MemoryInspection {\n+\n+    \/\/ Suppresses default constructor, ensuring non-instantiability.\n+    private MemoryInspection() {\n+    }\n+\n+    \/**\n+     * Returns a Stream of human-readable, lines with hexadecimal values for the provided\n+     * {@code memory} abstraction. The memory abstraction can be of arbitrary type.\n+     * <p>\n+     * Each element in the stream comprises the following characters:\n+     * <ol>\n+     *     <li>an initial 64-bit offset (e.g. \"0000000000000010\").<\/li>\n+     *     <li>a sequence of two spaces (i.e. \"  \").<\/li>\n+     *     <li>a sequence of at most eight bytes (e.g. \"66 6F 78 20 6A 75 6D 70\") where\n+     *     each byte is separated by a space.<\/li>\n+     *     <li>a sequence of two spaces (i.e. \"  \").<\/li>\n+     *     <li>a sequence of at most eight bytes (e.g. \"65 64 20 6F 76 65 72 20\") where\n+     *     each byte separated by a space.<\/li>\n+     *     <li>a sequence of N spaces (i.e. \"  \") such that the intermediate line is aligned to 68 characters<\/li>\n+     *     <li>a \"|\" separator.<\/li>\n+     *     <li>a sequence of at most 16 printable Ascii characters (values outside [32, 127] will be printed as \".\").<\/li>\n+     *     <li>a \"|\" separator.<\/li>\n+     * <\/ol>\n+     * All the values above are given in hexadecimal form with leading zeros. As there are at most 16 bytes\n+     * rendered for each line, there will be N = ({@code adapter.length(memory)} + 15) \/ 16 elements in the returned stream.\n+     * <p>\n+     * As a consequence of the above, this method renders to a format similar to the *nix command \"hexdump -C\".\n+     * <p>\n+     * As an example, a memory created, initialized and used as follows\n+     * {@snippet lang = java:\n+     *   MemorySegment memory = memorySession.allocate(64 + 4);\n+     *   memory.setUtf8String(0, \"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\");\n+     *   MemoryInspection.hexDump(memory, Adapter.ofMemorySegment())\n+     *       .forEach(System.out::println);\n+     *}\n+     * will be printed as:\n+     * {@snippet lang = text:\n+     * 0000000000000000  54 68 65 20 71 75 69 63  6B 20 62 72 6F 77 6E 20  |The quick brown |\n+     * 0000000000000010  66 6F 78 20 6A 75 6D 70  65 64 20 6F 76 65 72 20  |fox jumped over |\n+     * 0000000000000020  74 68 65 20 6C 61 7A 79  20 64 6F 67 0A 53 65 63  |the lazy dog.Sec|\n+     * 0000000000000030  6F 6E 64 20 6C 69 6E 65  09 3A 68 65 72 65 00 00  |ond line.:here..|\n+     * 0000000000000040  00 00 00 00                                       |....|\n+     *}\n+     * <p>\n+     * Use a {@linkplain MemorySegment#asSlice(long, long) slice} or similar memory slicing capabilities to\n+     * inspect a specific region of a memory.\n+     * <p>\n+     * This method can be used to directly dump the contents of various other memory abstractions such as\n+     * {@linkplain ByteBuffer ByteBuffers} and byte arrays:\n+     * {@snippet lang = java:\n+     *   MemoryInspection.hexDump(byteArray, Adapter.ofByteArray());\n+     *   MemoryInspection.hexDump(byteBuffer, Adapter.ofByteBuffer());\n+     *}\n+     *\n+     * @param memory  the memory abstraction to inspect.\n+     * @param adapter to apply to the provided memory to determine the size and content of the memory abstraction.\n+     * @param <M>     the memory abstraction type.\n+     * @return a Stream of human-readable, lines with hexadecimal values\n+     * @throws RuntimeException depending on the provided extractors whose exceptions will be relayed to the\n+     *                          call site.\n+     *\/\n+    public static <M> Stream<String> hexDump(M memory,\n+                                             Adapter<M> adapter) {\n+        requireNonNull(memory);\n+        requireNonNull(adapter);\n+        return MemorySegmentRenderUtil.hexDump(memory, adapter);\n+    }\n+\n+    \/**\n+     * Returns a human-readable view of the provided {@code memory} abstraction by optionally\n+     * (if not a {@link MemorySession} and {@link Adapter#ofMemorySegment()} already) copying the contents\n+     * to a fresh MemorySegment and then view the resulting MemorySegment through the provided {@code layout}.\n+     * <p>\n+     * Lines are separated with the system-dependent line separator {@link System#lineSeparator() }.\n+     * Otherwise, the exact format of the returned view is unspecified and should not\n+     * be acted upon programmatically.\n+     * <p>\n+     * As an example, a MemorySegment viewed though the following memory layout\n+     * {@snippet lang = java:\n+     * var layout = MemoryLayout.structLayout(\n+     *         ValueLayout.JAVA_INT.withName(\"x\"),\n+     *         ValueLayout.JAVA_INT.withName(\"y\")\n+     * ).withName(\"Point\");\n+     *}\n+     * might be rendered to something like this:\n+     * {@snippet lang = text:\n+     * Point {\n+     *   x=1,\n+     *   y=2\n+     * }\n+     *}\n+     * <p>\n+     * This method is intended to view memory abstractions through small and medium-sized memory layouts.\n+     *\n+     * @param memory   to be viewed\n+     * @param adapter  to apply to the provided memory to determine the size and content of the memory abstraction.\n+     * @param layout   to use as a layout when viewing the memory segment\n+     * @param renderer to apply when rendering value layouts\n+     * @param <M>      the memory abstraction type.\n+     * @return a view of the memory abstraction viewed through the memory layout\n+     * @throws OutOfMemoryError if the view exceeds the array size VM limit\n+     *\/\n+    public static <M> String toString(M memory,\n+                                      Adapter<M> adapter,\n+                                      MemoryLayout layout,\n+                                      ValueLayoutRenderer renderer) {\n+        requireNonNull(memory);\n+        requireNonNull(adapter);\n+        requireNonNull(layout);\n+        requireNonNull(renderer);\n+\n+        if (memory instanceof MemorySegment segment && adapter == MEMORY_SEGMENT_MEMORY_ADAPTER) {\n+            return MemorySegmentRenderUtil.toString(segment, layout, renderer);\n+        }\n+        long length = adapter.length(memory);\n+        try (var session = MemorySession.openConfined()) {\n+            var segment = session.allocate(length, Long.SIZE);\n+            for (long i = 0; i < length; i++) {\n+                segment.set(JAVA_BYTE, i, adapter.get(memory, i));\n+            }\n+            return MemorySegmentRenderUtil.toString(segment, layout, renderer);\n+        }\n+    }\n+\n+    \/**\n+     * General memory adapter for rendering any memory abstraction.\n+     *\n+     * @param <M> the type of memory abstraction (e.g. ByteBuffer, MemorySegment or byte array)\n+     *\/\n+    public interface Adapter<M> {\n+\n+        \/**\n+         * {@return a byte from the provided {@code  memory} at the provided {@code offset}}.\n+         *\n+         * @param memory the memory to read from\n+         * @param offset the offset in memory to read from\n+         * @throws RuntimeException if the provided offset is out of bounds or, depending on the memory\n+         *                          abstraction, for other reasons. The type of exception depends on the underlying\n+         *                          memory.\n+         *\/\n+        byte get(M memory, long offset);\n+\n+        \/**\n+         * {@return the length of this memory abstraction}\n+         *\n+         * @param memory the memory to read from\n+         *\/\n+        long length(M memory);\n+\n+        \/**\n+         * {@return a {@code MemoryAdapter<MemorySegment> } that reads byte values from a {@link MemorySegment}}\n+         *\/\n+        static Adapter<MemorySegment> ofMemorySegment() {\n+            return MEMORY_SEGMENT_MEMORY_ADAPTER;\n+        }\n+\n+        \/**\n+         * {@return a {@code MemoryAdapter<ByteBuffer> } that reads byte values from a {@link ByteBuffer}}\n+         *\/\n+        static Adapter<ByteBuffer> ofByteBuffer() {\n+            return BYTE_BUFFER_MEMORY_ADAPTER;\n+        }\n+\n+        \/**\n+         * {@return a {@code MemoryAdapter<byte[]> } that reads byte values from a byte array}\n+         *\/\n+        static Adapter<byte[]> ofByteArray() {\n+            return BYTE_ARRAY_MEMORY_ADAPTER;\n+        }\n+\n+    }\n+\n+    \/**\n+     * An interface that can be used to specify custom rendering of value\n+     * layouts via the {@link MemorySegment#toString(MemoryLayout, ValueLayoutRenderer)} method.\n+     * <p>\n+     * The render methods take two parameters:\n+     * <ul>\n+     *     <li>layout: This can be used to select different formatting for different paths<\/li>\n+     *     <li>value: The actual value<\/li>\n+     * <\/ul>\n+     * <p>\n+     * The {@linkplain ValueLayoutRenderer#standard() standard() } value layout renderer is path\n+     * agnostic and will thus render all layouts of the same type the same way.\n+     *\n+     * @see MemorySegment#toString(MemoryLayout, ValueLayoutRenderer)\n+     *\/\n+    public interface ValueLayoutRenderer {\n+        \/**\n+         * Renders the provided {@code layout} and {@code value} to a String.\n+         *\n+         * @param layout the layout to render\n+         * @param value  the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfBoolean layout, boolean value) {\n+            requireNonNull(layout);\n+            return Boolean.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code layout} and {@code value} to a String.\n+         *\n+         * @param layout the layout to render\n+         * @param value  the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfByte layout, byte value) {\n+            requireNonNull(layout);\n+            return Byte.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code layout} and {@code value} to a String.\n+         *\n+         * @param layout the layout to render\n+         * @param value  the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfChar layout, char value) {\n+            requireNonNull(layout);\n+            return Character.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code layout} and {@code value} to a String.\n+         *\n+         * @param layout the layout to render\n+         * @param value  the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfShort layout, short value) {\n+            requireNonNull(layout);\n+            return Short.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code layout} and {@code value} to a String.\n+         *\n+         * @param layout the layout to render\n+         * @param value  the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfInt layout, int value) {\n+            requireNonNull(layout);\n+            return Integer.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code layout} and {@code value} to a String.\n+         *\n+         * @param layout the layout to render\n+         * @param value  the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfLong layout, long value) {\n+            requireNonNull(layout);\n+            return Long.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code layout} and {@code value} to a String.\n+         *\n+         * @param layout the layout to render\n+         * @param value  the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfFloat layout, float value) {\n+            requireNonNull(layout);\n+            return Float.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code layout} and {@code value} to a String.\n+         *\n+         * @param layout the layout to render\n+         * @param value  the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfDouble layout, double value) {\n+            requireNonNull(layout);\n+            return Double.toString(value);\n+        }\n+\n+        \/**\n+         * Renders the provided {@code layout} and {@code value} to a String.\n+         *\n+         * @param layout the layout to render\n+         * @param value  the value to render\n+         * @return rendered String\n+         *\/\n+        default String render(ValueLayout.OfAddress layout, MemorySegment value) {\n+            requireNonNull(layout);\n+            return String.format(\"0x%0\" + (ValueLayout.ADDRESS.byteSize() * 2) + \"X\", value.address());\n+        }\n+\n+        \/**\n+         * {@return a standard value layout renderer that will render numeric values into decimal form and where\n+         * other value types are rendered to a reasonable \"natural\" form}\n+         * <p>\n+         * More specifically, values types are rendered as follows:\n+         * <ul>\n+         *     <li>Numeric values are rendered in decimal form (e.g 1 or 1.2).<\/li>\n+         *     <li>Boolean values are rendered as {@code true} or {@code false}.<\/li>\n+         *     <li>Character values are rendered as {@code char}.<\/li>\n+         *     <li>Address values are rendered in hexadecimal form e.g. {@code 0x0000000000000000} (on 64-bit platforms) or\n+         *     {@code 0x00000000} (on 32-bit platforms)<\/li>\n+         * <\/ul>\n+         *\/\n+        static ValueLayoutRenderer standard() {\n+            return STANDARD_VALUE_LAYOUT_RENDERER;\n+        }\n+\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryInspection.java","additions":333,"deletions":0,"binary":false,"changes":333,"status":"added"},{"patch":"@@ -41,1 +41,0 @@\n-import java.util.function.Function;\n@@ -54,1 +53,0 @@\n-import static jdk.internal.foreign.MemorySegmentRenderUtil.STANDARD_VALUE_LAYOUT_RENDERER;\n@@ -1905,1 +1903,1 @@\n-     *   System.out.println(memorySegment.toString(layout, ValueLayoutRenderer.standard()));\n+     *   System.out.println(memorySegment.toString(layout, MemoryInspection.ValueLayoutRenderer.standard()));\n@@ -1916,1 +1914,1 @@\n-     * @param renderer to apply when formatting value layouts. {@link ValueLayoutRenderer#standard()} can\n+     * @param renderer to apply when formatting value layouts. {@link MemoryInspection.ValueLayoutRenderer#standard()} can\n@@ -1921,2 +1919,2 @@\n-     * @see ValueLayoutRenderer\n-     * @see ValueLayoutRenderer#standard()\n+     * @see MemoryInspection.ValueLayoutRenderer\n+     * @see MemoryInspection.ValueLayoutRenderer#standard()\n@@ -1924,1 +1922,1 @@\n-    default String toString(MemoryLayout layout, ValueLayoutRenderer renderer) {\n+    default String toString(MemoryLayout layout, MemoryInspection.ValueLayoutRenderer renderer) {\n@@ -2159,141 +2157,0 @@\n-    \/**\n-     * An interface that can be used to specify custom rendering of value\n-     * layouts via the {@link MemorySegment#toString(MemoryLayout, ValueLayoutRenderer)} method.\n-     * <p>\n-     * The render methods take two parameters:\n-     * <ul>\n-     *     <li>layout: This can be used to select different formatting for different paths<\/li>\n-     *     <li>value: The actual value<\/li>\n-     * <\/ul>\n-     * <p>\n-     * The {@linkplain ValueLayoutRenderer#standard() standard() } value layout renderer is path\n-     * agnostic and will thus render all layouts of the same type the same way.\n-     * @see MemorySegment#toString(MemoryLayout, ValueLayoutRenderer)\n-     *\/\n-    interface ValueLayoutRenderer {\n-        \/**\n-         * Renders the provided {@code layout} and {@code value} to a String.\n-         *\n-         * @param layout the layout to render\n-         * @param value  the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfBoolean layout, boolean value) {\n-            Objects.requireNonNull(layout);\n-            return Boolean.toString(value);\n-        }\n-\n-        \/**\n-         * Renders the provided {@code layout} and {@code value} to a String.\n-         *\n-         * @param layout the layout to render\n-         * @param value  the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfByte layout, byte value) {\n-            Objects.requireNonNull(layout);\n-            return Byte.toString(value);\n-        }\n-\n-        \/**\n-         * Renders the provided {@code layout} and {@code value} to a String.\n-         *\n-         * @param layout the layout to render\n-         * @param value  the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfChar layout, char value) {\n-            Objects.requireNonNull(layout);\n-            return Character.toString(value);\n-        }\n-\n-        \/**\n-         * Renders the provided {@code layout} and {@code value} to a String.\n-         *\n-         * @param layout the layout to render\n-         * @param value  the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfShort layout, short value) {\n-            Objects.requireNonNull(layout);\n-            return Short.toString(value);\n-        }\n-\n-        \/**\n-         * Renders the provided {@code layout} and {@code value} to a String.\n-         *\n-         * @param layout the layout to render\n-         * @param value  the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfInt layout, int value) {\n-            Objects.requireNonNull(layout);\n-            return Integer.toString(value);\n-        }\n-\n-        \/**\n-         * Renders the provided {@code layout} and {@code value} to a String.\n-         *\n-         * @param layout the layout to render\n-         * @param value  the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfLong layout, long value) {\n-            Objects.requireNonNull(layout);\n-            return Long.toString(value);\n-        }\n-\n-        \/**\n-         * Renders the provided {@code layout} and {@code value} to a String.\n-         *\n-         * @param layout the layout to render\n-         * @param value  the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfFloat layout, float value) {\n-            Objects.requireNonNull(layout);\n-            return Float.toString(value);\n-        }\n-\n-        \/**\n-         * Renders the provided {@code layout} and {@code value} to a String.\n-         *\n-         * @param layout the layout to render\n-         * @param value  the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfDouble layout, double value) {\n-            Objects.requireNonNull(layout);\n-            return Double.toString(value);\n-        }\n-\n-        \/**\n-         * Renders the provided {@code layout} and {@code value} to a String.\n-         *\n-         * @param layout the layout to render\n-         * @param value  the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfAddress layout, MemorySegment value) {\n-            Objects.requireNonNull(layout);\n-            return String.format(\"0x%0\" + (ValueLayout.ADDRESS.byteSize() * 2) + \"X\", value.address());\n-        }\n-\n-        \/**\n-         * {@return a standard value layout renderer that will render numeric values into decimal form and where\n-         * other value types are rendered to a reasonable \"natural\" form}\n-         * <p>\n-         * More specifically, values types are rendered as follows:\n-         * <ul>\n-         *     <li>Numeric values are rendered in decimal form (e.g 1 or 1.2).<\/li>\n-         *     <li>Boolean values are rendered as {@code true} or {@code false}.<\/li>\n-         *     <li>Character values are rendered as {@code char}.<\/li>\n-         *     <li>Address values are rendered in hexadecimal form e.g. {@code 0x0000000000000000} (on 64-bit platforms) or\n-         *     {@code 0x00000000} (on 32-bit platforms)<\/li>\n-         * <\/ul>\n-         *\/\n-        static ValueLayoutRenderer standard() {\n-            return STANDARD_VALUE_LAYOUT_RENDERER;\n-        }\n-\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":5,"deletions":148,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.function.Function;\n@@ -35,0 +34,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n@@ -47,1 +47,1 @@\n-    private static final int HEX_STREAM_BYTES_PER_ROW = 1 << 4; \/\/ Should be a power of 2\n+    private static final int HEX_STREAM_BYTES_PER_ROW = 16; \/\/ Must be a power of 2 and is 16 by convention\n@@ -49,4 +49,4 @@\n-\n-    private static final String ADDRESS_FORMATTING = \"0x%0\" + (ValueLayout.ADDRESS.byteSize() * 2) + \"X\";\n-\n-    public static final MemorySegment.ValueLayoutRenderer STANDARD_VALUE_LAYOUT_RENDERER = new StandardValueLayoutRenderer();\n+    public static final MemoryInspection.ValueLayoutRenderer STANDARD_VALUE_LAYOUT_RENDERER = new StandardValueLayoutRenderer();\n+    public static final MemoryInspection.Adapter<MemorySegment> MEMORY_SEGMENT_MEMORY_ADAPTER = new MemorySegmentMemoryAdapter();\n+    public static final MemoryInspection.Adapter<ByteBuffer> BYTE_BUFFER_MEMORY_ADAPTER = new ByteBufferMemoryAdapter();\n+    public static final MemoryInspection.Adapter<byte[]> BYTE_ARRAY_MEMORY_ADAPTER = new ByteArrayMemoryAdapter();\n@@ -58,1 +58,1 @@\n-     * Returns a Stream of human-readable, lines with hexadecimal values for this memory segment.\n+     * Returns a Stream of human-readable, lines with hexadecimal values for this memory memory.\n@@ -79,1 +79,1 @@\n-     * As an example, a memory segment created, initialized and used as follows\n+     * As an example, a memory memory created, initialized and used as follows\n@@ -81,3 +81,3 @@\n-     *   MemorySegment segment = memorySession.allocate(64 + 4);\n-     *   segment.setUtf8String(0, \"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\");\n-     *   segment.hexDump()\n+     *   MemorySegment memory = memorySession.allocate(64 + 4);\n+     *   memory.setUtf8String(0, \"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\");\n+     *   memory.hexDump()\n@@ -96,1 +96,1 @@\n-     * of a memory segment.\n+     * of a memory memory.\n@@ -106,1 +106,1 @@\n-     * @param segment to inspect\n+     * @param memory to inspect\n@@ -108,0 +108,2 @@\n+     * @throws RuntimeException depending on the provided extractors whose exceptions will be relayed to the\n+     *                          call site.\n@@ -109,2 +111,5 @@\n-    public static Stream<String> hexDump(MemorySegment segment) {\n-        requireNonNull(segment);\n+    public static <M> Stream<String> hexDump(M memory,\n+                                             MemoryInspection.Adapter<M> adapter) {\n+        requireNonNull(memory);\n+        requireNonNull(adapter);\n+\n@@ -114,1 +119,2 @@\n-        return LongStream.range(0, segment.byteSize())\n+        final long lastIndex = adapter.length(memory);\n+        return LongStream.range(0, lastIndex)\n@@ -125,1 +131,1 @@\n-                    state.appendValue(segment.get(ValueLayout.JAVA_BYTE, index));\n+                    state.appendValue(adapter.get(memory, index));\n@@ -127,1 +133,1 @@\n-                    if (nextCnt % HEX_STREAM_BYTES_PER_ROW == 0 || nextCnt == segment.byteSize()) {\n+                    if (nextCnt % HEX_STREAM_BYTES_PER_ROW == 0 || nextCnt == lastIndex) {\n@@ -171,1 +177,1 @@\n-                                  MemorySegment.ValueLayoutRenderer renderer) {\n+                                  MemoryInspection.ValueLayoutRenderer renderer) {\n@@ -189,1 +195,1 @@\n-                                 MemorySegment.ValueLayoutRenderer renderer,\n+                                 MemoryInspection.ValueLayoutRenderer renderer,\n@@ -404,1 +410,18 @@\n-    private static final class StandardValueLayoutRenderer implements MemorySegment.ValueLayoutRenderer {\n+    private static final class StandardValueLayoutRenderer implements MemoryInspection.ValueLayoutRenderer {\n+        @Override\n+        public String toString() {\n+            return singletonToString(StandardValueLayoutRenderer.class);\n+        }\n+    }\n+\n+    private static final class MemorySegmentMemoryAdapter implements MemoryInspection.Adapter<MemorySegment> {\n+        @Override\n+        public byte get(MemorySegment memorySegment, long offset) {\n+            return memorySegment.get(JAVA_BYTE, offset);\n+        }\n+\n+        @Override\n+        public long length(MemorySegment memorySegment) {\n+            return memorySegment.byteSize();\n+        }\n+\n@@ -407,1 +430,1 @@\n-            return StandardValueLayoutRenderer.class.getSimpleName();\n+            return singletonToString(MemorySegmentMemoryAdapter.class);\n@@ -411,0 +434,38 @@\n+    private static final class ByteBufferMemoryAdapter implements MemoryInspection.Adapter<ByteBuffer> {\n+        @Override\n+        public byte get(ByteBuffer byteBuffer, long offset) {\n+            return byteBuffer.get(Math.toIntExact(offset));\n+        }\n+\n+        @Override\n+        public long length(ByteBuffer byteBuffer) {\n+            return byteBuffer.remaining();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return singletonToString(ByteBufferMemoryAdapter.class);\n+        }\n+    }\n+\n+    private static final class ByteArrayMemoryAdapter implements MemoryInspection.Adapter<byte[]> {\n+\n+        @Override\n+        public byte get(byte[] byteArray, long offset) {\n+            return byteArray[Math.toIntExact(offset)];\n+        }\n+\n+        @Override\n+        public long length(byte[] byteArray) {\n+            return byteArray.length;\n+        }\n+        @Override\n+        public String toString() {\n+            return singletonToString(ByteArrayMemoryAdapter.class);\n+        }\n+    }\n+\n+    private static String singletonToString(Class<?> implementingClass) {\n+        return \"The \" + implementingClass.getName() + \" singleton\";\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySegmentRenderUtil.java","additions":83,"deletions":22,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-            return hexDump(segment)\n+            return hexDump(segment, MemoryInspection.Adapter.ofMemorySegment())\n@@ -78,1 +78,1 @@\n-        var array = new byte[HEX_SEGMENT_SIZE];\n+        final byte[] array = new byte[HEX_SEGMENT_SIZE];\n@@ -80,1 +80,1 @@\n-        var actual = hexDump(MemorySegment.ofArray(array))\n+        var actual = hexDump(array, MemoryInspection.Adapter.ofByteArray())\n@@ -91,1 +91,2 @@\n-        var actual = hexDump(MemorySegment.ofBuffer(ByteBuffer.wrap(array)))\n+        var bb = ByteBuffer.wrap(array);\n+        var actual = hexDump(bb, MemoryInspection.Adapter.ofByteBuffer())\n@@ -118,1 +119,1 @@\n-            var actual = testWithFreshMemorySegment(ti.layout().byteSize(), s -> MemorySegmentRenderUtil.toString(s, ti.layout(), MemorySegment.ValueLayoutRenderer.standard()));\n+            var actual = testWithFreshMemorySegment(ti.layout().byteSize(), s -> MemorySegmentRenderUtil.toString(s, ti.layout(), MemoryInspection.ValueLayoutRenderer.standard()));\n@@ -148,1 +149,1 @@\n-            var actual = MemorySegmentRenderUtil.hexDump(segment)\n+            var actual = MemorySegmentRenderUtil.hexDump(segment, MemoryInspection.Adapter.ofMemorySegment())\n@@ -161,1 +162,1 @@\n-            MemorySegmentRenderUtil.hexDump(segment)\n+            MemorySegmentRenderUtil.hexDump(segment, MemoryInspection.Adapter.ofMemorySegment())\n@@ -179,1 +180,1 @@\n-            return MemorySegmentRenderUtil.toString(segment, Point.LAYOUT, MemorySegment.ValueLayoutRenderer.standard());\n+            return MemorySegmentRenderUtil.toString(segment, Point.LAYOUT, MemoryInspection.ValueLayoutRenderer.standard());\n@@ -198,1 +199,1 @@\n-            return MemorySegmentRenderUtil.toString(segment, Point.LAYOUT, new MemorySegment.ValueLayoutRenderer() {\n+            return MemorySegmentRenderUtil.toString(segment, Point.LAYOUT, new MemoryInspection.ValueLayoutRenderer() {\n@@ -246,1 +247,1 @@\n-                MemorySegmentRenderUtil.toString(segment, layout, MemorySegment.ValueLayoutRenderer.standard()));\n+                MemorySegmentRenderUtil.toString(segment, layout, MemoryInspection.ValueLayoutRenderer.standard()));\n@@ -282,1 +283,1 @@\n-                MemorySegmentRenderUtil.toString(segment, sequenceLayout, MemorySegment.ValueLayoutRenderer.standard()));\n+                MemorySegmentRenderUtil.toString(segment, sequenceLayout, MemoryInspection.ValueLayoutRenderer.standard()));\n@@ -318,1 +319,1 @@\n-                MemorySegmentRenderUtil.toString(segment, union, MemorySegment.ValueLayoutRenderer.standard()));\n+                MemorySegmentRenderUtil.toString(segment, union, MemoryInspection.ValueLayoutRenderer.standard()));\n","filename":"test\/jdk\/java\/foreign\/RenderTest.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"}]}