{"files":[{"patch":"@@ -1,210 +0,0 @@\n-package java.lang.foreign;\n-\n-import jdk.internal.foreign.MemoryInspectionUtil;\n-\n-import java.nio.Buffer;\n-import java.util.stream.Stream;\n-\n-import static java.util.Objects.requireNonNull;\n-import static jdk.internal.foreign.MemoryInspectionUtil.*;\n-\n-\/**\n- * Class that supports inspection of MemorySegments through MemoryLayouts.\n- * <p>\n- * Memory abstractions such as ByteBuffers and byte arrays can be inspected via wrapping methods\n- * such as {@link MemorySegment#ofArray(byte[])} and {@link MemorySegment#ofBuffer(Buffer)}.\n- *\n- * @author Per Minborg\n- * @since 20\n- *\/\n-public final class MemoryInspection {\n-\n-    \/\/ Suppresses default constructor, ensuring non-instantiability.\n-    private MemoryInspection() {\n-    }\n-\n-    \/**\n-     * Returns a human-readable view of the provided {@linkplain MemorySegment memory} viewed\n-     * through the provided {@code layout} using the provided {@linkplain ValueLayoutRenderer renderer}.\n-     * <p>\n-     * The exact format of the returned view is unspecified and should not\n-     * be acted upon programmatically.\n-     * <p>\n-     * As an example, a MemorySegment viewed though the following memory layout\n-     * {@snippet lang = java:\n-     * var layout = MemoryLayout.structLayout(\n-     *         ValueLayout.JAVA_INT.withName(\"x\"),\n-     *         ValueLayout.JAVA_INT.withName(\"y\")\n-     * ).withName(\"Point\");\n-     *\n-     * MemoryInspection.inspect(segment, layout, ValueLayoutRenderer.standard())\n-     *     .forEach(System.out::println);\n-     *\n-     *}\n-     * might be rendered to something like this:\n-     * {@snippet lang = text:\n-     * Point {\n-     *   x=1,\n-     *   y=2\n-     * }\n-     *}\n-     * <p>\n-     * This method is intended to view memory segments through small and medium-sized memory layouts.\n-     *\n-     * @param segment  to be viewed\n-     * @param layout   to use as a layout when viewing the memory segment\n-     * @param renderer to apply when rendering value layouts\n-     * @return a view of the memory abstraction viewed through the memory layout\n-     *\/\n-    public static Stream<String> inspect(MemorySegment segment,\n-                                         MemoryLayout layout,\n-                                         ValueLayoutRenderer renderer) {\n-        requireNonNull(segment);\n-        requireNonNull(layout);\n-        requireNonNull(renderer);\n-        return MemoryInspectionUtil.inspect(segment, layout, renderer);\n-    }\n-\n-    \/**\n-     * An interface that can be used to specify custom rendering of value\n-     * layouts via the {@link MemoryInspection#inspect(MemorySegment, MemoryLayout, ValueLayoutRenderer)} method.\n-     * <p>\n-     * The render methods take two parameters:\n-     * <ul>\n-     *     <li>layout: This can be used to select different formatting for different paths<\/li>\n-     *     <li>value: The actual value<\/li>\n-     * <\/ul>\n-     * <p>\n-     * The {@linkplain ValueLayoutRenderer#standard() standard() } value layout renderer is path\n-     * agnostic and will thus render all layouts of the same type the same way.\n-     *\n-     * @see MemoryInspection#inspect(MemorySegment, MemoryLayout, ValueLayoutRenderer)\n-     *\/\n-    public interface ValueLayoutRenderer {\n-        \/**\n-         * Renders the provided {@code booleanLayout} and {@code value} to a String.\n-         *\n-         * @param booleanLayout the layout to render\n-         * @param value         the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfBoolean booleanLayout, boolean value) {\n-            requireNonNull(booleanLayout);\n-            return Boolean.toString(value);\n-        }\n-\n-        \/**\n-         * Renders the provided {@code booleanLayout} and {@code value} to a String.\n-         *\n-         * @param booleanLayout the layout to render\n-         * @param value         the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfByte booleanLayout, byte value) {\n-            requireNonNull(booleanLayout);\n-            return Byte.toString(value);\n-        }\n-\n-        \/**\n-         * Renders the provided {@code charLayout} and {@code value} to a String.\n-         *\n-         * @param charLayout the layout to render\n-         * @param value      the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfChar charLayout, char value) {\n-            requireNonNull(charLayout);\n-            return Character.toString(value);\n-        }\n-\n-        \/**\n-         * Renders the provided {@code sortLayout} and {@code value} to a String.\n-         *\n-         * @param sortLayout the layout to render\n-         * @param value      the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfShort sortLayout, short value) {\n-            requireNonNull(sortLayout);\n-            return Short.toString(value);\n-        }\n-\n-        \/**\n-         * Renders the provided {@code intLayout} and {@code value} to a String.\n-         *\n-         * @param intLayout the layout to render\n-         * @param value     the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfInt intLayout, int value) {\n-            requireNonNull(intLayout);\n-            return Integer.toString(value);\n-        }\n-\n-        \/**\n-         * Renders the provided {@code longLayout} and {@code value} to a String.\n-         *\n-         * @param longLayout the layout to render\n-         * @param value      the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfLong longLayout, long value) {\n-            requireNonNull(longLayout);\n-            return Long.toString(value);\n-        }\n-\n-        \/**\n-         * Renders the provided {@code floatLayout} and {@code value} to a String.\n-         *\n-         * @param floatLayout the layout to render\n-         * @param value       the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfFloat floatLayout, float value) {\n-            requireNonNull(floatLayout);\n-            return Float.toString(value);\n-        }\n-\n-        \/**\n-         * Renders the provided {@code doubleLayout} and {@code value} to a String.\n-         *\n-         * @param doubleLayout the layout to render\n-         * @param value        the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfDouble doubleLayout, double value) {\n-            requireNonNull(doubleLayout);\n-            return Double.toString(value);\n-        }\n-\n-        \/**\n-         * Renders the provided {@code addressLayout} and {@code value} to a String.\n-         *\n-         * @param addressLayout the layout to render\n-         * @param value         the value to render\n-         * @return rendered String\n-         *\/\n-        default String render(ValueLayout.OfAddress addressLayout, MemorySegment value) {\n-            requireNonNull(addressLayout);\n-            return String.format(\"0x%0\" + (ValueLayout.ADDRESS.byteSize() * 2) + \"X\", value.address());\n-        }\n-\n-        \/**\n-         * {@return a standard value layout renderer that will render numeric values into decimal form and where\n-         * other value types are rendered to a reasonable \"natural\" form}\n-         * <p>\n-         * More specifically, values types are rendered as follows:\n-         * <ul>\n-         *     <li>Numeric values are rendered in decimal form (e.g 1 or 1.2).<\/li>\n-         *     <li>Boolean values are rendered as {@code true} or {@code false}.<\/li>\n-         *     <li>Character values are rendered as {@code char}.<\/li>\n-         *     <li>Address values are rendered in hexadecimal form e.g. {@code 0x0000000000000000} (on 64-bit platforms) or\n-         *     {@code 0x00000000} (on 32-bit platforms)<\/li>\n-         * <\/ul>\n-         *\/\n-        static ValueLayoutRenderer standard() {\n-            return STANDARD_VALUE_LAYOUT_RENDERER;\n-        }\n-\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryInspection.java","additions":0,"deletions":210,"binary":false,"changes":210,"status":"deleted"},{"patch":"@@ -1161,1 +1161,1 @@\n-     * A class providing various memory abstractions (such as MemorySegments and byte arrays) to be dumped into\n+     * A class allowing various memory abstractions (such as MemorySegments and byte arrays) to be dumped into\n@@ -1170,1 +1170,1 @@\n-         * Returns a Stream of string elements with values for the provided {@code memory} byte array.\n+         * Returns a Stream of string elements with values for the provided {@code bytes} array.\n@@ -1177,1 +1177,2 @@\n-         *   MemoryDumper.builder()\n+         *\n+         *   MemoryDumper dumper = MemoryDumper.builder()\n@@ -1183,2 +1184,3 @@\n-         *      .build()\n-         *      .dump(bytes)\n+         *      .build();\n+         *\n+         *   dumper.dump(bytes)\n@@ -1201,1 +1203,1 @@\n-         * Returns a Stream of string elements with values for the provided {@code memory} byte array staring\n+         * Returns a Stream of string elements with values for the provided {@code bytes} array staring\n@@ -1209,1 +1211,2 @@\n-         *   MemoryDumper.builder()\n+         *\n+         *   MemoryDumper dumper = MemoryDumper.builder()\n@@ -1215,2 +1218,3 @@\n-         *      .build()\n-         *      .dump(bytes, 0, 16)\n+         *      .build();\n+         *\n+         *   dumper.dump(bytes, 0, 16)\n@@ -1246,5 +1250,5 @@\n-         *    try (MemorySession session = MemorySession.openConfined()) {\n-         *       MemorySegment segment = session.allocateUtf8String(\"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\");\n-         *      dumper.dump(bytes)\n-         *          .forEach(System.out::println);\n-         *    }\n+         * try (MemorySession session = MemorySession.openConfined()) {\n+         *     MemorySegment segment = session.allocateUtf8String(\"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\");\n+         *     dumper.dump(bytes)\n+         *         .forEach(System.out::println);\n+         * }\n@@ -1265,1 +1269,0 @@\n-\n@@ -1311,5 +1314,5 @@\n-         *    try (MemorySession session = MemorySession.openConfined()) {\n-         *       MemorySegment segment = session.allocateUtf8String(\"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\");\n-         *      dumper.dump(bytes)\n-         *          .forEach(System.out::println);\n-         *    }\n+         * try (MemorySession session = MemorySession.openConfined()) {\n+         *     MemorySegment segment = session.allocateUtf8String(\"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\");\n+         *     dumper.dump(bytes)\n+         *         .forEach(System.out::println);\n+         * }\n@@ -1337,1 +1340,1 @@\n-             * Configures the number of bytes per line in.\n+             * Configures the number of bytes per line rendered per element in the output Stream.\n@@ -1343,1 +1346,1 @@\n-             * @throws IllegalArgumentException if the provided {@code bytes} are negative\n+             * @throws IllegalArgumentException if the provided {@code bytesPerLine} is negative\n@@ -1382,1 +1385,1 @@\n-             * Adds an index column with 8 bytes (64-bit) index with hexadecimal values formatted by\n+             * Adds an index column with an 8-byte (64-bit) index with hexadecimal values formatted by\n@@ -1390,1 +1393,1 @@\n-             * Adds an index column with the provided {@code  bytes} index with hexadecimal values formatted by\n+             * Adds an index column with the provided {@code indexBytes} index with hexadecimal values formatted by\n@@ -1393,1 +1396,1 @@\n-             * @param bytes the number of bytes to render in the index (in the range [1, 8])\n+             * @param indexBytes the number of bytes to render in the index (in the range [1, 8])\n@@ -1397,1 +1400,1 @@\n-            Builder addIndexColumn(int bytes);\n+            Builder addIndexColumn(int indexBytes);\n@@ -1400,1 +1403,1 @@\n-             * Adds an index column with the provided {@code  bytes} index with hexadecimal values formatted by\n+             * Adds an index column with the provided {@code indexBytes} index with hexadecimal values formatted by\n@@ -1403,2 +1406,2 @@\n-             * @param bytes     the number of bytes to render in the index (in the range [1, 8])\n-             * @param formatter the formatter to use for byte values in the index\n+             * @param indexBytes the number of bytes to render in the index (in the range [1, 8])\n+             * @param formatter  the formatter to use for byte values in the index\n@@ -1409,1 +1412,1 @@\n-            Builder addIndexColumn(int bytes, HexFormat formatter);\n+            Builder addIndexColumn(int indexBytes, HexFormat formatter);\n@@ -1412,1 +1415,1 @@\n-             * Adds an index column with the provided {@code  bytes} index with hexadecimal values formatted by\n+             * Adds an index column with the provided {@code indexBytes} index with hexadecimal values formatted by\n@@ -1418,2 +1421,2 @@\n-             * @param bytes    the number of bytes to render in the index (in the range [1, 8])\n-             * @param renderer the renderer to use for byte values in the index\n+             * @param indexBytes the number of bytes to render in the index (in the range [1, 8])\n+             * @param renderer   the renderer to use for byte values in the index\n@@ -1424,1 +1427,1 @@\n-            Builder addIndexColumn(int bytes, ColumnRenderer renderer);\n+            Builder addIndexColumn(int indexBytes, ColumnRenderer renderer);\n@@ -1460,2 +1463,1 @@\n-             * Represents a function that accepts a long index and a byte value and produces a CharSequence such\n-             * as a String.\n+             * Represents a function that accepts a long index and a byte value and produces a String.\n@@ -1469,1 +1471,1 @@\n-                 * {@return a rendering of the provided {@code bytes} with the provided {@code BytesPerLine} }\n+                 * {@return a rendering of the provided {@code bytes} with the provided {@code bytesPerLine} }\n@@ -1589,3 +1591,3 @@\n-        public MemoryDumper.Builder addIndexColumn(int bytes) {\n-            requireBetweenClosed(1, 8, bytes);\n-            return addIndexColumn(bytes, HexFormat.of());\n+        public MemoryDumper.Builder addIndexColumn(int indexBytes) {\n+            requireBetweenClosed(1, 8, indexBytes);\n+            return addIndexColumn(indexBytes, HexFormat.of());\n@@ -1595,2 +1597,2 @@\n-        public MemoryDumper.Builder addIndexColumn(int bytes, HexFormat formatter) {\n-            requireBetweenClosed(1, 8, bytes);\n+        public MemoryDumper.Builder addIndexColumn(int indexBytes, HexFormat formatter) {\n+            requireBetweenClosed(1, 8, indexBytes);\n@@ -1598,1 +1600,1 @@\n-            return addIndexColumn(bytes, ColumnRenderer.of(formatter));\n+            return addIndexColumn(indexBytes, ColumnRenderer.of(formatter));\n@@ -1602,2 +1604,2 @@\n-        public MemoryDumper.Builder addIndexColumn(int bytes, ColumnRenderer renderer) {\n-            requireBetweenClosed(1, 8, bytes);\n+        public MemoryDumper.Builder addIndexColumn(int indexBytes, ColumnRenderer renderer) {\n+            requireBetweenClosed(1, 8, indexBytes);\n@@ -1605,1 +1607,1 @@\n-            columns.add(new Column(ColumnType.INDEX, OptionalInt.of(bytes), columnPrefix, renderer, columnSuffix, columnDelimiter));\n+            columns.add(new Column(ColumnType.INDEX, OptionalInt.of(indexBytes), columnPrefix, renderer, columnSuffix, columnDelimiter));\n@@ -1669,1 +1671,0 @@\n-\n@@ -1713,1 +1714,1 @@\n-            final var state = new DumpState<>(memory, lastIndex, byteExtractor, bytesPerLine, columns, lines);\n+            final var state = new DumpState<>(memory, lastIndex, byteExtractor, bytesPerLine, columns);\n@@ -1739,1 +1740,0 @@\n-        private final long lines;\n@@ -1745,2 +1745,1 @@\n-                  List<StandardMemoryDumperBuilder.Column> columns,\n-                  long lines) {\n+                  List<StandardMemoryDumperBuilder.Column> columns) {\n@@ -1752,1 +1751,0 @@\n-            this.lines = lines;\n@@ -1800,4 +1798,0 @@\n-        long lastIndex() {\n-            return lastIndex;\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/HexFormat.java","additions":50,"deletions":56,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -1,279 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package jdk.internal.foreign;\n-\n-import java.lang.foreign.*;\n-import java.nio.ByteBuffer;\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import java.util.stream.IntStream;\n-import java.util.stream.LongStream;\n-import java.util.stream.Stream;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.util.Objects.requireNonNull;\n-\n-\/**\n- * Internal class to support inspection of memory abstractions like MemorySegments into various formats.\n- *\/\n-public final class MemoryInspectionUtil {\n-\n-    public static final MemoryInspection.ValueLayoutRenderer STANDARD_VALUE_LAYOUT_RENDERER = new StandardValueLayoutRenderer();\n-\n-    private MemoryInspectionUtil() {\n-    }\n-\n-    \/**\n-     * Returns a human-readable view of the provided {@code segment} viewed through\n-     * the provided {@code layout}.\n-     * <p>\n-     * Lines are separated with the system-dependent line separator {@link System#lineSeparator() }.\n-     * Otherwise, the exact format of the returned view is unspecified and should not\n-     * be acted upon programmatically.\n-     * <p>\n-     * As an example, a MemorySegment viewed though the following memory layout\n-     * {@snippet lang = java:\n-     * var layout = MemoryLayout.structLayout(\n-     *         ValueLayout.JAVA_INT.withName(\"x\"),\n-     *         ValueLayout.JAVA_INT.withName(\"y\")\n-     * ).withName(\"Point\");\n-     *}\n-     * might be rendered to something like this:\n-     * {@snippet lang = text:\n-     * Point {\n-     *   x=1,\n-     *   y=2\n-     * }\n-     *}\n-     * <p>\n-     * This method is intended to view memory segments through small and medium-sized memory layouts\n-     * and is, in all cases, restricted by the inherent String capacity limit.\n-     *\n-     * @param segment to be viewed\n-     * @param layout  to use as a layout when viewing the memory segment\n-     * @return a view of the memory segment viewed through the memory layout\n-     * @throws OutOfMemoryError if the view exceeds the array size VM limit\n-     *\/\n-    private static String toString(MemorySegment segment,\n-                                  MemoryLayout layout,\n-                                  MemoryInspection.ValueLayoutRenderer renderer) {\n-        requireNonNull(segment);\n-        requireNonNull(layout);\n-        requireNonNull(renderer);\n-\n-        final var sb = new StringBuilder();\n-        final Consumer<String> action = line -> {\n-            if (!sb.isEmpty()) {\n-                sb.append(System.lineSeparator());\n-            }\n-            sb.append(line);\n-        };\n-        toString0(segment, layout, renderer, action, new ViewState(), \"\");\n-        return sb.toString();\n-    }\n-\n-    public static Stream<String> inspect(MemorySegment segment,\n-                                         MemoryLayout layout,\n-                                         MemoryInspection.ValueLayoutRenderer renderer) {\n-        requireNonNull(segment);\n-        requireNonNull(layout);\n-        requireNonNull(renderer);\n-\n-        final var builder = Stream.<String>builder();\n-        toString0(segment, layout, renderer, builder::add, new ViewState(), \"\");\n-        return builder.build();\n-    }\n-\n-    private static void toString0(MemorySegment segment,\n-                                 MemoryLayout layout,\n-                                 MemoryInspection.ValueLayoutRenderer renderer,\n-                                 Consumer<String> action,\n-                                 ViewState state,\n-                                 String suffix) {\n-\n-        \/\/ TODO: Replace with \"patterns in switch statement\" once this becomes available.\n-\n-        if (layout instanceof ValueLayout.OfBoolean ofBoolean) {\n-            action.accept(renderValueLayout(state, ofBoolean, renderer.render(ofBoolean, segment.get(ofBoolean, state.indexAndAdd(ofBoolean))), suffix));\n-            return;\n-        }\n-        if (layout instanceof ValueLayout.OfByte ofByte) {\n-            action.accept(renderValueLayout(state, ofByte, renderer.render(ofByte, segment.get(ofByte, state.indexAndAdd(ofByte))), suffix));\n-            return;\n-        }\n-        if (layout instanceof ValueLayout.OfShort ofShort) {\n-            action.accept(renderValueLayout(state, ofShort, renderer.render(ofShort, segment.get(ofShort, state.indexAndAdd(ofShort))), suffix));\n-            return;\n-        }\n-        if (layout instanceof ValueLayout.OfInt ofInt) {\n-            action.accept(renderValueLayout(state, ofInt, renderer.render(ofInt, segment.get(ofInt, state.indexAndAdd(ofInt))), suffix));\n-            return;\n-        }\n-        if (layout instanceof ValueLayout.OfLong ofLong) {\n-            action.accept(renderValueLayout(state, ofLong, renderer.render(ofLong, segment.get(ofLong, state.indexAndAdd(ofLong))), suffix));\n-            return;\n-        }\n-        if (layout instanceof ValueLayout.OfFloat ofFloat) {\n-            action.accept(renderValueLayout(state, ofFloat, renderer.render(ofFloat, segment.get(ofFloat, state.indexAndAdd(ofFloat))), suffix));\n-            return;\n-        }\n-        if (layout instanceof ValueLayout.OfDouble ofDouble) {\n-            action.accept(renderValueLayout(state, ofDouble, renderer.render(ofDouble, segment.get(ofDouble, state.indexAndAdd(ofDouble))), suffix));\n-            return;\n-        }\n-        if (layout instanceof ValueLayout.OfChar ofChar) {\n-            action.accept(renderValueLayout(state, ofChar, renderer.render(ofChar, segment.get(ofChar, state.indexAndAdd(ofChar))), suffix));\n-            return;\n-        }\n-        if (layout instanceof ValueLayout.OfAddress ofAddress) {\n-            action.accept(renderValueLayout(state, ofAddress, renderer.render(ofAddress, segment.get(ofAddress, state.indexAndAdd(ofAddress))), suffix));\n-            return;\n-        }\n-        \/\/ PaddingLayout is package private.\n-        if (layout instanceof PaddingLayout paddingLayout) {\n-            action.accept(state.indentSpaces() + paddingLayout.bitSize() + \" padding bits\");\n-            state.indexAndAdd(paddingLayout);\n-            return;\n-        }\n-        if (layout instanceof GroupLayout groupLayout) {\n-\n-            \/* Strictly, we should provide all permutations of unions.\n-             * So, if we have a union U =  (A|B),(C|D) then we should present:\n-             * (A,C), (A,D), (B,C) and (B,D)\n-             *\/\n-\n-            final var separator = groupLayout instanceof StructLayout\n-                    ? \",\"  \/\/ Struct separator\n-                    : \"|\"; \/\/ Union separator\n-\n-            action.accept(indentedLabel(state, groupLayout) + \" {\");\n-            state.incrementIndent();\n-            final var members = groupLayout.memberLayouts();\n-            final long initialIndex = state.index();\n-            long maxIndex = initialIndex;\n-            for (int i = 0; i < members.size(); i++) {\n-                if (groupLayout instanceof UnionLayout) {\n-                    \/\/ If it is a union, we need to reset the index for each member\n-                    state.index(initialIndex);\n-                    \/\/ We record the max index used for any union member so we can leave off from there\n-                    maxIndex = Math.max(maxIndex, state.index());\n-                }\n-                toString0(segment, members.get(i), renderer, action, state, (i != (members.size() - 1)) ? separator : \"\");\n-                if (groupLayout instanceof UnionLayout) {\n-                    \/\/ This is the best we can do.\n-                    state.index(maxIndex);\n-                }\n-            }\n-            state.decrementIndent();\n-            action.accept(state.indentSpaces() + \"}\" + suffix);\n-            return;\n-        }\n-        if (layout instanceof SequenceLayout sequenceLayout) {\n-            action.accept(indentedLabel(state, sequenceLayout) + \" [\");\n-            state.incrementIndent();\n-            final long elementCount = sequenceLayout.elementCount();\n-            for (long i = 0; i < elementCount; i++) {\n-                toString0(segment, sequenceLayout.elementLayout(), renderer, action, state, (i != (elementCount - 1L)) ? \",\" : \"\");\n-            }\n-            state.decrementIndent();\n-            action.accept(state.indentSpaces() + \"]\" + suffix);\n-            return;\n-        }\n-        action.accept(state.indentSpaces() + \"Unknown layout: \" + layout + \" at index \" + state.index());\n-        state.indexAndAdd(layout);\n-    }\n-\n-    static String renderValueLayout(ViewState state,\n-                                    ValueLayout layout,\n-                                    String value,\n-                                    String suffix) {\n-        return indentedLabel(state, layout) + \"=\" + value + suffix;\n-    }\n-\n-    static String indentedLabel(ViewState state,\n-                                MemoryLayout layout) {\n-        return state.indentSpaces() + layout.name()\n-                .orElseGet(layout::toString);\n-    }\n-\n-    static final class ViewState {\n-\n-        private static final int SPACES_PER_INDENT = 4;\n-\n-        \/\/ Holding a non-static indents allows simple thread-safe use\n-        private final StringBuilder indents = new StringBuilder();\n-\n-        private int indent;\n-        private long index;\n-\n-        void incrementIndent() {\n-            indent++;\n-        }\n-\n-        void decrementIndent() {\n-            indent--;\n-        }\n-\n-        String indentSpaces() {\n-            final int spaces = indent * SPACES_PER_INDENT;\n-            while (indents.length() < spaces) {\n-                \/\/ Expand as needed\n-                indents.append(\" \");\n-            }\n-            return indents.substring(0, spaces);\n-        }\n-\n-        long index() {\n-            return index;\n-        }\n-\n-        void index(long index) {\n-            this.index = index;\n-        }\n-\n-        long indexAndAdd(long delta) {\n-            final long val = index;\n-            index += delta;\n-            return val;\n-        }\n-\n-        long indexAndAdd(MemoryLayout layout) {\n-            return indexAndAdd(layout.byteSize());\n-        }\n-    }\n-\n-    private static final class StandardValueLayoutRenderer implements MemoryInspection.ValueLayoutRenderer {\n-        @Override\n-        public String toString() {\n-            return singletonToString(StandardValueLayoutRenderer.class);\n-        }\n-    }\n-\n-    private static String singletonToString(Class<?> implementingClass) {\n-        return \"The \" + implementingClass.getName() + \" singleton\";\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemoryInspectionUtil.java","additions":0,"deletions":279,"binary":false,"changes":279,"status":"deleted"},{"patch":"@@ -1,290 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @modules java.base\/jdk.internal.foreign\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestMemoryInspection\n- *\/\n-\n-import java.lang.foreign.*;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteBuffer;\n-import java.nio.charset.StandardCharsets;\n-import java.util.List;\n-import java.util.function.Function;\n-import java.util.stream.Stream;\n-\n-import jdk.internal.foreign.MemoryInspectionUtil;\n-import org.testng.annotations.*;\n-\n-import static java.lang.foreign.ValueLayout.*;\n-import static java.util.stream.Collectors.joining;\n-import static org.testng.Assert.*;\n-import static jdk.internal.foreign.MemoryInspectionUtil.*;\n-import static java.util.Objects.requireNonNull;\n-\n-@Test\n-public class TestMemoryInspection {\n-\n-    private static final String EXPECT_ADDRESS = \"0x\" + \"00\".repeat((int) ValueLayout.ADDRESS.byteSize());\n-\n-    @Test\n-    public void valueLayouts() {\n-\n-        record TestInput(ValueLayout layout, String stringValue) {\n-        }\n-\n-        List.of(\n-                new TestInput(ValueLayout.JAVA_BYTE, \"0\"),\n-                new TestInput(ValueLayout.JAVA_SHORT, \"0\"),\n-                new TestInput(ValueLayout.JAVA_INT, \"0\"),\n-                new TestInput(ValueLayout.JAVA_LONG, \"0\"),\n-                new TestInput(ValueLayout.JAVA_FLOAT, \"0.0\"),\n-                new TestInput(ValueLayout.JAVA_DOUBLE, \"0.0\"),\n-                new TestInput(ValueLayout.JAVA_CHAR, \"\" + (char) 0),\n-                new TestInput(JAVA_BOOLEAN, \"false\"),\n-                new TestInput(ValueLayout.ADDRESS, EXPECT_ADDRESS)\n-        ).forEach(ti -> {\n-            var expect = ti.layout() + \"=\" + ti.stringValue();\n-            var actual = testWithFreshMemorySegment(ti.layout().byteSize(), s -> MemoryInspection.inspect(s, ti.layout(), MemoryInspection.ValueLayoutRenderer.standard()))\n-                    .collect(joining(System.lineSeparator()));\n-            assertEquals(actual, expect);\n-        });\n-    }\n-\n-    @Test\n-    public void point() {\n-\n-        var expect = platformLineSeparated(\"\"\"\n-                Point {\n-                    x=1,\n-                    y=2\n-                }\"\"\");\n-\n-        var actual = testWithFreshMemorySegment(Integer.BYTES * 2, segment -> {\n-            final Point point = new Point(segment);\n-            point.x(1);\n-            point.y(2);\n-            return MemoryInspection.inspect(segment, Point.LAYOUT, MemoryInspection.ValueLayoutRenderer.standard())\n-                    .collect(joining(System.lineSeparator()));\n-        });\n-\n-        assertEquals(actual, expect);\n-    }\n-\n-    @Test\n-    public void pointCustomRenderer() {\n-\n-        var expect = platformLineSeparated(\"\"\"\n-                Point {\n-                    x=0x0001,\n-                    y=0x0002\n-                }\"\"\");\n-\n-        var actual = testWithFreshMemorySegment(Integer.BYTES * 2, segment -> {\n-            final Point point = new Point(segment);\n-            point.x(1);\n-            point.y(2);\n-            return MemoryInspectionUtil.inspect(segment, Point.LAYOUT, new MemoryInspection.ValueLayoutRenderer() {\n-                @Override\n-                public String render(ValueLayout.OfInt intLayout, int value) {\n-                    return String.format(\"0x%04x\", value);\n-                }\n-            })\n-                    .collect(joining(System.lineSeparator()));\n-        });\n-\n-        assertEquals(actual, expect);\n-    }\n-\n-    @Test\n-    public void standardCustomRenderer() {\n-\n-        MemoryLayout layout = MemoryLayout.structLayout(\n-                \/\/ These are in bit alignment order (descending) for all platforms\n-                \/\/ in order for each element to be aligned to its type's bit alignment.\n-                Stream.of(\n-                                JAVA_LONG,\n-                                JAVA_DOUBLE,\n-                                ADDRESS,\n-                                JAVA_INT,\n-                                JAVA_FLOAT,\n-                                JAVA_SHORT,\n-                                JAVA_CHAR,\n-                                JAVA_BOOLEAN,\n-                                JAVA_BYTE\n-                        )\n-                        .map(vl -> vl.withName(vl.carrier().getSimpleName()))\n-                        .toArray(MemoryLayout[]::new)\n-        ).withName(\"struct\");\n-\n-        System.out.println(\"layout = \" + layout);\n-        var expect = platformLineSeparated(\"\"\"\n-                struct {\n-                    long=0,\n-                    double=0.0,\n-                    MemorySegment=$1,\n-                    int=0,\n-                    float=0.0,\n-                    short=0,\n-                    char=\\u0000,\n-                    boolean=false,\n-                    byte=0\n-                }\"\"\").replace(\"$1\", EXPECT_ADDRESS);\n-\n-\n-        var actual = testWithFreshMemorySegment(layout.byteSize(), segment ->\n-                MemoryInspection.inspect(segment, layout, MemoryInspection.ValueLayoutRenderer.standard()))\n-                .collect(joining(System.lineSeparator()));\n-\n-        assertEquals(actual, expect);\n-    }\n-\n-\n-    @Test\n-    public void sequence() {\n-        final int arraySize = 4;\n-        var sequenceLayout = MemoryLayout.sequenceLayout(arraySize,\n-                MemoryLayout.structLayout(\n-                        ValueLayout.JAVA_INT.withName(\"x\"),\n-                        ValueLayout.JAVA_INT.withName(\"y\")\n-                ).withName(\"Point\")\n-        ).withName(\"PointArrayOfElements\");\n-\n-        var expect = platformLineSeparated(\"\"\"\n-                PointArrayOfElements [\n-                    Point {\n-                        x=0,\n-                        y=0\n-                    },\n-                    Point {\n-                        x=0,\n-                        y=0\n-                    },\n-                    Point {\n-                        x=0,\n-                        y=0\n-                    },\n-                    Point {\n-                        x=0,\n-                        y=0\n-                    }\n-                ]\"\"\");\n-        var actual = testWithFreshMemorySegment(Integer.BYTES * 2 * arraySize, segment ->\n-                MemoryInspection.inspect(segment, sequenceLayout, MemoryInspection.ValueLayoutRenderer.standard()))\n-                .collect(joining(System.lineSeparator()));\n-\n-        assertEquals(actual, expect);\n-    }\n-\n-\n-    @Test\n-    public void union() {\n-        var u0 = MemoryLayout.structLayout(\n-                ValueLayout.JAVA_INT.withName(\"x\"),\n-                ValueLayout.JAVA_INT.withName(\"y\"),\n-                MemoryLayout.paddingLayout(Integer.SIZE)\n-        ).withName(\"Point\");\n-\n-        var u1 = MemoryLayout.structLayout(\n-                ValueLayout.JAVA_INT.withName(\"x\"),\n-                ValueLayout.JAVA_INT.withName(\"y\"),\n-                ValueLayout.JAVA_INT.withName(\"z\")\n-        ).withName(\"3D-Point\");\n-\n-        var union = MemoryLayout.unionLayout(u0, u1).withName(\"Union\");\n-\n-        var expect = platformLineSeparated(\"\"\"\n-                Union {\n-                    Point {\n-                        x=0,\n-                        y=0,\n-                        32 padding bits\n-                    }|\n-                    3D-Point {\n-                        x=0,\n-                        y=0,\n-                        z=0\n-                    }\n-                }\"\"\");\n-        var actual = testWithFreshMemorySegment(Integer.BYTES * 3, segment ->\n-                MemoryInspectionUtil.inspect(segment, union, MemoryInspection.ValueLayoutRenderer.standard()))\n-                .collect(joining(System.lineSeparator()));\n-\n-        assertEquals(actual, expect);\n-    }\n-\n-    static final class Point {\n-\n-        static final MemoryLayout LAYOUT = MemoryLayout.structLayout(\n-                ValueLayout.JAVA_INT.withName(\"x\"),\n-                ValueLayout.JAVA_INT.withName(\"y\")\n-        ).withName(\"Point\");\n-\n-        static final VarHandle xVH = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"x\"));\n-        static final VarHandle yVH = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"y\"));\n-\n-        private final MemorySegment memorySegment;\n-\n-        Point(MemorySegment memorySegment) {\n-            this.memorySegment = requireNonNull(memorySegment);\n-        }\n-\n-        int x() {\n-            return (int) xVH.get(memorySegment);\n-        }\n-\n-        int y() {\n-            return (int) yVH.get(memorySegment);\n-        }\n-\n-        void x(int x) {\n-            xVH.set(memorySegment, x);\n-        }\n-\n-        void y(int y) {\n-            yVH.set(memorySegment, y);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"Point {x=\" + x() + \", y=\" + y() + \"}\";\n-        }\n-    }\n-\n-    private static String platformLineSeparated(String s) {\n-        return s.lines()\n-                .collect(joining(System.lineSeparator()));\n-    }\n-\n-    private static <T> T testWithFreshMemorySegment(long size,\n-                                                    Function<MemorySegment, T> mapper) {\n-        try (final MemorySession session = MemorySession.openConfined()) {\n-            var segment = session.allocate(size);\n-            return mapper.apply(segment);\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryInspection.java","additions":0,"deletions":290,"binary":false,"changes":290,"status":"deleted"}]}