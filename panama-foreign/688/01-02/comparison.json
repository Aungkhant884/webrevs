{"files":[{"patch":"@@ -196,0 +196,2 @@\n+When working with deterministic deallocation and shared memory session, it is always possible for the session associated with a memory segment passed *by reference* to a native function to be closed (by another thread) *while* the native function is executing. When this happens, the native code is at risk of dereferencing already-freed memory, which might trigger a JVM crash, or even result in silent memory corruption. For this reason, the `Linker` API provides some basic temporal safety guarantees: any `Addressable` instance passed to a downcall method handle will be *kept alive* for the entire duration of the call. In other words, it's as if the call to the downcall method handle occurred inside an invisible call to `MemorySession::whileAlive`.\n+\n","filename":"doc\/panama_ffi.md","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,2 +73,2 @@\n-        MemoryLayouts.JAVA_INT.withName(\"x\"),\n-        MemoryLayouts.JAVA_INT.withName(\"y\")\n+        JAVA_INT.withName(\"x\"),\n+        JAVA_INT.withName(\"y\")\n@@ -136,0 +136,66 @@\n+Working with deterministic deallocation is great in terms of achieving better control as to *when* memory resources are released. But deterministic deallocation present its own challenges. Consider the following method:\n+\n+```java\n+void m() {\n+    MemorySegment segment = MemorySegment.allocateNative(MemorySession.openConfined());\n+    segment.set(JAVA_INT, 0, 42);\n+}\n+```\n+\n+This method creates a segment backed by a fresh confined memory session. But the session is not closed before the method returns. This means the off-heap memory associated with the native segment will never be released. In other words, we have created a *memory leak*. With power comes responsibility: clients must not forget to call the close method (unless they are working with a session backed by a `Cleaner` object, in which case the call will happen implicitly, of course).\n+\n+Another issue with deterministic deallocation is that it can sometimes be tricky to determine whether a certain access operation might fail or not. Consider the following method:\n+\n+```java\n+void accept(MemorySegment segment) {\n+   segment.setAtIndex(JAVA_INT, 0, 1);\n+   segment.setAtIndex(JAVA_INT, 1, 2);\n+}\n+```\n+\n+The first call to `setAtIndex` might fail, if the session associated to the segment has already been closed. But, if the segment is associated with a shared session, it might also be possible for the *second* call to fail (if some other thread has closed the session concurrently). To help clients running a sequence of operation against one or more segments in a more atomic fashion, the `MemorySession::whileAlive` method can be used:\n+\n+```java\n+void accept(MemorySegment segment) {\n+   segment.session().whileAlive(() -> {\n+       segment.setAtIndex(JAVA_INT, 0, 1);\n+       segment.setAtIndex(JAVA_INT, 1, 2);\n+   });\n+}\n+```\n+\n+Finally, when writing APIs returning memory segments, API authors might want to take extra caution so that the API private memory session is not leaked outside the API, through the memory segments generated by the API. Consider the following code:\n+\n+```java\n+class Allocator {\n+    private final MemorySession privateSession = MemorySession.openConfined();\n+    \n+    MemorySegment allocate(long byteSize) {\n+        return MemorySegment.allocateNative(byteSize, privateSession);\n+    }\n+}\n+```\n+\n+And now, consider the following client code:\n+\n+```java\n+Allocator allocator = new Allocator();\n+MemorySegment segment = allocator.allocate(100);\n+...\n+segment.session().close();\n+```\n+\n+The problem here is that the API is exposing its own memory session via the segment it returns; by doing so, clients can then access the session of the segments obtained from the API, and even *close* the session, thus releasing *all* the memory that has been allocated by the `Allocator` instance, even the memory associated with segments that the client knew nothing about. To help writing more robust APIs, the `MemorySession::asNonCloseable` method can be used, which obtain a *non-closeable* view of a given memory session:\n+\n+```java\n+class Allocator {\n+    private final MemorySession privateSession = MemorySession.openConfined();\n+    \n+    MemorySegment allocate(long byteSize) {\n+        return MemorySegment.allocateNative(byteSize, privateSession.asNonCloseable());\n+    }\n+}\n+```\n+\n+In the above example, we have tweaked the `Allocator::allocate` method so that it returns a segment associated with a non-closeable view of the private memory session. This means that clients of this method will no longer be able to call `MemorySession::close` on the returned segment.\n+\n@@ -141,2 +207,2 @@\n-SequenceLayout seq = MemoryLayout.sequenceLayout(1_000_000, MemoryLayouts.JAVA_INT);\n-SequenceLayout bulk_element = MemoryLayout.sequenceLayout(100, MemoryLayouts.JAVA_INT);\n+SequenceLayout seq = MemoryLayout.sequenceLayout(1_000_000, JAVA_INT);\n+SequenceLayout bulk_element = MemoryLayout.sequenceLayout(100, JAVA_INT);\n","filename":"doc\/panama_memaccess.md","additions":70,"deletions":4,"binary":false,"changes":74,"status":"modified"}]}