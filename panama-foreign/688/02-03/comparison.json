{"files":[{"patch":"@@ -136,1 +136,3 @@\n-Working with deterministic deallocation is great in terms of achieving better control as to *when* memory resources are released. But deterministic deallocation present its own challenges. Consider the following method:\n+#### Challenges\n+\n+Working with deterministic deallocation is great in terms of achieving better control as to *when* memory resources are released. But deterministic deallocation present some unique challenges which we discuss here; some of these issues might look surprising, especially coming from a world where deallocation happens implicitly (as in the ByteBuffer API). Consider the following method:\n@@ -202,0 +204,2 @@\n+As we have seen in this session, deterministic deallocation, as most things in computer science, is a trade-off. More specifically, we are trading between predictability of deallocation and simplicity of API and user code. It is ultimately up to developers to pick the solution that works best for their use case. As a general (and rough!) rule of thumb, long-lived, shared memory resources might be better modelled using implicit memory sessions, whereas short-lived, thread-confined memory resources are often modelled using closeable memory sessions.\n+\n","filename":"doc\/panama_memaccess.md","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}