{"files":[{"patch":"@@ -3,3 +3,1 @@\n-For build instructions please see the\n-[online documentation](https:\/\/openjdk.java.net\/groups\/build\/doc\/building.html),\n-or either of these files:\n+For build instructions please see the [online documentation](https:\/\/openjdk.java.net\/groups\/build\/doc\/building.html), or either of these files:\n@@ -10,2 +8,15 @@\n-See <https:\/\/openjdk.java.net\/> for more information about\n-the OpenJDK Community and the JDK.\n+See <https:\/\/openjdk.java.net\/> for more information about the OpenJDK Community and the JDK.\n+\n+---\n+Foreign Function & Memory API\n+===================\n+This repository contains changes which aim at improving the interoperability between the Java programming language and native libraries, which is one of the main goals of [Project Panama](https:\/\/openjdk.java.net\/projects\/panama\/). This is done by introducing a new Java API, the Foreign Function & Memory API, which can be used to:\n+\n+* interact with different kinds of memory resources, including so-called off-heap or native memory, as shown [here](doc\/panama_memaccess.md);\n+* find native functions in a .dll\/.so\/.dylib and invoke them using method handles, as shown [here](doc\/panama_ffi.md).\n+\n+This API has been delivered, as incubating\/preview APIs, in official JDK releases, see [JEP 412](https:\/\/openjdk.java.net\/jeps\/412), [JEP 419](https:\/\/openjdk.java.net\/jeps\/419) and [JEP 424](https:\/\/openjdk.java.net\/jeps\/424) for more details.\n+\n+The Foreign Function & Memory API is best used in combination with a tool called `jextract`, which can be used to generate Java bindings to access functions and\/or structs in a native library described by a given header file. The tool is available in a standalone [repository](https:\/\/github.com\/openjdk\/jextract) which contains several [examples](https:\/\/github.com\/openjdk\/jextract\/tree\/master\/samples) which should help you getting started.\n+\n+Early acccess (EA) binary snapshots of this repository can be found at: http:\/\/jdk.java.net\/panama\/\n","filename":"README.md","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,448 @@\n+## State of foreign function support\n+\n+**May 2022**\n+\n+**Maurizio Cimadamore**\n+\n+Panama supports foreign functions through the Foreign Linker API, which has been available as an [incubating](https:\/\/openjdk.java.net\/jeps\/11) API since Java [16](https:\/\/openjdk.java.net\/jeps\/389). The central abstraction in the Foreign Linker API is the *foreign linker*, which allows clients to construct *downcall* method handles — that is, method handles whose invocation targets a native function defined in some native library. In other words, Panama foreign function support is completely expressed in terms of Java code and no intermediate native code is required.\n+\n+### Native addresses\n+\n+Before we dive into the specifics of the foreign function support, it would be useful to briefly recap some of the main concepts we have learned when exploring the [foreign memory access support](panama_memaccess.md). The Foreign Memory Access API allows client to create and manipulate *memory segments*. A memory segment is a view over a memory source (either on- or off-heap) which is spatially bounded, temporally bounded and thread-confined. The guarantees ensure that dereferencing a segment that has been created by Java code is always *safe*, and can never result in a VM crash, or, worse, in silent memory corruption.\n+\n+Now, in the case of memory segments, the above properties (spatial bounds, temporal bounds and confinement) can be known *in full* when the segment is created. But when we interact with native libraries we often receive *raw* pointers; such pointers have no spatial bounds (does a `char*` in C refer to one `char`, or a `char` array of a given size?), no notion of temporal bounds, nor thread-confinement. Raw addresses in our interop support are modeled using the `MemoryAddress` abstraction.\n+\n+If clients want to dereference `MemoryAddress`, they can do so *unsafely* in two ways. First, they can use one of the *unsafe* dereference methods provided by `MemoryAddress` (these methods closely mirror those offered by `MemorySegment`); these methods are *restricted* and will generate runtime warnings if called without specifying the `--enable-native-access` command-line flag:\n+\n+```java\n+...\n+MemoryAddress addr = ... \/\/obtain address from native code\n+int x = addr.get(JAVA_INT, 0);\n+```\n+\n+Alternatively, the client can create a memory segment from an address *unsafely*, using the `MemorySegment::ofAddress` factory (which is also a *restricted* method); this can also be useful to inject extra knowledge about spatial bounds which might be available in the native library the client is interacting with:\n+\n+```java\n+MemoryAddress addr = ... \/\/obtain address from native code\n+try (MemorySession session = MemorySession openConfined()) {\n+\tMemorySegment segment = MemorySegment.ofAddress(100, session);\n+\tint x = segment.get(JAVA_INT, 0);\n+}\n+```\n+\n+Both `MemoryAddress` and `MemorySegment` implement the `Addressable` interface, which is an interface modelling entities that can be passed *by reference* — that is, which can be projected to a `MemoryAddress` instance. In the case of `MemoryAddress` such a projection is the identity function; in the case of a memory segment, the projection returns the `MemoryAddress` instance for the segment's base address. This abstraction allows to pass either memory address or memory segments where an address is expected (this is especially useful when generating native bindings).\n+\n+### Segment allocators\n+\n+Idiomatic C code implicitly relies on stack allocation to allow for concise variable declarations; consider this example:\n+\n+```c\n+int arr[] = { 0, 1, 2, 3, 4 };\n+```\n+\n+A variable initializer such as the one above can be implemented as follows, using the Foreign Memory Access API:\n+\n+```java\n+try (MemorySession session = MemorySession openConfined()) {\n+    MemorySegment arr = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(5, JAVA_INT), session);\n+    for (int i = 0 ; i < 5 ; i++) {\n+        arr.setAtIndex(JAVA_INT, i, i);\n+    }\n+}\n+```\n+\n+There are a number of issues with the above code snippet:\n+\n+* compared to the C code, it is more verbose — the native array has to be initialized *element by element*\n+* allocation is very slow compared to C; allocating the `arr` variable now takes a full `malloc`, while in C the variable was simply stack-allocated\n+* when having multiple declarations like the one above, it might become increasingly harder to manage the lifecycle of the various segments\n+\n+To address these problems, Panama provides a `SegmentAllocator` abstraction, a functional interface which provides methods to allocate commonly used values. Since `MemorySession` implements the `SegmentAllocator` interface, the above code can be rewritten conveniently as follows:\n+\n+```java\n+try (MemorySession session = MemorySession openConfined()) {    \n+    MemorySegment arr = session.allocateArray(JAVA_INT, 0, 1, 2, 3, 4);\n+} \/\/ 'arr' is released here\n+```\n+\n+In the above code, the memory session acts as a *native* allocator (that is, an allocator built on top of `MemorySegment::allocateNative`). The session is then used to create a native array, initialized to the values `0, 1, 2, 3, 4`.  The array initialization is more efficient, compared to the previous snippet, as the Java array is copied *in bulk* into the memory region associated with the newly allocated memory segment. The returned segment is associated with the session which performed the allocation, meaning that the segment will no longer be accessible after the try-with-resource construct.\n+\n+Custom segment allocators are also critical to achieve optimal allocation performance; for this reason, a number of predefined allocators are available via factories in the `SegmentAllocator` interface. For instance, it is possible to create an arena-based allocator, as follows:\n+\n+```java\n+try (MemorySession session = MemorySession openConfined()) {\n+    SegmentAllocator allocator = SegmentAllocator.newNativeArena(session);\n+    for (int i = 0 ; i < 100 ; i++) {\n+        allocator.allocateArray(JAVA_INT, 0, 1, 2, 3, 4);\n+    }\n+    ...\n+} \/\/ all memory allocated is released here\n+```\n+\n+The above code creates a confined session; inside the *try-with-resources*, a new unbounded arena allocation is created, associated with the existing session. The allocator will pre-allocate a native segment, of a specific size, and respond to allocation requests by returning different slices of the pre-allocated segment. If the pre-allocated segment does not have sufficient space to accommodate a new allocation request, a new segment will be allocated. If the session associated with the arena allocator is closed, all memory segments created by the allocator (see the body of the `for` loop) will be deallocated at once. This idiom combines the advantages of deterministic deallocation (provided by the Memory Access API) with a more flexible and scalable allocation scheme, and can be very useful when writing large applications.\n+\n+For these reasons, all the methods in the Foreign Linker API which *produce* memory segments (see `VaList::nextVarg`), allow an optional allocator to be provided by user code — this is key in ensuring that an application using the Foreign Linker API achieves optimal allocation performances, especially in non-trivial use cases.\n+\n+### Symbol lookups\n+\n+The first ingredient of any foreign function support is a mechanism to lookup symbols in native libraries. In traditional Java\/JNI, this is done via the `System::loadLibrary` and `System::load` methods. Unfortunately, these methods do not provide a way for clients to obtain the *address* associated with a given library symbol. For this reason, the Foreign Linker API introduces a new abstraction, namely `SymbolLookup` (similar in spirit to a method handle lookup), which provides capabilities to lookup named symbols; we can obtain a symbol lookup in 3 different ways:\n+\n+* `SymbolLookup::libraryLookup(String, MemorySession)` — creates a symbol lookup which can be used to search symbol in a library with the given name. The provided memory session parameter controls the library lifecycle: that is, when the memory session is closed, the library referred to by the lookup will also be closed;\n+* `SymbolLookup::loaderLookup` — creates a symbol lookup which can be used to search symbols in all the libraries loaded by the caller's classloader (e.g. using `System::loadLibrary` or `System::load`)\n+* `Linker::defaultLookup` — returns the default symbol lookup associated with a `Linker` instance. For instance, the default lookup of the native linker (see `Linker::nativeLinker`) can be used to look up platform-specific symbols in the standard C library (such as `strlen`, or `getpid`).\n+\n+Once a lookup has been obtained, a client can use it to retrieve handles to library symbols (either global variables or functions) using the `lookup(String)` method, which returns an `Optional<MemorySegment>`.  The memory segments returned by the `lookup` are zero-length segments, whose base address is the address of the function or variable in the library.\n+\n+For instance, the following code can be used to look up the `clang_getClangVersion` function provided by the `clang` library; it does so by creating a *library lookup* whose lifecycle is associated to that of a confined memory session.\n+\n+```java\n+try (MemorySession session = MemorySession.openConfined()) {\n+    SymbolLookup libclang = SymbolLookup.libraryLookup(\"libclang.so\");\n+    MemorySegment clangVersion = libclang.lookup(\"clang_getClangVersion\").get();\n+}\n+```\n+\n+### Linker\n+\n+At the core of Panama foreign function support we find the `Linker` abstraction. This abstraction plays a dual role: first, for downcalls, it allows modelling foreign function calls as plain `MethodHandle` calls (see `Linker::downcallHandle`); second, for upcalls, it allows to convert an existing `MethodHandle` (which might point to some Java method) into a `MemorySegment` which could then be passed to foreign functions as a function pointer (see `Linker::upcallStub`):\n+\n+```java\n+interface Linker {\n+    MethodHandle downcallHandle(Addressable symbol, FunctionDescriptor function);\n+    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, MemorySession session);    \n+    ... \/\/ some overloads omitted here\n+\n+    static Linker nativeLinker() { ... }\n+}\n+```\n+\n+Both functions take a `FunctionDescriptor` instance — essentially an aggregate of memory layouts which is used to describe the argument and return types of a foreign function in full. Supported layouts are *value layouts* (for scalars and pointers) and *group layouts* (for structs\/unions). Each layout in a function descriptor is associated with a carrier Java type (see table below); together, all the carrier types associated with layouts in a function descriptor will determine a unique Java `MethodType`  — that is, the Java signature that clients will be using when interacting with said downcall handles, or upcall stubs.\n+\n+The `Linker::nativeLinker` factory is used to obtain a `Linker` implementation for the ABI associated with the OS and processor where the Java runtime is currently executing. As such, the native linker can be used to call C functions. The following table shows the mapping between C types, layouts and Java carriers under the Linux\/macOS native linker implementation; note that the mappings can be platform dependent: on Windows\/x64, the C type `long` is 32-bit, so the `JAVA_INT` layout (and the Java carrier `int.class`) would have to be used instead:\n+\n+| C type                                                       | Layout                                                       | Java carrier                       |\n+| ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------- |\n+| `bool`                                                       | `JAVA_BOOLEAN`                                               | `byte`                             |\n+| `char`                                                       | `JAVA_BYTE`                                                  | `byte`                             |\n+| `short`                                                      | `JAVA_SHORT`                                                 | `short`, `char`                    |\n+| `int`                                                        | `JAVA_INT`                                                   | `int`                              |\n+| `long`                                                       | `JAVA_LONG`                                                  | `long`                             |\n+| `long long`                                                  | `JAVA_LONG`                                                  | `long`                             |\n+| `float`                                                      | `JAVA_FLOAT`                                                 | `float`                            |\n+| `double`                                                     | `JAVA_DOUBLE`                                                | `double`                           |\n+| `char*`<br \/>`int**`<br \/> ...                               | `ADDRESS`                                                    | `Addressable`<br \/>`MemoryAddress` |\n+| `struct Point { int x; int y; };`<br \/>`union Choice { float a; int b; };`<br \/>... | `MemoryLayout.structLayout(...)`<br \/>`MemoryLayout.unionLayout(...)`<br \/> | `MemorySegment`                    |\n+\n+Note that all C pointer types are modelled using the `ADDRESS` layout constant; the Java carrier type associated with this layout is either `Addressable` or `MemoryAddress` depending on where the layout occurs in the function descriptor. For downcall method handles, for instance, the `Addressable` carrier is used when the `ADDRESS` layout occurs in a parameter position of the corresponding function descriptor. This maximizes applicability of a downcall method handles, ensuring that any implementation of `Addressable` (e.g. memory segments, memory address, upcall stubs, va lists) can be passed where a pointer is expected.\n+\n+A tool, such as `jextract`, will generate all the required C layouts (for scalars and structs\/unions) *automatically*, so that clients do not have to worry about platform-dependent details such as sizes, alignment constraints and padding.\n+\n+### Downcalls\n+\n+We will now look at how foreign functions can be called from Java using the native linker. Assume we wanted to call the following function from the standard C library:\n+\n+```c\n+size_t strlen(const char *s);\n+```\n+\n+In order to do that, we have to:\n+\n+* lookup the `strlen` symbol\n+* describe the signature of the C function using a function descriptor\n+\n+* create a *downcall* native method handle with the above information, using the native linker\n+\n+Here's an example of how we might want to do that (a full listing of all the examples in this and subsequent sections will be provided in the [appendix](#appendix-full-source-code)):\n+\n+```java\n+Linker linker = Linker.nativeLinker();\n+MethodHandle strlen = linker.downcallHandle(\n+\t\tlinker.defaultLookup().lookup(\"strlen\").get(),\n+        FunctionDescriptor.of(JAVA_LONG, ADDRESS)\n+);\n+```\n+\n+Note that, since the function `strlen` is part of the standard C library, which is loaded with the VM, we can just use the default lookup of the native linker to look it up. The rest is pretty straightforward — the only tricky detail is how to model `size_t`: typically this type has the size of a pointer, so we can use `JAVA_LONG` both Linux and Windows. On the Java side, we model the `size_t` using a `long` and the pointer is modelled using an `Addressable` parameter.\n+\n+Once we have obtained the downcall method handle, we can just use it as any other method handle<a href=\"#2\"><sup>1<\/sup><\/a>:\n+\n+```java\n+try (MemorySession session = MemorySession openConfined()) {\n+    long len = strlen.invoke(session.allocateUtf8String(\"Hello\")); \/\/ 5\n+}\n+```\n+\n+Here we are using a memory session to convert a Java string into an off-heap memory segment which contains a `NULL` terminated C string. We then pass that segment to the method handle and retrieve our result in a Java `long`. Note how all this is possible *without* any piece of intervening native code — all the interop code can be expressed in (low level) Java. Note also how we use an explicit memory session to control the lifecycle of the allocated C string, which ensures timely deallocation of the memory segment holding the native string.\n+\n+The `Linker` interface also supports linking of native functions without an address known at link time; when that happens, an address (of type `Addressable`) must be provided when the method handle returned by the linker is invoked — this is very useful to support *virtual calls*. For instance, the above code can be rewritten as follows:\n+\n+```java\n+MethodHandle strlen_virtual = linker.downcallHandle( \/\/ address parameter missing!\n+\t\tFunctionDescriptor.of(JAVA_LONG, ADDRESS)\n+);\n+\n+try (MemorySession session = MemorySession openConfined()) {\n+    long len = strlen_virtual.invoke(\n+        linker.defaultLookup().lookup(\"strlen\").get() \/\/ address provided here!\n+        session.allocateUtf8String(\"Hello\")\n+    ); \/\/ 5\n+}\n+```\n+\n+It is important to note that, albeit the interop code is written in Java, the above code can *not* be considered 100% safe. There are many arbitrary decisions to be made when setting up downcall method handles such as the one above, some of which might be obvious to us (e.g. how many parameters does the function take), but which cannot ultimately be verified by the Panama runtime. After all, a symbol in a dynamic library is nothing but a numeric offset and, unless we are using a shared library with debugging information, no type information is attached to a given library symbol. This means that the Panama runtime has to *trust* the function descriptor passed in<a href=\"#3\"><sup>2<\/sup><\/a>; for this reason, the `Linker::nativeLinker` factory is also a restricted method.\n+\n+If a native function returns a raw pointer (of type `MemoryAddress`), it is then up to the client to make sure that the address is being accessed and disposed of correctly, compatibly with the requirements of the underlying native library. If a native function returns a struct by value, a *fresh*, memory segment is allocated off-heap and returned to the caller. In such cases, the downcall method handle will feature an additional prefix `SegmentAllocator` (see above) parameter which will be used by the downcall method handle to allocate the returned segment. The allocation will likely associate the segment with a memory session that is known to the caller and which can then be used to release the memory associated with that segment. \n+\n+When working with deterministic deallocation and shared memory session, it is always possible for the session associated with a memory segment passed *by reference* to a native function to be closed (by another thread) *while* the native function is executing. When this happens, the native code is at risk of dereferencing already-freed memory, which might trigger a JVM crash, or even result in silent memory corruption. For this reason, the `Linker` API provides some basic temporal safety guarantees: any `Addressable` instance passed to a downcall method handle will be *kept alive* for the entire duration of the call. In other words, it's as if the call to the downcall method handle occurred inside an invisible call to `MemorySession::whileAlive`.\n+\n+Performance-wise, the reader might ask how efficient calling a foreign function using a native method handle is; the answer is *very*. The JVM comes with some special support for native method handles, so that, if a give method handle is invoked many times (e.g, inside a *hot* loop), the JIT compiler might decide to generate a snippet of assembly code required to call the native function, and execute that directly. In most cases, invoking native function this way is as efficient as doing so through JNI.\n+\n+### Upcalls\n+\n+Sometimes, it is useful to pass Java code as a function pointer to some native function; we can achieve that by using foreign linker support for upcalls. To demonstrate this, let's consider the following function from the C standard library:\n+\n+```c\n+void qsort(void *base, size_t nmemb, size_t size,\n+           int (*compar)(const void *, const void *));\n+```\n+\n+The `qsort` function can be used to sort the contents of an array, using a custom comparator function — `compar` — which is passed as a function pointer. To be able to call the `qsort` function from Java we have first to create a downcall method handle for it:\n+\n+```java\n+Linker linker = Linker.nativeLinker();\n+MethodHandle qsort = linker.downcallHandle(\n+\t\tlinker.defaultLookup().lookup(\"qsort\").get(),\n+        FunctionDescriptor.ofVoid(ADDRESS, JAVA_LONG, JAVA_LONG, ADDRESS)\n+);\n+```\n+\n+As before, we use `JAVA_LONG` and `long.class` to map the C `size_t` type, and `ADDRESS` for both the first pointer parameter (the array pointer) and the last parameter (the function pointer).\n+\n+This time, in order to invoke the `qsort` downcall handle, we need a *function pointer* to be passed as the last parameter; this is where the upcall support in foreign linker comes in handy, as it allows us to create a function pointer out of an existing method handle. First, let's write a function that can compare two int elements (passed as pointers):\n+\n+```java\n+class Qsort {\n+\tstatic int qsortCompare(MemoryAddress addr1, MemoryAddress addr2) {\n+\t\treturn addr1.get(JAVA_INT, 0) - addr2.get(JAVA_INT, 0);\n+\t}\n+}\n+```\n+\n+Here we can see that the function is performing some *unsafe* dereference of the pointer contents.\n+\n+Now let's create a method handle pointing to the comparator function above:\n+\n+```java\n+FunctionDescriptor comparDesc = FunctionDescriptor.of(JAVA_INT, ADDRESS, ADDRESS);\n+MethodHandle comparHandle = MethodHandles.lookup()\n+                                         .findStatic(Qsort.class, \"qsortCompare\",\n+                                                     CLinker.upcallType(comparDesc));\n+```\n+\n+To do that, we first create a function descriptor for the function pointer type, and then we use the `CLinker::upcallType` to turn that function descriptor into a suitable `MethodType` instance to be used in a method handle lookup. Now that we have a method handle for our Java comparator function, we finally have all the ingredients to create an upcall stub, and pass it to the `qsort` downcall handle:\n+\n+```java\n+try (MemorySession session = MemorySession openConfined()) {\n+    MemorySegment comparFunc = linker.upcallStub(comparHandle, comparDesc, session);\n+    MemorySegment array = session.allocateArray(0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n+    qsort.invoke(array, 10L, 4L, comparFunc);\n+    int[] sorted = array.toArray(JAVA_INT); \/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n+}\n+```\n+\n+The above code creates an upcall stub — `comparFunc` — a function pointer that can be used to invoke our Java comparator function, of type `MemorySegment`. The upcall stub is associated with the provided memory session instance; this means that the stub will be uninstalled when the session is closed.\n+\n+The snippet then creates an off-heap array from a Java array, which is then passed to the `qsort` handle, along with the comparator function we obtained from the foreign linker.  As a side effect, after the call, the contents of the off-heap array will be sorted (as instructed by our comparator function, written in Java). We can than extract a new Java array from the segment, which contains the sorted elements. This is a more advanced example, but one that shows how powerful the native interop support provided by the foreign linker abstraction is, allowing full bidirectional interop support between Java and native.\n+\n+### Varargs\n+\n+Some C functions are *variadic* and can take an arbitrary number of arguments. Perhaps the most common example of this is the `printf` function, defined in the C standard library:\n+\n+```c\n+int printf(const char *format, ...);\n+```\n+\n+This function takes a format string, which features zero or more *holes*, and then can take a number of additional arguments that is identical to the number of holes in the format string.\n+\n+The foreign function support can support variadic calls, but with a caveat: the client must provide a specialized Java signature, and a specialized description of the C signature. For instance, let's say we wanted to model the following C call:\n+\n+```C\n+printf(\"%d plus %d equals %d\", 2, 2, 4);\n+```\n+\n+To do this using the foreign function support provided by Panama we would have to build a *specialized* downcall handle for that call shape, using the `FunctionDescriptor::asVariadic` to inject additional variadic layouts, as follows:\n+\n+```java\n+Linker linker = Linker.nativeLinker();\n+MethodHandle printf = linker.downcallHandle(\n+\t\tlinker.defaultLookup().lookup(\"printf\").get(),\n+        FunctionDescriptor.of(JAVA_INT, ADDRESS).asVariadic(JAVA_INT, JAVA_INT, JAVA_INT)\n+);\n+```\n+\n+Then we can call the specialized downcall handle as usual:\n+\n+```java\n+try (MemorySession session = MemorySession openConfined()) {    \n+    printf.invoke(session.allocateUtf8String(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n+}\n+```\n+\n+While this works, and provides optimal performance, there are some drawbacks:\n+\n+* If the variadic function needs to be called with many shapes, we have to create many downcall handles\n+* while this approach works for downcalls (since the Java code is in charge of determining which and how many arguments should be passed) it fails to scale to upcalls; in that case, the call comes from native code, so we have no way to guarantee that the shape of the upcall stub we have created will match that required by the native function.\n+\n+To add flexibility, the standard C foreign linker comes equipped with support for C variable argument lists — or `va_list`.  When a variadic function is called, C code has to unpack the variadic arguments by creating a `va_list` structure, and then accessing the variadic arguments through the `va_list` one by one (using the `va_arg` macro). To facilitate interop between standard variadic functions and `va_list` many C library functions in fact define *two* flavors of the same function, one using standard variadic signature, one using an extra `va_list` parameter. For instance, in the case of `printf` we can find that a `va_list`-accepting function performing the same task is also defined:\n+\n+```c\n+int vprintf(const char *format, va_list ap);\n+```\n+\n+The behavior of this function is the same as before — the only difference is that the ellipsis notation `...` has been replaced with a single `va_list` parameter; in other words, the function is no longer variadic.\n+\n+It is indeed fairly easy to create a downcall for `vprintf`:\n+\n+```java\n+Linker linker = Linker.nativeLinker();\n+MethodHandle vprintf = linker.downcallHandle(\n+\t\tlinker.defaultLookup().lookup(\"vprintf\").get(),\n+\t\tFunctionDescriptor.of(JAVA_INT, ADDRESS, ADDRESS));\n+```\n+\n+Here, the layout of a `va_list` parameter is simply `ADDRESS` (as va lists are passed by reference). To call the `vprintf` handle we need to create an instance of `VaList` which contains the arguments we want to pass to the `vprintf` function — we can do so, as follows:\n+\n+```java\n+try (MemorySession session = MemorySession openConfined()) {\n+    vprintf.invoke(\n+            session.allocateUtf8String(\"%d plus %d equals %d\"),\n+            VaList.make(builder ->\n+                            builder.addVarg(JAVA_INT, 2)\n+                                   .addVarg(JAVA_INT, 2)\n+                                   .addVarg(JAVA_INT, 4), session)\n+); \/\/prints \"2 plus 2 equals 4\"\n+```\n+\n+While the callee has to do more work to call the `vprintf` handle, note that that now we're back in a place where the downcall handle  `vprintf` can be shared across multiple callees. Note that both the format string and the `VaList` are associated with the given memory session — this means that both will remain valid throughout the native function call.\n+\n+Using `VaList` also scales to upcall stubs — it is therefore possible for clients to create upcalls stubs which take a `VaList` and then, from the Java upcall, read the arguments packed inside the `VaList` one by one using the methods provided by the `VaList` API (e.g. `VaList::nextVarg(ValueLayout.OfInt)`), which mimics the behavior of the C `va_arg` macro.\n+\n+### Appendix: full source code\n+\n+The full source code containing most of the code shown throughout this document can be seen below:\n+\n+```java\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.VaList;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.util.Arrays;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+public class Examples {\n+\n+    static Linker LINKER = Linker.nativeLinker();\n+    static SymbolLookup STDLIB = LINKER.defaultLookup();\n+\n+    public static void main(String[] args) throws Throwable {\n+        strlen();\n+        strlen_virtual();\n+        qsort();\n+        printf();\n+        vprintf();\n+    }\n+\n+    public static void strlen() throws Throwable {\n+        MethodHandle strlen = LINKER.downcallHandle(\n+                STDLIB.lookup(\"strlen\").get(),\n+                FunctionDescriptor.of(JAVA_LONG, ADDRESS)\n+        );\n+\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment hello = session.allocateUtf8String(\"Hello\");\n+            long len = (long) strlen.invoke(hello); \/\/ 5\n+            System.out.println(len);\n+        }\n+    }\n+\n+    public static void strlen_virtual() throws Throwable {\n+        MethodHandle strlen_virtual = LINKER.downcallHandle(\n+                FunctionDescriptor.of(JAVA_LONG, ADDRESS)\n+        );\n+\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment hello = session.allocateUtf8String(\"Hello\");\n+            long len = (long) strlen_virtual.invoke(\n+                STDLIB.lookup(\"strlen\").get(),\n+                hello); \/\/ 5\n+            System.out.println(len);\n+        }\n+    }\n+\n+    static class Qsort {\n+        static int qsortCompare(MemoryAddress addr1, MemoryAddress addr2) {\n+            return addr1.get(JAVA_INT, 0) - addr2.get(JAVA_INT, 0);\n+        }\n+    }\n+\n+    public static void qsort() throws Throwable {\n+        MethodHandle qsort = LINKER.downcallHandle(\n+                STDLIB.lookup(\"qsort\").get(),\n+                FunctionDescriptor.ofVoid(ADDRESS, JAVA_LONG, JAVA_LONG, ADDRESS)\n+        );\n+        FunctionDescriptor comparDesc = FunctionDescriptor.of(JAVA_INT, ADDRESS, ADDRESS);\n+        MethodHandle comparHandle = MethodHandles.lookup()\n+                                         .findStatic(Qsort.class, \"qsortCompare\",\n+                                                     Linker.upcallType(comparDesc));\n+\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment comparFunc = LINKER.upcallStub(\n+                comparHandle, comparDesc, session);\n+\n+            MemorySegment array = session.allocateArray(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n+            qsort.invoke(array, 10L, 4L, comparFunc);\n+            int[] sorted = array.toArray(JAVA_INT); \/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n+            System.out.println(Arrays.toString(sorted));\n+        }\n+    }\n+\n+    public static void printf() throws Throwable {\n+        MethodHandle printf = LINKER.downcallHandle(\n+                STDLIB.lookup(\"printf\").get(),\n+                FunctionDescriptor.of(JAVA_INT, ADDRESS).asVariadic(JAVA_INT, JAVA_INT, JAVA_INT)\n+        );\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment s = session.allocateUtf8String(\"%d plus %d equals %d\\n\");\n+            printf.invoke(s, 2, 2, 4);\n+        }\n+    }\n+\n+    public static void vprintf() throws Throwable {\n+\n+        MethodHandle vprintf = LINKER.downcallHandle(\n+                STDLIB.lookup(\"vprintf\").get(),\n+                FunctionDescriptor.of(JAVA_INT, ADDRESS, ADDRESS));\n+\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment s = session.allocateUtf8String(\"%d plus %d equals %d\\n\");\n+            VaList vlist = VaList.make(builder ->\n+                     builder.addVarg(JAVA_INT, 2)\n+                            .addVarg(JAVA_INT, 2)\n+                            .addVarg(JAVA_INT, 4), session);\n+            vprintf.invoke(s, vlist);\n+        }\n+    }\n+}\n+```\n+\n+\n+\n+* <a id=\"1\"\/>(<sup>1<\/sup>):<small> For simplicity, the examples shown in this document use `MethodHandle::invoke` rather than `MethodHandle::invokeExact`; by doing so we avoid having to cast by-reference arguments back to `Addressable`. With `invokeExact` the method handle invocation should be rewritten as `strlen.invokeExact((Addressable)session.allocateUtf8String(\"Hello\"));`<\/small>\n+* <a id=\"2\"\/>(<sup>2<\/sup>):<small> In reality this is not entirely new; even in JNI, when you call a `native` method the VM trusts that the corresponding implementing function in C will feature compatible parameter types and return values; if not a crash might occur.<\/small>\n","filename":"doc\/panama_ffi.md","additions":448,"deletions":0,"binary":false,"changes":448,"status":"added"},{"patch":"@@ -0,0 +1,281 @@\n+## State of foreign memory support\n+\n+**May 2022**\n+\n+**Maurizio Cimadamore**\n+\n+A crucial part of any native interop story lies in the ability of accessing off-heap memory efficiently and safely. Panama achieves this goal through the Foreign Memory Access API, which has been available as an [incubating](https:\/\/openjdk.java.net\/jeps\/11) API since Java [14](https:\/\/openjdk.java.net\/jeps\/370). The Foreign Memory Access API introduces abstractions to allocate and access flat memory regions (whether on- or off-heap), to manage the lifecycle of memory resources and to model native memory addresses.\n+\n+### Segments\n+\n+Memory segments are abstractions which can be used to model contiguous memory regions, located either on- or off- the Java heap. Segments can be allocated from native memory (e.g. like a `malloc`), or can be wrapped around existing memory sources (e.g. a Java array or a `ByteBuffer`). Memory segments provide *strong* spatial, temporal and thread-confinement guarantees which make memory dereference operation *safe* (more on that later), although in most simple cases some properties of memory segments can safely be ignored.\n+\n+For instance, the following snippet allocates 100 bytes off-heap:\n+\n+```java\n+MemorySegment segment = MemorySegment.allocateNative(100, MemorySession.openImplicit());\n+```\n+\n+The above code allocates a 100-bytes long memory segment. The lifecycle of a memory segment is controlled by an abstraction called `MemorySession`. In this example, the segment memory will not be *freed* as long as the segment instance is deemed *reachable*, as specified by the `openImplicit()` parameter. In other words, the above factory creates a segment whose behavior closely matches that of a `ByteBuffer` allocated with the `allocateDirect` factory. Of course, the memory access API also supports deterministic memory release; we will cover that in a later section of this document.\n+\n+Memory segments support *slicing* — that is, given a segment, it is possible to create a new segment whose spatial bounds are stricter than that of the original segment:\n+\n+```java\n+MemorySegment segment = MemorySement.allocateNative(10, MemorySession.openImplicit());\n+MemorySegment slice = segment.asSlice(4, 4);\n+```\n+\n+The above code creates a slice that starts at offset 4 and has a length of 4 bytes. Generally speaking, slices have the *same* temporal bounds as the parent segment (we will refine this concept later in this document). In this example, the memory associated with the parent segment will not be released as long as there is at least one *reachable* slice derived from that segment.\n+\n+Memory segments can be dereferenced easily, by using *value layouts* (layouts are covered in greater details in the next section). A value layout captures information such as:\n+\n+- The number of bytes to be dereferenced;\n+- The alignment constraints of the address at which dereference occurs;\n+- The endianness with which bytes are stored in said memory region;\n+- The Java type to be used in the dereference operation (e.g. `int` vs `float`).\n+\n+For instance, the layout constant `ValueLayout.JAVA_INT` is four bytes wide, has no alignment constraints, uses the native platform endianness (e.g. little-endian on Linux\/x64) and is associated with the Java type `int`. The following example reads pairs of 32-bit values (as Java ints) and uses them to construct an array of points:\n+\n+```java\n+record Point(int x, int y);\n+MemorySegment segment = MemorySement.allocateNative(10 * 4 * 2, MemorySession.openImplicit());\n+Point[] values = new Point[10];\n+for (int i = 0 ; i < values.length ; i++) {\n+    int x = segment.getAtIndex(JAVA_INT, i * 2);\n+    int y = segment.getAtIndex(JAVA_INT, (i * 2) + 1);\n+    values[i] = new Point(x, y);\n+}\n+```\n+\n+The above snippet allocates a flat array of 80 bytes using `MemorySegment::allocateNative`. Then, inside the loop, elements in the array are accessed using the `MemorySegment::getAtIndex` method, which accesses `int` elements in a segment at a certain *logical* index (under the hood, the segment offset being accessed is obtained by multiplying the logical index by 4, which is the stride of a Java `int` array). Thus, all coordinates `x` and `y` are collected into instances of a `Point` record.\n+\n+Memory segments are pretty flexible when it comes to interacting with existing memory sources and APIs. For instance, it is possible to create a `ByteBuffer` *view* out of an existing memory segment, as follows:\n+\n+```java\n+IntBuffer intBuffer = segment.asByteBuffer().asIntBuffer();\n+Point[] values = new Point[10];\n+for (int i = 0 ; i < values.length ; i++) {\n+    int x = intBuffer.get(i * 2);\n+    int y = intBuffer.get((i * 2) + 1);\n+    values[i] = new Point(x, y);\n+}\n+```\n+\n+Creating buffer views out of existing segment is a crucial tool enabling interoperability with existing API (especially those dealing with I\/O) which might be expressed in terms of the ByteBuffer API.\n+\n+### Layouts and structured access\n+\n+Expressing byte offsets (as in the example above) can lead to code that is hard to read, and very fragile — as memory layout invariants are captured, implicitly, in the constants used to scale offsets. To address this issue, we add a *memory layout* API which allows clients to define memory layouts *programmatically*. For instance, the layout of the array used in the above example can be expressed using the following code <a href=\"#1\"><sup>1<\/sup><\/a>:\n+\n+```java\n+MemoryLayout points = MemoryLayout.sequenceLayout(10,\n+    MemoryLayout.structLayout(\n+        JAVA_INT.withName(\"x\"),\n+        JAVA_INT.withName(\"y\")\n+    )\n+);            \n+```\n+\n+That is, our layout is a repetition of 10 *struct* elements, each struct element containing two 32-bit values each. The advantage of defining a memory layout upfront, using an API, is that we can then query the layout — for instance we can compute the offset of the `y` coordinate in the 4th element of the `points` array:\n+\n+```java\n+long y3 = points.byteOffset(PathElement.sequenceElement(3), PathElement.groupElement(\"y\")); \/\/ 28\n+```\n+\n+To specify which nested layout element should be used for the offset calculation we use a *layout path*, a selection expression that navigates the layout, from the *root* layout, down to the leaf layout we wish to select; in this case we need to select the 4th layout element in the sequence, and then select the layout named `y` inside the selected group layout.\n+\n+One of the things that can be derived from a layout is a *memory access var handle*. A memory access var handle is a special kind of var handle which takes a memory segment access coordinate, together with a byte offset — the offset, relative to the segment's base address at which the dereference operation should occur. With memory access var handles we can rewrite our example above as follows:\n+\n+```java\n+MemorySegment segment = MemorySegment.allocateNative(points, MemorySession.openImplicit());\n+VarHandle xHandle = points.varHandle(PathElement.sequenceElement(), PathElement.groupElement(\"x\"));\n+VarHandle yHandle = points.varHandle(PathElement.sequenceElement(), PathElement.groupElement(\"y\"));\n+Point[] values = new Point[10];\n+for (int i = 0 ; i < values.length ; i++) {\n+    int x = (int)xHandle.get(segment, (long)i);\n+    int y = (int)yHandle.get(segment, (long)i);\n+}\n+```\n+\n+In the above, `xHandle` and `yHandle` are two var handle instances whose type is `int` and which takes two access coordinates:\n+\n+1. a `MemorySegment` instance; the segment whose memory should be dereferenced\n+2. a *logical* index, which is used to select the element of the sequence we want to access (as the layout path used to construct these var handles contains one free dimension)\n+\n+Note that memory access var handles (as any other var handle) are *strongly* typed; and to get maximum efficiency, it is generally necessary to introduce casts to make sure that the access coordinates match the expected types — in this case we have to cast `i` into a `long`; similarly, since the signature polymorphic method `VarHandle::get` notionally returns `Object` a cast is necessary to force the right return type the var handle operation <a href=\"#2\"><sup>2<\/sup><\/a>.\n+\n+In other words, manual offset computation is no longer needed — offsets and strides can in fact be derived from the layout object; note how `yHandle` is able to compute the required offset of the `y` coordinate in the flat array without the need of any error-prone arithmetic computation.\n+\n+### Deterministic deallocation\n+\n+In addition to spatial bounds, memory segments also feature temporal bounds as well as thread-confinement. In the examples shown so far, we have always used the API in its simpler form, leaving the runtime to handle details such as whether it was safe or not to reclaim memory associated with a given memory segment. But there are cases where this behavior is not desirable: consider the case where a large memory segment is mapped from a file (this is possible using `MemorySegment::map`); in this case, an application would probably prefer to deterministically release (e.g. unmap) the memory associated with this segment, to ensure that memory doesn't remain available for longer than in needs to (and therefore potentially impacting the performance of the application).\n+\n+Memory segments support deterministic deallocation, through an abstraction called `MemorySession`. A memory session models the lifecycle associated with one or more memory resources (in this document, by memory resources we mean mostly memory segments); a memory session has a state: it starts off in the *alive* state, which means that all the resources it manages can be safely accessed — and, at the user's request, it can be *closed*. After a memory session is closed, access to resources managed by that session is no longer allowed. Memory sessions implement the `AutoCloseable` interface, and can therefore be used with the *try-with-resources* construct, as demonstrated in the following code:\n+\n+```java\n+try (MemorySession session = MemorySession.openConfined()) {\n+    MemorySegment mapped = MemorySegment.map(Path.of(\"someFile\"), 0, 100000, MapMode.READ_WRITE, session);    \n+} \/\/ segment is unmapped here\n+```\n+\n+Here, we create a new *confined* memory session, which is then used when creating a mapped segment; this means that the lifecycle of the `mapped` segment is tied to that of the memory session, and that accessing the segment (e.g. dereference) *after* `session` has been closed will not be possible.\n+\n+As this example alludes to, memory sessions can come in many flavors: they can be *confined* (where access is restricted to the thread which created the session), *shared* <a href=\"#3\"><sup>3<\/sup><\/a> (where access can occur in any thread) and can be optionally associated with a `Cleaner` object (as in the case of `openImplicit`), which performs *implicit* deallocation when the memory session becomes *unreachable* (if the `close` method has not been called by the user). Memory sessions are very handy when managing the lifecycle of multiple resources:\n+\n+```java\n+try (MemorySession session = MemorySession.openConfined()) {\n+    MemorySegment segment1 = MemorySegment.allocateNative(100, session);\n+    MemorySegment segment2 = MemorySegment.allocateNative(100, session);\n+    ...\n+    MemorySegment segmentN = MemorySegment.allocateNative(100, session);\n+} \/\/ all segments are deallocated here\n+```\n+\n+Here we create another confined session, and then, inside the *try-with-resources* we use the session to create many segments; all such segments share the *same* memory session — meaning that when such session is closed, the memory associated with all these segments will be reclaimed at once.\n+\n+Working with deterministic deallocation is great in terms of achieving better control as to *when* memory resources are released. But deterministic deallocation present its own challenges. Consider the following method:\n+\n+```java\n+void m() {\n+    MemorySegment segment = MemorySegment.allocateNative(MemorySession.openConfined());\n+    segment.set(JAVA_INT, 0, 42);\n+}\n+```\n+\n+This method creates a segment backed by a fresh confined memory session. But the session is not closed before the method returns. This means the off-heap memory associated with the native segment will never be released. In other words, we have created a *memory leak*. With power comes responsibility: clients must not forget to call the close method (unless they are working with a session backed by a `Cleaner` object, in which case the call will happen implicitly, of course).\n+\n+Another issue with deterministic deallocation is that it can sometimes be tricky to determine whether a certain access operation might fail or not. Consider the following method:\n+\n+```java\n+void accept(MemorySegment segment) {\n+   segment.setAtIndex(JAVA_INT, 0, 1);\n+   segment.setAtIndex(JAVA_INT, 1, 2);\n+}\n+```\n+\n+The first call to `setAtIndex` might fail, if the session associated to the segment has already been closed. But, if the segment is associated with a shared session, it might also be possible for the *second* call to fail (if some other thread has closed the session concurrently). To help clients running a sequence of operation against one or more segments in a more atomic fashion, the `MemorySession::whileAlive` method can be used:\n+\n+```java\n+void accept(MemorySegment segment) {\n+   segment.session().whileAlive(() -> {\n+       segment.setAtIndex(JAVA_INT, 0, 1);\n+       segment.setAtIndex(JAVA_INT, 1, 2);\n+   });\n+}\n+```\n+\n+Finally, when writing APIs returning memory segments, API authors might want to take extra caution so that the API private memory session is not leaked outside the API, through the memory segments generated by the API. Consider the following code:\n+\n+```java\n+class Allocator {\n+    private final MemorySession privateSession = MemorySession.openConfined();\n+    \n+    MemorySegment allocate(long byteSize) {\n+        return MemorySegment.allocateNative(byteSize, privateSession);\n+    }\n+}\n+```\n+\n+And now, consider the following client code:\n+\n+```java\n+Allocator allocator = new Allocator();\n+MemorySegment segment = allocator.allocate(100);\n+...\n+segment.session().close();\n+```\n+\n+The problem here is that the API is exposing its own memory session via the segment it returns; by doing so, clients can then access the session of the segments obtained from the API, and even *close* the session, thus releasing *all* the memory that has been allocated by the `Allocator` instance, even the memory associated with segments that the client knew nothing about. To help writing more robust APIs, the `MemorySession::asNonCloseable` method can be used, which obtain a *non-closeable* view of a given memory session:\n+\n+```java\n+class Allocator {\n+    private final MemorySession privateSession = MemorySession.openConfined();\n+    \n+    MemorySegment allocate(long byteSize) {\n+        return MemorySegment.allocateNative(byteSize, privateSession.asNonCloseable());\n+    }\n+}\n+```\n+\n+In the above example, we have tweaked the `Allocator::allocate` method so that it returns a segment associated with a non-closeable view of the private memory session. This means that clients of this method will no longer be able to call `MemorySession::close` on the returned segment.\n+\n+### Streaming slices\n+\n+To process the contents of a memory segment in bulk, a memory segment can be turned into a stream of slices, using the `MemorySegment::stream` method:\n+\n+```java\n+SequenceLayout seq = MemoryLayout.sequenceLayout(1_000_000, JAVA_INT);\n+SequenceLayout bulk_element = MemoryLayout.sequenceLayout(100, JAVA_INT);\n+\n+try (MemorySession session = MemorySession.openShared()) {\n+    MemorySegment segment = MemorySegment.allocateNative(seq, session);\n+    int sum = segment.elements(bulk_element).parallel()\n+                       .mapToInt(slice -> {\n+                           int res = 0;\n+                           for (int i = 0; i < 100 ; i++) {\n+                               res += slice.getAtIndex(JAVA_INT, i);\n+                           }\n+                           return res;\n+                       }).sum();\n+}\n+```\n+\n+The `MemorySegment::elements` method takes an element layout and returns a new stream. The stream is built on top of a spliterator instance (see `MemorySegment::spliterator`) which splits the segment into chunks whose size match that of the provided layout. Here, we want to sum elements in an array which contains a million of elements; now, doing a parallel sum where each computation processes *exactly* one element would be inefficient, so instead we use a *bulk* element layout. The bulk element layout is a sequence layout containing a group of 100 elements — which should make it more amenable to parallel processing. Since we are using `Stream::parallel` to work on disjoint slices in parallel, here we use a *shared* memory session, to ensure that the resulting segment can be accessed by multiple threads.\n+\n+### Combining memory access handles\n+\n+We have seen in the previous sections how memory access var handles dramatically simplify user code when structured access is involved. While deriving memory access var handles from layout is the most convenient option, the Foreign Memory Access API also allows to create such memory access var handles in a standalone fashion, as demonstrated in the following code:\n+\n+```java\n+VarHandle intHandle = MethodHandles.memorySegmentViewVarHandle(JAVA_INT); \/\/ (MS, J) -> I\n+```\n+\n+The above code creates a memory access var handle which reads\/writes `int` values at a certain byte offset in a segment. To create this var handle we have to specify a carrier type — the type we want to use e.g. to extract values from memory, as well as whether any byte swapping should be applied when contents are read from or stored to memory. Additionally, the user might want to impose additional constraints on how memory dereferences should occur; for instance, a client might want to prevent access to misaligned 32 bit values. Of course, all this information can be succinctly derived from the provided value layout (`JAVA_INT` in the above example).\n+\n+The attentive reader might have noted how rich the var handles returned by the layout API are, compared to the simple memory access var handle we have constructed here. How do we go from a simple access var handle that takes a byte offset to a var handle that can dereference a complex layout path? The answer is, by using var handle *combinators*. Developers familiar with the method handle API know how simpler method handles can be combined into more complex ones using the various combinator methods in the `MethodHandles` API. These methods allow, for instance, to insert (or bind) arguments into a target method handle, filter return values, permute arguments and much more.\n+\n+The Foreign Memory Access API adds a rich set of var handle combinators in the `MethodHandles` class; with these tools, developers can express var handle transformations such as:\n+\n+* mapping a var handle carrier type into a different one, using an embedding\/projection method handle pairs\n+* filter one or more var handle access coordinates using unary filters\n+* permute var handle access coordinates\n+* bind concrete access coordinates to an existing var handle\n+\n+Without diving too deep, let's consider how we might want to take a basic memory access handle and turn it into a var handle which dereference a segment at a specific offset (again using the `points` layout defined previously):\n+\n+```java\n+VarHandle intHandle = MemoryHandles.memorySegmentViewVarHandle(JAVA_INT); \/\/ (MS, J) -> I\n+long offsetOfY = points.byteOffset(PathElement.sequenceElement(3), PathElement.groupElement(\"y\"));\n+VarHandle valueHandle = MethodHandles.insertCoordinates(intHandle, 1, offsetOfValue); \/\/ (MS) -> I\n+```\n+\n+We have been able to derive, from a basic memory access var handle, a new var handle that dereferences a segment at a given fixed offset. It is easy to see how other, richer, var handles obtained using the layout API can be constructed manually using the var handle combinator API.\n+\n+### Unsafe segments\n+\n+The memory access API provides basic safety guarantees for all memory segments created using the API. More specifically, a memory dereference operation should either succeed, or result in a runtime exception — but, crucially, should never result in a VM crash, or, more subtly, in memory corruption occurring *outside* the region of memory associated with a memory segment. This is indeed the case, as all memory segments feature immutable *spatial bounds*, and, as we have seen, are associated with a memory session which make sure that segments cannot be dereferenced after their session has been closed, or, in case of a confined session, that segments cannot be dereferenced from a thread other than the one which created the session.\n+\n+That said, it is sometimes necessary to create a segment out of an existing memory source, which might be managed by native code. This is the case, for instance, if we want to create a segment out of a memory region managed by a *custom allocator*.\n+\n+The ByteBuffer API allows such a move, through a JNI [method](https:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/guides\/jni\/spec\/functions.html#NewDirectByteBuffer), namely `NewDirectByteBuffer`. This native method can be used to wrap a long address in a fresh direct byte buffer instance which is then returned to unsuspecting Java code.\n+\n+Memory segments provide a similar capability — that is, given an address (which might have been obtained through some native calls), it is possible to wrap a segment around it, with given spatial bounds and memory session, as follows:\n+\n+```java\n+try (MemorySession session = MemorySession.openShared()) {\n+    MemoryAddress addr = MemoryAddress.ofLong(someLongAddr);\n+    var unsafeSegment = MemorySegment.ofAddress(addr, 10, session);\n+    ...\n+}\n+```\n+\n+The above code creates a shared session and then, inside the *try-with-resources* it creates a *new* unsafe segment from a given address; the size of the segment is 10 bytes, and the unsafe segment is associated with the current shared session. This means that the unsafe segment cannot be dereferenced after the shared session has been closed.\n+\n+Of course, segments created this way are completely *unsafe*. There is no way for the runtime to verify that the provided address indeed points to a valid memory location, or that the size of the memory region pointed to by `addr` is indeed 10 bytes. Similarly, there are no guarantees that the underlying memory region associated with `addr` will not be deallocated *prior* to the call to `MemorySession::close`.\n+\n+For these reasons, `MemorySegment::ofAddress` is a *restricted method* in the Foreign Memory Access API. The first time a restricted method is invoked, a runtime warning is generated. Developers can get rid of warnings by specifying the set of modules that are allowed to call restricted methods. This is done by specifying the option `--enable-native-access=M`, where `M` is a module name. Multiple module names can be specified in a comma-separated list, where the special name `ALL-UNNAMED` is used to enable restricted access for all code on the class path. If the `--enable-native-access` option is specified, any attempt to call restricted operations from a module not listed in the option will fail with a runtime exception.\n+\n+* <a id=\"1\"\/>(<sup>1<\/sup>):<small> In general, deriving a complete layout from a C `struct` declaration is no trivial matter, and it's one of those areas where tooling can help greatly.<\/small>\n+* <a id=\"2\"\/>(<sup>2<\/sup>):<small> Clients can enforce stricter type checking when interacting with `VarHandle` instances, by obtaining an *exact* var handle, using the `VarHandle::withInvokeExactBehavior` method.<\/small>\n+* <a id=\"3\"\/>(<sup>3<\/sup>):<small> Shared sessions rely on VM thread-local handshakes (JEP [312](https:\/\/openjdk.java.net\/jeps\/312)) to implement lock-free, safe, shared memory access; that is, when it comes to memory access, there should no difference in performance between a shared segment and a confined segment. On the other hand, `MemorySession::close` might be slower on shared sessions than on confined ones.<\/small>\n+\n","filename":"doc\/panama_memaccess.md","additions":281,"deletions":0,"binary":false,"changes":281,"status":"added"}]}