{"files":[{"patch":"@@ -37,0 +37,2 @@\n+import java.lang.invoke.VarHandle;\n+import java.lang.ref.Reference;\n@@ -87,10 +89,14 @@\n-        WeakReference<ResourceScope> scopeRef = loadedLibraries.computeIfAbsent(library, lib -> {\n-            MemoryScope s = MemoryScope.createDefault();\n-            holder[0] = s; \/\/ keep the scope alive at least until the outer method returns\n-            s.addOrCleanupIfFail(ResourceList.ResourceCleanup.ofRunnable(() -> {\n-                nativeLibraries.unload(library);\n-                loadedLibraries.remove(library);\n-            }));\n-            return new WeakReference<>(s);\n-        });\n-        return new LibraryLookupImpl(library, scopeRef.get());\n+        try {\n+            WeakReference<ResourceScope> scopeRef = loadedLibraries.computeIfAbsent(library, lib -> {\n+                MemoryScope s = MemoryScope.createDefault();\n+                holder[0] = s; \/\/ keep the scope alive at least until the outer method returns\n+                s.addOrCleanupIfFail(ResourceList.ResourceCleanup.ofRunnable(() -> {\n+                    nativeLibraries.unload(library);\n+                    loadedLibraries.remove(library);\n+                }));\n+                return new WeakReference<>(s);\n+            });\n+            return new LibraryLookupImpl(library, scopeRef.get());\n+        } finally {\n+            Reference.reachabilityFence(holder);\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LibrariesHelper.java","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -147,2 +147,0 @@\n-    abstract void release();\n-\n@@ -230,5 +228,0 @@\n-        @Override\n-        void release() {\n-            lockCount--;\n-        }\n-\n@@ -256,1 +249,2 @@\n-                    release();\n+                    released = true;\n+                    lockCount--;\n@@ -273,1 +267,1 @@\n-        private static ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+        private static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n@@ -325,11 +319,0 @@\n-        void release() {\n-            int value;\n-            do {\n-                value = (int)STATE.getVolatile(this);\n-                if (value <= ALIVE) {\n-                    \/\/cannot get here - we can't close segment twice\n-                    throw new IllegalStateException(\"Already closed\");\n-                }\n-            } while (!STATE.compareAndSet(this, value, value - 1));\n-        }\n-\n@@ -361,1 +344,8 @@\n-                    release();\n+                    int value;\n+                    do {\n+                        value = (int)STATE.getVolatile(SharedScope.this);\n+                        if (value <= ALIVE) {\n+                            \/\/cannot get here - we can't close segment twice\n+                            throw new IllegalStateException(\"Already closed\");\n+                        }\n+                    } while (!STATE.compareAndSet(SharedScope.this, value, value - 1));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryScope.java","additions":11,"deletions":21,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    final void cleanup(ResourceCleanup first) {\n+    static void cleanup(ResourceCleanup first) {\n@@ -55,1 +55,1 @@\n-        final static ResourceCleanup DUMMY_CLEANUP = new ResourceCleanup() {\n+        final static ResourceCleanup CLOSED_LIST = new ResourceCleanup() {\n@@ -58,1 +58,1 @@\n-                \/\/ do nothing\n+                throw new IllegalStateException(\"This resource list has already been closed!\");\n@@ -75,1 +75,1 @@\n-            if (fst != ResourceCleanup.DUMMY_CLEANUP) {\n+            if (fst != ResourceCleanup.CLOSED_LIST) {\n@@ -85,1 +85,1 @@\n-            if (fst != ResourceCleanup.DUMMY_CLEANUP) {\n+            if (fst != ResourceCleanup.CLOSED_LIST) {\n@@ -87,1 +87,1 @@\n-                fst = ResourceCleanup.DUMMY_CLEANUP;\n+                fst = ResourceCleanup.CLOSED_LIST;\n@@ -89,0 +89,2 @@\n+            } else {\n+                throw new IllegalStateException(\"Attempt to cleanup an already closed resource list\");\n@@ -111,1 +113,1 @@\n-                if (newSegment == ResourceCleanup.DUMMY_CLEANUP) {\n+                if (newSegment == ResourceCleanup.CLOSED_LIST) {\n@@ -122,1 +124,5 @@\n-            if (fst != ResourceCleanup.DUMMY_CLEANUP) {\n+            \/\/ At this point we are only interested about add vs. close races - not close vs. close\n+            \/\/ (because MemoryScope::justClose ensured that this thread won the race to close the scope).\n+            \/\/ So, the only \"bad\" thing that could happen is that some other thread adds to this list\n+            \/\/ while we're closing it.\n+            if (FST.getAcquire(this) != ResourceCleanup.CLOSED_LIST) {\n@@ -128,1 +134,1 @@\n-                    if (FST.weakCompareAndSetRelease(this, prev, ResourceCleanup.DUMMY_CLEANUP)) {\n+                    if (FST.weakCompareAndSetRelease(this, prev, ResourceCleanup.CLOSED_LIST)) {\n@@ -133,0 +139,2 @@\n+            } else {\n+                throw new IllegalStateException(\"Attempt to cleanup an already closed resource list\");\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ResourceList.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"}]}