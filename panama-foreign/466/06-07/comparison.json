{"files":[{"patch":"@@ -427,1 +427,3 @@\n-        return new ArenaAllocator.BoundedArenaAllocator(scope, size);\n+        return scope.ownerThread() == null ?\n+                new ArenaAllocator.BoundedSharedArenaAllocator(scope, size) :\n+                new ArenaAllocator.BoundedArenaAllocator(scope, size);\n@@ -445,1 +447,3 @@\n-        return new ArenaAllocator(scope);\n+        return scope.ownerThread() == null ?\n+                new ArenaAllocator.UnboundedSharedArenaAllocator(scope) :\n+                new ArenaAllocator(scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    public synchronized MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n@@ -77,0 +77,32 @@\n+\n+    public static class BoundedSharedArenaAllocator extends BoundedArenaAllocator {\n+        public BoundedSharedArenaAllocator(ResourceScope scope, long size) {\n+            super(scope, size);\n+        }\n+\n+        @Override\n+        public synchronized MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+            return super.allocate(bytesSize, bytesAlignment);\n+        }\n+    }\n+\n+    public static class UnboundedSharedArenaAllocator implements SegmentAllocator {\n+\n+        final ResourceScope scope;\n+\n+        final ThreadLocal<ArenaAllocator> allocators = new ThreadLocal<>() {\n+            @Override\n+            protected ArenaAllocator initialValue() {\n+                return new ArenaAllocator(scope);\n+            }\n+        };\n+\n+        public UnboundedSharedArenaAllocator(ResourceScope scope) {\n+            this.scope = scope;\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+            return allocators.get().allocate(bytesSize, bytesAlignment);\n+        }\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ArenaAllocator.java","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -67,8 +67,22 @@\n-            try (ResourceScope scope = ResourceScope.ofConfined()) {\n-                SegmentAllocator allocator = allocationFactory.allocator(alignedLayout.byteSize() * ELEMS, scope);\n-                for (int i = 0 ; i < elems ; i++) {\n-                    MemorySegment address = allocationFunction.allocate(allocator, alignedLayout, value);\n-                    assertEquals(address.byteSize(), alignedLayout.byteSize());\n-                    addressList.add(address);\n-                    VarHandle handle = handleFactory.apply(alignedLayout);\n-                    assertEquals(value, handle.get(address));\n+            ResourceScope[] scopes = {\n+                    ResourceScope.ofConfined(),\n+                    ResourceScope.ofShared()\n+            };\n+            for (ResourceScope scope : scopes) {\n+                try (scope) {\n+                    SegmentAllocator allocator = allocationFactory.allocator(alignedLayout.byteSize() * ELEMS, scope);\n+                    for (int i = 0; i < elems; i++) {\n+                        MemorySegment address = allocationFunction.allocate(allocator, alignedLayout, value);\n+                        assertEquals(address.byteSize(), alignedLayout.byteSize());\n+                        addressList.add(address);\n+                        VarHandle handle = handleFactory.apply(alignedLayout);\n+                        assertEquals(value, handle.get(address));\n+                    }\n+                    boolean isBound = allocationFactory.isBound();\n+                    try {\n+                        allocationFunction.allocate(allocator, alignedLayout, value); \/\/too much, should fail if bound\n+                        assertFalse(isBound);\n+                    } catch (OutOfMemoryError ex) {\n+                        \/\/failure is expected if bound\n+                        assertTrue(isBound);\n+                    }\n@@ -76,7 +90,3 @@\n-                boolean isBound = allocationFactory.isBound();\n-                try {\n-                    allocationFunction.allocate(allocator, alignedLayout, value); \/\/too much, should fail if bound\n-                    assertFalse(isBound);\n-                } catch (OutOfMemoryError ex) {\n-                    \/\/failure is expected if bound\n-                    assertTrue(isBound);\n+                \/\/ addresses should be invalid now\n+                for (MemorySegment address : addressList) {\n+                    assertFalse(address.scope().isAlive());\n@@ -85,4 +95,0 @@\n-            \/\/ addresses should be invalid now\n-            for (MemorySegment address : addressList) {\n-                assertFalse(address.scope().isAlive());\n-            }\n@@ -111,5 +117,11 @@\n-        try (ResourceScope scope = ResourceScope.ofConfined()) {\n-            SegmentAllocator allocator = allocationFactory.allocator(100, scope);\n-            MemorySegment address = allocationFunction.allocate(allocator, layout, arr);\n-            Z found = arrayHelper.toArray(address, layout);\n-            assertEquals(found, arr);\n+        ResourceScope[] scopes = {\n+                ResourceScope.ofConfined(),\n+                ResourceScope.ofShared()\n+        };\n+        for (ResourceScope scope : scopes) {\n+            try (scope) {\n+                SegmentAllocator allocator = allocationFactory.allocator(100, scope);\n+                MemorySegment address = allocationFunction.allocate(allocator, layout, arr);\n+                Z found = arrayHelper.toArray(address, layout);\n+                assertEquals(found, arr);\n+            }\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":36,"deletions":24,"binary":false,"changes":60,"status":"modified"}]}