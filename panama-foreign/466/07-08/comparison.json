{"files":[{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.ref.Cleaner;\n+\n+\/**\n+ * A confined scope, which features an owner thread. The liveness check features an additional\n+ * confinement check - that is, calling any operation on this scope from a thread other than the\n+ * owner thread will result in an exception. Because of this restriction, checking the liveness bit\n+ * can be performed in plain mode.\n+ *\/\n+class ConfinedScope extends MemoryScope {\n+\n+    private boolean closed; \/\/ = false\n+    private int lockCount = 0;\n+    private final Thread owner;\n+\n+    public ConfinedScope(Thread owner, Object ref, Cleaner cleaner, boolean closeable) {\n+        super(ref, cleaner, closeable, new ConfinedResourceList());\n+        this.owner = owner;\n+    }\n+\n+    @ForceInline\n+    public final void checkValidState() {\n+        if (owner != Thread.currentThread()) {\n+            throw new IllegalStateException(\"Attempted access outside owning thread\");\n+        }\n+        if (closed) {\n+            throw new IllegalStateException(\"Already closed\");\n+        }\n+    }\n+\n+    @Override\n+    public boolean isAlive() {\n+        return !closed;\n+    }\n+\n+    @Override\n+    public Handle acquire() {\n+        checkValidState();\n+        if (!closeable) return DUMMY_LOCK;\n+        lockCount++;\n+        return new ConfinedHandle();\n+    }\n+\n+    void justClose() {\n+        this.checkValidState();\n+        if (lockCount == 0) {\n+            closed = true;\n+        } else {\n+            throw new IllegalStateException(\"Scope is acquired by \" + lockCount + \" locks\");\n+        }\n+    }\n+\n+    @Override\n+    public Thread ownerThread() {\n+        return owner;\n+    }\n+\n+    \/**\n+     * A confined resource list; no races are possible here.\n+     *\/\n+    static class ConfinedResourceList extends ResourceList {\n+        @Override\n+        void add(ResourceCleanup cleanup) {\n+            if (fst != ResourceCleanup.CLOSED_LIST) {\n+                cleanup.next = fst;\n+                fst = cleanup;\n+            } else {\n+                throw new IllegalStateException(\"Already closed!\");\n+            }\n+        }\n+\n+        @Override\n+        void cleanup() {\n+            if (fst != ResourceCleanup.CLOSED_LIST) {\n+                ResourceCleanup prev = fst;\n+                fst = ResourceCleanup.CLOSED_LIST;\n+                cleanup(prev);\n+            } else {\n+                throw new IllegalStateException(\"Attempt to cleanup an already closed resource list\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A confined resource scope handle; no races are possible here.\n+     *\/\n+    class ConfinedHandle implements Handle {\n+        boolean released = false;\n+\n+        @Override\n+        public void close() {\n+            checkValidState(); \/\/ thread check\n+            if (!released) {\n+                released = true;\n+                lockCount--;\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ConfinedScope.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.internal.ref.CleanerFactory;\n@@ -37,1 +36,0 @@\n-import java.lang.invoke.VarHandle;\n@@ -93,1 +91,1 @@\n-                s.addOrCleanupIfFail(ResourceList.ResourceCleanup.ofRunnable(() -> {\n+                s.addOrCleanupIfFail(MemoryScope.ResourceList.ResourceCleanup.ofRunnable(() -> {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LibrariesHelper.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-                scope.addOrCleanupIfFail(new ResourceList.ResourceCleanup() {\n+                scope.addOrCleanupIfFail(new MemoryScope.ResourceList.ResourceCleanup() {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.internal.vm.annotation.ForceInline;\n@@ -34,2 +33,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n@@ -39,1 +36,0 @@\n-import java.util.concurrent.atomic.AtomicBoolean;\n@@ -188,49 +184,1 @@\n-    \/**\n-     * A confined scope, which features an owner thread. The liveness check features an additional\n-     * confinement check - that is, calling any operation on this scope from a thread other than the\n-     * owner thread will result in an exception. Because of this restriction, checking the liveness bit\n-     * can be performed in plain mode.\n-     *\/\n-    static class ConfinedScope extends MemoryScope {\n-\n-        private boolean closed; \/\/ = false\n-        private int lockCount = 0;\n-        private final Thread owner;\n-\n-        public ConfinedScope(Thread owner, Object ref, Cleaner cleaner, boolean closeable) {\n-            super(ref, cleaner, closeable, new ResourceList.ConfinedResourceList());\n-            this.owner = owner;\n-        }\n-\n-        @ForceInline\n-        public final void checkValidState() {\n-            if (owner != Thread.currentThread()) {\n-                throw new IllegalStateException(\"Attempted access outside owning thread\");\n-            }\n-            if (closed) {\n-                throw new IllegalStateException(\"Already closed\");\n-            }\n-        }\n-\n-        @Override\n-        public boolean isAlive() {\n-            return !closed;\n-        }\n-\n-        @Override\n-        public Handle acquire() {\n-            checkValidState();\n-            if (!closeable) return DUMMY_LOCK;\n-            lockCount++;\n-            return new ConfinedHandle();\n-        }\n-\n-        void justClose() {\n-            this.checkValidState();\n-            if (lockCount == 0) {\n-                closed = true;\n-            } else {\n-                throw new IllegalStateException(\"Scope is acquired by \" + lockCount + \" locks\");\n-            }\n-        }\n-\n+    public static MemoryScope GLOBAL = new SharedScope( null, null, false) {\n@@ -238,2 +186,2 @@\n-        public Thread ownerThread() {\n-            return owner;\n+        void addInternal(ResourceList.ResourceCleanup resource) {\n+            \/\/ do nothing\n@@ -241,0 +189,1 @@\n+    };\n@@ -242,13 +191,1 @@\n-        class ConfinedHandle implements Handle {\n-            boolean released = false;\n-\n-            @Override\n-            public void close() {\n-                checkValidState(); \/\/ thread check\n-                if (!released) {\n-                    released = true;\n-                    lockCount--;\n-                }\n-            }\n-        }\n-    }\n+    public final Handle DUMMY_LOCK = () -> { };\n@@ -257,7 +194,4 @@\n-     * A shared scope, which can be shared across multiple threads. Closing a shared scope has to ensure that\n-     * (i) only one thread can successfully close a scope (e.g. in a close vs. close race) and that\n-     * (ii) no other thread is accessing the memory associated with this scope while the segment is being\n-     * closed. To ensure the former condition, a CAS is performed on the liveness bit. Ensuring the latter\n-     * is trickier, and require a complex synchronization protocol (see {@link jdk.internal.misc.ScopedMemoryAccess}).\n-     * Since it is the responsibility of the closing thread to make sure that no concurrent access is possible,\n-     * checking the liveness bit upon access can be performed in plain mode, as in the confined case.\n+     * A list of all cleanup actions associated with a resource scope. Cleanup actions are modelled as instances\n+     * of the {@link ResourceCleanup} class, and, together, form a linked list. Depending on whether a scope\n+     * is shared or confined, different implementations of this class will be used, see {@link ConfinedScope.ConfinedResourceList}\n+     * and {@link SharedScope.SharedResourceList}.\n@@ -265,1 +199,2 @@\n-    static class SharedScope extends MemoryScope {\n+    public abstract static class ResourceList implements Runnable {\n+        ResourceCleanup fst;\n@@ -267,1 +202,1 @@\n-        private static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+        abstract void add(ResourceCleanup cleanup);\n@@ -269,4 +204,1 @@\n-        private final static int ALIVE = 0;\n-        private final static int CLOSING = -1;\n-        private final static int CLOSED = -2;\n-        private final static int MAX_FORKS = Integer.MAX_VALUE;\n+        abstract void cleanup();\n@@ -274,19 +206,2 @@\n-        private int state = ALIVE;\n-\n-        private static final VarHandle STATE;\n-\n-        static {\n-            try {\n-                STATE = MethodHandles.lookup().findVarHandle(SharedScope.class, \"state\", int.class);\n-            } catch (Throwable ex) {\n-                throw new ExceptionInInitializerError(ex);\n-            }\n-        }\n-\n-        SharedScope(Object ref, Cleaner cleaner, boolean closeable) {\n-            super(ref, cleaner, closeable, new ResourceList.SharedResourceList());\n-        }\n-\n-        @Override\n-        public Thread ownerThread() {\n-            return null;\n+        public final void run() {\n+            cleanup(); \/\/ cleaner interop\n@@ -295,4 +210,5 @@\n-        @Override\n-        public void checkValidState() {\n-            if (state < ALIVE) {\n-                throw ScopedAccessError.INSTANCE;\n+        static void cleanup(ResourceCleanup first) {\n+            ResourceCleanup current = first;\n+            while (current != null) {\n+                current.cleanup();\n+                current = current.next;\n@@ -302,30 +218,2 @@\n-        @Override\n-        public Handle acquire() {\n-            if (!closeable) return DUMMY_LOCK;\n-            int value;\n-            do {\n-                value = (int)STATE.getVolatile(this);\n-                if (value < ALIVE) {\n-                    \/\/segment is not alive!\n-                    throw new IllegalStateException(\"Already closed\");\n-                } else if (value == MAX_FORKS) {\n-                    \/\/overflow\n-                    throw new IllegalStateException(\"Segment acquire limit exceeded\");\n-                }\n-            } while (!STATE.compareAndSet(this, value, value + 1));\n-            return new SharedHandle();\n-        }\n-\n-        void justClose() {\n-            int prevState = (int)STATE.compareAndExchange(this, ALIVE, CLOSING);\n-            if (prevState < 0) {\n-                throw new IllegalStateException(\"Already closed\");\n-            } else if (prevState != ALIVE) {\n-                throw new IllegalStateException(\"Scope is acquired by \" + prevState + \" locks\");\n-            }\n-            boolean success = SCOPED_MEMORY_ACCESS.closeScope(this);\n-            STATE.setVolatile(this, success ? CLOSED : ALIVE);\n-            if (!success) {\n-                throw new IllegalStateException(\"Cannot close while another thread is accessing the segment\");\n-            }\n-        }\n+        public static abstract class ResourceCleanup {\n+            ResourceCleanup next;\n@@ -333,4 +221,1 @@\n-        @Override\n-        public boolean isAlive() {\n-            return (int)STATE.getVolatile(this) != CLOSED;\n-        }\n+            public abstract void cleanup();\n@@ -338,14 +223,4 @@\n-        class SharedHandle implements Handle {\n-            final AtomicBoolean released = new AtomicBoolean(false);\n-\n-            @Override\n-            public void close() {\n-                if (released.compareAndSet(false, true)) {\n-                    int value;\n-                    do {\n-                        value = (int)STATE.getVolatile(SharedScope.this);\n-                        if (value <= ALIVE) {\n-                            \/\/cannot get here - we can't close segment twice\n-                            throw new IllegalStateException(\"Already closed\");\n-                        }\n-                    } while (!STATE.compareAndSet(SharedScope.this, value, value - 1));\n+            final static ResourceCleanup CLOSED_LIST = new ResourceCleanup() {\n+                @Override\n+                public void cleanup() {\n+                    throw new IllegalStateException(\"This resource list has already been closed!\");\n@@ -353,0 +228,9 @@\n+            };\n+\n+            static ResourceCleanup ofRunnable(Runnable cleanupAction) {\n+                return new ResourceCleanup() {\n+                    @Override\n+                    public void cleanup() {\n+                        cleanupAction.run();\n+                    }\n+                };\n@@ -355,8 +239,0 @@\n-    }\n-\n-    public static MemoryScope GLOBAL = new SharedScope( null, null, false) {\n-        @Override\n-        void addInternal(ResourceList.ResourceCleanup resource) {\n-            \/\/ do nothing\n-        }\n-    };\n@@ -364,1 +240,1 @@\n-    public final Handle DUMMY_LOCK = () -> { };\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryScope.java","additions":37,"deletions":161,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-        scope.addOrCleanupIfFail(new ResourceList.ResourceCleanup() {\n+        scope.addOrCleanupIfFail(new MemoryScope.ResourceList.ResourceCleanup() {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,144 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.foreign;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-\n-public abstract class ResourceList implements Runnable {\n-    ResourceCleanup fst;\n-\n-    abstract void add(ResourceCleanup cleanup);\n-\n-    abstract void cleanup();\n-\n-    public final void run() {\n-        cleanup(); \/\/ cleaner interop\n-    }\n-\n-    static void cleanup(ResourceCleanup first) {\n-        ResourceCleanup current = first;\n-        while (current != null) {\n-            current.cleanup();\n-            current = current.next;\n-        }\n-    }\n-\n-    public static abstract class ResourceCleanup {\n-        ResourceCleanup next;\n-\n-        public abstract void cleanup();\n-\n-        final static ResourceCleanup CLOSED_LIST = new ResourceCleanup() {\n-            @Override\n-            public void cleanup() {\n-                throw new IllegalStateException(\"This resource list has already been closed!\");\n-            }\n-        };\n-\n-        static ResourceCleanup ofRunnable(Runnable cleanupAction) {\n-            return new ResourceCleanup() {\n-                @Override\n-                public void cleanup() {\n-                    cleanupAction.run();\n-                }\n-            };\n-        }\n-    }\n-\n-    static class ConfinedResourceList extends ResourceList {\n-        @Override\n-        void add(ResourceCleanup cleanup) {\n-            if (fst != ResourceCleanup.CLOSED_LIST) {\n-                cleanup.next = fst;\n-                fst = cleanup;\n-            } else {\n-                throw new IllegalStateException(\"Already closed!\");\n-            }\n-        }\n-\n-        @Override\n-        void cleanup() {\n-            if (fst != ResourceCleanup.CLOSED_LIST) {\n-                ResourceCleanup prev = fst;\n-                fst = ResourceCleanup.CLOSED_LIST;\n-                cleanup(prev);\n-            } else {\n-                throw new IllegalStateException(\"Attempt to cleanup an already closed resource list\");\n-            }\n-        }\n-    }\n-\n-    static class SharedResourceList extends ResourceList {\n-\n-        static final VarHandle FST;\n-\n-        static {\n-            try {\n-                FST = MethodHandles.lookup().findVarHandle(ResourceList.class, \"fst\", ResourceCleanup.class);\n-            } catch (Throwable ex) {\n-                throw new ExceptionInInitializerError();\n-            }\n-        }\n-\n-        @Override\n-        void add(ResourceCleanup cleanup) {\n-            while (true) {\n-                ResourceCleanup prev = (ResourceCleanup) FST.getAcquire(this);\n-                cleanup.next = prev;\n-                ResourceCleanup newSegment = (ResourceCleanup) FST.compareAndExchangeRelease(this, prev, cleanup);\n-                if (newSegment == ResourceCleanup.CLOSED_LIST) {\n-                    \/\/ too late\n-                    throw new IllegalStateException(\"Already closed\");\n-                } else if (newSegment == prev) {\n-                    return; \/\/victory\n-                }\n-                \/\/ keep trying\n-            }\n-        }\n-\n-        void cleanup() {\n-            \/\/ At this point we are only interested about add vs. close races - not close vs. close\n-            \/\/ (because MemoryScope::justClose ensured that this thread won the race to close the scope).\n-            \/\/ So, the only \"bad\" thing that could happen is that some other thread adds to this list\n-            \/\/ while we're closing it.\n-            if (FST.getAcquire(this) != ResourceCleanup.CLOSED_LIST) {\n-                \/\/ok now we're really closing down\n-                ResourceCleanup prev = null;\n-                while (true) {\n-                    prev = (ResourceCleanup) FST.getAcquire(this);\n-                    \/\/ no need to check for DUMMY, since only one thread can get here!\n-                    if (FST.weakCompareAndSetRelease(this, prev, ResourceCleanup.CLOSED_LIST)) {\n-                        break;\n-                    }\n-                }\n-                cleanup(prev);\n-            } else {\n-                throw new IllegalStateException(\"Attempt to cleanup an already closed resource list\");\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ResourceList.java","additions":0,"deletions":144,"binary":false,"changes":144,"status":"deleted"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.misc.ScopedMemoryAccess;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.ref.Cleaner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+\/**\n+ * A shared scope, which can be shared across multiple threads. Closing a shared scope has to ensure that\n+ * (i) only one thread can successfully close a scope (e.g. in a close vs. close race) and that\n+ * (ii) no other thread is accessing the memory associated with this scope while the segment is being\n+ * closed. To ensure the former condition, a CAS is performed on the liveness bit. Ensuring the latter\n+ * is trickier, and require a complex synchronization protocol (see {@link jdk.internal.misc.ScopedMemoryAccess}).\n+ * Since it is the responsibility of the closing thread to make sure that no concurrent access is possible,\n+ * checking the liveness bit upon access can be performed in plain mode, as in the confined case.\n+ *\/\n+class SharedScope extends MemoryScope {\n+\n+    private static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n+    private final static int ALIVE = 0;\n+    private final static int CLOSING = -1;\n+    private final static int CLOSED = -2;\n+    private final static int MAX_FORKS = Integer.MAX_VALUE;\n+\n+    private int state = ALIVE;\n+\n+    private static final VarHandle STATE;\n+\n+    static {\n+        try {\n+            STATE = MethodHandles.lookup().findVarHandle(jdk.internal.foreign.SharedScope.class, \"state\", int.class);\n+        } catch (Throwable ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n+    SharedScope(Object ref, Cleaner cleaner, boolean closeable) {\n+        super(ref, cleaner, closeable, new SharedResourceList());\n+    }\n+\n+    @Override\n+    public Thread ownerThread() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void checkValidState() {\n+        if (state < ALIVE) {\n+            throw ScopedAccessError.INSTANCE;\n+        }\n+    }\n+\n+    @Override\n+    public Handle acquire() {\n+        if (!closeable) return DUMMY_LOCK;\n+        int value;\n+        do {\n+            value = (int) STATE.getVolatile(this);\n+            if (value < ALIVE) {\n+                \/\/segment is not alive!\n+                throw new IllegalStateException(\"Already closed\");\n+            } else if (value == MAX_FORKS) {\n+                \/\/overflow\n+                throw new IllegalStateException(\"Segment acquire limit exceeded\");\n+            }\n+        } while (!STATE.compareAndSet(this, value, value + 1));\n+        return new SharedHandle();\n+    }\n+\n+    void justClose() {\n+        int prevState = (int) STATE.compareAndExchange(this, ALIVE, CLOSING);\n+        if (prevState < 0) {\n+            throw new IllegalStateException(\"Already closed\");\n+        } else if (prevState != ALIVE) {\n+            throw new IllegalStateException(\"Scope is acquired by \" + prevState + \" locks\");\n+        }\n+        boolean success = SCOPED_MEMORY_ACCESS.closeScope(this);\n+        STATE.setVolatile(this, success ? CLOSED : ALIVE);\n+        if (!success) {\n+            throw new IllegalStateException(\"Cannot close while another thread is accessing the segment\");\n+        }\n+    }\n+\n+    @Override\n+    public boolean isAlive() {\n+        return (int) STATE.getVolatile(this) != CLOSED;\n+    }\n+\n+    \/**\n+     * A shared resource list; this implementation has to handle add vs. add races, as well as add vs. cleanup races.\n+     *\/\n+    static class SharedResourceList extends ResourceList {\n+\n+        static final VarHandle FST;\n+\n+        static {\n+            try {\n+                FST = MethodHandles.lookup().findVarHandle(ResourceList.class, \"fst\", ResourceCleanup.class);\n+            } catch (Throwable ex) {\n+                throw new ExceptionInInitializerError();\n+            }\n+        }\n+\n+        @Override\n+        void add(ResourceCleanup cleanup) {\n+            while (true) {\n+                ResourceCleanup prev = (ResourceCleanup) FST.getAcquire(this);\n+                cleanup.next = prev;\n+                ResourceCleanup newSegment = (ResourceCleanup) FST.compareAndExchangeRelease(this, prev, cleanup);\n+                if (newSegment == ResourceCleanup.CLOSED_LIST) {\n+                    \/\/ too late\n+                    throw new IllegalStateException(\"Already closed\");\n+                } else if (newSegment == prev) {\n+                    return; \/\/victory\n+                }\n+                \/\/ keep trying\n+            }\n+        }\n+\n+        void cleanup() {\n+            \/\/ At this point we are only interested about add vs. close races - not close vs. close\n+            \/\/ (because MemoryScope::justClose ensured that this thread won the race to close the scope).\n+            \/\/ So, the only \"bad\" thing that could happen is that some other thread adds to this list\n+            \/\/ while we're closing it.\n+            if (FST.getAcquire(this) != ResourceCleanup.CLOSED_LIST) {\n+                \/\/ok now we're really closing down\n+                ResourceCleanup prev = null;\n+                while (true) {\n+                    prev = (ResourceCleanup) FST.getAcquire(this);\n+                    \/\/ no need to check for DUMMY, since only one thread can get here!\n+                    if (FST.weakCompareAndSetRelease(this, prev, ResourceCleanup.CLOSED_LIST)) {\n+                        break;\n+                    }\n+                }\n+                cleanup(prev);\n+            } else {\n+                throw new IllegalStateException(\"Attempt to cleanup an already closed resource list\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A shared resource scope handle; this implementation has to handle close vs. close races.\n+     *\/\n+    class SharedHandle implements Handle {\n+        final AtomicBoolean released = new AtomicBoolean(false);\n+\n+        @Override\n+        public void close() {\n+            if (released.compareAndSet(false, true)) {\n+                int value;\n+                do {\n+                    value = (int) STATE.getVolatile(jdk.internal.foreign.SharedScope.this);\n+                    if (value <= ALIVE) {\n+                        \/\/cannot get here - we can't close segment twice\n+                        throw new IllegalStateException(\"Already closed\");\n+                    }\n+                } while (!STATE.compareAndSet(jdk.internal.foreign.SharedScope.this, value, value - 1));\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SharedScope.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.foreign.ResourceList;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -163,1 +163,4 @@\n-                handles.remove(0).close();\n+                ResourceScope.Handle handle = handles.remove(0);\n+                handle.close();\n+                handle.close(); \/\/ make sure it's idempotent\n+                handle.close(); \/\/ make sure it's idempotent\n@@ -174,1 +177,2 @@\n-                try (ResourceScope.Handle handle = scope.acquire()) {\n+                try {\n+                    ResourceScope.Handle handle = scope.acquire();\n@@ -176,0 +180,3 @@\n+                    handle.close();\n+                    handle.close(); \/\/ make sure it's idempotent\n+                    handle.close(); \/\/ make sure it's idempotent\n@@ -209,0 +216,2 @@\n+                handle.close(); \/\/ make sure it's idempotent\n+                handle.close(); \/\/ make sure it's idempotent\n","filename":"test\/jdk\/java\/foreign\/TestResourceScope.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"}]}