{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.foreign.MemoryScope;\n@@ -32,0 +33,1 @@\n+import jdk.internal.ref.CleanerFactory;\n@@ -69,1 +71,2 @@\n- * the method type and the function descriptor, respectively, used during the linking process, then it must be that:\n+ * the method type (obtained after dropping any prefix arguments) and the function descriptor, respectively,\n+ * used during the linking process, then it must be that:\n@@ -131,0 +134,4 @@\n+     * <p>\n+     * If the provided method type's return type is {@code MemorySegment}, then the resulting method handle features\n+     * an additional prefix parameter, of type {@link SegmentAllocator}), which will be used by the linker runtime\n+     * to allocate structs returned by-value.\n@@ -147,1 +154,1 @@\n-     * which can be used to call a target foreign function at an address passed in as a leading argument.\n+     * which can be used to call a target foreign function at the given address.\n@@ -149,3 +156,30 @@\n-     * For a given method type {@code (As...) -> R}, the returned method handle shall have the method type\n-     * {@code (Addressable, As...) -> R}, where {@code As...} are zero or more parameter types, and {@code R}\n-     * is the return type (which can be {@code void}).\n+     * If the provided method type's return type is {@code MemorySegment}, then the provided allocator will be used by\n+     * the linker runtime to allocate structs returned by-value.\n+     *\n+     * @see LibraryLookup#lookup(String)\n+     *\n+     * @param symbol    downcall symbol.\n+     * @param allocator the segment allocator.\n+     * @param type      the method type.\n+     * @param function  the function descriptor.\n+     * @return the downcall method handle.\n+     * @throws IllegalArgumentException in the case of a method type and function descriptor mismatch.\n+     *\/\n+    default MethodHandle downcallHandle(Addressable symbol, SegmentAllocator allocator, MethodType type, FunctionDescriptor function) {\n+        Objects.requireNonNull(symbol);\n+        Objects.requireNonNull(allocator);\n+        MethodHandle downcall = MethodHandles.insertArguments(downcallHandle(type, function), 0, symbol);\n+        if (type.returnType().equals(MemorySegment.class)) {\n+            downcall = MethodHandles.insertArguments(downcall, 0, allocator);\n+        }\n+        return downcall;\n+    }\n+\n+\n+    \/**\n+     * Obtain a foreign method handle, with the given type and featuring the given function descriptor,\n+     * which can be used to call a target foreign function at the given address, which is passed as\n+     * the first dynamic parameter to the resulting method handle. If the provided method\n+     * type's return type is {@code MemorySegment}, then the resulting method handle features an additional\n+     * prefix parameter (inserted immediately after the address parameter), of type {@link SegmentAllocator}),\n+     * which will be used by the linker runtime to allocate structs returned by-value.\n@@ -163,3 +197,2 @@\n-     * Allocates a native segment whose base address (see {@link MemorySegment#address}) can be\n-     * passed to other foreign functions (as a function pointer); calling such a function pointer\n-     * from native code will result in the execution of the provided method handle.\n+     * Allocates a native segment with given scope which can be passed to other foreign functions (as a function pointer);\n+     * calling such a function pointer from native code will result in the execution of the provided method handle.\n@@ -167,2 +200,1 @@\n-     * <p>The returned segment is <a href=MemorySegment.html#thread-confinement>shared<\/a>, and it only features\n-     * the {@link MemorySegment#CLOSE} access mode. When the returned segment is closed,\n+     * <p>The returned segment is associated with the provided scope. When such scope is closed,\n@@ -173,0 +205,1 @@\n+     * @param scope the upcall stub scope.\n@@ -176,1 +209,18 @@\n-    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function);\n+    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope);\n+\n+    \/**\n+     * Allocates a native segment which can be passed to other foreign functions (as a function pointer);\n+     * calling such a function pointer from native code will result in the execution of the provided method handle.\n+     * <p>\n+     * The returned segment is associated with a fresh, shared, resource scope,\n+     * which will be automatically closed when the segment (or views derived from it) is no longer in use.\n+     * The scope associated with the returned segment cannot be closed directly e.g. by calling {@link ResourceScope#close()}.\n+     *\n+     * @param target   the target method handle.\n+     * @param function the function descriptor.\n+     * @return the native stub segment.\n+     * @throws IllegalArgumentException if the target's method type and the function descriptor mismatch.\n+     *\/\n+    default MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function) {\n+        return upcallStub(target, function, MemoryScope.createDefault());\n+    }\n@@ -277,1 +327,1 @@\n-    static MemorySegment toCString(String str, NativeScope scope) {\n+    static MemorySegment toCString(String str, SegmentAllocator scope) {\n@@ -297,1 +347,1 @@\n-    static MemorySegment toCString(String str, Charset charset, NativeScope scope) {\n+    static MemorySegment toCString(String str, Charset charset, SegmentAllocator scope) {\n@@ -398,1 +448,1 @@\n-    private static MemorySegment toCString(byte[] bytes, NativeScope scope) {\n+    private static MemorySegment toCString(byte[] bytes, SegmentAllocator scope) {\n@@ -461,1 +511,1 @@\n-    interface VaList extends Addressable, AutoCloseable {\n+    interface VaList extends Addressable {\n@@ -468,2 +518,2 @@\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n+         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n+         * (see {@link #scope()}).\n@@ -479,2 +529,2 @@\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n+         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n+         * (see {@link #scope()}).\n@@ -490,2 +540,2 @@\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n+         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n+         * (see {@link #scope()}).\n@@ -501,2 +551,2 @@\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n+         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n+         * (see {@link #scope()}).\n@@ -515,2 +565,2 @@\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n+         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n+         * (see {@link #scope()}).\n@@ -524,1 +574,1 @@\n-         * The memory segment returned by this method will be allocated using the given {@code NativeScope}.\n+         * The memory segment returned by this method will be allocated using the given {@code NativeAllocator}.\n@@ -529,2 +579,2 @@\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n+         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n+         * (see {@link #scope()}).\n@@ -533,1 +583,1 @@\n-        MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope);\n+        MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator scope);\n@@ -539,2 +589,2 @@\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n+         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n+         * (see {@link #scope()}).\n@@ -545,16 +595,2 @@\n-         * A predicate used to check if the memory associated with the C {@code va_list} modelled\n-         * by this instance is still valid to use.\n-         *\n-         * @return true, if the memory associated with the C {@code va_list} modelled by this instance is still valid\n-         * @see #close()\n-         *\/\n-        boolean isAlive();\n-\n-        \/**\n-         * Releases the underlying C {@code va_list} modelled by this instance, and any native memory that is attached\n-         * to this va list that holds its elements (see {@link VaList#make(Consumer)}).\n-         * <p>\n-         * After calling this method, {@link #isAlive()} will return {@code false} and further attempts to read values\n-         * from this va list will result in an exception.\n-         *\n-         * @see #isAlive()\n+         * Returns the resource scope associated with this instance.\n+         * @return the resource scope associated with this instance.\n@@ -562,1 +598,1 @@\n-        void close();\n+        ResourceScope scope();\n@@ -569,3 +605,2 @@\n-         * If this method needs to allocate native memory for the copy, it will use\n-         * {@link MemorySegment#allocateNative(long, long)} to do so. {@link #close()} will have to be called on the\n-         * returned va list instance to release the allocated memory.\n+         * Any native resource required by the execution of this method will be allocated in the resource scope\n+         * associated with this instance (see {@link #scope()}).\n@@ -579,2 +614,2 @@\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n+         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n+         * (see {@link #scope()}).\n@@ -584,20 +619,0 @@\n-        \/**\n-         * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list's elements\n-         * starting from the current position, without affecting the state of the original va list, essentially\n-         * allowing the elements to be traversed multiple times.\n-         * <p>\n-         * If this method needs to allocate native memory for the copy, it will use\n-         * the given {@code NativeScope} to do so.\n-         * <p>\n-         * This method only copies the va list cursor itself and not the memory that may be attached to the\n-         * va list which holds its elements. That means that if this va list was created with the\n-         * {@link #make(Consumer)} method, closing this va list will also release the native memory that holds its\n-         * elements, making the copy unusable.\n-         *\n-         * @param scope the scope to allocate the copy in\n-         * @return a copy of this C {@code va_list}.\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n-         *\/\n-        VaList copy(NativeScope scope);\n-\n@@ -613,1 +628,2 @@\n-         * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list}.\n+         * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list},\n+         * backed by the global resource scope (see {@link ResourceScope#globalScope()}).\n@@ -623,0 +639,16 @@\n+            return SharedUtils.newVaListOfAddress(address, ResourceScope.globalScope());\n+        }\n+\n+        \/**\n+         * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list},\n+         * with given resource scope.\n+         * <p>\n+         * This method is <em>restricted<\/em>. Restricted method are unsafe, and, if used incorrectly, their use might crash\n+         * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+         * restricted methods, and use safe and supported functionalities, where possible.\n+         *\n+         * @param address a memory address pointing to an existing C {@code va_list}.\n+         * @param scope the resource scope to be associated with the returned {@code VaList} instance.\n+         * @return a new {@code VaList} instance backed by the C {@code va_list} at {@code address}.\n+         *\/\n+        static VaList ofAddressRestricted(MemoryAddress address, ResourceScope scope) {\n@@ -625,1 +657,2 @@\n-            return SharedUtils.newVaListOfAddress(address);\n+            Objects.requireNonNull(scope);\n+            return SharedUtils.newVaListOfAddress(address, scope);\n@@ -629,1 +662,2 @@\n-         * Constructs a new {@code VaList} using a builder (see {@link Builder}).\n+         * Constructs a new {@code VaList} using a builder (see {@link Builder}), associated with a fresh shared,\n+         * non-closeable resource scope (see {@link ResourceScope}).\n@@ -632,5 +666,2 @@\n-         * {@link MemorySegment#allocateNative(long, long)} to do so.\n-         * <p>\n-         * This method will allocate native memory to hold the elements in the va list. This memory\n-         * will be 'attached' to the returned va list instance, and will be released when {@link VaList#close()}\n-         * is called.\n+         * {@link MemorySegment#allocateNative(long, long, ResourceScope)} to do so, where the resource scope\n+         * used for the allocation is the valist scope itself (see {@link VaList#scope()}).\n@@ -647,1 +678,1 @@\n-            return SharedUtils.newVaList(actions, MemorySegment::allocateNative);\n+            return SharedUtils.newVaList(actions, MemoryScope.createDefault());\n@@ -654,1 +685,1 @@\n-         * the given {@code NativeScope} to do so.\n+         * the given {@code NativeAllocator} to do so.\n@@ -657,1 +688,1 @@\n-         * will be managed by the given {@code NativeScope}, and will be released when the scope is closed.\n+         * will be managed by the given {@code NativeAllocator}, and will be released when the scope is closed.\n@@ -667,1 +698,1 @@\n-        static VaList make(Consumer<Builder> actions, NativeScope scope) {\n+        static VaList make(Consumer<Builder> actions, ResourceScope scope) {\n@@ -670,1 +701,1 @@\n-            return SharedUtils.newVaList(actions, SharedUtils.Allocator.ofScope(scope));\n+            return SharedUtils.newVaList(actions, scope);\n@@ -753,1 +784,1 @@\n-     * and {@link CLinker#upcallStub(MethodHandle, FunctionDescriptor)}.\n+     * and {@link CLinker#upcallStub(MethodHandle, FunctionDescriptor, ResourceScope)}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":118,"deletions":87,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- * is reachable; this can be achieved by creating the segment using the {@link MemoryAddress#asSegmentRestricted(long, Runnable, Object)}\n+ * is reachable; this can be achieved by creating the segment using the {@link MemoryAddress#asSegmentRestricted(long, ResourceScope)}.\n@@ -54,1 +54,1 @@\n-MemorySegment errnoSegment = errno.address().asRestrictedSegment(4, errno);\n+MemorySegment errnoSegment = errno.address().asSegmentRestricted(4, ResourceScope.ofShared(errno, Cleaner.create()));\n@@ -85,1 +85,1 @@\n-         * clients can obtain a segment from this symbol's address using the {@link MemoryAddress#asSegmentRestricted(long, Runnable, Object)},\n+         * clients can obtain a segment from this symbol's address using the {@link MemoryAddress#asSegmentRestricted(long, Runnable, ResourceScope)},\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/LibraryLookup.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * {@link MemoryAddress#ofLong(long)} and {@link MemoryAddress#asSegmentRestricted(long, Runnable, Object)}.\n+ * {@link MemoryAddress#ofLong(long)} and {@link MemoryAddress#asSegmentRestricted(long, Runnable, ResourceScope)}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MappedMemorySegments.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.foreign.AbstractMemorySegmentImpl;\n@@ -31,2 +30,1 @@\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n-import jdk.internal.foreign.Utils;\n+import jdk.internal.ref.CleanerFactory;\n@@ -94,6 +92,4 @@\n-     * Returns a new confined native memory segment with given size, and whose base address is this address; the returned segment has its own temporal\n-     * bounds, and can therefore be closed. This method can be useful when interacting with custom native memory sources (e.g. custom allocators),\n-     * where an address to some underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n-     * <p>\n-     * The returned segment will feature all <a href=\"#access-modes\">access modes<\/a>\n-     * (see {@link MemorySegment#ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     * Returns a shared native memory segment with given size, and whose base address is this address. This method\n+     * can be useful when interacting with custom native memory sources (e.g. custom allocators), where an address to some\n+     * underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n+     * The returned segment is associated with the global resource scope (see {@link ResourceScope#globalScope()}).\n@@ -105,2 +101,1 @@\n-     * Calling {@link MemorySegment#close()} on the returned segment will <em>not<\/em> result in releasing any\n-     * memory resources which might implicitly be associated with the segment. This method is equivalent to the following code:\n+     * This method is equivalent to the following code:\n@@ -108,1 +103,1 @@\n-    asSegmentRestricted(byteSize, null, null);\n+    asSegmentRestricted(byteSize, null, ResourceScope.globalScope());\n@@ -115,1 +110,1 @@\n-     * @return a new confined native memory segment with given base address and size.\n+     * @return a new native memory segment with given base address and size.\n@@ -122,1 +117,1 @@\n-        return asSegmentRestricted(bytesSize, null, null);\n+        return asSegmentRestricted(bytesSize, null, ResourceScope.globalScope());\n@@ -126,8 +121,5 @@\n-     * Returns a new confined native memory segment with given size, and whose base address is this address; the returned segment has its own temporal\n-     * bounds, and can therefore be closed. This method can be useful when interacting with custom native memory sources (e.g. custom allocators),\n-     * where an address to some underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n-     * <p>\n-     * The returned segment will feature all <a href=\"#access-modes\">access modes<\/a>\n-     * (see {@link MemorySegment#ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n-     * Moreover, the returned segment will keep a strong reference to the supplied attachment object (if any), which can\n-     * be useful in cases where the lifecycle of the segment is dependent on that of some other external resource.\n+     * Returns a native memory segment with given size and resource scope, and whose base address is this address. This method\n+     * can be useful when interacting with custom native memory sources (e.g. custom allocators), where an address to some\n+     * underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n+     * The returned segment is not read-only (see {@link MemorySegment#isReadOnly()}), and is associated with the\n+     * provided resource scope.\n@@ -139,3 +131,29 @@\n-     * Calling {@link MemorySegment#close()} on the returned segment will <em>not<\/em> result in releasing any\n-     * memory resources which might implicitly be associated with the segment, but will result in calling the\n-     * provided cleanup action (if any).\n+     * This method is equivalent to the following code:\n+     * <pre>{@code\n+    asSegmentRestricted(byteSize, null, scope);\n+     * }<\/pre>\n+     * This method is <em>restricted<\/em>. Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param bytesSize the desired size.\n+     * @param scope the native segment scope.\n+     * @return a new native memory segment with given base address, size and scope.\n+     * @throws IllegalArgumentException if {@code bytesSize <= 0}.\n+     * @throws UnsupportedOperationException if this address is an heap address.\n+     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either\n+     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).\n+     *\/\n+    default MemorySegment asSegmentRestricted(long bytesSize, ResourceScope scope) {\n+        return asSegmentRestricted(bytesSize, null, scope);\n+    }\n+\n+    \/**\n+     * Returns a new native memory segment with given size and resource scope, and whose base address is this address. This method\n+     * can be useful when interacting with custom native memory sources (e.g. custom allocators), where an address to some\n+     * underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n+     * The returned segment is associated with the provided resource scope.\n+     * <p>\n+     * Clients should ensure that the address and bounds refers to a valid region of memory that is accessible for reading and,\n+     * if appropriate, writing; an attempt to access an invalid memory location from Java code will either return an arbitrary value,\n+     * have no visible effect, or cause an unspecified exception to be thrown.\n@@ -143,2 +161,2 @@\n-     * Both the cleanup action and the attachment object (if any) will be preserved under terminal operations such as\n-     * {@link MemorySegment#handoff(Thread)}, {@link MemorySegment#share()} and {@link MemorySegment#registerCleaner(Cleaner)}.\n+     * Calling {@link ResourceScope#close()} on the scope associated with the returned segment will result in calling\n+     * the provided cleanup action (if any).\n@@ -152,2 +170,2 @@\n-     * @param attachment an attachment object that will be kept strongly reachable by the returned segment; can be {@code null}.\n-     * @return a new confined native memory segment with given base address and size.\n+     * @param scope the native segment scope.\n+     * @return a new native memory segment with given base address, size and scope.\n@@ -159,1 +177,1 @@\n-    MemorySegment asSegmentRestricted(long bytesSize, Runnable cleanupAction, Object attachment);\n+    MemorySegment asSegmentRestricted(long bytesSize, Runnable cleanupAction, ResourceScope scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":48,"deletions":30,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import java.io.FileDescriptor;\n-import java.lang.ref.Cleaner;\n@@ -36,0 +34,1 @@\n+import jdk.internal.foreign.MemoryScope;\n@@ -38,0 +37,1 @@\n+import jdk.internal.ref.CleanerFactory;\n@@ -43,1 +43,0 @@\n-import java.util.Optional;\n@@ -48,1 +47,1 @@\n- * and temporal bounds. Spatial bounds ensure that memory access operations on a memory segment cannot affect a memory location\n+ * and temporal bounds (e.g. a {@link ResourceScope}). Spatial bounds ensure that memory access operations on a memory segment cannot affect a memory location\n@@ -50,1 +49,1 @@\n- * operations on a segment cannot occur after a memory segment has been closed (see {@link MemorySegment#close()}).\n+ * operations on a segment cannot occur after the resource scope associated with a memory segment has been closed (see {@link ResourceScope#close()}).\n@@ -85,25 +84,0 @@\n- * <p>\n- * Array and buffer segments are effectively <em>views<\/em> over existing memory regions which might outlive the\n- * lifecycle of the segments derived from them, and can even be manipulated directly (e.g. via array access, or direct use\n- * of the {@link ByteBuffer} API) by other clients. As a result, while sharing array or buffer segments is possible,\n- * it is strongly advised that clients wishing to do so take extra precautions to make sure that the underlying memory sources\n- * associated with such segments remain inaccessible, and that said memory sources are never aliased by more than one segment\n- * at a time - e.g. so as to prevent concurrent modifications of the contents of an array, or buffer segment.\n- *\n- * <h2>Explicit deallocation<\/h2>\n- *\n- * Memory segments are closed explicitly (see {@link MemorySegment#close()}). When a segment is closed, it is no longer\n- * <em>alive<\/em> (see {@link #isAlive()}, and subsequent operation on the segment (or on any {@link MemoryAddress} instance\n- * derived from it) will fail with {@link IllegalStateException}.\n- * <p>\n- * Closing a segment might trigger the releasing of the underlying memory resources associated with said segment, depending on\n- * the kind of memory segment being considered:\n- * <ul>\n- *     <li>closing a native memory segment results in <em>freeing<\/em> the native memory associated with it<\/li>\n- *     <li>closing a mapped memory segment results in the backing memory-mapped file to be unmapped<\/li>\n- *     <li>closing a buffer, or a heap segment does not have any side-effect, other than marking the segment\n- *     as <em>not alive<\/em> (see {@link MemorySegment#isAlive()}). Also, since the buffer and heap segments might keep\n- *     strong references to the original buffer or array instance, it is the responsibility of clients to ensure that\n- *     these segments are discarded in a timely manner, so as not to prevent garbage collection to reclaim the underlying\n- *     objects.<\/li>\n- * <\/ul>\n@@ -111,1 +85,1 @@\n- * <h2><a id = \"access-modes\">Access modes<\/a><\/h2>\n+ * <h2>Lifecycle and confinement<\/h2>\n@@ -113,4 +87,14 @@\n- * Memory segments supports zero or more <em>access modes<\/em>. Supported access modes are {@link #READ},\n- * {@link #WRITE}, {@link #CLOSE}, {@link #SHARE} and {@link #HANDOFF}. The set of access modes supported by a segment alters the\n- * set of operations that are supported by that segment. For instance, attempting to call {@link #close()} on\n- * a segment which does not support the {@link #CLOSE} access mode will result in an exception.\n+ * Memory segments are associated to a resource scope (see {@link ResourceScope}), which can be accessed using\n+ * the {@link #scope()} method. As for all resources associated with a resource scope, a segment cannot be\n+ * accessed after its corresponding scope has been closed. For instance, the following code will result in an\n+ * exception:\n+ * <blockquote><pre>{@code\n+MemorySegment segment = null;\n+try (ResourceScope scope = ResourceScope.ofConfined()) {\n+    segment = MemorySegment.allocateNative(8, 1, scope);\n+}\n+MemoryAccess.getLong(segment); \/\/ already closed!\n+ * }<\/pre><\/blockquote>\n+ * Additionally, access to a memory segment in subject to the thread-confinement checks enforced by the owning scope; that is,\n+ * if the segment is associated with a shared scope, it can be accessed by multiple threads; if it is associated with a confined\n+ * scope, it can only be accessed by the thread which own the scope.\n@@ -118,4 +102,2 @@\n- * The set of supported access modes can only be made stricter (by supporting <em>fewer<\/em> access modes). This means\n- * that restricting the set of access modes supported by a segment before sharing it with other clients\n- * is generally a good practice if the creator of the segment wants to retain some control over how the segment\n- * is going to be accessed.\n+ * Heap and buffer segments are always associated with a <em>global<\/em>, shared scope. This scope cannot be closed,\n+ * and can be considered as <em>always alive<\/em>.\n@@ -125,2 +107,1 @@\n- * Memory segments support <em>views<\/em>. For instance, it is possible to alter the set of supported access modes,\n- * by creating an <em>immutable<\/em> view of a memory segment, as follows:\n+ * Memory segments support <em>views<\/em>. For instance, it is possible to create an <em>immutable<\/em> view of a memory segment, as follows:\n@@ -129,1 +110,1 @@\n-MemorySegment roSegment = segment.withAccessModes(segment.accessModes() & ~WRITE);\n+MemorySegment roSegment = segment.asReadOnly();\n@@ -134,5 +115,2 @@\n- * Temporal bounds of the original segment are inherited by the view; that is, closing a segment view, such as a sliced\n- * view, will cause the original segment to be closed; as such special care must be taken when sharing views\n- * between multiple clients. If a client want to protect itself against early closure of a segment by\n- * another actor, it is the responsibility of that client to take protective measures, such as removing {@link #CLOSE}\n- * from the set of supported access modes, before sharing the view with another client.\n+ * Temporal bounds of the original segment are inherited by the views; that is, when the scope associated with a segment\n+ * is closed, all the views associated with that segment will also be rendered inaccessible.\n@@ -145,27 +123,1 @@\n- * <h2><a id = \"thread-confinement\">Thread confinement<\/a><\/h2>\n- *\n- * Memory segments support strong thread-confinement guarantees. Upon creation, they are assigned an <em>owner thread<\/em>,\n- * typically the thread which initiated the creation operation. After creation, only the owner thread will be allowed\n- * to directly manipulate the memory segment (e.g. close the memory segment) or access the underlying memory associated with\n- * the segment using a memory access var handle. Any attempt to perform such operations from a thread other than the\n- * owner thread will result in a runtime failure.\n- * <p>\n- * The {@link #handoff(Thread)} method can be used to change the thread-confinement properties of a memory segment.\n- * This method is, like {@link #close()}, a <em>terminal operation<\/em> which marks the original segment as not alive\n- * (see {@link #isAlive()}) and creates a <em>new<\/em> segment with the desired thread-confinement properties. Calling\n- * {@link #handoff(Thread)} is only possible if the segment features the corresponding {@link #HANDOFF} access mode.\n- * <p>\n- * For instance, if a client wants to transfer ownership of a segment to another (known) thread, it can do so as follows:\n- *\n- * <blockquote><pre>{@code\n-MemorySegment segment = ...\n-MemorySegment aSegment = segment.handoff(threadA);\n- * }<\/pre><\/blockquote>\n- *\n- * By doing so, the original segment is marked as not alive, and a new segment is returned whose owner thread\n- * is {@code threadA}; this allows, for instance, for two threads {@code A} and {@code B} to share\n- * a segment in a controlled, cooperative and race-free fashion (also known as <em>serial thread confinement<\/em>).\n- * <p>\n- * Alternatively, the {@link #share()} method can be used to remove thread ownership altogether; this is only possible\n- * if the segment features the corresponding {@link #SHARE} access mode. The following code shows how clients can\n- * obtain a shared segment:\n+ * <h2>Spliterator support<\/h2>\n@@ -173,10 +125,3 @@\n- * <blockquote><pre>{@code\n-MemorySegment segment = ...\n-MemorySegment sharedSegment = segment.share();\n- * }<\/pre><\/blockquote>\n- *\n- * Again here, the original segment is marked as not alive, and a new <em>shared<\/em> segment is returned which features no owner\n- * thread (e.g. {@link #ownerThread()} returns {@code null}). This might be useful when multiple threads need to process\n- * the contents of the same memory segment concurrently (e.g. in the case of parallel processing). For instance, a client\n- * might obtain a {@link Spliterator} from a shared segment, which can then be used to slice the segment and allow multiple\n- * threads to work in parallel on disjoint segment slices. The following code can be used to sum all int values in a memory segment in parallel:\n+ * A client might obtain a {@link Spliterator} from a segment, which can then be used to slice the segment and allow multiple\n+ * threads to work in parallel on disjoint segment slices (to do this, the segment has to be associated with a shared scope).\n+ * The following code can be used to sum all int values in a memory segment in parallel:\n@@ -185,2 +130,3 @@\n-SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);\n-try (MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT).share()) {\n+try (ResourceScope scope = ResourceScope.ofShared()) {\n+    SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);\n+    MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT, scope);\n@@ -194,26 +140,0 @@\n- * Once shared, a segment can be claimed back by a given thread (again using {@link #handoff(Thread)}); in fact, many threads\n- * can attempt to gain ownership of the same segment, concurrently, and only one of them is guaranteed to succeed.\n- * <p>\n- * When using shared segments, clients should make sure that no other thread is accessing the segment while\n- * the segment is being closed. If one or more threads attempts to access a segment concurrently while the\n- * segment is being closed, an exception might occur on both the accessing and the closing threads. Clients should\n- * refrain from attempting to close a segment repeatedly (e.g. keep calling {@link #close()} until no exception is thrown);\n- * such exceptions should instead be seen as an indication that the client code is lacking appropriate synchronization between the threads\n- * accessing\/closing the segment.\n- *\n- * <h2>Implicit deallocation<\/h2>\n- *\n- * Clients can register a memory segment against a {@link Cleaner}, to make sure that underlying resources associated with\n- * that segment will be released when the segment becomes <em>unreachable<\/em>, which can be useful to prevent native memory\n- * leaks. This can be achieved using the {@link #registerCleaner(Cleaner)} method, as follows:\n- *\n- * <blockquote><pre>{@code\n-MemorySegment segment = ...\n-MemorySegment gcSegment = segment.registerCleaner(cleaner);\n- * }<\/pre><\/blockquote>\n- *\n- * Here, the original segment is marked as not alive, and a new segment is returned (the owner thread of the returned\n- * segment set is set to that of the current thread, see {@link #ownerThread()}); the new segment\n- * will also be registered with the the {@link Cleaner} instance provided to the {@link #registerCleaner(Cleaner)} method;\n- * as such, if not closed explicitly (see {@link #close()}), the new segment will be automatically closed by the cleaner.\n- *\n@@ -226,1 +146,1 @@\n-public interface MemorySegment extends Addressable, AutoCloseable {\n+public interface MemorySegment extends Addressable {\n@@ -248,1 +168,1 @@\n-     * <a href=\"#access-modes\">access modes<\/a> as the given segment less the {@link #CLOSE} access mode.\n+     * scope as the given segment.\n@@ -261,2 +181,2 @@\n-     * The thread owning this segment.\n-     * @return the thread owning this segment.\n+     * Returns the resource scope associated with this memory segment.\n+     * @return the resource scope associated with this memory segment.\n@@ -264,1 +184,1 @@\n-    Thread ownerThread();\n+    ResourceScope scope();\n@@ -272,27 +192,0 @@\n-    \/**\n-     * Obtains a segment view with specific <a href=\"#access-modes\">access modes<\/a>. Supported access modes are {@link #READ}, {@link #WRITE},\n-     * {@link #CLOSE}, {@link #SHARE} and {@link #HANDOFF}. It is generally not possible to go from a segment with stricter access modes\n-     * to one with less strict access modes. For instance, attempting to add {@link #WRITE} access mode to a read-only segment\n-     * will be met with an exception.\n-     * @param accessModes an ORed mask of zero or more access modes.\n-     * @return a segment view with specific access modes.\n-     * @throws IllegalArgumentException when {@code mask} is an access mask which is less strict than the one supported by this\n-     * segment, or when {@code mask} contains bits not associated with any of the supported access modes.\n-     *\/\n-    MemorySegment withAccessModes(int accessModes);\n-\n-    \/**\n-     * Does this segment support a given set of access modes?\n-     * @param accessModes an ORed mask of zero or more access modes.\n-     * @return true, if the access modes in {@code accessModes} are stricter than the ones supported by this segment.\n-     * @throws IllegalArgumentException when {@code mask} contains bits not associated with any of the supported access modes.\n-     *\/\n-    boolean hasAccessModes(int accessModes);\n-\n-    \/**\n-     * Returns the <a href=\"#access-modes\">access modes<\/a> associated with this segment; the result is represented as ORed values from\n-     * {@link #READ}, {@link #WRITE}, {@link #CLOSE}, {@link #SHARE} and {@link #HANDOFF}.\n-     * @return the access modes associated with this segment.\n-     *\/\n-    int accessModes();\n-\n@@ -380,4 +273,3 @@\n-     * Is this a mapped segment? Returns true if this segment is a mapped memory segment,\n-     * created using the {@link #mapFile(Path, long, long, FileChannel.MapMode)} factory, or a buffer segment\n-     * derived from a {@link java.nio.MappedByteBuffer} using the {@link #ofByteBuffer(ByteBuffer)} factory.\n-     * @return {@code true} if this segment is a mapped segment.\n+     * Is this segment read-only?\n+     * @return {@code true}, if this segment is read-only.\n+     * @see #asReadOnly()\n@@ -385,1 +277,1 @@\n-    boolean isMapped();\n+    boolean isReadOnly();\n@@ -388,3 +280,4 @@\n-     * Is this segment alive?\n-     * @return true, if the segment is alive.\n-     * @see MemorySegment#close()\n+     * Obtains a read-only view of this segment. The resulting segment will be identical to this one, but\n+     * attempts to overwrite the contents of the returned segment will cause runtime exceptions.\n+     * @return a read-only view of this segment\n+     * @see #isReadOnly()\n@@ -392,1 +285,1 @@\n-    boolean isAlive();\n+    MemorySegment asReadOnly();\n@@ -395,110 +288,4 @@\n-     * Closes this memory segment. This is a <em>terminal operation<\/em>; as a side-effect, if this operation completes\n-     * without exceptions, this segment will be marked as <em>not alive<\/em>, and subsequent operations on this segment\n-     * will fail with {@link IllegalStateException}.\n-     * <p>\n-     * Depending on the kind of memory segment being closed, calling this method further triggers deallocation of all the resources\n-     * associated with the memory segment.\n-     *\n-     * @apiNote This operation is not idempotent; that is, closing an already closed segment <em>always<\/em> results in an\n-     * exception being thrown. This reflects a deliberate design choice: segment state transitions should be\n-     * manifest in the client code; a failure in any of these transitions reveals a bug in the underlying application\n-     * logic. This is especially useful when reasoning about the lifecycle of dependent segment views (see {@link #asSlice(MemoryAddress)},\n-     * where closing one segment might side-effect multiple segments. In such cases it might in fact not be obvious, looking\n-     * at the code, as to whether a given segment is alive or not.\n-     *\n-     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n-     * thread owning this segment, or if this segment is shared and the segment is concurrently accessed while this method is\n-     * called.\n-     * @throws UnsupportedOperationException if this segment does not support the {@link #CLOSE} access mode.\n-     *\/\n-    void close();\n-\n-    \/**\n-     * Obtains a new confined memory segment backed by the same underlying memory region as this segment. The returned segment will\n-     * be confined on the specified thread, and will feature the same spatial bounds and access modes (see {@link #accessModes()})\n-     * as this segment.\n-     * <p>\n-     * This is a <em>terminal operation<\/em>; as a side-effect, if this operation completes\n-     * without exceptions, this segment will be marked as <em>not alive<\/em>, and subsequent operations on this segment\n-     * will fail with {@link IllegalStateException}.\n-     * <p>\n-     * In case where the owner thread of the returned segment differs from that of this segment, write accesses to this\n-     * segment's content <a href=\"..\/..\/..\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happens-before<\/i><\/a>\n-     * hand-over from the current owner thread to the new owner thread, which in turn <i>happens before<\/i> read accesses\n-     * to the returned segment's contents on the new owner thread.\n-     *\n-     * @param thread the new owner thread\n-     * @return a new confined memory segment whose owner thread is set to {@code thread}.\n-     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n-     * thread owning this segment.\n-     * @throws UnsupportedOperationException if this segment does not support the {@link #HANDOFF} access mode.\n-     *\/\n-    MemorySegment handoff(Thread thread);\n-\n-    \/**\n-     * Obtains a new confined memory segment backed by the same underlying memory region as this segment, but whose\n-     * temporal bounds are controlled by the provided {@link NativeScope} instance.\n-     * <p>\n-     * This is a <em>terminal operation<\/em>;\n-     * as a side-effect, this segment will be marked as <em>not alive<\/em>, and subsequent operations on this segment\n-     * will fail with {@link IllegalStateException}.\n-     * <p>\n-     * The returned segment will feature only {@link MemorySegment#READ} and {@link MemorySegment#WRITE} access modes\n-     * (assuming these were available in the original segment). As such the returned segment cannot be closed directly\n-     * using {@link MemorySegment#close()} - but it will be closed indirectly when this native scope is closed. The\n-     * returned segment will also be confined by the same thread as the provided native scope (see {@link NativeScope#ownerThread()}).\n-     * <p>\n-     * In case where the owner thread of the returned segment differs from that of this segment, write accesses to this\n-     * segment's content <a href=\"..\/..\/..\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happens-before<\/i><\/a>\n-     * hand-over from the current owner thread to the new owner thread, which in turn <i>happens before<\/i> read accesses\n-     * to the returned segment's contents on the new owner thread.\n-     *\n-     * @param nativeScope the native scope.\n-     * @return a new confined memory segment backed by the same underlying memory region as this segment, but whose life-cycle\n-     * is tied to that of {@code nativeScope}.\n-     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n-     * thread owning this segment.\n-     * @throws UnsupportedOperationException if this segment does not support the {@link #HANDOFF} access mode.\n-     *\/\n-    MemorySegment handoff(NativeScope nativeScope);\n-\n-    \/**\n-     * Obtains a new shared memory segment backed by the same underlying memory region as this segment. The returned segment will\n-     * not be confined on any thread and can therefore be accessed concurrently from multiple threads; moreover, the\n-     * returned segment will feature the same spatial bounds and access modes (see {@link #accessModes()})\n-     * as this segment.\n-     * <p>\n-     * This is a <em>terminal operation<\/em>; as a side-effect, if this operation completes\n-     * without exceptions, this segment will be marked as <em>not alive<\/em>, and subsequent operations on this segment\n-     * will fail with {@link IllegalStateException}.\n-     * <p>\n-     * Write accesses to this segment's content <a href=\"..\/..\/..\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happens-before<\/i><\/a>\n-     * hand-over from the current owner thread to the new owner thread, which in turn <i>happens before<\/i> read accesses\n-     * to the returned segment's contents on a new thread.\n-     *\n-     * @return a new memory shared segment backed by the same underlying memory region as this segment.\n-     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n-     * thread owning this segment.\n-     *\/\n-    MemorySegment share();\n-\n-    \/**\n-     * Register this memory segment instance against a {@link Cleaner} object, by returning a new memory segment backed\n-     * by the same underlying memory region as this segment. The returned segment will feature the same confinement,\n-     * spatial bounds and access modes (see {@link #accessModes()}) as this segment. Moreover, the returned segment\n-     * will be associated with the specified {@link Cleaner} object; this allows for the segment to be closed\n-     * as soon as it becomes <em>unreachable<\/em>, which might be helpful in preventing native memory leaks.\n-     * <p>\n-     * This is a <em>terminal operation<\/em>; as a side-effect, if this operation completes\n-     * without exceptions, this segment will be marked as <em>not alive<\/em>, and subsequent operations on this segment\n-     * will fail with {@link IllegalStateException}.\n-     * <p>\n-     * The implicit deallocation behavior associated with the returned segment will be preserved under terminal\n-     * operations such as {@link #handoff(Thread)} and {@link #share()}.\n-     *\n-     * @param cleaner the cleaner object, responsible for implicit deallocation of the returned segment.\n-     * @return a new memory segment backed by the same underlying memory region as this segment, which features\n-     * implicit deallocation.\n-     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n-     * thread owning this segment, or if this segment is already associated with a cleaner.\n-     * @throws UnsupportedOperationException if this segment does not support the {@link #CLOSE} access mode.\n+     * Is this a mapped segment? Returns true if this segment is a mapped memory segment,\n+     * created using the {@link #mapFile(Path, long, long, FileChannel.MapMode)} factory, or a buffer segment\n+     * derived from a {@link java.nio.MappedByteBuffer} using the {@link #ofByteBuffer(ByteBuffer)} factory.\n+     * @return {@code true} if this segment is a mapped segment.\n@@ -506,1 +293,1 @@\n-    MemorySegment registerCleaner(Cleaner cleaner);\n+    boolean isMapped();\n@@ -531,1 +318,1 @@\n-     * @throws UnsupportedOperationException if this segment does not support the {@link #WRITE} access mode\n+     * @throws UnsupportedOperationException if this segment is read-only (see {@link #isReadOnly()}).\n@@ -552,3 +339,1 @@\n-     * @throws UnsupportedOperationException if either the source segment or this segment do not feature required access modes;\n-     * more specifically, {@code src} should feature at least the {@link MemorySegment#READ} access mode,\n-     * while this segment should feature at least the {@link MemorySegment#WRITE} access mode.\n+     * @throws UnsupportedOperationException if this segment is read-only (see {@link #isReadOnly()}).\n@@ -579,2 +364,0 @@\n-     * @throws UnsupportedOperationException if either this segment or the other\n-     * segment does not feature at least the {@link MemorySegment#READ} access mode\n@@ -587,1 +370,1 @@\n-     * (e.g. the segment has access mode {@link #READ} but not {@link #WRITE}), then the resulting buffer is <em>read-only<\/em>\n+     * (e.g. the segment is a read-only segment, see {@link #isReadOnly()}), then the resulting buffer is <em>read-only<\/em>\n@@ -596,3 +379,2 @@\n-     * The life-cycle of the returned buffer will be tied to that of this segment. That means that if the this segment\n-     * is closed (see {@link MemorySegment#close()}, accessing the returned\n-     * buffer will throw an {@link IllegalStateException}.\n+     * The life-cycle of the returned buffer will be tied to that of this segment. That is, accessing the returned buffer\n+     * after the scope associated with this segment has been closed (see {@link ResourceScope#close()}, will throw an {@link IllegalStateException}.\n@@ -600,1 +382,1 @@\n-     * If this segment is <em>shared<\/em>, calling certain I\/O operations on the resulting buffer might result in\n+     * If this segment is associated with a shared scope, calling certain I\/O operations on the resulting buffer might result in\n@@ -611,1 +393,1 @@\n-     * than {@link Integer#MAX_VALUE}, or if the segment does not support the {@link #READ} access mode.\n+     * than {@link Integer#MAX_VALUE}.\n@@ -618,2 +400,2 @@\n-     * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this\n-     * segment's contents cannot be copied into a {@link byte[]} instance, e.g. its size is greater than {@link Integer#MAX_VALUE},\n+     * @throws UnsupportedOperationException if this segment's contents cannot be copied into a {@link byte[]} instance,\n+     * e.g. its size is greater than {@link Integer#MAX_VALUE}.\n@@ -628,3 +410,2 @@\n-     * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this\n-     * segment's contents cannot be copied into a {@link short[]} instance, e.g. because {@code byteSize() % 2 != 0},\n-     * or {@code byteSize() \/ 2 > Integer#MAX_VALUE}.\n+     * @throws UnsupportedOperationException if this segment's contents cannot be copied into a {@link short[]} instance,\n+     * e.g. because {@code byteSize() % 2 != 0}, or {@code byteSize() \/ 2 > Integer#MAX_VALUE}.\n@@ -639,3 +420,2 @@\n-     * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this\n-     * segment's contents cannot be copied into a {@link char[]} instance, e.g. because {@code byteSize() % 2 != 0},\n-     * or {@code byteSize() \/ 2 > Integer#MAX_VALUE}.\n+     * @throws UnsupportedOperationException if this segment's contents cannot be copied into a {@link char[]} instance,\n+     * e.g. because {@code byteSize() % 2 != 0}, or {@code byteSize() \/ 2 > Integer#MAX_VALUE}.\n@@ -650,3 +430,2 @@\n-     * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this\n-     * segment's contents cannot be copied into a {@link int[]} instance, e.g. because {@code byteSize() % 4 != 0},\n-     * or {@code byteSize() \/ 4 > Integer#MAX_VALUE}.\n+     * @throws UnsupportedOperationException if this segment's contents cannot be copied into a {@link int[]} instance,\n+     * e.g. because {@code byteSize() % 4 != 0}, or {@code byteSize() \/ 4 > Integer#MAX_VALUE}.\n@@ -661,3 +440,2 @@\n-     * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this\n-     * segment's contents cannot be copied into a {@link float[]} instance, e.g. because {@code byteSize() % 4 != 0},\n-     * or {@code byteSize() \/ 4 > Integer#MAX_VALUE}.\n+     * @throws UnsupportedOperationException if this segment's contents cannot be copied into a {@link float[]} instance,\n+     * e.g. because {@code byteSize() % 4 != 0}, or {@code byteSize() \/ 4 > Integer#MAX_VALUE}.\n@@ -672,3 +450,2 @@\n-     * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this\n-     * segment's contents cannot be copied into a {@link long[]} instance, e.g. because {@code byteSize() % 8 != 0},\n-     * or {@code byteSize() \/ 8 > Integer#MAX_VALUE}.\n+     * @throws UnsupportedOperationException if this segment's contents cannot be copied into a {@link long[]} instance,\n+     * e.g. because {@code byteSize() % 8 != 0}, or {@code byteSize() \/ 8 > Integer#MAX_VALUE}.\n@@ -683,3 +460,2 @@\n-     * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this\n-     * segment's contents cannot be copied into a {@link double[]} instance, e.g. because {@code byteSize() % 8 != 0},\n-     * or {@code byteSize() \/ 8 > Integer#MAX_VALUE}.\n+     * @throws UnsupportedOperationException if this segment's contents cannot be copied into a {@link double[]} instance,\n+     * e.g. because {@code byteSize() % 8 != 0}, or {@code byteSize() \/ 8 > Integer#MAX_VALUE}.\n@@ -696,3 +472,4 @@\n-     * The segment will feature all <a href=\"#access-modes\">access modes<\/a> (see {@link #ALL_ACCESS}),\n-     * unless the given buffer is {@linkplain ByteBuffer#isReadOnly() read-only} in which case the segment will\n-     * not feature the {@link #WRITE} access mode, and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     * If the buffer is read-only (see {@link ByteBuffer#isReadOnly()}), the resulting segment will also be read-only\n+     * (see {@link #isReadOnly()}). The scope associated with this segment can either be the <em>global<\/em> resource scope\n+     * (see {@link ResourceScope#globalScope()}), in case the buffer has been created independently, or to some other\n+     * (possibly closeable) resource scope, in case the buffer has been obtained using {@link #asByteBuffer()}.\n@@ -700,2 +477,1 @@\n-     * The resulting memory segment keeps a reference to the backing buffer, to ensure it remains <em>reachable<\/em>\n-     * for the life-time of the segment.\n+     * The resulting memory segment keeps a reference to the backing buffer, keeping it <em>reachable<\/em>.\n@@ -704,1 +480,1 @@\n-     * @return a new confined buffer memory segment.\n+     * @return a new buffer memory segment.\n@@ -712,4 +488,1 @@\n-     * <p>\n-     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable<\/em>\n-     * for the life-time of the segment. The segment will feature all <a href=\"#access-modes\">access modes<\/a>\n-     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     * The returned segment's resource scope is set to the <em>global<\/em> resource scope (see {@link ResourceScope#globalScope()}).\n@@ -718,1 +491,1 @@\n-     * @return a new confined array memory segment.\n+     * @return a new array memory segment.\n@@ -726,4 +499,1 @@\n-     * <p>\n-     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable<\/em>\n-     * for the life-time of the segment. The segment will feature all <a href=\"#access-modes\">access modes<\/a>\n-     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     * The returned segment's resource scope is set to the <em>global<\/em> resource scope (see {@link ResourceScope#globalScope()}).\n@@ -732,1 +502,1 @@\n-     * @return a new confined array memory segment.\n+     * @return a new array memory segment.\n@@ -740,4 +510,1 @@\n-     * <p>\n-     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable<\/em>\n-     * for the life-time of the segment. The segment will feature all <a href=\"#access-modes\">access modes<\/a>\n-     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     * The returned segment's resource scope is set to the <em>global<\/em> resource scope (see {@link ResourceScope#globalScope()}).\n@@ -746,1 +513,1 @@\n-     * @return a new confined array memory segment.\n+     * @return a new array memory segment.\n@@ -754,4 +521,1 @@\n-     * <p>\n-     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable<\/em>\n-     * for the life-time of the segment. The segment will feature all <a href=\"#access-modes\">access modes<\/a>\n-     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     * The returned segment's resource scope is set to the <em>global<\/em> resource scope (see {@link ResourceScope#globalScope()}).\n@@ -760,1 +524,1 @@\n-     * @return a new confined array memory segment.\n+     * @return a new array memory segment.\n@@ -768,4 +532,1 @@\n-     * <p>\n-     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable<\/em>\n-     * for the life-time of the segment. The segment will feature all <a href=\"#access-modes\">access modes<\/a>\n-     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     * The returned segment's resource scope is set to the <em>global<\/em> resource scope (see {@link ResourceScope#globalScope()}).\n@@ -774,1 +535,1 @@\n-     * @return a new confined array memory segment.\n+     * @return a new array memory segment.\n@@ -782,4 +543,1 @@\n-     * <p>\n-     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable<\/em>\n-     * for the life-time of the segment. The segment will feature all <a href=\"#access-modes\">access modes<\/a>\n-     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     * The returned segment's resource scope is set to the <em>global<\/em> resource scope (see {@link ResourceScope#globalScope()}).\n@@ -788,1 +546,1 @@\n-     * @return a new confined array memory segment.\n+     * @return a new array memory segment.\n@@ -796,4 +554,1 @@\n-     * <p>\n-     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable<\/em>\n-     * for the life-time of the segment. The segment will feature all <a href=\"#access-modes\">access modes<\/a>\n-     * (see {@link #ALL_ACCESS}).\n+     * The returned segment's resource scope is set to the <em>global<\/em> resource scope (see {@link ResourceScope#globalScope()}).\n@@ -802,1 +557,1 @@\n-     * @return a new confined array memory segment.\n+     * @return a new array memory segment.\n@@ -810,0 +565,3 @@\n+     * The returned segment is associated with a fresh, shared, resource scope which will be automatically closed when\n+     * the segment (or any slices and views derived from it) is no longer in use.\n+     * The scope associated with the returned segment cannot be closed directly e.g. by calling {@link ResourceScope#close()}.\n@@ -817,2 +575,0 @@\n-     * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,\n-     * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.\n@@ -825,0 +581,22 @@\n+        return allocateNative(layout, MemoryScope.createDefault());\n+    }\n+\n+    \/**\n+     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given layout\n+     * and resource scope. A client is responsible make sure that the resource scope associated to the returned segment is closed\n+     * when the segment is no longer in use. Failure to do so will result in off-heap memory leaks.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    allocateNative(layout.bytesSize(), layout.bytesAlignment(), scope);\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n+     *\n+     * @param layout the layout of the off-heap memory block backing the native memory segment.\n+     * @param scope the segment scope.\n+     * @return a new native memory segment.\n+     * @throws IllegalArgumentException if the specified layout has illegal size or alignment constraint.\n+     *\/\n+    static MemorySegment allocateNative(MemoryLayout layout, ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n@@ -826,1 +604,1 @@\n-        return allocateNative(layout.byteSize(), layout.byteAlignment());\n+        return allocateNative(layout.byteSize(), layout.byteAlignment(), scope);\n@@ -831,0 +609,3 @@\n+     * The returned segment is associated with a fresh, shared resource scope, which will be automatically closed when\n+     * the segment (or any slices and views derived from it) is no longer in use.\n+     * The scope associated with the returned segment cannot be closed directly e.g. by calling {@link ResourceScope#close()}.\n@@ -834,1 +615,1 @@\n-allocateNative(bytesSize, 1);\n+    allocateNative(bytesSize, 1);\n@@ -838,2 +619,0 @@\n-     * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,\n-     * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.\n@@ -842,1 +621,1 @@\n-     * @return a new confined native memory segment.\n+     * @return a new native memory segment.\n@@ -850,1 +629,72 @@\n-     * Creates a new confined mapped memory segment that models a memory-mapped region of a file from a given path.\n+     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size (in bytes)\n+     * and resource scope. A client is responsible make sure that the resource scope associated to the returned segment is closed\n+     * when the segment is no longer in use. Failure to do so will result in off-heap memory leaks.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    allocateNative(bytesSize, 1, scope);\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n+     *\n+     * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.\n+     * @param scope the segment scope.\n+     * @return a new native memory segment.\n+     * @throws IllegalArgumentException if {@code bytesSize < 0}.\n+     *\/\n+    static MemorySegment allocateNative(long bytesSize, ResourceScope scope) {\n+        return allocateNative(bytesSize, 1, scope);\n+    }\n+\n+    \/**\n+     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size\n+     * and alignment constraints (in bytes). The returned segment is associated with a fresh, shared resource scope,\n+     * which will be automatically closed when the segment (or any slices and views derived from it) is no longer in use.\n+     * The scope associated with the returned segment cannot be closed directly e.g. by calling {@link ResourceScope#close()}.\n+     *\n+     * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n+     *\n+     * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.\n+     * @param alignmentBytes the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.\n+     * @return a new native memory segment.\n+     * @throws IllegalArgumentException if {@code bytesSize < 0}, {@code alignmentBytes < 0}, or if {@code alignmentBytes}\n+     * is not a power of 2.\n+     *\/\n+    static MemorySegment allocateNative(long bytesSize, long alignmentBytes) {\n+        return allocateNative(bytesSize, alignmentBytes, MemoryScope.createDefault());\n+    }\n+\n+    \/**\n+     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size\n+     * (in bytes), alignment constraint (in bytes) and resource scope. A client is responsible make sure that the resource\n+     * scope associated to the returned segment is closed when the segment is no longer in use.\n+     * Failure to do so will result in off-heap memory leaks.\n+     *\n+     * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n+     *\n+     * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.\n+     * @param alignmentBytes the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.\n+     * @param scope the segment scope.\n+     * @return a new native memory segment.\n+     * @throws IllegalArgumentException if {@code bytesSize < 0}, {@code alignmentBytes < 0}, or if {@code alignmentBytes}\n+     * is not a power of 2.\n+     *\/\n+    static MemorySegment allocateNative(long bytesSize, long alignmentBytes, ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n+        if (bytesSize <= 0) {\n+            throw new IllegalArgumentException(\"Invalid allocation size : \" + bytesSize);\n+        }\n+\n+        if (alignmentBytes < 0 ||\n+                ((alignmentBytes & (alignmentBytes - 1)) != 0L)) {\n+            throw new IllegalArgumentException(\"Invalid alignment constraint : \" + alignmentBytes);\n+        }\n+\n+        return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, alignmentBytes, (MemoryScope) scope);\n+    }\n+\n+    \/**\n+     * Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.\n+     * The returned segment is associated with a fresh, shared resource scope, which will be automatically closed when\n+     * the segment (or any slices and views derived from it) is no longer in use. The scope associated with the returned\n+     * segment cannot be closed directly e.g. by calling {@link ResourceScope#close()}.\n@@ -852,3 +702,33 @@\n-     * The segment will feature all <a href=\"#access-modes\">access modes<\/a> (see {@link #ALL_ACCESS}),\n-     * unless the given mapping mode is {@linkplain FileChannel.MapMode#READ_ONLY READ_ONLY}, in which case\n-     * the segment will not feature the {@link #WRITE} access mode, and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    mapFile(path, bytesOffset, bytesSize, mapMode, ResourceScope.ofShared(Cleaner.create()));\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @implNote When obtaining a mapped segment from a newly created file, the initialization state of the contents of the block\n+     * of mapped memory associated with the returned mapped memory segment is unspecified and should not be relied upon.\n+     *\n+     * @param path the path to the file to memory map.\n+     * @param bytesOffset the offset (expressed in bytes) within the file at which the mapped segment is to start.\n+     * @param bytesSize the size (in bytes) of the mapped memory backing the memory segment.\n+     * @param mapMode a file mapping mode, see {@link FileChannel#map(FileChannel.MapMode, long, long)}; the chosen mapping mode\n+     *                might affect the behavior of the returned memory mapped segment (see {@link MappedMemorySegments#force(MemorySegment)}).\n+     * @return a new mapped memory segment.\n+     * @throws IllegalArgumentException if {@code bytesOffset < 0}.\n+     * @throws IllegalArgumentException if {@code bytesSize < 0}.\n+     * @throws UnsupportedOperationException if an unsupported map mode is specified, or if the {@code path} is associated\n+     * with a provider that does not support creating file channels.\n+     * @throws IOException if the specified path does not point to an existing file, or if some other I\/O error occurs.\n+     * @throws  SecurityException If a security manager is installed and it denies an unspecified permission required by the implementation.\n+     * In the case of the default provider, the {@link SecurityManager#checkRead(String)} method is invoked to check\n+     * read access if the file is opened for reading. The {@link SecurityManager#checkWrite(String)} method is invoked to check\n+     * write access if the file is opened for writing.\n+     *\/\n+    static MemorySegment mapFile(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {\n+        return mapFile(path, bytesOffset, bytesSize, mapMode, MemoryScope.createDefault());\n+    }\n+\n+    \/**\n+     * Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.\n+     * <p>\n+     * If the specified mapping mode is {@linkplain FileChannel.MapMode#READ_ONLY READ_ONLY}, the resulting segment\n+     * will be read-only (see {@link #isReadOnly()}).\n@@ -878,0 +758,1 @@\n+     * @param scope the segment scope.\n@@ -888,30 +769,3 @@\n-    static MemorySegment mapFile(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {\n-        return MappedMemorySegmentImpl.makeMappedSegment(path, bytesOffset, bytesSize, mapMode);\n-    }\n-\n-    \/**\n-     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size and\n-     * alignment constraint (in bytes). The segment will feature all <a href=\"#access-modes\">access modes<\/a>\n-     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n-     *\n-     * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n-     * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,\n-     * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.\n-     *\n-     * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.\n-     * @param alignmentBytes the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.\n-     * @return a new confined native memory segment.\n-     * @throws IllegalArgumentException if {@code bytesSize < 0}, {@code alignmentBytes < 0}, or if {@code alignmentBytes}\n-     * is not a power of 2.\n-     *\/\n-    static MemorySegment allocateNative(long bytesSize, long alignmentBytes) {\n-        if (bytesSize <= 0) {\n-            throw new IllegalArgumentException(\"Invalid allocation size : \" + bytesSize);\n-        }\n-\n-        if (alignmentBytes < 0 ||\n-                ((alignmentBytes & (alignmentBytes - 1)) != 0L)) {\n-            throw new IllegalArgumentException(\"Invalid alignment constraint : \" + alignmentBytes);\n-        }\n-\n-        return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, alignmentBytes);\n+    static MemorySegment mapFile(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode, ResourceScope scope) throws IOException {\n+        Objects.requireNonNull(scope);\n+        return MappedMemorySegmentImpl.makeMappedSegment(path, bytesOffset, bytesSize, mapMode, (MemoryScope) scope);\n@@ -921,1 +775,1 @@\n-     * Returns a shared native memory segment whose base address is {@link MemoryAddress#NULL} and whose size is {@link Long#MAX_VALUE}.\n+     * Returns a native memory segment whose base address is {@link MemoryAddress#NULL} and whose size is {@link Long#MAX_VALUE}.\n@@ -923,1 +777,1 @@\n-     * The segment will feature the {@link #READ} and {@link #WRITE} <a href=\"#access-modes\">access modes<\/a>.\n+     * The returned segment is associated with the <em>global<\/em> resource scope (see {@link ResourceScope#globalScope()}).\n@@ -927,2 +781,0 @@\n-                 .withOwnerThread(null)\n-                 .withAccessModes(READ | WRITE);\n@@ -943,45 +795,0 @@\n-\n-    \/\/ access mode masks\n-\n-    \/**\n-     * Read access mode; read operations are supported by a segment which supports this access mode.\n-     * @see MemorySegment#accessModes()\n-     * @see MemorySegment#withAccessModes(int)\n-     *\/\n-    int READ = 1;\n-\n-    \/**\n-     * Write access mode; write operations are supported by a segment which supports this access mode.\n-     * @see MemorySegment#accessModes()\n-     * @see MemorySegment#withAccessModes(int)\n-     *\/\n-    int WRITE = READ << 1;\n-\n-    \/**\n-     * Close access mode; calling {@link #close()} is supported by a segment which supports this access mode.\n-     * @see MemorySegment#accessModes()\n-     * @see MemorySegment#withAccessModes(int)\n-     *\/\n-    int CLOSE = WRITE << 1;\n-\n-    \/**\n-     * Share access mode; this segment support sharing with threads other than the owner thread (see {@link #share()}).\n-     * @see MemorySegment#accessModes()\n-     * @see MemorySegment#withAccessModes(int)\n-     *\/\n-    int SHARE = CLOSE << 1;\n-\n-    \/**\n-     * Handoff access mode; this segment support serial thread-confinement via thread ownership changes\n-     * (see {@link #handoff(NativeScope)} and {@link #handoff(Thread)}).\n-     * @see MemorySegment#accessModes()\n-     * @see MemorySegment#withAccessModes(int)\n-     *\/\n-    int HANDOFF = SHARE << 1;\n-\n-    \/**\n-     * Default access mode; this is a union of all the access modes supported by memory segments.\n-     * @see MemorySegment#accessModes()\n-     * @see MemorySegment#withAccessModes(int)\n-     *\/\n-    int ALL_ACCESS = READ | WRITE | CLOSE | SHARE | HANDOFF;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":234,"deletions":427,"binary":false,"changes":661,"status":"modified"},{"patch":"@@ -1,472 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package jdk.incubator.foreign;\n-\n-import jdk.internal.foreign.AbstractMemorySegmentImpl;\n-import jdk.internal.foreign.AbstractNativeScope;\n-import jdk.internal.foreign.Utils;\n-\n-import java.lang.invoke.VarHandle;\n-import java.lang.reflect.Array;\n-import java.nio.ByteOrder;\n-import java.util.Objects;\n-import java.util.OptionalLong;\n-import java.util.function.Function;\n-import java.util.stream.Stream;\n-\n-\/**\n- * A native scope is an abstraction which provides shared temporal bounds for one or more allocations, backed\n- * by off-heap memory. Native scopes can be either <em>bounded<\/em> or <em>unbounded<\/em>, depending on whether the size\n- * of the native scope is known statically. If an application knows before-hand how much memory it needs to allocate,\n- * then using a <em>bounded<\/em> native scope will typically provide better performance than independently allocating the memory\n- * for each value (e.g. using {@link MemorySegment#allocateNative(long)}), or using an <em>unbounded<\/em> native scope.\n- * For this reason, using a bounded native scope is recommended in cases where programs might need to emulate native stack allocation.\n- * <p>\n- * Allocation scopes are thread-confined (see {@link #ownerThread()}; as such, the resulting {@link MemorySegment} instances\n- * returned by the native scope will be backed by memory segments confined by the same owner thread as the native scope's\n- * owner thread.\n- * <p>\n- * To allow for more usability, it is possible for a native scope to reclaim ownership of an existing memory segment\n- * (see {@link MemorySegment#handoff(NativeScope)}). This might be useful to allow one or more segments which were independently\n- * created to share the same life-cycle as a given native scope - which in turns enables a client to group all memory\n- * allocation and usage under a single <em>try-with-resources block<\/em>.\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n- * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n- *\n- * @apiNote In the future, if the Java language permits, {@link NativeScope}\n- * may become a {@code sealed} interface, which would prohibit subclassing except by\n- * explicitly permitted types.\n- *\/\n-public interface NativeScope extends AutoCloseable {\n-\n-    \/**\n-     * If this native scope is bounded, returns the size, in bytes, of this native scope.\n-     * @return the size, in bytes, of this native scope (if available).\n-     *\/\n-    OptionalLong byteSize();\n-\n-    \/**\n-     * The thread owning this native scope.\n-     * @return the thread owning this native scope.\n-     *\/\n-    Thread ownerThread();\n-\n-    \/**\n-     * Returns the number of allocated bytes in this native scope.\n-     * @return the number of allocated bytes in this native scope.\n-     *\/\n-    long allocatedBytes();\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given byte value.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @param value the value to be set on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < layout.byteSize()}.\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a byte value.\n-     *\/\n-    default MemorySegment allocate(ValueLayout layout, byte value) {\n-        Objects.requireNonNull(layout);\n-        VarHandle handle = layout.varHandle(byte.class);\n-        MemorySegment addr = allocate(layout);\n-        handle.set(addr, value);\n-        return addr;\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given char value.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @param value the value to be set on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < layout.byteSize()}.\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a char value.\n-     *\/\n-    default MemorySegment allocate(ValueLayout layout, char value) {\n-        Objects.requireNonNull(layout);\n-        VarHandle handle = layout.varHandle(char.class);\n-        MemorySegment addr = allocate(layout);\n-        handle.set(addr, value);\n-        return addr;\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given short value.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @param value the value to be set on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < layout.byteSize()}.\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a short value.\n-     *\/\n-    default MemorySegment allocate(ValueLayout layout, short value) {\n-        Objects.requireNonNull(layout);\n-        VarHandle handle = layout.varHandle(short.class);\n-        MemorySegment addr = allocate(layout);\n-        handle.set(addr, value);\n-        return addr;\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given int value.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @param value the value to be set on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < layout.byteSize()}.\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a int value.\n-     *\/\n-    default MemorySegment allocate(ValueLayout layout, int value) {\n-        Objects.requireNonNull(layout);\n-        VarHandle handle = layout.varHandle(int.class);\n-        MemorySegment addr = allocate(layout);\n-        handle.set(addr, value);\n-        return addr;\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given float value.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @param value the value to be set on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < layout.byteSize()}.\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a float value.\n-     *\/\n-    default MemorySegment allocate(ValueLayout layout, float value) {\n-        Objects.requireNonNull(layout);\n-        VarHandle handle = layout.varHandle(float.class);\n-        MemorySegment addr = allocate(layout);\n-        handle.set(addr, value);\n-        return addr;\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given long value.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @param value the value to be set on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < layout.byteSize()}.\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a long value.\n-     *\/\n-    default MemorySegment allocate(ValueLayout layout, long value) {\n-        Objects.requireNonNull(layout);\n-        VarHandle handle = layout.varHandle(long.class);\n-        MemorySegment addr = allocate(layout);\n-        handle.set(addr, value);\n-        return addr;\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given double value.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @param value the value to be set on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < layout.byteSize()}.\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a double value.\n-     *\/\n-    default MemorySegment allocate(ValueLayout layout, double value) {\n-        Objects.requireNonNull(layout);\n-        VarHandle handle = layout.varHandle(double.class);\n-        MemorySegment addr = allocate(layout);\n-        handle.set(addr, value);\n-        return addr;\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given address value\n-     * (expressed as an {@link Addressable} instance).\n-     * The address value might be narrowed according to the platform address size (see {@link MemoryLayouts#ADDRESS}).\n-     * The segment returned by this method cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @param value the value to be set on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < layout.byteSize()}.\n-     * @throws IllegalArgumentException if {@code layout.byteSize() != MemoryLayouts.ADDRESS.byteSize()}.\n-     *\/\n-    default MemorySegment allocate(ValueLayout layout, Addressable value) {\n-        Objects.requireNonNull(value);\n-        Objects.requireNonNull(layout);\n-        if (MemoryLayouts.ADDRESS.byteSize() != layout.byteSize()) {\n-            throw new IllegalArgumentException(\"Layout size mismatch - \" + layout.byteSize() + \" != \" + MemoryLayouts.ADDRESS.byteSize());\n-        }\n-        switch ((int)layout.byteSize()) {\n-            case 4: return allocate(layout, (int)value.address().toRawLongValue());\n-            case 8: return allocate(layout, value.address().toRawLongValue());\n-            default: throw new UnsupportedOperationException(\"Unsupported pointer size\"); \/\/ should not get here\n-        }\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given byte array.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param array the array to be copied on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < (elementLayout.byteSize() * array.length)}.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a byte value.\n-     *\/\n-    default MemorySegment allocateArray(ValueLayout elementLayout, byte[] array) {\n-        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given short array.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param array the array to be copied on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < (elementLayout.byteSize() * array.length)}.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a short value.\n-     *\/\n-    default MemorySegment allocateArray(ValueLayout elementLayout, short[] array) {\n-        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given char array.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param array the array to be copied on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < (elementLayout.byteSize() * array.length)}.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a char value.\n-     *\/\n-    default MemorySegment allocateArray(ValueLayout elementLayout, char[] array) {\n-        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given int array.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param array the array to be copied on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < (elementLayout.byteSize() * array.length)}.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a int value.\n-     *\/\n-    default MemorySegment allocateArray(ValueLayout elementLayout, int[] array) {\n-        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given float array.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param array the array to be copied on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < (elementLayout.byteSize() * array.length)}.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a float value.\n-     *\/\n-    default MemorySegment allocateArray(ValueLayout elementLayout, float[] array) {\n-        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given long array.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param array the array to be copied on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < (elementLayout.byteSize() * array.length)}.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a long value.\n-     *\/\n-    default MemorySegment allocateArray(ValueLayout elementLayout, long[] array) {\n-        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given double array.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param array the array to be copied on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < (elementLayout.byteSize() * array.length)}.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a double value.\n-     *\/\n-    default MemorySegment allocateArray(ValueLayout elementLayout, double[] array) {\n-        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given address array.\n-     * The address value of each array element might be narrowed according to the platform address size (see {@link MemoryLayouts#ADDRESS}).\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param array the array to be copied on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < (elementLayout.byteSize() * array.length)}.\n-     * @throws IllegalArgumentException if {@code layout.byteSize() != MemoryLayouts.ADDRESS.byteSize()}.\n-     *\/\n-    default MemorySegment allocateArray(ValueLayout elementLayout, Addressable[] array) {\n-        Objects.requireNonNull(elementLayout);\n-        Objects.requireNonNull(array);\n-        Stream.of(array).forEach(Objects::requireNonNull);\n-        if (MemoryLayouts.ADDRESS.byteSize() != elementLayout.byteSize()) {\n-            throw new IllegalArgumentException(\"Layout size mismatch - \" + elementLayout.byteSize() + \" != \" + MemoryLayouts.ADDRESS.byteSize());\n-        }\n-        switch ((int)elementLayout.byteSize()) {\n-            case 4: return copyArrayWithSwapIfNeeded(Stream.of(array)\n-                            .mapToInt(a -> (int)a.address().toRawLongValue()).toArray(),\n-                            elementLayout, MemorySegment::ofArray);\n-            case 8: return copyArrayWithSwapIfNeeded(Stream.of(array)\n-                            .mapToLong(a -> a.address().toRawLongValue()).toArray(),\n-                            elementLayout, MemorySegment::ofArray);\n-            default: throw new UnsupportedOperationException(\"Unsupported pointer size\"); \/\/ should not get here\n-        }\n-    }\n-\n-    private <Z> MemorySegment copyArrayWithSwapIfNeeded(Z array, ValueLayout elementLayout,\n-                                                        Function<Z, MemorySegment> heapSegmentFactory) {\n-        Objects.requireNonNull(array);\n-        Objects.requireNonNull(elementLayout);\n-        Utils.checkPrimitiveCarrierCompat(array.getClass().componentType(), elementLayout);\n-        MemorySegment addr = allocate(MemoryLayout.ofSequence(Array.getLength(array), elementLayout));\n-        if (elementLayout.byteSize() == 1 || (elementLayout.order() == ByteOrder.nativeOrder())) {\n-            addr.copyFrom(heapSegmentFactory.apply(array));\n-        } else {\n-            ((AbstractMemorySegmentImpl)addr).copyFromSwap(heapSegmentFactory.apply(array), elementLayout.byteSize());\n-        }\n-        return addr;\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout. The segment returned by this method is\n-     * associated with a segment which cannot be closed. Moreover, the returned segment must conform to the layout alignment constraints.\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < layout.byteSize()}.\n-     *\/\n-    default MemorySegment allocate(MemoryLayout layout) {\n-        Objects.requireNonNull(layout);\n-        return allocate(layout.byteSize(), layout.byteAlignment());\n-    }\n-\n-    \/**\n-     * Allocate a block of memory corresponding to an array with given element layout and size.\n-     * The segment returned by this method is associated with a segment which cannot be closed.\n-     * Moreover, the returned segment must conform to the layout alignment constraints. This is equivalent to the\n-     * following code:\n-     * <pre>{@code\n-    allocate(MemoryLayout.ofSequence(size, elementLayout));\n-     * }<\/pre>\n-     * @param elementLayout the array element layout.\n-     * @param count the array element count.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < (elementLayout.byteSize() * count)}.\n-     *\/\n-    default MemorySegment allocateArray(MemoryLayout elementLayout, long count) {\n-        Objects.requireNonNull(elementLayout);\n-        return allocate(MemoryLayout.ofSequence(count, elementLayout));\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given size. The segment returned by this method is\n-     * associated with a segment which cannot be closed. Moreover, the returned segment must be aligned to {@code size}.\n-     * @param bytesSize the size (in bytes) of the block of memory to be allocated.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if\n-     * {@code limit() - size() < bytesSize}.\n-     *\/\n-    default MemorySegment allocate(long bytesSize) {\n-        return allocate(bytesSize, bytesSize);\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given size and alignment constraint.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover,\n-     * the returned segment must be aligned to {@code alignment}.\n-     * @param bytesSize the size (in bytes) of the block of memory to be allocated.\n-     * @param bytesAlignment the alignment (in bytes) of the block of memory to be allocated.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if\n-     * {@code limit() - size() < bytesSize}.\n-     *\/\n-    MemorySegment allocate(long bytesSize, long bytesAlignment);\n-\n-    \/**\n-     * Close this native scope; calling this method will render any segment obtained through this native scope\n-     * unusable and might release any backing memory resources associated with this native scope.\n-     *\/\n-    @Override\n-    void close();\n-\n-    \/**\n-     * Creates a new bounded native scope, backed by off-heap memory.\n-     * @param size the size of the native scope.\n-     * @return a new bounded native scope, with given size (in bytes).\n-     *\/\n-    static NativeScope boundedScope(long size) {\n-        return new AbstractNativeScope.BoundedNativeScope(size);\n-    }\n-\n-    \/**\n-     * Creates a new unbounded native scope, backed by off-heap memory.\n-     * @return a new unbounded native scope.\n-     *\/\n-    static NativeScope unboundedScope() {\n-        return new AbstractNativeScope.UnboundedNativeScope();\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/NativeScope.java","additions":0,"deletions":472,"binary":false,"changes":472,"status":"deleted"},{"patch":"@@ -0,0 +1,262 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.foreign;\n+\n+import jdk.internal.foreign.MemoryScope;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.ref.Cleaner;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Spliterator;\n+\n+\/**\n+ * A resource scope manages the lifecycle of one or more resources. Resources (e.g. {@link MemorySegment}) associated\n+ * with a resource scope can only be accessed while the resource scope is <em>alive<\/em> (see {@link #isAlive()}),\n+ * and by the thread associated with the resource scope (if any).\n+ *\n+ * <h2>Explicit deallocation<\/h2>\n+ *\n+ * Resource scopes created using one of the factories in this class can be closed explicitly (see {@link ResourceScope#close()}).\n+ * When a resource scope is closed, it is no longer <em>alive<\/em> (see {@link #isAlive()}, and subsequent operation on\n+ * resources derived from that scope (e.g. attempting to access a {@link MemorySegment} instance) will fail with {@link IllegalStateException}.\n+ * <p>\n+ * Closing a resource scope will cause all the cleanup actions associated with that scope (see {@link #addOnClose(Runnable)}) to be called.\n+ * Moreover, closing a resource scope might trigger the releasing of the underlying memory resources associated with said scope; for instance:\n+ * <ul>\n+ *     <li>closing the scope associated with a native memory segment results in <em>freeing<\/em> the native memory associated with it\n+ *     (see {@link MemorySegment#allocateNative(long, ResourceScope)}, or {@link SegmentAllocator#arenaUnbounded(ResourceScope)})<\/li>\n+ *     <li>closing the scope associated with a mapped memory segment results in the backing memory-mapped file to be unmapped\n+ *     (see {@link MemorySegment#mapFile(Path, long, long, FileChannel.MapMode, ResourceScope)})<\/li>\n+ *     <li>closing the scope associated with an upcall stub results in releasing the stub\n+ *     (see {@link CLinker#upcallStub(MethodHandle, FunctionDescriptor, ResourceScope)}<\/li>\n+ * <\/ul>\n+ *\n+ * <h2>Implicit deallocation<\/h2>\n+ *\n+ * Resource scopes can be associated with a {@link Cleaner} instance (see {@link #ofConfined(Cleaner)}) - we call these\n+ * resource scopes <em>managed<\/em> resource scopes. A managed resource scope is closed automatically once the scope instance\n+ * becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n+ * <p>\n+ * Managed resource scopes can still be closed explicitly (see {@link #close()}); this can be useful to allow for predictable,\n+ * deterministic resource deallocation, while still prevent accidental native memory leaks. In case a managed resource\n+ * scope is closed explicitly, no further action will be taken when the scope becomes unreachable; that is, cleanup actions\n+ * (see {@link #addOnClose(Runnable)}) associated with a resource scope, whether managed or not, are called <em>exactly once<\/em>.\n+ *\n+ * <h2><a id = \"thread-confinement\">Thread confinement<\/a><\/h2>\n+ *\n+ * Resource scopes can be further divided into two categories: <em>thread-confined<\/em> resource scopes, and <em>shared<\/em>\n+ * resource scopes.\n+ * <p>\n+ * Confined resource scopes (see {@link #ofConfined()}), support strong thread-confinement guarantees. Upon creation,\n+ * they are assigned an <em>owner thread<\/em>, typically the thread which initiated the creation operation (see {@link #ownerThread()}).\n+ * After creating a confined resource scope, only the owner thread will be allowed to directly manipulate the resources\n+ * associated with this resource scope. Any attempt to perform resource access from a thread other than the\n+ * owner thread will result in a runtime failure.\n+ * <p>\n+ * Shared resource scopes (see {@link #ofShared()}), support strong thread-confinement guarantees. A shared resource scope\n+ * has no owner thread; as such resources associated with this scope can be accessed by multiple threads. This might be useful\n+ * when multiple threads need to access the same resource concurrently (e.g. in the case of parallel processing). For instance, a client\n+ * might obtain a {@link Spliterator} from a shared segment, which can then be used to slice the segment and allow multiple\n+ * threads to work in parallel on disjoint segment slices. The following code can be used to sum all int values in a memory segment in parallel:\n+ *\n+ * <blockquote><pre>{@code\n+SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);\n+try (ResourceScope scope = ResourceScope.ofShared()) {\n+    MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT, scope);\n+    VarHandle VH_int = SEQUENCE_LAYOUT.elementLayout().varHandle(int.class);\n+    int sum = StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)\n+        .mapToInt(s -> (int)VH_int.get(s.address()))\n+        .sum();\n+}\n+ * }<\/pre><\/blockquote>\n+ *\n+ * <p>\n+ * When using shared resource scopes, clients should make sure that no other thread is accessing the segment while\n+ * the segment is being closed. If one or more threads attempts to access a segment concurrently while the\n+ * segment is being closed, an exception might occur on both the accessing and the closing threads. Clients should\n+ * refrain from attempting to close a shared resource scope repeatedly (e.g. keep calling {@link #close()} until no exception is thrown);\n+ * such exceptions should instead be seen as an indication that the client code is lacking appropriate synchronization between the threads\n+ * accessing\/closing the resources associated with the shared resource scope.\n+ *\n+ * <h2>Scope handles<\/h2>\n+ *\n+ * Resource scopes can be made <em>non-closeable<\/em> by acquiring one or more resource scope <em>handles<\/em> (see\n+ * {@link #acquire()}. A resource scope handle can be used to make sure that its corresponding scope cannot be closed\n+ * (either explicitly, or implicitly) for a certain period of time - e.g. when one or more resources associated with\n+ * the parent scope need to be accessed. A resource scope can be acquired multiple times; the resource scope can only be\n+ * closed <em>after<\/em> all the handles acquired against that scope have been closed (see {@link Handle#close()}).\n+ * This can be useful when clients need to perform a critical operation on a memory segment, during which they have\n+ * to ensure that the segment will not be released; this can be done as follows:\n+ *\n+ * <blockquote><pre>{@code\n+MemorySegment segment = ...\n+try (ResourceScope.Handle segmentHandle = segment.scope().acquire()) {\n+   <critical operation on segment>\n+} \/\/ release scope handle\n+ * }<\/pre><\/blockquote>\n+ *\n+ * @apiNote In the future, if the Java language permits, {@link ResourceScope}\n+ * may become a {@code sealed} interface, which would prohibit subclassing except by other explicitly permitted subtypes.\n+ *\n+ * @implSpec\n+ * Implementations of this interface are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ *\/\n+public interface ResourceScope extends AutoCloseable {\n+    \/**\n+     * Is this resource scope alive?\n+     * @return true, if this resource scope is alive.\n+     * @see ResourceScope#close()\n+     *\/\n+    boolean isAlive();\n+\n+    \/**\n+     * The thread owning this resource scope.\n+     * @return the thread owning this resource scope, or {@code null} if this resource scope is shared.\n+     *\/\n+    Thread ownerThread();\n+\n+    \/**\n+     * Closes this resource scope. As a side-effect, if this operation completes without exceptions, this scope will be marked\n+     * as <em>not alive<\/em>, and subsequent operations on resources associated with this scope will fail with {@link IllegalStateException}.\n+     * Additionally, upon successful closure, all native resources associated with this resource scope will be released.\n+     *\n+     * @apiNote This operation is not idempotent; that is, closing an already closed resource scope <em>always<\/em> results in an\n+     * exception being thrown. This reflects a deliberate design choice: resource scope state transitions should be\n+     * manifest in the client code; a failure in any of these transitions reveals a bug in the underlying application\n+     * logic.\n+     *\n+     * @throws IllegalStateException if one of the following condition is met:\n+     * <ul>\n+     *     <li>this resource scope is not <em>alive<\/em>\n+     *     <li>this resource scope is confined, and this method is called from a thread other than the thread owning this resource scope<\/li>\n+     *     <li>this resource scope is shared and a resource associated with this scope is accessed while this method is called<\/li>\n+     *     <li>one or more handles (see {@link #acquire()}) associated with this resource scope have not been closed<\/li>\n+     * <\/ul>\n+     * @throws UnsupportedOperationException if the {@code close} operation is not supported by this resource scope. This\n+     * is the case for the resource scope returned by {@link #globalScope()}, or the resource scopes associated to\n+     * memory segments created using certain factories (such as {@link MemorySegment#allocateNative(long)}).\n+     *\/\n+    void close();\n+\n+    \/**\n+     * Add a custom cleanup action which will be executed when the resource scope is closed.\n+     * @param runnable the custom cleanup action to be associated with this scope.\n+     * @throws IllegalStateException if this scope has already been closed.\n+     *\/\n+    void addOnClose(Runnable runnable);\n+\n+    \/**\n+     * Make this resource scope non-closeable by acquiring a new resource scope handle. This scope cannot be closed unless all its\n+     * acquired handles have been closed first.\n+     * @return a resource scope handle.\n+     *\/\n+    Handle acquire();\n+\n+    \/**\n+     * An abstraction modelling resource scope handle. A resource scope handle is typically acquired by clients (see\n+     * {@link #acquire()} in order to prevent the resource scope from being closed while executing a certain operation.\n+     * A resource scope handle features a method (see {@link #close()}) which can be used by clients to release the handle.\n+     *\/\n+    interface Handle extends AutoCloseable {\n+\n+        \/**\n+         * Release this handle on the resource scope associated with this instance. This method is idempotent,\n+         * that is, closing an already closed handle has no effect.\n+         *\/\n+        @Override\n+        void close();\n+    }\n+\n+    \/**\n+     * Create a new confined scope. The resulting scope is closeable, and is not managed by a {@link Cleaner}.\n+     * @return a new confined scope.\n+     *\/\n+    static ResourceScope ofConfined() {\n+        return ofConfined(null, null);\n+    }\n+\n+    \/**\n+     * Create a new confined scope managed by a {@link Cleaner}.\n+     * @param cleaner the cleaner to be associated with the returned scope.\n+     * @return a new confined scope, managed by {@code cleaner}.\n+     * @throws NullPointerException if {@code cleaner == null}.\n+     *\/\n+    static ResourceScope ofConfined(Cleaner cleaner) {\n+        Objects.requireNonNull(cleaner);\n+        return ofConfined(null, cleaner);\n+    }\n+\n+    \/**\n+     * Create a new confined scope. The resulting scope might be managed by a {@link Cleaner} (where provided).\n+     * An optional attachment can be associated with the resulting scope.\n+     * @param attachment an attachment object which is kept alive by the returned resource scope (can be {@code null}).\n+     * @param cleaner the cleaner to be associated with the returned scope. Can be {@code null}.\n+     * @return a new confined scope, managed by {@code cleaner} (where provided).\n+     *\/\n+    static ResourceScope ofConfined(Object attachment, Cleaner cleaner) {\n+        return MemoryScope.createConfined(attachment, cleaner);\n+    }\n+\n+    \/**\n+     * Create a new shared scope. The resulting scope is closeable, and is not managed by a {@link Cleaner}.\n+     * @return a new shared scope.\n+     *\/\n+    static ResourceScope ofShared() {\n+        return ofShared(null, null);\n+    }\n+\n+    \/**\n+     * Create a new shared scope managed by a {@link Cleaner}.\n+     * @param cleaner the cleaner to be associated with the returned scope.\n+     * @return a new shared scope, managed by {@code cleaner}.\n+     * @throws NullPointerException if {@code cleaner == null}.\n+     *\/\n+    static ResourceScope ofShared(Cleaner cleaner) {\n+        Objects.requireNonNull(cleaner);\n+        return ofShared(null, cleaner);\n+    }\n+\n+    \/**\n+     * Create a new shared scope. The resulting scope might be managed by a {@link Cleaner} (where provided).\n+     * An optional attachment can be associated with the resulting scope.\n+     * @param attachment an attachment object which is kept alive by the returned resource scope (can be {@code null}).\n+     * @param cleaner the cleaner to be associated with the returned scope. Can be {@code null}.\n+     * @return a new shared scope, managed by {@code cleaner} (where provided).\n+     *\/\n+    static ResourceScope ofShared(Object attachment, Cleaner cleaner) {\n+        return MemoryScope.createShared(attachment, cleaner);\n+    }\n+\n+    \/**\n+     * A non-closeable, shared, global scope which is assumed to be always alive.\n+     * @return the global scope.\n+     *\/\n+    static ResourceScope globalScope() {\n+        return MemoryScope.GLOBAL;\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ResourceScope.java","additions":262,"deletions":0,"binary":false,"changes":262,"status":"added"},{"patch":"@@ -0,0 +1,490 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.foreign;\n+\n+import jdk.internal.foreign.ArenaAllocator;\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.Utils;\n+\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Array;\n+import java.nio.ByteOrder;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+\/**\n+ *  This interface models a memory allocator. Clients implementing this interface\n+ *  must implement the {@link #allocate(long, long)} method. This interface defines several default methods\n+ *  which can be useful to create segments from several kinds of Java values such as primitives and arrays.\n+ *  This interface can be seen as a thin wrapper around the basic capabilities for creating native segments\n+ *  (e.g. {@link MemorySegment#allocateNative(long, long)}); since {@link SegmentAllocator} is a <em>functional interface<\/em>,\n+ *  clients can easily obtain a native allocator instance as follows:\n+ * <blockquote><pre>{@code\n+SegmentAllocator defaultAllocator = MemorySegment::allocateNative;\n+ * }<\/pre><\/blockquote>\n+ * This interface provides a factory, namely {@link SegmentAllocator#of(ResourceScope)} which can be used to obtain\n+ * a <em>scoped<\/em> allocator, that is, an allocator which creates segment bound by a given scope. This can be useful\n+ * when working inside a <em>try-with-resources<\/em> construct:\n+ *\n+ * <blockquote><pre>{@code\n+try (ResourceScope scope = ResourceScope.ofConfined()) {\n+   SegmentAllocator allocator = SegmentAllocator.of(scope);\n+   ...\n+}\n+ * }<\/pre><\/blockquote>\n+ *\n+ * In addition, this interface also defines factories for commonly used allocators; for instance, {@link #malloc(Supplier)} returns a\n+ * native allocator which returns segments backed by separate resources scopes, while {@link #arenaUnbounded(ResourceScope)}\n+ * and {@link #arenaBounded(long, ResourceScope)} are arena-style native allocators. Finally {@link #of(MemorySegment)}\n+ * returns an allocator which wraps a segment (either on-heap or off-heap) and recycles its content upon each new allocation request.\n+ *\/\n+@FunctionalInterface\n+public interface SegmentAllocator {\n+\n+    \/**\n+     * Allocate a block of memory  with given layout and initialize it with given byte value.\n+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n+     * segment must conform to the layout alignment constraints.\n+     * @param layout the layout of the block of memory to be allocated.\n+     * @param value the value to be set on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a byte value.\n+     *\/\n+    default MemorySegment allocate(ValueLayout layout, byte value) {\n+        Objects.requireNonNull(layout);\n+        VarHandle handle = layout.varHandle(byte.class);\n+        MemorySegment addr = allocate(layout);\n+        handle.set(addr, value);\n+        return addr;\n+    }\n+\n+    \/**\n+     * Allocate a block of memory  with given layout and initialize it with given char value.\n+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n+     * segment must conform to the layout alignment constraints.\n+     * @param layout the layout of the block of memory to be allocated.\n+     * @param value the value to be set on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a char value.\n+     *\/\n+    default MemorySegment allocate(ValueLayout layout, char value) {\n+        Objects.requireNonNull(layout);\n+        VarHandle handle = layout.varHandle(char.class);\n+        MemorySegment addr = allocate(layout);\n+        handle.set(addr, value);\n+        return addr;\n+    }\n+\n+    \/**\n+     * Allocate a block of memory  with given layout and initialize it with given short value.\n+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n+     * segment must conform to the layout alignment constraints.\n+     * @param layout the layout of the block of memory to be allocated.\n+     * @param value the value to be set on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a short value.\n+     *\/\n+    default MemorySegment allocate(ValueLayout layout, short value) {\n+        Objects.requireNonNull(layout);\n+        VarHandle handle = layout.varHandle(short.class);\n+        MemorySegment addr = allocate(layout);\n+        handle.set(addr, value);\n+        return addr;\n+    }\n+\n+    \/**\n+     * Allocate a block of memory  with given layout and initialize it with given int value.\n+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n+     * segment must conform to the layout alignment constraints.\n+     * @param layout the layout of the block of memory to be allocated.\n+     * @param value the value to be set on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a int value.\n+     *\/\n+    default MemorySegment allocate(ValueLayout layout, int value) {\n+        Objects.requireNonNull(layout);\n+        VarHandle handle = layout.varHandle(int.class);\n+        MemorySegment addr = allocate(layout);\n+        handle.set(addr, value);\n+        return addr;\n+    }\n+\n+    \/**\n+     * Allocate a block of memory  with given layout and initialize it with given float value.\n+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n+     * segment must conform to the layout alignment constraints.\n+     * @param layout the layout of the block of memory to be allocated.\n+     * @param value the value to be set on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a float value.\n+     *\/\n+    default MemorySegment allocate(ValueLayout layout, float value) {\n+        Objects.requireNonNull(layout);\n+        VarHandle handle = layout.varHandle(float.class);\n+        MemorySegment addr = allocate(layout);\n+        handle.set(addr, value);\n+        return addr;\n+    }\n+\n+    \/**\n+     * Allocate a block of memory  with given layout and initialize it with given long value.\n+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n+     * segment must conform to the layout alignment constraints.\n+     * @param layout the layout of the block of memory to be allocated.\n+     * @param value the value to be set on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a long value.\n+     *\/\n+    default MemorySegment allocate(ValueLayout layout, long value) {\n+        Objects.requireNonNull(layout);\n+        VarHandle handle = layout.varHandle(long.class);\n+        MemorySegment addr = allocate(layout);\n+        handle.set(addr, value);\n+        return addr;\n+    }\n+\n+    \/**\n+     * Allocate a block of memory  with given layout and initialize it with given double value.\n+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n+     * segment must conform to the layout alignment constraints.\n+     * @param layout the layout of the block of memory to be allocated.\n+     * @param value the value to be set on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a double value.\n+     *\/\n+    default MemorySegment allocate(ValueLayout layout, double value) {\n+        Objects.requireNonNull(layout);\n+        VarHandle handle = layout.varHandle(double.class);\n+        MemorySegment addr = allocate(layout);\n+        handle.set(addr, value);\n+        return addr;\n+    }\n+\n+    \/**\n+     * Allocate a block of memory  with given layout and initialize it with given address value\n+     * (expressed as an {@link Addressable} instance).\n+     * The address value might be narrowed according to the platform address size (see {@link MemoryLayouts#ADDRESS}).\n+     * The segment returned by this method cannot be closed. Moreover, the returned\n+     * segment must conform to the layout alignment constraints.\n+     * @param layout the layout of the block of memory to be allocated.\n+     * @param value the value to be set on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code layout.byteSize() != MemoryLayouts.ADDRESS.byteSize()}.\n+     *\/\n+    default MemorySegment allocate(ValueLayout layout, Addressable value) {\n+        Objects.requireNonNull(value);\n+        Objects.requireNonNull(layout);\n+        if (MemoryLayouts.ADDRESS.byteSize() != layout.byteSize()) {\n+            throw new IllegalArgumentException(\"Layout size mismatch - \" + layout.byteSize() + \" != \" + MemoryLayouts.ADDRESS.byteSize());\n+        }\n+        return switch ((int)layout.byteSize()) {\n+            case 4 -> allocate(layout, (int)value.address().toRawLongValue());\n+            case 8 -> allocate(layout, value.address().toRawLongValue());\n+            default -> throw new UnsupportedOperationException(\"Unsupported pointer size\"); \/\/ should not get here\n+        };\n+    }\n+\n+    \/**\n+     * Allocate a block of memory  with given layout and initialize it with given byte array.\n+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n+     * segment must conform to the layout alignment constraints.\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param array the array to be copied on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a byte value.\n+     *\/\n+    default MemorySegment allocateArray(ValueLayout elementLayout, byte[] array) {\n+        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n+    }\n+\n+    \/**\n+     * Allocate a block of memory  with given layout and initialize it with given short array.\n+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n+     * segment must conform to the layout alignment constraints.\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param array the array to be copied on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a short value.\n+     *\/\n+    default MemorySegment allocateArray(ValueLayout elementLayout, short[] array) {\n+        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n+    }\n+\n+    \/**\n+     * Allocate a block of memory  with given layout and initialize it with given char array.\n+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n+     * segment must conform to the layout alignment constraints.\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param array the array to be copied on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a char value.\n+     *\/\n+    default MemorySegment allocateArray(ValueLayout elementLayout, char[] array) {\n+        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n+    }\n+\n+    \/**\n+     * Allocate a block of memory  with given layout and initialize it with given int array.\n+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n+     * segment must conform to the layout alignment constraints.\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param array the array to be copied on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a int value.\n+     *\/\n+    default MemorySegment allocateArray(ValueLayout elementLayout, int[] array) {\n+        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n+    }\n+\n+    \/**\n+     * Allocate a block of memory  with given layout and initialize it with given float array.\n+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n+     * segment must conform to the layout alignment constraints.\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param array the array to be copied on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a float value.\n+     *\/\n+    default MemorySegment allocateArray(ValueLayout elementLayout, float[] array) {\n+        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n+    }\n+\n+    \/**\n+     * Allocate a block of memory  with given layout and initialize it with given long array.\n+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n+     * segment must conform to the layout alignment constraints.\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param array the array to be copied on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a long value.\n+     *\/\n+    default MemorySegment allocateArray(ValueLayout elementLayout, long[] array) {\n+        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n+    }\n+\n+    \/**\n+     * Allocate a block of memory  with given layout and initialize it with given double array.\n+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n+     * segment must conform to the layout alignment constraints.\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param array the array to be copied on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a double value.\n+     *\/\n+    default MemorySegment allocateArray(ValueLayout elementLayout, double[] array) {\n+        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n+    }\n+\n+    \/**\n+     * Allocate a block of memory  with given layout and initialize it with given address array.\n+     * The address value of each array element might be narrowed according to the platform address size (see {@link MemoryLayouts#ADDRESS}).\n+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n+     * segment must conform to the layout alignment constraints.\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param array the array to be copied on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code layout.byteSize() != MemoryLayouts.ADDRESS.byteSize()}.\n+     *\/\n+    default MemorySegment allocateArray(ValueLayout elementLayout, Addressable[] array) {\n+        Objects.requireNonNull(elementLayout);\n+        Objects.requireNonNull(array);\n+        Stream.of(array).forEach(Objects::requireNonNull);\n+        if (MemoryLayouts.ADDRESS.byteSize() != elementLayout.byteSize()) {\n+            throw new IllegalArgumentException(\"Layout size mismatch - \" + elementLayout.byteSize() + \" != \" + MemoryLayouts.ADDRESS.byteSize());\n+        }\n+        return switch ((int)elementLayout.byteSize()) {\n+            case 4 -> copyArrayWithSwapIfNeeded(Stream.of(array)\n+                            .mapToInt(a -> (int)a.address().toRawLongValue()).toArray(),\n+                    elementLayout, MemorySegment::ofArray);\n+            case 8 -> copyArrayWithSwapIfNeeded(Stream.of(array)\n+                            .mapToLong(a -> a.address().toRawLongValue()).toArray(),\n+                    elementLayout, MemorySegment::ofArray);\n+            default -> throw new UnsupportedOperationException(\"Unsupported pointer size\"); \/\/ should not get here\n+        };\n+    }\n+\n+    private <Z> MemorySegment copyArrayWithSwapIfNeeded(Z array, ValueLayout elementLayout,\n+                                                        Function<Z, MemorySegment> heapSegmentFactory) {\n+        Objects.requireNonNull(array);\n+        Objects.requireNonNull(elementLayout);\n+        Utils.checkPrimitiveCarrierCompat(array.getClass().componentType(), elementLayout);\n+        MemorySegment addr = allocate(MemoryLayout.ofSequence(Array.getLength(array), elementLayout));\n+        if (elementLayout.byteSize() == 1 || (elementLayout.order() == ByteOrder.nativeOrder())) {\n+            addr.copyFrom(heapSegmentFactory.apply(array));\n+        } else {\n+            ((AbstractMemorySegmentImpl)addr).copyFromSwap(heapSegmentFactory.apply(array), elementLayout.byteSize());\n+        }\n+        return addr;\n+    }\n+\n+    \/**\n+     * Allocate a block of memory  with given layout. The segment returned by this method is\n+     * associated with a segment which cannot be closed. Moreover, the returned segment must conform to the layout alignment constraints.\n+     * @param layout the layout of the block of memory to be allocated.\n+     * @return a segment for the newly allocated memory block.\n+     *\/\n+    default MemorySegment allocate(MemoryLayout layout) {\n+        Objects.requireNonNull(layout);\n+        return allocate(layout.byteSize(), layout.byteAlignment());\n+    }\n+\n+    \/**\n+     * Allocate a block of memory corresponding to an array with given element layout and size.\n+     * The segment returned by this method is associated with a segment which cannot be closed.\n+     * Moreover, the returned segment must conform to the layout alignment constraints. This is equivalent to the\n+     * following code:\n+     * <pre>{@code\n+    allocate(MemoryLayout.ofSequence(size, elementLayout));\n+     * }<\/pre>\n+     * @param elementLayout the array element layout.\n+     * @param count the array element count.\n+     * @return a segment for the newly allocated memory block.\n+     *\/\n+    default MemorySegment allocateArray(MemoryLayout elementLayout, long count) {\n+        Objects.requireNonNull(elementLayout);\n+        return allocate(MemoryLayout.ofSequence(count, elementLayout));\n+    }\n+\n+    \/**\n+     * Allocate a block of memory  with given size. The segment returned by this method is\n+     * associated with a segment which cannot be closed. Moreover, the returned segment must be aligned to {@code size}.\n+     * @param bytesSize the size (in bytes) of the block of memory to be allocated.\n+     * @return a segment for the newly allocated memory block.\n+     *\/\n+    default MemorySegment allocate(long bytesSize) {\n+        return allocate(bytesSize, 1);\n+    }\n+\n+    \/**\n+     * Allocate a block of memory  with given size and alignment constraint.\n+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover,\n+     * the returned segment must be aligned to {@code alignment}.\n+     * @param bytesSize the size (in bytes) of the block of memory to be allocated.\n+     * @param bytesAlignment the alignment (in bytes) of the block of memory to be allocated.\n+     * @return a segment for the newly allocated memory block.\n+     *\/\n+    MemorySegment allocate(long bytesSize, long bytesAlignment);\n+\n+    \/**\n+     * Returns a native allocator which allocates memory segments using the {@code malloc} allocation primitive,\n+     * each backed by a resource scope that is obtained using the provided supplier. For instance, to create an allocator which\n+     * returns independent, confined segments, clients can use the following code:\n+     *\n+     * <blockquote><pre>{@code\n+    SegmentAllocator confinedAllocator = malloc(ResourceScope::ofConfined);\n+    SegmentAllocator sharedAllocator = malloc(ResourceScope::ofShared);\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @param scopeFactory the factory used to generate the resource scope attached to each newly allocated segment.\n+     * @return a native allocator using the {@code malloc} allocation primitive.\n+     *\/\n+    static SegmentAllocator malloc(Supplier<ResourceScope> scopeFactory) {\n+        Objects.requireNonNull(scopeFactory);\n+        return (size, align) -> MemorySegment.allocateNative(size, align, scopeFactory.get());\n+    }\n+\n+    \/**\n+     * Returns a native arena-based allocator which allocates a single memory segment, of given size (using malloc),\n+     * and then responds to allocation request by returning different slices of that same segment\n+     * (until no further allocation is possible).\n+     * This can be useful when clients want to perform multiple allocation requests while avoiding the cost associated\n+     * with allocating a new off-heap memory region upon each allocation request.\n+     * <p>\n+     * The returned allocator might throw an {@link OutOfMemoryError} if an incoming allocation request exceeds\n+     * the allocator capacity.\n+     *\n+     * @param size the size (in bytes) of the allocation arena.\n+     * @param scope the scope associated with the segments returned by this allocator.\n+     * @return a new bounded arena-based allocator\n+     *\/\n+    static SegmentAllocator arenaBounded(long size, ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n+        return scope.ownerThread() == null ?\n+                new ArenaAllocator.BoundedSharedArenaAllocator(scope, size) :\n+                new ArenaAllocator.BoundedArenaAllocator(scope, size);\n+    }\n+\n+    \/**\n+     * Returns a native unbounded arena-based allocator.\n+     * <p>\n+     * The returned allocator allocates a memory segment {@code S} of a certain fixed size (using malloc) and then\n+     * responds to allocation requests in one of the following ways:\n+     * <ul>\n+     *     <li>if the size of the allocation requests is smaller than the size of {@code S}, and {@code S} has a <em>free<\/em>\n+     *     slice {@code S'} which fits that allocation request, return that {@code S'}.\n+     *     <li>if the size of the allocation requests is smaller than the size of {@code S}, and {@code S} has no <em>free<\/em>\n+     *     slices which fits that allocation request, allocate a new segment {@code S'} (using malloc), which has same size as {@code S}\n+     *     and set {@code S = S'}; the allocator then tries to respond to the same allocation request again.\n+     *     <li>if the size of the allocation requests is bigger than the size of {@code S}, allocate a new segment {@code S'}\n+     *     (using malloc), which has a sufficient size to satisfy the allocation request, and return {@code S'}.\n+     * <\/ul>\n+     * <p>\n+     * This segment allocator can be useful when clients want to perform multiple allocation requests while avoiding the\n+     * cost associated with allocating a new off-heap memory region upon each allocation request.\n+     * <p>\n+     * The returned allocator might throw an {@link OutOfMemoryError} if an incoming allocation request exceeds\n+     * the system capacity.\n+     *\n+     * @param scope the scope associated with the segments returned by this allocator.\n+     * @return a new unbounded arena-based allocator\n+     *\/\n+    static SegmentAllocator arenaUnbounded(ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n+        return scope.ownerThread() == null ?\n+                new ArenaAllocator.UnboundedSharedArenaAllocator(scope) :\n+                new ArenaAllocator(scope);\n+    }\n+\n+    \/**\n+     * Returns a native allocator which responds to allocation requests by recycling a single segment; that is,\n+     * each new allocation request will return a new slice starting at the segment offset {@code 0} (alignment\n+     * constraints are ignored by this allocator). This can be useful to limit allocation requests in case a client\n+     * knows that they have fully processed the contents of the allocated segment before the subsequent allocation request\n+     * takes place.\n+     *\n+     * @param segment the memory segment to be recycled by the returned allocator.\n+     * @return an allocator which recycles an existing segment upon each new allocation request.\n+     *\/\n+    static SegmentAllocator of(MemorySegment segment) {\n+        Objects.requireNonNull(segment);\n+        return (size, align) -> segment.asSlice(0, size);\n+    }\n+\n+    \/**\n+     * Returns a native allocator which responds to allocation requests by allocating new segments\n+     * bound by the given resource scope, using the {@link MemorySegment#allocateNative(long, long, ResourceScope)}\n+     * factory.\n+     *\n+     * @param scope the resource scope associated to the segments created by the returned allocator.\n+     * @return an allocator which allocates new memory segment bound by the provided resource scope.\n+     *\/\n+    static SegmentAllocator of(ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n+        return (size, align) -> MemorySegment.allocateNative(size, align, scope);\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":490,"deletions":0,"binary":false,"changes":490,"status":"added"},{"patch":"@@ -48,4 +48,3 @@\n-try (MemorySegment segment = MemorySegment.allocateNative(10 * 4)) {\n-    for (int i = 0 ; i < 10 ; i++) {\n-       MemoryAccess.setIntAtIndex(segment, i);\n-    }\n+MemorySegment segment = MemorySegment.allocateNative(10 * 4);\n+for (int i = 0 ; i < 10 ; i++) {\n+   MemoryAccess.setIntAtIndex(segment, i);\n@@ -57,4 +56,1 @@\n- * The segment is created inside a <em>try-with-resources<\/em> construct: this idiom ensures that all the memory resources\n- * associated with the segment will be released at the end of the block, according to the semantics described in\n- * Section {@jls 14.20.3} of <cite>The Java Language Specification<\/cite>. Inside the try-with-resources block, we initialize\n- * the contents of the memory segment using the\n+ * Inside a loop, we then initialize the contents of the memory segment using the\n@@ -69,10 +65,19 @@\n- * crucial that the resources associated with a memory segment are released when the segment is no longer in use, by calling the {@link jdk.incubator.foreign.MemorySegment#close()}\n- * method either explicitly, or implicitly, by relying on try-with-resources construct (as demonstrated in the example above).\n- * Closing a given memory segment is an <em>atomic<\/em> operation which can either succeed - and result in the underlying\n- * memory associated with the segment to be released, or <em>fail<\/em> with an exception.\n- * <p>\n- * The deterministic deallocation model differs significantly from the implicit strategies adopted within other APIs, most\n- * notably the {@link java.nio.ByteBuffer} API: in that case, when a native byte buffer is created (see {@link java.nio.ByteBuffer#allocateDirect(int)}),\n- * the underlying memory is not released until the byte buffer reference becomes <em>unreachable<\/em>. While implicit deallocation\n- * models such as this can be very convenient - clients do not have to remember to <em>close<\/em> a direct buffer - such models can also make it\n- * hard for clients to ensure that the memory associated with a direct buffer has indeed been released.\n+ * often crucial that the resources associated with a memory segment are released when the segment is no longer in use,\n+ * and in a timely fashion. For this reason, there might be cases where waiting for the garbage collector to determine that a segment\n+ * is <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a> is not optimal.\n+ * Clients that operate under these assumptions might want to be able to programmatically release the memory associated\n+ * with a memory segment. This can be done, using the {@link jdk.incubator.foreign.ResourceScope} abstraction, as shown below:\n+ *\n+ * <pre>{@code\n+try (ResourceScope scope = ResourceScope.ofConfined()) {\n+    MemorySegment segment = MemorySegment.allocateNative(10 * 4, scope);\n+    for (int i = 0 ; i < 10 ; i++) {\n+        MemoryAccess.setIntAtIndex(segment, i);\n+    }\n+}\n+ * }<\/pre>\n+ *\n+ * This example is almost identical to the one shown above; this time we first create a so called <em>resource scope<\/em>,\n+ * which is used to <em>bind<\/em> the life-cycle of the segment created immediately afterwards. Note the use of the\n+ * <em>try-with-resources<\/em> construct: this idiom ensures that all the memory resources associated with the segment will be released\n+ * at the end of the block, according to the semantics described in Section {@jls 14.20.3} of <cite>The Java Language Specification<\/cite>.\n@@ -89,8 +94,3 @@\n- * the segment being accessed has not been closed prematurely. We call this guarantee <em>temporal safety<\/em>. Note that,\n- * in the general case, guaranteeing temporal safety can be hard, as multiple threads could attempt to access and\/or close\n- * the same memory segment concurrently. The memory access API addresses this problem by imposing strong\n- * <em>thread-confinement<\/em> guarantees on memory segments: upon creation, a memory segment is associated with an owner thread,\n- * which is the only thread that can either access or close the segment.\n- * <p>\n- * Together, spatial and temporal safety ensure that each memory access operation either succeeds - and accesses a valid\n- * memory location - or fails.\n+ * the resource scope associated with the segment being accessed has not been closed prematurely.\n+ * We call this guarantee <em>temporal safety<\/em>. Together, spatial and temporal safety ensure that each memory access\n+ * operation either succeeds - and accesses a valid memory location - or fails.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -38,3 +38,0 @@\n-import java.io.FileDescriptor;\n-import java.lang.invoke.VarHandle;\n-import java.lang.ref.Cleaner;\n@@ -63,2 +60,2 @@\n-    final static int FIRST_RESERVED_FLAG = 1 << 16; \/\/ upper 16 bits are reserved\n-    final static int SMALL = FIRST_RESERVED_FLAG;\n+    final static int READ_ONLY = 1;\n+    final static int SMALL = READ_ONLY << 1;\n@@ -90,2 +87,11 @@\n-                ALL_ACCESS | SMALL :\n-                ALL_ACCESS;\n+                SMALL : 0;\n+    }\n+\n+    @Override\n+    public AbstractMemorySegmentImpl asReadOnly() {\n+        return dup(0, length, mask | READ_ONLY, scope);\n+    }\n+\n+    @Override\n+    public boolean isReadOnly() {\n+        return isSet(READ_ONLY);\n@@ -118,1 +124,1 @@\n-                withAccessModes(accessModes() & ~CLOSE));\n+                this);\n@@ -226,3 +232,0 @@\n-        if (!isSet(READ)) {\n-            throw unsupportedAccessMode(READ);\n-        }\n@@ -231,1 +234,1 @@\n-        if (!isSet(WRITE)) {\n+        if (isSet(READ_ONLY)) {\n@@ -238,5 +241,0 @@\n-    @Override\n-    public final int accessModes() {\n-        return mask & ALL_ACCESS;\n-    }\n-\n@@ -248,1 +246,0 @@\n-    @Override\n@@ -253,1 +250,0 @@\n-    @Override\n@@ -258,83 +254,0 @@\n-    @Override\n-    public AbstractMemorySegmentImpl withAccessModes(int accessModes) {\n-        checkAccessModes(accessModes);\n-        if ((~accessModes() & accessModes) != 0) {\n-            throw new IllegalArgumentException(\"Cannot acquire more access modes\");\n-        }\n-        return dup(0, length, (mask & ~ALL_ACCESS) | accessModes, scope);\n-    }\n-\n-    @Override\n-    public boolean hasAccessModes(int accessModes) {\n-        checkAccessModes(accessModes);\n-        return (accessModes() & accessModes) == accessModes;\n-    }\n-\n-    private void checkAccessModes(int accessModes) {\n-        if ((accessModes & ~ALL_ACCESS) != 0) {\n-            throw new IllegalArgumentException(\"Invalid access modes\");\n-        }\n-    }\n-\n-    public MemorySegment handoff(Thread thread) {\n-        Objects.requireNonNull(thread);\n-        checkValidState();\n-        if (!isSet(HANDOFF)) {\n-            throw unsupportedAccessMode(HANDOFF);\n-        }\n-        try {\n-            return dup(0L, length, mask, scope.confineTo(thread));\n-        } finally {\n-            \/\/flush read\/writes to segment memory before returning the new segment\n-            VarHandle.fullFence();\n-        }\n-    }\n-\n-    @Override\n-    public MemorySegment share() {\n-        checkValidState();\n-        if (!isSet(SHARE)) {\n-            throw unsupportedAccessMode(SHARE);\n-        }\n-        try {\n-            return dup(0L, length, mask, scope.share());\n-        } finally {\n-            \/\/flush read\/writes to segment memory before returning the new segment\n-            VarHandle.fullFence();\n-        }\n-    }\n-\n-    @Override\n-    public MemorySegment handoff(NativeScope scope) {\n-        Objects.requireNonNull(scope);\n-        checkValidState();\n-        if (!isSet(HANDOFF)) {\n-            throw unsupportedAccessMode(HANDOFF);\n-        }\n-        if (!isSet(CLOSE)) {\n-            throw unsupportedAccessMode(CLOSE);\n-        }\n-        MemorySegment dup = handoff(scope.ownerThread());\n-        ((AbstractNativeScope)scope).register(dup);\n-        return dup.withAccessModes(accessModes() & (READ | WRITE));\n-    }\n-\n-    @Override\n-    public MemorySegment registerCleaner(Cleaner cleaner) {\n-        Objects.requireNonNull(cleaner);\n-        checkValidState();\n-        if (!isSet(CLOSE)) {\n-            throw unsupportedAccessMode(CLOSE);\n-        }\n-        return dup(0L, length, mask, scope.cleanable(cleaner));\n-    }\n-\n-    @Override\n-    public final void close() {\n-        checkValidState();\n-        if (!isSet(CLOSE)) {\n-            throw unsupportedAccessMode(CLOSE);\n-        }\n-        scope.close();\n-    }\n-\n@@ -396,4 +309,2 @@\n-        if (!readOnly && !isSet(WRITE)) {\n-            throw unsupportedAccessMode(WRITE);\n-        } else if (readOnly && !isSet(READ)) {\n-            throw unsupportedAccessMode(READ);\n+        if (!readOnly && isSet(READ_ONLY)) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n@@ -404,5 +315,0 @@\n-    private void checkAccessAndScope(long offset, long length, boolean readOnly) {\n-        checkValidState();\n-        checkAccess(offset, length, readOnly);\n-    }\n-\n@@ -469,25 +375,0 @@\n-    UnsupportedOperationException unsupportedAccessMode(int expected) {\n-        return new UnsupportedOperationException((String.format(\"Required access mode %s ; current access modes: %s\",\n-                modeStrings(expected).get(0), modeStrings(mask))));\n-    }\n-\n-    private List<String> modeStrings(int mode) {\n-        List<String> modes = new ArrayList<>();\n-        if ((mode & READ) != 0) {\n-            modes.add(\"READ\");\n-        }\n-        if ((mode & WRITE) != 0) {\n-            modes.add(\"WRITE\");\n-        }\n-        if ((mode & CLOSE) != 0) {\n-            modes.add(\"CLOSE\");\n-        }\n-        if ((mode & SHARE) != 0) {\n-            modes.add(\"SHARE\");\n-        }\n-        if ((mode & HANDOFF) != 0) {\n-            modes.add(\"HANDOFF\");\n-        }\n-        return modes;\n-    }\n-\n@@ -611,1 +492,1 @@\n-            bufferScope = MemoryScope.createConfined(bb, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n+            bufferScope = MemoryScope.GLOBAL;\n@@ -615,1 +496,1 @@\n-            modes &= ~WRITE;\n+            modes |= READ_ONLY;\n@@ -618,1 +499,1 @@\n-            return new HeapMemorySegmentImpl.OfByte(bbAddress + pos, (byte[])base, size, modes, bufferScope);\n+            return new HeapMemorySegmentImpl.OfByte(bbAddress + pos, (byte[])base, size, modes);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":20,"deletions":139,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -1,194 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.foreign;\n-\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeScope;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.OptionalLong;\n-\n-public abstract class AbstractNativeScope implements NativeScope {\n-\n-    private final List<MemorySegment> segments = new ArrayList<>();\n-    private final Thread ownerThread;\n-\n-    private static final int SCOPE_MASK = MemorySegment.READ | MemorySegment.WRITE; \/\/ no terminal operations allowed\n-\n-    AbstractNativeScope() {\n-        this.ownerThread = Thread.currentThread();\n-    }\n-\n-    public static NativeScope emptyScope() {\n-        return new EmptyScope();\n-    }\n-\n-    @Override\n-    public Thread ownerThread() {\n-        return ownerThread;\n-    }\n-\n-    @Override\n-    public void close() {\n-        segments.forEach(MemorySegment::close);\n-    }\n-\n-    void checkOwnerThread() {\n-        if (Thread.currentThread() != ownerThread()) {\n-            throw new IllegalStateException(\"Attempt to access scope from different thread\");\n-        }\n-    }\n-\n-    MemorySegment newSegment(long size, long align) {\n-        MemorySegment segment = MemorySegment.allocateNative(size, align);\n-        segments.add(segment);\n-        return segment;\n-    }\n-\n-    MemorySegment newSegment(long size) {\n-        return newSegment(size, size);\n-    }\n-\n-    public void register(MemorySegment segment) {\n-        segments.add(segment);\n-    }\n-\n-    public static class UnboundedNativeScope extends AbstractNativeScope {\n-\n-        private static final long BLOCK_SIZE = 4 * 1024;\n-        private static final long MAX_ALLOC_SIZE = BLOCK_SIZE \/ 2;\n-\n-        private MemorySegment segment;\n-        private long sp = 0L;\n-        private long size = 0L;\n-\n-        @Override\n-        public OptionalLong byteSize() {\n-            return OptionalLong.empty();\n-        }\n-\n-        @Override\n-        public long allocatedBytes() {\n-            return size;\n-        }\n-\n-        public UnboundedNativeScope() {\n-            super();\n-            this.segment = newSegment(BLOCK_SIZE);\n-        }\n-\n-        @Override\n-        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-            checkOwnerThread();\n-            if (Utils.alignUp(bytesSize, bytesAlignment) > MAX_ALLOC_SIZE) {\n-                MemorySegment segment = newSegment(bytesSize, bytesAlignment);\n-                return segment.withAccessModes(SCOPE_MASK);\n-            }\n-            \/\/ try to slice from current segment first...\n-            MemorySegment slice = trySlice(bytesSize, bytesAlignment);\n-            if (slice == null) {\n-                \/\/ ... if that fails, allocate a new segment and slice from there\n-                sp = 0L;\n-                segment = newSegment(BLOCK_SIZE, 1L);\n-                slice = trySlice(bytesSize, bytesAlignment);\n-                if (slice == null) {\n-                    \/\/ this should not be possible - allocations that do not fit in BLOCK_SIZE should get their own\n-                    \/\/ standalone segment (see above).\n-                    throw new AssertionError(\"Cannot get here!\");\n-                }\n-            }\n-            return slice;\n-        }\n-\n-        private MemorySegment trySlice(long bytesSize, long bytesAlignment) {\n-            long min = segment.address().toRawLongValue();\n-            long start = Utils.alignUp(min + sp, bytesAlignment) - min;\n-            if (segment.byteSize() - start < bytesSize) {\n-                return null;\n-            } else {\n-                MemorySegment slice = segment.asSlice(start, bytesSize)\n-                        .withAccessModes(SCOPE_MASK);\n-                sp = start + bytesSize;\n-                size += Utils.alignUp(bytesSize, bytesAlignment);\n-                return slice;\n-            }\n-        }\n-    }\n-\n-    public static class BoundedNativeScope extends AbstractNativeScope {\n-        private final MemorySegment segment;\n-        private long sp = 0L;\n-\n-        @Override\n-        public OptionalLong byteSize() {\n-            return OptionalLong.of(segment.byteSize());\n-        }\n-\n-        @Override\n-        public long allocatedBytes() {\n-            return sp;\n-        }\n-\n-        public BoundedNativeScope(long size) {\n-            super();\n-            this.segment = newSegment(size, 1);\n-        }\n-\n-        @Override\n-        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-            checkOwnerThread();\n-            long min = segment.address().toRawLongValue();\n-            long start = Utils.alignUp(min + sp, bytesAlignment) - min;\n-            try {\n-                MemorySegment slice = segment.asSlice(start, bytesSize)\n-                        .withAccessModes(SCOPE_MASK);\n-                sp = start + bytesSize;\n-                return slice;\n-            } catch (IndexOutOfBoundsException ex) {\n-                throw new OutOfMemoryError(\"Not enough space left to allocate\");\n-            }\n-        }\n-    }\n-\n-    \/\/ only for registering\n-    private static class EmptyScope extends AbstractNativeScope {\n-        @Override\n-        public OptionalLong byteSize() {\n-            return OptionalLong.of(0);\n-        }\n-\n-        @Override\n-        public long allocatedBytes() {\n-            return 0;\n-        }\n-\n-        @Override\n-        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-            throw new OutOfMemoryError(\"Not enough space left to allocate\");\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractNativeScope.java","additions":0,"deletions":194,"binary":false,"changes":194,"status":"deleted"},{"patch":"@@ -0,0 +1,109 @@\n+package jdk.internal.foreign;\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import jdk.incubator.foreign.ResourceScope;\n+\n+import java.util.OptionalLong;\n+\n+public class ArenaAllocator implements SegmentAllocator {\n+\n+    private final SegmentAllocator allocator;\n+    private MemorySegment segment;\n+\n+    private static final long BLOCK_SIZE = 4 * 1024;\n+    private static final long MAX_ALLOC_SIZE = BLOCK_SIZE \/ 2;\n+\n+    private long sp = 0L;\n+\n+    public ArenaAllocator(ResourceScope scope) {\n+        this(BLOCK_SIZE, scope);\n+    }\n+\n+    ArenaAllocator(long initialSize, ResourceScope scope) {\n+        this.allocator = SegmentAllocator.malloc(() -> scope);\n+        this.segment = allocator.allocate(initialSize, 1);\n+    }\n+\n+    MemorySegment newSegment(long size, long align) {\n+        MemorySegment segment = allocator.allocate(size, align);\n+        return segment;\n+    }\n+\n+    @Override\n+    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+        if (Utils.alignUp(bytesSize, bytesAlignment) > MAX_ALLOC_SIZE) {\n+            return newSegment(bytesSize, bytesAlignment);\n+        }\n+        \/\/ try to slice from current segment first...\n+        MemorySegment slice = trySlice(bytesSize, bytesAlignment);\n+        if (slice == null) {\n+            \/\/ ... if that fails, allocate a new segment and slice from there\n+            sp = 0L;\n+            segment = newSegment(BLOCK_SIZE, 1L);\n+            slice = trySlice(bytesSize, bytesAlignment);\n+            if (slice == null) {\n+                \/\/ this should not be possible - allocations that do not fit in BLOCK_SIZE should get their own\n+                \/\/ standalone segment (see above).\n+                throw new AssertionError(\"Cannot get here!\");\n+            }\n+        }\n+        return slice;\n+    }\n+\n+    private MemorySegment trySlice(long bytesSize, long bytesAlignment) {\n+        long min = segment.address().toRawLongValue();\n+        long start = Utils.alignUp(min + sp, bytesAlignment) - min;\n+        if (segment.byteSize() - start < bytesSize) {\n+            return null;\n+        } else {\n+            MemorySegment slice = segment.asSlice(start, bytesSize);\n+            sp = start + bytesSize;\n+            return slice;\n+        }\n+    }\n+\n+    public static class BoundedArenaAllocator extends ArenaAllocator {\n+\n+        public BoundedArenaAllocator(ResourceScope scope, long size) {\n+            super(size, scope);\n+        }\n+\n+        @Override\n+        MemorySegment newSegment(long size, long align) {\n+            throw new OutOfMemoryError(\"Not enough space left to allocate\");\n+        }\n+    }\n+\n+    public static class BoundedSharedArenaAllocator extends BoundedArenaAllocator {\n+        public BoundedSharedArenaAllocator(ResourceScope scope, long size) {\n+            super(scope, size);\n+        }\n+\n+        @Override\n+        public synchronized MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+            return super.allocate(bytesSize, bytesAlignment);\n+        }\n+    }\n+\n+    public static class UnboundedSharedArenaAllocator implements SegmentAllocator {\n+\n+        final ResourceScope scope;\n+\n+        final ThreadLocal<ArenaAllocator> allocators = new ThreadLocal<>() {\n+            @Override\n+            protected ArenaAllocator initialValue() {\n+                return new ArenaAllocator(scope);\n+            }\n+        };\n+\n+        public UnboundedSharedArenaAllocator(ResourceScope scope) {\n+            this.scope = scope;\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+            return allocators.get().allocate(bytesSize, bytesAlignment);\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ArenaAllocator.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.ref.Cleaner;\n+\n+\/**\n+ * A confined scope, which features an owner thread. The liveness check features an additional\n+ * confinement check - that is, calling any operation on this scope from a thread other than the\n+ * owner thread will result in an exception. Because of this restriction, checking the liveness bit\n+ * can be performed in plain mode.\n+ *\/\n+class ConfinedScope extends MemoryScope {\n+\n+    private boolean closed; \/\/ = false\n+    private int lockCount = 0;\n+    private final Thread owner;\n+\n+    public ConfinedScope(Thread owner, Object ref, Cleaner cleaner, boolean closeable) {\n+        super(ref, cleaner, closeable, new ConfinedResourceList());\n+        this.owner = owner;\n+    }\n+\n+    @ForceInline\n+    public final void checkValidState() {\n+        if (owner != Thread.currentThread()) {\n+            throw new IllegalStateException(\"Attempted access outside owning thread\");\n+        }\n+        if (closed) {\n+            throw new IllegalStateException(\"Already closed\");\n+        }\n+    }\n+\n+    @Override\n+    public boolean isAlive() {\n+        return !closed;\n+    }\n+\n+    @Override\n+    public Handle acquire() {\n+        checkValidState();\n+        if (!closeable) return DUMMY_LOCK;\n+        lockCount++;\n+        return new ConfinedHandle();\n+    }\n+\n+    void justClose() {\n+        this.checkValidState();\n+        if (lockCount == 0) {\n+            closed = true;\n+        } else {\n+            throw new IllegalStateException(\"Scope is acquired by \" + lockCount + \" locks\");\n+        }\n+    }\n+\n+    @Override\n+    public Thread ownerThread() {\n+        return owner;\n+    }\n+\n+    \/**\n+     * A confined resource list; no races are possible here.\n+     *\/\n+    static class ConfinedResourceList extends ResourceList {\n+        @Override\n+        void add(ResourceCleanup cleanup) {\n+            if (fst != ResourceCleanup.CLOSED_LIST) {\n+                cleanup.next = fst;\n+                fst = cleanup;\n+            } else {\n+                throw new IllegalStateException(\"Already closed!\");\n+            }\n+        }\n+\n+        @Override\n+        void cleanup() {\n+            if (fst != ResourceCleanup.CLOSED_LIST) {\n+                ResourceCleanup prev = fst;\n+                fst = ResourceCleanup.CLOSED_LIST;\n+                cleanup(prev);\n+            } else {\n+                throw new IllegalStateException(\"Attempt to cleanup an already closed resource list\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A confined resource scope handle; no races are possible here.\n+     *\/\n+    class ConfinedHandle implements Handle {\n+        boolean released = false;\n+\n+        @Override\n+        public void close() {\n+            checkValidState(); \/\/ thread check\n+            if (!released) {\n+                released = true;\n+                lockCount--;\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ConfinedScope.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -37,1 +37,0 @@\n-import java.util.function.Supplier;\n@@ -55,2 +54,2 @@\n-    HeapMemorySegmentImpl(long offset, H base, long length, int mask, MemoryScope scope) {\n-        super(length, mask, scope);\n+    HeapMemorySegmentImpl(long offset, H base, long length, int mask) {\n+        super(length, mask, MemoryScope.GLOBAL);\n@@ -78,1 +77,1 @@\n-        return nioAccess.newHeapByteBuffer((byte[]) base(), (int)min() - BYTE_ARR_BASE, (int) byteSize(), this);\n+        return nioAccess.newHeapByteBuffer((byte[]) base(), (int)min() - BYTE_ARR_BASE, (int) byteSize(), null);\n@@ -85,2 +84,2 @@\n-        OfByte(long offset, byte[] base, long length, int mask, MemoryScope scope) {\n-            super(offset, base, length, mask, scope);\n+        OfByte(long offset, byte[] base, long length, int mask) {\n+            super(offset, base, length, mask);\n@@ -91,1 +90,1 @@\n-            return new OfByte(this.offset + offset, base, size, mask, scope);\n+            return new OfByte(this.offset + offset, base, size, mask);\n@@ -102,2 +101,1 @@\n-            MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n-            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize), scope);\n+            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize));\n@@ -109,2 +107,2 @@\n-        OfChar(long offset, char[] base, long length, int mask, MemoryScope scope) {\n-            super(offset, base, length, mask, scope);\n+        OfChar(long offset, char[] base, long length, int mask) {\n+            super(offset, base, length, mask);\n@@ -115,1 +113,1 @@\n-            return new OfChar(this.offset + offset, base, size, mask, scope);\n+            return new OfChar(this.offset + offset, base, size, mask);\n@@ -126,2 +124,1 @@\n-            MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n-            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize), scope);\n+            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize));\n@@ -133,2 +130,2 @@\n-        OfShort(long offset, short[] base, long length, int mask, MemoryScope scope) {\n-            super(offset, base, length, mask, scope);\n+        OfShort(long offset, short[] base, long length, int mask) {\n+            super(offset, base, length, mask);\n@@ -139,1 +136,1 @@\n-            return new OfShort(this.offset + offset, base, size, mask, scope);\n+            return new OfShort(this.offset + offset, base, size, mask);\n@@ -150,2 +147,1 @@\n-            MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n-            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize), scope);\n+            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize));\n@@ -157,2 +153,2 @@\n-        OfInt(long offset, int[] base, long length, int mask, MemoryScope scope) {\n-            super(offset, base, length, mask, scope);\n+        OfInt(long offset, int[] base, long length, int mask) {\n+            super(offset, base, length, mask);\n@@ -163,1 +159,1 @@\n-            return new OfInt(this.offset + offset, base, size, mask, scope);\n+            return new OfInt(this.offset + offset, base, size, mask);\n@@ -174,2 +170,1 @@\n-            MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n-            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize), scope);\n+            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize));\n@@ -181,2 +176,2 @@\n-        OfLong(long offset, long[] base, long length, int mask, MemoryScope scope) {\n-            super(offset, base, length, mask, scope);\n+        OfLong(long offset, long[] base, long length, int mask) {\n+            super(offset, base, length, mask);\n@@ -187,1 +182,1 @@\n-            return new OfLong(this.offset + offset, base, size, mask, scope);\n+            return new OfLong(this.offset + offset, base, size, mask);\n@@ -198,2 +193,1 @@\n-            MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n-            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize), scope);\n+            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize));\n@@ -205,2 +199,2 @@\n-        OfFloat(long offset, float[] base, long length, int mask, MemoryScope scope) {\n-            super(offset, base, length, mask, scope);\n+        OfFloat(long offset, float[] base, long length, int mask) {\n+            super(offset, base, length, mask);\n@@ -211,1 +205,1 @@\n-            return new OfFloat(this.offset + offset, base, size, mask, scope);\n+            return new OfFloat(this.offset + offset, base, size, mask);\n@@ -222,2 +216,1 @@\n-            MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n-            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize), scope);\n+            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize));\n@@ -229,2 +222,2 @@\n-        OfDouble(long offset, double[] base, long length, int mask, MemoryScope scope) {\n-            super(offset, base, length, mask, scope);\n+        OfDouble(long offset, double[] base, long length, int mask) {\n+            super(offset, base, length, mask);\n@@ -235,1 +228,1 @@\n-            return new OfDouble(this.offset + offset, base, size, mask, scope);\n+            return new OfDouble(this.offset + offset, base, size, mask);\n@@ -246,2 +239,1 @@\n-            MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n-            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize), scope);\n+            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize));\n@@ -250,0 +242,1 @@\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":32,"deletions":39,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -34,1 +35,0 @@\n-import jdk.internal.ref.CleanerFactory;\n@@ -36,4 +36,2 @@\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.IdentityHashMap;\n+import java.lang.ref.Reference;\n+import java.lang.ref.WeakReference;\n@@ -43,1 +41,1 @@\n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -52,1 +50,1 @@\n-    private final static Map<NativeLibrary, AtomicInteger> loadedLibraries = new IdentityHashMap<>();\n+    private final static Map<NativeLibrary, WeakReference<ResourceScope>> loadedLibraries = new ConcurrentHashMap<>();\n@@ -79,8 +77,0 @@\n-    \/\/ return the absolute path of the library of given name by searching\n-    \/\/ in the given array of paths.\n-    private static Optional<Path> findLibraryPath(Path[] paths, String libName) {\n-         return Arrays.stream(paths).\n-              map(p -> p.resolve(System.mapLibraryName(libName))).\n-              filter(Files::isRegularFile).map(Path::toAbsolutePath).findFirst();\n-    }\n-\n@@ -91,1 +81,1 @@\n-    synchronized static LibraryLookupImpl lookup(Supplier<NativeLibrary> librarySupplier, String notFoundMsg) {\n+    static LibraryLookupImpl lookup(Supplier<NativeLibrary> librarySupplier, String notFoundMsg) {\n@@ -96,12 +86,14 @@\n-        AtomicInteger refCount = loadedLibraries.computeIfAbsent(library, lib -> new AtomicInteger());\n-        refCount.incrementAndGet();\n-        LibraryLookupImpl lookup = new LibraryLookupImpl(library);\n-        CleanerFactory.cleaner().register(lookup, () -> tryUnload(library));\n-        return lookup;\n-    }\n-\n-    synchronized static void tryUnload(NativeLibrary library) {\n-        AtomicInteger refCount = loadedLibraries.get(library);\n-        if (refCount.decrementAndGet() == 0) {\n-            loadedLibraries.remove(library);\n-            nativeLibraries.unload(library);\n+        ResourceScope[] holder = new ResourceScope[1];\n+        try {\n+            WeakReference<ResourceScope> scopeRef = loadedLibraries.computeIfAbsent(library, lib -> {\n+                MemoryScope s = MemoryScope.createDefault();\n+                holder[0] = s; \/\/ keep the scope alive at least until the outer method returns\n+                s.addOrCleanupIfFail(MemoryScope.ResourceList.ResourceCleanup.ofRunnable(() -> {\n+                    nativeLibraries.unload(library);\n+                    loadedLibraries.remove(library);\n+                }));\n+                return new WeakReference<>(s);\n+            });\n+            return new LibraryLookupImpl(library, scopeRef.get());\n+        } finally {\n+            Reference.reachabilityFence(holder);\n@@ -111,0 +103,1 @@\n+    \/\/Todo: in principle we could expose a scope accessor, so that users could unload libraries at will\n@@ -113,0 +106,1 @@\n+        final ResourceScope scope;\n@@ -114,1 +108,1 @@\n-        LibraryLookupImpl(NativeLibrary library) {\n+        LibraryLookupImpl(NativeLibrary library, ResourceScope scope) {\n@@ -116,0 +110,1 @@\n+            this.scope = scope;\n@@ -123,1 +118,1 @@\n-                return Optional.of(new Symbol() { \/\/ inner class - retains a link to enclosing lookup\n+                return Optional.of(new Symbol() { \/\/ inner class - retains a link to the scope\n@@ -139,1 +134,1 @@\n-        static LibraryLookup DEFAULT_LOOKUP = new LibraryLookupImpl(NativeLibraries.defaultLibrary);\n+        static LibraryLookup DEFAULT_LOOKUP = new LibraryLookupImpl(NativeLibraries.defaultLibrary, MemoryScope.GLOBAL);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LibrariesHelper.java","additions":26,"deletions":31,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.io.FileDescriptor;\n@@ -43,1 +42,0 @@\n-import java.util.Optional;\n@@ -64,1 +62,2 @@\n-        return nioAccess.newMappedByteBuffer(unmapper, min, (int)length, null, this);\n+        return nioAccess.newMappedByteBuffer(unmapper, min, (int)length, null,\n+                scope == MemoryScope.GLOBAL ? null : this);\n@@ -80,5 +79,0 @@\n-    @Override\n-    public MappedMemorySegmentImpl withAccessModes(int accessModes) {\n-        return (MappedMemorySegmentImpl)super.withAccessModes(accessModes);\n-    }\n-\n@@ -114,1 +108,1 @@\n-    public static MemorySegment makeMappedSegment(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {\n+    public static MemorySegment makeMappedSegment(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode, MemoryScope scope) throws IOException {\n@@ -117,0 +111,1 @@\n+        scope.checkValidStateSlow();\n@@ -128,1 +123,1 @@\n-                modes &= ~WRITE;\n+                modes |= READ_ONLY;\n@@ -131,2 +126,1 @@\n-                MemoryScope scope = MemoryScope.createConfined(null, unmapperProxy::unmap, null);\n-                return new MappedMemorySegmentImpl(unmapperProxy.address(), unmapperProxy, bytesSize,\n+                AbstractMemorySegmentImpl segment = new MappedMemorySegmentImpl(unmapperProxy.address(), unmapperProxy, bytesSize,\n@@ -134,0 +128,7 @@\n+                scope.addOrCleanupIfFail(new MemoryScope.ResourceList.ResourceCleanup() {\n+                    @Override\n+                    public void cleanup() {\n+                        unmapperProxy.unmap();\n+                    }\n+                });\n+                return segment;\n@@ -135,1 +136,1 @@\n-                return new EmptyMappedMemorySegmentImpl(modes);\n+                return new EmptyMappedMemorySegmentImpl(modes, scope);\n@@ -152,3 +153,2 @@\n-        public EmptyMappedMemorySegmentImpl(int modes) {\n-            super(0, null, 0, modes,\n-                    MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null));\n+        public EmptyMappedMemorySegmentImpl(int modes, MemoryScope scope) {\n+            super(0, null, 0, modes, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -96,1 +97,2 @@\n-    public MemorySegment asSegmentRestricted(long bytesSize, Runnable cleanupAction, Object attachment) {\n+    public MemorySegment asSegmentRestricted(long bytesSize, Runnable cleanupAction, ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n@@ -101,1 +103,3 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(this, bytesSize, cleanupAction, attachment);\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(this, bytesSize,\n+                cleanupAction,\n+                (MemoryScope) scope);\n@@ -108,0 +112,4 @@\n+    public static MemorySegment ofLongUnchecked(long value, long byteSize, MemoryScope memoryScope) {\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize, null, memoryScope);\n+    }\n+\n@@ -109,1 +117,1 @@\n-        return MemoryAddress.ofLong(value).asSegmentRestricted(byteSize).share();\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize, null, MemoryScope.GLOBAL);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -30,2 +31,1 @@\n-import jdk.internal.ref.PhantomCleanable;\n-import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.ref.CleanerFactory;\n@@ -33,2 +33,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n@@ -42,1 +40,1 @@\n- * (this operation is triggered by {@link AbstractMemorySegmentImpl#close()}). This bit is consulted prior\n+ * (this operation is triggered by {@link ResourceScope#close()}). This bit is consulted prior\n@@ -52,1 +50,1 @@\n-abstract class MemoryScope implements ScopedMemoryAccess.Scope {\n+public abstract class MemoryScope implements ResourceScope, ScopedMemoryAccess.Scope {\n@@ -54,1 +52,2 @@\n-    static final Runnable DUMMY_CLEANUP_ACTION = () -> { };\n+    final ResourceList resourceList;\n+    final boolean closeable;\n@@ -56,2 +55,34 @@\n-    private MemoryScope(Object ref, Runnable cleanupAction, Cleaner cleaner) {\n-        Objects.requireNonNull(cleanupAction);\n+    @Override\n+    public void addOnClose(Runnable runnable) {\n+        Objects.requireNonNull(runnable);\n+        addInternal(ResourceList.ResourceCleanup.ofRunnable(runnable));\n+    }\n+\n+    \/**\n+     * Add a cleanup action. If a failure occurred (because of a add vs. close race), call the cleanup action.\n+     * This semantics is useful when allocating new memory segments, since we first do a malloc\/mmap and _then_\n+     * we register the cleanup (free\/munmap) against the scope; so, if registration fails, we still have to\n+     * cleanup memory. From the perspective of the client, such a failure would manifest as a factory\n+     * returning a segment that is already \"closed\" - which is always possible anyway (e.g. if the scope\n+     * is closed _after_ the cleanup for the segment is registered but _before_ the factory returns the\n+     * new segment to the client). For this reason, it's not worth adding extra complexity to the segment\n+     * initialization logic here - and using an optimistic logic works well in practice.\n+     *\/\n+    public void addOrCleanupIfFail(ResourceList.ResourceCleanup resource) {\n+        try {\n+            addInternal(resource);\n+        } catch (Throwable ex) {\n+            resource.cleanup();\n+        }\n+    }\n+\n+    void addInternal(ResourceList.ResourceCleanup resource) {\n+        try {\n+            checkValidStateSlow();\n+            resourceList.add(resource);\n+        } catch (ScopedMemoryAccess.Scope.ScopedAccessError err) {\n+            throw new IllegalStateException(\"Already closed\");\n+        }\n+    }\n+\n+    protected MemoryScope(Object ref, Cleaner cleaner, boolean closeable, ResourceList resourceList) {\n@@ -59,4 +90,13 @@\n-        this.cleanupAction = cleanupAction;\n-        this.scopeCleanable = cleaner != null ?\n-                new ScopeCleanable(this, cleaner, cleanupAction) :\n-                null;\n+        this.resourceList = resourceList;\n+        this.closeable = closeable;\n+        if (cleaner != null) {\n+            cleaner.register(this, resourceList);\n+        }\n+    }\n+\n+    public static MemoryScope createDefault() {\n+        return new SharedScope(null, CleanerFactory.cleaner(), false);\n+    }\n+\n+    public static MemoryScope createConfined(Thread thread, Object ref, Cleaner cleaner) {\n+        return new ConfinedScope(thread, ref, cleaner, true);\n@@ -69,1 +109,0 @@\n-     * @param cleanupAction a cleanup action to be executed when returned scope is closed\n@@ -72,2 +111,2 @@\n-    static MemoryScope createConfined(Object ref, Runnable cleanupAction, Cleaner cleaner) {\n-        return new ConfinedScope(Thread.currentThread(), ref, cleanupAction, cleaner);\n+    public static MemoryScope createConfined(Object ref, Cleaner cleaner) {\n+        return new ConfinedScope(Thread.currentThread(), ref, cleaner, true);\n@@ -79,1 +118,0 @@\n-     * @param cleanupAction a cleanup action to be executed when returned scope is closed\n@@ -82,2 +120,2 @@\n-    static MemoryScope createShared(Object ref, Runnable cleanupAction, Cleaner cleaner) {\n-        return new SharedScope(ref, cleanupAction, cleaner);\n+    public static MemoryScope createShared(Object ref, Cleaner cleaner) {\n+        return new SharedScope(ref, cleaner, true);\n@@ -87,2 +125,0 @@\n-    protected final ScopeCleanable scopeCleanable;\n-    protected final Runnable cleanupAction;\n@@ -95,31 +131,3 @@\n-    final void close() {\n-        try {\n-            justClose();\n-            cleanupAction.run();\n-            if (scopeCleanable != null) {\n-                scopeCleanable.clear();\n-            }\n-        } finally {\n-            Reference.reachabilityFence(this);\n-        }\n-    }\n-\n-    abstract void justClose();\n-\n-    \/**\n-     * Duplicates this scope with given new \"owner\" thread and {@link #close() closes} it.\n-     * @param newOwner new owner thread of the returned memory scope\n-     * @return a new confined scope, which is a duplicate of this scope, but with a new owner thread.\n-     * @throws IllegalStateException if this scope is already closed or if this is\n-     * a confined scope and this method is called outside of the owner thread.\n-     *\/\n-    final MemoryScope confineTo(Thread newOwner) {\n-        try {\n-            justClose();\n-            if (scopeCleanable != null) {\n-                scopeCleanable.clear();\n-            }\n-            return new ConfinedScope(newOwner, ref, cleanupAction, scopeCleanable != null ?\n-                    scopeCleanable.cleaner : null);\n-        } finally {\n-            Reference.reachabilityFence(this);\n+    public final void close() {\n+        if (!closeable) {\n+            throw new UnsupportedOperationException(\"Scope cannot be closed\");\n@@ -127,10 +135,0 @@\n-    }\n-\n-    \/**\n-     * Duplicates this scope with given new \"owner\" thread and {@link #close() closes} it.\n-     * @return a new shared scope, which is a duplicate of this scope.\n-     * @throws IllegalStateException if this scope is already closed or if this is\n-     * a confined scope and this method is called outside of the owner thread,\n-     * or if this is already a shared scope.\n-     *\/\n-    final MemoryScope share() {\n@@ -139,5 +137,1 @@\n-            if (scopeCleanable != null) {\n-                scopeCleanable.clear();\n-            }\n-            return new SharedScope(ref, cleanupAction, scopeCleanable != null ?\n-                    scopeCleanable.cleaner : null);\n+            resourceList.cleanup();\n@@ -149,13 +143,1 @@\n-    final MemoryScope cleanable(Cleaner cleaner) {\n-        if (scopeCleanable != null) {\n-            throw new IllegalStateException(\"Already registered with a cleaner\");\n-        }\n-        try {\n-            justClose();\n-            return ownerThread() == null ?\n-                    new SharedScope(ref, cleanupAction, cleaner) :\n-                    new ConfinedScope(ownerThread(), ref, cleanupAction, cleaner);\n-        } finally {\n-            Reference.reachabilityFence(this);\n-        }\n-    }\n+    abstract void justClose();\n@@ -175,0 +157,9 @@\n+\n+    \/**\n+     * This is a faster version of {@link #checkValidStateSlow()}, which is called upon memory access, and which\n+     * relies on invariants associated with the memory scope implementations (typically, volatile access\n+     * to the closed state bit is replaced with plain access, and ownership check is removed where not needed.\n+     * Should be used with care.\n+     *\/\n+    public abstract void checkValidState();\n+\n@@ -180,1 +171,7 @@\n-    public abstract void checkValidState();\n+    public final void checkValidStateSlow() {\n+        if (ownerThread() != null && Thread.currentThread() != ownerThread()) {\n+            throw new IllegalStateException(\"Attempted access outside owning thread\");\n+        } else if (!isAlive()) {\n+            throw new IllegalStateException(\"Already closed\");\n+        }\n+    }\n@@ -187,26 +184,1 @@\n-    \/**\n-     * A confined scope, which features an owner thread. The liveness check features an additional\n-     * confinement check - that is, calling any operation on this scope from a thread other than the\n-     * owner thread will result in an exception. Because of this restriction, checking the liveness bit\n-     * can be performed in plain mode (see {@link #checkAliveRaw(MemoryScope)}).\n-     *\/\n-    static class ConfinedScope extends MemoryScope {\n-\n-        private boolean closed; \/\/ = false\n-        final Thread owner;\n-\n-        public ConfinedScope(Thread owner, Object ref, Runnable cleanupAction, Cleaner cleaner) {\n-            super(ref, cleanupAction, cleaner);\n-            this.owner = owner;\n-        }\n-\n-        @ForceInline\n-        public final void checkValidState() {\n-            if (owner != Thread.currentThread()) {\n-                throw new IllegalStateException(\"Attempted access outside owning thread\");\n-            }\n-            if (closed) {\n-                throw ScopedAccessError.INSTANCE;\n-            }\n-        }\n-\n+    public static MemoryScope GLOBAL = new SharedScope( null, null, false) {\n@@ -214,2 +186,2 @@\n-        public boolean isAlive() {\n-            return !closed;\n+        void addInternal(ResourceList.ResourceCleanup resource) {\n+            \/\/ do nothing\n@@ -217,0 +189,1 @@\n+    };\n@@ -218,10 +191,1 @@\n-        void justClose() {\n-            checkValidState();\n-            closed = true;\n-        }\n-\n-        @Override\n-        public Thread ownerThread() {\n-            return owner;\n-        }\n-    }\n+    public final Handle DUMMY_LOCK = () -> { };\n@@ -230,8 +194,4 @@\n-     * A shared scope, which can be shared across multiple threads. Closing a shared scope has to ensure that\n-     * (i) only one thread can successfully close a scope (e.g. in a close vs. close race) and that\n-     * (ii) no other thread is accessing the memory associated with this scope while the segment is being\n-     * closed. To ensure the former condition, a CAS is performed on the liveness bit. Ensuring the latter\n-     * is trickier, and require a complex synchronization protocol (see {@link jdk.internal.misc.ScopedMemoryAccess}).\n-     * Since it is the responsibility of the closing thread to make sure that no concurrent access is possible,\n-     * checking the liveness bit upon access can be performed in plain mode (see {@link #checkAliveRaw(MemoryScope)}),\n-     * as in the confined case.\n+     * A list of all cleanup actions associated with a resource scope. Cleanup actions are modelled as instances\n+     * of the {@link ResourceCleanup} class, and, together, form a linked list. Depending on whether a scope\n+     * is shared or confined, different implementations of this class will be used, see {@link ConfinedScope.ConfinedResourceList}\n+     * and {@link SharedScope.SharedResourceList}.\n@@ -239,3 +199,2 @@\n-    static class SharedScope extends MemoryScope {\n-\n-        static ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+    public abstract static class ResourceList implements Runnable {\n+        ResourceCleanup fst;\n@@ -243,3 +202,1 @@\n-        final static int ALIVE = 0;\n-        final static int CLOSING = 1;\n-        final static int CLOSED = 2;\n+        abstract void add(ResourceCleanup cleanup);\n@@ -247,1 +204,1 @@\n-        int state = ALIVE;\n+        abstract void cleanup();\n@@ -249,12 +206,2 @@\n-        private static final VarHandle STATE;\n-\n-        static {\n-            try {\n-                STATE = MethodHandles.lookup().findVarHandle(SharedScope.class, \"state\", int.class);\n-            } catch (Throwable ex) {\n-                throw new ExceptionInInitializerError(ex);\n-            }\n-        }\n-\n-        SharedScope(Object ref, Runnable cleanupAction, Cleaner cleaner) {\n-            super(ref, cleanupAction, cleaner);\n+        public final void run() {\n+            cleanup(); \/\/ cleaner interop\n@@ -263,9 +210,5 @@\n-        @Override\n-        public Thread ownerThread() {\n-            return null;\n-        }\n-\n-        @Override\n-        public void checkValidState() {\n-            if (state != ALIVE) {\n-                throw ScopedAccessError.INSTANCE;\n+        static void cleanup(ResourceCleanup first) {\n+            ResourceCleanup current = first;\n+            while (current != null) {\n+                current.cleanup();\n+                current = current.next;\n@@ -275,10 +218,2 @@\n-        void justClose() {\n-            if (!STATE.compareAndSet(this, ALIVE, CLOSING)) {\n-                throw new IllegalStateException(\"Already closed\");\n-            }\n-            boolean success = SCOPED_MEMORY_ACCESS.closeScope(this);\n-            STATE.setVolatile(this, success ? CLOSED : ALIVE);\n-            if (!success) {\n-                throw new IllegalStateException(\"Cannot close while another thread is accessing the segment\");\n-            }\n-        }\n+        public static abstract class ResourceCleanup {\n+            ResourceCleanup next;\n@@ -286,5 +221,1 @@\n-        @Override\n-        public boolean isAlive() {\n-            return (int)STATE.getVolatile(this) != CLOSED;\n-        }\n-    }\n+            public abstract void cleanup();\n@@ -292,3 +223,6 @@\n-    static class ScopeCleanable extends PhantomCleanable<MemoryScope> {\n-        final Cleaner cleaner;\n-        final Runnable cleanupAction;\n+            final static ResourceCleanup CLOSED_LIST = new ResourceCleanup() {\n+                @Override\n+                public void cleanup() {\n+                    throw new IllegalStateException(\"This resource list has already been closed!\");\n+                }\n+            };\n@@ -296,4 +230,8 @@\n-        public ScopeCleanable(MemoryScope referent, Cleaner cleaner, Runnable cleanupAction) {\n-            super(referent, cleaner);\n-            this.cleaner = cleaner;\n-            this.cleanupAction = cleanupAction;\n+            static ResourceCleanup ofRunnable(Runnable cleanupAction) {\n+                return new ResourceCleanup() {\n+                    @Override\n+                    public void cleanup() {\n+                        cleanupAction.run();\n+                    }\n+                };\n+            }\n@@ -302,4 +240,0 @@\n-        @Override\n-        protected void performCleanup() {\n-            cleanupAction.run();\n-        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryScope.java","additions":115,"deletions":181,"binary":false,"changes":296,"status":"modified"},{"patch":"@@ -44,3 +44,1 @@\n-    public static final MemorySegment EVERYTHING = makeNativeSegmentUnchecked(MemoryAddress.NULL, Long.MAX_VALUE, MemoryScope.DUMMY_CLEANUP_ACTION, null)\n-            .share()\n-            .withAccessModes(READ | WRITE);\n+    public static final MemorySegment EVERYTHING = makeNativeSegmentUnchecked(MemoryAddress.NULL, Long.MAX_VALUE, null, MemoryScope.GLOBAL);\n@@ -71,1 +69,2 @@\n-        return nioAccess.newDirectByteBuffer(min(), (int) this.length, null, this);\n+        return nioAccess.newDirectByteBuffer(min(), (int) this.length, null,\n+                scope == MemoryScope.GLOBAL ? null : this);\n@@ -86,1 +85,2 @@\n-    public static MemorySegment makeNativeSegment(long bytesSize, long alignmentBytes) {\n+    public static MemorySegment makeNativeSegment(long bytesSize, long alignmentBytes, MemoryScope scope) {\n+        scope.checkValidStateSlow();\n@@ -101,1 +101,5 @@\n-        MemoryScope scope = MemoryScope.createConfined(null, () -> {\n+        AbstractMemorySegmentImpl segment = new NativeMemorySegmentImpl(buf, alignedSize,\n+                defaultAccessModes(alignedSize), scope);\n+        scope.addOrCleanupIfFail(new MemoryScope.ResourceList.ResourceCleanup() {\n+            @Override\n+            public void cleanup() {\n@@ -104,3 +108,2 @@\n-            }, null);\n-        MemorySegment segment = new NativeMemorySegmentImpl(buf, alignedSize,\n-                defaultAccessModes(alignedSize), scope);\n+            }\n+        });\n@@ -114,3 +117,7 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, Runnable cleanupAction, Object ref) {\n-        return new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, defaultAccessModes(bytesSize),\n-                MemoryScope.createConfined(ref, cleanupAction == null ? MemoryScope.DUMMY_CLEANUP_ACTION : cleanupAction, null));\n+    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, Runnable cleanupAction, MemoryScope scope) {\n+        scope.checkValidStateSlow();\n+        AbstractMemorySegmentImpl segment = new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, defaultAccessModes(bytesSize), scope);\n+        if (cleanupAction != null) {\n+            scope.addOnClose(cleanupAction);\n+        }\n+        return segment;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.misc.ScopedMemoryAccess;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.ref.Cleaner;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+\/**\n+ * A shared scope, which can be shared across multiple threads. Closing a shared scope has to ensure that\n+ * (i) only one thread can successfully close a scope (e.g. in a close vs. close race) and that\n+ * (ii) no other thread is accessing the memory associated with this scope while the segment is being\n+ * closed. To ensure the former condition, a CAS is performed on the liveness bit. Ensuring the latter\n+ * is trickier, and require a complex synchronization protocol (see {@link jdk.internal.misc.ScopedMemoryAccess}).\n+ * Since it is the responsibility of the closing thread to make sure that no concurrent access is possible,\n+ * checking the liveness bit upon access can be performed in plain mode, as in the confined case.\n+ *\/\n+class SharedScope extends MemoryScope {\n+\n+    private static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n+    private final static int ALIVE = 0;\n+    private final static int CLOSING = -1;\n+    private final static int CLOSED = -2;\n+    private final static int MAX_FORKS = Integer.MAX_VALUE;\n+\n+    private int state = ALIVE;\n+\n+    private static final VarHandle STATE;\n+\n+    static {\n+        try {\n+            STATE = MethodHandles.lookup().findVarHandle(jdk.internal.foreign.SharedScope.class, \"state\", int.class);\n+        } catch (Throwable ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n+    SharedScope(Object ref, Cleaner cleaner, boolean closeable) {\n+        super(ref, cleaner, closeable, new SharedResourceList());\n+    }\n+\n+    @Override\n+    public Thread ownerThread() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void checkValidState() {\n+        if (state < ALIVE) {\n+            throw ScopedAccessError.INSTANCE;\n+        }\n+    }\n+\n+    @Override\n+    public Handle acquire() {\n+        if (!closeable) return DUMMY_LOCK;\n+        int value;\n+        do {\n+            value = (int) STATE.getVolatile(this);\n+            if (value < ALIVE) {\n+                \/\/segment is not alive!\n+                throw new IllegalStateException(\"Already closed\");\n+            } else if (value == MAX_FORKS) {\n+                \/\/overflow\n+                throw new IllegalStateException(\"Segment acquire limit exceeded\");\n+            }\n+        } while (!STATE.compareAndSet(this, value, value + 1));\n+        return new SharedHandle();\n+    }\n+\n+    void justClose() {\n+        int prevState = (int) STATE.compareAndExchange(this, ALIVE, CLOSING);\n+        if (prevState < 0) {\n+            throw new IllegalStateException(\"Already closed\");\n+        } else if (prevState != ALIVE) {\n+            throw new IllegalStateException(\"Scope is acquired by \" + prevState + \" locks\");\n+        }\n+        boolean success = SCOPED_MEMORY_ACCESS.closeScope(this);\n+        STATE.setVolatile(this, success ? CLOSED : ALIVE);\n+        if (!success) {\n+            throw new IllegalStateException(\"Cannot close while another thread is accessing the segment\");\n+        }\n+    }\n+\n+    @Override\n+    public boolean isAlive() {\n+        return (int) STATE.getVolatile(this) != CLOSED;\n+    }\n+\n+    \/**\n+     * A shared resource list; this implementation has to handle add vs. add races, as well as add vs. cleanup races.\n+     *\/\n+    static class SharedResourceList extends ResourceList {\n+\n+        static final VarHandle FST;\n+\n+        static {\n+            try {\n+                FST = MethodHandles.lookup().findVarHandle(ResourceList.class, \"fst\", ResourceCleanup.class);\n+            } catch (Throwable ex) {\n+                throw new ExceptionInInitializerError();\n+            }\n+        }\n+\n+        @Override\n+        void add(ResourceCleanup cleanup) {\n+            while (true) {\n+                ResourceCleanup prev = (ResourceCleanup) FST.getAcquire(this);\n+                cleanup.next = prev;\n+                ResourceCleanup newSegment = (ResourceCleanup) FST.compareAndExchangeRelease(this, prev, cleanup);\n+                if (newSegment == ResourceCleanup.CLOSED_LIST) {\n+                    \/\/ too late\n+                    throw new IllegalStateException(\"Already closed\");\n+                } else if (newSegment == prev) {\n+                    return; \/\/victory\n+                }\n+                \/\/ keep trying\n+            }\n+        }\n+\n+        void cleanup() {\n+            \/\/ At this point we are only interested about add vs. close races - not close vs. close\n+            \/\/ (because MemoryScope::justClose ensured that this thread won the race to close the scope).\n+            \/\/ So, the only \"bad\" thing that could happen is that some other thread adds to this list\n+            \/\/ while we're closing it.\n+            if (FST.getAcquire(this) != ResourceCleanup.CLOSED_LIST) {\n+                \/\/ok now we're really closing down\n+                ResourceCleanup prev = null;\n+                while (true) {\n+                    prev = (ResourceCleanup) FST.getAcquire(this);\n+                    \/\/ no need to check for DUMMY, since only one thread can get here!\n+                    if (FST.weakCompareAndSetRelease(this, prev, ResourceCleanup.CLOSED_LIST)) {\n+                        break;\n+                    }\n+                }\n+                cleanup(prev);\n+            } else {\n+                throw new IllegalStateException(\"Attempt to cleanup an already closed resource list\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A shared resource scope handle; this implementation has to handle close vs. close races.\n+     *\/\n+    class SharedHandle implements Handle {\n+        final AtomicBoolean released = new AtomicBoolean(false);\n+\n+        @Override\n+        public void close() {\n+            if (released.compareAndSet(false, true)) {\n+                int value;\n+                do {\n+                    value = (int) STATE.getVolatile(jdk.internal.foreign.SharedScope.this);\n+                    if (value <= ALIVE) {\n+                        \/\/cannot get here - we can't close segment twice\n+                        throw new IllegalStateException(\"Already closed\");\n+                    }\n+                } while (!STATE.compareAndSet(jdk.internal.foreign.SharedScope.this, value, value - 1));\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SharedScope.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -153,1 +153,0 @@\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -32,0 +34,1 @@\n+import jdk.internal.foreign.MemoryScope;\n@@ -219,1 +222,1 @@\n-                    methodType(MemorySegment.class, MemorySegment.class, long.class, long.class, SharedUtils.Allocator.class));\n+                    methodType(MemorySegment.class, MemorySegment.class, long.class, long.class, Context.class));\n@@ -221,1 +224,1 @@\n-                    methodType(MemorySegment.class, long.class, long.class, SharedUtils.Allocator.class));\n+                    methodType(MemorySegment.class, long.class, long.class, Context.class));\n@@ -223,1 +226,1 @@\n-                    methodType(MemorySegment.class, MemoryAddress.class, long.class, SharedUtils.Allocator.class));\n+                    methodType(MemorySegment.class, MemoryAddress.class, long.class, Context.class));\n@@ -229,0 +232,89 @@\n+    \/**\n+     * A binding context is used as an helper to carry out evaluation of certain bindings; for instance,\n+     * it helps {@link Allocate} bindings, by providing the {@link SegmentAllocator} that should be used for\n+     * the allocation operation, or {@link ToSegment} bindings, by providing the {@link ResourceScope} that\n+     * should be used to create an unsafe struct from a memory address.\n+     *\/\n+    public static class Context implements AutoCloseable {\n+        private final SegmentAllocator allocator;\n+        private final ResourceScope scope;\n+\n+        private Context(SegmentAllocator allocator, ResourceScope scope) {\n+            this.allocator = allocator;\n+            this.scope = scope;\n+        }\n+\n+        public SegmentAllocator allocator() {\n+            return allocator;\n+        }\n+\n+        public ResourceScope scope() {\n+            return scope;\n+        }\n+\n+        @Override\n+        public void close() {\n+            scope().close();\n+        }\n+\n+        \/**\n+         * Create a binding context from given native scope.\n+         *\/\n+        public static Context ofBoundedAllocator(long size) {\n+            ResourceScope scope = ResourceScope.ofConfined();\n+            return new Context(SegmentAllocator.arenaBounded(size, scope), scope);\n+        }\n+\n+        \/**\n+         * Create a binding context from given segment allocator. The resulting context will throw when\n+         * the context's scope is accessed.\n+         *\/\n+        public static Context ofAllocator(SegmentAllocator allocator) {\n+            return new Context(allocator, null) {\n+                @Override\n+                public ResourceScope scope() {\n+                    throw new UnsupportedOperationException();\n+                }\n+            };\n+        }\n+\n+        \/**\n+         * Create a binding context from given scope. The resulting context will throw when\n+         * the context's allocator is accessed.\n+         *\/\n+        public static Context ofScope() {\n+            ResourceScope scope = ResourceScope.ofConfined();\n+            return new Context(null, scope) {\n+                @Override\n+                public SegmentAllocator allocator() { throw new UnsupportedOperationException(); }\n+            };\n+        }\n+\n+        \/**\n+         * Dummy binding context. Throws exceptions when attempting to access allocator\/scope, and its\n+         * {@link #close()} is idempotent.\n+         *\/\n+        public static Context DUMMY = new Context(null, null) {\n+            @Override\n+            public SegmentAllocator allocator() {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public ResourceScope scope() {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public void close() {\n+                \/\/ do nothing\n+            }\n+        };\n+\n+        \/**\n+         * Default binding context. Does not provide a resource scope, but provides a default {@link SegmentAllocator}\n+         * which uses {@link MemorySegment#allocateNative(long, long)}.\n+         *\/\n+        public static Context DEFAULT = ofAllocator(MemorySegment::allocateNative);\n+    }\n+\n@@ -256,1 +348,1 @@\n-                                   BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator);\n+                                   BindingInterpreter.LoadFunc loadFunc, Context context);\n@@ -457,1 +549,1 @@\n-                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n@@ -492,1 +584,1 @@\n-                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n@@ -572,1 +664,1 @@\n-                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n@@ -616,1 +708,1 @@\n-                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n@@ -656,2 +748,2 @@\n-                                                    SharedUtils.Allocator allocator) {\n-            MemorySegment copy = allocator.allocate(size, alignment);\n+                                                    Context context) {\n+            MemorySegment copy = context.allocator().allocate(size, alignment);\n@@ -688,1 +780,1 @@\n-                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n@@ -690,1 +782,1 @@\n-            MemorySegment copy = copyBuffer(operand, size, alignment, allocator);\n+            MemorySegment copy = copyBuffer(operand, size, alignment, context);\n@@ -731,2 +823,2 @@\n-        private static MemorySegment allocateBuffer(long size, long allignment, SharedUtils.Allocator allocator) {\n-            return allocator.allocate(size, allignment);\n+        private static MemorySegment allocateBuffer(long size, long allignment, Context context) {\n+            return context.allocator().allocate(size, allignment);\n@@ -759,2 +851,2 @@\n-                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n-            stack.push(allocateBuffer(size, alignment, allocator));\n+                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+            stack.push(allocateBuffer(size, alignment, context));\n@@ -806,1 +898,1 @@\n-                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n@@ -841,1 +933,1 @@\n-                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n@@ -876,1 +968,1 @@\n-                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n@@ -905,3 +997,2 @@\n-        private static MemorySegment toSegment(MemoryAddress operand, long size, SharedUtils.Allocator allocator) {\n-            MemorySegment ms = MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size);\n-            return allocator.handoff(ms);\n+        private static MemorySegment toSegment(MemoryAddress operand, long size, Context context) {\n+            return MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size, (MemoryScope) context.scope);\n@@ -919,1 +1010,1 @@\n-                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n@@ -921,1 +1012,1 @@\n-            MemorySegment segment = toSegment(operand, size, allocator);\n+            MemorySegment segment = toSegment(operand, size, context);\n@@ -972,1 +1063,1 @@\n-                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":116,"deletions":25,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-    static void unbox(Object arg, List<Binding> bindings, StoreFunc storeFunc, SharedUtils.Allocator allocator) {\n+    static void unbox(Object arg, List<Binding> bindings, StoreFunc storeFunc, Binding.Context context) {\n@@ -38,1 +38,1 @@\n-            b.interpret(stack, storeFunc, null, allocator);\n+            b.interpret(stack, storeFunc, null, context);\n@@ -42,1 +42,1 @@\n-    static Object box(List<Binding> bindings, LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+    static Object box(List<Binding> bindings, LoadFunc loadFunc, Binding.Context context) {\n@@ -45,1 +45,1 @@\n-            b.interpret(stack, null, loadFunc, allocator);\n+            b.interpret(stack, null, loadFunc, context);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingInterpreter.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -33,1 +35,0 @@\n-import jdk.internal.foreign.abi.SharedUtils.Allocator;\n@@ -50,0 +51,1 @@\n+import static java.lang.invoke.MethodHandles.empty;\n@@ -53,0 +55,1 @@\n+import static java.lang.invoke.MethodHandles.tryFinally;\n@@ -54,1 +57,0 @@\n-import static jdk.internal.foreign.abi.SharedUtils.DEFAULT_ALLOCATOR;\n@@ -77,0 +79,2 @@\n+    private static final MethodHandle MH_WRAP_ALLOCATOR;\n+\n@@ -87,1 +91,3 @@\n-                    methodType(Object.class, Addressable.class, Object[].class, MethodHandle.class, Map.class, Map.class));\n+                    methodType(Object.class, Addressable.class, SegmentAllocator.class, Object[].class, MethodHandle.class, Map.class, Map.class));\n+            MH_WRAP_ALLOCATOR = lookup.findStatic(Binding.Context.class, \"ofAllocator\",\n+                    methodType(Binding.Context.class, SegmentAllocator.class));\n@@ -165,1 +171,1 @@\n-            handle = insertArguments(MH_INVOKE_INTERP_BINDINGS.bindTo(this), 2, handle, argIndexMap, retIndexMap);\n+            handle = insertArguments(MH_INVOKE_INTERP_BINDINGS.bindTo(this), 3, handle, argIndexMap, retIndexMap);\n@@ -167,1 +173,1 @@\n-            handle = collectArguments(handle, 1, collectorInterp);\n+            handle = collectArguments(handle, 2, collectorInterp);\n@@ -204,1 +210,4 @@\n-        MethodHandle specializedHandle = leafHandle; \/\/ initial\n+        int argInsertPos = 1;\n+        int argContextPos = 1;\n+\n+        MethodHandle specializedHandle = dropArguments(leafHandle, argContextPos, Binding.Context.class);\n@@ -206,7 +215,0 @@\n-        int argInsertPos = 0; \/\/ +1 for addr\n-        int argAllocatorPos = -1;\n-        if (bufferCopySize > 0) {\n-            argAllocatorPos = 1;\n-            specializedHandle = dropArguments(specializedHandle, argAllocatorPos, Allocator.class);\n-            argInsertPos++;\n-        }\n@@ -222,1 +224,1 @@\n-                    specializedHandle = binding.specialize(specializedHandle, argInsertPos, argAllocatorPos);\n+                    specializedHandle = binding.specialize(specializedHandle, argInsertPos, argContextPos);\n@@ -229,1 +231,1 @@\n-            int retAllocatorPos = 0;\n+            int retContextPos = 0;\n@@ -231,1 +233,1 @@\n-            returnFilter = dropArguments(returnFilter, retAllocatorPos, Allocator.class);\n+            returnFilter = dropArguments(returnFilter, retContextPos, Binding.Context.class);\n@@ -235,1 +237,1 @@\n-                returnFilter = binding.specialize(returnFilter, retInsertPos, retAllocatorPos);\n+                returnFilter = binding.specialize(returnFilter, retInsertPos, retContextPos);\n@@ -237,2 +239,7 @@\n-            returnFilter = insertArguments(returnFilter, retAllocatorPos, DEFAULT_ALLOCATOR);\n-            specializedHandle = MethodHandles.filterReturnValue(specializedHandle, returnFilter);\n+            returnFilter = MethodHandles.filterArguments(returnFilter, retContextPos, MH_WRAP_ALLOCATOR);\n+            \/\/ (SegmentAllocator, Addressable, Context, ...) -> ...\n+            specializedHandle = MethodHandles.collectArguments(returnFilter, retInsertPos, specializedHandle);\n+            \/\/ (Addressable, SegmentAllocator, Context, ...) -> ...\n+            specializedHandle = SharedUtils.swapArguments(specializedHandle, 0, 1); \/\/ normalize parameter order\n+        } else {\n+            specializedHandle = MethodHandles.dropArguments(specializedHandle, 1, SegmentAllocator.class);\n@@ -241,0 +248,3 @@\n+        \/\/ now bind the internal context parameter\n+\n+        argContextPos++; \/\/ skip over the return SegmentAllocator (inserted by the above code)\n@@ -242,1 +252,3 @@\n-            specializedHandle = SharedUtils.wrapWithAllocator(specializedHandle, argAllocatorPos, bufferCopySize, false);\n+            specializedHandle = SharedUtils.wrapWithAllocator(specializedHandle, argContextPos, bufferCopySize, false);\n+        } else {\n+            specializedHandle = insertArguments(specializedHandle, argContextPos, Binding.Context.DUMMY);\n@@ -258,1 +270,2 @@\n-        try (MemorySegment argBuffer = MemorySegment.allocateNative(layout.size, 64)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment argBuffer = MemorySegment.allocateNative(layout.size, 64, scope);\n@@ -260,1 +273,1 @@\n-                stackArgsSeg = MemorySegment.allocateNative(stackArgsBytes, 8);\n+                stackArgsSeg = MemorySegment.allocateNative(stackArgsBytes, 8, scope);\n@@ -303,4 +316,0 @@\n-        } finally {\n-            if (stackArgsSeg != null) {\n-                stackArgsSeg.close();\n-            }\n@@ -310,1 +319,1 @@\n-    Object invokeInterpBindings(Addressable address, Object[] args, MethodHandle leaf,\n+    Object invokeInterpBindings(Addressable address, SegmentAllocator allocator, Object[] args, MethodHandle leaf,\n@@ -313,1 +322,4 @@\n-        try (Allocator unboxAllocator = SharedUtils.makeAllocator(bufferCopySize)) {\n+        Binding.Context unboxContext = bufferCopySize != 0\n+                ? Binding.Context.ofBoundedAllocator(bufferCopySize)\n+                : Binding.Context.DUMMY;\n+        try (unboxContext) {\n@@ -322,1 +334,1 @@\n-                        }, unboxAllocator);\n+                        }, unboxContext);\n@@ -334,1 +346,1 @@\n-                        (storage, type) -> oArr[retIndexMap.get(storage)], DEFAULT_ALLOCATOR);\n+                        (storage, type) -> oArr[retIndexMap.get(storage)], Binding.Context.ofAllocator(allocator));\n@@ -337,1 +349,1 @@\n-                        DEFAULT_ALLOCATOR);\n+                        Binding.Context.ofAllocator(allocator));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":43,"deletions":31,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -34,1 +36,0 @@\n-import jdk.internal.foreign.abi.SharedUtils.Allocator;\n@@ -171,1 +172,1 @@\n-        specializedHandle = dropArguments(specializedHandle, argAllocatorPos, SharedUtils.Allocator.class);\n+        specializedHandle = dropArguments(specializedHandle, argAllocatorPos, Binding.Context.class);\n@@ -176,1 +177,1 @@\n-            filter = dropArguments(filter, filterAllocatorPos, Allocator.class);\n+            filter = dropArguments(filter, filterAllocatorPos, Binding.Context.class);\n@@ -260,1 +261,4 @@\n-        try (Allocator allocator = SharedUtils.makeAllocator(bufferCopySize)) {\n+        Binding.Context allocator = bufferCopySize != 0\n+                ? Binding.Context.ofBoundedAllocator(bufferCopySize)\n+                : Binding.Context.ofScope();\n+        try (allocator) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-import jdk.incubator.foreign.NativeScope;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -40,1 +41,0 @@\n-import jdk.internal.foreign.AbstractNativeScope;\n@@ -60,0 +60,1 @@\n+import static java.lang.invoke.MethodHandles.constant;\n@@ -64,1 +65,0 @@\n-import static java.lang.invoke.MethodHandles.filterReturnValue;\n@@ -77,4 +77,3 @@\n-    private static final MethodHandle MH_MAKE_ALLOCATOR;\n-    private static final MethodHandle MH_CLOSE_ALLOCATOR;\n-\n-    static final Allocator DEFAULT_ALLOCATOR = MemorySegment::allocateNative;\n+    private static final MethodHandle MH_MAKE_CONTEXT_NO_ALLOCATOR;\n+    private static final MethodHandle MH_MAKE_CONTEXT_BOUNDED_ALLOCATOR;\n+    private static final MethodHandle MH_CLOSE_CONTEXT;\n@@ -84,2 +83,2 @@\n-            var lookup = MethodHandles.lookup();\n-            MH_ALLOC_BUFFER = lookup.findStatic(SharedUtils.class, \"allocateNative\",\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            MH_ALLOC_BUFFER = lookup.findVirtual(SegmentAllocator.class, \"allocate\",\n@@ -91,3 +90,5 @@\n-            MH_MAKE_ALLOCATOR = lookup.findStatic(SharedUtils.class, \"makeAllocator\",\n-                    methodType(Allocator.class, long.class));\n-            MH_CLOSE_ALLOCATOR = lookup.findVirtual(Allocator.class, \"close\",\n+            MH_MAKE_CONTEXT_NO_ALLOCATOR = lookup.findStatic(Binding.Context.class, \"ofScope\",\n+                    methodType(Binding.Context.class));\n+            MH_MAKE_CONTEXT_BOUNDED_ALLOCATOR = lookup.findStatic(Binding.Context.class, \"ofBoundedAllocator\",\n+                    methodType(Binding.Context.class, long.class));\n+            MH_CLOSE_CONTEXT = lookup.findVirtual(Binding.Context.class, \"close\",\n@@ -174,2 +175,2 @@\n-        if (handle.type().parameterType(1) != MemoryAddress.class)\n-            throw new IllegalArgumentException(\"MemoryAddress expected as second param: \" + handle.type());\n+        if (handle.type().parameterType(2) != MemoryAddress.class)\n+            throw new IllegalArgumentException(\"MemoryAddress expected as third param: \" + handle.type());\n@@ -180,5 +181,6 @@\n-        handle = collectArguments(ret, 1, handle); \/\/ (MemorySegment, Addressable, MemoryAddress, ...) MemorySegment\n-        handle = collectArguments(handle, 2, MH_BASEADDRESS); \/\/ (MemorySegment, Addressable, MemorySegment, ...) MemorySegment\n-        handle = mergeArguments(handle, 0, 2);  \/\/ (MemorySegment, Addressable, ...) MemorySegment\n-        handle = collectArguments(handle, 0, insertArguments(MH_ALLOC_BUFFER, 0, cDesc.returnLayout().get())); \/\/ (Addressable, ...) MemoryAddress\n-\n+        handle = collectArguments(ret, 1, handle); \/\/ (MemorySegment, Addressable, SegmentAllocator, MemoryAddress, ...) MemorySegment\n+        handle = collectArguments(handle, 3, MH_BASEADDRESS); \/\/ (MemorySegment, Addressable, SegmentAllocator, MemorySegment, ...) MemorySegment\n+        handle = mergeArguments(handle, 0, 3);  \/\/ (MemorySegment, Addressable, SegmentAllocator, ...) MemorySegment\n+        handle = collectArguments(handle, 0, insertArguments(MH_ALLOC_BUFFER, 1, cDesc.returnLayout().get())); \/\/ (SegmentAllocator, Addressable, SegmentAllocator, ...) MemoryAddress\n+        handle = mergeArguments(handle, 0, 2);  \/\/ (SegmentAllocator, Addressable, ...) MemoryAddress\n+        handle = swapArguments(handle, 0, 1); \/\/ (Addressable, SegmentAllocator, ...) MemoryAddress\n@@ -339,4 +341,13 @@\n-    static Allocator makeAllocator(long size) {\n-        return  size != 0\n-            ? Allocator.ofScope(NativeScope.boundedScope(size))\n-            : Allocator.empty();\n+\n+    static MethodHandle swapArguments(MethodHandle mh, int firstArg, int secondArg) {\n+        MethodType mtype = mh.type();\n+        int[] perms = new int[mtype.parameterCount()];\n+        MethodType swappedType = MethodType.methodType(mtype.returnType());\n+        for (int i = 0 ; i < perms.length ; i++) {\n+            int dst = i;\n+            if (i == firstArg) dst = secondArg;\n+            if (i == secondArg) dst = firstArg;\n+            perms[i] = dst;\n+            swappedType = swappedType.appendParameterTypes(mtype.parameterType(dst));\n+        }\n+        return permuteArguments(mh, swappedType, perms);\n@@ -360,1 +371,1 @@\n-        \/\/ downcalls get the leading Addressable param as well\n+        \/\/ downcalls get the leading Addressable\/SegmentAllocator param as well\n@@ -362,2 +373,2 @@\n-            closer = dropArguments(closer, insertPos, Addressable.class); \/\/ (Throwable, V?, Addressable) -> V\/void\n-            insertPos++;\n+            closer = dropArguments(closer, insertPos, Addressable.class, SegmentAllocator.class); \/\/ (Throwable, V?, Addressable, SegmentAllocator) -> V\/void\n+            insertPos+=2;\n@@ -366,1 +377,12 @@\n-        closer = collectArguments(closer, insertPos, MH_CLOSE_ALLOCATOR); \/\/ (Throwable, V?, Addressable?, NativeScope) -> V\/void\n+        closer = collectArguments(closer, insertPos, MH_CLOSE_CONTEXT); \/\/ (Throwable, V?, Addressable?, BindingContext) -> V\/void\n+\n+        MethodHandle contextFactory;\n+\n+        if (bufferCopySize > 0) {\n+            contextFactory = MethodHandles.insertArguments(MH_MAKE_CONTEXT_BOUNDED_ALLOCATOR, 0, bufferCopySize);\n+        } else if (upcall) {\n+            contextFactory = MH_MAKE_CONTEXT_NO_ALLOCATOR;\n+        } else {\n+            \/\/ this path is probably never used now, since ProgrammableInvoker never calls this routine with bufferCopySize == 0\n+            contextFactory = constant(Binding.Context.class, Binding.Context.DUMMY);\n+        }\n@@ -369,2 +391,1 @@\n-        MethodHandle makeScopeHandle = insertArguments(MH_MAKE_ALLOCATOR, 0, bufferCopySize);\n-        specializedHandle = collectArguments(specializedHandle, allocatorPos, makeScopeHandle);\n+        specializedHandle = collectArguments(specializedHandle, allocatorPos, contextFactory);\n@@ -404,1 +425,1 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, Allocator allocator) {\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n@@ -406,3 +427,3 @@\n-            case Win64 -> Windowsx64Linker.newVaList(actions, allocator);\n-            case SysV -> SysVx64Linker.newVaList(actions, allocator);\n-            case AArch64 -> AArch64Linker.newVaList(actions, allocator);\n+            case Win64 -> Windowsx64Linker.newVaList(actions, scope);\n+            case SysV -> SysVx64Linker.newVaList(actions, scope);\n+            case AArch64 -> AArch64Linker.newVaList(actions, scope);\n@@ -418,1 +439,1 @@\n-    public static VaList newVaListOfAddress(MemoryAddress ma) {\n+    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n@@ -420,3 +441,3 @@\n-            case Win64 -> Windowsx64Linker.newVaListOfAddress(ma);\n-            case SysV -> SysVx64Linker.newVaListOfAddress(ma);\n-            case AArch64 -> AArch64Linker.newVaListOfAddress(ma);\n+            case Win64 -> Windowsx64Linker.newVaListOfAddress(ma, scope);\n+            case SysV -> SysVx64Linker.newVaListOfAddress(ma, scope);\n+            case AArch64 -> AArch64Linker.newVaListOfAddress(ma, scope);\n@@ -475,42 +496,0 @@\n-    public interface Allocator extends AutoCloseable {\n-        static Allocator empty() {\n-            return Allocator.ofScope(AbstractNativeScope.emptyScope());\n-        }\n-\n-        default MemorySegment allocate(MemoryLayout layout) {\n-            return allocate(layout.byteSize(), layout.byteAlignment());\n-        }\n-\n-        default MemorySegment allocate(long size) {\n-            return allocate(size, 1);\n-        }\n-\n-        @Override\n-        default void close() {}\n-\n-        default MemorySegment handoff(MemorySegment ms) {\n-            return ms;\n-        }\n-\n-        MemorySegment allocate(long size, long align);\n-\n-        static Allocator ofScope(NativeScope scope) {\n-            return new Allocator() {\n-                @Override\n-                public MemorySegment allocate(long size, long align) {\n-                    return scope.allocate(size, align);\n-                }\n-\n-                @Override\n-                public MemorySegment handoff(MemorySegment ms) {\n-                    return ms.handoff(scope);\n-                }\n-\n-                @Override\n-                public void close() {\n-                    scope.close();\n-                }\n-            };\n-        }\n-    }\n-\n@@ -573,1 +552,1 @@\n-        public MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope) {\n+        public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator scope) {\n@@ -583,7 +562,2 @@\n-        public boolean isAlive() {\n-            return true;\n-        }\n-\n-        @Override\n-        public void close() {\n-            throw uoe();\n+        public ResourceScope scope() {\n+            return ResourceScope.globalScope();\n@@ -597,5 +571,0 @@\n-        @Override\n-        public VaList copy(NativeScope scope) {\n-            throw uoe();\n-        }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":61,"deletions":92,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.internal.foreign.MemoryAddressImpl;\n+import jdk.internal.foreign.MemoryScope;\n@@ -34,1 +34,1 @@\n-    public static MemorySegment upcallAddress(UpcallHandler handler) {\n+    public static MemorySegment upcallAddress(UpcallHandler handler, MemoryScope scope) {\n@@ -36,5 +36,3 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(\n-                MemoryAddress.ofLong(stubAddress), 0, () -> freeUpcallStub(stubAddress), null)\n-                .share()\n-                .withAccessModes(MemorySegment.CLOSE | MemorySegment.HANDOFF | MemorySegment.SHARE);\n-    };\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(stubAddress), 0,\n+                () -> freeUpcallStub(stubAddress), scope);\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -31,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryLayout;\n@@ -34,0 +32,3 @@\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.internal.foreign.MemoryScope;\n+import jdk.internal.foreign.abi.Binding;\n@@ -43,2 +44,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.*;\n-\n@@ -62,2 +61,2 @@\n-            MH_boxVaList = lookup.findStatic(AArch64Linker.class, \"newVaListOfAddress\",\n-                MethodType.methodType(VaList.class, MemoryAddress.class));\n+            MH_boxVaList = MethodHandles.insertArguments(lookup.findStatic(AArch64Linker.class, \"newVaListOfAddress\",\n+                MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)), 1, ResourceScope.globalScope());\n@@ -82,0 +81,4 @@\n+        if (!type.returnType().equals(MemorySegment.class)) {\n+            \/\/ not returning segment, just insert default allocator\n+            handle = MethodHandles.insertArguments(handle, 1, Binding.Context.DEFAULT.allocator());\n+        }\n@@ -87,1 +90,2 @@\n-    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function) {\n+    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n@@ -91,1 +95,1 @@\n-        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));\n+        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function), (MemoryScope) scope);\n@@ -94,2 +98,2 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, SharedUtils.Allocator allocator) {\n-        AArch64VaList.Builder builder = AArch64VaList.builder(allocator);\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n+        AArch64VaList.Builder builder = AArch64VaList.builder(scope);\n@@ -100,2 +104,2 @@\n-    public static VaList newVaListOfAddress(MemoryAddress ma) {\n-        return AArch64VaList.ofAddress(ma);\n+    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n+        return AArch64VaList.ofAddress(ma, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Linker.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n+import jdk.internal.foreign.MemoryScope;\n@@ -107,1 +107,0 @@\n-    private final List<MemorySegment> attachedSegments;\n@@ -109,2 +108,1 @@\n-    private AArch64VaList(MemorySegment segment, MemorySegment gpRegsArea, MemorySegment fpRegsArea,\n-                          List<MemorySegment> attachedSegments) {\n+    private AArch64VaList(MemorySegment segment, MemorySegment gpRegsArea, MemorySegment fpRegsArea) {\n@@ -114,1 +112,0 @@\n-        this.attachedSegments = attachedSegments;\n@@ -118,2 +115,2 @@\n-        MemorySegment gpRegsArea = handoffIfNeeded(grTop(segment).addOffset(-MAX_GP_OFFSET)\n-                .asSegmentRestricted(MAX_GP_OFFSET), segment.ownerThread());\n+        MemorySegment gpRegsArea = grTop(segment).addOffset(-MAX_GP_OFFSET).asSegmentRestricted(\n+                MAX_GP_OFFSET, segment.scope());\n@@ -121,3 +118,3 @@\n-        MemorySegment fpRegsArea = handoffIfNeeded(vrTop(segment).addOffset(-MAX_FP_OFFSET)\n-                .asSegmentRestricted(MAX_FP_OFFSET), segment.ownerThread());\n-        return new AArch64VaList(segment, gpRegsArea, fpRegsArea, List.of(gpRegsArea, fpRegsArea));\n+        MemorySegment fpRegsArea = vrTop(segment).addOffset(-MAX_FP_OFFSET).asSegmentRestricted(\n+                MAX_FP_OFFSET, segment.scope());\n+        return new AArch64VaList(segment, gpRegsArea, fpRegsArea);\n@@ -128,4 +125,3 @@\n-        MemorySegment ms = MemoryAddress.ofLong(ptr)\n-                .asSegmentRestricted(LAYOUT.byteSize(), () -> U.freeMemory(ptr), null)\n-                .share();\n-        cleaner.register(AArch64VaList.class, ms::close);\n+        MemorySegment ms = MemoryAddress.ofLong(ptr).asSegmentRestricted(\n+                LAYOUT.byteSize(), () -> U.freeMemory(ptr), ResourceScope.ofShared());\n+        cleaner.register(AArch64VaList.class, () -> ms.scope().close());\n@@ -242,3 +238,3 @@\n-    public MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope) {\n-        Objects.requireNonNull(scope);\n-        return (MemorySegment) read(MemorySegment.class, layout, SharedUtils.Allocator.ofScope(scope));\n+    public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n+        Objects.requireNonNull(allocator);\n+        return (MemorySegment) read(MemorySegment.class, layout, allocator);\n@@ -251,1 +247,1 @@\n-    private Object read(Class<?> carrier, MemoryLayout layout, SharedUtils.Allocator allocator) {\n+    private Object read(Class<?> carrier, MemoryLayout layout, SegmentAllocator allocator) {\n@@ -260,7 +256,5 @@\n-                    try (MemorySegment slice = handoffIfNeeded(stackPtr()\n-                            .asSegmentRestricted(layout.byteSize()), segment.ownerThread())) {\n-                        MemorySegment seg = allocator.allocate(layout);\n-                        seg.copyFrom(slice);\n-                        postAlignStack(layout);\n-                        yield seg;\n-                    }\n+                    MemorySegment slice = stackPtr().asSegmentRestricted(layout.byteSize(), scope());\n+                    MemorySegment seg = allocator.allocate(layout);\n+                    seg.copyFrom(slice);\n+                    postAlignStack(layout);\n+                    yield seg;\n@@ -270,6 +264,4 @@\n-                    try (MemorySegment slice = handoffIfNeeded(stackPtr()\n-                            .asSegmentRestricted(layout.byteSize()), segment.ownerThread())) {\n-                        Object res = reader.get(slice);\n-                        postAlignStack(layout);\n-                        yield res;\n-                    }\n+                    MemorySegment slice = stackPtr().asSegmentRestricted(layout.byteSize(), scope());\n+                    Object res = reader.get(slice);\n+                    postAlignStack(layout);\n+                    yield res;\n@@ -317,6 +309,4 @@\n-                    try (MemorySegment slice = handoffIfNeeded(ptr\n-                            .asSegmentRestricted(layout.byteSize()), segment.ownerThread())) {\n-                        MemorySegment seg = allocator.allocate(layout);\n-                        seg.copyFrom(slice);\n-                        yield seg;\n-                    }\n+                    MemorySegment slice = ptr.asSegmentRestricted(layout.byteSize(), scope());\n+                    MemorySegment seg = allocator.allocate(layout);\n+                    seg.copyFrom(slice);\n+                    yield seg;\n@@ -359,2 +349,2 @@\n-    static AArch64VaList.Builder builder(SharedUtils.Allocator allocator) {\n-        return new AArch64VaList.Builder(allocator);\n+    static AArch64VaList.Builder builder(ResourceScope scope) {\n+        return new AArch64VaList.Builder(scope);\n@@ -363,7 +353,2 @@\n-    public static VaList ofAddress(MemoryAddress ma) {\n-        return readFromSegment(ma.asSegmentRestricted(LAYOUT.byteSize()));\n-    }\n-\n-    @Override\n-    public boolean isAlive() {\n-        return segment.isAlive();\n+    public static VaList ofAddress(MemoryAddress ma, ResourceScope scope) {\n+        return readFromSegment(ma.asSegmentRestricted(LAYOUT.byteSize(), scope));\n@@ -373,3 +358,2 @@\n-    public void close() {\n-        segment.close();\n-        attachedSegments.forEach(MemorySegment::close);\n+    public ResourceScope scope() {\n+        return segment.scope();\n@@ -380,11 +364,1 @@\n-        return copy(MemorySegment::allocateNative);\n-    }\n-\n-    @Override\n-    public VaList copy(NativeScope scope) {\n-        Objects.requireNonNull(scope);\n-        return copy(SharedUtils.Allocator.ofScope(scope));\n-    }\n-\n-    private VaList copy(SharedUtils.Allocator allocator) {\n-        MemorySegment copy = allocator.allocate(LAYOUT);\n+        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.scope());\n@@ -392,1 +366,1 @@\n-        return new AArch64VaList(copy, gpRegsArea, fpRegsArea, List.of());\n+        return new AArch64VaList(copy, gpRegsArea, fpRegsArea);\n@@ -427,1 +401,1 @@\n-        private final SharedUtils.Allocator allocator;\n+        private final ResourceScope scope;\n@@ -435,4 +409,4 @@\n-        Builder(SharedUtils.Allocator allocator) {\n-            this.allocator = allocator;\n-            this.gpRegs = allocator.allocate(LAYOUT_GP_REGS);\n-            this.fpRegs = allocator.allocate(LAYOUT_FP_REGS);\n+        Builder(ResourceScope scope) {\n+            this.scope = scope;\n+            this.gpRegs = MemorySegment.allocateNative(LAYOUT_GP_REGS, scope);\n+            this.fpRegs = MemorySegment.allocateNative(LAYOUT_FP_REGS, scope);\n@@ -537,0 +511,1 @@\n+            SegmentAllocator allocator = SegmentAllocator.arenaUnbounded(scope);\n@@ -538,1 +513,0 @@\n-            List<MemorySegment> attachedSegments = new ArrayList<>();\n@@ -552,1 +526,0 @@\n-                attachedSegments.add(stackArgsSegment);\n@@ -561,5 +534,3 @@\n-            attachedSegments.add(gpRegs);\n-            attachedSegments.add(fpRegs);\n-            assert gpRegs.ownerThread() == vaListSegment.ownerThread();\n-            assert fpRegs.ownerThread() == vaListSegment.ownerThread();\n-            return new AArch64VaList(vaListSegment, gpRegs, fpRegs, attachedSegments);\n+            assert gpRegs.scope().ownerThread() == vaListSegment.scope().ownerThread();\n+            assert fpRegs.scope().ownerThread() == vaListSegment.scope().ownerThread();\n+            return new AArch64VaList(vaListSegment, gpRegs, fpRegs);\n@@ -568,5 +539,0 @@\n-\n-    private static MemorySegment handoffIfNeeded(MemorySegment segment, Thread thread) {\n-        return segment.ownerThread() == thread ?\n-                segment : segment.handoff(thread);\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64VaList.java","additions":44,"deletions":78,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n+import jdk.internal.foreign.MemoryScope;\n@@ -120,1 +120,0 @@\n-    private final List<MemorySegment> attachedSegments;\n@@ -122,1 +121,1 @@\n-    private SysVVaList(MemorySegment segment, MemorySegment regSaveArea, List<MemorySegment> attachedSegments) {\n+    private SysVVaList(MemorySegment segment, MemorySegment regSaveArea) {\n@@ -125,1 +124,0 @@\n-        this.attachedSegments = attachedSegments;\n@@ -130,1 +128,1 @@\n-        return new SysVVaList(segment, regSaveArea, List.of(regSaveArea));\n+        return new SysVVaList(segment, regSaveArea);\n@@ -135,4 +133,3 @@\n-        MemorySegment base = MemoryAddress.ofLong(ptr)\n-                .asSegmentRestricted(LAYOUT.byteSize(), () -> U.freeMemory(ptr), null)\n-                .share();\n-        cleaner.register(SysVVaList.class, base::close);\n+        MemorySegment base = MemoryAddress.ofLong(ptr).asSegmentRestricted(\n+                LAYOUT.byteSize(), () -> U.freeMemory(ptr), ResourceScope.ofShared());\n+        cleaner.register(SysVVaList.class, () -> base.scope().close());\n@@ -143,1 +140,1 @@\n-        return base.withAccessModes(0).address();\n+        return base.address();\n@@ -179,2 +176,2 @@\n-        return handoffIfNeeded(((MemoryAddress)VH_reg_save_area.get(segment))\n-                .asSegmentRestricted(LAYOUT_REG_SAVE_AREA.byteSize()), segment.ownerThread());\n+        return ((MemoryAddress)VH_reg_save_area.get(segment)).asSegmentRestricted(\n+                LAYOUT_REG_SAVE_AREA.byteSize(), segment.scope());\n@@ -219,3 +216,3 @@\n-    public MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope) {\n-        Objects.requireNonNull(scope);\n-        return (MemorySegment) read(MemorySegment.class, layout, SharedUtils.Allocator.ofScope(scope));\n+    public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n+        Objects.requireNonNull(allocator);\n+        return (MemorySegment) read(MemorySegment.class, layout, allocator);\n@@ -228,1 +225,1 @@\n-    private Object read(Class<?> carrier, MemoryLayout layout, SharedUtils.Allocator allocator) {\n+    private Object read(Class<?> carrier, MemoryLayout layout, SegmentAllocator allocator) {\n@@ -237,7 +234,5 @@\n-                    try (MemorySegment slice = handoffIfNeeded(stackPtr()\n-                            .asSegmentRestricted(layout.byteSize()), segment.ownerThread())) {\n-                        MemorySegment seg = allocator.allocate(layout);\n-                        seg.copyFrom(slice);\n-                        postAlignStack(layout);\n-                        yield seg;\n-                    }\n+                    MemorySegment slice = stackPtr().asSegmentRestricted(layout.byteSize(), scope());\n+                    MemorySegment seg = allocator.allocate(layout);\n+                    seg.copyFrom(slice);\n+                    postAlignStack(layout);\n+                    yield seg;\n@@ -247,2 +242,2 @@\n-                    try (MemorySegment slice = handoffIfNeeded(stackPtr()\n-                            .asSegmentRestricted(layout.byteSize()), segment.ownerThread())) {\n+                    try (ResourceScope localScope = ResourceScope.ofConfined()) {\n+                        MemorySegment slice = stackPtr().asSegmentRestricted(layout.byteSize(), localScope);\n@@ -308,6 +303,2 @@\n-    static SysVVaList.Builder builder(SharedUtils.Allocator allocator) {\n-        return new SysVVaList.Builder(allocator);\n-    }\n-\n-    public static VaList ofAddress(MemoryAddress ma) {\n-        return readFromSegment(ma.asSegmentRestricted(LAYOUT.byteSize()));\n+    static SysVVaList.Builder builder(ResourceScope scope) {\n+        return new SysVVaList.Builder(scope);\n@@ -316,3 +307,2 @@\n-    @Override\n-    public boolean isAlive() {\n-        return segment.isAlive();\n+    public static VaList ofAddress(MemoryAddress ma, ResourceScope scope) {\n+        return readFromSegment(ma.asSegmentRestricted(LAYOUT.byteSize(), scope));\n@@ -322,3 +312,2 @@\n-    public void close() {\n-        segment.close();\n-        attachedSegments.forEach(MemorySegment::close);\n+    public ResourceScope scope() {\n+        return segment.scope();\n@@ -329,11 +318,1 @@\n-        return copy(MemorySegment::allocateNative);\n-    }\n-\n-    @Override\n-    public VaList copy(NativeScope scope) {\n-        Objects.requireNonNull(scope);\n-        return copy(SharedUtils.Allocator.ofScope(scope));\n-    }\n-\n-    private VaList copy(SharedUtils.Allocator allocator) {\n-        MemorySegment copy = allocator.allocate(LAYOUT);\n+        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.scope());\n@@ -341,1 +320,1 @@\n-        return new SysVVaList(copy, regSaveArea, List.of());\n+        return new SysVVaList(copy, regSaveArea);\n@@ -365,1 +344,1 @@\n-        private final SharedUtils.Allocator allocator;\n+        private final ResourceScope scope;\n@@ -371,3 +350,3 @@\n-        public Builder(SharedUtils.Allocator allocator) {\n-            this.allocator = allocator;\n-            this.reg_save_area = allocator.allocate(LAYOUT_REG_SAVE_AREA);\n+        public Builder(ResourceScope scope) {\n+            this.scope = scope;\n+            this.reg_save_area = MemorySegment.allocateNative(LAYOUT_REG_SAVE_AREA, scope);\n@@ -454,0 +433,1 @@\n+            SegmentAllocator allocator = SegmentAllocator.arenaUnbounded(scope);\n@@ -455,1 +435,0 @@\n-            List<MemorySegment> attachedSegments = new ArrayList<>();\n@@ -474,1 +453,0 @@\n-                attachedSegments.add(stackArgsSegment);\n@@ -480,3 +458,2 @@\n-            attachedSegments.add(reg_save_area);\n-            assert reg_save_area.ownerThread() == vaListSegment.ownerThread();\n-            return new SysVVaList(vaListSegment, reg_save_area, attachedSegments);\n+            assert reg_save_area.scope().ownerThread() == vaListSegment.scope().ownerThread();\n+            return new SysVVaList(vaListSegment, reg_save_area);\n@@ -485,5 +462,0 @@\n-\n-    private static MemorySegment handoffIfNeeded(MemorySegment segment, Thread thread) {\n-        return segment.ownerThread() == thread ?\n-            segment : segment.handoff(thread);\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":35,"deletions":63,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -30,1 +29,0 @@\n-import jdk.incubator.foreign.MemoryLayout;\n@@ -33,0 +31,3 @@\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.internal.foreign.MemoryScope;\n+import jdk.internal.foreign.abi.Binding;\n@@ -40,1 +41,0 @@\n-import java.util.Optional;\n@@ -43,2 +43,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.*;\n-\n@@ -67,2 +65,2 @@\n-            MH_boxVaList = lookup.findStatic(SysVx64Linker.class, \"newVaListOfAddress\",\n-                MethodType.methodType(VaList.class, MemoryAddress.class));\n+            MH_boxVaList = MethodHandles.insertArguments(lookup.findStatic(SysVx64Linker.class, \"newVaListOfAddress\",\n+                MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)), 1, ResourceScope.globalScope());\n@@ -81,2 +79,2 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, SharedUtils.Allocator allocator) {\n-        SysVVaList.Builder builder = SysVVaList.builder(allocator);\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n+        SysVVaList.Builder builder = SysVVaList.builder(scope);\n@@ -93,0 +91,4 @@\n+        if (!type.returnType().equals(MemorySegment.class)) {\n+            \/\/ not returning segment, just insert default allocator\n+            handle = MethodHandles.insertArguments(handle, 1, Binding.Context.DEFAULT.allocator());\n+        }\n@@ -98,1 +100,2 @@\n-    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function) {\n+    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n@@ -102,1 +105,1 @@\n-        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));\n+        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function), (MemoryScope) scope);\n@@ -105,2 +108,2 @@\n-    public static VaList newVaListOfAddress(MemoryAddress ma) {\n-        return SysVVaList.ofAddress(ma);\n+    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n+        return SysVVaList.ofAddress(ma, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.MemoryScope;\n@@ -65,2 +66,1 @@\n-    private final List<MemorySegment> attachedSegments;\n-    private final MemorySegment livenessCheck;\n+    private final ResourceScope scope;\n@@ -68,1 +68,1 @@\n-    private WinVaList(MemorySegment segment, List<MemorySegment> attachedSegments, MemorySegment livenessCheck) {\n+    private WinVaList(MemorySegment segment, ResourceScope scope) {\n@@ -70,2 +70,1 @@\n-        this.attachedSegments = attachedSegments;\n-        this.livenessCheck = livenessCheck;\n+        this.scope = scope;\n@@ -104,3 +103,3 @@\n-    public MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope) {\n-        Objects.requireNonNull(scope);\n-        return (MemorySegment) read(MemorySegment.class, layout, SharedUtils.Allocator.ofScope(scope));\n+    public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n+        Objects.requireNonNull(allocator);\n+        return (MemorySegment) read(MemorySegment.class, layout, allocator);\n@@ -113,1 +112,1 @@\n-    private Object read(Class<?> carrier, MemoryLayout layout, SharedUtils.Allocator allocator) {\n+    private Object read(Class<?> carrier, MemoryLayout layout, SegmentAllocator allocator) {\n@@ -122,6 +121,4 @@\n-                    try (MemorySegment struct = handoffIfNeeded(structAddr.asSegmentRestricted(layout.byteSize()),\n-                         segment.ownerThread())) {\n-                        MemorySegment seg = allocator.allocate(layout.byteSize());\n-                        seg.copyFrom(struct);\n-                        yield seg;\n-                    }\n+                    MemorySegment struct = structAddr.asSegmentRestricted(layout.byteSize(), scope());\n+                    MemorySegment seg = allocator.allocate(layout);\n+                    seg.copyFrom(struct);\n+                    yield seg;\n@@ -151,3 +148,3 @@\n-    static WinVaList ofAddress(MemoryAddress addr) {\n-        MemorySegment segment = addr.asSegmentRestricted(Long.MAX_VALUE);\n-        return new WinVaList(segment, List.of(segment), null);\n+    static WinVaList ofAddress(MemoryAddress addr, ResourceScope scope) {\n+        MemorySegment segment = addr.asSegmentRestricted(Long.MAX_VALUE, scope);\n+        return new WinVaList(segment, scope);\n@@ -156,2 +153,2 @@\n-    static Builder builder(SharedUtils.Allocator allocator) {\n-        return new Builder(allocator);\n+    static Builder builder(ResourceScope scope) {\n+        return new Builder(scope);\n@@ -161,4 +158,2 @@\n-    public void close() {\n-        if (livenessCheck != null)\n-            livenessCheck.close();\n-        attachedSegments.forEach(MemorySegment::close);\n+    public ResourceScope scope() {\n+        return scope;\n@@ -169,12 +164,2 @@\n-        MemorySegment liveness = handoffIfNeeded(MemoryAddress.NULL.asSegmentRestricted(1),\n-                segment.ownerThread());\n-        return new WinVaList(segment, List.of(), liveness);\n-    }\n-\n-    @Override\n-    public VaList copy(NativeScope scope) {\n-        Objects.requireNonNull(scope);\n-        MemorySegment liveness = handoffIfNeeded(MemoryAddress.NULL.asSegmentRestricted(1),\n-                segment.ownerThread());\n-        liveness = liveness.handoff(scope);\n-        return new WinVaList(segment, List.of(), liveness);\n+        ((MemoryScope)scope).checkValidStateSlow();\n+        return new WinVaList(segment, scope);\n@@ -188,7 +173,0 @@\n-    @Override\n-    public boolean isAlive() {\n-        if (livenessCheck != null)\n-            return livenessCheck.isAlive();\n-        return segment.isAlive();\n-    }\n-\n@@ -197,1 +175,1 @@\n-        private final SharedUtils.Allocator allocator;\n+        private final ResourceScope scope;\n@@ -200,2 +178,3 @@\n-        public Builder(SharedUtils.Allocator allocator) {\n-            this.allocator = allocator;\n+        public Builder(ResourceScope scope) {\n+            ((MemoryScope)scope).checkValidStateSlow();\n+            this.scope = scope;\n@@ -241,0 +220,1 @@\n+            SegmentAllocator allocator = SegmentAllocator.arenaUnbounded(scope);\n@@ -270,1 +250,1 @@\n-            return new WinVaList(segment, attachedSegments, null);\n+            return new WinVaList(segment, scope);\n@@ -273,5 +253,0 @@\n-\n-    private static MemorySegment handoffIfNeeded(MemorySegment segment, Thread thread) {\n-        return segment.ownerThread() == thread ?\n-                segment : segment.handoff(thread);\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":27,"deletions":52,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -30,1 +29,0 @@\n-import jdk.incubator.foreign.MemoryLayout;\n@@ -33,0 +31,3 @@\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.internal.foreign.MemoryScope;\n+import jdk.internal.foreign.abi.Binding;\n@@ -42,2 +43,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.*;\n-\n@@ -68,2 +67,2 @@\n-            MH_boxVaList = lookup.findStatic(Windowsx64Linker.class, \"newVaListOfAddress\",\n-                MethodType.methodType(VaList.class, MemoryAddress.class));\n+            MH_boxVaList = MethodHandles.insertArguments(lookup.findStatic(Windowsx64Linker.class, \"newVaListOfAddress\",\n+                MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)), 1, ResourceScope.globalScope());\n@@ -82,2 +81,2 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, SharedUtils.Allocator allocator) {\n-        WinVaList.Builder builder = WinVaList.builder(allocator);\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n+        WinVaList.Builder builder = WinVaList.builder(scope);\n@@ -94,0 +93,4 @@\n+        if (!type.returnType().equals(MemorySegment.class)) {\n+            \/\/ not returning segment, just insert default allocator\n+            handle = MethodHandles.insertArguments(handle, 1, Binding.Context.DEFAULT.allocator());\n+        }\n@@ -99,1 +102,2 @@\n-    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function) {\n+    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n@@ -103,1 +107,1 @@\n-        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));\n+        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function), (MemoryScope) scope);\n@@ -106,2 +110,2 @@\n-    public static VaList newVaListOfAddress(MemoryAddress ma) {\n-        return WinVaList.ofAddress(ma);\n+    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n+        return WinVaList.ofAddress(ma, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -360,1 +360,1 @@\n-    static Object makeArg(MemoryLayout layout, List<Consumer<Object>> checks, boolean check, List<MemorySegment> segments) throws ReflectiveOperationException {\n+    static Object makeArg(MemoryLayout layout, List<Consumer<Object>> checks, boolean check) throws ReflectiveOperationException {\n@@ -363,2 +363,1 @@\n-            initStruct(segment, (GroupLayout)layout, checks, check, segments);\n-            segments.add(segment);\n+            initStruct(segment, (GroupLayout)layout, checks, check);\n@@ -368,1 +367,0 @@\n-            segments.add(segment);\n@@ -401,1 +399,1 @@\n-    static void initStruct(MemorySegment str, GroupLayout g, List<Consumer<Object>> checks, boolean check, List<MemorySegment> segments) throws ReflectiveOperationException {\n+    static void initStruct(MemorySegment str, GroupLayout g, List<Consumer<Object>> checks, boolean check) throws ReflectiveOperationException {\n@@ -406,1 +404,1 @@\n-            Object value = makeArg(l, fieldsCheck, check, segments);\n+            Object value = makeArg(l, fieldsCheck, check);\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -42,0 +45,34 @@\n+\n+    public static class NativeScope implements SegmentAllocator, AutoCloseable {\n+        final ResourceScope resourceScope;\n+        final ResourceScope.Handle scopeHandle;\n+        final SegmentAllocator allocator;\n+\n+        long allocatedBytes = 0;\n+\n+        public NativeScope() {\n+            this.resourceScope = ResourceScope.ofConfined();\n+            this.scopeHandle = resourceScope.acquire();\n+            this.allocator = SegmentAllocator.arenaUnbounded(resourceScope);\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+            allocatedBytes += bytesSize;\n+            return allocator.allocate(bytesSize, bytesAlignment);\n+        }\n+\n+        public ResourceScope scope() {\n+            return resourceScope;\n+        }\n+\n+        public long allocatedBytes() {\n+            return allocatedBytes;\n+        }\n+\n+        @Override\n+        public void close() {\n+            scopeHandle.close();\n+            resourceScope.close();\n+        }\n+    }\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.function.BiConsumer;\n@@ -44,0 +45,1 @@\n+import java.util.function.Function;\n@@ -57,1 +59,1 @@\n-public class StdLibTest {\n+public class StdLibTest extends NativeTestHelper {\n@@ -209,2 +211,3 @@\n-            try (MemorySegment buf = MemorySegment.allocateNative(s1.length() + s2.length() + 1) ;\n-                 MemorySegment other = toCString(s2)) {\n+            try (NativeScope scope = new NativeScope()) {\n+                MemorySegment buf = scope.allocate(s1.length() + s2.length() + 1);\n+                MemorySegment other = toCString(s2, scope);\n@@ -221,2 +224,3 @@\n-            try (MemorySegment ns1 = toCString(s1) ;\n-                 MemorySegment ns2 = toCString(s2)) {\n+            try (NativeScope scope = new NativeScope()) {\n+                MemorySegment ns1 = toCString(s1, scope);\n+                MemorySegment ns2 = toCString(s2, scope);\n@@ -228,1 +232,2 @@\n-            try (MemorySegment s = toCString(msg)) {\n+            try (NativeScope scope = new NativeScope()) {\n+                MemorySegment s = toCString(msg, scope);\n@@ -234,1 +239,2 @@\n-            try (MemorySegment s = toCString(msg)) {\n+            try (NativeScope scope = new NativeScope()) {\n+                MemorySegment s = toCString(msg, scope);\n@@ -240,1 +246,2 @@\n-            try (MemorySegment time = MemorySegment.allocateNative(8)) {\n+            try (NativeScope scope = new NativeScope()) {\n+                MemorySegment time = scope.allocate(8);\n@@ -289,1 +296,1 @@\n-            try (NativeScope scope = NativeScope.unboundedScope()) {\n+            try (NativeScope scope = new NativeScope()) {\n@@ -294,2 +301,1 @@\n-                MemorySegment qsortUpcallStub = abi.upcallStub(qsortCompar.bindTo(nativeArr), qsortComparFunction);\n-                qsortUpcallStub = qsortUpcallStub.handoff(scope);\n+                MemorySegment qsortUpcallStub = abi.upcallStub(qsortCompar.bindTo(nativeArr), qsortComparFunction, scope.scope());\n@@ -314,1 +320,2 @@\n-            try (MemorySegment formatStr = toCString(format)) {\n+            try (NativeScope scope = new NativeScope()) {\n+                MemorySegment formatStr = toCString(format, scope);\n@@ -316,1 +323,1 @@\n-                        args.stream().map(a -> a.nativeValue).toArray());\n+                        args.stream().map(a -> a.nativeValue(scope)).toArray());\n@@ -321,10 +328,4 @@\n-            try (MemorySegment formatStr = toCString(format)) {\n-                VaList vaList = VaList.make(b -> args.forEach(a -> a.accept(b)));\n-                int result = (int)vprintf.invokeExact(formatStr.address(), vaList);\n-                try {\n-                    vaList.close();\n-                }\n-                catch (UnsupportedOperationException e) {\n-                    assertEquals(e.getMessage(), \"Empty VaList\");\n-                }\n-                return result;\n+            try (NativeScope scope = new NativeScope()) {\n+                MemorySegment formatStr = toCString(format, scope);\n+                VaList vaList = VaList.make(b -> args.forEach(a -> a.accept(b, scope)), scope.scope());\n+                return (int)vprintf.invokeExact(formatStr.address(), vaList);\n@@ -401,1 +402,1 @@\n-    enum PrintfArg implements Consumer<VaList.Builder> {\n+    enum PrintfArg implements BiConsumer<VaList.Builder, NativeScope> {\n@@ -403,4 +404,4 @@\n-        INTEGRAL(int.class, asVarArg(C_INT), \"%d\", 42, 42, VaList.Builder::vargFromInt),\n-        STRING(MemoryAddress.class, asVarArg(C_POINTER), \"%s\", toCString(\"str\").address(), \"str\", VaList.Builder::vargFromAddress),\n-        CHAR(byte.class, asVarArg(C_CHAR), \"%c\", (byte) 'h', 'h', (builder, layout, value) -> builder.vargFromInt(C_INT, (int)value)),\n-        DOUBLE(double.class, asVarArg(C_DOUBLE), \"%.4f\", 1.2345d, 1.2345d, VaList.Builder::vargFromDouble);\n+        INTEGRAL(int.class, asVarArg(C_INT), \"%d\", scope -> 42, 42, VaList.Builder::vargFromInt),\n+        STRING(MemoryAddress.class, asVarArg(C_POINTER), \"%s\", scope -> toCString(\"str\", scope).address(), \"str\", VaList.Builder::vargFromAddress),\n+        CHAR(byte.class, asVarArg(C_CHAR), \"%c\", scope -> (byte) 'h', 'h', (builder, layout, value) -> builder.vargFromInt(C_INT, (int)value)),\n+        DOUBLE(double.class, asVarArg(C_DOUBLE), \"%.4f\", scope ->1.2345d, 1.2345d, VaList.Builder::vargFromDouble);\n@@ -411,1 +412,1 @@\n-        final Object nativeValue;\n+        final Function<NativeScope, ?> nativeValueFactory;\n@@ -416,1 +417,1 @@\n-        <Z> PrintfArg(Class<?> carrier, ValueLayout layout, String format, Z nativeValue, Object javaValue, VaListBuilderCall<Z> builderCall) {\n+        <Z> PrintfArg(Class<?> carrier, ValueLayout layout, String format, Function<NativeScope, Z> nativeValueFactory, Object javaValue, VaListBuilderCall<Z> builderCall) {\n@@ -420,1 +421,1 @@\n-            this.nativeValue = nativeValue;\n+            this.nativeValueFactory = nativeValueFactory;\n@@ -427,2 +428,2 @@\n-        public void accept(VaList.Builder builder) {\n-            builderCall.build(builder, layout, nativeValue);\n+        public void accept(VaList.Builder builder, NativeScope scope) {\n+            builderCall.build(builder, layout, nativeValueFactory.apply(scope));\n@@ -434,0 +435,4 @@\n+\n+        public Object nativeValue(NativeScope scope) {\n+            return nativeValueFactory.apply(scope);\n+        }\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":38,"deletions":33,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -65,1 +65,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(8)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(8, scope);\n@@ -81,1 +82,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(8)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(8, scope);\n","filename":"test\/jdk\/java\/foreign\/TestAddressHandle.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -45,1 +46,0 @@\n-import static jdk.incubator.foreign.MemorySegment.READ;\n@@ -104,4 +104,4 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(layout)) {\n-            init.accept(segment);\n-            checker.accept(segment);\n-        }\n+        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        init.accept(segment);\n+        assertFalse(segment.isReadOnly());\n+        checker.accept(segment);\n@@ -115,3 +115,2 @@\n-        try (MemorySegment segment = MemoryAddress.NULL.asSegmentRestricted(seq.byteSize())) {\n-            arrayFactory.apply(segment);\n-        }\n+        MemorySegment segment = MemoryAddress.NULL.asSegmentRestricted(seq.byteSize());\n+        arrayFactory.apply(segment);\n@@ -124,1 +123,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(layout.byteSize() + 1)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout.byteSize() + 1, layout.byteSize(), scope);\n@@ -130,1 +130,1 @@\n-            expectedExceptions = IllegalStateException.class)\n+            expectedExceptions = UnsupportedOperationException.class)\n@@ -133,1 +133,1 @@\n-        segment.close();\n+        segment.scope().close();\n@@ -137,16 +137,0 @@\n-    @Test(dataProvider = \"elemLayouts\",\n-            expectedExceptions = UnsupportedOperationException.class)\n-    public void testArrayFromHeapSegmentWithoutAccess(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {\n-        MemorySegment segment = MemorySegment.ofArray(new byte[(int)layout.byteSize()]);\n-        segment = segment.withAccessModes(MemorySegment.ALL_ACCESS & ~READ);\n-        arrayFactory.apply(segment);\n-    }\n-\n-    @Test(dataProvider = \"elemLayouts\",\n-            expectedExceptions = UnsupportedOperationException.class)\n-    public void testArrayFromNativeSegmentWithoutAccess(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {\n-        try (MemorySegment segment = MemorySegment.allocateNative(layout).withAccessModes(MemorySegment.ALL_ACCESS & ~READ)) {\n-            arrayFactory.apply(segment);\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":11,"deletions":27,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -189,1 +190,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(tuples)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(tuples, scope);\n@@ -233,3 +235,3 @@\n-        try (MemorySegment segment = MemorySegment.mapFile(tempPath, 0L, 8, FileChannel.MapMode.READ_WRITE)) {\n-            assertTrue(segment.hasAccessModes(ALL_ACCESS));\n-            assertEquals(segment.accessModes(), ALL_ACCESS);\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.mapFile(tempPath, 0L, 8, FileChannel.MapMode.READ_WRITE, scope);\n+            assertFalse(segment.isReadOnly());\n@@ -238,3 +240,3 @@\n-        try (MemorySegment segment = MemorySegment.mapFile(tempPath, 0L, 8, FileChannel.MapMode.READ_ONLY)) {\n-            assertTrue(segment.hasAccessModes(ALL_ACCESS & ~WRITE));\n-            assertEquals(segment.accessModes(), ALL_ACCESS & ~WRITE);\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.mapFile(tempPath, 0L, 8, FileChannel.MapMode.READ_ONLY, scope);\n+            assertTrue(segment.isReadOnly());\n@@ -250,2 +252,3 @@\n-        \/\/write to channel\n-        try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            \/\/write to channel\n+            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE, scope);\n@@ -256,2 +259,3 @@\n-        \/\/read from channel\n-        try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            \/\/read from channel\n+            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY, scope);\n@@ -262,1 +266,1 @@\n-    @Test(dataProvider = \"mappedOps\", expectedExceptions = IllegalStateException.class)\n+    @Test(dataProvider = \"mappedOps\", expectedExceptions = UnsupportedOperationException.class)\n@@ -270,1 +274,1 @@\n-        segment.close();\n+        segment.scope().close();\n@@ -284,2 +288,3 @@\n-            \/\/write to channel\n-            try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {\n+            try (ResourceScope scope = ResourceScope.ofConfined()) {\n+                \/\/write to channel\n+                MemorySegment segment = MemorySegment.mapFile(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE, scope);\n@@ -293,2 +298,3 @@\n-            \/\/read from channel\n-            try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {\n+            try (ResourceScope scope = ResourceScope.ofConfined()) {\n+                \/\/read from channel\n+                MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY, scope);\n@@ -322,1 +328,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(bytes, scope);\n@@ -333,1 +340,1 @@\n-                assertTrue(ex.getCause().getMessage().contains(\"already closed\"));\n+                assertTrue(ex.getCause().getMessage().contains(\"Already closed\"));\n@@ -347,1 +354,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(bytes, scope);\n@@ -369,1 +377,1 @@\n-                assertTrue(ex.getMessage().contains(\"already closed\"));\n+                assertTrue(ex.getMessage().contains(\"Already closed\"));\n@@ -380,1 +388,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(bytes, scope);\n@@ -392,1 +401,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(seq)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(seq, scope);\n@@ -429,1 +439,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(seq)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(seq, scope);\n@@ -439,2 +450,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {\n-            leaked = segment;\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            leaked = MemorySegment.allocateNative(bytes, scope);\n@@ -448,3 +459,2 @@\n-        try (MemorySegment segment = MemoryAddress.NULL.asSegmentRestricted(Integer.MAX_VALUE + 10L)) {\n-            segment.asByteBuffer();\n-        }\n+        MemorySegment segment = MemoryAddress.NULL.asSegmentRestricted(Integer.MAX_VALUE + 10L);\n+        segment.asByteBuffer();\n@@ -477,1 +487,2 @@\n-        try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0, SIZE, FileChannel.MapMode.READ_WRITE)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0, SIZE, FileChannel.MapMode.READ_WRITE, scope);\n@@ -485,1 +496,2 @@\n-            try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), offset, SIZE - offset, FileChannel.MapMode.READ_ONLY)) {\n+            try (ResourceScope scope = ResourceScope.ofConfined()) {\n+                MemorySegment segment = MemorySegment.mapFile(f.toPath(), offset, SIZE - offset, FileChannel.MapMode.READ_ONLY, scope);\n@@ -497,1 +509,2 @@\n-        try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 0L, FileChannel.MapMode.READ_WRITE)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 0L, FileChannel.MapMode.READ_WRITE, scope);\n@@ -500,1 +513,1 @@\n-            assertTrue((segment.accessModes() & (READ | WRITE)) == (READ | WRITE));\n+            assertFalse(segment.isReadOnly());\n@@ -507,1 +520,2 @@\n-        try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 0L, FileChannel.MapMode.READ_ONLY)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 0L, FileChannel.MapMode.READ_ONLY, scope);\n@@ -510,1 +524,1 @@\n-            assertTrue((segment.accessModes() & (READ | WRITE)) == READ);\n+            assertTrue(segment.isReadOnly());\n@@ -528,2 +542,3 @@\n-        try (MemorySegment nativeArray = MemorySegment.allocateNative(bytes);\n-             MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment nativeArray = MemorySegment.allocateNative(bytes, 1, scope);\n+            MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes]);\n@@ -540,2 +555,3 @@\n-        try (MemorySegment nativeArray = MemorySegment.allocateNative(seq);\n-             MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment nativeArray = MemorySegment.allocateNative(seq, scope);\n+            MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes]);\n@@ -551,3 +567,3 @@\n-        try (MemorySegment segment = MemorySegment.ofByteBuffer(rwBuffer)) {\n-            assertTrue(segment.hasAccessModes(ALL_ACCESS));\n-            assertEquals(segment.accessModes(), ALL_ACCESS);\n+        {\n+            MemorySegment segment = MemorySegment.ofByteBuffer(rwBuffer);\n+            assertFalse(segment.isReadOnly());\n@@ -556,4 +572,4 @@\n-        ByteBuffer roBuffer = rwBuffer.asReadOnlyBuffer();\n-        try (MemorySegment segment = MemorySegment.ofByteBuffer(roBuffer)) {\n-            assertTrue(segment.hasAccessModes(ALL_ACCESS & ~WRITE));\n-            assertEquals(segment.accessModes(), ALL_ACCESS & ~WRITE);\n+        {\n+            ByteBuffer roBuffer = rwBuffer.asReadOnlyBuffer();\n+            MemorySegment segment = MemorySegment.ofByteBuffer(roBuffer);\n+            assertTrue(segment.isReadOnly());\n@@ -566,1 +582,1 @@\n-        assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());\n+        assertEquals(segment.isReadOnly(), bb.isReadOnly());\n@@ -569,1 +585,0 @@\n-        assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));\n@@ -573,1 +588,1 @@\n-        assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());\n+        assertEquals(segment.isReadOnly(), bb.isReadOnly());\n@@ -576,1 +591,0 @@\n-        assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));\n@@ -582,6 +596,5 @@\n-        try (MemorySegment segment = MemorySegment.ofByteBuffer(bb)) {\n-            ByteBuffer buffer = segment.asByteBuffer();\n-            assertEquals(buffer.position(), 0);\n-            assertEquals(buffer.capacity(), segment.byteSize());\n-            assertEquals(buffer.limit(), segment.byteSize());\n-        }\n+        MemorySegment segment = MemorySegment.ofByteBuffer(bb);\n+        ByteBuffer buffer = segment.asByteBuffer();\n+        assertEquals(buffer.position(), 0);\n+        assertEquals(buffer.capacity(), segment.byteSize());\n+        assertEquals(buffer.limit(), segment.byteSize());\n@@ -592,2 +605,3 @@\n-        try(MemorySegment ms = MemorySegment.allocateNative(4)) {\n-            MemorySegment msNoAccess = ms.withAccessModes(MemorySegment.READ); \/\/ READ is required to make BB\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment ms = MemorySegment.allocateNative(4, 1, scope);\n+            MemorySegment msNoAccess = ms.asReadOnly();\n@@ -595,1 +609,1 @@\n-            assertEquals(msNoAccess.accessModes(), msRoundTrip.accessModes());\n+            assertEquals(msNoAccess.isReadOnly(), msRoundTrip.isReadOnly());\n@@ -601,1 +615,1 @@\n-        MemorySegment s1 = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT);\n+        MemorySegment s1 = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT, ResourceScope.ofConfined());\n@@ -604,1 +618,2 @@\n-        s1.close(); \/\/ memory freed\n+        \/\/ memory freed\n+        s1.scope().close();\n@@ -613,2 +628,3 @@\n-        try (FileChannel channel = FileChannel.open(tmp.toPath(), StandardOpenOption.WRITE)) {\n-            MemorySegment segment = MemorySegment.allocateNative(10).share();\n+        try (FileChannel channel = FileChannel.open(tmp.toPath(), StandardOpenOption.WRITE) ;\n+             ResourceScope scope = ResourceScope.ofShared()) {\n+            MemorySegment segment = MemorySegment.allocateNative(10, 1, scope);\n@@ -619,1 +635,1 @@\n-            segment.close();\n+            segment.scope().close();\n@@ -629,1 +645,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(10);\n+            MemorySegment segment = MemorySegment.allocateNative(10, ResourceScope.ofConfined());\n@@ -634,1 +650,1 @@\n-            segment.close();\n+            segment.scope().close();\n@@ -644,1 +660,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(10);\n+            MemorySegment segment = MemorySegment.allocateNative(10, ResourceScope.ofConfined());\n@@ -653,3 +669,4 @@\n-    @Test(dataProvider=\"segments\")\n-    public void buffersAndArraysFromSlices(Supplier<MemorySegment> segmentSupplier) {\n-        try (MemorySegment segment = segmentSupplier.get()) {\n+    @Test\n+    public void buffersAndArraysFromSlices() {\n+        try (ResourceScope scope = ResourceScope.ofShared()) {\n+            MemorySegment segment = MemorySegment.allocateNative(16, scope);\n@@ -670,3 +687,4 @@\n-    @Test(dataProvider=\"segments\")\n-    public void viewsFromSharedSegment(Supplier<MemorySegment> segmentSupplier) {\n-        try (MemorySegment segment = segmentSupplier.get().share()) {\n+    @Test\n+    public void viewsFromSharedSegment() {\n+        try (ResourceScope scope = ResourceScope.ofShared()) {\n+            MemorySegment segment = MemorySegment.allocateNative(16, scope);\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":91,"deletions":73,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -1,185 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @modules java.base\/jdk.internal.ref\n- *          jdk.incubator.foreign\/jdk.incubator.foreign\n- * @run testng\/othervm -Dforeign.restricted=permit TestCleaner\n- *\/\n-\n-import jdk.incubator.foreign.MemorySegment;\n-import java.lang.ref.Cleaner;\n-import jdk.internal.ref.CleanerFactory;\n-\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n-import java.util.stream.Stream;\n-\n-public class TestCleaner {\n-\n-    static class SegmentState {\n-        private AtomicInteger cleanupCalls = new AtomicInteger(0);\n-\n-        void cleanup() {\n-            cleanupCalls.incrementAndGet();\n-        }\n-\n-        int cleanupCalls() {\n-            return cleanupCalls.get();\n-        }\n-    }\n-\n-    @Test(dataProvider = \"cleaners\")\n-    public void testAtMostOnce(RegisterKind registerKind, Supplier<Cleaner> cleanerFactory, SegmentFunction segmentFunction) {\n-        SegmentState segmentState = new SegmentState();\n-        MemorySegment root = MemorySegment.allocateNative(10).share();\n-        MemorySegment segment = root.address().asSegmentRestricted(10, () -> {\n-            root.close();\n-            segmentState.cleanup();\n-        }, null);\n-\n-        if (registerKind == RegisterKind.BEFORE) {\n-            \/\/ register cleaners before\n-            segment = segment.registerCleaner(cleanerFactory.get());\n-        }\n-\n-        kickGCAndCheck(segmentState, segment);\n-\n-        segment = segmentFunction.apply(segment);\n-\n-        kickGCAndCheck(segmentState, segment);\n-\n-        if (segment.isAlive() && registerKind == RegisterKind.AFTER) {\n-            \/\/ register cleaners after\n-            segment = segment.registerCleaner(cleanerFactory.get());\n-        }\n-\n-        kickGCAndCheck(segmentState, segment);\n-        segment = null;\n-        while (segmentState.cleanupCalls() == 0) {\n-            byte[] b = new byte[100];\n-            System.gc();\n-            try {\n-                Thread.sleep(10);\n-            } catch (InterruptedException ex) {\n-                throw new AssertionError(ex);\n-            }\n-        }\n-        assertEquals(segmentState.cleanupCalls(), 1);\n-    }\n-\n-    private void kickGCAndCheck(SegmentState segmentState, MemorySegment segment) {\n-        for (int i = 0 ; i < 100 ; i++) {\n-            byte[] b = new byte[100];\n-            System.gc();\n-            Thread.onSpinWait();\n-        }\n-        \/\/check that cleanup has not been called by any cleaner yet!\n-        assertEquals(segmentState.cleanupCalls(), segment.isAlive() ? 0 : 1);\n-    }\n-\n-    @Test(dataProvider = \"segmentFunctions\")\n-    public void testBadDoubleRegister(Supplier<Cleaner> cleanerFactory, SegmentFunction segmentFunction) {\n-        MemorySegment segment = MemorySegment.allocateNative(10);\n-        segment = segment.registerCleaner(cleanerFactory.get());\n-        segment = segmentFunction.apply(segment);\n-        try {\n-            segment.registerCleaner(cleanerFactory.get()); \/\/ error here!\n-            fail();\n-        } catch (IllegalStateException ex) {\n-            if (!segment.isAlive()) {\n-                assertTrue(ex.getMessage().contains(\"This segment is already closed\"));\n-            } else {\n-                assertTrue(ex.getMessage().contains(\"Already registered with a cleaner\"));\n-            }\n-        }\n-    }\n-\n-    enum SegmentFunction implements Function<MemorySegment, MemorySegment> {\n-        IDENTITY(Function.identity()),\n-        CLOSE(s -> { s.close(); return s; }),\n-        SHARE(s -> { return s.share(); });\n-\n-        private final Function<MemorySegment, MemorySegment> segmentFunction;\n-\n-        SegmentFunction(Function<MemorySegment, MemorySegment> segmentFunction) {\n-            this.segmentFunction = segmentFunction;\n-        }\n-\n-        @Override\n-        public MemorySegment apply(MemorySegment segment) {\n-            return segmentFunction.apply(segment);\n-        }\n-    }\n-\n-    @DataProvider\n-    static Object[][] segmentFunctions() {\n-        Supplier<?>[] cleaners = {\n-                (Supplier<Cleaner>)Cleaner::create,\n-                (Supplier<Cleaner>)CleanerFactory::cleaner\n-        };\n-\n-        SegmentFunction[] segmentFunctions = SegmentFunction.values();\n-        Object[][] data = new Object[cleaners.length * segmentFunctions.length][3];\n-\n-        for (int cleaner = 0 ; cleaner < cleaners.length ; cleaner++) {\n-            for (int segmentFunction = 0 ; segmentFunction < segmentFunctions.length ; segmentFunction++) {\n-                data[cleaner + (cleaners.length * segmentFunction)] =\n-                        new Object[] { cleaners[cleaner], segmentFunctions[segmentFunction] };\n-            }\n-        }\n-\n-        return data;\n-    }\n-\n-    enum RegisterKind {\n-        BEFORE,\n-        AFTER;\n-    }\n-\n-    @DataProvider\n-    static Object[][] cleaners() {\n-        Supplier<?>[] cleaners = {\n-                (Supplier<Cleaner>)Cleaner::create,\n-                (Supplier<Cleaner>)CleanerFactory::cleaner\n-        };\n-\n-        List<Object[]> data = new ArrayList<>();\n-        for (RegisterKind kind : RegisterKind.values()) {\n-            for (Object cleaner : cleaners) {\n-                for (SegmentFunction segmentFunction : SegmentFunction.values()) {\n-                    data.add(new Object[] {kind, cleaner, segmentFunction});\n-                }\n-            }\n-        }\n-        return data.toArray(Object[][]::new);\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestCleaner.java","additions":0,"deletions":185,"binary":false,"changes":185,"status":"deleted"},{"patch":"@@ -48,0 +48,1 @@\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -49,0 +50,1 @@\n+import static org.testng.Assert.*;\n@@ -59,1 +61,0 @@\n-        List<MemorySegment> segments = new ArrayList<>();\n@@ -61,6 +62,20 @@\n-        MethodHandle mh = abi.downcallHandle(addr, methodType(ret, paramTypes, fields), function(ret, paramTypes, fields));\n-        Object[] args = makeArgs(paramTypes, fields, checks, segments);\n-        mh = mh.asSpreader(Object[].class, paramTypes.size());\n-        Object res = mh.invoke(args);\n-        if (ret == Ret.NON_VOID) {\n-            checks.forEach(c -> c.accept(res));\n+        MethodType mt = methodType(ret, paramTypes, fields);\n+        FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n+        Object[] args = makeArgs(paramTypes, fields, checks);\n+        try (NativeScope scope = new NativeScope()) {\n+            boolean needsScope = mt.returnType().equals(MemorySegment.class);\n+            Object res = doCall(addr, scope, mt, descriptor, args);\n+            if (ret == Ret.NON_VOID) {\n+                checks.forEach(c -> c.accept(res));\n+                if (needsScope) {\n+                    \/\/ check that return struct has indeed been allocated in the native scope\n+                    assertEquals(((MemorySegment) res).scope(), scope.scope());\n+                    assertEquals(scope.allocatedBytes(), descriptor.returnLayout().get().byteSize());\n+                } else {\n+                    \/\/ if here, there should be no allocation through the scope!\n+                    assertEquals(scope.allocatedBytes(), 0L);\n+                }\n+            } else {\n+                \/\/ if here, there should be no allocation through the scope!\n+                assertEquals(scope.allocatedBytes(), 0L);\n+            }\n@@ -68,1 +83,6 @@\n-        segments.forEach(MemorySegment::close);\n+    }\n+\n+    Object doCall(LibraryLookup.Symbol addr, SegmentAllocator allocator, MethodType type, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n+        MethodHandle mh = abi.downcallHandle(addr, allocator, type, descriptor);\n+        Object res = mh.invokeWithArguments(args);\n+        return res;\n@@ -87,1 +107,1 @@\n-    static Object[] makeArgs(List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<MemorySegment> segments) throws ReflectiveOperationException {\n+    static Object[] makeArgs(List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks) throws ReflectiveOperationException {\n@@ -90,1 +110,1 @@\n-            args[i] = makeArg(params.get(i).layout(fields), checks, i == 0, segments);\n+            args[i] = makeArg(params.get(i).layout(fields), checks, i == 0);\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":30,"deletions":10,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -64,1 +65,2 @@\n-            MemorySegment segment = MemorySegment.allocateNative(SEGMENT_SIZE).share();\n+            ResourceScope scope = ResourceScope.ofShared();\n+            MemorySegment segment = MemorySegment.allocateNative(SEGMENT_SIZE, 1, scope);\n@@ -74,1 +76,1 @@\n-            accessExecutor.execute(new Handshaker(segment));\n+            accessExecutor.execute(new Handshaker(scope));\n@@ -77,1 +79,1 @@\n-            assertTrue(!segment.isAlive());\n+            assertTrue(!segment.scope().isAlive());\n@@ -92,1 +94,1 @@\n-            outer: while (segment.isAlive()) {\n+            outer: while (segment.scope().isAlive()) {\n@@ -106,1 +108,0 @@\n-            cleanup();\n@@ -111,2 +112,0 @@\n-        void cleanup() {}\n-\n@@ -182,1 +181,1 @@\n-            this.copy = MemorySegment.allocateNative(SEGMENT_SIZE).share();\n+            this.copy = MemorySegment.allocateNative(SEGMENT_SIZE, 1, segment.scope());\n@@ -191,5 +190,0 @@\n-\n-        @Override\n-        void cleanup() {\n-            copy.close();\n-        }\n@@ -232,1 +226,1 @@\n-        final MemorySegment segment;\n+        final ResourceScope scope;\n@@ -234,2 +228,2 @@\n-        Handshaker(MemorySegment segment) {\n-            this.segment = segment;\n+        Handshaker(ResourceScope scope) {\n+            this.scope = scope;\n@@ -242,1 +236,1 @@\n-                    segment.close();\n+                    scope.close();\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":11,"deletions":17,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -62,2 +62,3 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(\n-                layout.map(l -> ((SequenceLayout)l).withElementCount(4), MemoryLayout.PathElement.groupElement(\"arr\")))) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(\n+                    layout.map(l -> ((SequenceLayout)l).withElementCount(4), MemoryLayout.PathElement.groupElement(\"arr\")), scope);\n@@ -88,2 +89,3 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(\n-                layout.map(l -> ((SequenceLayout)l).withElementCount(4), MemoryLayout.PathElement.groupElement(\"arr\"), MemoryLayout.PathElement.sequenceElement()))) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(\n+                    layout.map(l -> ((SequenceLayout)l).withElementCount(4), MemoryLayout.PathElement.groupElement(\"arr\"), MemoryLayout.PathElement.sequenceElement()), scope);\n@@ -105,1 +107,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(seq)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(seq, scope);\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -86,2 +87,3 @@\n-        try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout))) {\n-            boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout, scope));\n+            boolean isRO = segment.isReadOnly();\n@@ -117,2 +119,3 @@\n-        try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq))) {\n-            boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, scope));\n+            boolean isRO = segment.isReadOnly();\n@@ -185,2 +188,3 @@\n-        try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq))) {\n-            boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, scope));\n+            boolean isRO = segment.isReadOnly();\n@@ -220,1 +224,1 @@\n-    static Function<MemorySegment, MemorySegment> IMMUTABLE = ms -> ms.withAccessModes(MemorySegment.READ | MemorySegment.CLOSE);\n+    static Function<MemorySegment, MemorySegment> IMMUTABLE = MemorySegment::asReadOnly;\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -52,1 +53,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(aligned)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(aligned, scope);\n@@ -67,1 +69,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(alignedGroup)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(alignedGroup, scope);\n@@ -93,1 +96,2 @@\n-            try (MemorySegment segment = MemorySegment.allocateNative(layout)) {\n+            try (ResourceScope scope = ResourceScope.ofConfined()) {\n+                MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n@@ -116,1 +120,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(g)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(g, scope);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -36,0 +37,2 @@\n+\n+import jdk.incubator.foreign.ResourceScope;\n@@ -61,1 +64,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(layout)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n@@ -83,1 +87,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(layout)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n@@ -105,1 +110,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(layout)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n@@ -127,1 +133,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(layout)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n@@ -153,1 +160,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(layout)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n@@ -167,1 +175,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(layout)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryHandleAsUnsigned.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import jdk.incubator.foreign.MemoryAddress;\n+\n@@ -37,0 +37,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -40,1 +41,0 @@\n-import static jdk.incubator.foreign.MemorySegment.READ;\n@@ -104,1 +104,2 @@\n-        try (var nativeSegment = MemorySegment.allocateNative(4)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            var nativeSegment = MemorySegment.allocateNative(4, 4, scope);\n@@ -115,2 +116,3 @@\n-            try (var s1 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L);\n-                 var s2 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L)) {\n+            try (ResourceScope scope = ResourceScope.ofConfined()) {\n+                var s1 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, scope);\n+                var s2 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, scope);\n@@ -152,3 +154,5 @@\n-        var s1 = MemorySegment.ofArray(new byte[4]);\n-        var s2 = MemorySegment.ofArray(new byte[4]);\n-        s1.close();\n+        MemorySegment s1, s2;\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            s1 = MemorySegment.allocateNative(4, 1, scope);\n+            s2 = MemorySegment.allocateNative(4, 1, scope);\n+        }\n@@ -160,12 +164,0 @@\n-    @Test\n-    public void testInsufficientAccessModes() {\n-        var s1 = MemorySegment.ofArray(new byte[4]);\n-        var s2 = MemorySegment.ofArray(new byte[4]);\n-        var s1WithoutRead = s1.withAccessModes(s1.accessModes() & ~READ);\n-        var s2WithoutRead = s2.withAccessModes(s2.accessModes() & ~READ);\n-\n-        assertThrows(UOE, () -> s1.mismatch(s2WithoutRead));\n-        assertThrows(UOE, () -> s1WithoutRead.mismatch(s2));\n-        assertThrows(UOE, () -> s1WithoutRead.mismatch(s2WithoutRead));\n-    }\n-\n@@ -174,8 +166,18 @@\n-        var segment = MemorySegment.ofArray(new byte[4]);\n-        {\n-            AtomicReference<RuntimeException> exception = new AtomicReference<>();\n-            Runnable action = () -> {\n-                try {\n-                    MemorySegment.ofArray(new byte[4]).mismatch(segment);\n-                } catch (RuntimeException e) {\n-                    exception.set(e);\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            var segment = MemorySegment.allocateNative(4, 1, scope);\n+            {\n+                AtomicReference<RuntimeException> exception = new AtomicReference<>();\n+                Runnable action = () -> {\n+                    try {\n+                        MemorySegment.ofArray(new byte[4]).mismatch(segment);\n+                    } catch (RuntimeException e) {\n+                        exception.set(e);\n+                    }\n+                };\n+                Thread thread = new Thread(action);\n+                thread.start();\n+                thread.join();\n+\n+                RuntimeException e = exception.get();\n+                if (!(e instanceof IllegalStateException)) {\n+                    throw e;\n@@ -183,8 +185,0 @@\n-            };\n-            Thread thread = new Thread(action);\n-            thread.start();\n-            thread.join();\n-\n-            RuntimeException e = exception.get();\n-            if (!(e instanceof IllegalStateException)) {\n-                throw e;\n@@ -192,8 +186,16 @@\n-        }\n-        {\n-            AtomicReference<RuntimeException> exception = new AtomicReference<>();\n-            Runnable action = () -> {\n-                try {\n-                    segment.mismatch(MemorySegment.ofArray(new byte[4]));\n-                } catch (RuntimeException e) {\n-                    exception.set(e);\n+            {\n+                AtomicReference<RuntimeException> exception = new AtomicReference<>();\n+                Runnable action = () -> {\n+                    try {\n+                        segment.mismatch(MemorySegment.ofArray(new byte[4]));\n+                    } catch (RuntimeException e) {\n+                        exception.set(e);\n+                    }\n+                };\n+                Thread thread = new Thread(action);\n+                thread.start();\n+                thread.join();\n+\n+                RuntimeException e = exception.get();\n+                if (!(e instanceof IllegalStateException)) {\n+                    throw e;\n@@ -201,8 +203,0 @@\n-            };\n-            Thread thread = new Thread(action);\n-            thread.start();\n-            thread.join();\n-\n-            RuntimeException e = exception.get();\n-            if (!(e instanceof IllegalStateException)) {\n-                throw e;\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":46,"deletions":52,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -156,1 +157,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(seq)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(seq, scope);\n@@ -165,1 +167,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(doubles)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(doubles, scope);\n@@ -177,4 +180,3 @@\n-        MemorySegment mallocSegment = addr.asSegmentRestricted(12, () -> free(addr), null);\n-        try (MemorySegment segment = mallocSegment) {\n-            assertTrue(segment.hasAccessModes(ALL_ACCESS));\n-            assertEquals(segment.accessModes(), ALL_ACCESS);\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment mallocSegment = addr.asSegmentRestricted(12, () -> free(addr), scope);\n+            assertFalse(mallocSegment.isReadOnly());\n@@ -187,2 +189,1 @@\n-        assertTrue(everything.hasAccessModes(READ | WRITE));\n-        assertEquals(everything.accessModes(), READ | WRITE);\n+        assertFalse(everything.isReadOnly());\n@@ -194,4 +195,7 @@\n-        MemorySegment mallocSegment = addr.asSegmentRestricted(12, () -> free(addr), null);\n-        assertEquals(mallocSegment.byteSize(), 12);\n-        mallocSegment.close(); \/\/free here\n-        assertTrue(!mallocSegment.isAlive());\n+        MemorySegment mallocSegment = null;\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            mallocSegment = addr.asSegmentRestricted(12, () -> free(addr), scope);\n+            assertEquals(mallocSegment.byteSize(), 12);\n+            \/\/free here\n+        }\n+        assertTrue(!mallocSegment.scope().isAlive());\n@@ -211,1 +215,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(4)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(4, 1, scope);\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1,536 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @run testng\/othervm TestNativeScope\n- *\/\n-\n-import jdk.incubator.foreign.*;\n-\n-import org.testng.annotations.*;\n-\n-import java.lang.invoke.VarHandle;\n-import java.lang.reflect.Array;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-import java.nio.DoubleBuffer;\n-import java.nio.FloatBuffer;\n-import java.nio.IntBuffer;\n-import java.nio.LongBuffer;\n-import java.nio.ShortBuffer;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n-import java.util.stream.IntStream;\n-import java.util.stream.LongStream;\n-\n-import static jdk.incubator.foreign.MemorySegment.CLOSE;\n-import static jdk.incubator.foreign.MemorySegment.HANDOFF;\n-import static org.testng.Assert.*;\n-\n-public class TestNativeScope {\n-\n-    final static int ELEMS = 128;\n-    final static Class<?> ADDRESS_CARRIER = MemoryLayouts.ADDRESS.bitSize() == 64 ? long.class : int.class;\n-\n-    @Test(dataProvider = \"nativeScopes\")\n-    public <Z> void testAllocation(Z value, ScopeFactory scopeFactory, ValueLayout layout, AllocationFunction<Z> allocationFunction, Function<MemoryLayout, VarHandle> handleFactory) {\n-        ValueLayout[] layouts = {\n-                layout,\n-                layout.withBitAlignment(layout.bitAlignment() * 2),\n-                layout.withBitAlignment(layout.bitAlignment() * 4),\n-                layout.withBitAlignment(layout.bitAlignment() * 8)\n-        };\n-        for (ValueLayout alignedLayout : layouts) {\n-            List<MemorySegment> addressList = new ArrayList<>();\n-            int elems = ELEMS \/ ((int)alignedLayout.byteAlignment() \/ (int)layout.byteAlignment());\n-            try (NativeScope scope = scopeFactory.make((int)alignedLayout.byteSize() * ELEMS)) {\n-                for (int i = 0 ; i < elems ; i++) {\n-                    MemorySegment address = allocationFunction.allocate(scope, alignedLayout, value);\n-                    assertEquals(address.byteSize(), alignedLayout.byteSize());\n-                    addressList.add(address);\n-                    VarHandle handle = handleFactory.apply(alignedLayout);\n-                    assertEquals(value, handle.get(address));\n-                    try {\n-                        address.close();\n-                        fail();\n-                    } catch (UnsupportedOperationException uoe) {\n-                        \/\/failure is expected\n-                        assertTrue(true);\n-                    }\n-                }\n-                boolean isBound = scope.byteSize().isPresent();\n-                try {\n-                    allocationFunction.allocate(scope, alignedLayout, value); \/\/too much, should fail if bound\n-                    assertFalse(isBound);\n-                } catch (OutOfMemoryError ex) {\n-                    \/\/failure is expected if bound\n-                    assertTrue(isBound);\n-                }\n-            }\n-            \/\/ addresses should be invalid now\n-            for (MemorySegment address : addressList) {\n-                assertFalse(address.isAlive());\n-            }\n-        }\n-    }\n-\n-    static final int SIZE_256M = 1024 * 1024 * 256;\n-\n-    @Test\n-    public void testBigAllocationInUnboundedScope() {\n-        try (NativeScope scope = NativeScope.unboundedScope()) {\n-            for (int i = 8 ; i < SIZE_256M ; i *= 8) {\n-                MemorySegment address = scope.allocate(i);\n-                \/\/check size\n-                assertEquals(address.byteSize(), i);\n-                \/\/check alignment\n-                assertTrue(address.address().toRawLongValue() % i == 0);\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void testAttachClose() {\n-        MemorySegment s1 = MemorySegment.ofArray(new byte[1]);\n-        MemorySegment s2 = MemorySegment.ofArray(new byte[1]);\n-        MemorySegment s3 = MemorySegment.ofArray(new byte[1]);\n-        assertTrue(s1.isAlive());\n-        assertTrue(s2.isAlive());\n-        assertTrue(s3.isAlive());\n-        try (NativeScope scope = NativeScope.boundedScope(10)) {\n-            MemorySegment ss1 = s1.handoff(scope);\n-            assertFalse(s1.isAlive());\n-            assertTrue(ss1.isAlive());\n-            s1 = ss1;\n-            MemorySegment ss2 = s2.handoff(scope);\n-            assertFalse(s2.isAlive());\n-            assertTrue(ss2.isAlive());\n-            s2 = ss2;\n-            MemorySegment ss3 = s3.handoff(scope);\n-            assertFalse(s3.isAlive());\n-            assertTrue(ss3.isAlive());\n-            s3 = ss3;\n-        }\n-        assertFalse(s1.isAlive());\n-        assertFalse(s2.isAlive());\n-        assertFalse(s3.isAlive());\n-    }\n-\n-    @Test\n-    public void testNoTerminalOps() {\n-        try (NativeScope scope = NativeScope.boundedScope(10)) {\n-            MemorySegment s1 = MemorySegment.ofArray(new byte[1]);\n-            MemorySegment attached = s1.handoff(scope);\n-            int[] terminalOps = {CLOSE, HANDOFF};\n-            for (int mode : terminalOps) {\n-                if (attached.hasAccessModes(mode)) {\n-                    fail();\n-                }\n-            }\n-        }\n-    }\n-\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testNoReattach() {\n-        MemorySegment s1 = MemorySegment.ofArray(new byte[1]);\n-        NativeScope scope1 = NativeScope.boundedScope(10);\n-        NativeScope scope2 = NativeScope.boundedScope(10);\n-        s1.handoff(scope1).handoff(scope2);\n-    }\n-\n-    @Test(expectedExceptions = IllegalStateException.class)\n-    public void testNotAliveClaim() {\n-        MemorySegment segment = MemorySegment.ofArray(new byte[1]);\n-        segment.close();\n-        segment.handoff(NativeScope.boundedScope(10));\n-    }\n-\n-    @Test\n-    public void testRegisterFromUnconfined() {\n-        MemorySegment unconfined = MemorySegment.allocateNative(10).share();\n-        NativeScope scope = NativeScope.boundedScope(10);\n-        MemorySegment registered = unconfined.handoff(scope);\n-        assertFalse(unconfined.isAlive());\n-        assertEquals(registered.ownerThread(), scope.ownerThread());\n-        scope.close();\n-        assertFalse(registered.isAlive());\n-    }\n-\n-    @Test(dataProvider = \"arrayScopes\")\n-    public <Z> void testArray(ScopeFactory scopeFactory, ValueLayout layout, AllocationFunction<Object> allocationFunction, ToArrayHelper<Z> arrayHelper) {\n-        Z arr = arrayHelper.array();\n-        try (NativeScope scope = scopeFactory.make(100)) {\n-            MemorySegment address = allocationFunction.allocate(scope, layout, arr);\n-            Z found = arrayHelper.toArray(address, layout);\n-            assertEquals(found, arr);\n-        }\n-    }\n-\n-    @DataProvider(name = \"nativeScopes\")\n-    static Object[][] nativeScopes() {\n-        return new Object[][] {\n-                { (byte)42, (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_8_BE,\n-                        (AllocationFunction<Byte>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n-                { (short)42, (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<Short>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n-                { (char)42, (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<Character>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n-                { 42, (ScopeFactory) NativeScope::boundedScope,\n-                        MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<Integer>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n-                { 42f, (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<Float>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n-                { 42L, (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<Long>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n-                { 42d, (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<Double>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n-                { MemoryAddress.ofLong(42), (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n-                        (AllocationFunction<MemoryAddress>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n-\n-                { (byte)42, (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_8_LE,\n-                        (AllocationFunction<Byte>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n-                { (short)42, (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<Short>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n-                { (char)42, (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<Character>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n-                { 42, (ScopeFactory) NativeScope::boundedScope,\n-                        MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<Integer>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n-                { 42f, (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<Float>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n-                { 42L, (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<Long>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n-                { 42d, (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<Double>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n-                { MemoryAddress.ofLong(42), (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n-                        (AllocationFunction<MemoryAddress>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n-\n-                { (byte)42, (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_8_BE,\n-                        (AllocationFunction<Byte>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n-                { (short)42, (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<Short>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n-                { (char)42, (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<Character>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n-                { 42, (ScopeFactory)size -> NativeScope.unboundedScope(),\n-                        MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<Integer>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n-                { 42f, (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<Float>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n-                { 42L, (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<Long>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n-                { 42d, (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<Double>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n-                { MemoryAddress.ofLong(42), (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n-                        (AllocationFunction<MemoryAddress>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n-\n-                { (byte)42, (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_8_LE,\n-                        (AllocationFunction<Byte>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n-                { (short)42, (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<Short>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n-                { (char)42, (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<Character>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n-                { 42, (ScopeFactory)size -> NativeScope.unboundedScope(),\n-                        MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<Integer>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n-                { 42f, (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<Float>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n-                { 42L, (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<Long>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n-                { 42d, (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<Double>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n-                { MemoryAddress.ofLong(42), (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n-                        (AllocationFunction<MemoryAddress>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n-        };\n-    }\n-\n-    @DataProvider(name = \"arrayScopes\")\n-    static Object[][] arrayScopes() {\n-        return new Object[][] {\n-                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_8_LE,\n-                        (AllocationFunction<byte[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toByteArray },\n-                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<short[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toShortArray },\n-                { (ScopeFactory) NativeScope::boundedScope,\n-                        MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<int[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toIntArray },\n-                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<float[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toFloatArray },\n-                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<long[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toLongArray },\n-                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<double[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toDoubleArray },\n-                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n-                        (AllocationFunction<MemoryAddress[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toAddressArray },\n-\n-\n-                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_8_BE,\n-                        (AllocationFunction<byte[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toByteArray },\n-                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<short[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toShortArray },\n-                { (ScopeFactory) NativeScope::boundedScope,\n-                        MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<int[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toIntArray },\n-                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<float[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toFloatArray },\n-                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<long[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toLongArray },\n-                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<double[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toDoubleArray },\n-                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n-                        (AllocationFunction<MemoryAddress[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toAddressArray },\n-\n-                { (ScopeFactory) size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_8_LE,\n-                        (AllocationFunction<byte[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toByteArray },\n-                { (ScopeFactory) size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<short[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toShortArray },\n-                { (ScopeFactory) size -> NativeScope.unboundedScope(),\n-                        MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<int[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toIntArray },\n-                { (ScopeFactory) size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<float[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toFloatArray },\n-                { (ScopeFactory) size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<long[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toLongArray },\n-                { (ScopeFactory) size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<double[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toDoubleArray },\n-                { (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n-                        (AllocationFunction<MemoryAddress[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toAddressArray },\n-\n-\n-                { (ScopeFactory) size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_8_BE,\n-                        (AllocationFunction<byte[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toByteArray },\n-                { (ScopeFactory) size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<short[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toShortArray },\n-                { (ScopeFactory) size -> NativeScope.unboundedScope(),\n-                        MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<int[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toIntArray },\n-                { (ScopeFactory) size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<float[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toFloatArray },\n-                { (ScopeFactory) size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<long[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toLongArray },\n-                { (ScopeFactory) size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<double[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toDoubleArray },\n-                { (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n-                        (AllocationFunction<MemoryAddress[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toAddressArray },\n-        };\n-    }\n-\n-    interface AllocationFunction<X> {\n-        MemorySegment allocate(NativeScope scope, ValueLayout layout, X value);\n-    }\n-\n-    interface ScopeFactory {\n-        NativeScope make(int size);\n-    }\n-\n-    interface ToArrayHelper<T> {\n-        T array();\n-        T toArray(MemorySegment segment, ValueLayout layout);\n-\n-        ToArrayHelper<byte[]> toByteArray = new ToArrayHelper<>() {\n-            @Override\n-            public byte[] array() {\n-                return new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n-            }\n-\n-            @Override\n-            public byte[] toArray(MemorySegment segment, ValueLayout layout) {\n-                ByteBuffer buffer = segment.asByteBuffer().order(layout.order());\n-                byte[] found = new byte[buffer.limit()];\n-                buffer.get(found);\n-                return found;\n-            }\n-        };\n-\n-        ToArrayHelper<short[]> toShortArray = new ToArrayHelper<>() {\n-            @Override\n-            public short[] array() {\n-                return new short[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n-            }\n-\n-            @Override\n-            public short[] toArray(MemorySegment segment, ValueLayout layout) {\n-                ShortBuffer buffer = segment.asByteBuffer().order(layout.order()).asShortBuffer();\n-                short[] found = new short[buffer.limit()];\n-                buffer.get(found);\n-                return found;\n-            }\n-        };\n-\n-        ToArrayHelper<int[]> toIntArray = new ToArrayHelper<>() {\n-            @Override\n-            public int[] array() {\n-                return new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n-            }\n-\n-            @Override\n-            public int[] toArray(MemorySegment segment, ValueLayout layout) {\n-                IntBuffer buffer = segment.asByteBuffer().order(layout.order()).asIntBuffer();\n-                int[] found = new int[buffer.limit()];\n-                buffer.get(found);\n-                return found;\n-            }\n-        };\n-\n-        ToArrayHelper<float[]> toFloatArray = new ToArrayHelper<>() {\n-            @Override\n-            public float[] array() {\n-                return new float[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n-            }\n-\n-            @Override\n-            public float[] toArray(MemorySegment segment, ValueLayout layout) {\n-                FloatBuffer buffer = segment.asByteBuffer().order(layout.order()).asFloatBuffer();\n-                float[] found = new float[buffer.limit()];\n-                buffer.get(found);\n-                return found;\n-            }\n-        };\n-\n-        ToArrayHelper<long[]> toLongArray = new ToArrayHelper<>() {\n-            @Override\n-            public long[] array() {\n-                return new long[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n-            }\n-\n-            @Override\n-            public long[] toArray(MemorySegment segment, ValueLayout layout) {\n-                LongBuffer buffer = segment.asByteBuffer().order(layout.order()).asLongBuffer();\n-                long[] found = new long[buffer.limit()];\n-                buffer.get(found);\n-                return found;\n-            }\n-        };\n-\n-        ToArrayHelper<double[]> toDoubleArray = new ToArrayHelper<>() {\n-            @Override\n-            public double[] array() {\n-                return new double[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n-            }\n-\n-            @Override\n-            public double[] toArray(MemorySegment segment, ValueLayout layout) {\n-                DoubleBuffer buffer = segment.asByteBuffer().order(layout.order()).asDoubleBuffer();\n-                double[] found = new double[buffer.limit()];\n-                buffer.get(found);\n-                return found;\n-            }\n-        };\n-\n-        ToArrayHelper<MemoryAddress[]> toAddressArray = new ToArrayHelper<>() {\n-            @Override\n-            public MemoryAddress[] array() {\n-                return switch ((int)MemoryLayouts.ADDRESS.byteSize()) {\n-                    case 4 -> wrap(toIntArray.array());\n-                    case 8 -> wrap(toLongArray.array());\n-                    default -> throw new IllegalStateException(\"Cannot get here\");\n-                };\n-            }\n-\n-            @Override\n-            public MemoryAddress[] toArray(MemorySegment segment, ValueLayout layout) {\n-                return switch ((int)layout.byteSize()) {\n-                    case 4 -> wrap(toIntArray.toArray(segment, layout));\n-                    case 8 -> wrap(toLongArray.toArray(segment, layout));\n-                    default -> throw new IllegalStateException(\"Cannot get here\");\n-                };\n-            }\n-\n-            private MemoryAddress[] wrap(int[] ints) {\n-                return IntStream.of(ints).mapToObj(MemoryAddress::ofLong).toArray(MemoryAddress[]::new);\n-            }\n-\n-            private MemoryAddress[] wrap(long[] ints) {\n-                return LongStream.of(ints).mapToObj(MemoryAddress::ofLong).toArray(MemoryAddress[]::new);\n-            }\n-        };\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestNativeScope.java","additions":0,"deletions":536,"binary":false,"changes":536,"status":"deleted"},{"patch":"@@ -56,0 +56,1 @@\n+import java.util.function.Supplier;\n@@ -88,1 +89,0 @@\n-            NativeScope.class,\n@@ -93,1 +93,3 @@\n-            LibraryLookup.class\n+            LibraryLookup.class,\n+            SegmentAllocator.class,\n+            ResourceScope.class\n@@ -100,0 +102,1 @@\n+            \"jdk.incubator.foreign.MemoryAddress\/asSegmentRestricted(long,java.lang.Runnable,jdk.incubator.foreign.ResourceScope)\/1\/0\",\n@@ -104,1 +107,5 @@\n-            \"jdk.incubator.foreign.FunctionDescriptor\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\"\n+            \"jdk.incubator.foreign.FunctionDescriptor\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ResourceScope\/ofConfined(java.lang.Object,java.lang.ref.Cleaner)\/0\/0\",\n+            \"jdk.incubator.foreign.ResourceScope\/ofConfined(java.lang.Object,java.lang.ref.Cleaner)\/1\/0\",\n+            \"jdk.incubator.foreign.ResourceScope\/ofShared(java.lang.Object,java.lang.ref.Cleaner)\/0\/0\",\n+            \"jdk.incubator.foreign.ResourceScope\/ofShared(java.lang.Object,java.lang.ref.Cleaner)\/1\/0\"\n@@ -125,0 +132,1 @@\n+        addDefaultMapping(boolean.class, true);\n@@ -150,1 +158,0 @@\n-        addDefaultMapping(NativeScope.class, NativeScope.boundedScope(10));\n@@ -156,0 +163,3 @@\n+        addDefaultMapping(ResourceScope.class, ResourceScope.ofConfined());\n+        addDefaultMapping(SegmentAllocator.class, MemorySegment::allocateNative);\n+        addDefaultMapping(Supplier.class, () -> null);\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.ref\n+ *          jdk.incubator.foreign\/jdk.incubator.foreign\n+ * @run testng\/othervm -Dforeign.restricted=permit TestResourceScope\n+ *\/\n+\n+import java.lang.ref.Cleaner;\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.internal.ref.CleanerFactory;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+import java.util.stream.IntStream;\n+\n+public class TestResourceScope {\n+\n+    final static int N_THREADS = 10000;\n+\n+    @Test(dataProvider = \"cleaners\")\n+    public void testConfined(Supplier<Cleaner> cleanerSupplier) {\n+        AtomicInteger acc = new AtomicInteger();\n+        Cleaner cleaner = cleanerSupplier.get();\n+        ResourceScope scope = ResourceScope.ofConfined(null, cleaner);\n+        for (int i = 0 ; i < N_THREADS ; i++) {\n+            int delta = i;\n+            scope.addOnClose(() -> acc.addAndGet(delta));\n+        }\n+        assertEquals(acc.get(), 0);\n+\n+        if (cleaner == null) {\n+            scope.close();\n+            assertEquals(acc.get(), IntStream.range(0, N_THREADS).sum());\n+        } else {\n+            scope = null;\n+            int expected = IntStream.range(0, N_THREADS).sum();\n+            while (acc.get() != expected) {\n+                kickGC();\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"cleaners\")\n+    public void testSharedSingleThread(Supplier<Cleaner> cleanerSupplier) {\n+        AtomicInteger acc = new AtomicInteger();\n+        Cleaner cleaner = cleanerSupplier.get();\n+        ResourceScope scope = ResourceScope.ofShared(null, cleaner);\n+        for (int i = 0 ; i < N_THREADS ; i++) {\n+            int delta = i;\n+            scope.addOnClose(() -> acc.addAndGet(delta));\n+        }\n+        assertEquals(acc.get(), 0);\n+\n+        if (cleaner == null) {\n+            scope.close();\n+            assertEquals(acc.get(), IntStream.range(0, N_THREADS).sum());\n+        } else {\n+            scope = null;\n+            int expected = IntStream.range(0, N_THREADS).sum();\n+            while (acc.get() != expected) {\n+                kickGC();\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"cleaners\")\n+    public void testSharedMultiThread(Supplier<Cleaner> cleanerSupplier) {\n+        AtomicInteger acc = new AtomicInteger();\n+        Cleaner cleaner = cleanerSupplier.get();\n+        List<Thread> threads = new ArrayList<>();\n+        ResourceScope scope = ResourceScope.ofShared(null, cleaner);\n+        AtomicReference<ResourceScope> scopeRef = new AtomicReference<>(scope);\n+        for (int i = 0 ; i < N_THREADS ; i++) {\n+            int delta = i;\n+            Thread thread = new Thread(() -> {\n+                try {\n+                    scopeRef.get().addOnClose(() -> {\n+                        acc.addAndGet(delta);\n+                    });\n+                } catch (IllegalStateException ex) {\n+                    \/\/ already closed - we need to call cleanup manually\n+                    acc.addAndGet(delta);\n+                }\n+            });\n+            threads.add(thread);\n+        }\n+        assertEquals(acc.get(), 0);\n+        threads.forEach(Thread::start);\n+\n+        \/\/ if no cleaner, close - not all segments might have been added to the scope!\n+        \/\/ if cleaner, don't unset the scope - after all, the scope is kept alive by threads\n+        if (cleaner == null) {\n+            scope.close();\n+        }\n+\n+        threads.forEach(t -> {\n+            try {\n+                t.join();\n+            } catch (InterruptedException ex) {\n+                fail();\n+            }\n+        });\n+\n+        if (cleaner == null) {\n+            assertEquals(acc.get(), IntStream.range(0, N_THREADS).sum());\n+        } else {\n+            scope = null;\n+            scopeRef.set(null);\n+            int expected = IntStream.range(0, N_THREADS).sum();\n+            while (acc.get() != expected) {\n+                kickGC();\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"cleaners\")\n+    public void testLockSingleThread(Supplier<Cleaner> cleanerSupplier) {\n+        Cleaner cleaner = cleanerSupplier.get();\n+        ResourceScope scope = ResourceScope.ofConfined(null, cleaner);\n+        List<ResourceScope.Handle> handles = new ArrayList<>();\n+        for (int i = 0 ; i < N_THREADS ; i++) {\n+            handles.add(scope.acquire());\n+        }\n+\n+        while (true) {\n+            try {\n+                scope.close();\n+                assertEquals(handles.size(), 0);\n+                break;\n+            } catch (IllegalStateException ex) {\n+                assertTrue(handles.size() > 0);\n+                ResourceScope.Handle handle = handles.remove(0);\n+                handle.close();\n+                handle.close(); \/\/ make sure it's idempotent\n+                handle.close(); \/\/ make sure it's idempotent\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"cleaners\")\n+    public void testLockSharedMultiThread(Supplier<Cleaner> cleanerSupplier) {\n+        Cleaner cleaner = cleanerSupplier.get();\n+        ResourceScope scope = ResourceScope.ofShared(null, cleaner);\n+        for (int i = 0 ; i < N_THREADS ; i++) {\n+            new Thread(() -> {\n+                try {\n+                    ResourceScope.Handle handle = scope.acquire();\n+                    waitSomeTime();\n+                    handle.close();\n+                    handle.close(); \/\/ make sure it's idempotent\n+                    handle.close(); \/\/ make sure it's idempotent\n+                } catch (IllegalStateException ex) {\n+                    \/\/ might be already closed - do nothing\n+                }\n+            }).start();\n+        }\n+\n+        while (true) {\n+            try {\n+                scope.close();\n+                break;\n+            } catch (IllegalStateException ex) {\n+                waitSomeTime();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testCloseEmptyConfinedScope() {\n+        ResourceScope.ofConfined().close();\n+    }\n+\n+    @Test\n+    public void testCloseEmptySharedScope() {\n+        ResourceScope.ofShared().close();\n+    }\n+\n+    @Test\n+    public void testCloseConfinedLock() {\n+        ResourceScope.Handle handle = ResourceScope.ofConfined().acquire();\n+        AtomicReference<Throwable> failure = new AtomicReference<>();\n+        Thread t = new Thread(() -> {\n+            try {\n+                handle.close();\n+                handle.close(); \/\/ make sure it's idempotent\n+                handle.close(); \/\/ make sure it's idempotent\n+            } catch (Throwable ex) {\n+                failure.set(ex);\n+            }\n+        });\n+        t.start();\n+        try {\n+            t.join();\n+            assertNotNull(failure.get());\n+            assertEquals(failure.get().getClass(), IllegalStateException.class);\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    private void waitSomeTime() {\n+        try {\n+            Thread.sleep(10);\n+        } catch (InterruptedException ex) {\n+            \/\/ ignore\n+        }\n+    }\n+\n+    private void kickGC() {\n+        for (int i = 0 ; i < 100 ; i++) {\n+            byte[] b = new byte[100];\n+            System.gc();\n+            Thread.onSpinWait();\n+        }\n+    }\n+\n+    @DataProvider\n+    static Object[][] cleaners() {\n+        return new Object[][] {\n+                { (Supplier<Cleaner>)() -> null },\n+                { (Supplier<Cleaner>)Cleaner::create },\n+                { (Supplier<Cleaner>)CleanerFactory::cleaner }\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestResourceScope.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm -Dforeign.restricted=permit TestScopedOperations\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemoryLayouts;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class TestScopedOperations {\n+\n+    @Test(dataProvider = \"scopedOperations\")\n+    public void testOpAfterClose(String name, ScopedOperation scopedOperation) {\n+        ResourceScope scope = ResourceScope.ofConfined();\n+        scope.close();\n+        try {\n+            scopedOperation.accept(scope);\n+            fail();\n+        } catch (IllegalStateException ex) {\n+            assertTrue(ex.getMessage().contains(\"closed\"));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"scopedOperations\")\n+    public void testOpOutsideConfinement(String name, ScopedOperation scopedOperation) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            AtomicReference<Throwable> failed = new AtomicReference<>();\n+            Thread t = new Thread(() -> {\n+                try {\n+                    scopedOperation.accept(scope);\n+                } catch (Throwable ex) {\n+                    failed.set(ex);\n+                }\n+            });\n+            t.start();\n+            t.join();\n+            assertNotNull(failed.get());\n+            assertEquals(failed.get().getClass(), IllegalStateException.class);\n+            assertTrue(failed.get().getMessage().contains(\"outside\"));\n+        } catch (InterruptedException ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static List<ScopedOperation> scopedOperations = new ArrayList<>();\n+\n+    static {\n+            \/\/ scope operations\n+            ScopedOperation.ofScope(scope -> scope.addOnClose(() -> {}), \"ResourceScope::addOnClose\");\n+            ScopedOperation.ofScope(scope -> scope.acquire().close(), \"ResourceScope::lock\");\n+            \/\/ segment operations\n+            ScopedOperation.ofSegment(MemorySegment::toByteArray, \"MemorySegment::toByteArray\");\n+            ScopedOperation.ofSegment(MemorySegment::toCharArray, \"MemorySegment::toCharArray\");\n+            ScopedOperation.ofSegment(MemorySegment::toShortArray, \"MemorySegment::toShortArray\");\n+            ScopedOperation.ofSegment(MemorySegment::toIntArray, \"MemorySegment::toIntArray\");\n+            ScopedOperation.ofSegment(MemorySegment::toFloatArray, \"MemorySegment::toFloatArray\");\n+            ScopedOperation.ofSegment(MemorySegment::toLongArray, \"MemorySegment::toLongArray\");\n+            ScopedOperation.ofSegment(MemorySegment::toDoubleArray, \"MemorySegment::toDoubleArray\");\n+            ScopedOperation.ofSegment(MemorySegment::address, \"MemorySegment::address\");\n+            ScopedOperation.ofSegment(s -> MemoryLayout.ofSequence(s.byteSize(), MemoryLayouts.JAVA_BYTE), \"MemorySegment::spliterator\");\n+            ScopedOperation.ofSegment(s -> s.copyFrom(s), \"MemorySegment::copyFrom\");\n+            ScopedOperation.ofSegment(s -> s.mismatch(s), \"MemorySegment::mismatch\");\n+            ScopedOperation.ofSegment(s -> s.fill((byte) 0), \"MemorySegment::fill\");\n+            \/\/ valist operations\n+            ScopedOperation.ofVaList(CLinker.VaList::address, \"VaList::address\");\n+            ScopedOperation.ofVaList(CLinker.VaList::copy, \"VaList::copy\");\n+            ScopedOperation.ofVaList(list -> list.vargAsAddress(MemoryLayouts.ADDRESS), \"VaList::vargAsAddress\");\n+            ScopedOperation.ofVaList(list -> list.vargAsInt(MemoryLayouts.JAVA_INT), \"VaList::vargAsInt\");\n+            ScopedOperation.ofVaList(list -> list.vargAsLong(MemoryLayouts.JAVA_LONG), \"VaList::vargAsLong\");\n+            ScopedOperation.ofVaList(list -> list.vargAsDouble(MemoryLayouts.JAVA_DOUBLE), \"VaList::vargAsDouble\");\n+            ScopedOperation.ofVaList(CLinker.VaList::skip, \"VaList::skip\");\n+            ScopedOperation.ofVaList(list -> list.vargAsSegment(MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT)), \"VaList::vargAsSegment\/1\");\n+            ScopedOperation.ofVaList(list -> list.vargAsSegment(MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT), SegmentAllocator.malloc(list::scope)), \"VaList::vargAsSegment\/2\");\n+            \/\/ allocator operations\n+            ScopedOperation.ofAllocator(a -> a.allocate(1), \"NativeAllocator::allocate\/size\");\n+            ScopedOperation.ofAllocator(a -> a.allocate(1, 1), \"NativeAllocator::allocate\/size\/align\");\n+            ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_BYTE), \"NativeAllocator::allocate\/layout\");\n+            ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_BYTE, (byte)0), \"NativeAllocator::allocate\/byte\");\n+            ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_CHAR, (char)0), \"NativeAllocator::allocate\/char\");\n+            ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_SHORT, (short)0), \"NativeAllocator::allocate\/short\");\n+            ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_INT, 0), \"NativeAllocator::allocate\/int\");\n+            ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_FLOAT, 0f), \"NativeAllocator::allocate\/float\");\n+            ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_LONG, 0L), \"NativeAllocator::allocate\/long\");\n+            ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_DOUBLE, 0d), \"NativeAllocator::allocate\/double\");\n+            ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_BYTE, 1L), \"NativeAllocator::allocateArray\/size\");\n+            ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_BYTE, new byte[] { 0 }), \"NativeAllocator::allocateArray\/byte\");\n+            ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_CHAR, new char[] { 0 }), \"NativeAllocator::allocateArray\/char\");\n+            ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_SHORT, new short[] { 0 }), \"NativeAllocator::allocateArray\/short\");\n+            ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_INT, new int[] { 0 }), \"NativeAllocator::allocateArray\/int\");\n+            ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_FLOAT, new float[] { 0 }), \"NativeAllocator::allocateArray\/float\");\n+            ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_LONG, new long[] { 0 }), \"NativeAllocator::allocateArray\/long\");\n+            ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_DOUBLE, new double[] { 0 }), \"NativeAllocator::allocateArray\/double\");\n+    };\n+\n+    @DataProvider(name = \"scopedOperations\")\n+    static Object[][] scopedOperations() {\n+        return scopedOperations.stream().map(op -> new Object[] { op.name, op }).toArray(Object[][]::new);\n+    }\n+\n+    static class ScopedOperation implements Consumer<ResourceScope> {\n+\n+        final Consumer<ResourceScope> scopeConsumer;\n+        final String name;\n+\n+        private ScopedOperation(Consumer<ResourceScope> scopeConsumer, String name) {\n+            this.scopeConsumer = scopeConsumer;\n+            this.name = name;\n+        }\n+\n+        @Override\n+        public void accept(ResourceScope scope) {\n+            scopeConsumer.accept(scope);\n+        }\n+\n+        static void ofScope(Consumer<ResourceScope> scopeConsumer, String name) {\n+            scopedOperations.add(new ScopedOperation(scopeConsumer::accept, name));\n+        }\n+\n+        static void ofVaList(Consumer<CLinker.VaList> vaListConsumer, String name) {\n+            scopedOperations.add(new ScopedOperation(scope -> {\n+                CLinker.VaList vaList = CLinker.VaList.make((builder) -> {}, scope);\n+                vaListConsumer.accept(vaList);\n+            }, name));\n+        }\n+\n+        static void ofSegment(Consumer<MemorySegment> segmentConsumer, String name) {\n+            for (SegmentFactory segmentFactory : SegmentFactory.values()) {\n+                scopedOperations.add(new ScopedOperation(scope -> {\n+                    MemorySegment segment = segmentFactory.segmentFactory.apply(scope);\n+                    segmentConsumer.accept(segment);\n+                }, segmentFactory.name() + \"\/\" + name));\n+            }\n+        }\n+\n+        static void ofAllocator(Consumer<SegmentAllocator> allocatorConsumer, String name) {\n+            for (AllocatorFactory allocatorFactory : AllocatorFactory.values()) {\n+                scopedOperations.add(new ScopedOperation(scope -> {\n+                    SegmentAllocator allocator = allocatorFactory.allocatorFactory.apply(scope);\n+                    allocatorConsumer.accept(allocator);\n+                }, allocatorFactory.name() + \"\/\" + name));\n+            }\n+        }\n+\n+        enum SegmentFactory {\n+\n+            NATIVE(scope -> MemorySegment.allocateNative(10, scope)),\n+            MAPPED(scope -> {\n+                try {\n+                    return MemorySegment.mapFile(Path.of(\"foo.txt\"), 0, 10, FileChannel.MapMode.READ_WRITE, scope);\n+                } catch (IOException ex) {\n+                    throw new AssertionError(ex);\n+                }\n+            }),\n+            UNSAFE(scope -> MemoryAddress.NULL.asSegmentRestricted(10, scope));\n+\n+            static {\n+                try {\n+                    File f = new File(\"foo.txt\");\n+                    f.createNewFile();\n+                    f.deleteOnExit();\n+                } catch (IOException ex) {\n+                    throw new ExceptionInInitializerError(ex);\n+                }\n+            }\n+\n+            final Function<ResourceScope, MemorySegment> segmentFactory;\n+\n+            SegmentFactory(Function<ResourceScope, MemorySegment> segmentFactory) {\n+                this.segmentFactory = segmentFactory;\n+            }\n+        }\n+\n+        enum AllocatorFactory {\n+            MALLOC(scope -> SegmentAllocator.malloc(() -> scope)),\n+            ARENA_BOUNDED(scope -> SegmentAllocator.arenaBounded(1000, scope)),\n+            ARENA_UNBOUNDED(SegmentAllocator::arenaUnbounded),\n+            FROM_SEGMENT(scope -> {\n+                MemorySegment segment = MemorySegment.allocateNative(10, scope);\n+                return SegmentAllocator.of(segment);\n+            }),\n+            FROM_SCOPED(SegmentAllocator::of);\n+\n+            final Function<ResourceScope, SegmentAllocator> allocatorFactory;\n+\n+            AllocatorFactory(Function<ResourceScope, SegmentAllocator> allocatorFactory) {\n+                this.allocatorFactory = allocatorFactory;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -0,0 +1,486 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm TestSegmentAllocators\n+ *\/\n+\n+import jdk.incubator.foreign.*;\n+\n+import org.testng.annotations.*;\n+\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.DoubleBuffer;\n+import java.nio.FloatBuffer;\n+import java.nio.IntBuffer;\n+import java.nio.LongBuffer;\n+import java.nio.ShortBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+\n+import static org.testng.Assert.*;\n+\n+public class TestSegmentAllocators {\n+\n+    final static int ELEMS = 128;\n+    final static Class<?> ADDRESS_CARRIER = MemoryLayouts.ADDRESS.bitSize() == 64 ? long.class : int.class;\n+\n+    @Test(dataProvider = \"nativeScopes\")\n+    public <Z> void testAllocation(Z value, AllocationFactory allocationFactory, ValueLayout layout, AllocationFunction<Z> allocationFunction, Function<MemoryLayout, VarHandle> handleFactory) {\n+        ValueLayout[] layouts = {\n+                layout,\n+                layout.withBitAlignment(layout.bitAlignment() * 2),\n+                layout.withBitAlignment(layout.bitAlignment() * 4),\n+                layout.withBitAlignment(layout.bitAlignment() * 8)\n+        };\n+        for (ValueLayout alignedLayout : layouts) {\n+            List<MemorySegment> addressList = new ArrayList<>();\n+            int elems = ELEMS \/ ((int)alignedLayout.byteAlignment() \/ (int)layout.byteAlignment());\n+            ResourceScope[] scopes = {\n+                    ResourceScope.ofConfined(),\n+                    ResourceScope.ofShared()\n+            };\n+            for (ResourceScope scope : scopes) {\n+                try (scope) {\n+                    SegmentAllocator allocator = allocationFactory.allocator(alignedLayout.byteSize() * ELEMS, scope);\n+                    for (int i = 0; i < elems; i++) {\n+                        MemorySegment address = allocationFunction.allocate(allocator, alignedLayout, value);\n+                        assertEquals(address.byteSize(), alignedLayout.byteSize());\n+                        addressList.add(address);\n+                        VarHandle handle = handleFactory.apply(alignedLayout);\n+                        assertEquals(value, handle.get(address));\n+                    }\n+                    boolean isBound = allocationFactory.isBound();\n+                    try {\n+                        allocationFunction.allocate(allocator, alignedLayout, value); \/\/too much, should fail if bound\n+                        assertFalse(isBound);\n+                    } catch (OutOfMemoryError ex) {\n+                        \/\/failure is expected if bound\n+                        assertTrue(isBound);\n+                    }\n+                }\n+                \/\/ addresses should be invalid now\n+                for (MemorySegment address : addressList) {\n+                    assertFalse(address.scope().isAlive());\n+                }\n+            }\n+        }\n+    }\n+\n+    static final int SIZE_256M = 1024 * 1024 * 256;\n+\n+    @Test\n+    public void testBigAllocationInUnboundedScope() {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            SegmentAllocator allocator = SegmentAllocator.arenaUnbounded(scope);\n+            for (int i = 8 ; i < SIZE_256M ; i *= 8) {\n+                MemorySegment address = allocator.allocate(i, i);\n+                \/\/check size\n+                assertEquals(address.byteSize(), i);\n+                \/\/check alignment\n+                assertEquals(address.address().toRawLongValue() % i, 0);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"arrayScopes\")\n+    public <Z> void testArray(AllocationFactory allocationFactory, ValueLayout layout, AllocationFunction<Object> allocationFunction, ToArrayHelper<Z> arrayHelper) {\n+        Z arr = arrayHelper.array();\n+        ResourceScope[] scopes = {\n+                ResourceScope.ofConfined(),\n+                ResourceScope.ofShared()\n+        };\n+        for (ResourceScope scope : scopes) {\n+            try (scope) {\n+                SegmentAllocator allocator = allocationFactory.allocator(100, scope);\n+                MemorySegment address = allocationFunction.allocate(allocator, layout, arr);\n+                Z found = arrayHelper.toArray(address, layout);\n+                assertEquals(found, arr);\n+            }\n+        }\n+    }\n+\n+    @DataProvider(name = \"nativeScopes\")\n+    static Object[][] nativeScopes() {\n+        return new Object[][] {\n+                { (byte)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_8_BE,\n+                        (AllocationFunction<Byte>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n+                { (short)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_BE,\n+                        (AllocationFunction<Short>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n+                { (char)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_BE,\n+                        (AllocationFunction<Character>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n+                { 42, AllocationFactory.BOUNDED,\n+                        MemoryLayouts.BITS_32_BE,\n+                        (AllocationFunction<Integer>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n+                { 42f, AllocationFactory.BOUNDED, MemoryLayouts.BITS_32_BE,\n+                        (AllocationFunction<Float>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n+                { 42L, AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_BE,\n+                        (AllocationFunction<Long>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n+                { 42d, AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_BE,\n+                        (AllocationFunction<Double>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n+                { MemoryAddress.ofLong(42), AllocationFactory.BOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction<MemoryAddress>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n+\n+                { (byte)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_8_LE,\n+                        (AllocationFunction<Byte>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n+                { (short)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_LE,\n+                        (AllocationFunction<Short>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n+                { (char)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_LE,\n+                        (AllocationFunction<Character>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n+                { 42, AllocationFactory.BOUNDED,\n+                        MemoryLayouts.BITS_32_LE,\n+                        (AllocationFunction<Integer>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n+                { 42f, AllocationFactory.BOUNDED, MemoryLayouts.BITS_32_LE,\n+                        (AllocationFunction<Float>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n+                { 42L, AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_LE,\n+                        (AllocationFunction<Long>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n+                { 42d, AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_LE,\n+                        (AllocationFunction<Double>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n+                { MemoryAddress.ofLong(42), AllocationFactory.BOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction<MemoryAddress>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n+\n+                { (byte)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_8_BE,\n+                        (AllocationFunction<Byte>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n+                { (short)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_BE,\n+                        (AllocationFunction<Short>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n+                { (char)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_BE,\n+                        (AllocationFunction<Character>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n+                { 42, AllocationFactory.UNBOUNDED,\n+                        MemoryLayouts.BITS_32_BE,\n+                        (AllocationFunction<Integer>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n+                { 42f, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_32_BE,\n+                        (AllocationFunction<Float>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n+                { 42L, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_BE,\n+                        (AllocationFunction<Long>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n+                { 42d, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_BE,\n+                        (AllocationFunction<Double>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n+                { MemoryAddress.ofLong(42), AllocationFactory.UNBOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction<MemoryAddress>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n+\n+                { (byte)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_8_LE,\n+                        (AllocationFunction<Byte>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n+                { (short)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_LE,\n+                        (AllocationFunction<Short>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n+                { (char)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_LE,\n+                        (AllocationFunction<Character>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n+                { 42, AllocationFactory.UNBOUNDED,\n+                        MemoryLayouts.BITS_32_LE,\n+                        (AllocationFunction<Integer>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n+                { 42f, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_32_LE,\n+                        (AllocationFunction<Float>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n+                { 42L, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_LE,\n+                        (AllocationFunction<Long>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n+                { 42d, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_LE,\n+                        (AllocationFunction<Double>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n+                { MemoryAddress.ofLong(42), AllocationFactory.UNBOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction<MemoryAddress>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n+        };\n+    }\n+\n+    @DataProvider(name = \"arrayScopes\")\n+    static Object[][] arrayScopes() {\n+        return new Object[][] {\n+                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_8_LE,\n+                        (AllocationFunction<byte[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toByteArray },\n+                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_LE,\n+                        (AllocationFunction<short[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toShortArray },\n+                { AllocationFactory.BOUNDED,\n+                        MemoryLayouts.BITS_32_LE,\n+                        (AllocationFunction<int[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toIntArray },\n+                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_32_LE,\n+                        (AllocationFunction<float[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toFloatArray },\n+                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_LE,\n+                        (AllocationFunction<long[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toLongArray },\n+                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_LE,\n+                        (AllocationFunction<double[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toDoubleArray },\n+                { AllocationFactory.BOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction<MemoryAddress[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toAddressArray },\n+\n+\n+                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_8_BE,\n+                        (AllocationFunction<byte[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toByteArray },\n+                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_BE,\n+                        (AllocationFunction<short[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toShortArray },\n+                { AllocationFactory.BOUNDED,\n+                        MemoryLayouts.BITS_32_BE,\n+                        (AllocationFunction<int[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toIntArray },\n+                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_32_BE,\n+                        (AllocationFunction<float[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toFloatArray },\n+                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_BE,\n+                        (AllocationFunction<long[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toLongArray },\n+                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_BE,\n+                        (AllocationFunction<double[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toDoubleArray },\n+                { AllocationFactory.BOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction<MemoryAddress[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toAddressArray },\n+\n+                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_8_LE,\n+                        (AllocationFunction<byte[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toByteArray },\n+                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_LE,\n+                        (AllocationFunction<short[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toShortArray },\n+                { AllocationFactory.UNBOUNDED,\n+                        MemoryLayouts.BITS_32_LE,\n+                        (AllocationFunction<int[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toIntArray },\n+                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_32_LE,\n+                        (AllocationFunction<float[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toFloatArray },\n+                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_LE,\n+                        (AllocationFunction<long[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toLongArray },\n+                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_LE,\n+                        (AllocationFunction<double[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toDoubleArray },\n+                { AllocationFactory.UNBOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction<MemoryAddress[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toAddressArray },\n+\n+\n+                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_8_BE,\n+                        (AllocationFunction<byte[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toByteArray },\n+                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_BE,\n+                        (AllocationFunction<short[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toShortArray },\n+                { AllocationFactory.UNBOUNDED,\n+                        MemoryLayouts.BITS_32_BE,\n+                        (AllocationFunction<int[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toIntArray },\n+                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_32_BE,\n+                        (AllocationFunction<float[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toFloatArray },\n+                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_BE,\n+                        (AllocationFunction<long[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toLongArray },\n+                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_BE,\n+                        (AllocationFunction<double[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toDoubleArray },\n+                { AllocationFactory.UNBOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction<MemoryAddress[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toAddressArray },\n+        };\n+    }\n+\n+    interface AllocationFunction<X> {\n+        MemorySegment allocate(SegmentAllocator scope, ValueLayout layout, X value);\n+    }\n+\n+    static class AllocationFactory {\n+        private final boolean isBound;\n+        private final BiFunction<Long, ResourceScope, SegmentAllocator> factory;\n+\n+        private AllocationFactory(boolean isBound, BiFunction<Long, ResourceScope, SegmentAllocator> factory) {\n+            this.isBound = isBound;\n+            this.factory = factory;\n+        }\n+\n+        SegmentAllocator allocator(long size, ResourceScope scope) {\n+            return factory.apply(size, scope);\n+        }\n+\n+        public boolean isBound() {\n+            return isBound;\n+        }\n+\n+        static AllocationFactory BOUNDED = new AllocationFactory(true, SegmentAllocator::arenaBounded);\n+        static AllocationFactory UNBOUNDED = new AllocationFactory(false, (size, scope) -> SegmentAllocator.arenaUnbounded(scope));\n+    }\n+\n+    interface ToArrayHelper<T> {\n+        T array();\n+        T toArray(MemorySegment segment, ValueLayout layout);\n+\n+        ToArrayHelper<byte[]> toByteArray = new ToArrayHelper<>() {\n+            @Override\n+            public byte[] array() {\n+                return new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+            }\n+\n+            @Override\n+            public byte[] toArray(MemorySegment segment, ValueLayout layout) {\n+                ByteBuffer buffer = segment.asByteBuffer().order(layout.order());\n+                byte[] found = new byte[buffer.limit()];\n+                buffer.get(found);\n+                return found;\n+            }\n+        };\n+\n+        ToArrayHelper<short[]> toShortArray = new ToArrayHelper<>() {\n+            @Override\n+            public short[] array() {\n+                return new short[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+            }\n+\n+            @Override\n+            public short[] toArray(MemorySegment segment, ValueLayout layout) {\n+                ShortBuffer buffer = segment.asByteBuffer().order(layout.order()).asShortBuffer();\n+                short[] found = new short[buffer.limit()];\n+                buffer.get(found);\n+                return found;\n+            }\n+        };\n+\n+        ToArrayHelper<int[]> toIntArray = new ToArrayHelper<>() {\n+            @Override\n+            public int[] array() {\n+                return new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+            }\n+\n+            @Override\n+            public int[] toArray(MemorySegment segment, ValueLayout layout) {\n+                IntBuffer buffer = segment.asByteBuffer().order(layout.order()).asIntBuffer();\n+                int[] found = new int[buffer.limit()];\n+                buffer.get(found);\n+                return found;\n+            }\n+        };\n+\n+        ToArrayHelper<float[]> toFloatArray = new ToArrayHelper<>() {\n+            @Override\n+            public float[] array() {\n+                return new float[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+            }\n+\n+            @Override\n+            public float[] toArray(MemorySegment segment, ValueLayout layout) {\n+                FloatBuffer buffer = segment.asByteBuffer().order(layout.order()).asFloatBuffer();\n+                float[] found = new float[buffer.limit()];\n+                buffer.get(found);\n+                return found;\n+            }\n+        };\n+\n+        ToArrayHelper<long[]> toLongArray = new ToArrayHelper<>() {\n+            @Override\n+            public long[] array() {\n+                return new long[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+            }\n+\n+            @Override\n+            public long[] toArray(MemorySegment segment, ValueLayout layout) {\n+                LongBuffer buffer = segment.asByteBuffer().order(layout.order()).asLongBuffer();\n+                long[] found = new long[buffer.limit()];\n+                buffer.get(found);\n+                return found;\n+            }\n+        };\n+\n+        ToArrayHelper<double[]> toDoubleArray = new ToArrayHelper<>() {\n+            @Override\n+            public double[] array() {\n+                return new double[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+            }\n+\n+            @Override\n+            public double[] toArray(MemorySegment segment, ValueLayout layout) {\n+                DoubleBuffer buffer = segment.asByteBuffer().order(layout.order()).asDoubleBuffer();\n+                double[] found = new double[buffer.limit()];\n+                buffer.get(found);\n+                return found;\n+            }\n+        };\n+\n+        ToArrayHelper<MemoryAddress[]> toAddressArray = new ToArrayHelper<>() {\n+            @Override\n+            public MemoryAddress[] array() {\n+                return switch ((int)MemoryLayouts.ADDRESS.byteSize()) {\n+                    case 4 -> wrap(toIntArray.array());\n+                    case 8 -> wrap(toLongArray.array());\n+                    default -> throw new IllegalStateException(\"Cannot get here\");\n+                };\n+            }\n+\n+            @Override\n+            public MemoryAddress[] toArray(MemorySegment segment, ValueLayout layout) {\n+                return switch ((int)layout.byteSize()) {\n+                    case 4 -> wrap(toIntArray.toArray(segment, layout));\n+                    case 8 -> wrap(toLongArray.toArray(segment, layout));\n+                    default -> throw new IllegalStateException(\"Cannot get here\");\n+                };\n+            }\n+\n+            private MemoryAddress[] wrap(int[] ints) {\n+                return IntStream.of(ints).mapToObj(MemoryAddress::ofLong).toArray(MemoryAddress[]::new);\n+            }\n+\n+            private MemoryAddress[] wrap(long[] ints) {\n+                return LongStream.of(ints).mapToObj(MemoryAddress::ofLong).toArray(MemoryAddress[]::new);\n+            }\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":486,"deletions":0,"binary":false,"changes":486,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MappedMemorySegments;\n@@ -34,0 +33,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -37,2 +37,0 @@\n-import java.io.File;\n-import java.io.IOException;\n@@ -45,2 +43,0 @@\n-import java.nio.channels.FileChannel;\n-import java.nio.file.Path;\n@@ -51,1 +47,0 @@\n-import java.util.function.Function;\n@@ -77,34 +72,0 @@\n-    @Test(dataProvider = \"segmentOperations\")\n-    public void testOpOutsideConfinement(SegmentMember member) throws Throwable {\n-        try (MemorySegment segment = MemorySegment.allocateNative(4)) {\n-            AtomicBoolean failed = new AtomicBoolean(false);\n-            Thread t = new Thread(() -> {\n-                try {\n-                    Object o = member.method.invoke(segment, member.params);\n-                } catch (ReflectiveOperationException ex) {\n-                    throw new IllegalStateException(ex);\n-                }\n-            });\n-            t.setUncaughtExceptionHandler((thread, ex) -> failed.set(true));\n-            t.start();\n-            t.join();\n-            assertEquals(failed.get(), member.isConfined());\n-        }\n-    }\n-\n-    @Test(dataProvider = \"segmentOperations\")\n-    public void testOpAfterClose(SegmentMember member) throws Throwable {\n-        MemorySegment segment = MemorySegment.allocateNative(4);\n-        segment.close();\n-        try {\n-            Object o = member.method.invoke(segment, member.params);\n-            assertFalse(member.isConfined());\n-        } catch (InvocationTargetException ex) {\n-            assertTrue(member.isConfined());\n-            Throwable target = ex.getTargetException();\n-            assertTrue(target instanceof NullPointerException ||\n-                          target instanceof UnsupportedOperationException ||\n-                          target instanceof IllegalStateException);\n-        }\n-    }\n-\n@@ -113,3 +74,1 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(1024 * 1024 * 8 * 2)) { \/\/ 2M\n-            \/\/ do nothing\n-        }\n+        MemorySegment segment = MemorySegment.allocateNative(1024 * 1024 * 8 * 2); \/\/ 2M\n@@ -122,1 +81,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(1000)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(1000, 1, scope);\n@@ -133,1 +93,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(10)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(10, 1, scope);\n@@ -152,4 +113,3 @@\n-        try (MemorySegment segment = memorySegmentSupplier.get()) {\n-            assertTrue(segment.hasAccessModes(ALL_ACCESS));\n-            assertEquals(segment.accessModes(), ALL_ACCESS);\n-        }\n+        MemorySegment segment = memorySegmentSupplier.get();\n+        assertFalse(segment.isReadOnly());\n+        tryClose(segment);\n@@ -158,14 +118,5 @@\n-    @Test(dataProvider = \"accessModes\")\n-    public void testAccessModes(int accessModes) {\n-        int[] arr = new int[1];\n-        for (AccessActions action : AccessActions.values()) {\n-            MemorySegment segment = MemorySegment.ofArray(arr);\n-            MemorySegment restrictedSegment = segment.withAccessModes(accessModes);\n-            assertEquals(restrictedSegment.accessModes(), accessModes);\n-            boolean shouldFail = !restrictedSegment.hasAccessModes(action.accessMode);\n-            try {\n-                action.run(restrictedSegment);\n-                assertFalse(shouldFail);\n-            } catch (UnsupportedOperationException ex) {\n-                assertTrue(shouldFail);\n-            }\n+    static void tryClose(MemorySegment segment) {\n+        try {\n+            segment.scope().close();\n+        } catch (UnsupportedOperationException ex) {\n+            \/\/ whoops - scope is not closeable\n@@ -187,1 +138,5 @@\n-                () -> MemorySegment.allocateNative(MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder()))\n+                () -> MemorySegment.allocateNative(MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder())),\n+                () -> MemorySegment.allocateNative(4, ResourceScope.ofConfined()),\n+                () -> MemorySegment.allocateNative(4, 8, ResourceScope.ofConfined()),\n+                () -> MemorySegment.allocateNative(MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder()), ResourceScope.ofConfined())\n+\n@@ -198,5 +153,5 @@\n-            try (MemorySegment segment = memorySegmentSupplier.get()) {\n-                segment.fill(value);\n-                for (long l = 0; l < segment.byteSize(); l++) {\n-                    assertEquals((byte) byteHandle.get(segment, l), value);\n-                }\n+            MemorySegment segment = memorySegmentSupplier.get();\n+            segment.fill(value);\n+            for (long l = 0; l < segment.byteSize(); l++) {\n+                assertEquals((byte) byteHandle.get(segment, l), value);\n+            }\n@@ -204,11 +159,9 @@\n-                \/\/ fill a slice\n-                var sliceSegment = segment.asSlice(1, segment.byteSize() - 2).fill((byte) ~value);\n-                for (long l = 0; l < sliceSegment.byteSize(); l++) {\n-                    assertEquals((byte) byteHandle.get(sliceSegment, l), ~value);\n-                }\n-                \/\/ assert enclosing slice\n-                assertEquals((byte) byteHandle.get(segment, 0L), value);\n-                for (long l = 1; l < segment.byteSize() - 2; l++) {\n-                    assertEquals((byte) byteHandle.get(segment, l), (byte) ~value);\n-                }\n-                assertEquals((byte) byteHandle.get(segment, segment.byteSize() - 1L), value);\n+            \/\/ fill a slice\n+            var sliceSegment = segment.asSlice(1, segment.byteSize() - 2).fill((byte) ~value);\n+            for (long l = 0; l < sliceSegment.byteSize(); l++) {\n+                assertEquals((byte) byteHandle.get(sliceSegment, l), ~value);\n+            }\n+            \/\/ assert enclosing slice\n+            assertEquals((byte) byteHandle.get(segment, 0L), value);\n+            for (long l = 1; l < segment.byteSize() - 2; l++) {\n+                assertEquals((byte) byteHandle.get(segment, l), (byte) ~value);\n@@ -216,0 +169,2 @@\n+            assertEquals((byte) byteHandle.get(segment, segment.byteSize() - 1L), value);\n+            tryClose(segment);\n@@ -219,1 +174,1 @@\n-    @Test(dataProvider = \"segmentFactories\", expectedExceptions = IllegalStateException.class)\n+    @Test(dataProvider = \"segmentFactories\")\n@@ -222,2 +177,9 @@\n-        segment.close();\n-        segment.fill((byte) 0xFF);\n+        tryClose(segment);\n+        if (!segment.scope().isAlive()) {\n+            try {\n+                segment.fill((byte) 0xFF);\n+                fail();\n+            } catch (IllegalStateException ex) {\n+                assertTrue(true);\n+            }\n+        }\n@@ -228,3 +190,3 @@\n-        try (MemorySegment segment = memorySegmentSupplier.get()) {\n-            segment.withAccessModes(segment.accessModes() & ~WRITE).fill((byte) 0xFF);\n-        }\n+        MemorySegment segment = memorySegmentSupplier.get();\n+        segment.asReadOnly().fill((byte) 0xFF);\n+        tryClose(segment);\n@@ -235,12 +197,12 @@\n-        try (MemorySegment segment = memorySegmentSupplier.get()) {\n-            AtomicReference<RuntimeException> exception = new AtomicReference<>();\n-            Runnable action = () -> {\n-                try {\n-                    segment.fill((byte) 0xBA);\n-                } catch (RuntimeException e) {\n-                    exception.set(e);\n-                }\n-            };\n-            Thread thread = new Thread(action);\n-            thread.start();\n-            thread.join();\n+        MemorySegment segment = memorySegmentSupplier.get();\n+        AtomicReference<RuntimeException> exception = new AtomicReference<>();\n+        Runnable action = () -> {\n+            try {\n+                segment.fill((byte) 0xBA);\n+            } catch (RuntimeException e) {\n+                exception.set(e);\n+            }\n+        };\n+        Thread thread = new Thread(action);\n+        thread.start();\n+        thread.join();\n@@ -248,0 +210,1 @@\n+        if (segment.scope().ownerThread() != null) {\n@@ -252,0 +215,2 @@\n+        } else {\n+            assertNull(exception.get());\n@@ -253,0 +218,1 @@\n+        tryClose(segment);\n@@ -262,21 +228,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testWithAccessModesBadUnsupportedMode() {\n-        int[] arr = new int[1];\n-        MemorySegment segment = MemorySegment.ofArray(arr);\n-        segment.withAccessModes((1 << AccessActions.values().length) + 1);\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadWithAccessModesBadStrongerMode() {\n-        int[] arr = new int[1];\n-        MemorySegment segment = MemorySegment.ofArray(arr).withAccessModes(READ);\n-        segment.withAccessModes(WRITE);\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadHasAccessModes() {\n-        int[] arr = new int[1];\n-        MemorySegment segment = MemorySegment.ofArray(arr);\n-        segment.hasAccessModes((1 << AccessActions.values().length) + 1);\n-    }\n-\n@@ -326,133 +271,0 @@\n-    @DataProvider(name = \"segmentOperations\")\n-    static Object[][] segmentMembers() {\n-        List<SegmentMember> members = new ArrayList<>();\n-        for (Method m : MemorySegment.class.getDeclaredMethods()) {\n-            \/\/skip defaults, statics and method declared in j.l.Object\n-            if (m.isDefault() ||\n-                    m.getDeclaringClass().equals(Object.class) ||\n-                    (m.getModifiers() & Modifier.STATIC) != 0) continue;\n-            Object[] args = Stream.of(m.getParameterTypes())\n-                    .map(TestSegments::defaultValue)\n-                    .toArray();\n-            members.add(new SegmentMember(m, args));\n-        }\n-        return members.stream().map(ms -> new Object[] { ms }).toArray(Object[][]::new);\n-    }\n-\n-    static class SegmentMember {\n-        final Method method;\n-        final Object[] params;\n-\n-        final static List<String> CONFINED_NAMES = List.of(\n-                \"address\",\n-                \"close\",\n-                \"share\",\n-                \"handoff\",\n-                \"registerCleaner\",\n-                \"fill\",\n-                \"spliterator\",\n-                \"copyFrom\",\n-                \"mismatch\",\n-                \"toByteArray\",\n-                \"toCharArray\",\n-                \"toShortArray\",\n-                \"toIntArray\",\n-                \"toFloatArray\",\n-                \"toLongArray\",\n-                \"toDoubleArray\"\n-        );\n-\n-        public SegmentMember(Method method, Object[] params) {\n-            this.method = method;\n-            this.params = params;\n-        }\n-\n-        boolean isConfined() {\n-            return CONFINED_NAMES.contains(method.getName());\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return method.getName();\n-        }\n-    }\n-\n-    static Object defaultValue(Class<?> c) {\n-        if (c.isPrimitive()) {\n-            if (c == char.class) {\n-                return (char)0;\n-            } else if (c == boolean.class) {\n-                return false;\n-            } else if (c == byte.class) {\n-                return (byte)0;\n-            } else if (c == short.class) {\n-                return (short)0;\n-            } else if (c == int.class) {\n-                return 0;\n-            } else if (c == long.class) {\n-                return 0L;\n-            } else if (c == float.class) {\n-                return 0f;\n-            } else if (c == double.class) {\n-                return 0d;\n-            } else {\n-                throw new IllegalStateException();\n-            }\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    @DataProvider(name = \"accessModes\")\n-    public Object[][] accessModes() {\n-        int nActions = AccessActions.values().length;\n-        Object[][] results = new Object[1 << nActions][];\n-        for (int accessModes = 0 ; accessModes < results.length ; accessModes++) {\n-            results[accessModes] = new Object[] { accessModes };\n-        }\n-        return results;\n-    }\n-\n-    enum AccessActions {\n-        SHARE(MemorySegment.SHARE) {\n-            @Override\n-            void run(MemorySegment segment) {\n-                segment.share();\n-            }\n-        },\n-        CLOSE(MemorySegment.CLOSE) {\n-            @Override\n-            void run(MemorySegment segment) {\n-                segment.close();\n-            }\n-        },\n-        READ(MemorySegment.READ) {\n-            @Override\n-            void run(MemorySegment segment) {\n-                INT_HANDLE.get(segment);\n-            }\n-        },\n-        WRITE(MemorySegment.WRITE) {\n-            @Override\n-            void run(MemorySegment segment) {\n-                INT_HANDLE.set(segment, 42);\n-            }\n-        },\n-        HANDOFF(MemorySegment.HANDOFF) {\n-            @Override\n-            void run(MemorySegment segment) {\n-                segment.handoff(new Thread());\n-            }\n-        };\n-\n-        final int accessMode;\n-\n-        static VarHandle INT_HANDLE = MemoryLayouts.JAVA_INT.varHandle(int.class);\n-\n-        AccessActions(int accessMode) {\n-            this.accessMode = accessMode;\n-        }\n-\n-        abstract void run(MemorySegment segment);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":64,"deletions":252,"binary":false,"changes":316,"status":"modified"},{"patch":"@@ -49,26 +49,0 @@\n-    @Test\n-    public void testConfined() throws Throwable {\n-        Thread owner = Thread.currentThread();\n-        MemorySegment s = MemorySegment.allocateNative(4);\n-        AtomicReference<MemorySegment> confined = new AtomicReference<>(s);\n-        setInt(s, 42);\n-        assertEquals(getInt(s), 42);\n-        List<Thread> threads = new ArrayList<>();\n-        for (int i = 0 ; i < 1000 ; i++) {\n-            threads.add(new Thread(() -> {\n-                assertEquals(getInt(confined.get()), 42);\n-                confined.set(confined.get().handoff(owner));\n-            }));\n-        }\n-        threads.forEach(t -> {\n-            confined.set(confined.get().handoff(t));\n-            t.start();\n-            try {\n-                t.join();\n-            } catch (Throwable e) {\n-                throw new IllegalStateException(e);\n-            }\n-        });\n-        confined.get().close();\n-    }\n-\n@@ -78,1 +52,2 @@\n-        try (MemorySegment s = MemorySegment.allocateNative(layout).share()) {\n+        try (ResourceScope scope = ResourceScope.ofShared()) {\n+            MemorySegment s = MemorySegment.allocateNative(layout, scope);\n@@ -122,1 +97,2 @@\n-        try (MemorySegment s = MemorySegment.allocateNative(4)) {\n+        try (ResourceScope scope = ResourceScope.ofShared()) {\n+            MemorySegment s = MemorySegment.allocateNative(4, 1, scope);\n@@ -126,1 +102,1 @@\n-            MemorySegment sharedSegment = s.address().asSegmentRestricted(s.byteSize()).share();\n+            MemorySegment sharedSegment = s.address().asSegmentRestricted(s.byteSize(), scope);\n@@ -143,28 +119,0 @@\n-    @Test\n-    public void testHandoffToSelf() {\n-        MemorySegment s1 = MemorySegment.ofArray(new int[4]);\n-        MemorySegment s2 = s1.handoff(Thread.currentThread());\n-        assertFalse(s1.isAlive());\n-        assertTrue(s2.isAlive());\n-    }\n-\n-    @Test\n-    public void testShareTwice() {\n-        MemorySegment s1 = MemorySegment.ofArray(new int[4]).share();\n-        MemorySegment s2 = s1.share();\n-        assertFalse(s1.isAlive());\n-        assertTrue(s2.isAlive());\n-    }\n-\n-    @Test(expectedExceptions=UnsupportedOperationException.class)\n-    public void testBadHandoffNoAccess() {\n-        MemorySegment.ofArray(new int[4])\n-            .withAccessModes(MemorySegment.CLOSE).handoff(new Thread());\n-    }\n-\n-    @Test(expectedExceptions=UnsupportedOperationException.class)\n-    public void testBadShareNoAccess() {\n-        MemorySegment.ofArray(new int[4])\n-                .withAccessModes(MemorySegment.CLOSE).share();\n-    }\n-\n@@ -176,1 +124,2 @@\n-        try (MemorySegment s1 = MemorySegment.allocateNative(MemoryLayout.ofSequence(2, MemoryLayouts.JAVA_INT))) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment s1 = MemorySegment.allocateNative(MemoryLayout.ofSequence(2, MemoryLayouts.JAVA_INT), scope);\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":7,"deletions":58,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -49,1 +50,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(LAYOUT)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(LAYOUT, scope);\n","filename":"test\/jdk\/java\/foreign\/TestSlices.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -63,3 +64,19 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout).share();\n-        for (int i = 0; i < layout.elementCount().getAsLong(); i++) {\n-            INT_HANDLE.set(segment, (long) i, i);\n+        try (ResourceScope scope = ResourceScope.ofShared()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n+            for (int i = 0; i < layout.elementCount().getAsLong(); i++) {\n+                INT_HANDLE.set(segment, (long) i, i);\n+            }\n+            long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();\n+            \/\/serial\n+            long serial = sum(0, segment);\n+            assertEquals(serial, expected);\n+            \/\/parallel counted completer\n+            long parallelCounted = new SumSegmentCounted(null, segment.spliterator(layout), threshold).invoke();\n+            assertEquals(parallelCounted, expected);\n+            \/\/parallel recursive action\n+            long parallelRecursive = new SumSegmentRecursive(segment.spliterator(layout), threshold).invoke();\n+            assertEquals(parallelRecursive, expected);\n+            \/\/parallel stream\n+            long streamParallel = StreamSupport.stream(segment.spliterator(layout), true)\n+                    .reduce(0L, TestSpliterator::sumSingle, Long::sum);\n+            assertEquals(streamParallel, expected);\n@@ -67,15 +84,0 @@\n-        long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();\n-        \/\/serial\n-        long serial = sum(0, segment);\n-        assertEquals(serial, expected);\n-        \/\/parallel counted completer\n-        long parallelCounted = new SumSegmentCounted(null, segment.spliterator(layout), threshold).invoke();\n-        assertEquals(parallelCounted, expected);\n-        \/\/parallel recursive action\n-        long parallelRecursive = new SumSegmentRecursive(segment.spliterator(layout), threshold).invoke();\n-        assertEquals(parallelRecursive, expected);\n-        \/\/parallel stream\n-        long streamParallel = StreamSupport.stream(segment.spliterator(layout), true)\n-                .reduce(0L, TestSpliterator::sumSingle, Long::sum);\n-        assertEquals(streamParallel, expected);\n-        segment.close();\n@@ -84,0 +86,1 @@\n+    @Test\n@@ -96,1 +99,1 @@\n-        segment.withAccessModes(MemorySegment.READ).spliterator(layout)\n+        segment.spliterator(layout)\n@@ -205,48 +208,0 @@\n-\n-    @DataProvider(name = \"accessScenarios\")\n-    public Object[][] accessScenarios() {\n-        SequenceLayout layout = MemoryLayout.ofSequence(16, MemoryLayouts.JAVA_INT);\n-        var mallocSegment = MemorySegment.allocateNative(layout);\n-\n-        Map<Supplier<Spliterator<MemorySegment>>,Integer> l = Map.of(\n-            () -> mallocSegment.withAccessModes(ALL_ACCESS).spliterator(layout), ALL_ACCESS,\n-            () -> mallocSegment.withAccessModes(0).spliterator(layout), 0,\n-            () -> mallocSegment.withAccessModes(READ).spliterator(layout), READ,\n-            () -> mallocSegment.withAccessModes(CLOSE).spliterator(layout), 0,\n-            () -> mallocSegment.withAccessModes(READ|WRITE).spliterator(layout), READ|WRITE,\n-            () -> mallocSegment.withAccessModes(READ|WRITE| SHARE).spliterator(layout), READ|WRITE| SHARE,\n-            () -> mallocSegment.withAccessModes(READ|WRITE| SHARE |HANDOFF).spliterator(layout), READ|WRITE| SHARE |HANDOFF\n-\n-        );\n-        return l.entrySet().stream().map(e -> new Object[] { e.getKey(), e.getValue() }).toArray(Object[][]::new);\n-    }\n-\n-    static Consumer<MemorySegment> assertAccessModes(int accessModes) {\n-        return segment -> {\n-            assertTrue(segment.hasAccessModes(accessModes & ~CLOSE));\n-            assertEquals(segment.accessModes(), accessModes & ~CLOSE);\n-        };\n-    }\n-\n-    @Test(dataProvider = \"accessScenarios\")\n-    public void testAccessModes(Supplier<Spliterator<MemorySegment>> spliteratorSupplier,\n-                                int expectedAccessModes) {\n-        Spliterator<MemorySegment> spliterator = spliteratorSupplier.get();\n-        spliterator.forEachRemaining(assertAccessModes(expectedAccessModes));\n-\n-        spliterator = spliteratorSupplier.get();\n-        do { } while (spliterator.tryAdvance(assertAccessModes(expectedAccessModes)));\n-\n-        splitOrConsume(spliteratorSupplier.get(), assertAccessModes(expectedAccessModes));\n-    }\n-\n-    static void splitOrConsume(Spliterator<MemorySegment> spliterator,\n-                               Consumer<MemorySegment> consumer) {\n-        var s1 = spliterator.trySplit();\n-        if (s1 != null) {\n-            splitOrConsume(s1, consumer);\n-            splitOrConsume(spliterator, consumer);\n-        } else {\n-            spliterator.forEachRemaining(consumer);\n-        }\n-    }\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":22,"deletions":67,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -48,1 +49,2 @@\n-        try (MemorySegment s = MemorySegment.allocateNative(8)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, scope);\n@@ -55,1 +57,2 @@\n-        try (MemorySegment s = MemorySegment.allocateNative(8)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, scope);\n@@ -62,1 +65,2 @@\n-        try (MemorySegment s = MemorySegment.allocateNative(8)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, scope);\n@@ -69,1 +73,2 @@\n-        try (MemorySegment s = MemorySegment.allocateNative(8)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, scope);\n@@ -76,1 +81,2 @@\n-        try (MemorySegment s = MemorySegment.allocateNative(8)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, scope);\n@@ -83,1 +89,2 @@\n-        try (MemorySegment s = MemorySegment.allocateNative(8)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, scope);\n","filename":"test\/jdk\/java\/foreign\/TestTypeAccess.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -33,3 +33,0 @@\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.NativeScope;\n-import org.testng.annotations.DataProvider;\n@@ -38,6 +35,0 @@\n-import java.lang.reflect.Field;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import static jdk.incubator.foreign.MemoryAddress.NULL;\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_BYTE;\n","filename":"test\/jdk\/java\/foreign\/TestUnsupportedPlatform.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -42,2 +42,1 @@\n-import jdk.incubator.foreign.ValueLayout;\n-import org.testng.annotations.AfterClass;\n+\n@@ -73,1 +72,1 @@\n-                    MethodType.methodType(Object.class, Object[].class, AtomicReference.class, List.class));\n+                    MethodType.methodType(Object.class, Object[].class, AtomicReference.class));\n@@ -86,5 +85,0 @@\n-    @AfterClass\n-    void teardown() {\n-        dummyStub.close();\n-    }\n-\n@@ -93,1 +87,0 @@\n-        List<MemorySegment> segments = new ArrayList<>();\n@@ -97,7 +90,10 @@\n-        MethodHandle mh = abi.downcallHandle(addr, methodType(ret, paramTypes, fields), function(ret, paramTypes, fields));\n-        Object[] args = makeArgs(ret, paramTypes, fields, returnChecks, argChecks, segments);\n-        mh = mh.asSpreader(Object[].class, paramTypes.size() + 1);\n-        Object res = mh.invoke(args);\n-        argChecks.forEach(c -> c.accept(args));\n-        if (ret == Ret.NON_VOID) {\n-            returnChecks.forEach(c -> c.accept(res));\n+        MethodType mtype = methodType(ret, paramTypes, fields);\n+        try (NativeScope scope = new NativeScope()) {\n+            MethodHandle mh = abi.downcallHandle(addr, scope, mtype, function(ret, paramTypes, fields));\n+            Object[] args = makeArgs(scope, ret, paramTypes, fields, returnChecks, argChecks);\n+            Object[] callArgs = args;\n+            Object res = mh.invokeWithArguments(callArgs);\n+            argChecks.forEach(c -> c.accept(args));\n+            if (ret == Ret.NON_VOID) {\n+                returnChecks.forEach(c -> c.accept(res));\n+            }\n@@ -105,1 +101,0 @@\n-        segments.forEach(MemorySegment::close);\n@@ -127,1 +122,1 @@\n-    static Object[] makeArgs(Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemorySegment> segments) throws ReflectiveOperationException {\n+    static Object[] makeArgs(NativeScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n@@ -130,1 +125,1 @@\n-            args[i] = makeArg(params.get(i).layout(fields), checks, i == 0, segments);\n+            args[i] = makeArg(params.get(i).layout(fields), checks, i == 0);\n@@ -132,1 +127,1 @@\n-        args[params.size()] = makeCallback(ret, params, fields, checks, argChecks, segments);\n+        args[params.size()] = makeCallback(scope, ret, params, fields, checks, argChecks);\n@@ -137,1 +132,1 @@\n-    static MemoryAddress makeCallback(Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemorySegment> segments) {\n+    static MemoryAddress makeCallback(NativeScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) {\n@@ -143,1 +138,1 @@\n-        MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box, segments);\n+        MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box);\n@@ -176,2 +171,1 @@\n-        MemorySegment stub = abi.upcallStub(mh, func);\n-        segments.add(stub);\n+        MemorySegment stub = abi.upcallStub(mh, func, scope.scope());\n@@ -181,1 +175,1 @@\n-    static Object passAndSave(Object[] o, AtomicReference<Object[]> ref, List<MemorySegment> copies) {\n+    static Object passAndSave(Object[] o, AtomicReference<Object[]> ref) {\n@@ -188,1 +182,0 @@\n-                copies.add(copy);\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":19,"deletions":26,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -51,1 +52,0 @@\n-import java.util.function.Consumer;\n@@ -85,1 +85,1 @@\n-                    MethodType.methodType(void.class, Object[].class, AtomicReference.class, List.class));\n+                    MethodType.methodType(void.class, Object[].class, AtomicReference.class));\n@@ -91,1 +91,1 @@\n-    static void passAndSave(Object[] o, AtomicReference<Object[]> ref, List<MemorySegment> copies) {\n+    static void passAndSave(Object[] o, AtomicReference<Object[]> ref) {\n@@ -98,1 +98,0 @@\n-                copies.add(copy);\n@@ -107,1 +106,0 @@\n-        List<MemorySegment> segments = new ArrayList<>();\n@@ -109,1 +107,1 @@\n-        MethodHandle target = MethodHandles.insertArguments(MH_passAndSave, 1, capturedArgs, segments)\n+        MethodHandle target = MethodHandles.insertArguments(MH_passAndSave, 1, capturedArgs)\n@@ -112,1 +110,2 @@\n-        try (MemorySegment upcallStub = LINKER.upcallStub(target, upcallDescriptor)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDescriptor, scope);\n@@ -117,1 +116,1 @@\n-                args[i] = makeArg(argLayouts.get(i - 1), null, false, segments);\n+                args[i] = makeArg(argLayouts.get(i - 1), null, false);\n@@ -130,1 +129,0 @@\n-            segments.forEach(MemorySegment::close);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -95,3 +96,3 @@\n-        try (MemorySegment upcallStub = LINKER.upcallStub(target, upcallDesc);\n-             MemorySegment argSegment = MemorySegment.allocateNative(S_PDI_LAYOUT)) {\n-\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDesc, scope);\n+            MemorySegment argSegment = MemorySegment.allocateNative(S_PDI_LAYOUT, scope);\n@@ -102,1 +103,1 @@\n-        assertFalse(captured.isAlive());\n+        assertFalse(captured.scope().isAlive());\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -41,0 +42,1 @@\n+import java.lang.ref.Cleaner;\n@@ -60,1 +62,1 @@\n-        return abi.upcallStub(MH_dummy, FunctionDescriptor.ofVoid());\n+        return abi.upcallStub(MH_dummy, FunctionDescriptor.ofVoid(), ResourceScope.ofConfined());\n@@ -63,1 +65,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test(expectedExceptions = IndexOutOfBoundsException.class)\n@@ -65,4 +67,4 @@\n-        try (MemorySegment stub = getStub()) {\n-            VarHandle vh = JAVA_INT.varHandle(int.class);\n-            vh.set(stub, 10);\n-        }\n+        MemorySegment stub = getStub();\n+        VarHandle vh = JAVA_INT.varHandle(int.class);\n+        vh.set(stub, 10);\n+        stub.scope().close();\n@@ -74,2 +76,2 @@\n-        stub.close();\n-        assertFalse(stub.isAlive());\n+        stub.scope().close();\n+        assertFalse(stub.scope().isAlive());\n@@ -81,2 +83,3 @@\n-        stub.close();\n-        stub.close(); \/\/ should fail\n+        stub.scope().close();\n+        \/\/ should fail\n+        stub.scope().close();\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStubs.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -70,3 +71,4 @@\n-        try (MemorySegment writeBack = MemorySegment.allocateNative(args.size() * WRITEBACK_BYTES_PER_ARG);\n-            MemorySegment callInfo = MemorySegment.allocateNative(ML_CallInfo);\n-            MemorySegment argIDs = MemorySegment.allocateNative(MemoryLayout.ofSequence(args.size(), C_INT))) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment writeBack = MemorySegment.allocateNative(args.size() * WRITEBACK_BYTES_PER_ARG, WRITEBACK_BYTES_PER_ARG, scope);\n+            MemorySegment callInfo = MemorySegment.allocateNative(ML_CallInfo, scope);\n+            MemorySegment argIDs = MemorySegment.allocateNative(MemoryLayout.ofSequence(args.size(), C_INT), scope);\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -111,1 +112,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(inner_size * outer_size * 8)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(inner_size * outer_size * 8, 4, scope);\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -89,1 +90,2 @@\n-        try (MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid())) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @library ..\/\n@@ -50,3 +51,0 @@\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.util.Arrays;\n@@ -70,1 +68,1 @@\n-public class VaListTest {\n+public class VaListTest extends NativeTestHelper {\n@@ -112,1 +110,1 @@\n-            = actions -> Windowsx64Linker.newVaList(actions, MemorySegment::allocateNative);\n+            = actions -> Windowsx64Linker.newVaList(actions, ResourceScope.ofConfined());\n@@ -114,1 +112,1 @@\n-            = actions -> SysVx64Linker.newVaList(actions, MemorySegment::allocateNative);\n+            = actions -> SysVx64Linker.newVaList(actions, ResourceScope.ofConfined());\n@@ -116,1 +114,1 @@\n-            = actions -> AArch64Linker.newVaList(actions, MemorySegment::allocateNative);\n+            = actions -> AArch64Linker.newVaList(actions, ResourceScope.ofConfined());\n@@ -118,1 +116,1 @@\n-            = VaList::make;\n+            = (builder) -> VaList.make(builder, ResourceScope.ofConfined());\n@@ -121,1 +119,1 @@\n-            = (actions, scope) -> Windowsx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));\n+            = (builder, scope) -> Windowsx64Linker.newVaList(builder, scope.scope());\n@@ -123,1 +121,1 @@\n-            = (actions, scope) -> SysVx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));\n+            = (builder, scope) -> SysVx64Linker.newVaList(builder, scope.scope());\n@@ -125,1 +123,1 @@\n-            = (actions, scope) -> AArch64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));\n+            = (builder, scope) -> AArch64Linker.newVaList(builder, scope.scope());\n@@ -127,1 +125,1 @@\n-            = VaList::make;\n+            = (builder, scope) -> VaList.make(builder, scope.scope());\n@@ -148,7 +146,7 @@\n-        try (VaList vaList = vaListFactory.apply(b ->\n-                b.vargFromInt(intLayout, 10)\n-                        .vargFromInt(intLayout, 15)\n-                        .vargFromInt(intLayout, 20))) {\n-            int x = sumInts.apply(3, vaList);\n-            assertEquals(x, 45);\n-        }\n+        VaList vaList = vaListFactory.apply(b ->\n+            b.vargFromInt(intLayout, 10)\n+                    .vargFromInt(intLayout, 15)\n+                    .vargFromInt(intLayout, 20));\n+        int x = sumInts.apply(3, vaList);\n+        assertEquals(x, 45);\n+        vaList.scope().close();\n@@ -176,7 +174,7 @@\n-        try (VaList vaList = vaListFactory.apply(b ->\n-                b.vargFromDouble(doubleLayout, 3.0D)\n-                        .vargFromDouble(doubleLayout, 4.0D)\n-                        .vargFromDouble(doubleLayout, 5.0D))) {\n-            double x = sumDoubles.apply(3, vaList);\n-            assertEquals(x, 12.0D);\n-        }\n+        VaList vaList = vaListFactory.apply(b ->\n+            b.vargFromDouble(doubleLayout, 3.0D)\n+                    .vargFromDouble(doubleLayout, 4.0D)\n+                    .vargFromDouble(doubleLayout, 5.0D));\n+        double x = sumDoubles.apply(3, vaList);\n+        assertEquals(x, 12.0D);\n+        vaList.scope().close();\n@@ -206,1 +204,2 @@\n-        try (MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT, scope);\n@@ -208,4 +207,4 @@\n-            try (VaList vaList = vaListFactory.apply(b -> b.vargFromAddress(pointerLayout, msInt.address()))) {\n-                int x = getFromPointer.apply(vaList);\n-                assertEquals(x, 10);\n-            }\n+            VaList vaList = vaListFactory.apply(b -> b.vargFromAddress(pointerLayout, msInt.address()));\n+            int x = getFromPointer.apply(vaList);\n+            assertEquals(x, 10);\n+            vaList.scope().close();\n@@ -259,1 +258,2 @@\n-        try (MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, scope);\n@@ -263,4 +263,4 @@\n-            try (VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(Point_LAYOUT, struct))) {\n-                int sum = sumStruct.apply(vaList);\n-                assertEquals(sum, 15);\n-            }\n+            VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(Point_LAYOUT, struct));\n+            int sum = sumStruct.apply(vaList);\n+            assertEquals(sum, 15);\n+            vaList.scope().close();\n@@ -310,1 +310,2 @@\n-        try (MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, scope);\n@@ -314,4 +315,4 @@\n-            try (VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(BigPoint_LAYOUT, struct))) {\n-                long sum = sumBigStruct.apply(vaList);\n-                assertEquals(sum, 15);\n-            }\n+            VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(BigPoint_LAYOUT, struct));\n+            long sum = sumBigStruct.apply(vaList);\n+            assertEquals(sum, 15);\n+            vaList.scope().close();\n@@ -362,1 +363,2 @@\n-        try (MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, scope);\n@@ -366,4 +368,4 @@\n-            try (VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(FloatPoint_LAYOUT, struct))) {\n-                float sum = sumFloatStruct.apply(vaList);\n-                assertEquals(sum, 4.376f, 0.00001f);\n-            }\n+            VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(FloatPoint_LAYOUT, struct));\n+            float sum = sumFloatStruct.apply(vaList);\n+            assertEquals(sum, 4.376f, 0.00001f);\n+            vaList.scope().close();\n@@ -424,1 +426,2 @@\n-        try (MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, scope);\n@@ -429,4 +432,4 @@\n-            try (VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(HugePoint_LAYOUT, struct))) {\n-                long sum = sumHugeStruct.apply(vaList);\n-                assertEquals(sum, 6);\n-            }\n+            VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(HugePoint_LAYOUT, struct));\n+            long sum = sumHugeStruct.apply(vaList);\n+            assertEquals(sum, 6);\n+            vaList.scope().close();\n@@ -475,2 +478,3 @@\n-        try (MemorySegment longSum = MemorySegment.allocateNative(longLayout);\n-             MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment longSum = MemorySegment.allocateNative(longLayout, scope);\n+            MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout, scope);\n@@ -489,1 +493,1 @@\n-            try (list) {\n+            try {\n@@ -491,0 +495,2 @@\n+            } finally {\n+                list.scope().close();\n@@ -504,1 +510,2 @@\n-        try (MemorySegment stub = abi.upcallStub(callback, desc)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment stub = abi.upcallStub(callback, desc, scope);\n@@ -522,1 +529,1 @@\n-            expectedExceptionsMessageRegExp = \".*Empty VaList.*\",\n+            expectedExceptionsMessageRegExp = \".*Scope cannot be closed.*\",\n@@ -525,1 +532,1 @@\n-        emptyList.close();\n+        emptyList.scope().close();\n@@ -548,1 +555,1 @@\n-        try (NativeScope scope = NativeScope.unboundedScope()) {\n+        try (NativeScope scope = new NativeScope()) {\n@@ -556,1 +563,1 @@\n-        assertFalse(listLeaked.isAlive());\n+        assertFalse(listLeaked.scope().isAlive());\n@@ -564,2 +571,3 @@\n-        try (NativeScope scope = NativeScope.unboundedScope()) {\n-            try (MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT)) {\n+        try (NativeScope scope = new NativeScope()) {\n+            try (ResourceScope innerScope = ResourceScope.ofConfined()) {\n+                MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT, innerScope);\n@@ -568,6 +576,6 @@\n-                try (VaList list = vaListFactory.apply(b -> b.vargFromSegment(Point_LAYOUT, pointIn))) {\n-                    pointOut = list.vargAsSegment(Point_LAYOUT, scope);\n-                    assertEquals((int) VH_Point_x.get(pointOut), 3);\n-                    assertEquals((int) VH_Point_y.get(pointOut), 6);\n-                }\n-                assertTrue(pointOut.isAlive()); \/\/ after VaList freed\n+                VaList list = vaListFactory.apply(b -> b.vargFromSegment(Point_LAYOUT, pointIn));\n+                pointOut = list.vargAsSegment(Point_LAYOUT, scope);\n+                assertEquals((int) VH_Point_x.get(pointOut), 3);\n+                assertEquals((int) VH_Point_y.get(pointOut), 6);\n+                list.scope().close();\n+                assertTrue(pointOut.scope().isAlive()); \/\/ after VaList freed\n@@ -575,1 +583,1 @@\n-            assertTrue(pointOut.isAlive()); \/\/ after input MS freed\n+            assertTrue(pointOut.scope().isAlive()); \/\/ after inner scope freed\n@@ -577,1 +585,1 @@\n-        assertFalse(pointOut.isAlive()); \/\/ after scope freed\n+        assertFalse(pointOut.scope().isAlive()); \/\/ after outer scope freed\n@@ -591,13 +599,5 @@\n-        try (VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)\n-                .vargFromInt(intLayout, 8))) {\n-            VaList  copy = list.copy();\n-            assertEquals(copy.vargAsInt(intLayout), 4);\n-            assertEquals(copy.vargAsInt(intLayout), 8);\n-            copy.close();\n-\n-            assertFalse(copy.isAlive());\n-\n-            assertEquals(list.vargAsInt(intLayout), 4);\n-            assertEquals(list.vargAsInt(intLayout), 8);\n-        }\n-    }\n+        VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)\n+                .vargFromInt(intLayout, 8));\n+        VaList  copy = list.copy();\n+        assertEquals(copy.vargAsInt(intLayout), 4);\n+        assertEquals(copy.vargAsInt(intLayout), 8);\n@@ -605,12 +605,6 @@\n-    @Test(dataProvider = \"copy\")\n-    public void testScopedCopy(Function<Consumer<VaList.Builder>, VaList> vaListFactory, ValueLayout intLayout) {\n-        try (VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)\n-                .vargFromInt(intLayout, 8))) {\n-            VaList copy;\n-            try (NativeScope scope = NativeScope.unboundedScope()) {\n-                copy = list.copy(scope);\n-\n-                assertEquals(copy.vargAsInt(intLayout), 4);\n-                assertEquals(copy.vargAsInt(intLayout), 8);\n-            }\n-            assertFalse(copy.isAlive());\n+\/\/        try { \/\/ this logic only works on Windows!\n+\/\/            int x = copy.vargAsInt(intLayout);\n+\/\/            fail();\n+\/\/        } catch (IndexOutOfBoundsException ex) {\n+\/\/            \/\/ ok - we exhausted the list\n+\/\/        }\n@@ -618,3 +612,3 @@\n-            assertEquals(list.vargAsInt(intLayout), 4);\n-            assertEquals(list.vargAsInt(intLayout), 8);\n-        }\n+        assertEquals(list.vargAsInt(intLayout), 4);\n+        assertEquals(list.vargAsInt(intLayout), 8);\n+        list.scope().close();\n@@ -629,2 +623,2 @@\n-        try (VaList copy = list.copy()) {\n-            list.close();\n+        VaList copy = list.copy();\n+        list.scope().close();\n@@ -632,16 +626,1 @@\n-            copy.vargAsInt(intLayout); \/\/ should throw\n-        }\n-    }\n-\n-    @Test(dataProvider = \"copy\",\n-            expectedExceptions = IllegalStateException.class)\n-    public void testCopyUnusableAfterOriginalClosedScope(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n-                                                         ValueLayout intLayout) {\n-        VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)\n-                .vargFromInt(intLayout, 8));\n-        try (NativeScope scope = NativeScope.unboundedScope()) {\n-            VaList copy = list.copy(scope);\n-            list.close();\n-\n-            copy.vargAsInt(intLayout); \/\/ should throw\n-        }\n+        copy.vargAsInt(intLayout); \/\/ should throw\n@@ -681,4 +660,3 @@\n-                    try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {\n-                        assertEquals((long) VH_BigPoint_x.get(struct), 8);\n-                        assertEquals((long) VH_BigPoint_y.get(struct), 16);\n-                    }\n+                    MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT);\n+                    assertEquals((long) VH_BigPoint_x.get(struct), 8);\n+                    assertEquals((long) VH_BigPoint_y.get(struct), 16);\n@@ -688,3 +666,3 @@\n-                    try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {\n-                        assertEquals((long) VH_BigPoint_x.get(struct), 8);\n-                        assertEquals((long) VH_BigPoint_y.get(struct), 16);\n+                    MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT);\n+                    assertEquals((long) VH_BigPoint_x.get(struct), 8);\n+                    assertEquals((long) VH_BigPoint_y.get(struct), 16);\n@@ -692,3 +670,2 @@\n-                        VH_BigPoint_x.set(struct, 0);\n-                        VH_BigPoint_y.set(struct, 0);\n-                    }\n+                    VH_BigPoint_x.set(struct, 0);\n+                    VH_BigPoint_y.set(struct, 0);\n@@ -697,4 +674,3 @@\n-                    try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {\n-                        assertEquals((long) VH_BigPoint_x.get(struct), 8);\n-                        assertEquals((long) VH_BigPoint_y.get(struct), 16);\n-                    }\n+                    struct = copy.vargAsSegment(BigPoint_LAYOUT);\n+                    assertEquals((long) VH_BigPoint_x.get(struct), 8);\n+                    assertEquals((long) VH_BigPoint_y.get(struct), 16);\n@@ -703,4 +679,3 @@\n-                    try (MemorySegment struct = vaList.vargAsSegment(Point_LAYOUT)) {\n-                        assertEquals((int) VH_Point_x.get(struct), 5);\n-                        assertEquals((int) VH_Point_y.get(struct), 10);\n-                    }\n+                    MemorySegment struct = vaList.vargAsSegment(Point_LAYOUT);\n+                    assertEquals((int) VH_Point_x.get(struct), 5);\n+                    assertEquals((int) VH_Point_y.get(struct), 10);\n@@ -709,5 +684,4 @@\n-                    try (MemorySegment struct = vaList.vargAsSegment(HugePoint_LAYOUT)) {\n-                        assertEquals((long) VH_HugePoint_x.get(struct), 1);\n-                        assertEquals((long) VH_HugePoint_y.get(struct), 2);\n-                        assertEquals((long) VH_HugePoint_z.get(struct), 3);\n-                    }\n+                    MemorySegment struct = vaList.vargAsSegment(HugePoint_LAYOUT);\n+                    assertEquals((long) VH_HugePoint_x.get(struct), 1);\n+                    assertEquals((long) VH_HugePoint_y.get(struct), 2);\n+                    assertEquals((long) VH_HugePoint_z.get(struct), 3);\n@@ -716,4 +690,3 @@\n-                    try (MemorySegment struct = vaList.vargAsSegment(FloatPoint_LAYOUT)) {\n-                        assertEquals((float) VH_FloatPoint_x.get(struct), 1.0f);\n-                        assertEquals((float) VH_FloatPoint_y.get(struct), 2.0f);\n-                    }\n+                    MemorySegment struct = vaList.vargAsSegment(FloatPoint_LAYOUT);\n+                    assertEquals((float) VH_FloatPoint_x.get(struct), 1.0f);\n+                    assertEquals((float) VH_FloatPoint_y.get(struct), 2.0f);\n@@ -762,4 +735,3 @@\n-                    try (MemorySegment point = vaList.vargAsSegment(Point_LAYOUT)) {\n-                        assertEquals((int) VH_Point_x.get(point), 5);\n-                        assertEquals((int) VH_Point_y.get(point), 10);\n-                    }\n+                    MemorySegment point = vaList.vargAsSegment(Point_LAYOUT);\n+                    assertEquals((int) VH_Point_x.get(point), 5);\n+                    assertEquals((int) VH_Point_y.get(point), 10);\n@@ -768,3 +740,3 @@\n-                    try (MemorySegment bigPoint = vaList.vargAsSegment(BigPoint_LAYOUT)) {\n-                        assertEquals((long) VH_BigPoint_x.get(bigPoint), 15);\n-                        assertEquals((long) VH_BigPoint_y.get(bigPoint), 20);\n+                    MemorySegment bigPoint = vaList.vargAsSegment(BigPoint_LAYOUT);\n+                    assertEquals((long) VH_BigPoint_x.get(bigPoint), 15);\n+                    assertEquals((long) VH_BigPoint_y.get(bigPoint), 20);\n@@ -772,3 +744,2 @@\n-                        VH_BigPoint_x.set(bigPoint, 0);\n-                        VH_BigPoint_y.set(bigPoint, 0);\n-                    }\n+                    VH_BigPoint_x.set(bigPoint, 0);\n+                    VH_BigPoint_y.set(bigPoint, 0);\n@@ -777,4 +748,3 @@\n-                    try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {\n-                        assertEquals((long) VH_BigPoint_x.get(struct), 15);\n-                        assertEquals((long) VH_BigPoint_y.get(struct), 20);\n-                    }\n+                    MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT);\n+                    assertEquals((long) VH_BigPoint_x.get(struct), 15);\n+                    assertEquals((long) VH_BigPoint_y.get(struct), 20);\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":126,"deletions":156,"binary":false,"changes":282,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -58,1 +59,1 @@\n-    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE);\n+    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.ofConfined());\n@@ -66,2 +67,2 @@\n-    static final MemorySegment mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL);\n-    static final MemorySegment mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL);\n+    static final MemorySegment mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, ResourceScope.ofConfined());\n+    static final MemorySegment mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, ResourceScope.ofConfined());\n@@ -72,2 +73,2 @@\n-    static final MemorySegment mismatchSegmentSmall1 = MemorySegment.allocateNative(7);\n-    static final MemorySegment mismatchSegmentSmall2 = MemorySegment.allocateNative(7);\n+    static final MemorySegment mismatchSegmentSmall1 = MemorySegment.allocateNative(7, ResourceScope.ofConfined());\n+    static final MemorySegment mismatchSegmentSmall2 = MemorySegment.allocateNative(7, ResourceScope.ofConfined());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/BulkOps.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-        return (MemorySegment) identity_struct.invokeExact(point);\n+        return (MemorySegment) identity_struct.invokeExact(recycling_allocator, point);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadConstant.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -87,0 +88,2 @@\n+    static final SegmentAllocator recycling_allocator = SegmentAllocator.of(MemorySegment.allocateNative(POINT_LAYOUT));\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadHelper.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-        return (MemorySegment) identity_struct_v.invokeExact(identity_struct_addr, point);\n+        return (MemorySegment) identity_struct_v.invokeExact(identity_struct_addr, recycling_allocator, point);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadVirtual.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.incubator.foreign.SegmentAllocator;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -60,0 +62,1 @@\n+    static final MemoryLayout ALLOC_LAYOUT = MemoryLayout.ofSequence(ELEM_SIZE, JAVA_INT);\n@@ -63,0 +66,8 @@\n+    final ResourceScope scope = ResourceScope.ofConfined();\n+    final SegmentAllocator recyclingAlloc = SegmentAllocator.of(MemorySegment.allocateNative(ALLOC_LAYOUT, scope));\n+\n+    @TearDown\n+    public void tearDown() throws Throwable {\n+        scope.close();\n+    }\n+\n@@ -73,4 +84,6 @@\n-    public void segment_loop() {\n-        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE);\n-        for (int i = 0; i < ELEM_SIZE; i++) {\n-            VH_int.set(segment, (long) i, i);\n+    public void segment_loop_confined() {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, scope);\n+            for (int i = 0; i < ELEM_SIZE; i++) {\n+                VH_int.set(segment, (long) i, i);\n+            }\n@@ -78,1 +91,0 @@\n-        segment.close();\n@@ -83,1 +95,11 @@\n-        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE).share();\n+        try (ResourceScope scope = ResourceScope.ofShared()) {\n+            MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, scope);\n+            for (int i = 0; i < ELEM_SIZE; i++) {\n+                VH_int.set(segment, (long) i, i);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void segment_loop_recycle() {\n+        MemorySegment segment = recyclingAlloc.allocate(ALLOC_SIZE, 4);\n@@ -87,1 +109,0 @@\n-        segment.close();\n@@ -98,0 +119,27 @@\n+\n+    \/\/ hack to even out calls to System::gc, which allows us to compare how the implicit segment deallocation\n+    \/\/ fares compared with ByteBuffer; if there's no call to System.gc() we end up comparing how well the two\n+    \/\/ act under significant native memory pressure, and here the ByteBuffer API has more juice, since it features\n+    \/\/ a complex exponential back off with multiple GC retries (see ByteBuffer::allocateDirect). Of course, we\n+    \/\/ don't care about those cases with segments, as if clients need to allocate\/free very frequently\n+    \/\/ they should just use deterministic deallocation (with confined scope) instead, which delivers much\n+    \/\/ better performances anyway.\n+    static byte gcCount = 0;\n+\n+    @Benchmark\n+    public void buffer_loop_implicit() {\n+        if (gcCount++ == 0) System.gc(); \/\/ GC when we overflow\n+        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(ALLOC_SIZE).order(ByteOrder.nativeOrder());\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            byteBuffer.putInt(i * CARRIER_SIZE , i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void segment_loop_implicit() {\n+        if (gcCount++ == 0) System.gc(); \/\/ GC when we overflow\n+        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            VH_int.set(segment, (long) i, i);\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNew.java","additions":55,"deletions":7,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -29,0 +28,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -75,1 +75,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE);\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.ofConfined());\n@@ -87,1 +87,1 @@\n-        segment.close();\n+        segment.scope().close();\n@@ -150,1 +150,1 @@\n-        MemorySegment base = segment.withAccessModes(MemorySegment.READ);\n+        MemorySegment base = segment.asReadOnly();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstant.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n@@ -29,0 +27,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -41,1 +40,0 @@\n-import java.lang.invoke.VarHandle;\n@@ -77,2 +75,2 @@\n-        segmentIn = MemorySegment.allocateNative(ALLOC_SIZE);\n-        segmentOut = MemorySegment.allocateNative(ALLOC_SIZE);\n+        segmentIn = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.ofConfined());\n+        segmentOut = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.ofConfined());\n@@ -97,2 +95,2 @@\n-        segmentIn.close();\n-        segmentOut.close();\n+        segmentIn.scope().close();\n+        segmentOut.scope().close();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantFP.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -29,0 +28,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -43,0 +43,1 @@\n+import java.lang.ref.Cleaner;\n@@ -81,8 +82,7 @@\n-            try (MemorySegment s = MemorySegment.allocateNative(ALLOC_SIZE)) {\n-                for (int i = 0; i < ALLOC_SIZE; i++) {\n-                    MemoryAccess.setByteAtOffset(intB, i, (byte)i);\n-                    MemoryAccess.setIntAtIndex(intI, i, i);\n-                    MemoryAccess.setDoubleAtIndex(intD, i, i);\n-                    MemoryAccess.setFloatAtIndex(intF, i, i);\n-                    MemoryAccess.setByteAtOffset(s, i, (byte) i);\n-                }\n+            MemorySegment s = MemorySegment.allocateNative(ALLOC_SIZE, 1, ResourceScope.ofConfined(Cleaner.create()));\n+            for (int i = 0; i < ALLOC_SIZE; i++) {\n+                MemoryAccess.setByteAtOffset(intB, i, (byte)i);\n+                MemoryAccess.setIntAtIndex(intI, i, i);\n+                MemoryAccess.setDoubleAtIndex(intD, i, i);\n+                MemoryAccess.setFloatAtIndex(intF, i, i);\n+                MemoryAccess.setByteAtOffset(s, i, (byte) i);\n@@ -102,1 +102,1 @@\n-        segment.close();\n+        segment.scope().close();\n@@ -163,1 +163,1 @@\n-        MemorySegment base = segment.withAccessModes(MemorySegment.READ);\n+        MemorySegment base = segment.asReadOnly();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantHeap.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -98,1 +99,1 @@\n-        segment = MemorySegment.mapFile(tempPath, 0L, ALLOC_SIZE, FileChannel.MapMode.READ_WRITE);\n+        segment = MemorySegment.mapFile(tempPath, 0L, ALLOC_SIZE, FileChannel.MapMode.READ_WRITE, ResourceScope.ofConfined());\n@@ -104,1 +105,1 @@\n-        segment.close();\n+        segment.scope().close();\n@@ -166,1 +167,1 @@\n-        MemorySegment base = segment.withAccessModes(MemorySegment.READ);\n+        MemorySegment base = segment.asReadOnly();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantMapped.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -74,1 +75,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE).share();\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, ResourceScope.ofShared());\n@@ -86,1 +87,1 @@\n-        segment.close();\n+        segment.scope().close();\n@@ -149,1 +150,1 @@\n-        MemorySegment base = segment.withAccessModes(MemorySegment.READ);\n+        MemorySegment base = segment.asReadOnly();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantShared.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -74,1 +75,1 @@\n-        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4);\n+        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.ofConfined());\n@@ -96,1 +97,1 @@\n-        nativeSegment.close();\n+        nativeSegment.scope().close();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverPollutedSegments.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -41,1 +42,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -47,1 +47,0 @@\n-import java.util.OptionalInt;\n@@ -52,1 +51,0 @@\n-import java.util.function.IntFunction;\n@@ -88,1 +86,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE).share();\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, ResourceScope.ofShared());\n@@ -97,1 +95,1 @@\n-        segment.close();\n+        segment.scope().close();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/ParallelSum.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-import jdk.incubator.foreign.NativeScope;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -61,1 +62,4 @@\n-    NativeScope scope = NativeScope.unboundedScope();\n+    ResourceScope scope = ResourceScope.ofConfined();\n+\n+    SegmentAllocator segmentAllocator;\n+    SegmentAllocator arenaAllocator = SegmentAllocator.arenaUnbounded(scope);\n@@ -97,0 +101,1 @@\n+        segmentAllocator = SegmentAllocator.of(MemorySegment.allocateNative(size + 1));\n@@ -111,1 +116,2 @@\n-        try (MemorySegment segment = CLinker.toCString(str)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = CLinker.toCString(str, SegmentAllocator.of(scope));\n@@ -118,1 +124,6 @@\n-        return (int)STRLEN.invokeExact(CLinker.toCString(str, scope).address());\n+        return (int)STRLEN.invokeExact(CLinker.toCString(str, arenaAllocator).address());\n+    }\n+\n+    @Benchmark\n+    public int panama_strlen_recycle() throws Throwable {\n+        return (int)STRLEN.invokeExact(CLinker.toCString(str, segmentAllocator).address());\n@@ -141,1 +152,1 @@\n-        MemorySegment str = address.asSegmentRestricted(len + 1);\n+        MemorySegment str = address.asSegmentRestricted(len + 1, ResourceScope.globalScope());\n@@ -151,1 +162,1 @@\n-        MemorySegment str = address.asSegmentRestricted(len + 1);\n+        MemorySegment str = address.asSegmentRestricted(len + 1, ResourceScope.globalScope());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -78,5 +79,5 @@\n-        try (CLinker.VaList vaList = CLinker.VaList.make(b ->\n-            b.vargFromInt(C_INT, 1)\n-             .vargFromDouble(C_DOUBLE, 2D)\n-             .vargFromLong(C_LONG_LONG, 3L)\n-        )) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            CLinker.VaList vaList = CLinker.VaList.make(b ->\n+                    b.vargFromInt(C_INT, 1)\n+                            .vargFromDouble(C_DOUBLE, 2D)\n+                            .vargFromLong(C_LONG_LONG, 3L), scope);\n@@ -84,1 +85,1 @@\n-                                  vaList);\n+                    vaList);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/VaList.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -64,1 +65,1 @@\n-        data = MemorySegment.allocateNative(JAVA_INT);\n+        data = MemorySegment.allocateNative(JAVA_INT, ResourceScope.ofConfined());\n@@ -69,1 +70,1 @@\n-        data.close();\n+        data.scope().close();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/VarHandleExact.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,6 +24,2 @@\n-\n-void func() {}\n-\n-int identity(int x) {\n-  return x;\n-}\n+#include <stdlib.h>\n+#include \"libCallOverhead.c\"\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libCallOverheadJNI.c","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -69,1 +70,1 @@\n-        this(MemorySegment.allocateNative(LAYOUT), x, y);\n+        this(MemorySegment.allocateNative(LAYOUT, ResourceScope.ofConfined()), x, y);\n@@ -116,1 +117,1 @@\n-        segment.close();\n+        segment.scope().close();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/support\/PanamaPoint.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}