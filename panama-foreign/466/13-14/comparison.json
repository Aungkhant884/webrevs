{"files":[{"patch":"@@ -33,1 +33,0 @@\n-import jdk.internal.ref.CleanerFactory;\n@@ -42,1 +41,0 @@\n-import java.util.stream.Stream;\n@@ -326,1 +324,1 @@\n-     * @param scope the scope to be used for the native segment allocation.\n+     * @param allocator the scope to be used for the native segment allocation.\n@@ -329,1 +327,1 @@\n-    static MemorySegment toCString(String str, SegmentAllocator scope) {\n+    static MemorySegment toCString(String str, SegmentAllocator allocator) {\n@@ -331,2 +329,19 @@\n-        Objects.requireNonNull(scope);\n-        return toCString(str.getBytes(), scope);\n+        Objects.requireNonNull(allocator);\n+        return toCString(str.getBytes(), allocator);\n+    }\n+\n+    \/**\n+     * Converts a Java string into a null-terminated C string, using the platform's default charset,\n+     * storing the result into a native memory segment associated with the provided resource scope.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement byte array.  The\n+     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n+     * control over the encoding process is required.\n+     *\n+     * @param str the Java string to be converted into a C string.\n+     * @param scope the resource scope to be associated with the returned segment.\n+     * @return a new native memory segment containing the converted C string.\n+     *\/\n+    static MemorySegment toCString(String str, ResourceScope scope) {\n+        return toCString(str, SegmentAllocator.scoped(scope));\n@@ -346,1 +361,1 @@\n-     * @param scope the scope to be used for the native segment allocation.\n+     * @param allocator the scope to be used for the native segment allocation.\n@@ -349,1 +364,1 @@\n-    static MemorySegment toCString(String str, Charset charset, SegmentAllocator scope) {\n+    static MemorySegment toCString(String str, Charset charset, SegmentAllocator allocator) {\n@@ -352,2 +367,20 @@\n-        Objects.requireNonNull(scope);\n-        return toCString(str.getBytes(charset), scope);\n+        Objects.requireNonNull(allocator);\n+        return toCString(str.getBytes(charset), allocator);\n+    }\n+\n+    \/**\n+     * Converts a Java string into a null-terminated C string, using the given {@link java.nio.charset.Charset charset},\n+     * storing the result into a new native memory segment native memory segment associated with the provided resource scope.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement byte array.  The\n+     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n+     * control over the encoding process is required.\n+     *\n+     * @param str the Java string to be converted into a C string.\n+     * @param charset The {@link java.nio.charset.Charset} to be used to compute the contents of the C string.\n+     * @param scope the resource scope to be associated with the returned segment.\n+     * @return a new native memory segment containing the converted C string.\n+     *\/\n+    static MemorySegment toCString(String str, Charset charset, ResourceScope scope) {\n+        return toCString(str, charset, SegmentAllocator.scoped(scope));\n@@ -450,2 +483,2 @@\n-    private static MemorySegment toCString(byte[] bytes, SegmentAllocator scope) {\n-        MemorySegment addr = scope.allocate(bytes.length + 1, 1L);\n+    private static MemorySegment toCString(byte[] bytes, SegmentAllocator allocator) {\n+        MemorySegment addr = allocator.allocate(bytes.length + 1, 1L);\n@@ -576,1 +609,15 @@\n-         * The memory segment returned by this method will be allocated using the given {@code NativeAllocator}.\n+         * The memory segment returned by this method will be allocated using the given {@link SegmentAllocator}.\n+         *\n+         * @param layout the layout of the value\n+         * @param allocator the scope to be used for the native segment allocation\n+         * @return the value read as an {@code MemorySegment}\n+         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n+         * (see {@link #scope()}).\n+         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}\n+         *\/\n+        MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator);\n+\n+        \/**\n+         * Reads the next value as a {@code MemorySegment}, and advances this va list's position.\n+         * <p>\n+         * The memory segment returned by this method will be associated with the given {@link ResourceScope}.\n@@ -579,1 +626,1 @@\n-         * @param scope the scope to allocate the segment in\n+         * @param scope the resource scope to be associated with the returned segment\n@@ -585,1 +632,1 @@\n-        MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator scope);\n+        MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope);\n@@ -665,1 +712,1 @@\n-         * non-closeable resource scope (see {@link ResourceScope}).\n+         * non-closeable {@link ResourceScope resource scope}.\n@@ -667,3 +714,3 @@\n-         * If this method needs to allocate native memory for the va list, it will use\n-         * {@link MemorySegment#allocateNative(long, long, ResourceScope)} to do so, where the resource scope\n-         * used for the allocation is the valist scope itself (see {@link VaList#scope()}).\n+         * If this method needs to allocate native memory, such memory will be managed by the same scope which also\n+         * manages the returned valist instance; as such, this memory will be released only when the returned\n+         * valist instance becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n@@ -684,4 +731,2 @@\n-         * Constructs a new {@code VaList} using a builder (see {@link Builder}).\n-         * <p>\n-         * If this method needs to allocate native memory for the va list, it will use\n-         * the given {@code NativeAllocator} to do so.\n+         * Constructs a new {@code VaList} using a builder (see {@link Builder}), associated with a given\n+         * {@link ResourceScope resource scope}.\n@@ -689,2 +734,2 @@\n-         * This method will allocate native memory to hold the elements in the va list. This memory\n-         * will be managed by the given {@code NativeAllocator}, and will be released when the scope is closed.\n+         * If this method needs to allocate native memory, such memory will be managed by the given\n+         * {@link ResourceScope resource scope}, and will be released when the resource scope is {@link ResourceScope#close closed}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":70,"deletions":25,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.MemoryScope;\n@@ -50,1 +51,1 @@\n- * This interface provides a factory, namely {@link SegmentAllocator#of(ResourceScope)} which can be used to obtain\n+ * This interface provides a factory, namely {@link SegmentAllocator#scoped(ResourceScope)} which can be used to obtain\n@@ -63,1 +64,1 @@\n- * and {@link #arenaBounded(long, ResourceScope)} are arena-style native allocators. Finally {@link #of(MemorySegment)}\n+ * and {@link #arenaBounded(long, ResourceScope)} are arena-style native allocators. Finally {@link #prefix(MemorySegment)}\n@@ -438,1 +439,1 @@\n-    static SegmentAllocator of(MemorySegment segment) {\n+    static SegmentAllocator prefix(MemorySegment segment) {\n@@ -451,1 +452,1 @@\n-    static SegmentAllocator of(ResourceScope scope) {\n+    static SegmentAllocator scoped(ResourceScope scope) {\n@@ -453,1 +454,1 @@\n-        return (size, align) -> MemorySegment.allocateNative(size, align, scope);\n+        return ((MemoryScope)scope).allocator();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -30,0 +31,1 @@\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -32,0 +34,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -54,0 +57,3 @@\n+    protected final Object ref;\n+    @Stable\n+    SegmentAllocator allocator;\n@@ -124,2 +130,0 @@\n-    protected final Object ref;\n-\n@@ -184,0 +188,11 @@\n+    \/**\n+     * Return a scoped allocator; the instance returned by this method is lazily created and then shared\n+     * upon subsequent requests.\n+     *\/\n+    public SegmentAllocator allocator() {\n+        if (allocator == null) {\n+            allocator = (size, align) -> MemorySegment.allocateNative(size, align, this);\n+        }\n+        return allocator;\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryScope.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -552,1 +552,6 @@\n-        public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator scope) {\n+        public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n+            throw uoe();\n+        }\n+\n+        @Override\n+        public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.foreign.MemoryScope;\n@@ -243,0 +242,5 @@\n+    @Override\n+    public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n+        return vargAsSegment(layout, SegmentAllocator.scoped(scope));\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64VaList.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.foreign.MemoryScope;\n@@ -221,0 +220,5 @@\n+    @Override\n+    public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n+        return vargAsSegment(layout, SegmentAllocator.scoped(scope));\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -108,0 +108,5 @@\n+    @Override\n+    public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n+        return vargAsSegment(layout, SegmentAllocator.scoped(scope));\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import java.util.function.Consumer;\n@@ -59,1 +58,1 @@\n-public class StdLibTest extends NativeTestHelper {\n+public class StdLibTest {\n@@ -211,2 +210,2 @@\n-            try (NativeScope scope = new NativeScope()) {\n-                MemorySegment buf = scope.allocate(s1.length() + s2.length() + 1);\n+            try (ResourceScope scope = ResourceScope.ofConfined()) {\n+                MemorySegment buf = MemorySegment.allocateNative(s1.length() + s2.length() + 1, scope);\n@@ -224,1 +223,1 @@\n-            try (NativeScope scope = new NativeScope()) {\n+            try (ResourceScope scope = ResourceScope.ofConfined()) {\n@@ -232,1 +231,1 @@\n-            try (NativeScope scope = new NativeScope()) {\n+            try (ResourceScope scope = ResourceScope.ofConfined()) {\n@@ -239,1 +238,1 @@\n-            try (NativeScope scope = new NativeScope()) {\n+            try (ResourceScope scope = ResourceScope.ofConfined()) {\n@@ -246,2 +245,2 @@\n-            try (NativeScope scope = new NativeScope()) {\n-                MemorySegment time = scope.allocate(8);\n+            try (ResourceScope scope = ResourceScope.ofConfined()) {\n+                MemorySegment time = MemorySegment.allocateNative(8, scope);\n@@ -296,3 +295,3 @@\n-            try (NativeScope scope = new NativeScope()) {\n-\n-                MemorySegment nativeArr = scope.allocateArray(C_INT, arr);\n+            try (ResourceScope scope = ResourceScope.ofConfined()) {\n+                SegmentAllocator allocator = SegmentAllocator.scoped(scope);\n+                MemorySegment nativeArr = allocator.allocateArray(C_INT, arr);\n@@ -301,1 +300,1 @@\n-                MemorySegment qsortUpcallStub = abi.upcallStub(qsortCompar.bindTo(nativeArr), qsortComparFunction, scope.scope());\n+                MemorySegment qsortUpcallStub = abi.upcallStub(qsortCompar.bindTo(nativeArr), qsortComparFunction, scope);\n@@ -320,1 +319,1 @@\n-            try (NativeScope scope = new NativeScope()) {\n+            try (ResourceScope scope = ResourceScope.ofConfined()) {\n@@ -328,1 +327,1 @@\n-            try (NativeScope scope = new NativeScope()) {\n+            try (ResourceScope scope = ResourceScope.ofConfined()) {\n@@ -330,1 +329,1 @@\n-                VaList vaList = VaList.make(b -> args.forEach(a -> a.accept(b, scope)), scope.scope());\n+                VaList vaList = VaList.make(b -> args.forEach(a -> a.accept(b, scope)), scope);\n@@ -402,1 +401,1 @@\n-    enum PrintfArg implements BiConsumer<VaList.Builder, NativeScope> {\n+    enum PrintfArg implements BiConsumer<VaList.Builder, ResourceScope> {\n@@ -412,1 +411,1 @@\n-        final Function<NativeScope, ?> nativeValueFactory;\n+        final Function<ResourceScope, ?> nativeValueFactory;\n@@ -417,1 +416,1 @@\n-        <Z> PrintfArg(Class<?> carrier, ValueLayout layout, String format, Function<NativeScope, Z> nativeValueFactory, Object javaValue, VaListBuilderCall<Z> builderCall) {\n+        <Z> PrintfArg(Class<?> carrier, ValueLayout layout, String format, Function<ResourceScope, Z> nativeValueFactory, Object javaValue, VaListBuilderCall<Z> builderCall) {\n@@ -428,1 +427,1 @@\n-        public void accept(VaList.Builder builder, NativeScope scope) {\n+        public void accept(VaList.Builder builder, ResourceScope scope) {\n@@ -436,1 +435,1 @@\n-        public Object nativeValue(NativeScope scope) {\n+        public Object nativeValue(ResourceScope scope) {\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":20,"deletions":21,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -223,1 +223,1 @@\n-                return SegmentAllocator.of(segment);\n+                return SegmentAllocator.prefix(segment);\n@@ -225,1 +225,1 @@\n-            FROM_SCOPED(SegmentAllocator::of);\n+            FROM_SCOPED(SegmentAllocator::scoped);\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -340,1 +340,1 @@\n-        MemorySegment allocate(SegmentAllocator scope, ValueLayout layout, X value);\n+        MemorySegment allocate(SegmentAllocator allocator, ValueLayout layout, X value);\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-    static final SegmentAllocator recycling_allocator = SegmentAllocator.of(MemorySegment.allocateNative(POINT_LAYOUT));\n+    static final SegmentAllocator recycling_allocator = SegmentAllocator.prefix(MemorySegment.allocateNative(POINT_LAYOUT));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    final SegmentAllocator recyclingAlloc = SegmentAllocator.of(MemorySegment.allocateNative(ALLOC_LAYOUT, scope));\n+    final SegmentAllocator recyclingAlloc = SegmentAllocator.prefix(MemorySegment.allocateNative(ALLOC_LAYOUT, scope));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNew.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-        segmentAllocator = SegmentAllocator.of(MemorySegment.allocateNative(size + 1));\n+        segmentAllocator = SegmentAllocator.prefix(MemorySegment.allocateNative(size + 1));\n@@ -117,1 +117,1 @@\n-            MemorySegment segment = CLinker.toCString(str, SegmentAllocator.of(scope));\n+            MemorySegment segment = CLinker.toCString(str, scope);\n@@ -123,1 +123,1 @@\n-    public int panama_strlen_scope() throws Throwable {\n+    public int panama_strlen_arena() throws Throwable {\n@@ -128,1 +128,1 @@\n-    public int panama_strlen_recycle() throws Throwable {\n+    public int panama_strlen_prefix() throws Throwable {\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}